[
    {
        "title": "N-Queens II",
        "question_content": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return the number of distinct solutions to the&nbsp;n-queens puzzle.\n&nbsp;\nExample 1:\n\nInput: n = 4\nOutput: 2\nExplanation: There are two distinct solutions to the 4-queens puzzle as shown.\n\nExample 2:\n\nInput: n = 1\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 9",
        "solutions": [
            {
                "id": 2111583,
                "title": "cpp-explained-clean",
                "content": "**UPVOTE IF HELPFUL**\\nWe first create a **( n X n )** chess board and assign **0** to every index.\\nWhenever a queen will be placed, index will be made **1**.\\n\\nIn this approach ,\\n\\nWhenever a queen is placed, at first it is checked if it satisfies the conditions given that it is not under attack.\\n\\n**validMove** function.\\nFirst it check there are no other queen in row the queen is filled.\\nAs we are putting queen column wise so no need to check for column.\\nThen there are two diagonals to check for.\\n* **COLUMN_WISE** FILLING = Only left part of the diagonals are checked as positions to the right of the present column are still unfilled.\\n*  **ROW_WISE** FILLING = Only upper part of the diagonals are checked as positions below of the present column are still unfilled.\\n\\nIf conditions satisfied, Queen is placed and we move to next column.\\nIf no queen satisfy the problem, we backtrack and try to change the position of previous queen.\\n\\n**UPVOTE IF HELPFUL**\\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n\\tvector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\\n\\treturn solve(col, diag, anti_diag, 0);\\n}\\n   \\nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\\n\\tint n = size(col), count = 0;\\n    if(row == n) return 1;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){ \\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1); \\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = false; \\n\\t\\t}                                \\n\\treturn count;\\n}\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/4a277b77-14e4-44ff-87eb-e400a3d7d41e_1654392063.0433629.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n\\tvector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\\n\\treturn solve(col, diag, anti_diag, 0);\\n}\\n   \\nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\\n\\tint n = size(col), count = 0;\\n    if(row == n) return 1;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){ \\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1); \\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = false; \\n\\t\\t}                                \\n\\treturn count;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111857,
                "title": "java-c-n-queens-1-2-almost-same-solution",
                "content": "**Rules For N-Queens in a chess Board :-**\\n1. Every Row should Have 1 queen\\n\\n\\n2. Every Column should have 1 quuen\\n3. No 2 queens can attack each other\\n\\n![image](https://assets.leetcode.com/users/images/a69e681e-0067-4c46-8659-f10d126eb181_1654402034.2685366.png)\\n\\n```\\nN-Quuens I\\n```\\n\\n**Problem Statement:** The n-queens is the problem of placing n queens on n \\xD7 n chessboard such that no two queens can attack each other. Given an integer n, return all distinct solutions to the n -queens puzzle. Each solution contains a distinct boards configuration of the queen\\u2019s placement, where \\u2018Q\\u2019 and \\u2018.\\u2019 indicate queen and empty space respectively.\\n\\n**Intuition:** Using the concept of Backtracking, we will place Queen at different positions of the chessboard and find the right arrangement where all the n queens can be placed on the n*n grid.\\n\\n![image](https://assets.leetcode.com/users/images/cad068d6-420e-4588-87cc-ccee4a719323_1654402478.1131492.png)\\n\\n\\n**Approach:**\\n\\n**Ist position:** This is the position where we can see no possible arrangement is found where all queens can be placed since, at the 3rd column, the Queen will be killed at all possible positions of row.\\n\\n![image](https://assets.leetcode.com/users/images/92f73459-712f-4564-a82b-a33364ea38fb_1654401381.1760585.png)\\n\\n**2nd position:** One of the correct possible arrangements is found. So we will store it as our answer.\\n\\n![image](https://assets.leetcode.com/users/images/7c6019f5-930c-4fed-bd6b-0f53440db5a9_1654401405.4075787.png)\\n\\n**3rd position:** One of the correct possible arrangements is found. So we will store it as our answer.\\n\\n![image](https://assets.leetcode.com/users/images/dd4669ff-be65-40df-88dd-ae1a04442ae5_1654401442.4140863.png)\\n\\n**4th position:** This is the position where we can see no possible arrangement is found where all queens can be placed since, at the 4th column, the Queen will be killed at all possible positions of row.\\n\\n![image](https://assets.leetcode.com/users/images/93fc6398-0119-4ba3-82a6-5162845f35fe_1654401463.9854825.png)\\n\\n<iframe src=\"https://leetcode.com/playground/MgCvV5hU/shared\" frameBorder=\"0\" width=\"1400\" height=\"1000\"></iframe>\\n\\n\\nANALYSIS :-\\n* **Time Complexity:** Exponential in nature, since we are trying out all ways. To be precise it goes as O(N! * N) nearly.\\n\\n* **Space Complexity:** O(N^2)\\n```\\nN-Quuens II\\n```\\n\\nThis Problem is Almost Similar to N-Queens what extra we have to done over here is, Instead of printing the position we have to **count** the no. of ways in which Queens can be arranged on N-By-N chess \\n\\n![image](https://assets.leetcode.com/users/images/c8f00056-d8d7-4965-a879-f3fac38d8bfc_1654399504.9641533.png)\\n\\n<iframe src=\"https://leetcode.com/playground/H7a7hggm/shared\" frameBorder=\"0\" width=\"1200\" height=\"800\"></iframe>\\n\\nANALYSIS :-\\n* **Time Complexity:** O(N! * N)\\n\\n* **Space Complexity:** O(N^2)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nN-Quuens I\\n```\n```\\nN-Quuens II\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20058,
                "title": "accepted-java-solution",
                "content": "    /**\\n     * don't need to actually place the queen,\\n     * instead, for each row, try to place without violation on\\n     * col/ diagonal1/ diagnol2.\\n     * trick: to detect whether 2 positions sit on the same diagnol:\\n     * if delta(col, row) equals, same diagnol1;\\n     * if sum(col, row) equals, same diagnal2.\\n     */\\n    private final Set<Integer> occupiedCols = new HashSet<Integer>();\\n    private final Set<Integer> occupiedDiag1s = new HashSet<Integer>();\\n    private final Set<Integer> occupiedDiag2s = new HashSet<Integer>();\\n    public int totalNQueens(int n) {\\n        return totalNQueensHelper(0, 0, n);\\n    }\\n    \\n    private int totalNQueensHelper(int row, int count, int n) {\\n        for (int col = 0; col < n; col++) {\\n            if (occupiedCols.contains(col))\\n                continue;\\n            int diag1 = row - col;\\n            if (occupiedDiag1s.contains(diag1))\\n                continue;\\n            int diag2 = row + col;\\n            if (occupiedDiag2s.contains(diag2))\\n                continue;\\n            // we can now place a queen here\\n            if (row == n-1)\\n                count++;\\n            else {\\n                occupiedCols.add(col);\\n                occupiedDiag1s.add(diag1);\\n                occupiedDiag2s.add(diag2);\\n                count = totalNQueensHelper(row+1, count, n);\\n                // recover\\n                occupiedCols.remove(col);\\n                occupiedDiag1s.remove(diag1);\\n                occupiedDiag2s.remove(diag2);\\n            }\\n        }\\n        \\n        return count;\\n    }",
                "solutionTags": [],
                "code": "    /**\\n     * don't need to actually place the queen,\\n     * instead, for each row, try to place without violation on\\n     * col/ diagonal1/ diagnol2.\\n     * trick: to detect whether 2 positions sit on the same diagnol:\\n     * if delta(col, row) equals, same diagnol1;\\n     * if sum(col, row) equals, same diagnal2.\\n     */\\n    private final Set<Integer> occupiedCols = new HashSet<Integer>();\\n    private final Set<Integer> occupiedDiag1s = new HashSet<Integer>();\\n    private final Set<Integer> occupiedDiag2s = new HashSet<Integer>();\\n    public int totalNQueens(int n) {\\n        return totalNQueensHelper(0, 0, n);\\n    }\\n    \\n    private int totalNQueensHelper(int row, int count, int n) {\\n        for (int col = 0; col < n; col++) {\\n            if (occupiedCols.contains(col))\\n                continue;\\n            int diag1 = row - col;\\n            if (occupiedDiag1s.contains(diag1))\\n                continue;\\n            int diag2 = row + col;\\n            if (occupiedDiag2s.contains(diag2))\\n                continue;\\n            // we can now place a queen here\\n            if (row == n-1)\\n                count++;\\n            else {\\n                occupiedCols.add(col);\\n                occupiedDiag1s.add(diag1);\\n                occupiedDiag2s.add(diag2);\\n                count = totalNQueensHelper(row+1, count, n);\\n                // recover\\n                occupiedCols.remove(col);\\n                occupiedDiag1s.remove(diag1);\\n                occupiedDiag2s.remove(diag2);\\n            }\\n        }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 20048,
                "title": "easiest-java-solution-1ms-98-22",
                "content": "This is a classic backtracking problem. \\n\\nStart row by row, and loop through columns. At each decision point, skip unsafe positions by using three boolean arrays.\\n\\nStart going back when we reach row n.\\n\\nJust FYI, if using HashSet, running time will be at least 3 times slower!\\n\\n    public class Solution {\\n        int count = 0;\\n        public int totalNQueens(int n) {\\n            boolean[] cols = new boolean[n];     // columns   |\\n            boolean[] d1 = new boolean[2 * n];   // diagonals \\\\\\n            boolean[] d2 = new boolean[2 * n];   // diagonals /\\n            backtracking(0, cols, d1, d2, n);\\n            return count;\\n        }\\n        \\n        public void backtracking(int row, boolean[] cols, boolean[] d1, boolean []d2, int n) {\\n            if(row == n) count++;\\n    \\n            for(int col = 0; col < n; col++) {\\n                int id1 = col - row + n;\\n                int id2 = col + row;\\n                if(cols[col] || d1[id1] || d2[id2]) continue;\\n                \\n                cols[col] = true; d1[id1] = true; d2[id2] = true;\\n                backtracking(row + 1, cols, d1, d2, n);\\n                cols[col] = false; d1[id1] = false; d2[id2] = false;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        int count = 0;\\n        public int totalNQueens(int n) {\\n            boolean[] cols = new boolean[n];     // columns   |\\n            boolean[] d1 = new boolean[2 * n];   // diagonals \\\\\\n            boolean[] d2 = new boolean[2 * n];   // diagonals /\\n            backtracking(0, cols, d1, d2, n);\\n            return count;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1237811,
                "title": "short-easy-w-explanation-visualization-backtracking-explained",
                "content": "This is very similar to [N-Queens](https://leetcode.com/problems/n-queens/) problem, with the only difference being that we are required to return count instead of all the solution boards. But both the solutions are almost the same.\\n\\n\\u2714\\uFE0F ***Solution - I (Backtracking)***\\n\\nThis is a common backtracking problem. We can see than the number of ways to place a `N` queens on a `NxN` board can get very large since we have `N^2` choices at first, then `N^2 -1`, `N^2 -2` and so on... leading to overall time complexity of `O(N^2N)`.\\n\\nBut, we dont need to explore all `O(N^2)` options each time. Firstly, we have `N` Queens and all must be placed such that no queen attacks the other queen. This means, **on each row only one queen** can be placed and then we can move to the next row.\\n\\nSo for each row we will to place one queen without violating the constraint and then move on to the next row. This will be repeated till all `N` queens have been placed. We will use the *`check`* method to ensure that the queen is safe to placed at *`(i, j)`*. If all `N` queens have been placed, we have got our first solution.\\n\\nTo get all the other possible solutions, we will need to remove the previously placed queen and try if its possible to place the queen on the same row at some other column, i.e, we need to **backtrack**. This will give us all the possible ways to place `N` queens on the board as per the given constraints.\\n\\nA visualization from [wikipedia](https://en.wikipedia.org/wiki/File:Eight-queens-animation.gif) of how this process works -\\n\\n<p align = center><img src=https://assets.leetcode.com/users/images/d2f3e045-6674-4828-bb23-8ccf3a0e1283_1621672263.6452782.gif /></p>\\n\\nAnother good visualization of N-Queens problem can be found [here](https://www.cs.usfca.edu/~galles/visualization/RecQueens.html)\\n\\n```\\nint totalNQueens(int n) {\\n\\tvector<vector<bool>> board(n, vector<bool>(n, false));\\n\\treturn solve(board, 0);\\n}\\nbool check(vector<vector<bool>>& board, int row, int col) {\\n\\tint n = size(board);\\n\\tfor(int i = 0; i <= row; i++) {\\n\\t\\tif(board[i][col]) return false; // checking if any queen already placed on same column previously\\n\\t\\t// checking if all diagonals are safe -\\n\\t\\tif(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\\n\\t\\tif(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\\n\\t}\\n\\treturn true;\\n}    \\nint solve(vector<vector<bool>>& board, int row) {\\n\\tif(row == size(board)) return 1;\\n\\tint count = 0;\\n\\tfor(int col = 0; col < size(board); col++)           \\n\\t\\tif(check(board, row, col)){          // check if we can place at (row, col)\\n\\t\\t\\tboard[row][col] = true;          // place the queen at (row, col)\\n\\t\\t\\tcount += solve(board, row + 1);  // explore for the next row. The function will return 1 if all N queens get placed for current combination\\n\\t\\t\\tboard[row][col] = false;         // backtrack - remove previously placed queen and try for different columns\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**, we have *`N`* choices in the first row, *`N-1`* in the second row, *`N-2`* in the next and so on... which brings overall time complexity to `O(N!)`\\n***Space Complexity :*** **`O(N*N)`**. Required for board and recursive stack. \\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Backtracking O(N) Space)***\\n\\nWe don\\'t need to simulate the exact board since we only require number of solutions and not the exact board solutions themselves. \\n\\nHere, we only keep track of queen placements on each of *`n`* columns, *`2n-1`* diagonals and *`2n-1`* anti-diagonals. This will eliminate the need to iterative *`check`* function and reduc space usage\\n\\n```\\nint totalNQueens(int n) {\\n\\tvector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\\n\\treturn solve(col, diag, anti_diag, 0);\\n}\\n   \\nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\\n\\tint n = size(col), count = 0;\\n    if(row == n) return 1;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){        // check if (row, column) is safe\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;      // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1);                                  // explore for the next row\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = false;     // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**\\n***Space Complexity :*** **`O(N)`**, for recursive stack and *`col`*, *`diag`*, *`anti_diag`*\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Backtracking + Bitset O(N))***\\n\\nSlight optimization using bitset in C++, although it won\\'t make much of difference in space usage since it\\'s dominated by recursive stack space usage.\\n\\n```\\nint totalNQueens(int n) {\\n\\tbitset<17> col, diag, anti_diag;\\n\\treturn solve(col, diag, anti_diag, 0, n);\\n}  \\nint solve(bitset<17>& col, bitset<17>& diag, bitset<17>& anti_diag, int row, int n) {\\n    if(row == n) return 1;\\n    int count = 0;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = 1;    // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1, n);                          // explore for the next row. \\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = 0;    // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**\\n***Space Complexity :*** **`O(N)`**, for recursive stack\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Backtracking + Bit-Manipulation)***\\n\\nDirect bit-manipulation instead of using bitset -\\n\\n```\\nint totalNQueens(int n, int row = 0, int col = 0, int diag = 0, int anti_diag = 0) {\\n    if(row == n) return 1;\\n    int count = 0;\\n\\tfor(int column = 0; column < n; column++) {\\n        int col_mask = 1 << column, diag_mask = 1 << row + column, anti_diag_mask = 1 << row - column + n - 1;\\n        if(!(col & col_mask) && !(diag & diag_mask) && !(anti_diag & anti_diag_mask))\\n\\t\\t\\tcount += totalNQueens(n, row + 1, col | col_mask, diag | diag_mask, anti_diag | anti_diag_mask);\\n    }\\n\\treturn count;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src = https://assets.leetcode.com/users/images/abb6caae-6ffd-4062-8244-73bd3703cfb8_1622279017.2683792.png /></td></tr></table>\\n\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint totalNQueens(int n) {\\n\\tvector<vector<bool>> board(n, vector<bool>(n, false));\\n\\treturn solve(board, 0);\\n}\\nbool check(vector<vector<bool>>& board, int row, int col) {\\n\\tint n = size(board);\\n\\tfor(int i = 0; i <= row; i++) {\\n\\t\\tif(board[i][col]) return false; // checking if any queen already placed on same column previously\\n\\t\\t// checking if all diagonals are safe -\\n\\t\\tif(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\\n\\t\\tif(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\\n\\t}\\n\\treturn true;\\n}    \\nint solve(vector<vector<bool>>& board, int row) {\\n\\tif(row == size(board)) return 1;\\n\\tint count = 0;\\n\\tfor(int col = 0; col < size(board); col++)           \\n\\t\\tif(check(board, row, col)){          // check if we can place at (row, col)\\n\\t\\t\\tboard[row][col] = true;          // place the queen at (row, col)\\n\\t\\t\\tcount += solve(board, row + 1);  // explore for the next row. The function will return 1 if all N queens get placed for current combination\\n\\t\\t\\tboard[row][col] = false;         // backtrack - remove previously placed queen and try for different columns\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\n```\\nint totalNQueens(int n) {\\n\\tvector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\\n\\treturn solve(col, diag, anti_diag, 0);\\n}\\n   \\nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\\n\\tint n = size(col), count = 0;\\n    if(row == n) return 1;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){        // check if (row, column) is safe\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;      // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1);                                  // explore for the next row\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = false;     // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\n```\\nint totalNQueens(int n) {\\n\\tbitset<17> col, diag, anti_diag;\\n\\treturn solve(col, diag, anti_diag, 0, n);\\n}  \\nint solve(bitset<17>& col, bitset<17>& diag, bitset<17>& anti_diag, int row, int n) {\\n    if(row == n) return 1;\\n    int count = 0;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = 1;    // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1, n);                          // explore for the next row. \\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = 0;    // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\n```\\nint totalNQueens(int n, int row = 0, int col = 0, int diag = 0, int anti_diag = 0) {\\n    if(row == n) return 1;\\n    int count = 0;\\n\\tfor(int column = 0; column < n; column++) {\\n        int col_mask = 1 << column, diag_mask = 1 << row + column, anti_diag_mask = 1 << row - column + n - 1;\\n        if(!(col & col_mask) && !(diag & diag_mask) && !(anti_diag & anti_diag_mask))\\n\\t\\t\\tcount += totalNQueens(n, row + 1, col | col_mask, diag | diag_mask, anti_diag | anti_diag_mask);\\n    }\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 126533,
                "title": "python-backtracking-solution-beats-97",
                "content": "```\\nclass Solution:\\n    def totalNQueens(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        diag1 = set()\\n        diag2 = set()\\n        usedCols = set()\\n        \\n        return self.helper(n, diag1, diag2, usedCols, 0)\\n\\n    def helper(self, n, diag1, diag2, usedCols, row):\\n        if row == n:\\n            return 1\\n        \\n        solutions = 0\\n        \\n        for col in range(n):\\n            if row + col in diag1 or row - col in diag2 or col in usedCols:\\n                continue\\n                \\n            diag1.add(row + col)\\n            diag2.add(row - col)\\n            usedCols.add(col)\\n            \\n            solutions += self.helper(n, diag1, diag2, usedCols, row + 1)\\n        \\n            diag1.remove(row + col)\\n            diag2.remove(row - col)\\n            usedCols.remove(col)\\n        \\n        return solutions\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        diag1 = set()\\n        diag2 = set()\\n        usedCols = set()\\n        \\n        return self.helper(n, diag1, diag2, usedCols, 0)\\n\\n    def helper(self, n, diag1, diag2, usedCols, row):\\n        if row == n:\\n            return 1\\n        \\n        solutions = 0\\n        \\n        for col in range(n):\\n            if row + col in diag1 or row - col in diag2 or col in usedCols:\\n                continue\\n                \\n            diag1.add(row + col)\\n            diag2.add(row - col)\\n            usedCols.add(col)\\n            \\n            solutions += self.helper(n, diag1, diag2, usedCols, row + 1)\\n        \\n            diag1.remove(row + col)\\n            diag2.remove(row - col)\\n            usedCols.remove(col)\\n        \\n        return solutions\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 20147,
                "title": "python-recursive-dfs-solution",
                "content": "The idea here is quite similar to [N-Queens ][1] while we don\\'t need to record the path, and as the return value is a number not a list, it\\'s better to use a global variable to record the result.\\n       \\n    def totalNQueens(self, n):\\n        self.res = 0\\n        self.dfs([-1]*n, 0)\\n        return self.res\\n        \\n    def dfs(self, nums, index):\\n        if index == len(nums):\\n            self.res += 1\\n            return #backtracking\\n        for i in range(len(nums)):\\n            nums[index] = i\\n            if self.valid(nums, index):\\n                self.dfs(nums, index+1)\\n        \\n    def valid(self, nums, n):\\n        for i in range(n):\\n            if nums[i] == nums[n] or abs(nums[n]-nums[i]) == n-i:\\n                return False\\n        return True\\n\\n\\n  [1]: https://leetcode.com/discuss/53764/python-recursive-dfs-solution-with-comments",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "The idea here is quite similar to [N-Queens ][1] while we don\\'t need to record the path, and as the return value is a number not a list, it\\'s better to use a global variable to record the result.\\n       \\n    def totalNQueens(self, n):\\n        self.res = 0\\n        self.dfs([-1]*n, 0)\\n        return self.res\\n        \\n    def dfs(self, nums, index):\\n        if index == len(nums):\\n            self.res += 1\\n            return #backtracking\\n        for i in range(len(nums)):\\n            nums[index] = i\\n            if self.valid(nums, index):\\n                self.dfs(nums, index+1)\\n        \\n    def valid(self, nums, n):\\n        for i in range(n):\\n            if nums[i] == nums[n] or abs(nums[n]-nums[i]) == n-i:\\n                return False\\n        return True\\n\\n\\n  [1]: https://leetcode.com/discuss/53764/python-recursive-dfs-solution-with-comments",
                "codeTag": "Python3"
            },
            {
                "id": 20077,
                "title": "c-solution-dfs-easy-understanding",
                "content": "    int totalNQueens(int n) {\\n        vector<bool> col(n, true);\\n        vector<bool> anti(2*n-1, true);\\n        vector<bool> main(2*n-1, true);\\n        vector<int> row(n, 0);\\n        int count = 0;\\n        dfs(0, row, col, main, anti, count);\\n        return count;\\n    }\\n    void dfs(int i, vector<int> &row, vector<bool> &col, vector<bool>& main, vector<bool> &anti, int &count) {\\n            if (i == row.size()) {\\n                count++;\\n                return;\\n            }\\n           for (int j = 0; j < col.size(); j++) {\\n             if (col[j] && main[i+j] && anti[i+col.size()-1-j]) {\\n                 row[i] = j; \\n                 col[j] = main[i+j] = anti[i+col.size()-1-j] = false;\\n                 dfs(i+1, row, col, main, anti, count);\\n                 col[j] = main[i+j] = anti[i+col.size()-1-j] = true;\\n          }\\n        }\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int totalNQueens(int n) {\\n        vector<bool> col(n, true);\\n        vector<bool> anti(2*n-1, true);\\n        vector<bool> main(2*n-1, true);\\n        vector<int> row(n, 0);\\n        int count = 0;\\n        dfs(0, row, col, main, anti, count);\\n        return count;\\n    }\\n    void dfs(int i, vector<int> &row, vector<bool> &col, vector<bool>& main, vector<bool> &anti, int &count) {\\n            if (i == row.size()) {\\n                count++;\\n                return;\\n            }\\n           for (int j = 0; j < col.size(); j++) {\\n             if (col[j] && main[i+j] && anti[i+col.size()-1-j]) {\\n                 row[i] = j; \\n                 col[j] = main[i+j] = anti[i+col.size()-1-j] = false;\\n                 dfs(i+1, row, col, main, anti, count);\\n                 col[j] = main[i+j] = anti[i+col.size()-1-j] = true;\\n          }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1238198,
                "title": "python-super-short-backtracking-explained",
                "content": "This problem is similar to problem **46** and **51**, basically we need to go over all `n!` permutations and then check if it is correct and write function to draw this solution. Let us use `dfs(board, c1, c2, c3)` function here, where:\\n\\n1. `board` are positions of queen for the first, second and so on lines. Length of `board` is how many queens we already used.\\n2. `c1` is bit mask for columns, `c2` and `c3` for diagonals. Note, that we use `i-j+n` for one of the diagonals to avoid negative numbers.  Each time we try to take all possible positions and then check if we can put queen on this position.\\n\\n#### Complexity\\nTime and space complexity is `O(n!)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def totalNQueens(self, n):\\n        def dfs(board, i, c1, c2, c3):\\n            if i == n: self.ans += 1\\n            \\n           for j in range(n):\\n                if c1 & 1<<j or c2 & 1<<i-j+n or c3 & 1<<i+j: continue\\n                dfs(board + [j], i + 1, c1 ^ 1<<j, c2 ^ 1<<i-j+n, c3 ^ 1<<i+j)\\n        \\n        self.ans = 0\\n        dfs([], 0, 0, 0, 0)\\n        return self.ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def totalNQueens(self, n):\\n        def dfs(board, i, c1, c2, c3):\\n            if i == n: self.ans += 1\\n            \\n           for j in range(n):\\n                if c1 & 1<<j or c2 & 1<<i-j+n or c3 & 1<<i+j: continue\\n                dfs(board + [j], i + 1, c1 ^ 1<<j, c2 ^ 1<<i-j+n, c3 ^ 1<<i+j)\\n        \\n        self.ans = 0\\n        dfs([], 0, 0, 0, 0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111695,
                "title": "c-n-queens-variation",
                "content": "**Please upvote the post if you like it :)**\\n\\nSo, basically  we have been given `n` queens and we need to place those **queens** in the `board` such that  no **two** queens **attack** each other right?\\n\\nCool, so we know that the number of ways to place `N` **queens** on a `NxN` **board** can get very large since we have `N^2` choices at first, then `N^2 -1`, `N^2 -2` and so on... which eventually leads to an overall **time** **complexity** of `O(N^2N)`, which is extremely **high** and we can\\'t afford that.\\n\\nBut, simultaneously we also know that we don\\'t actually need to traverse all the `O(N^2)` options each time. \\nSo, we can place one **queen** in each **row** and then move to the next row.\\n\\nSo for each row, we will place one queen (if possible within the contraint) and then move on to the next row. This will be repeated till all `N` queens have been placed. We will use the `isSafe` method to ensure that the queen is safe to `place` at **(i, j)**. Once, all `N` **queens** have been placed, we have got our first solution.\\n\\nFinally, to get all the other possible solutions, we will keep on removing the previously placed queen and try if its possible to place it at some other location, i.e, where we need to **backtrack**. This will give us all the possible combinations to place `N Queens` on the board as per the given constraints.\\n\\n****\\nVisualization if needed from [wikipedia](https://en.wikipedia.org/wiki/File:Eight-queens-animation.gif)- \\n\\n\\n![image](https://assets.leetcode.com/users/images/6388c419-0494-4d56-9bc4-a710a3699862_1654316356.7472951.gif)\\n\\n\\n****\\n**Solution 1 - Backtracking Approach (C++) :** \\u2705\\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n\\tvector<vector<bool>> board(n, vector<bool>(n, false));\\n\\treturn solve(board, 0);\\n    }\\n    bool isSafe(vector<vector<bool>>& board, int row, int col) {\\n\\t    int n = size(board);\\n\\t    for(int i = 0; i <= row; i++) {\\n\\t\\t\\t// checking if any queen already placed on same column previously\\n\\t\\t    if(board[i][col]) return false; \\n\\t\\t    // checking if all diagonals are safe -\\n\\t\\t    if(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\\n\\t\\t    if(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\\n\\t    }\\n\\t    return true;\\n    }    \\n    int solve(vector<vector<bool>>& board, int row) {\\n\\t    if(row == size(board)) return 1;\\n\\t    int count = 0;\\n\\t    for(int col = 0; col < size(board); col++)           \\n\\t\\t    if(isSafe(board, row, col)){          // check if we can place at (row, col)\\n\\t\\t\\t    board[row][col] = true;          // place the queen at (row, col)\\n\\t\\t\\t    count += solve(board, row + 1);  // explore for the next row. The function will return 1 if all N queens get placed for current combination\\n\\t\\t\\t\\t// backtrack - remove previously placed queen and try for different columns\\n\\t\\t\\t    board[row][col] = false;         \\n\\t\\t    }                                \\n\\t    return count;\\n    }\\n};\\n```\\n\\n****\\n**Time Complexity : O(N!)**, Since we have N choices in the first row, then N-1 choices in the second row and so on so the overall complexity become **O(N!)** \\n**Space Complexity: O(N*N)**, Just the `board` and recursive `stack` space\\n\\n****\\n**Solution 2 - (Backtracking Approach O(N) Space):** \\u2705\\nHere we only need the number of `distinct` solutions and not the exact board solutions themselves, so what we can do is that we can keep a track on `queen` placements on each `n` **columns**, `2n-1` **diagonals**,` 2n-1` **Anti-daigonals**, this way we can remove the `isSafe` function and reduce **space** size.\\n\\n```\\nint totalNQueens(int n) {\\n\\tvector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\\n\\treturn solve(col, diag, anti_diag, 0);\\n}\\n   \\nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\\n\\tint n = size(col), count = 0;\\n    if(row == n) return 1;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){        // check if (row, column) is safe\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;      // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1);                                  // explore for the next row\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = false;     // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\\n**Time Complexity : O(N!)**\\n**Space Complexity : O(N), for recursive stack and col, diag, anti_diag**\\n",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n\\tvector<vector<bool>> board(n, vector<bool>(n, false));\\n\\treturn solve(board, 0);\\n    }\\n    bool isSafe(vector<vector<bool>>& board, int row, int col) {\\n\\t    int n = size(board);\\n\\t    for(int i = 0; i <= row; i++) {\\n\\t\\t\\t// checking if any queen already placed on same column previously\\n\\t\\t    if(board[i][col]) return false; \\n\\t\\t    // checking if all diagonals are safe -\\n\\t\\t    if(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\\n\\t\\t    if(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\\n\\t    }\\n\\t    return true;\\n    }    \\n    int solve(vector<vector<bool>>& board, int row) {\\n\\t    if(row == size(board)) return 1;\\n\\t    int count = 0;\\n\\t    for(int col = 0; col < size(board); col++)           \\n\\t\\t    if(isSafe(board, row, col)){          // check if we can place at (row, col)\\n\\t\\t\\t    board[row][col] = true;          // place the queen at (row, col)\\n\\t\\t\\t    count += solve(board, row + 1);  // explore for the next row. The function will return 1 if all N queens get placed for current combination\\n\\t\\t\\t\\t// backtrack - remove previously placed queen and try for different columns\\n\\t\\t\\t    board[row][col] = false;         \\n\\t\\t    }                                \\n\\t    return count;\\n    }\\n};\\n```\n```\\nint totalNQueens(int n) {\\n\\tvector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\\n\\treturn solve(col, diag, anti_diag, 0);\\n}\\n   \\nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\\n\\tint n = size(col), count = 0;\\n    if(row == n) return 1;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){        // check if (row, column) is safe\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;      // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1);                                  // explore for the next row\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = false;     // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20046,
                "title": "share-my-java-code-beats-97-83-run-times",
                "content": "    /*\\n        \\u5e38\\u89c4n-queens\\u89e3\\u6cd5, \\u6570\\u7b54\\u6848\\u4e2a\\u6570.\\n        \\u7528column\\u6807\\u8bb0\\u6b64\\u884c\\u4e4b\\u524d\\u7684\\u54ea\\u4e9bcolumn\\u5df2\\u7ecf\\u653e\\u7f6e\\u4e86queen. \\u68cb\\u76d8\\u5750\\u6807(row, col)\\u5bf9\\u5e94column\\u7684\\u7b2ccol\\u4f4d(LSB --> MSB, \\u4e0b\\u540c).\\n        \\u7528diag\\u6807\\u8bb0\\u6b64\\u4f4d\\u7f6e\\u4e4b\\u524d\\u7684\\u54ea\\u4e9b\\u4e3b\\u5bf9\\u89d2\\u7ebf\\u5df2\\u7ecf\\u653e\\u7f6e\\u4e86queen. \\u68cb\\u76d8\\u5750\\u6807(row, col)\\u5bf9\\u5e94diag\\u7684\\u7b2c(n - 1 + row - col)\\u4f4d.\\n        \\u7528antiDiag\\u6807\\u8bb0\\u6b64\\u4f4d\\u7f6e\\u4e4b\\u524d\\u7684\\u54ea\\u4e9b\\u526f\\u5bf9\\u89d2\\u7ebf\\u5df2\\u7ecf\\u653e\\u7f6e\\u4e86queen. \\u68cb\\u76d8\\u5750\\u6807(row, col)\\u5bf9\\u5e94antiDiag\\u7684\\u7b2c(row + col)\\u4f4d.\\n    */\\n    public class Solution {\\n        int count = 0;\\n        \\n        public int totalNQueens(int n) {\\n            dfs(0, n, 0, 0, 0);\\n            return count;\\n        }\\n        \\n        private void dfs(int row, int n, int column, int diag, int antiDiag) {\\n            if (row == n) {\\n                ++count;\\n                return;\\n            }\\n            for (int i = 0; i < n; ++i) {\\n                boolean isColSafe = ((1 << i) & column) == 0;\\n                boolean isDiagSafe = ((1 << (n - 1 + row - i)) & diag) == 0;\\n                boolean isAntiDiagSafe = ((1 << (row + i)) & antiDiag) == 0;\\n                if (isColSafe && isDiagSafe && isAntiDiagSafe) {\\n                    dfs(row + 1, n, (1 << i) | column, (1 << (n - 1 + row - i)) | diag, (1 << (row + i)) | antiDiag);\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        int count = 0;\\n        \\n        public int totalNQueens(int n) {\\n            dfs(0, n, 0, 0, 0);\\n            return count;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1237780,
                "title": "js-python-java-c-easy-recursive-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\n_(**Note**: This problem is an easier duplicate to the previous problem, [**51: N-Queens**](https://leetcode.com/problems/n-queens), except that it doesn\\'t require us to return the actual boards, just the count.)_\\n\\nA naive approach here would attempt every possible combination of locations, but there are **(N^2)! / (N^2 - N)!** different combinations, which is up to **~1e17** when **N = 9**. Instead, we need to make sure we only attempt to place queens where it\\'s feasible to do so, based on the instructions. This would seem to call for a **depth first search** (**DFS**) approach with a **recursive** helper function (**place**), so that we only pursue workable combinations without wasting time on known dead-ends.\\n\\nFirst, we should consider how the queens will be placed. Since each row can only have one queen, our basic process will be to **place** a queen and then recurse to the next row. On each row, we\\'ll have to iterate through the possible options, check the cell for validity, then **place** the queen on the board.\\n\\nRather than store the whole board, we can save on **space complexity** if we only keep track of the different axes of attack in which a queen might be placed. Since a queen has four axes of attack, we\\'ll need to check the three remaining axes (other than the horizontal row, which our iteration will naturally take care of) for validity.\\n\\nThere are **N** possible columns and **2 * N - 1** possible left-downward diagonals and right-downward diagonals. With a constraint of **1 <= N <= 9,** each of the two diagonal states represents up to **17 bits**\\' worth of data and the vertical state up to **9 bits**, so we can use **bit manipulation** to store these states efficiently.\\n\\nSo for each recursive call to **place** a queen, we should pass along the board state in the form of only three integers (**vert, ldiag, rdiag**). We can then use **bitmasks** to check for cell validity before attempting to recurse to the next row.\\n\\nIf we successfully reach the end of the board without failing, we should increment our answer counter (**ans**).\\n\\n - _**Time Complexity: O(N!)** which represents the maximum number of queens placed_\\n - _**Space Complexity: O(N)** for the recursion stack_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 38.0MB** (beats 100% / 99%).\\n```javascript\\nvar totalNQueens = function(N) {\\n    let ans = 0\\n    \\n    const place = (i, vert, ldiag, rdiag) => {\\n        if (i === N) ans++\\n        else for (let j = 0; j < N; j++) {\\n            let vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j)\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n        }\\n    }\\n\\n    place(0,0,0,0)\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **44ms / 13.9MB** (beats 90% / 99%).\\n```python\\nclass Solution:\\n    def totalNQueens(self, N: int) -> int:\\n        self.ans = 0\\n        \\n        def place(i: int, vert: int, ldiag: int, rdiag:int) -> None:\\n            if i == N: self.ans += 1\\n            else:\\n                for j in range(N):\\n                    vmask, lmask, rmask = 1 << j, 1 << (i+j), 1 << (N-i-1+j)\\n                    if vert & vmask or ldiag & lmask or rdiag & rmask: continue\\n                    place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n            \\n        place(0,0,0,0)\\n        return self.ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 35.2MB** (beats 100% / 99%).\\n```java\\nclass Solution {\\n    int ans;\\n    \\n    public int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n    \\n    private void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if ((vert & vmask) + (ldiag & lmask) + (rdiag & rmask) > 0) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n    \\nprivate:\\n    int ans;\\n    \\n    void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar totalNQueens = function(N) {\\n    let ans = 0\\n    \\n    const place = (i, vert, ldiag, rdiag) => {\\n        if (i === N) ans++\\n        else for (let j = 0; j < N; j++) {\\n            let vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j)\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n        }\\n    }\\n\\n    place(0,0,0,0)\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def totalNQueens(self, N: int) -> int:\\n        self.ans = 0\\n        \\n        def place(i: int, vert: int, ldiag: int, rdiag:int) -> None:\\n            if i == N: self.ans += 1\\n            else:\\n                for j in range(N):\\n                    vmask, lmask, rmask = 1 << j, 1 << (i+j), 1 << (N-i-1+j)\\n                    if vert & vmask or ldiag & lmask or rdiag & rmask: continue\\n                    place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n            \\n        place(0,0,0,0)\\n        return self.ans\\n```\n```java\\nclass Solution {\\n    int ans;\\n    \\n    public int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n    \\n    private void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if ((vert & vmask) + (ldiag & lmask) + (rdiag & rmask) > 0) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n    \\nprivate:\\n    int ans;\\n    \\n    void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111513,
                "title": "python-solution-with-explanation",
                "content": "This problem is an extension on the yesterday\\'s daily challenge problem [N-Queens](https://leetcode.com/problems/n-queens/discuss/2107719/python-solution-with-explanation). Please refer the link to understand how **N-Queens** is implemented. \\n\\n\\nThe below code is just a slight modification on yesterday\\'s [solution](https://leetcode.com/problems/n-queens/discuss/2107719/python-solution-with-explanation) that I had posted. In this, instead of returning the list of valid solutions, I am returning the count of number of valid solutions.\\n\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        state=[[\\'.\\'] * n for _ in range(n)]\\n\\t\\t\\n\\t\\t# for tracking the columns which already have a queen\\n        visited_cols=set()\\n\\t\\t\\n\\t\\t# This will hold the difference of row and col\\n        # This is required to identify diagonals\\n        # specifically for diagonals with increasing row and increasing col pattern\\n        # example: square (1,0) = 1-0 = 1\\n        # squares in same diagonals will have same difference\\n        # example: squares (0,0) and (8,8) are in the same diagonal\\n        # as both have same difference which is `0`\\n        visited_diagonals=set()\\n\\t\\t\\n\\t\\t # This will hold the sum of row and col\\n        # This is required to identify antidiagonals.\\n        # specifically for diagonals with increasing row and decreasing col pattern\\n        # the squares in same diagonal won\\'t have the same difference.\\n        # example: square (1,0) = 1-0 = 1\\n        # squares in same diagonals will have same difference\\n        # example: squares (0,7) and (1,6) are in the same diagonal\\n        # as both have same sum which is `7`\\n        visited_antidiagonals=set()\\n        \\n        res=set()\\n        def backtrack(r):\\n            if r==n:\\n                res.add(map(\\'#\\'.join, map(\\'\\'.join, state))) # add a valid solution\\n                return\\n                        \\n            for c in range(n):\\n\\t\\t\\t # If the current square doesn\\'t have another queen in same column and diagonal.\\n                if not(c in visited_cols or (r-c) in visited_diagonals or (r+c) in visited_antidiagonals):\\n                    visited_cols.add(c)\\n                    visited_diagonals.add(r-c)\\n                    visited_antidiagonals.add(r+c)\\n                    state[r][c]=\\'Q\\'\\n                    backtrack(r+1)\\n                    \\n\\t\\t\\t\\t\\t# reset the exploration path for backtracking\\n                    visited_cols.remove(c)\\n                    visited_diagonals.remove(r-c)\\n                    visited_antidiagonals.remove(r+c)\\n                    state[r][c]=\\'.\\'\\n                        \\n        backtrack(0)\\n        return len(res)\\n\\n```\\n\\nBut sometimes while building a solution for a problem that is an extension or similar to another problem, we might end up with similar solution with slight change. This is what I did in my above approach. We were already tracking valid solutions in [N-Queens](https://leetcode.com/problems/n-queens/discuss/2107719/python-solution-with-explanation). So instead of returning the list of valid solutions, I am returning count of the number of solutions in the list.\\n\\nIf you observe the exploration path that solution tree takes, you would notice that it starts at a different row each time. Each path it takes is unique. So instead of tracking the valid solutions. We can just track the count of valid solutions. Whenever we hit the required number of queens, we just add that path to overall tally.\\n\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:                \\n        visited_cols=set()\\n        visited_diagonals=set()\\n        visited_antidiagonals=set()\\n        \\n        res=set()\\n        def backtrack(r):\\n            if r==n:  # valid solution state   \\n                return 1\\n                        \\n            cnt=0\\n            for c in range(n):\\n                if not(c in visited_cols or (r-c) in visited_diagonals or (r+c) in visited_antidiagonals):\\n                    visited_cols.add(c)\\n                    visited_diagonals.add(r-c)\\n                    visited_antidiagonals.add(r+c)                    \\n                    cnt+=backtrack(r+1) # count the overall tally from this current state\\n                    \\n                    visited_cols.remove(c)\\n                    visited_diagonals.remove(r-c)\\n                    visited_antidiagonals.remove(r+c)                    \\n            \\n            return cnt\\n        \\n        return backtrack(0)\\n\\n```\\n\\n**Time - O(N!)** - In the solution tree, number of valid exploration paths from a node reduces by 2 at each level. In first level, we have `N` columns options to place the queen i.e `N` paths from the root node. In the next level, we have max `N-2` options available because we can\\'t place the queen in same column and same diagonal as previous queen. In the next level, it will be `N-4` because of two columns and two diagonals occupied by previous two queens. This will continue and give us a `O(N!)`Time. (Let me know if you think otherwise :) )\\n\\n**Space - O(N^2)** - recursive call stack to explore all possible solutions\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        state=[[\\'.\\'] * n for _ in range(n)]\\n\\t\\t\\n\\t\\t# for tracking the columns which already have a queen\\n        visited_cols=set()\\n\\t\\t\\n\\t\\t# This will hold the difference of row and col\\n        # This is required to identify diagonals\\n        # specifically for diagonals with increasing row and increasing col pattern\\n        # example: square (1,0) = 1-0 = 1\\n        # squares in same diagonals will have same difference\\n        # example: squares (0,0) and (8,8) are in the same diagonal\\n        # as both have same difference which is `0`\\n        visited_diagonals=set()\\n\\t\\t\\n\\t\\t # This will hold the sum of row and col\\n        # This is required to identify antidiagonals.\\n        # specifically for diagonals with increasing row and decreasing col pattern\\n        # the squares in same diagonal won\\'t have the same difference.\\n        # example: square (1,0) = 1-0 = 1\\n        # squares in same diagonals will have same difference\\n        # example: squares (0,7) and (1,6) are in the same diagonal\\n        # as both have same sum which is `7`\\n        visited_antidiagonals=set()\\n        \\n        res=set()\\n        def backtrack(r):\\n            if r==n:\\n                res.add(map(\\'#\\'.join, map(\\'\\'.join, state))) # add a valid solution\\n                return\\n                        \\n            for c in range(n):\\n\\t\\t\\t # If the current square doesn\\'t have another queen in same column and diagonal.\\n                if not(c in visited_cols or (r-c) in visited_diagonals or (r+c) in visited_antidiagonals):\\n                    visited_cols.add(c)\\n                    visited_diagonals.add(r-c)\\n                    visited_antidiagonals.add(r+c)\\n                    state[r][c]=\\'Q\\'\\n                    backtrack(r+1)\\n                    \\n\\t\\t\\t\\t\\t# reset the exploration path for backtracking\\n                    visited_cols.remove(c)\\n                    visited_diagonals.remove(r-c)\\n                    visited_antidiagonals.remove(r+c)\\n                    state[r][c]=\\'.\\'\\n                        \\n        backtrack(0)\\n        return len(res)\\n\\n```\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:                \\n        visited_cols=set()\\n        visited_diagonals=set()\\n        visited_antidiagonals=set()\\n        \\n        res=set()\\n        def backtrack(r):\\n            if r==n:  # valid solution state   \\n                return 1\\n                        \\n            cnt=0\\n            for c in range(n):\\n                if not(c in visited_cols or (r-c) in visited_diagonals or (r+c) in visited_antidiagonals):\\n                    visited_cols.add(c)\\n                    visited_diagonals.add(r-c)\\n                    visited_antidiagonals.add(r+c)                    \\n                    cnt+=backtrack(r+1) # count the overall tally from this current state\\n                    \\n                    visited_cols.remove(c)\\n                    visited_diagonals.remove(r-c)\\n                    visited_antidiagonals.remove(r+c)                    \\n            \\n            return cnt\\n        \\n        return backtrack(0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20119,
                "title": "collection-of-solutions-in-java",
                "content": "This post is mainly for myself as I learnt a lot from all kinds of solutions posted under this question. The copyright goes to the original author :)\\n\\nClick on the title of each method and you can see the original author's explanations (if there is any).\\n\\n\\n#[Java accepted clean solutions, >98.73% by yunli2015][1]#\\n\\n    public class Solution {\\n        int count=0;\\n        public int totalNQueens(int n) {\\n            dfs(new int[n],0,n);\\n            return count;\\n        }\\n        public void dfs(int[] pos,int step,int n) {\\n            if(step==n) {\\n                count++;\\n                return;\\n            }\\n            for(int i=0;i<n;i++) {\\n                pos[step]=i;\\n                if(isvalid(pos,step)) dfs(pos,step+1,n);\\n            }\\n        }\\n        public boolean isvalid(int[] pos, int step) {\\n            for(int i=0;i<step;i++) {\\n                if(pos[i]==pos[step]||(Math.abs(pos[i]-pos[step]))==(step-i)) return false;\\n            }\\n            return true;\\n        } \\n    }\\n\\nessentially the same one:\\n#[Share. Java, 3ms, recurrsion, backtracing, very easy to understand. by Yuan__Yuan][2]#\\n\\n    public class Solution {\\n        public int totalNQueens(int n) {\\n            if (n == 0)\\n                return 0;\\n            int[] q = new int[n];\\n            return track(q, 0);\\n        }\\n        \\n        private int track(int[] q, int row) {\\n            if (row == q.length)\\n                return 1;\\n            int solutions = 0;\\n            for (int i = 0; i < q.length; i++) {\\n                q[row] = i;\\n                if (isValid(q, row, i)) {\\n                    solutions += track(q, row + 1);\\n                }\\n            }\\n            return solutions;\\n        }\\n        \\n        private boolean isValid(int[] q, int row, int col) {\\n            for (int i = 0; i < row; i++) {\\n                if (q[i] == col || Math.abs(row - i) == Math.abs(col - q[i]))\\n                    return false;\\n            }\\n            return true;\\n        }\\n    }\\n\\n#[My own tedious code][3]#\\n\\n    public class Solution {\\n        private int counter = 0;\\n        public int totalNQueens(int N) {\\n            for(int i=0; i<N; i++) {\\n                char[][] board = new char[N][N];\\n                board[i][0] = 'Q';\\n                solve(board, N, 1);\\n            }\\n            return counter;\\n        }\\n        private boolean isSafe(char[][] board, int N, int row, int col) {\\n            for(int i=0; i<N; i++) {\\n                if(board[i][col]!=0) return false;\\n                if(board[row][i]!=0) return false;\\n            }\\n        \\n            int step = 1;\\n            step = 1;\\n            while(row-step>=0 && col-step>=0) {\\n                if(board[row-step][col-step]!=0) return false;\\n                ++step;\\n            }\\n            step = 1;\\n            while(row+step<N && col-step>=0) {\\n                if(board[row+step][col-step]!=0) return false;\\n                ++step;\\n            }\\n            return true;\\n        }\\n        private boolean solve(char[][] board, int N, int col) {\\n            if(col==N) {\\n                ++counter; \\n                return false;\\n            }\\n            for(int i=0; i<N; i++) {\\n                if(isSafe(board, N, i, col)) {\\n                    board[i][col] = 'Q';\\n                    if(solve(board, N, col+1)) return true;\\n                    else {\\n                        board[i][col] = 0;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n\\n#[Pretty simple JAVA solution by EvelynGuo][4]#\\n\\n    public class Solution {\\n      Set<Integer> col = new HashSet<Integer>();\\n      Set<Integer> diag1 = new HashSet<Integer>();\\n      Set<Integer> diag2 = new HashSet<Integer>();\\n    \\n      public int totalNQueens(int n) {\\n        int[] res = new int[1];\\n        helper(res,n,0);\\n        return res[0];\\n      }\\n      public void helper(int[] res, int n, int row){\\n        if(row==n){\\n            res[0]++;\\n        }\\n        else{\\n            for(int i=0; i<n; i++){\\n                if(col.contains(i) || diag1.contains(i+row) || diag2.contains(row-i)) continue;\\n                else{\\n                    col.add(i);\\n                    diag1.add(i+row);\\n                    diag2.add(row-i);\\n                    helper(res,n,row+1);\\n                    col.remove(i);\\n                    diag1.remove(i+row);\\n                    diag2.remove(row-i);\\n                }\\n             }\\n          }\\n       }\\n    }\\n\\nSimilar idea as above but better implementation:\\n\\n#[Easiest Java Solution (1ms, 98.22%) by yavinci][5]#\\n\\n    public class Solution {\\n        int count = 0;\\n        public int totalNQueens(int n) {\\n            boolean[] cols = new boolean[n];     // columns   |\\n            boolean[] d1 = new boolean[2 * n];   // diagonals \\\\\\n            boolean[] d2 = new boolean[2 * n];   // diagonals /\\n            backtracking(0, cols, d1, d2, n);\\n            return count;\\n        }\\n    \\n        public void backtracking(int row, boolean[] cols, boolean[] d1, boolean []d2, int n) {\\n            if(row == n) count++;\\n    \\n            for(int col = 0; col < n; col++) {\\n                int id1 = col - row + n;\\n                int id2 = col + row;\\n                if(cols[col] || d1[id1] || d2[id2]) continue;\\n    \\n                cols[col] = true; d1[id1] = true; d2[id2] = true;\\n                backtracking(row + 1, cols, d1, d2, n);\\n                cols[col] = false; d1[id1] = false; d2[id2] = false;\\n            }\\n        }\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/60251/java-accepted-clean-solutions-98-73%25\\n  [2]: https://leetcode.com/discuss/72502/share-java-3ms-recurrsion-backtracing-very-easy-understand\\n  [3]: https://leetcode.com/discuss/80748/java-almost-same-as-n-queens-i\\n  [4]: https://leetcode.com/discuss/63709/pretty-simple-java-solution\\n  [5]: https://leetcode.com/discuss/69603/easiest-java-solution-1ms-98-22%25",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        int count=0;\\n        public int totalNQueens(int n) {\\n            dfs(new int[n],0,n);\\n            return count;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1237813,
                "title": "n-queens-ii-easy-solution-using-backtracking-w-explanation-and-visualization",
                "content": "This is very similar to [N-Queens](https://leetcode.com/problems/n-queens/) problem, with the only difference being that we are required to return count instead of all the solution boards. But both the solutions are almost the same.\\n\\n\\u2714\\uFE0F ***Solution - I (Backtracking)***\\n\\nThis is a common backtracking problem. We can see than the number of ways to place a `N` queens on a `NxN` board can get very large since we have `N^2` choices at first, then `N^2 -1`, `N^2 -2` and so on... leading to overall time complexity of `O(N^2N)`.\\n\\nBut, we dont need to explore all `O(N^2)` options each time. Firstly, we have `N` Queens and all must be placed such that no queen attacks the other queen. This means, **on each row only one queen** can be placed and then we can move to the next row.\\n\\nSo for each row we will to place one queen without violating the constraint and then move on to the next row. This will be repeated till all `N` queens have been placed. We will use the *`check`* method to ensure that the queen is safe to placed at *`(i, j)`*. If all `N` queens have been placed, we have got our first solution.\\n\\nTo get all the other possible solutions, we will need to remove the previously placed queen and try if its possible to place the queen on the same row at some other column, i.e, we need to **backtrack**. This will give us all the possible ways to place `N` queens on the board as per the given constraints.\\n\\nA visualization from [wikipedia](https://en.wikipedia.org/wiki/File:Eight-queens-animation.gif) of how this process works -\\n\\n<p align = center><img src=https://assets.leetcode.com/users/images/d2f3e045-6674-4828-bb23-8ccf3a0e1283_1621672263.6452782.gif /></p>\\n\\nAnother good visualization of N-Queens problem can be found [here](https://www.cs.usfca.edu/~galles/visualization/RecQueens.html)\\n\\n```\\nint totalNQueens(int n) {\\n\\tvector<vector<bool>> board(n, vector<bool>(n, false));\\n\\treturn solve(board, 0);\\n}\\nbool check(vector<vector<bool>>& board, int row, int col) {\\n\\tint n = size(board);\\n\\tfor(int i = 0; i <= row; i++) {\\n\\t\\tif(board[i][col]) return false; // checking if any queen already placed on same column previously\\n\\t\\t// checking if all diagonals are safe -\\n\\t\\tif(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\\n\\t\\tif(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\\n\\t}\\n\\treturn true;\\n}    \\nint solve(vector<vector<bool>>& board, int row) {\\n\\tif(row == size(board)) return 1;\\n\\tint count = 0;\\n\\tfor(int col = 0; col < size(board); col++)           \\n\\t\\tif(check(board, row, col)){          // check if we can place at (row, col)\\n\\t\\t\\tboard[row][col] = true;          // place the queen at (row, col)\\n\\t\\t\\tcount += solve(board, row + 1);  // explore for the next row. The function will return 1 if all N queens get placed for current combination\\n\\t\\t\\tboard[row][col] = false;         // backtrack - remove previously placed queen and try for different columns\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**, we have *`N`* choices in the first row, *`N-1`* in the second row, *`N-2`* in the next and so on... which brings overall time complexity to `O(N!)`\\n***Space Complexity :*** **`O(N*N)`**. Required for board and recursive stack. \\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Backtracking O(N) Space)***\\n\\nWe don\\'t need to simulate the exact board since we only require number of solutions and not the exact board solutions themselves. \\n\\nHere, we only keep track of queen placements on each of *`n`* columns, *`2n-1`* diagonals and *`2n-1`* anti-diagonals. This will eliminate the need to iterative *`check`* function and reduc space usage\\n\\n```\\nint totalNQueens(int n) {\\n\\tvector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\\n\\treturn solve(col, diag, anti_diag, 0);\\n}\\n   \\nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\\n\\tint n = size(col), count = 0;\\n    if(row == n) return 1;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){        // check if (row, column) is safe\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;      // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1);                                  // explore for the next row\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = false;     // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**\\n***Space Complexity :*** **`O(N)`**, for recursive stack and *`col`*, *`diag`*, *`anti_diag`*\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Backtracking + Bitset O(N))***\\n\\nSlight optimization using bitset in C++, although it won\\'t make much of difference in space usage since it\\'s dominated by recursive stack space usage.\\n\\n```\\nint totalNQueens(int n) {\\n\\tbitset<17> col, diag, anti_diag;\\n\\treturn solve(col, diag, anti_diag, 0, n);\\n}  \\nint solve(bitset<17>& col, bitset<17>& diag, bitset<17>& anti_diag, int row, int n) {\\n    if(row == n) return 1;\\n    int count = 0;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = 1;    // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1, n);                          // explore for the next row. \\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = 0;    // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**\\n***Space Complexity :*** **`O(N)`**, for recursive stack\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Backtracking + Bit-Manipulation)***\\n\\nDirect bit-manipulation instead of using bitset -\\n\\n```\\nint totalNQueens(int n, int row = 0, int col = 0, int diag = 0, int anti_diag = 0) {\\n    if(row == n) return 1;\\n    int count = 0;\\n\\tfor(int column = 0; column < n; column++) {\\n        int col_mask = 1 << column, diag_mask = 1 << row + column, anti_diag_mask = 1 << row - column + n - 1;\\n        if(!(col & col_mask) && !(diag & diag_mask) && !(anti_diag & anti_diag_mask))\\n\\t\\t\\tcount += totalNQueens(n, row + 1, col | col_mask, diag | diag_mask, anti_diag | anti_diag_mask);\\n    }\\n\\treturn count;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src = https://assets.leetcode.com/users/images/abb6caae-6ffd-4062-8244-73bd3703cfb8_1622279017.2683792.png /></td></tr></table>\\n\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint totalNQueens(int n) {\\n\\tvector<vector<bool>> board(n, vector<bool>(n, false));\\n\\treturn solve(board, 0);\\n}\\nbool check(vector<vector<bool>>& board, int row, int col) {\\n\\tint n = size(board);\\n\\tfor(int i = 0; i <= row; i++) {\\n\\t\\tif(board[i][col]) return false; // checking if any queen already placed on same column previously\\n\\t\\t// checking if all diagonals are safe -\\n\\t\\tif(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\\n\\t\\tif(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\\n\\t}\\n\\treturn true;\\n}    \\nint solve(vector<vector<bool>>& board, int row) {\\n\\tif(row == size(board)) return 1;\\n\\tint count = 0;\\n\\tfor(int col = 0; col < size(board); col++)           \\n\\t\\tif(check(board, row, col)){          // check if we can place at (row, col)\\n\\t\\t\\tboard[row][col] = true;          // place the queen at (row, col)\\n\\t\\t\\tcount += solve(board, row + 1);  // explore for the next row. The function will return 1 if all N queens get placed for current combination\\n\\t\\t\\tboard[row][col] = false;         // backtrack - remove previously placed queen and try for different columns\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\n```\\nint totalNQueens(int n) {\\n\\tvector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\\n\\treturn solve(col, diag, anti_diag, 0);\\n}\\n   \\nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\\n\\tint n = size(col), count = 0;\\n    if(row == n) return 1;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){        // check if (row, column) is safe\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;      // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1);                                  // explore for the next row\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = false;     // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\n```\\nint totalNQueens(int n) {\\n\\tbitset<17> col, diag, anti_diag;\\n\\treturn solve(col, diag, anti_diag, 0, n);\\n}  \\nint solve(bitset<17>& col, bitset<17>& diag, bitset<17>& anti_diag, int row, int n) {\\n    if(row == n) return 1;\\n    int count = 0;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = 1;    // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1, n);                          // explore for the next row. \\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = 0;    // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\n```\\nint totalNQueens(int n, int row = 0, int col = 0, int diag = 0, int anti_diag = 0) {\\n    if(row == n) return 1;\\n    int count = 0;\\n\\tfor(int column = 0; column < n; column++) {\\n        int col_mask = 1 << column, diag_mask = 1 << row + column, anti_diag_mask = 1 << row - column + n - 1;\\n        if(!(col & col_mask) && !(diag & diag_mask) && !(anti_diag & anti_diag_mask))\\n\\t\\t\\tcount += totalNQueens(n, row + 1, col | col_mask, diag | diag_mask, anti_diag | anti_diag_mask);\\n    }\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111854,
                "title": "java-branch-and-bound-method-easy-optimized-solu-faster-than-98",
                "content": "**Upvote if u find this solution good**\\n```\\nclass Solution {\\n    int count = 0;\\n    public void total(int row ,int n , boolean[] cols,boolean[] nDiagnol,boolean[] rDiagnol){\\n        if(row==n){\\n            count++;\\n            return;\\n        }\\n        for(int col=0;col<n;col++){\\n            if(!cols[col] && !nDiagnol[row+col] && !rDiagnol[row-col+n-1]){\\n                cols[col]=true;\\n                nDiagnol[row+col]=true;\\n                rDiagnol[row-col+n-1]=true;\\n                total(row+1,n,cols,nDiagnol,rDiagnol);\\n                cols[col]=false;\\n                nDiagnol[row+col]=false;\\n                rDiagnol[row-col+n-1]=false;\\n            }\\n        }\\n    }\\n    public int totalNQueens(int n) {\\n     boolean[] cols = new boolean[n];\\n     boolean[] nDiagnol = new boolean[2*n-1];\\n     boolean[] rDiagnol = new boolean[2*n-1];\\n        total(0,n,cols,nDiagnol,rDiagnol);\\n        return count;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public void total(int row ,int n , boolean[] cols,boolean[] nDiagnol,boolean[] rDiagnol){\\n        if(row==n){\\n            count++;\\n            return;\\n        }\\n        for(int col=0;col<n;col++){\\n            if(!cols[col] && !nDiagnol[row+col] && !rDiagnol[row-col+n-1]){\\n                cols[col]=true;\\n                nDiagnol[row+col]=true;\\n                rDiagnol[row-col+n-1]=true;\\n                total(row+1,n,cols,nDiagnol,rDiagnol);\\n                cols[col]=false;\\n                nDiagnol[row+col]=false;\\n                rDiagnol[row-col+n-1]=false;\\n            }\\n        }\\n    }\\n    public int totalNQueens(int n) {\\n     boolean[] cols = new boolean[n];\\n     boolean[] nDiagnol = new boolean[2*n-1];\\n     boolean[] rDiagnol = new boolean[2*n-1];\\n        total(0,n,cols,nDiagnol,rDiagnol);\\n        return count;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237781,
                "title": "n-queens-ii-js-python-java-c-easy-recursive-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\n_(**Note**: This problem is an easier duplicate to the previous problem, [**51: N-Queens**](https://leetcode.com/problems/n-queens), except that it doesn\\'t require us to return the actual boards, just the count.)_\\n\\nA naive approach here would attempt every possible combination of locations, but there are **(N^2)! / (N^2 - N)!** different combinations, which is up to **~1e17** when **N = 9**. Instead, we need to make sure we only attempt to place queens where it\\'s feasible to do so, based on the instructions. This would seem to call for a **depth first search** (**DFS**) approach with a **recursive** helper function (**place**), so that we only pursue workable combinations without wasting time on known dead-ends.\\n\\nFirst, we should consider how the queens will be placed. Since each row can only have one queen, our basic process will be to **place** a queen and then recurse to the next row. On each row, we\\'ll have to iterate through the possible options, check the cell for validity, then **place** the queen on the board.\\n\\nRather than store the whole board, we can save on **space complexity** if we only keep track of the different axes of attack in which a queen might be placed. Since a queen has four axes of attack, we\\'ll need to check the three remaining axes (other than the horizontal row, which our iteration will naturally take care of) for validity.\\n\\nThere are **N** possible columns and **2 * N - 1** possible left-downward diagonals and right-downward diagonals. With a constraint of **1 <= N <= 9,** each of the two diagonal states represents up to **17 bits**\\' worth of data and the vertical state up to **9 bits**, so we can use **bit manipulation** to store these states efficiently.\\n\\nSo for each recursive call to **place** a queen, we should pass along the board state in the form of only three integers (**vert, ldiag, rdiag**). We can then use **bitmasks** to check for cell validity before attempting to recurse to the next row.\\n\\nIf we successfully reach the end of the board without failing, we should increment our answer counter (**ans**).\\n\\n - _**Time Complexity: O(N!)** which represents the maximum number of queens placed_\\n - _**Space Complexity: O(N)** for the recursion stack_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 38.0MB** (beats 100% / 99%).\\n```javascript\\nvar totalNQueens = function(N) {\\n    let ans = 0\\n    \\n    const place = (i, vert, ldiag, rdiag) => {\\n        if (i === N) ans++\\n        else for (let j = 0; j < N; j++) {\\n            let vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j)\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n        }\\n    }\\n\\n    place(0,0,0,0)\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **44ms / 13.9MB** (beats 90% / 99%).\\n```python\\nclass Solution:\\n    def totalNQueens(self, N: int) -> int:\\n        self.ans = 0\\n        \\n        def place(i: int, vert: int, ldiag: int, rdiag:int) -> None:\\n            if i == N: self.ans += 1\\n            else:\\n                for j in range(N):\\n                    vmask, lmask, rmask = 1 << j, 1 << (i+j), 1 << (N-i-1+j)\\n                    if vert & vmask or ldiag & lmask or rdiag & rmask: continue\\n                    place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n            \\n        place(0,0,0,0)\\n        return self.ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 35.2MB** (beats 100% / 99%).\\n```java\\nclass Solution {\\n    int ans;\\n    \\n    public int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n    \\n    private void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if ((vert & vmask) + (ldiag & lmask) + (rdiag & rmask) > 0) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n    \\nprivate:\\n    int ans;\\n    \\n    void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar totalNQueens = function(N) {\\n    let ans = 0\\n    \\n    const place = (i, vert, ldiag, rdiag) => {\\n        if (i === N) ans++\\n        else for (let j = 0; j < N; j++) {\\n            let vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j)\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n        }\\n    }\\n\\n    place(0,0,0,0)\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def totalNQueens(self, N: int) -> int:\\n        self.ans = 0\\n        \\n        def place(i: int, vert: int, ldiag: int, rdiag:int) -> None:\\n            if i == N: self.ans += 1\\n            else:\\n                for j in range(N):\\n                    vmask, lmask, rmask = 1 << j, 1 << (i+j), 1 << (N-i-1+j)\\n                    if vert & vmask or ldiag & lmask or rdiag & rmask: continue\\n                    place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n            \\n        place(0,0,0,0)\\n        return self.ans\\n```\n```java\\nclass Solution {\\n    int ans;\\n    \\n    public int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n    \\n    private void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if ((vert & vmask) + (ldiag & lmask) + (rdiag & rmask) > 0) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n    \\nprivate:\\n    int ans;\\n    \\n    void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551698,
                "title": "java-tc-o-n-n-sc-o-n-space-optimized-backtracking-using-bitset",
                "content": "```java\\n/**\\n * Space Optimized Backtracking\\n *\\n * Total number of permutations can be found by this equation\\n * T(N) = N * T(N-1) + O(N)\\n * T(N-1) = (N-1) * T(N-2) + O(N)\\n * T(N-2) = (N-2) * T(N-3) + O(N)\\n * T(N-3) = (N-3) * T(N-4) + O(N)\\n * ...\\n * T(2) = 2 * T(1) + O(N)\\n * T(1) = O(1)\\n * Thus total number of permutations\\n *      = N * (P(N,0) + P(N,1) + ... + P(N, N-2)) + P(N,N-1)\\n *      = N * (e * N! - P(N,N-1) - P(N,N)) + N!\\n *      = ((e-2)*N + 1) * N! = (0.718 * N + 1) * N!\\n *\\n * Total Time Complexity = O(N * N!)\\n *\\n * Space Complexity:\\n * -> O(N) for recursion depth\\n * -> O(1) for occupied BitSet\\n *\\n * Total Space Complexity = O(N)\\n *\\n * N = Input board size.\\n */\\nclass Solution {\\n    public int totalNQueens(int n) {\\n        if (n <= 0) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n\\n        return totalNQueensHelper(new BitSet(5 * n), 0, n);\\n    }\\n\\n    private int totalNQueensHelper(BitSet occupied, int row, int n) {\\n        if (row == n) {\\n            return 1;\\n        }\\n\\n        int count = 0;\\n        for (int col = 0; col < n; col++) {\\n            // First N bits are for columns\\n            // Then 2*N bits are for diagonal at 45 degrees\\n            // Then 2*N bits are for diagonal at 135 degrees\\n            int diag45 = n + (row + col);\\n            int diag135 = 3 * n + (n + row - col);\\n            if (occupied.get(col) || occupied.get(diag45) || occupied.get(diag135)) {\\n                continue;\\n            }\\n\\n            occupied.set(col);\\n            occupied.set(diag45);\\n            occupied.set(diag135);\\n\\n            count += totalNQueensHelper(occupied, row + 1, n);\\n\\n            occupied.clear(col);\\n            occupied.clear(diag45);\\n            occupied.clear(diag135);\\n        }\\n\\n        return count;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other N-Queens questions on LeetCode:\\n- [51. N-Queens](https://leetcode.com/problems/n-queens/discuss/1551695/Java-or-TC:-O(N*N!)-or-SC:-O(N)-or-Space-Optimized-Backtracking-using-BitSet)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\n/**\\n * Space Optimized Backtracking\\n *\\n * Total number of permutations can be found by this equation\\n * T(N) = N * T(N-1) + O(N)\\n * T(N-1) = (N-1) * T(N-2) + O(N)\\n * T(N-2) = (N-2) * T(N-3) + O(N)\\n * T(N-3) = (N-3) * T(N-4) + O(N)\\n * ...\\n * T(2) = 2 * T(1) + O(N)\\n * T(1) = O(1)\\n * Thus total number of permutations\\n *      = N * (P(N,0) + P(N,1) + ... + P(N, N-2)) + P(N,N-1)\\n *      = N * (e * N! - P(N,N-1) - P(N,N)) + N!\\n *      = ((e-2)*N + 1) * N! = (0.718 * N + 1) * N!\\n *\\n * Total Time Complexity = O(N * N!)\\n *\\n * Space Complexity:\\n * -> O(N) for recursion depth\\n * -> O(1) for occupied BitSet\\n *\\n * Total Space Complexity = O(N)\\n *\\n * N = Input board size.\\n */\\nclass Solution {\\n    public int totalNQueens(int n) {\\n        if (n <= 0) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n\\n        return totalNQueensHelper(new BitSet(5 * n), 0, n);\\n    }\\n\\n    private int totalNQueensHelper(BitSet occupied, int row, int n) {\\n        if (row == n) {\\n            return 1;\\n        }\\n\\n        int count = 0;\\n        for (int col = 0; col < n; col++) {\\n            // First N bits are for columns\\n            // Then 2*N bits are for diagonal at 45 degrees\\n            // Then 2*N bits are for diagonal at 135 degrees\\n            int diag45 = n + (row + col);\\n            int diag135 = 3 * n + (n + row - col);\\n            if (occupied.get(col) || occupied.get(diag45) || occupied.get(diag135)) {\\n                continue;\\n            }\\n\\n            occupied.set(col);\\n            occupied.set(diag45);\\n            occupied.set(diag135);\\n\\n            count += totalNQueensHelper(occupied, row + 1, n);\\n\\n            occupied.clear(col);\\n            occupied.clear(diag45);\\n            occupied.clear(diag135);\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111511,
                "title": "backtracking-and-bit-manipulation-explained",
                "content": "### Logic:\\nThis problem is essentially the original [N-Queens](https://leetcode.com/problems/n-queens/) problem but made simpler in that we don\\'t need to keep track of board state! Otherwise, the approach is identitical; attempt all valid board states through **backtracking**.\\n\\nSince the explanation still applies, I will use the same diagrammatic explanation as I did in the original N-Queens problem.\\n\\nFirst, we need to understand how a Queen moves and what constitutes a valid position. Queen\\'s can move in literally any straight-lined direction. \\n\\n![image](https://assets.leetcode.com/users/images/b51628d9-0917-45db-a2b7-823ece81a8c1_1654307228.4397633.png)\\n\\nIt\\'s possibe to place a Queen down if and only if:\\n* There exists no Queen on the current row.\\n* There exists no Queen on the current column.\\n* There exists no Queen on the current diagonal.\\n* There exists no Queen on the current anti-diagonal.\\n\\n> Backtracking: Try a promising Queen position, see how it goes. If it fails, undo that Queen and try again somewhere else.\\n\\n![image](https://assets.leetcode.com/users/images/ca380113-d402-4c1e-a21d-a632196a39fd_1654307245.1164281.png)\\n\\n\\nHopefull it\\'s now clear that we need some way to keep track of Queens on previous rows, columns and diagonals. We can take care of rows automatically by incrementing each queen placement by row. In other words, after each successful Queen placement, we move to the next row (since no two Queens can share the same row).\\nWe can keep track of previous columns just by their column indexes. What about the diagonals? Well here\\'s an interesting observation:\\n\\n![image](https://assets.leetcode.com/users/images/e88b8d70-250d-48bd-bf75-ce265e69b7d4_1654307264.8783712.png)\\n\\n\\n(the \"+N\" is to offset negative values. You will see why we do this in the next section). Now we have everything we need to keep track of previous Queens and start thinking about our algorithm! But just one more thing; let\\'s keep track of \"used\" columns and diagonals using bit masks.\\n\\n___\\n### Why Integer Bit Masks?\\nWe prefer integer bitmasks in this question for 2 main reasons:\\n1. Sets in Java are a slow datastructure. So keeping track of visited columns and diagonals using integers is much quicker through bit manipulation!\\n2. It\\'s slightly more space efficient since we\\'re only storing three integers instead of arrays or other datastructures. \\n\\n### Bit Manipulation Tricks\\n1. **Check the ith bit:** `x & (1 << i)`, where `1 << i` is shifting 1 to the left i number of times.\\n\\tFor example, if we want to check if a Queen exists at column 5, we can check if (cols & (1 << 5) != 0). Basically, if we haven\\'t seen a Queen at this column before, then the bitwise AND operation at that specific bit will be 0. Otherwise, it will be a non-zero value.\\n2. **Set the ith bit:** `x |= (1 << i)`. This performs a bitwise OR operation on the ith bit. This will always set the ith bit to 1. For example, if the ith bit in `cols` is currently 1, then 1 | 1 = 1. If it\\'s set to 0, then 0 | 0 is still = 1.\\n3. **Flip the ith bit:** `x ^= (1 << i)` To reverse the previous action, we use the inverse logic of an OR; a bitwise XOR (exclusive-OR).  The basic idea of XOR is that if two bits are the same (0,0) and (1,1), you will get 0. However if the two bits are different (1,0) or (0,1), you get 1. This is the exact opposite of OR, hence the name. \\n___\\n### Code:\\nIf you have any questions, suggestions or improvements, feel free to let me know. Thank you for reading!\\n```java\\nclass Solution {\\n\\tpublic int totalNQueens(int n) {\\n        return backtrack(0, 0, 0, 0, n);\\n    }\\n    \\n    private int backtrack(int row, int cols, int diags, int antiDiags, int N) {\\n\\t\\t// If we\\'re at row N, we\\'ve finished placing all N queens. Therefore, we\\'ve reached a new valid position.\\n        if (row == N) return 1;\\n        \\n        int total = 0;\\n        for (int col=0; col<N; col++) {\\n            int diag = row - col + N;\\n            int antiDiag = row + col;\\n            \\n\\t\\t\\t// Check if it\\'s possible to place a Queen at this point\\n            if ((cols & (1 << col)) != 0 || (diags & (1 << diag)) != 0 || (antiDiags & (1 << antiDiag)) != 0) continue;\\n            \\n\\t\\t\\t// If so, apply changes to the columns and diagonals\\n            cols |= 1 << col;\\n            diags |= 1 << diag;\\n            antiDiags |= 1 << antiDiag;\\n            \\n\\t\\t\\t// Continue to the next row\\n            total += backtrack(row + 1, cols, diags, antiDiags, N);\\n            \\n\\t\\t\\t// Undo changes and try another position\\n            cols ^= 1 << col;\\n            diags ^= 1 << diag;\\n            antiDiags ^= 1 << antiDiag;\\n        }\\n        \\n        return total;\\n    }\\n}\\n```\\n**Time Complexity:** `O(N!)` since we look for every valid board state.\\n**Space Complexity:** `O(N)` due to the recursive call stack.",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```java\\nclass Solution {\\n\\tpublic int totalNQueens(int n) {\\n        return backtrack(0, 0, 0, 0, n);\\n    }\\n    \\n    private int backtrack(int row, int cols, int diags, int antiDiags, int N) {\\n\\t\\t// If we\\'re at row N, we\\'ve finished placing all N queens. Therefore, we\\'ve reached a new valid position.\\n        if (row == N) return 1;\\n        \\n        int total = 0;\\n        for (int col=0; col<N; col++) {\\n            int diag = row - col + N;\\n            int antiDiag = row + col;\\n            \\n\\t\\t\\t// Check if it\\'s possible to place a Queen at this point\\n            if ((cols & (1 << col)) != 0 || (diags & (1 << diag)) != 0 || (antiDiags & (1 << antiDiag)) != 0) continue;\\n            \\n\\t\\t\\t// If so, apply changes to the columns and diagonals\\n            cols |= 1 << col;\\n            diags |= 1 << diag;\\n            antiDiags |= 1 << antiDiag;\\n            \\n\\t\\t\\t// Continue to the next row\\n            total += backtrack(row + 1, cols, diags, antiDiags, N);\\n            \\n\\t\\t\\t// Undo changes and try another position\\n            cols ^= 1 << col;\\n            diags ^= 1 << diag;\\n            antiDiags ^= 1 << antiDiag;\\n        }\\n        \\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718314,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranties of any kind. You can are to use the content as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func totalNQueens(_ n: Int) -> Int {\\n        var res = 0, stack = [(Array(repeating: 0, count: n), 0)]\\n        \\n        while !stack.isEmpty {\\n            var cur = stack.removeLast(), row = cur.0, idx = cur.1\\n            if idx == row.count { res += 1; continue }\\n            for i in 0..<n {\\n                row[idx] = i\\n                if !detect(idx) { stack.append((row, idx + 1)) }\\n            }\\n            func detect(_ i: Int) -> Bool {\\n                var idx = i - 1\\n                while idx >= 0 {\\n                    let lhs = row[idx], rhs = row[i]\\n                    if lhs == rhs || abs(lhs - rhs) == (i - idx) { return true }\\n                    idx -= 1\\n                }\\n                return false\\n            }\\n        }\\n        return res\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.017 (0.019) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // There are two distinct solutions to the 4-queens puzzle as shown.\\n    func test0() {\\n        let value = solution.totalNQueens(4)\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test1() {\\n        let value = solution.totalNQueens(1)\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func totalNQueens(_ n: Int) -> Int {\\n        var res = 0, stack = [(Array(repeating: 0, count: n), 0)]\\n        \\n        while !stack.isEmpty {\\n            var cur = stack.removeLast(), row = cur.0, idx = cur.1\\n            if idx == row.count { res += 1; continue }\\n            for i in 0..<n {\\n                row[idx] = i\\n                if !detect(idx) { stack.append((row, idx + 1)) }\\n            }\\n            func detect(_ i: Int) -> Bool {\\n                var idx = i - 1\\n                while idx >= 0 {\\n                    let lhs = row[idx], rhs = row[i]\\n                    if lhs == rhs || abs(lhs - rhs) == (i - idx) { return true }\\n                    idx -= 1\\n                }\\n                return false\\n            }\\n        }\\n        return res\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // There are two distinct solutions to the 4-queens puzzle as shown.\\n    func test0() {\\n        let value = solution.totalNQueens(4)\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test1() {\\n        let value = solution.totalNQueens(1)\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20094,
                "title": "a-classic-c-solution-using-bitwise-operations-0ms",
                "content": "The code is very short and simple:\\n\\n    int next(int row, unsigned int vertMask, unsigned int leftMask, unsigned int rightMask, unsigned int rangeMask) {\\n        if (row == 0)\\n            return 1;\\n            \\n        unsigned int mask = rangeMask & ~(leftMask | rightMask | vertMask);\\n        int r = 0;\\n        while (mask) {\\n            unsigned int queenFlag = mask & -mask;\\n            r += next(\\n                    row-1, \\n                    (  vertMask | queenFlag ), \\n                    (  leftMask | queenFlag ) << 1, \\n                    ( rightMask | queenFlag ) >> 1, \\n                    rangeMask\\n                );\\n            mask ^= queenFlag;\\n        }\\n        return r;\\n    }\\n\\n    int totalNQueens(int n) {\\n        return next(n, 0, 0, 0, ((unsigned int)-1) >> (32-n));\\n    }\\n    \\n\\nThe main idea is each bit represent a position. If a bit is set to 1, it means this position is unavailable to put a queen into. So with 32-bit integer this way can solve no more than 32-queens problem. \\n\\nAssume current is first row, and N == 5. So rangeMask will be 0b 0001 1111. \\nThis line\\n\\nmask = rangeMask & ~(leftMask | rightMask | vertMask)\\n\\nmake available bits set to 1. So mask = 0b 0001 1111. mask & -mask is a trick to get the lowest 1-bit. Now set a queen at position queenFlag, and try next row.\\n\\nAssume row N has a queen at column 3. The arguments for next(N-1, ...) will be:\\n\\nTo shift left/right queenFlag by 1 will make the positions the queen could attack to set to 1. I set the masks' type to unsigned to avoid signed right shift could cause a bug when N = 32.",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "The code is very short and simple:\\n\\n    int next(int row, unsigned int vertMask, unsigned int leftMask, unsigned int rightMask, unsigned int rangeMask) {\\n        if (row == 0)\\n            return 1;\\n            \\n        unsigned int mask = rangeMask & ~(leftMask | rightMask | vertMask);\\n        int r = 0;\\n        while (mask) {\\n            unsigned int queenFlag = mask & -mask;\\n            r += next(\\n                    row-1, \\n                    (  vertMask | queenFlag ), \\n                    (  leftMask | queenFlag ) << 1, \\n                    ( rightMask | queenFlag ) >> 1, \\n                    rangeMask\\n                );\\n            mask ^= queenFlag;\\n        }\\n        return r;\\n    }\\n\\n    int totalNQueens(int n) {\\n        return next(n, 0, 0, 0, ((unsigned int)-1) >> (32-n));\\n    }\\n    \\n\\nThe main idea is each bit represent a position. If a bit is set to 1, it means this position is unavailable to put a queen into. So with 32-bit integer this way can solve no more than 32-queens problem. \\n\\nAssume current is first row, and N == 5. So rangeMask will be 0b 0001 1111. \\nThis line\\n\\nmask = rangeMask & ~(leftMask | rightMask | vertMask)\\n\\nmake available bits set to 1. So mask = 0b 0001 1111. mask & -mask is a trick to get the lowest 1-bit. Now set a queen at position queenFlag, and try next row.\\n\\nAssume row N has a queen at column 3. The arguments for next(N-1, ...) will be:\\n\\nTo shift left/right queenFlag by 1 will make the positions the queen could attack to set to 1. I set the masks' type to unsigned to avoid signed right shift could cause a bug when N = 32.",
                "codeTag": "Unknown"
            },
            {
                "id": 2114337,
                "title": "java-two-approaches-with-detailed-explanation",
                "content": "**Approach 1:**\\n\\n**Logic:**\\nN-Queens II is just an extension of N-Queens I rather much more easier I have just made a single change in my entire code which is rather than returning the ans array i returned the ans.size as the question asked for it..\\n**Do have a look at my N-Queens I soln which is explained in detail to understand this approach**\\nhttps://leetcode.com/problems/n-queens/discuss/2109925/java-backtracking-detailed-explanation-with-pictures-easycode\\n\\n**Code  -->**\\n```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n        List<List<String>> ans = new ArrayList<List<String>>();\\n        \\n        char arr[][] = new char[n][n];\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n                arr[i][j] = \\'.\\';\\n        \\n        queenTry(ans,arr,0);\\n        return ans.size();\\n    }\\n    private void queenTry(List<List<String>> ans, char[][] arr, int row)\\n    {\\n        if(row == arr.length)\\n        {\\n            ans.add(build(arr));\\n            return;\\n        }\\n        for(int col=0;col<arr.length;col++)\\n        {\\n            if(validatePosition(arr,row,col))\\n            {\\n                arr[row][col] = \\'Q\\';\\n                queenTry(ans,arr,row+1);\\n                arr[row][col] = \\'.\\'; \\n            }\\n        }\\n    }\\n    \\n    private boolean validatePosition(char[][] arr,int row,int col)\\n    {\\n        //checks validity in every row for a single column\\n        for(int i=0;i<row;i++)\\n        {\\n            if(arr[i][col] == \\'Q\\')\\n                return false;\\n        }\\n        //checks for every 45 degree angle\\n        for(int i=row-1,j=col+1;i>=0 && j<arr.length;i--,j++)\\n        {\\n            if(arr[i][j] == \\'Q\\')\\n                return false;\\n        }\\n        //checks for every 135 degree angle\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--)\\n        {\\n            if(arr[i][j] == \\'Q\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    private List<String> build(char arr[][])\\n    {\\n        List<String> val = new ArrayList<>();\\n        for(int i=0;i<arr.length;i++)\\n            val.add(new String(arr[i]));\\n        return val;\\n    }\\n}\\n```\\n\\n**Approach 2:(More Optimized)**\\nHere we create three Sets for every used column index ,used 45degree angle and used 135 degree angle and for every valid position we update the position in the three sets \\n**Logic:**\\n* We continue the above stated idea till we found that the current row is equal to the number of rows in the board\\n* Firstly we iterate through every column if we find the current position of row,col is a valid position we continue the process\\n* We then update the three sets \\n```\\n\\tcolIndex with the col value\\n \\tdegree135 with the row-col value\\n\\tdegree45 with the row+col value\\n```\\n* Then we call the same function recursively and then remove the values which were added in the sets\\n\\n**Helper methods used-->**\\n**validCounter -->** places the queen at valid positions and then calls the validPosition function to check for validity and then update it in the set and recursively calls itself\\n**validPosition -->** checks whether the queen can be placed at that position or not\\n\\n**Code -->**\\n**Java**\\n```\\nclass Solution {\\n    \\n    private Set<Integer> colIndex = new HashSet<Integer>();\\n    private Set<Integer> degree45 = new HashSet<Integer>();\\n    private Set<Integer> degree135 = new HashSet<Integer>();\\n    \\n    private int count = 0;\\n    \\n    public int totalNQueens(int n) {\\n        validCounter(n,0);\\n        return count;\\n    }\\n    \\n    public void validCounter(int n, int row)\\n    {\\n        if(row == n)\\n        {\\n            count++;\\n            return;\\n        }\\n        else\\n        {\\n            for(int col=0;col<n;col++)\\n            {\\n                if(validPosition(row,col))\\n                {\\n                    colIndex.add(col);\\n                    degree135.add(row-col);\\n                    degree45.add(row+col);\\n                    \\n                    validCounter(n,row+1);  //recursive calling\\n                    \\n                    colIndex.remove(col);\\n                    degree135.remove(row-col);\\n                    degree45.remove(row+col);\\n                }\\n            }\\n        }\\n    }\\n    private boolean validPosition(int row,int col)\\n    {\\n        if(colIndex.contains(col) || degree135.contains(row-col) || degree45.contains(row+col))\\n            return false;\\n        else\\n            return true;\\n    }\\n}\\n```\\n\\n**Upvote if this helped**",
                "solutionTags": [
                    "Java",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n        List<List<String>> ans = new ArrayList<List<String>>();\\n        \\n        char arr[][] = new char[n][n];\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n                arr[i][j] = \\'.\\';\\n        \\n        queenTry(ans,arr,0);\\n        return ans.size();\\n    }\\n    private void queenTry(List<List<String>> ans, char[][] arr, int row)\\n    {\\n        if(row == arr.length)\\n        {\\n            ans.add(build(arr));\\n            return;\\n        }\\n        for(int col=0;col<arr.length;col++)\\n        {\\n            if(validatePosition(arr,row,col))\\n            {\\n                arr[row][col] = \\'Q\\';\\n                queenTry(ans,arr,row+1);\\n                arr[row][col] = \\'.\\'; \\n            }\\n        }\\n    }\\n    \\n    private boolean validatePosition(char[][] arr,int row,int col)\\n    {\\n        //checks validity in every row for a single column\\n        for(int i=0;i<row;i++)\\n        {\\n            if(arr[i][col] == \\'Q\\')\\n                return false;\\n        }\\n        //checks for every 45 degree angle\\n        for(int i=row-1,j=col+1;i>=0 && j<arr.length;i--,j++)\\n        {\\n            if(arr[i][j] == \\'Q\\')\\n                return false;\\n        }\\n        //checks for every 135 degree angle\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--)\\n        {\\n            if(arr[i][j] == \\'Q\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    private List<String> build(char arr[][])\\n    {\\n        List<String> val = new ArrayList<>();\\n        for(int i=0;i<arr.length;i++)\\n            val.add(new String(arr[i]));\\n        return val;\\n    }\\n}\\n```\n```\\n\\tcolIndex with the col value\\n \\tdegree135 with the row-col value\\n\\tdegree45 with the row+col value\\n```\n```\\nclass Solution {\\n    \\n    private Set<Integer> colIndex = new HashSet<Integer>();\\n    private Set<Integer> degree45 = new HashSet<Integer>();\\n    private Set<Integer> degree135 = new HashSet<Integer>();\\n    \\n    private int count = 0;\\n    \\n    public int totalNQueens(int n) {\\n        validCounter(n,0);\\n        return count;\\n    }\\n    \\n    public void validCounter(int n, int row)\\n    {\\n        if(row == n)\\n        {\\n            count++;\\n            return;\\n        }\\n        else\\n        {\\n            for(int col=0;col<n;col++)\\n            {\\n                if(validPosition(row,col))\\n                {\\n                    colIndex.add(col);\\n                    degree135.add(row-col);\\n                    degree45.add(row+col);\\n                    \\n                    validCounter(n,row+1);  //recursive calling\\n                    \\n                    colIndex.remove(col);\\n                    degree135.remove(row-col);\\n                    degree45.remove(row+col);\\n                }\\n            }\\n        }\\n    }\\n    private boolean validPosition(int row,int col)\\n    {\\n        if(colIndex.contains(col) || degree135.contains(row-col) || degree45.contains(row+col))\\n            return false;\\n        else\\n            return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111563,
                "title": "python-explained",
                "content": "**UPVOTE IF HELPFUL**\\n\\nWe first create a **( n X n )** chess board and assign **0** to every index.\\nWhenever a queen will be placed, index will be made **1**.\\n\\nIn this approach , we fill queens **column-wise** starting from left side.\\n\\nWhenever a queen is placed, at first it is checked if it satisfies the conditions given that it is not under attack.\\n\\n**validMove** function.\\nFirst it check there are no other queen in row the queen is filled.\\nAs we are putting queen column wise so no need to check for column.\\nThen there are two diagonals to check for.\\n* Only left part of the diagonals are checked as positions to the right of the present column are still unfilled.\\n\\nIf conditions satisfied, Queen is placed and we move to next column.\\nIf no queen satisfy the problem, we backtrack and try to change the position of previous queen.\\n\\n**UPVOTE IF HELPFUL**\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> List[List[str]]:\\n        def validMove(board,row,col):\\n            i=col\\n            while i>=0:\\n                if board[row][i]:\\n                    return False\\n                i-=1\\n            i=row\\n            j=col\\n            while (i>=0 and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i-=1\\n                j-=1\\n            i=row\\n            j=col\\n            while (i<n and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        def solve(board,col):\\n            if (col==n):\\n                res[0]+=1\\n                return\\n            for i in range(n):\\n                if validMove(board,i,col):\\n                    board[i][col]=1\\n                    solve(board,col+1)\\n                    board[i][col]=0\\n            return\\n        \\n        res=[0]\\n        board=[]\\n        for i in range(n):\\n            board.append([])\\n            for j in range(n):\\n                board[-1].append(0)\\n        solve(board,0)\\n        return res[0]\\n```\\n![image](https://assets.leetcode.com/users/images/2411afa6-d051-4373-b850-dc589989c8bf_1654391362.3126545.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> List[List[str]]:\\n        def validMove(board,row,col):\\n            i=col\\n            while i>=0:\\n                if board[row][i]:\\n                    return False\\n                i-=1\\n            i=row\\n            j=col\\n            while (i>=0 and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i-=1\\n                j-=1\\n            i=row\\n            j=col\\n            while (i<n and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        def solve(board,col):\\n            if (col==n):\\n                res[0]+=1\\n                return\\n            for i in range(n):\\n                if validMove(board,i,col):\\n                    board[i][col]=1\\n                    solve(board,col+1)\\n                    board[i][col]=0\\n            return\\n        \\n        res=[0]\\n        board=[]\\n        for i in range(n):\\n            board.append([])\\n            for j in range(n):\\n                board[-1].append(0)\\n        solve(board,0)\\n        return res[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909458,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func totalNQueens(_ n: Int) -> Int {\\n        var res: [[Int]] = []\\n        \\n        func backtarck(_ path: [Int]) {\\n            if path.count == n { res.append(path) }\\n            \\n            var path = path\\n            var available: [Int] = []\\n            for i in 0..<n { available.append(i) }\\n            \\n            for (i, val) in path.enumerated() {\\n                \\n                if let index = available.firstIndex(of: val - path.count + i) {\\n                    available.remove(at: index)\\n                }\\n                \\n                if let index = available.firstIndex(of: val) {\\n                    available.remove(at: index)\\n                }\\n                \\n                if let index = available.firstIndex(of: val + path.count - i) {\\n                    available.remove(at: index)\\n                }\\n            }\\n            \\n            for i in 0..<n {\\n                if available.contains(i) == false { continue }\\n                path.append(i)\\n                backtarck(path)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        backtarck([])\\n        \\n        return res.count\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func totalNQueens(_ n: Int) -> Int {\\n        var res: [[Int]] = []\\n        \\n        func backtarck(_ path: [Int]) {\\n            if path.count == n { res.append(path) }\\n            \\n            var path = path\\n            var available: [Int] = []\\n            for i in 0..<n { available.append(i) }\\n            \\n            for (i, val) in path.enumerated() {\\n                \\n                if let index = available.firstIndex(of: val - path.count + i) {\\n                    available.remove(at: index)\\n                }\\n                \\n                if let index = available.firstIndex(of: val) {\\n                    available.remove(at: index)\\n                }\\n                \\n                if let index = available.firstIndex(of: val + path.count - i) {\\n                    available.remove(at: index)\\n                }\\n            }\\n            \\n            for i in 0..<n {\\n                if available.contains(i) == false { continue }\\n                path.append(i)\\n                backtarck(path)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        backtarck([])\\n        \\n        return res.count\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367756,
                "title": "java-backtracking-solution",
                "content": "```\\nclass Solution {\\n    public int cnt=0;\\n    public int totalNQueens(int n) {\\n        char Board[][]=new char[n][n];\\n        for(int i=0;i<n;i++)\\n        {\\n            for (int j = 0; j < n; j++) \\n            {\\n                Board[i][j] = \\'.\\';\\n            }\\n        }\\n        placeQueen(n,Board,0);\\n        return cnt;\\n    }\\n    public void placeQueen(int n, char Board[][],int row)\\n    {\\n        //Base Case\\n        if(row==n)\\n        {\\n            cnt++;\\n            return;\\n        }\\n         for(int col=0;col<n;col++)\\n         {\\n             if(canPlaceQueen(n,Board,row, col))\\n             {\\n                 Board[row][col]=\\'Q\\';\\n                 placeQueen(n,Board,row+1);\\n                 Board[row][col]=\\'.\\';\\n             }\\n         }\\n        \\n    }\\n    public Boolean canPlaceQueen(int n,char Board[][],int row, int col)\\n    {\\n       // check all rows for the current column\\n        for (int i = 0; i < row; i++) \\n        {\\n            if (Board[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n\\n        //check for 45 degree positions\\n        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\\n            if (Board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        //check for 135 positions\\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\\n            if (Board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public int cnt=0;\\n    public int totalNQueens(int n) {\\n        char Board[][]=new char[n][n];\\n        for(int i=0;i<n;i++)\\n        {\\n            for (int j = 0; j < n; j++) \\n            {\\n                Board[i][j] = \\'.\\';\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 470018,
                "title": "c-100-speed-100-space-o-1-solution",
                "content": "\\tclass Solution {  \\n\\tprivate:\\n\\t\\tint res;\\n\\tpublic:\\n\\t\\tvoid dfs(int n,int dep,int r,int d1, int d2){\\n\\t\\t\\tif(dep==n){\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tint cur=1<<i;\\n\\t\\t\\t\\tif((cur&r) || (cur&d1) || (cur&d2)) continue;\\n\\t\\t\\t\\tdfs(n,dep+1, (cur|r),(cur|d1)<<1,(cur|d2)>>1);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tint totalNQueens(int n) {\\n\\t\\t\\tres=0;\\n\\t\\t\\tdfs(n,0,0,0,0);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {  \\n\\tprivate:\\n\\t\\tint res;\\n\\tpublic:\\n\\t\\tvoid dfs(int n,int dep,int r,int d1, int d2){\\n\\t\\t\\tif(dep==n){\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1237765,
                "title": "python-backtracking-clean-concise-o-n",
                "content": "**Python 3**\\n```python\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def backtrack(c, rowSet, mainDiagSet, antiDiagSet):\\n            nonlocal ans\\n            if c == n:\\n                ans += 1\\n                return\\n            for r in range(n):\\n                if r not in rowSet and (r-c) not in mainDiagSet and (r+c) not in antiDiagSet:\\n                    rowSet.add(r)\\n                    mainDiagSet.add(r-c)\\n                    antiDiagSet.add(r+c)\\n                    backtrack(c + 1, rowSet, mainDiagSet, antiDiagSet)\\n                    rowSet.remove(r)\\n                    mainDiagSet.remove(r-c)\\n                    antiDiagSet.remove(r+c)\\n            \\n        ans = 0\\n        backtrack(0, set(), set(), set())\\n        return ans\\n```\\n\\n**Complexity**\\n- Time: `O(N!)`\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def backtrack(c, rowSet, mainDiagSet, antiDiagSet):\\n            nonlocal ans\\n            if c == n:\\n                ans += 1\\n                return\\n            for r in range(n):\\n                if r not in rowSet and (r-c) not in mainDiagSet and (r+c) not in antiDiagSet:\\n                    rowSet.add(r)\\n                    mainDiagSet.add(r-c)\\n                    antiDiagSet.add(r+c)\\n                    backtrack(c + 1, rowSet, mainDiagSet, antiDiagSet)\\n                    rowSet.remove(r)\\n                    mainDiagSet.remove(r-c)\\n                    antiDiagSet.remove(r+c)\\n            \\n        ans = 0\\n        backtrack(0, set(), set(), set())\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544297,
                "title": "javascript-48ms-backtracking",
                "content": "- Time Complexity: O(N!)\\n- Space Complexity: O(N)\\n```JavaScript\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar totalNQueens = function(n) {\\n    const cols = new Set(),\\n          hills = new Set(),\\n          dales = new Set();\\n    /**\\n     * @param {number} row\\n     * @param {number} col\\n     * @return {boolean}\\n     */\\n    const isSafe = (row, col) => !(cols.has(col) || hills.has(row - col) || dales.has(row + col));\\n    \\n    /**\\n     * @param {number} row\\n     * @param {number} col\\n     * @return {void}\\n     */\\n    const placeQueen = (row, col) => {\\n        cols.add(col), hills.add(row - col), dales.add(row + col);\\n    }\\n    \\n    /**\\n     * @param {number} row\\n     * @param {number} col\\n     * @return {void}\\n     */\\n    const removeQueen = (row, col) => {\\n        cols.delete(col), hills.delete(row - col), dales.delete(row + col);\\n    }\\n    \\n    /**\\n     * @param {number} row\\n     * @param {number} count\\n     * @return {number}\\n     */\\n    const backtrackQueen = (row, count) => {\\n        if (row === n) {\\n            return ++count;\\n        }\\n        for (let col = 0; col < n; col++) {\\n            if (isSafe(row, col)) {\\n                placeQueen(row, col);\\n                count = backtrackQueen(row + 1, count);\\n                removeQueen(row, col);\\n            }\\n        }\\n        return count;\\n    }\\n    return backtrackQueen(0, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```JavaScript\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar totalNQueens = function(n) {\\n    const cols = new Set(),\\n          hills = new Set(),\\n          dales = new Set();\\n    /**\\n     * @param {number} row\\n     * @param {number} col\\n     * @return {boolean}\\n     */\\n    const isSafe = (row, col) => !(cols.has(col) || hills.has(row - col) || dales.has(row + col));\\n    \\n    /**\\n     * @param {number} row\\n     * @param {number} col\\n     * @return {void}\\n     */\\n    const placeQueen = (row, col) => {\\n        cols.add(col), hills.add(row - col), dales.add(row + col);\\n    }\\n    \\n    /**\\n     * @param {number} row\\n     * @param {number} col\\n     * @return {void}\\n     */\\n    const removeQueen = (row, col) => {\\n        cols.delete(col), hills.delete(row - col), dales.delete(row + col);\\n    }\\n    \\n    /**\\n     * @param {number} row\\n     * @param {number} count\\n     * @return {number}\\n     */\\n    const backtrackQueen = (row, count) => {\\n        if (row === n) {\\n            return ++count;\\n        }\\n        for (let col = 0; col < n; col++) {\\n            if (isSafe(row, col)) {\\n                placeQueen(row, col);\\n                count = backtrackQueen(row + 1, count);\\n                removeQueen(row, col);\\n            }\\n        }\\n        return count;\\n    }\\n    return backtrackQueen(0, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111576,
                "title": "java-clean-easy-explained",
                "content": "**UPVOTE IF HELPFUL**\\n\\nWe first create a **( n X n )** chess board and assign **0** to every index.\\nWhenever a queen will be placed, index will be made **1**.\\n\\nIn this approach ,\\n\\nWhenever a queen is placed, at first it is checked if it satisfies the conditions given that it is not under attack.\\n\\n**validMove** function.\\nFirst it check there are no other queen in row the queen is filled.\\nAs we are putting queen column wise so no need to check for column.\\nThen there are two diagonals to check for.\\n* **COLUMN_WISE** FILLING = Only left part of the diagonals are checked as positions to the right of the present column are still unfilled.\\n*  **ROW_WISE** FILLING = Only upper part of the diagonals are checked as positions below of the present column are still unfilled.\\n\\nIf conditions satisfied, Queen is placed and we move to next column.\\nIf no queen satisfy the problem, we backtrack and try to change the position of previous queen.\\n\\n\\n**UPVOTE IF HELPFUL**\\n```\\npublic class Solution {\\n    int count = 0;\\n    \\n    public int totalNQueens(int n) {\\n        dfs(0, n, 0, 0, 0);\\n        return count;\\n    }\\n    \\n    private void dfs(int row, int n, int column, int diag, int antiDiag) {\\n        if (row == n) {\\n            ++count;\\n            return;\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            boolean isColSafe = ((1 << i) & column) == 0;\\n            boolean isDiagSafe = ((1 << (n - 1 + row - i)) & diag) == 0;\\n            boolean isAntiDiagSafe = ((1 << (row + i)) & antiDiag) == 0;\\n            if (isColSafe && isDiagSafe && isAntiDiagSafe) {\\n                dfs(row + 1, n, (1 << i) | column, (1 << (n - 1 + row - i)) | diag, (1 << (row + i)) | antiDiag);\\n            }\\n        }\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/5dec5b54-2976-4bb0-9569-fea033425a49_1654392303.9171877.jpeg)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    int count = 0;\\n    \\n    public int totalNQueens(int n) {\\n        dfs(0, n, 0, 0, 0);\\n        return count;\\n    }\\n    \\n    private void dfs(int row, int n, int column, int diag, int antiDiag) {\\n        if (row == n) {\\n            ++count;\\n            return;\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            boolean isColSafe = ((1 << i) & column) == 0;\\n            boolean isDiagSafe = ((1 << (n - 1 + row - i)) & diag) == 0;\\n            boolean isAntiDiagSafe = ((1 << (row + i)) & antiDiag) == 0;\\n            if (isColSafe && isDiagSafe && isAntiDiagSafe) {\\n                dfs(row + 1, n, (1 << i) | column, (1 << (n - 1 + row - i)) | diag, (1 << (row + i)) | antiDiag);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413249,
                "title": "my-easy-understand-n-queens-solutions-in-java",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/n-queens/)\\nDifficulty: <span class=\"red\">Hard</span>\\n\\n\\n\\n## Problem\\n\\n> The n-queens puzzle is the problem of placing `n` queens on an `n\\xD7n` chessboard such that no two queens attack each other.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/rk4qd.jpg \"From LeetCode\")\\n\\n> Given an integer `n`, return all distinct solutions to the n-queens puzzle.\\n\\n> Each solution contains a distinct board configuration of the n-queens\\' placement, where `Q` and `.` both indicate a queen and an empty space respectively.\\n\\n**Note:** A queen can attack other queens that are at the same `row` or `column` or at the `diagonal` line.\\n\\n**Example:** \\n\\n```java\\nInput: 4\\nOutput: [\\n [\".Q..\",  // Solution 1\\n  \"...Q\",\\n  \"Q...\",\\n  \"..Q.\"],\\n\\n [\"..Q.\",  // Solution 2\\n  \"Q...\",\\n  \"...Q\",\\n  \".Q..\"]\\n]\\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above.\\n```\\n\\n## Analysis\\n\\n### Brute-Force\\n\\nEnumerate all possible placements of queens on a `nxn` chessboard and check if each is valid.\\n\\n**Time:** `O(N^N)`\\n**Space:** `O(1)` if we do not consider the output list.\\n\\n\\n### Backtracking\\n\\nThe basic idea is to examine each row and use an array `attack` to restrict the possibilities in the future searching.\\n\\nCheck out the comments. Be careful about the following aspects:\\n\\n- Why will we stop? In other words, what is the base case?\\n- How do we make string generation more efficiently? `StringBuilder`\\n- Why should we initialize `attack` array with `int` type rather than `boolean`?\\n\\n```java\\npublic List<List<String>> solveNQueens(int n) {\\n  List<List<String>> result = new ArrayList<>();\\n  List<Integer> queens = new ArrayList<>(); // store (i, j) where to place queens\\n  int[][] attack = new int[n][n];  // > 0 -> could be attacked\\n  backtrack(0, n, queens, attack, result);\\n  return result;\\n}\\n\\n// d is the depth (here it means the current row)\\n// queens stores the col of a placed queen\\nprivate void backtrack(int d, int n, List<Integer> queens, int[][] attack, List<List<String>> result) {\\n  // base case\\n  if (d == n) {\\n    // Init dot builder\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = 0; i < n; ++i) sb.append(\".\");\\n    // Set queen\\n    List<String> strList = new ArrayList<>();\\n    for (int row = 0; row < n; ++row) {\\n      int col = queens.get(row);\\n      sb.setCharAt(col, \\'Q\\');\\n      strList.add(sb.toString());\\n      sb.setCharAt(col, \\'.\\');\\n    }\\n    result.add(strList);\\n    return;\\n  }\\n  // backtrack\\n  for (int i = 0; i < n; ++i) {\\n    if (attack[d][i] == 0) {\\n      // pick\\n      queens.add(i);\\n      updateAttack(d, i, n, attack);\\n      backtrack(d + 1, n, queens, attack, result);\\n      // restore\\n      queens.remove(queens.size() - 1);\\n      restoreAttack(d, i, n, attack);\\n    }\\n  }\\n}\\n```\\n\\nThe graph is from LeetCode solution section.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/1sasw.jpg)\\n\\nEach time we pick a queen `(i, j)` we need to update all the attacked positions below it, which include three cases as shown in the graph:\\n\\n- Left-Below positions\\n- Below positions\\n- Right-Below positions\\n\\nNotice that we cannot use `boolean` since some attacked positions might be overlapped.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/owjlb.png)\\n\\nIn the example above, when we restore attacked position for queen `B`, the orange position will be restored to no-attack state if we use `true/false`; however, it is still under attack by queen `A`.\\n\\n```java\\nprivate void updateAttack(int i, int j, int n, int[][] attack) {\\n  // update all below/hill/dale positions by +1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] += 1; // mid\\n    if (j - offset >= 0) attack[k][j - offset] += 1; // left\\n    if (j + offset < n) attack[k][j + offset] += 1; // right\\n  }\\n}\\n\\nprivate void restoreAttack(int i, int j, int n, int[][] attack) {\\n  // restore all below/hill/dale positions by -1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] -= 1;\\n    if (j - offset >= 0) attack[k][j - offset] -= 1; // left\\n    if (j + offset < n) attack[k][j + offset] -= 1; // right\\n  }\\n}\\n```\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/a2rtf.jpg)\\n\\n**Time:** `O(N x N!)`. There is `N` possibilities to put the first queen, then no more than `N(N-2)` to put the second one, and no more than `N(N-2)(N-4)` to put the third one, and so forth. In total, there are `N` layers. The number of calls of `backtracking` at each layer is upper bounded by `N!`. (not consider string construction)\\n**Space:** `O(N^2)` since there are call stacks and `attack` array (do not consider output).\\n\\nThe space complexity can be optimized by using `N`-size array `rows`, `dale`, and `hill`. Each element of them denotes a specific vertical line or diagonal line that a queen can attack.\\n\\nFrom LeetCode solution section:\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/oujkh.jpg)\\n\\n\\n\\n\\n## N-Queens II\\n\\nReturns the number of solutions. Modify based on the above solution.\\n\\n```java\\npublic int totalNQueens(int n) {\\n  int[][] attack = new int[n][n];  // > 0 -> could be attacked\\n  return backtrack(0, n, attack);\\n}\\n\\n// d is the depth (here it means the current row)\\nprivate int backtrack(int d, int n, int[][] attack) {\\n  // base case\\n  if (d == n) {\\n    return 1;\\n  }\\n  // backtrack\\n  int count = 0;\\n  for (int i = 0; i < n; ++i) {\\n    if (attack[d][i] == 0) {\\n      updateAttack(d, i, n, attack);\\n      count += backtrack(d + 1, n, attack);\\n      restoreAttack(d, i, n, attack);\\n    }\\n  }\\n  return count;\\n}\\n\\n\\nprivate void updateAttack(int i, int j, int n, int[][] attack) {\\n  // update all below/hill/dale positions by +1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] += 1; // mid\\n    if (j - offset >= 0) attack[k][j - offset] += 1; // left\\n    if (j + offset < n) attack[k][j + offset] += 1; // right\\n  }\\n}\\n\\nprivate void restoreAttack(int i, int j, int n, int[][] attack) {\\n  // restore all below/hill/dale positions by -1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] -= 1;\\n    if (j - offset >= 0) attack[k][j - offset] -= 1; // left\\n    if (j + offset < n) attack[k][j + offset] -= 1; // right\\n  }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```java\\nInput: 4\\nOutput: [\\n [\".Q..\",  // Solution 1\\n  \"...Q\",\\n  \"Q...\",\\n  \"..Q.\"],\\n\\n [\"..Q.\",  // Solution 2\\n  \"Q...\",\\n  \"...Q\",\\n  \".Q..\"]\\n]\\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above.\\n```\n```java\\npublic List<List<String>> solveNQueens(int n) {\\n  List<List<String>> result = new ArrayList<>();\\n  List<Integer> queens = new ArrayList<>(); // store (i, j) where to place queens\\n  int[][] attack = new int[n][n];  // > 0 -> could be attacked\\n  backtrack(0, n, queens, attack, result);\\n  return result;\\n}\\n\\n// d is the depth (here it means the current row)\\n// queens stores the col of a placed queen\\nprivate void backtrack(int d, int n, List<Integer> queens, int[][] attack, List<List<String>> result) {\\n  // base case\\n  if (d == n) {\\n    // Init dot builder\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = 0; i < n; ++i) sb.append(\".\");\\n    // Set queen\\n    List<String> strList = new ArrayList<>();\\n    for (int row = 0; row < n; ++row) {\\n      int col = queens.get(row);\\n      sb.setCharAt(col, \\'Q\\');\\n      strList.add(sb.toString());\\n      sb.setCharAt(col, \\'.\\');\\n    }\\n    result.add(strList);\\n    return;\\n  }\\n  // backtrack\\n  for (int i = 0; i < n; ++i) {\\n    if (attack[d][i] == 0) {\\n      // pick\\n      queens.add(i);\\n      updateAttack(d, i, n, attack);\\n      backtrack(d + 1, n, queens, attack, result);\\n      // restore\\n      queens.remove(queens.size() - 1);\\n      restoreAttack(d, i, n, attack);\\n    }\\n  }\\n}\\n```\n```java\\nprivate void updateAttack(int i, int j, int n, int[][] attack) {\\n  // update all below/hill/dale positions by +1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] += 1; // mid\\n    if (j - offset >= 0) attack[k][j - offset] += 1; // left\\n    if (j + offset < n) attack[k][j + offset] += 1; // right\\n  }\\n}\\n\\nprivate void restoreAttack(int i, int j, int n, int[][] attack) {\\n  // restore all below/hill/dale positions by -1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] -= 1;\\n    if (j - offset >= 0) attack[k][j - offset] -= 1; // left\\n    if (j + offset < n) attack[k][j + offset] -= 1; // right\\n  }\\n}\\n```\n```java\\npublic int totalNQueens(int n) {\\n  int[][] attack = new int[n][n];  // > 0 -> could be attacked\\n  return backtrack(0, n, attack);\\n}\\n\\n// d is the depth (here it means the current row)\\nprivate int backtrack(int d, int n, int[][] attack) {\\n  // base case\\n  if (d == n) {\\n    return 1;\\n  }\\n  // backtrack\\n  int count = 0;\\n  for (int i = 0; i < n; ++i) {\\n    if (attack[d][i] == 0) {\\n      updateAttack(d, i, n, attack);\\n      count += backtrack(d + 1, n, attack);\\n      restoreAttack(d, i, n, attack);\\n    }\\n  }\\n  return count;\\n}\\n\\n\\nprivate void updateAttack(int i, int j, int n, int[][] attack) {\\n  // update all below/hill/dale positions by +1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] += 1; // mid\\n    if (j - offset >= 0) attack[k][j - offset] += 1; // left\\n    if (j + offset < n) attack[k][j + offset] += 1; // right\\n  }\\n}\\n\\nprivate void restoreAttack(int i, int j, int n, int[][] attack) {\\n  // restore all below/hill/dale positions by -1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] -= 1;\\n    if (j - offset >= 0) attack[k][j - offset] -= 1; // left\\n    if (j + offset < n) attack[k][j + offset] -= 1; // right\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20114,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "    class Solution {\\n    public:\\n        int totalNQueens(int n) {\\n            int result=0;\\n            vector<int> solution(n);\\n            help(n, 0, solution, result);\\n            return result;\\n        }\\n        /** n:#-of-rows   row:current-#-of-row  solution:store-n-row's-col-index result:final result**/\\n        void help(int n, int row, vector<int>& solution, int& result){\\n            for(int i=0; i<n; i++){\\n                if(check(i, row, solution)){\\n                    if(row+1==n){\\n                        result++;\\n                        continue;\\n                    }\\n                    solution[row]=i;\\n                    help(n, row+1, solution, result);\\n                }\\n            }\\n        }\\n        /*** check the cur-col-choise is valid or not **/\\n        bool check(int col, int row, vector<int>& solution){\\n            for(int i=0; i<row; i++){\\n                if(col==solution[i] || abs(col-solution[i])==abs(row-i))  \\n                    return false;\\n            }\\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int totalNQueens(int n) {\\n            int result=0;\\n            vector<int> solution(n);\\n            help(n, 0, solution, result);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 20128,
                "title": "shortest-c-solution-in-0ms",
                "content": "Idea is to  use vectors to keep track of invalid positions , so validity can be checked in O(1) and put a queen in each column\\n     \\n    #include<vector>\\n    using namespace std;\\n    class Solution {\\n    public:\\n        int find(int n, int left, int i, int r, vector<int>&rows,vector<int>&d1,vector<int>&d2){\\n            if (left == 0)\\n                return 1;\\n            int j,sum=0;\\n                for (j=r; j<n; j++){\\n                    if (rows[j] || d1[i+j] || d2[n-1+i-j])\\n                        continue;\\n                    rows[j]=d1[i+j]=d2[n-1+i-j]=1;\\n                    sum += find(n, left-1, i+1, 0,rows,d1,d2 );\\n                    rows[j]=d1[i+j]=d2[n-1+i-j]=0;\\n                }\\n            return sum;\\n        }\\n        int totalNQueens(int n) {\\n            vector<int>  rows(n),d1(2*n-1),d2(2*n-1);\\n            return find(n,n,0,0,rows,d1,d2);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int find(int n, int left, int i, int r, vector<int>&rows,vector<int>&d1,vector<int>&d2){\\n            if (left == 0)\\n                return 1;\\n            int j,sum=0;\\n                for (j=r; j<n; j++){\\n                    if (rows[j] || d1[i+j] || d2[n-1+i-j])\\n                        continue;\\n                    rows[j]=d1[i+j]=d2[n-1+i-j]=1;\\n                    sum += find(n, left-1, i+1, 0,rows,d1,d2 );\\n                    rows[j]=d1[i+j]=d2[n-1+i-j]=0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3315464,
                "title": "backtracking-logic-solution",
                "content": "\\n\\n# 1. BackTracking Logic Solution\\n\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        res,col,pos,neg=0,set(),set(),set()\\n        def backtracking(r):\\n            if n==r:\\n                nonlocal res\\n                res+=1\\n            for c in range(n):\\n                if c in col or (c+r) in pos or (r-c) in neg:\\n                    continue\\n                col.add(c)\\n                pos.add(c+r)\\n                neg.add(r-c)\\n                backtracking(r+1)\\n                col.remove(c)\\n                pos.remove(c+r)\\n                neg.remove(r-c)\\n        backtracking(0)\\n        return res\\n    #please upvote me it would encourage me alot\\n\\n\\n```\\n\\n#   please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        res,col,pos,neg=0,set(),set(),set()\\n        def backtracking(r):\\n            if n==r:\\n                nonlocal res\\n                res+=1\\n            for c in range(n):\\n                if c in col or (c+r) in pos or (r-c) in neg:\\n                    continue\\n                col.add(c)\\n                pos.add(c+r)\\n                neg.add(r-c)\\n                backtracking(r+1)\\n                col.remove(c)\\n                pos.remove(c+r)\\n                neg.remove(r-c)\\n        backtracking(0)\\n        return res\\n    #please upvote me it would encourage me alot\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115356,
                "title": "c-backtracking-simple",
                "content": "```\\nvoid fun(vector<vector<string>>& ans, vector<string>& temp, int r, set<int>& c, set<int>& d1, set<int>& d2, int n) {\\n        \\n        if(r == n) {\\n           ans.push_back(temp); \\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            if(c.find(i) == c.end() && d1.find(r-i) == d1.end() && d2.find(r+i) == d2.end()) {\\n                \\n                c.insert(i); d1.insert(r-i); d2.insert(r+i);\\n                \\n                temp[r][i] = \\'Q\\';\\n                fun(ans, temp, r+1, c, d1, d2, n);\\n                temp[r][i] = \\'.\\';\\n                \\n                c.erase(i); d1.erase(r-i); d2.erase(r+i);\\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n        set<int> c, d1, d2;\\n        string dots = \"\";\\n        for(int i=0;i<n;i++) dots.push_back(\\'.\\');\\n        \\n        vector<string> temp(n, dots);\\n        vector<vector<string>> ans;\\n        fun(ans, temp, 0, c, d1, d2, n);\\n        \\n        return ans.size();\\n    }",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvoid fun(vector<vector<string>>& ans, vector<string>& temp, int r, set<int>& c, set<int>& d1, set<int>& d2, int n) {\\n        \\n        if(r == n) {\\n           ans.push_back(temp); \\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            if(c.find(i) == c.end() && d1.find(r-i) == d1.end() && d2.find(r+i) == d2.end()) {\\n                \\n                c.insert(i); d1.insert(r-i); d2.insert(r+i);\\n                \\n                temp[r][i] = \\'Q\\';\\n                fun(ans, temp, r+1, c, d1, d2, n);\\n                temp[r][i] = \\'.\\';\\n                \\n                c.erase(i); d1.erase(r-i); d2.erase(r+i);\\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n        set<int> c, d1, d2;\\n        string dots = \"\";\\n        for(int i=0;i<n;i++) dots.push_back(\\'.\\');\\n        \\n        vector<string> temp(n, dots);\\n        vector<vector<string>> ans;\\n        fun(ans, temp, 0, c, d1, d2, n);\\n        \\n        return ans.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2114396,
                "title": "easy-recursive-solution",
                "content": "```csharp\\npublic int TotalNQueens(int n)\\n{\\n\\tint count = 0;\\n\\tvar rows = new bool[n];\\n\\tvar diag1 = new bool[2 * n];\\n\\tvar diag2 = new bool[2 * n];\\n\\n\\tHelper(0); // start with the first column\\n\\n\\treturn count;\\n\\n\\tvoid Helper(int col)\\n\\t{\\n\\t\\tif (col == n) count++; // successfully placed n queens\\n\\t\\t// in case col == n, we could return right away, but it is also alright to go on\\n\\n\\t\\tfor (int row = 0; row < n; row++)\\n\\t\\t{\\n\\t\\t\\tint a = row + col;\\n\\t\\t\\tint b = row - col + n;\\n\\n\\t\\t\\tif (rows[row] || diag1[a] || diag2[b]) continue; // unable to place a queen\\n\\n\\t\\t\\trows[row] = diag1[a] = diag2[b] = true;  // place a queen\\n\\t\\t\\tHelper(col + 1);                         // go to the next column\\n\\t\\t\\trows[row] = diag1[a] = diag2[b] = false; // remove the queen\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Recursion"
                ],
                "code": "```csharp\\npublic int TotalNQueens(int n)\\n{\\n\\tint count = 0;\\n\\tvar rows = new bool[n];\\n\\tvar diag1 = new bool[2 * n];\\n\\tvar diag2 = new bool[2 * n];\\n\\n\\tHelper(0); // start with the first column\\n\\n\\treturn count;\\n\\n\\tvoid Helper(int col)\\n\\t{\\n\\t\\tif (col == n) count++; // successfully placed n queens\\n\\t\\t// in case col == n, we could return right away, but it is also alright to go on\\n\\n\\t\\tfor (int row = 0; row < n; row++)\\n\\t\\t{\\n\\t\\t\\tint a = row + col;\\n\\t\\t\\tint b = row - col + n;\\n\\n\\t\\t\\tif (rows[row] || diag1[a] || diag2[b]) continue; // unable to place a queen\\n\\n\\t\\t\\trows[row] = diag1[a] = diag2[b] = true;  // place a queen\\n\\t\\t\\tHelper(col + 1);                         // go to the next column\\n\\t\\t\\trows[row] = diag1[a] = diag2[b] = false; // remove the queen\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2113239,
                "title": "easy-c-sol-backtracking-recursion-time-o-n-n",
                "content": "```\\nclass Solution {  //Time : O(N!*N)\\npublic:\\n    \\n     void solve(int col, vector<string> &board, vector<vector<string>> &ans, vector<int> &leftRow, vector<int> &upperDiagonal, vector<int> &lowerDiagonal, int n){\\n        \\n        if(col == n){\\n            ans.push_back(board);\\n            return;\\n        }\\n        \\n        for(int row = 0; row<n; row++){\\n            \\n            if(leftRow[row] == 0 && lowerDiagonal[row+col] == 0 && upperDiagonal[n-1+col-row] == 0){\\n                \\n                board[row][col] = \\'Q\\';\\n                leftRow[row] = 1;\\n                lowerDiagonal[row+col] = 1;\\n                upperDiagonal[n-1 + col - row] = 1;\\n                solve(col+1,board,ans,leftRow,upperDiagonal,lowerDiagonal,n);\\n                \\n                board[row][col] = \\'.\\';\\n                leftRow[row] = 0;\\n                lowerDiagonal[row+col] = 0;\\n                upperDiagonal[n-1+col-row] = 0;\\n                \\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n         vector<vector<string>> res;\\n        vector<string> board(n);\\n        \\n        string s(n,\\'.\\');\\n        \\n        for(int i=0;i<n;i++){\\n            board[i] = s;\\n        }\\n        \\n        vector<int> leftRow(n,0),upperDiagonal(2*n-1,0),lowerDiagonal(2*n-1,0);\\n        solve(0,board,res,leftRow,upperDiagonal,lowerDiagonal,n);\\n        \\n        int ans = res.size();\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {  //Time : O(N!*N)\\npublic:\\n    \\n     void solve(int col, vector<string> &board, vector<vector<string>> &ans, vector<int> &leftRow, vector<int> &upperDiagonal, vector<int> &lowerDiagonal, int n){\\n        \\n        if(col == n){\\n            ans.push_back(board);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2111570,
                "title": "backtracking-explained",
                "content": "**UPVOTE IF HELPFUL**\\nWe first create a **( n X n )** chess board and assign **0** to every index.\\nWhenever a queen will be placed, index will be made **1**.\\n\\nIn this approach , we fill queens **column-wise** starting from left side.\\n\\nWhenever a queen is placed, at first it is checked if it satisfies the conditions given that it is not under attack.\\n\\n**validMove** function.\\nFirst it check there are no other queen in row the queen is filled.\\nAs we are putting queen column wise so no need to check for column.\\nThen there are two diagonals to check for.\\n* Only left part of the diagonals are checked as positions to the right of the present column are still unfilled.\\n\\nIf conditions satisfied, Queen is placed and we move to next column.\\nIf no queen satisfy the problem, we backtrack and try to change the position of previous queen.\\n**UPVOTE IF HELPFUL**\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> List[List[str]]:\\n        def validMove(board,row,col):\\n            i=col\\n            while i>=0:\\n                if board[row][i]:\\n                    return False\\n                i-=1\\n            i=row\\n            j=col\\n            while (i>=0 and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i-=1\\n                j-=1\\n            i=row\\n            j=col\\n            while (i<n and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        def solve(board,col):\\n            if (col==n):\\n                res[0]+=1\\n                return\\n            for i in range(n):\\n                if validMove(board,i,col):\\n                    board[i][col]=1\\n                    solve(board,col+1)\\n                    board[i][col]=0\\n            return\\n        \\n        res=[0]\\n        board=[]\\n        for i in range(n):\\n            board.append([])\\n            for j in range(n):\\n                board[-1].append(0)\\n        solve(board,0)\\n        return res[0]\\n```\\n![image](https://assets.leetcode.com/users/images/2626719c-e537-443c-90c8-afc1ae43d2e6_1654391433.2912345.jpeg)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> List[List[str]]:\\n        def validMove(board,row,col):\\n            i=col\\n            while i>=0:\\n                if board[row][i]:\\n                    return False\\n                i-=1\\n            i=row\\n            j=col\\n            while (i>=0 and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i-=1\\n                j-=1\\n            i=row\\n            j=col\\n            while (i<n and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        def solve(board,col):\\n            if (col==n):\\n                res[0]+=1\\n                return\\n            for i in range(n):\\n                if validMove(board,i,col):\\n                    board[i][col]=1\\n                    solve(board,col+1)\\n                    board[i][col]=0\\n            return\\n        \\n        res=[0]\\n        board=[]\\n        for i in range(n):\\n            board.append([])\\n            for j in range(n):\\n                board[-1].append(0)\\n        solve(board,0)\\n        return res[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652274,
                "title": "beats-99-20-32ms-clean-recursive-solution-in-python",
                "content": "This solution is basically the same as the solution introduced in the article, but I condensed it into 10 lines of code to look more compact.\\n\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int: \\n        def rec(col, horizontal, diag, anti_diag):\\n            if col == n: return 1\\n            res = 0\\n            for row in range(n):\\n                if row not in horizontal and (row + col) not in diag and (row - col) not in anti_diag:\\n                    horizontal[row] = True; diag[row + col] = True; anti_diag[row - col] = True;\\n                    res += rec(col + 1, horizontal, diag, anti_diag)\\n                    del horizontal[row]; del diag[row + col]; del anti_diag[row - col];\\n            return res\\n        return rec(0, {}, {}, {})\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int: \\n        def rec(col, horizontal, diag, anti_diag):\\n            if col == n: return 1\\n            res = 0\\n            for row in range(n):\\n                if row not in horizontal and (row + col) not in diag and (row - col) not in anti_diag:\\n                    horizontal[row] = True; diag[row + col] = True; anti_diag[row - col] = True;\\n                    res += rec(col + 1, horizontal, diag, anti_diag)\\n                    del horizontal[row]; del diag[row + col]; del anti_diag[row - col];\\n            return res\\n        return rec(0, {}, {}, {})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20141,
                "title": "never-write-codes-like-this-lets-do-eval",
                "content": "Following codes got AC. But you should never write some codes like this. This is post is just for joking.\\n\\n    /**\\n     * @param {number} n\\n     * @return {number}\\n     */\\n    var totalNQueens = function(n) {\\n        var p = '', s = 0, l;\\n        for (var i = 0; i < n; i++) {\\n            l = '\\\\nfor (var s# = 0; s# < ' + n + '; s#++)';\\n            for (var j = 0; j < i; j++)\\n                l += 'if (s# !== s@ && Math.abs(s# - s@) !== (# - @)) '.replace(/@/g, j);\\n            p += l.replace(/#/g, i);\\n        }\\n        p += '\\\\ns++;\\\\ns';\\n        return eval(p);\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Following codes got AC. But you should never write some codes like this. This is post is just for joking.\\n\\n    /**\\n     * @param {number} n\\n     * @return {number}\\n     */\\n    var totalNQueens = function(n) {\\n        var p = '', s = 0, l;\\n        for (var i = 0; i < n; i++) {\\n            l = '\\\\nfor (var s# = 0; s# < ' + n + '; s#++)';\\n            for (var j = 0; j < i; j++)\\n                l += 'if (s# !== s@ && Math.abs(s# - s@) !== (# - @)) '.replace(/@/g, j);\\n            p += l.replace(/#/g, i);\\n        }\\n        p += '\\\\ns++;\\\\ns';\\n        return eval(p);\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3764197,
                "title": "backtracking-logic-solution",
                "content": "\\n\\n# 1. BackTracking Logic Solution\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def addans(board,ans):\\n            temp=[]\\n            for row in board:\\n                for j in range(len(row)):\\n                    if row[j]==\"Q\":\\n                        temp.append(j+1)\\n            ans.append(temp)\\n        def solve(col,board,low,upper,lower,ans,n):\\n            if col==n:\\n                addans(board,ans)\\n                return \\n            for row in range(n):\\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\\n                    board[row][col]=\"Q\"\\n                    low[row]=1\\n                    upper[n-1+col-row]=1\\n                    lower[row+col]=1\\n                    solve(col+1,board,low,upper,lower,ans,n)\\n                    low[row]=0\\n                    upper[n-1+col-row]=0\\n                    lower[row+col]=0\\n        ans=[]        \\n        board=[[0]*n for i in range(n)]\\n        low=[0]*n\\n        upper=[0]*(2*n-1)\\n        lower=[0]*(2*n-1)\\n        solve(0,board,low,upper,lower,ans,n)\\n        return len(ans)\\n```\\n   # please upvote me it would encourage me alot\\n\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def addans(board,ans):\\n            temp=[]\\n            for row in board:\\n                for j in range(len(row)):\\n                    if row[j]==\"Q\":\\n                        temp.append(j+1)\\n            ans.append(temp)\\n        def solve(col,board,low,upper,lower,ans,n):\\n            if col==n:\\n                addans(board,ans)\\n                return \\n            for row in range(n):\\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\\n                    board[row][col]=\"Q\"\\n                    low[row]=1\\n                    upper[n-1+col-row]=1\\n                    lower[row+col]=1\\n                    solve(col+1,board,low,upper,lower,ans,n)\\n                    low[row]=0\\n                    upper[n-1+col-row]=0\\n                    lower[row+col]=0\\n        ans=[]        \\n        board=[[0]*n for i in range(n)]\\n        low=[0]*n\\n        upper=[0]*(2*n-1)\\n        lower=[0]*(2*n-1)\\n        solve(0,board,low,upper,lower,ans,n)\\n        return len(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587899,
                "title": "striver-type-c-most-optimized",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int& n,vector<string> &tmp, vector<vector<string>> &ans,vector<bool> &c,vector<bool> &md,vector<bool> &td){\\n        if(i==n){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        string str(n,\\'.\\');\\n        for(int j = 0; j < n; j++){\\n            if((c[j]==false&&md[i-j+n]==false&&td[i+j]==false)){\\n                str[j] = \\'Q\\';\\n                c[j] = true;md[i-j+n]=true;td[i+j] = true;\\n                tmp.push_back(str);\\n                solve(i+1,n,tmp,ans,c,md,td);\\n                tmp.pop_back();\\n                str[j] = \\'.\\';\\n                c[j] = false;md[i-j+n]=false;td[i+j] = false;\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        vector<vector<string>> ans;\\n        vector<string> tmp;\\n        vector<bool> c(n,false),md(2*n+3,false),td(2*n+3,false);\\n        solve(0,n,tmp,ans,c,md,td);\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int& n,vector<string> &tmp, vector<vector<string>> &ans,vector<bool> &c,vector<bool> &md,vector<bool> &td){\\n        if(i==n){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        string str(n,\\'.\\');\\n        for(int j = 0; j < n; j++){\\n            if((c[j]==false&&md[i-j+n]==false&&td[i+j]==false)){\\n                str[j] = \\'Q\\';\\n                c[j] = true;md[i-j+n]=true;td[i+j] = true;\\n                tmp.push_back(str);\\n                solve(i+1,n,tmp,ans,c,md,td);\\n                tmp.pop_back();\\n                str[j] = \\'.\\';\\n                c[j] = false;md[i-j+n]=false;td[i+j] = false;\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        vector<vector<string>> ans;\\n        vector<string> tmp;\\n        vector<bool> c(n,false),md(2*n+3,false),td(2*n+3,false);\\n        solve(0,n,tmp,ans,c,md,td);\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115617,
                "title": "javascript-efficient-solution-meme",
                "content": "There is canonic solution with backtracking for the nQueen problem. You can read more on Wikepedia, or even find a video with detailed explanation, **my role here is rather give you a meme**.\\n\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar totalNQueens = function(n) {\\n    const cols = new Set();\\n    const posDiag = new Set();\\n    const negDiag = new Set();\\n    let solutionCount = 0;\\n    \\n    function computePositionForRow(row) {\\n        if (row === n) {\\n            solutionCount += 1;\\n            return;\\n        }\\n        \\n        for (let col = 0; col < n; col += 1) {\\n            if (cols.has(col) || posDiag.has(row + col) || negDiag.has(row - col)) {\\n                continue;\\n            }\\n            \\n            cols.add(col);\\n            posDiag.add(row + col);\\n            negDiag.add(row - col);\\n            \\n            computePositionForRow(row + 1);\\n            \\n            cols.delete(col);\\n            posDiag.delete(row + col);\\n            negDiag.delete(row - col);\\n        }\\n    }\\n    \\n    computePositionForRow(0);\\n    \\n    return solutionCount;\\n};\\n```\\n\\n**If you like solution or meme, upvote for motivate me**\\n\\nMeme#9 *see my other solutions for more memes!\\n\\n![image](https://assets.leetcode.com/users/images/6642a7a4-3d37-4a24-bcdd-6e3db52c05fd_1654456097.356457.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar totalNQueens = function(n) {\\n    const cols = new Set();\\n    const posDiag = new Set();\\n    const negDiag = new Set();\\n    let solutionCount = 0;\\n    \\n    function computePositionForRow(row) {\\n        if (row === n) {\\n            solutionCount += 1;\\n            return;\\n        }\\n        \\n        for (let col = 0; col < n; col += 1) {\\n            if (cols.has(col) || posDiag.has(row + col) || negDiag.has(row - col)) {\\n                continue;\\n            }\\n            \\n            cols.add(col);\\n            posDiag.add(row + col);\\n            negDiag.add(row - col);\\n            \\n            computePositionForRow(row + 1);\\n            \\n            cols.delete(col);\\n            posDiag.delete(row + col);\\n            negDiag.delete(row - col);\\n        }\\n    }\\n    \\n    computePositionForRow(0);\\n    \\n    return solutionCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111566,
                "title": "explanation-understandable",
                "content": "**UPVOTE IF HELPFUL**\\n\\nWe first create a **( n X n )** chess board and assign **0** to every index.\\nWhenever a queen will be placed, index will be made **1**.\\n\\nIn this approach , we fill queens **column-wise** starting from left side.\\n\\nWhenever a queen is placed, at first it is checked if it satisfies the conditions given that it is not under attack.\\n\\n**validMove** function.\\nFirst it check there are no other queen in row the queen is filled.\\nAs we are putting queen column wise so no need to check for column.\\nThen there are two diagonals to check for.\\n* Only left part of the diagonals are checked as positions to the right of the present column are still unfilled.\\n\\nIf conditions satisfied, Queen is placed and we move to next column.\\nIf no queen satisfy the problem, we backtrack and try to change the position of previous queen.\\n**UPVOTE IF HELPFUL**\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> List[List[str]]:\\n        def validMove(board,row,col):\\n            i=col\\n            while i>=0:\\n                if board[row][i]:\\n                    return False\\n                i-=1\\n            i=row\\n            j=col\\n            while (i>=0 and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i-=1\\n                j-=1\\n            i=row\\n            j=col\\n            while (i<n and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        def solve(board,col):\\n            if (col==n):\\n                res[0]+=1\\n                return\\n            for i in range(n):\\n                if validMove(board,i,col):\\n                    board[i][col]=1\\n                    solve(board,col+1)\\n                    board[i][col]=0\\n            return\\n        \\n        res=[0]\\n        board=[]\\n        for i in range(n):\\n            board.append([])\\n            for j in range(n):\\n                board[-1].append(0)\\n        solve(board,0)\\n        return res[0]\\n```\\n![image](https://assets.leetcode.com/users/images/2626719c-e537-443c-90c8-afc1ae43d2e6_1654391433.2912345.jpeg)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> List[List[str]]:\\n        def validMove(board,row,col):\\n            i=col\\n            while i>=0:\\n                if board[row][i]:\\n                    return False\\n                i-=1\\n            i=row\\n            j=col\\n            while (i>=0 and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i-=1\\n                j-=1\\n            i=row\\n            j=col\\n            while (i<n and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        def solve(board,col):\\n            if (col==n):\\n                res[0]+=1\\n                return\\n            for i in range(n):\\n                if validMove(board,i,col):\\n                    board[i][col]=1\\n                    solve(board,col+1)\\n                    board[i][col]=0\\n            return\\n        \\n        res=[0]\\n        board=[]\\n        for i in range(n):\\n            board.append([])\\n            for j in range(n):\\n                board[-1].append(0)\\n        solve(board,0)\\n        return res[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441898,
                "title": "c-soln-backtracking",
                "content": "Same as N-Queens I \\njust return the size of the vector used to keep possible solution of board\\n\\n```\\nclass Solution {\\npublic:\\n // this vector keeps possible board configurations\\n vector<vector<string>> res;\\n    \\n// checks whether the position is safe for queen or not\\n    bool is_Safe(vector<string>& board , int row , int column)\\n    {\\n        for(int index = row ; index >= 0 ; index--)\\n            if(board[index][column] == \\'Q\\')\\n                return false;\\n        \\n        for(int index = row , jindex = column ; index >= 0 && jindex >=0 ; index-- , jindex--)\\n            if(board[index][jindex] == \\'Q\\')\\n                return false;\\n        \\n        for(int index = row , jindex = column ; index >= 0 && jindex < board.size() ; index-- , jindex++)\\n            if(board[index][jindex] == \\'Q\\')\\n                return false;\\n        \\n        return true;\\n    }\\n    \\n    // checks all possible configurations by backtracking\\n    void placequeen(vector<string>& board , int row)\\n    {\\n        if(row == board.size())\\n        {\\n            res.push_back(board);\\n            return;\\n        }\\n        \\n        for(int index = 0 ; index < board.size() ; index++)\\n        {\\n            if(is_Safe(board , row , index))\\n            {\\n                \\n                board[row][index] = \\'Q\\';\\n                placequeen(board , row + 1);\\n                board[row][index] = \\'.\\';\\n            }\\n        }\\n    }\\n    \\n    \\n    int totalNQueens(int n) {\\n\\n         if(n <= 0)\\n            return res.size();\\n        \\n        vector<string> board(n,string(n,\\'.\\'));\\n        placequeen(board,0);\\n        \\n        return res.size();\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n // this vector keeps possible board configurations\\n vector<vector<string>> res;\\n    \\n// checks whether the position is safe for queen or not\\n    bool is_Safe(vector<string>& board , int row , int column)\\n    {\\n        for(int index = row ; index >= 0 ; index--)\\n            if(board[index][column] == \\'Q\\')\\n                return false;\\n        \\n        for(int index = row , jindex = column ; index >= 0 && jindex >=0 ; index-- , jindex--)\\n            if(board[index][jindex] == \\'Q\\')\\n                return false;\\n        \\n        for(int index = row , jindex = column ; index >= 0 && jindex < board.size() ; index-- , jindex++)\\n            if(board[index][jindex] == \\'Q\\')\\n                return false;\\n        \\n        return true;\\n    }\\n    \\n    // checks all possible configurations by backtracking\\n    void placequeen(vector<string>& board , int row)\\n    {\\n        if(row == board.size())\\n        {\\n            res.push_back(board);\\n            return;\\n        }\\n        \\n        for(int index = 0 ; index < board.size() ; index++)\\n        {\\n            if(is_Safe(board , row , index))\\n            {\\n                \\n                board[row][index] = \\'Q\\';\\n                placequeen(board , row + 1);\\n                board[row][index] = \\'.\\';\\n            }\\n        }\\n    }\\n    \\n    \\n    int totalNQueens(int n) {\\n\\n         if(n <= 0)\\n            return res.size();\\n        \\n        vector<string> board(n,string(n,\\'.\\'));\\n        placequeen(board,0);\\n        \\n        return res.size();\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839035,
                "title": "clean-java-solution",
                "content": "The idea is that along the diagonals, the (row, col) tuple follows the sequence (i,j), (i+1, j+1), ..., so col - row is constant for a diagonal. Similarly, along cross diagonals, (row,col) tuple follows the sequence (i,j), (i+1, j-i), (i+2, j-2), hence row+col is constant for a cross diagonal. Using this idea, a valid position can be checked in constant time\\n```\\nclass Solution {\\n        \\n    private int numSolutions = 0;\\n    public Solution() {        \\n    }\\n    public int totalNQueens(int n) { \\n        tryQueenPlacement(0, new ChessBoard(n));\\n        return numSolutions;\\n    }\\n    \\n    private void tryQueenPlacement(int i, ChessBoard board) {\\n        if(i == board.size()) {\\n            ++numSolutions;\\n            return;\\n        }\\n        for(int j = 0; j < board.size(); j++) {\\n            if(board.isValidQueenPosition(i, j)) {\\n                board.placeQueen(i, j);\\n                tryQueenPlacement(i+1, board);                                                   \\n                board.removeQueen(i, j);\\n            }                   \\n        }\\n    }\\n    \\n    class ChessBoard{\\n        private final int boardSize;\\n        private int[] cols;\\n        private int[] diagonals;\\n        private int[] crossDiagonals;\\n        ChessBoard(int n) {\\n            this.boardSize = n;            \\n            reset(n);\\n        }\\n        \\n        int size() {\\n            return boardSize;\\n        }\\n        \\n        void reset(int boardSize) {\\n            this.cols = new int[boardSize];\\n            this.diagonals = new int[2*boardSize - 1];\\n            this.crossDiagonals = new int[2*boardSize - 1];\\n        }\\n        \\n        boolean isValidQueenPosition(int i, int j) {\\n            if(cols[j] == 1 || diagonals[j-i + (boardSize - 1)] == 1 || crossDiagonals[j+i] == 1) {\\n                return false;\\n            } \\n            return true;\\n        }\\n    \\n        void placeQueen(int i, int j) {\\n            cols[j] = 1;\\n            diagonals[j-i + (boardSize - 1)] = 1;\\n            crossDiagonals[j+i] = 1;\\n        }\\n\\n        void removeQueen(int i, int j) {\\n            cols[j] = 0;\\n            diagonals[j-i + (boardSize - 1)] = 0;\\n            crossDiagonals[j+i] = 0;\\n        }                  \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        \\n    private int numSolutions = 0;\\n    public Solution() {        \\n    }\\n    public int totalNQueens(int n) { \\n        tryQueenPlacement(0, new ChessBoard(n));\\n        return numSolutions;\\n    }\\n    \\n    private void tryQueenPlacement(int i, ChessBoard board) {\\n        if(i == board.size()) {\\n            ++numSolutions;\\n            return;\\n        }\\n        for(int j = 0; j < board.size(); j++) {\\n            if(board.isValidQueenPosition(i, j)) {\\n                board.placeQueen(i, j);\\n                tryQueenPlacement(i+1, board);                                                   \\n                board.removeQueen(i, j);\\n            }                   \\n        }\\n    }\\n    \\n    class ChessBoard{\\n        private final int boardSize;\\n        private int[] cols;\\n        private int[] diagonals;\\n        private int[] crossDiagonals;\\n        ChessBoard(int n) {\\n            this.boardSize = n;            \\n            reset(n);\\n        }\\n        \\n        int size() {\\n            return boardSize;\\n        }\\n        \\n        void reset(int boardSize) {\\n            this.cols = new int[boardSize];\\n            this.diagonals = new int[2*boardSize - 1];\\n            this.crossDiagonals = new int[2*boardSize - 1];\\n        }\\n        \\n        boolean isValidQueenPosition(int i, int j) {\\n            if(cols[j] == 1 || diagonals[j-i + (boardSize - 1)] == 1 || crossDiagonals[j+i] == 1) {\\n                return false;\\n            } \\n            return true;\\n        }\\n    \\n        void placeQueen(int i, int j) {\\n            cols[j] = 1;\\n            diagonals[j-i + (boardSize - 1)] = 1;\\n            crossDiagonals[j+i] = 1;\\n        }\\n\\n        void removeQueen(int i, int j) {\\n            cols[j] = 0;\\n            diagonals[j-i + (boardSize - 1)] = 0;\\n            crossDiagonals[j+i] = 0;\\n        }                  \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609947,
                "title": "not-the-fastest-in-leetcode-complier-but-the-simple-and-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        int cnt = 0;\\n        vector<int> curPos;\\n\\n        totalNQueens(n, curPos, &cnt);\\n\\n        return cnt;\\n    }\\n    \\n    bool isColValid(vector<int>& curPos, int curCol) {\\n        for (int row = 0; row < curPos.size(); row++) {\\n            if (curPos[row] == curCol) return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool isPosValid(vector<int>& curPos, int curRow, int curCol) {\\n        for (int row = 0; row < curPos.size(); row++) {\\n            if (abs(curPos[row] - curCol) == abs(row - curRow) ) return false;\\n        }\\n        return true;\\n    }\\n    \\n    void totalNQueens(int n, vector<int>& curPos, int* cnt) {\\n        // BASE CASE\\n        if (curPos.size() == n) {\\n            *cnt += 1;\\n            return;\\n        }\\n        \\n        for (int col = 0; col < n; col++) {\\n            if (!isColValid(curPos, col)) continue;\\n            if (!isPosValid(curPos, curPos.size(), col)) continue;\\n            // Positions valid\\n            // and to the correct postions\\n            curPos.push_back(col);\\n            totalNQueens(n, curPos, cnt);\\n            // delete this position\\n            curPos.pop_back();\\n             \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        int cnt = 0;\\n        vector<int> curPos;\\n\\n        totalNQueens(n, curPos, &cnt);\\n\\n        return cnt;\\n    }\\n    \\n    bool isColValid(vector<int>& curPos, int curCol) {\\n        for (int row = 0; row < curPos.size(); row++) {\\n            if (curPos[row] == curCol) return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool isPosValid(vector<int>& curPos, int curRow, int curCol) {\\n        for (int row = 0; row < curPos.size(); row++) {\\n            if (abs(curPos[row] - curCol) == abs(row - curRow) ) return false;\\n        }\\n        return true;\\n    }\\n    \\n    void totalNQueens(int n, vector<int>& curPos, int* cnt) {\\n        // BASE CASE\\n        if (curPos.size() == n) {\\n            *cnt += 1;\\n            return;\\n        }\\n        \\n        for (int col = 0; col < n; col++) {\\n            if (!isColValid(curPos, col)) continue;\\n            if (!isPosValid(curPos, curPos.size(), col)) continue;\\n            // Positions valid\\n            // and to the correct postions\\n            curPos.push_back(col);\\n            totalNQueens(n, curPos, cnt);\\n            // delete this position\\n            curPos.pop_back();\\n             \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 243444,
                "title": "python-solution",
                "content": "We use the backtracking algorithm. Initialize the result `res = 0`. We use three sets `cols`, `diag` and `off_diag` to keep track of the columns, diagonals, and off-diagonals that have been occupied in the current state of the board. We define a recursive `backtrack` function which counts all valid configurations of the board, and increment `res` by `1` if a configuration is valid. More specifically, `backtrack(i)` enumerates all valid positions that the queen can be put in the `i`th row. For each valid position, we add the column, diagonal and off-diagonal occupied by the position to `cols`, `diag`, and `off_diag`, respectively, and recursively call `backtrack(i+1)`, until `i == n`, in which case we know that the current state of the board represents a valid configuration of the `n` queens, and we increment `res` by `1`. Finally, we return `res`.\\n\\nTime complexity: `O(n!)`, space complexity: `O(n)`. \\n\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def backtrack(i):\\n            if i == n:\\n                return 1\\n            res = 0\\n            for j in range(n):\\n                if j not in cols and i-j not in diag and i+j not in off_diag:\\n                    cols.add(j)\\n                    diag.add(i-j)\\n                    off_diag.add(i+j)\\n                    res += backtrack(i+1)\\n                    off_diag.remove(i+j)\\n                    diag.remove(i-j)\\n                    cols.remove(j)\\n            return res\\n       \\n        cols = set()\\n        diag = set()\\n        off_diag = set()\\n        return backtrack(0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def backtrack(i):\\n            if i == n:\\n                return 1\\n            res = 0\\n            for j in range(n):\\n                if j not in cols and i-j not in diag and i+j not in off_diag:\\n                    cols.add(j)\\n                    diag.add(i-j)\\n                    off_diag.add(i+j)\\n                    res += backtrack(i+1)\\n                    off_diag.remove(i+j)\\n                    diag.remove(i-j)\\n                    cols.remove(j)\\n            return res\\n       \\n        cols = set()\\n        diag = set()\\n        off_diag = set()\\n        return backtrack(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807847,
                "title": "c-recursive-backtracking-bitmask-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a very classical problem; ans there is no math formula known to solve it!\\n\\n2 codes are given. One uses ordinary backtracking with boolean arrays.  The other uses bimasks insteads of boolean arrays.\\n\\nThe code solves the N-Queens problem by recursively placing queens on a chessboard. It uses backtracking and checks for valid positions to avoid conflicts. The solutions are stored in a vector and returned. The code initializes the chessboard, sets flags for occupied columns, diagonals, and anti-diagonals, and finds all valid solutions using a recursive function. \\n\\nSimilar question:\\n[51. N-Queens\\n](https://leetcode.com/problems/n-queens/solutions/3713298/c-recursive-backtracking-bool-vector-vs-bitmask-beasts-100/)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)\\n\\n```\\nsol 92:\\n.......Q\\n...Q....\\nQ.......\\n..Q.....\\n.....Q..\\n.Q......\\n......Q.\\n....Q...\\n```\\nvectors col, antidiag, and diag are used as boolean flags to keep track of occupied columns, anti-diagonals, and diagonals, respectively.\\n\\nHere\\'s a breakdown of each vector\\'s purpose:\\n\\ncol: This vector represents the occupied columns on the chessboard. Each element in the vector corresponds to a column on the board. If col[j] is true, it means that column j is already occupied by a queen. Otherwise, if col[j] is false, the column is available for placing a queen.\\n\\nantidiag: This vector represents the occupied anti-diagonals on the chessboard. An anti-diagonal is a diagonal line that runs from the top-right to the bottom-left of the chessboard. The length of the anti-diagonals is 2*n - 1, where n is the number of rows/columns. Each element in the vector corresponds to an anti-diagonal on the board. If antidiag[i+j] is true, it means that the anti-diagonal i+j is already occupied by a queen. If antidiag[i+j] is false, the anti-diagonal is available for placing a queen.\\n\\ndiag: This vector represents the occupied diagonals on the chessboard. A diagonal is a line that runs from the top-left to the bottom-right of the chessboard. Similar to the antidiag vector, the length of the diagonals is also 2*n - 1. Each element in the vector corresponds to a diagonal on the board. If diag[i+n-j-1] is true, it means that the diagonal i-j is already occupied by a queen (Note that i-j may be negative, shifting it to i+n-j-1 to ensure be non-negative ). If diag[i+n-j-1] is false, the diagonal is available for placing a queen.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n!)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> col, diag, antidiag;\\n    int find_sol(int i, int n) {\\n        int num=0;\\n        if (i == n) \\n            return 1;\\n        for (int j = 0; j < n; j++) {\\n            if (!col[j] && !antidiag[i+j] && !diag[i+n-j-1]) {\\n                col[j] = antidiag[i+j] = diag[i+n-j-1] = true;\\n                num+=find_sol(i+1, n);\\n                col[j] = antidiag[i+j] = diag[i+n-j-1] = false;\\n            }\\n        }\\n        return num;\\n    }\\n    int totalNQueens(int n) {\\n        col.assign(n, false);\\n        diag.assign(2*n-1, false);\\n        antidiag.assign(2*n-1, false);\\n        return find_sol(0, n);\\n    }\\n};\\n\\n```\\n# Code using Bit Mask\\n```\\nclass Solution {\\npublic:\\n    int col_mask, diag_mask, anti_diag_mask;\\n    int find_sol(int i, int n) {\\n        int num=0;\\n        if (i == n) \\n            return 1;\\n        for (int j = 0; j < n; j++) {\\n            if ((col_mask & (1 << j)) == 0 && \\n                (diag_mask & (1 << (i - j + n - 1))) == 0 && \\n                (anti_diag_mask & (1 << (i + j))) == 0) \\n            {\\n                col_mask |= (1 << j);\\n                diag_mask |= (1 << (i - j + n - 1));\\n                anti_diag_mask |= (1 << (i + j));\\n\\n                num+=find_sol(i+1, n);\\n\\n                col_mask &= ~(1 << j);\\n                diag_mask &= ~(1 << (i - j + n - 1));\\n                anti_diag_mask &= ~(1 << (i + j));\\n            }\\n        }\\n        return num;\\n    }\\n    int totalNQueens(int n) {\\n        col_mask = diag_mask = anti_diag_mask = 0;\\n        return find_sol(0, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\nsol 92:\\n.......Q\\n...Q....\\nQ.......\\n..Q.....\\n.....Q..\\n.Q......\\n......Q.\\n....Q...\\n```\n```\\nclass Solution {\\npublic:\\n    vector<bool> col, diag, antidiag;\\n    int find_sol(int i, int n) {\\n        int num=0;\\n        if (i == n) \\n            return 1;\\n        for (int j = 0; j < n; j++) {\\n            if (!col[j] && !antidiag[i+j] && !diag[i+n-j-1]) {\\n                col[j] = antidiag[i+j] = diag[i+n-j-1] = true;\\n                num+=find_sol(i+1, n);\\n                col[j] = antidiag[i+j] = diag[i+n-j-1] = false;\\n            }\\n        }\\n        return num;\\n    }\\n    int totalNQueens(int n) {\\n        col.assign(n, false);\\n        diag.assign(2*n-1, false);\\n        antidiag.assign(2*n-1, false);\\n        return find_sol(0, n);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int col_mask, diag_mask, anti_diag_mask;\\n    int find_sol(int i, int n) {\\n        int num=0;\\n        if (i == n) \\n            return 1;\\n        for (int j = 0; j < n; j++) {\\n            if ((col_mask & (1 << j)) == 0 && \\n                (diag_mask & (1 << (i - j + n - 1))) == 0 && \\n                (anti_diag_mask & (1 << (i + j))) == 0) \\n            {\\n                col_mask |= (1 << j);\\n                diag_mask |= (1 << (i - j + n - 1));\\n                anti_diag_mask |= (1 << (i + j));\\n\\n                num+=find_sol(i+1, n);\\n\\n                col_mask &= ~(1 << j);\\n                diag_mask &= ~(1 << (i - j + n - 1));\\n                anti_diag_mask &= ~(1 << (i + j));\\n            }\\n        }\\n        return num;\\n    }\\n    int totalNQueens(int n) {\\n        col_mask = diag_mask = anti_diag_mask = 0;\\n        return find_sol(0, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479663,
                "title": "fast-clean-concise-c-solution-easy-to-understand-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int n, res = 0;\\n\\t// Check whether placing a new queen at given point is safe or not\\n    bool isSafe(vector<string> arr, int x, int y){\\n        for (int row=0; row<x; row++){\\n            if (arr[row][y]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n    \\n        int row = x;\\n        int col = y;\\n        while(row>=0 && col>=0){\\n            if (arr[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            row--;\\n            col--;\\n        }\\n    \\n        row = x;\\n        col = y;\\n        while(row>=0 && col<n){\\n            if (arr[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            row--;\\n            col++;\\n        }\\n    \\n        return true;\\n    }\\n\\n    void nQueen(vector<string> &ans, int i){\\n        if (i>=n){\\n\\t\\t\\t// count all the possible answers\\n            res++;\\n            return;\\n        }\\n        \\n        for(int k=0;k<n;k++){\\n            if(isSafe(ans,i,k)){\\n                ans[i][k] = \\'Q\\';\\n                nQueen(ans,i+1);\\n                ans[i][k] = \\'.\\';  // backtracking\\n            }\\n        }        \\n    }\\n    \\n    int totalNQueens(int num) {\\n        n = num;\\n\\t\\t// initializing vector with \".......n\"\\n        vector<string> ans(n);\\n        string temp = \"\";\\n        for(int j=0;j<n;j++)\\n            temp+=\\'.\\';\\n        \\n        for(int i=0;i<n;i++)\\n            ans[i] = temp;\\n        \\n        \\n        nQueen(ans,0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, res = 0;\\n\\t// Check whether placing a new queen at given point is safe or not\\n    bool isSafe(vector<string> arr, int x, int y){\\n        for (int row=0; row<x; row++){\\n            if (arr[row][y]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n    \\n        int row = x;\\n        int col = y;\\n        while(row>=0 && col>=0){\\n            if (arr[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            row--;\\n            col--;\\n        }\\n    \\n        row = x;\\n        col = y;\\n        while(row>=0 && col<n){\\n            if (arr[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            row--;\\n            col++;\\n        }\\n    \\n        return true;\\n    }\\n\\n    void nQueen(vector<string> &ans, int i){\\n        if (i>=n){\\n\\t\\t\\t// count all the possible answers\\n            res++;\\n            return;\\n        }\\n        \\n        for(int k=0;k<n;k++){\\n            if(isSafe(ans,i,k)){\\n                ans[i][k] = \\'Q\\';\\n                nQueen(ans,i+1);\\n                ans[i][k] = \\'.\\';  // backtracking\\n            }\\n        }        \\n    }\\n    \\n    int totalNQueens(int num) {\\n        n = num;\\n\\t\\t// initializing vector with \".......n\"\\n        vector<string> ans(n);\\n        string temp = \"\";\\n        for(int j=0;j<n;j++)\\n            temp+=\\'.\\';\\n        \\n        for(int i=0;i<n;i++)\\n            ans[i] = temp;\\n        \\n        \\n        nQueen(ans,0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113635,
                "title": "c-backtracking-w-shifting-bits-and-a-cheat-version",
                "content": "For backtracking we can use 3 integers as bitmasks. We only need to shift them for the main and anti diagonal.\\n\\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        return bt(n, 0, 0, 0, 0);\\n    }\\n    \\nprivate:\\n    int bt(int n, int idx, int same, int main, int anti) {\\n        if (idx == n) return 1;\\n       \\n        int ans = 0;\\n        \\n        for (int i = 0; i < n; ++i) {\\n\\t\\t    const int mask = 1 << i;\\n            if (same & mask) continue;\\n            if (main & mask) continue;\\n            if (anti & mask) continue;\\n            \\n            ans += bt(n, idx + 1, same | mask, (main | mask) << 1, (anti | mask) >> 1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nSince the results never change and only depend on ```n``` we could even do something like:\\n\\n```\\n    int totalNQueens(int n) {\\n        static const int ans[] = {0, 1, 0, 0, 2, 10, 4, 40, 92, 352};\\n        return ans[n];\\n    }\\n```\\n\\nWhich is likley considered cheating. :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        return bt(n, 0, 0, 0, 0);\\n    }\\n    \\nprivate:\\n    int bt(int n, int idx, int same, int main, int anti) {\\n        if (idx == n) return 1;\\n       \\n        int ans = 0;\\n        \\n        for (int i = 0; i < n; ++i) {\\n\\t\\t    const int mask = 1 << i;\\n            if (same & mask) continue;\\n            if (main & mask) continue;\\n            if (anti & mask) continue;\\n            \\n            ans += bt(n, idx + 1, same | mask, (main | mask) << 1, (anti | mask) >> 1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```n```\n```\\n    int totalNQueens(int n) {\\n        static const int ans[] = {0, 1, 0, 0, 2, 10, 4, 40, 92, 352};\\n        return ans[n];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113550,
                "title": "simple-java-solution",
                "content": "```\\npublic class Solution {\\n    int s=0;\\n    public int totalNQueens(int n) {\\n        boolean[] k=new boolean[n];\\n        boolean[] p= new boolean[2*n-1];\\n        boolean[] a=new boolean[2*n-1];\\n        task(0, n,k,p,a);\\n        return s;\\n    }\\n    public void task(int x, int n, boolean[] k, boolean[] p, boolean[] a) {\\n        if (x==n) {\\n            s++;\\n            return;\\n        }\\n        for(int i=0;i<n;i++) \\n        {\\n            if(!k[i]&&!p[i+x]&&!a[n-1-x+i]) \\n            {\\n                k[i]=p[i+x]=a[n-1-x+i]=true;\\n                task(x+1,n,k,p,a);\\n                k[i]=p[i+x]=a[n-1-x+i]=false;\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    int s=0;\\n    public int totalNQueens(int n) {\\n        boolean[] k=new boolean[n];\\n        boolean[] p= new boolean[2*n-1];\\n        boolean[] a=new boolean[2*n-1];\\n        task(0, n,k,p,a);\\n        return s;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2113344,
                "title": "accepted-c-easy-solution",
                "content": "\\nclass Solution {\\npublic:\\n\\n    int queencount = 0;// to keep the total count\\n    bool isItSafe(vector<vector<bool> > &grid,int row,int col,int n) \\n\\t{\\n\\t\\tfor(int i=row-1;i>=0;i--)\\n\\t\\t{\\n\\t\\t\\tif(grid[i][col]) return false;\\n\\t\\t}\\n\\t\\tfor(int i=row-1,j=col-1;i>=0 and j>=0;i--,j--)\\n\\t\\t{\\n\\t\\t\\tif(grid[i][j]) return false;\\n\\t\\t}\\n\\t\\tfor(int i=row-1,j=col+1;i>=0 and j<n;i--,j++)\\n\\t\\t{\\n\\t\\t\\tif(grid[i][j]) return false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\n   \\n\\tvoid countNQueen(vector<vector<bool> > &grid, int curr_row, int n){\\n\\t\\tif(curr_row == n){ // We found a solution so we increment our count\\n\\t\\t\\tqueencount++;\\n\\t\\t\\t// display(grid,n);\\n\\t\\t\\t// cout<<\"\\\\n\\\\n\";\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tif(isItSafe(grid,curr_row,i,n)){\\n\\t\\t\\t\\tgrid[curr_row][i] = true;\\n\\t\\t\\t\\tcountNQueen(grid,curr_row+1,n);\\n\\t\\t\\t\\tgrid[curr_row][i] = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    \\n    int totalNQueens(int n) {\\n        vector<vector<bool> > grid(n, vector<bool>(n,false));\\n   \\n         countNQueen(grid,0,n); \\n        return queencount;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int queencount = 0;// to keep the total count\\n    bool isItSafe(vector<vector<bool> > &grid,int row,int col,int n) \\n\\t{\\n\\t\\tfor(int i=row-1;i>=0;i--)\\n\\t\\t{\\n\\t\\t\\tif(grid[i][col]) return false;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2113275,
                "title": "c-use-recursion-and-backtracking-explanation-through-comments-dlc-june-day-5",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) \\n    {\\n        int ans=0;                 //ans counts toatal no. of possible orders \\n        vector<string> board(n);   // create the board of n rows \\n        string s(n,\\'.\\');           // define column of the board size n=4 i.e. \"....\" \\n        \\n        for(int i=0;i<n;i++)       // define whole board as a empty string\\n        {\\n            board[i]=s;            //[\"....\",\"....\",\"....\",\"....\"]\\n        }\\n        \\n        // we are moving from left to right\\n        // so we need to check only left part of the current cell because all the cells after current cell (right part) will surely empty\\n        // we also can not check for upper and lower direction for current cell because each column and row has only one queen\\n        \\n        // using hashing for check the collision\\n        vector<int> leftrow(n,0);                      // maintaining an array left that will tell which row has already taken for placing queen\\n        vector<int> upperdiagonal(2*n-1,0);          // maintaiing an array upperdiagonal that will tell which upperdiagonal has already taken\\n        vector<int> lowerdiagonal(2*n-1,0);          // maintaiing an array lowerdiagonal that will tell which lowerdiagonal has already taken\\n        \\n        solve(0, board, ans, leftrow, lowerdiagonal, upperdiagonal, n);\\n        return ans;   \\n    }\\n    \\n    void solve(int col, vector<string> &board, int &ans, \\n               vector<int> &leftrow, vector<int> &lowerdiagonal, \\n               vector<int> &upperdiagonal, int n)\\n    {\\n        //when all columns are covered, we increase the count and return\\n        if(col == n) \\n        {\\n            ans++;\\n            return;\\n        }\\n        \\n        for(int row=0; row<n; row++)\\n        {\\n            //condition for checking collision, if all satisfy means there is no collision\\n            if(leftrow[row]==0 && lowerdiagonal[row+col]==0 && \\n               upperdiagonal[n-1+row-col]==0)\\n            {\\n                board[row][col] = \\'Q\\';\\n                leftrow[row]=1;\\n                lowerdiagonal[row+col]=1;\\n                upperdiagonal[n-1+row-col]=1;\\n                solve(col+1, board, ans, leftrow, lowerdiagonal, upperdiagonal, n);\\n                //backtracking\\n                board[row][col] = \\'.\\'; \\n                leftrow[row]=0;\\n                lowerdiagonal[row+col]=0;\\n                upperdiagonal[n-1+row-col]=0;\\n            }\\n        }\\n    }     \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) \\n    {\\n        int ans=0;                 //ans counts toatal no. of possible orders \\n        vector<string> board(n);   // create the board of n rows \\n        string s(n,\\'.\\');           // define column of the board size n=4 i.e. \"....\" \\n        \\n        for(int i=0;i<n;i++)       // define whole board as a empty string\\n        {\\n            board[i]=s;            //[\"....\",\"....\",\"....\",\"....\"]\\n        }\\n        \\n        // we are moving from left to right\\n        // so we need to check only left part of the current cell because all the cells after current cell (right part) will surely empty\\n        // we also can not check for upper and lower direction for current cell because each column and row has only one queen\\n        \\n        // using hashing for check the collision\\n        vector<int> leftrow(n,0);                      // maintaining an array left that will tell which row has already taken for placing queen\\n        vector<int> upperdiagonal(2*n-1,0);          // maintaiing an array upperdiagonal that will tell which upperdiagonal has already taken\\n        vector<int> lowerdiagonal(2*n-1,0);          // maintaiing an array lowerdiagonal that will tell which lowerdiagonal has already taken\\n        \\n        solve(0, board, ans, leftrow, lowerdiagonal, upperdiagonal, n);\\n        return ans;   \\n    }\\n    \\n    void solve(int col, vector<string> &board, int &ans, \\n               vector<int> &leftrow, vector<int> &lowerdiagonal, \\n               vector<int> &upperdiagonal, int n)\\n    {\\n        //when all columns are covered, we increase the count and return\\n        if(col == n) \\n        {\\n            ans++;\\n            return;\\n        }\\n        \\n        for(int row=0; row<n; row++)\\n        {\\n            //condition for checking collision, if all satisfy means there is no collision\\n            if(leftrow[row]==0 && lowerdiagonal[row+col]==0 && \\n               upperdiagonal[n-1+row-col]==0)\\n            {\\n                board[row][col] = \\'Q\\';\\n                leftrow[row]=1;\\n                lowerdiagonal[row+col]=1;\\n                upperdiagonal[n-1+row-col]=1;\\n                solve(col+1, board, ans, leftrow, lowerdiagonal, upperdiagonal, n);\\n                //backtracking\\n                board[row][col] = \\'.\\'; \\n                leftrow[row]=0;\\n                lowerdiagonal[row+col]=0;\\n                upperdiagonal[n-1+row-col]=0;\\n            }\\n        }\\n    }     \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800718,
                "title": "c-backtracking-beginner-friendly-solution-w-comments",
                "content": "DO \\u2B06\\uFE0FUPVOTE IF IT WAS HELPFUL\\t\\n\\t\\n\\tclass Solution {\\n\\t\\t// vector<vector<string>> ans;\\n\\t\\tint count=0;\\n\\tpublic:\\n\\t\\tbool issafe(int r,int c,vector<string>&v,int n){\\n\\t\\t\\t//column check\\n\\t\\t\\tfor(int i=0;i<=r;i++){\\n\\t\\t\\t\\tif(v[i][c]==\\'Q\\') return false;\\n\\t\\t\\t}\\n\\t\\t\\t//diagonal check left side\\n\\t\\t\\tint row=r,col=c;\\n\\t\\t\\twhile(row>=0 && col>=0){\\n\\t\\t\\t\\tif(v[row][col]==\\'Q\\') return false;\\n\\t\\t\\t\\trow--,col--;\\n\\t\\t\\t}\\n\\t\\t\\t//diagonal check right side\\n\\t\\t\\trow=r,col=c;\\n\\t\\t\\twhile(row>=0 && col<n){\\n\\t\\t\\t\\tif(v[row][col]==\\'Q\\') return false;\\n\\t\\t\\t\\trow--,col++;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tvoid helper(int r,vector<string> &v,int n){\\n\\t\\t\\t if(r==n){\\n\\t\\t\\t\\t count++;\\n\\t\\t\\t\\t return ;\\n\\t\\t\\t }\\n\\t\\t\\tfor(int i=0;i<n;i++){ //fixing row and checking for column(each row can have only one queen)\\n\\t\\t\\t\\tif(issafe(r,i,v,n)){\\n\\t\\t\\t\\t\\tv[r][i]=\\'Q\\';\\n\\t\\t\\t\\t\\thelper(r+1,v,n);\\n\\t\\t\\t\\t\\tv[r][i]=\\'.\\';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint totalNQueens(int n) {\\n\\t\\t\\tvector<string> v;\\n\\t\\t\\tstring s(n,\\'.\\');\\n\\t\\t\\tfor(int i=0;i<n;i++) v.push_back(s);\\n\\t\\t\\thelper(0,v,n);\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\t\\t// vector<vector<string>> ans;\\n\\t\\tint count=0;\\n\\tpublic:\\n\\t\\tbool issafe(int r,int c,vector<string>&v,int n){\\n\\t\\t\\t//column check\\n\\t\\t\\tfor(int i=0;i<=r;i++){\\n\\t\\t\\t\\tif(v[i][c]==\\'Q\\') return false;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1138289,
                "title": "c-easy-clean-code-explained-with-comments-backtracking",
                "content": "***Generally we see that part 2 of any variant is a modification of part 1. But, here part is relatively simple as we have to only count the valid configurations of placing N Queens on an \"n x n\" board. So, here we go through the solution.***\\n\\n```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    bool isValid(int matrix[][9],int row,int col,int n) {\\n        \\n        // col check\\n        for(int r=0;r<row;r++) { \\n            if(matrix[r][col]==1) return false;\\n        }\\n        \\n        // left diagonal\\n        int i=row,j=col;\\n        while(i>=0 && j>=0) {\\n            if(matrix[i][j]==1) return false;\\n            i--;j--;\\n        }\\n        // right diagonal \\n        i=row,j=col;\\n        while(i>=0 && j<n) {\\n            if(matrix[i][j]==1) return false;\\n            i--;j++;\\n        }\\n\\n        return true;\\n    }\\n    \\n    void solve(int matrix[][9],int row,int n){\\n       // if in all the rows queens are placed, that means we have reached the end, print the board \\n        if(row==n) { \\n            count++;\\n            return;\\n        }\\n      //  bool nextQueen=false; // \"assuming that next Queen\\'s placement is not decided YET\"\\n        for(int col=0;col<n;col++) { // moving into all the columns of \"row\" \\n            if(isValid(matrix,row,col,n)) { \\n               \\n                matrix[row][col] = 1; // if yes, mark it as 1\\n // now looking for next Queen\\'s placement, moving to the next row and calling this func Recursively.\\n                solve(matrix,row+1,n);\\n                matrix[row][col]=0; \\n//THIS IS WHERE ALL THE BACKTRACKING IS HAPPENING. IF WE GOT nextQueen as false, we will BACKTRACK BY SETTING THE CURRRENT POSITION TO 0 AGAIN, WE ARE LITERALLY MOVING \"BACK\" AND WILL LOOK FOR ANY OTHER LOCATION FOR THE PLACEMENT OF THE QUEEN\\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n        int matrix[9][9]={0}; // creating an 2d array of 9X9 since that is the max limit\\n        solve(matrix,0,n); // solve(matrix,starting row,max rows)\\n        return count;\\n    }\\n};\\n```\\n\\n# HAPPY CODING. PLEASE UPVOTE :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    bool isValid(int matrix[][9],int row,int col,int n) {\\n        \\n        // col check\\n        for(int r=0;r<row;r++) { \\n            if(matrix[r][col]==1) return false;\\n        }\\n        \\n        // left diagonal\\n        int i=row,j=col;\\n        while(i>=0 && j>=0) {\\n            if(matrix[i][j]==1) return false;\\n            i--;j--;\\n        }\\n        // right diagonal \\n        i=row,j=col;\\n        while(i>=0 && j<n) {\\n            if(matrix[i][j]==1) return false;\\n            i--;j++;\\n        }\\n\\n        return true;\\n    }\\n    \\n    void solve(int matrix[][9],int row,int n){\\n       // if in all the rows queens are placed, that means we have reached the end, print the board \\n        if(row==n) { \\n            count++;\\n            return;\\n        }\\n      //  bool nextQueen=false; // \"assuming that next Queen\\'s placement is not decided YET\"\\n        for(int col=0;col<n;col++) { // moving into all the columns of \"row\" \\n            if(isValid(matrix,row,col,n)) { \\n               \\n                matrix[row][col] = 1; // if yes, mark it as 1\\n // now looking for next Queen\\'s placement, moving to the next row and calling this func Recursively.\\n                solve(matrix,row+1,n);\\n                matrix[row][col]=0; \\n//THIS IS WHERE ALL THE BACKTRACKING IS HAPPENING. IF WE GOT nextQueen as false, we will BACKTRACK BY SETTING THE CURRRENT POSITION TO 0 AGAIN, WE ARE LITERALLY MOVING \"BACK\" AND WILL LOOK FOR ANY OTHER LOCATION FOR THE PLACEMENT OF THE QUEEN\\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n        int matrix[9][9]={0}; // creating an 2d array of 9X9 since that is the max limit\\n        solve(matrix,0,n); // solve(matrix,starting row,max rows)\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861345,
                "title": "python3-backtracking-solution-with-detailed-comments-explanation",
                "content": "```py\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        \\n        # We only need three arrays; one for rows and two for left & right diagonals.\\n        # Since there can be only 1 queen in a row, col, & diagonals, we don\\'t need to consider\\n        # every cell/square on the board. We can just iterate over the columns.\\n        # We can use specific places in these arrays to mark off ENTIRE rows, columns, and diagonals,\\n        # since placing a queen makes the row, col, and diagonals its in invalid for placing any others.\\n        # The rows array takes care of marking off both the current row & column.\\n        # Ex. rows[2] marks off the entire third column, and the entire current row.\\n        \\n        rows = [0] * n         # There are n columns\\n        hills = [0] * (2*n-1)  # number of right diagonals (draw a board and count diagonals to verify)\\n        slopes = [0] * (2*n-1) # number of left diagonals\\n        \\n        # When placing a queen, also mark the row, column, and diagonals it attacks, since\\n        # we can\\'t place any other queens in those paths.\\n        # A queen\\'s right diagonal (hill) is: row - column.\\n        # A queen\\'s left diagonal (slope) is: row + column.\\n        def place_queen(row, col):\\n            right_diag = row - col\\n            left_diag = row + col\\n            \\n            rows[col] = 1\\n            hills[right_diag] = 1\\n            slopes[left_diag] = 1\\n            \\n        # For removing a queen, it\\'s much the same process: Unmark the row, column, and diagonals,\\n        # since removing a queen means they are no longer under attack.\\n        def remove_queen(row, col):\\n            right_diag = row - col\\n            left_diag = row + col\\n            \\n            rows[col] = 0\\n            hills[right_diag] = 0\\n            slopes[left_diag] = 0\\n        \\n        def not_under_attack(row, col):\\n            right_diag = row - col\\n            left_diag = row + col\\n            \\n            # In python, 0 is False and 1 is True.\\n            # So if we have rows[0] = 0, the boolean value of rows[0] is False, and not(rows[0]) returns True.\\n            # This is a simple check to see if all three of these spots contain 1\\'s or not.\\n            return not(rows[col] or hills[right_diag] or slopes[left_diag])\\n        \\n        # Start searching from the point (0,0).\\n        # (Saying row = 0, count = 0 in the function arguments is just the default value, if the function\\n        # gets called with nothing passed in. If the function DOES get called with values passed in,\\n        # the 0\\'s get overriden, and you\\'d be working with a different row & count).\\n        # Place a queen on the first open spot you find, check if the number of filled spots equals n,\\n        # and if it does, increase the total count of valid solutions.\\n        # The else clause here is what does the actual backtracking: it places a queen, calls the function again\\n        # and again with a new spot in the board, until we don\\'t hit the else clause anymore, at which point we\\n        # remove the queen at the new row, col, and resume our search by continuing the for loop.\\n        # Notice how row gets incremented each time the backtrack function gets called recursively.\\n        def backtrack(row = 0, count = 0):\\n            for col in range(n):\\n                if not_under_attack(row, col):\\n                    place_queen(row, col)\\n                    \\n                    if row+1 == n:\\n                        count += 1\\n                    else:\\n                        count = backtrack(row+1, count)\\n                        \\n                    remove_queen(row, col)\\n                    \\n            return count```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```py\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        \\n        # We only need three arrays; one for rows and two for left & right diagonals.\\n        # Since there can be only 1 queen in a row, col, & diagonals, we don\\'t need to consider\\n        # every cell/square on the board. We can just iterate over the columns.\\n        # We can use specific places in these arrays to mark off ENTIRE rows, columns, and diagonals,\\n        # since placing a queen makes the row, col, and diagonals its in invalid for placing any others.\\n        # The rows array takes care of marking off both the current row & column.\\n        # Ex. rows[2] marks off the entire third column, and the entire current row.\\n        \\n        rows = [0] * n         # There are n columns\\n        hills = [0] * (2*n-1)  # number of right diagonals (draw a board and count diagonals to verify)\\n        slopes = [0] * (2*n-1) # number of left diagonals\\n        \\n        # When placing a queen, also mark the row, column, and diagonals it attacks, since\\n        # we can\\'t place any other queens in those paths.\\n        # A queen\\'s right diagonal (hill) is: row - column.\\n        # A queen\\'s left diagonal (slope) is: row + column.\\n        def place_queen(row, col):\\n            right_diag = row - col\\n            left_diag = row + col\\n            \\n            rows[col] = 1\\n            hills[right_diag] = 1\\n            slopes[left_diag] = 1\\n            \\n        # For removing a queen, it\\'s much the same process: Unmark the row, column, and diagonals,\\n        # since removing a queen means they are no longer under attack.\\n        def remove_queen(row, col):\\n            right_diag = row - col\\n            left_diag = row + col\\n            \\n            rows[col] = 0\\n            hills[right_diag] = 0\\n            slopes[left_diag] = 0\\n        \\n        def not_under_attack(row, col):\\n            right_diag = row - col\\n            left_diag = row + col\\n            \\n            # In python, 0 is False and 1 is True.\\n            # So if we have rows[0] = 0, the boolean value of rows[0] is False, and not(rows[0]) returns True.\\n            # This is a simple check to see if all three of these spots contain 1\\'s or not.\\n            return not(rows[col] or hills[right_diag] or slopes[left_diag])\\n        \\n        # Start searching from the point (0,0).\\n        # (Saying row = 0, count = 0 in the function arguments is just the default value, if the function\\n        # gets called with nothing passed in. If the function DOES get called with values passed in,\\n        # the 0\\'s get overriden, and you\\'d be working with a different row & count).\\n        # Place a queen on the first open spot you find, check if the number of filled spots equals n,\\n        # and if it does, increase the total count of valid solutions.\\n        # The else clause here is what does the actual backtracking: it places a queen, calls the function again\\n        # and again with a new spot in the board, until we don\\'t hit the else clause anymore, at which point we\\n        # remove the queen at the new row, col, and resume our search by continuing the for loop.\\n        # Notice how row gets incremented each time the backtrack function gets called recursively.\\n        def backtrack(row = 0, count = 0):\\n            for col in range(n):\\n                if not_under_attack(row, col):\\n                    place_queen(row, col)\\n                    \\n                    if row+1 == n:\\n                        count += 1\\n                    else:\\n                        count = backtrack(row+1, count)\\n                        \\n                    remove_queen(row, col)\\n                    \\n            return count```",
                "codeTag": "Java"
            },
            {
                "id": 810361,
                "title": "c-4ms-heavily-commented-solution-clean-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int cnt = 0;\\n    bool is_valid(vector<string> &board, int row, int col){\\n        // check col\\n        for(int i=row;i>=0;--i)\\n            if(board[i][col] == \\'Q\\') return false;\\n        // check left diagonal\\n        for(int i=row,j=col;i>=0&&j>=0;--i,--j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        //check right diagonal\\n        for(int i=row,j=col;i>=0&&j<board.size();--i,++j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        return true;\\n    }\\n    void dfs(vector<string> &board, int row){\\n        // exit condition\\n        if(row == board.size()){\\n            cnt++;\\n            return;\\n        }\\n        // iterate every possible position\\n        for(int i=0;i<board.size();++i){\\n            if(is_valid(board,row,i)){\\n                // make decision\\n                board[row][i] = \\'Q\\';\\n                // next iteration\\n                dfs(board,row+1);\\n                // back-tracking\\n                board[row][i] = \\'.\\';\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n\\t\\t// return 0 if n <= 0\\n        if(n <= 0) return 0;\\n        vector<string> board(n,string(n,\\'.\\'));\\n        dfs(board,0);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cnt = 0;\\n    bool is_valid(vector<string> &board, int row, int col){\\n        // check col\\n        for(int i=row;i>=0;--i)\\n            if(board[i][col] == \\'Q\\') return false;\\n        // check left diagonal\\n        for(int i=row,j=col;i>=0&&j>=0;--i,--j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        //check right diagonal\\n        for(int i=row,j=col;i>=0&&j<board.size();--i,++j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        return true;\\n    }\\n    void dfs(vector<string> &board, int row){\\n        // exit condition\\n        if(row == board.size()){\\n            cnt++;\\n            return;\\n        }\\n        // iterate every possible position\\n        for(int i=0;i<board.size();++i){\\n            if(is_valid(board,row,i)){\\n                // make decision\\n                board[row][i] = \\'Q\\';\\n                // next iteration\\n                dfs(board,row+1);\\n                // back-tracking\\n                board[row][i] = \\'.\\';\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n\\t\\t// return 0 if n <= 0\\n        if(n <= 0) return 0;\\n        vector<string> board(n,string(n,\\'.\\'));\\n        dfs(board,0);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 472966,
                "title": "c-backtracking",
                "content": "For explanation: https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2654/\\n\\n```\\nint totalNQueens(int n) {\\n    vector<int> row(n,0);\\n    vector<vector<int>> board(n, row); // board is n x n filled with 0\\'s (safe)\\n    return backtrackNQueens(board, n, 0, 0);\\n}\\n\\nint backtrackNQueens(vector<vector<int>> &board, int n, int row, int count){\\n    for(int col = 0; col < n; col++){\\n        if(board[row][col] == 0){ // 0 is safe\\n            vector<vector<int>> prevBoard = board; // this is where we will backtrack to\\n            placeQueen(board, n, row, col);\\n            if(row == n-1){\\n                count++;\\n            } else {\\n                count = backtrackNQueens(board, n, row + 1, count);\\n            }\\n            board = prevBoard; // backtrack the last queen\\n        } \\n    }\\n    return count;\\n}\\n\\nvoid placeQueen(vector<vector<int>> &board, int n, int row, int col){\\n    for(int i = 0; i < n; i++){\\n        board[i][col] = 1; // fill vertically\\n        board[row][i] = 1; // fill horizontally \\n        int j = row + col - i; // fill the NE diagonal \\n        if(j >=0 && j < n){\\n            board[i][j] = 1;\\n        }\\n        int k = row - col + i; // fill the SE diagonal\\n        if(k >=0 && k < n){\\n            board[k][i] = 1;\\n        } \\n    }\\n}   \\n```",
                "solutionTags": [],
                "code": "```\\nint totalNQueens(int n) {\\n    vector<int> row(n,0);\\n    vector<vector<int>> board(n, row); // board is n x n filled with 0\\'s (safe)\\n    return backtrackNQueens(board, n, 0, 0);\\n}\\n\\nint backtrackNQueens(vector<vector<int>> &board, int n, int row, int count){\\n    for(int col = 0; col < n; col++){\\n        if(board[row][col] == 0){ // 0 is safe\\n            vector<vector<int>> prevBoard = board; // this is where we will backtrack to\\n            placeQueen(board, n, row, col);\\n            if(row == n-1){\\n                count++;\\n            } else {\\n                count = backtrackNQueens(board, n, row + 1, count);\\n            }\\n            board = prevBoard; // backtrack the last queen\\n        } \\n    }\\n    return count;\\n}\\n\\nvoid placeQueen(vector<vector<int>> &board, int n, int row, int col){\\n    for(int i = 0; i < n; i++){\\n        board[i][col] = 1; // fill vertically\\n        board[row][i] = 1; // fill horizontally \\n        int j = row + col - i; // fill the NE diagonal \\n        if(j >=0 && j < n){\\n            board[i][j] = 1;\\n        }\\n        int k = row - col + i; // fill the SE diagonal\\n        if(k >=0 && k < n){\\n            board[k][i] = 1;\\n        } \\n    }\\n}   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374660,
                "title": "very-easy-to-understand",
                "content": "```java\\nclass Solution {\\n    int count=0;\\n    public int totalNQueens(int n) {\\n        int[] queue = new int[n];\\n        backtrack(0,queue,n);\\n        return count;\\n    }\\n    \\n    private void backtrack(int row,int[] queue,int n){\\n        if(row==n){\\n            count++;\\n        }else{\\n            for(int i=0;i<n;i++){\\n                if(isOk(row,i,queue)){\\n                    queue[row]=i;\\n                    backtrack(row+1,queue,n);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private boolean isOk(int row,int col,int[] queue){\\n        int leftup=col-1,rightup=col+1;\\n        int n=queue.length;\\n        for(int i=row-1;i>=0;i--){\\n            if(queue[i]==col) return false;\\n            if(leftup>=0&&queue[i]==leftup) return false;\\n            if(rightup<n&&queue[i]==rightup) return false;\\n            leftup--;rightup++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\nclass Solution {\\n    int count=0;\\n    public int totalNQueens(int n) {\\n        int[] queue = new int[n];\\n        backtrack(0,queue,n);\\n        return count;\\n    }\\n    \\n    private void backtrack(int row,int[] queue,int n){\\n        if(row==n){\\n            count++;\\n        }else{\\n            for(int i=0;i<n;i++){\\n                if(isOk(row,i,queue)){\\n                    queue[row]=i;\\n                    backtrack(row+1,queue,n);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private boolean isOk(int row,int col,int[] queue){\\n        int leftup=col-1,rightup=col+1;\\n        int n=queue.length;\\n        for(int i=row-1;i>=0;i--){\\n            if(queue[i]==col) return false;\\n            if(leftup>=0&&queue[i]==leftup) return false;\\n            if(rightup<n&&queue[i]==rightup) return false;\\n            leftup--;rightup++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20133,
                "title": "easy-java-python-recursive-iterative-backtracking-solutions",
                "content": "For detail explanation see n-queens [solution][1]\\n\\n**Java recursive**\\n\\n    private int bt(boolean[] c, boolean[] f, boolean[] b, int row, int n) {\\n        if (row == n) return 1;\\n        int ans = 0;\\n        for (int col = 0; col < n; ++col) {\\n            int i = col + row, j = col - row + n;\\n            if (c[col] || f[i] || b[j]) continue;\\n            c[col] = f[i] = b[j] = true;\\n            ans += bt(c, f, b, row + 1, n);\\n            c[col] = f[i] = b[j] = false;\\n        }\\n        return ans;\\n    }\\n\\n    public int totalNQueens(int n) {\\n        return bt(new boolean[n], new boolean[2 * n], new boolean[2 * n], 0, n);\\n    }\\n\\n    // Runtime: 2ms\\n\\n**Java Iterative**\\n\\n    public int totalNQueens(int n) {\\n        int ans = 0;\\n        int[] queens = new int[n];\\n        boolean[] c = new boolean[n + 1];\\n        boolean[] f = new boolean[2 * n];\\n        boolean[] b = new boolean[2 * n];\\n        c[n] = true; //dummy boundary\\n        int col = 0, row = 0;\\n        while (true) {\\n            if (c[col] || f[col + row] || b[col - row + n]) {\\n                if (row == n || col == n) {\\n                    if (row == 0) return ans;\\n                    if (row == n) ans++;\\n                    col = queens[--row];\\n                    c[col] = f[col + row] = b[col - row + n] = false;\\n                }\\n                col++;\\n            } else {\\n                c[col] = f[col + row] = b[col - row + n] = true;\\n                queens[row++] = col;\\n                col = 0;\\n            }\\n        }\\n    }\\n    // Runtime: 4ms\\n\\n**Python iterative**\\n\\n    def totalNQueens(self, n):\\n        row = col = ans = 0\\n        queens = [-1] * n\\n        columns = [True] * n + [False]  # || col with dummy for boundary\\n        back = [True] * n * 2  # \\\\\\\\ col - row\\n        forward = [True] * n * 2  # // col + row\\n        while True:\\n            if columns[col] and back[col - row + n] and forward[col + row]:\\n                queens[row] = col\\n                columns[col] = back[col - row + n] = forward[col + row] = False\\n                row += 1\\n                col = 0\\n            else:\\n                if row == n or col == n:\\n                    if row == n:\\n                        ans += 1\\n                    if row == 0:\\n                        return ans\\n                    row -= 1\\n                    col = queens[row]\\n                    columns[col] = back[col - row + n] = forward[col + row] = True\\n                col += 1\\n\\n    # Runtime: 60 ms\\n\\n\\n  [1]: https://leetcode.com/discuss/63710/ac-python-76-ms-iterative-backtracking-solution",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "For detail explanation see n-queens [solution][1]\\n\\n**Java recursive**\\n\\n    private int bt(boolean[] c, boolean[] f, boolean[] b, int row, int n) {\\n        if (row == n) return 1;\\n        int ans = 0;\\n        for (int col = 0; col < n; ++col) {\\n            int i = col + row, j = col - row + n;\\n            if (c[col] || f[i] || b[j]) continue;\\n            c[col] = f[i] = b[j] = true;\\n            ans += bt(c, f, b, row + 1, n);\\n            c[col] = f[i] = b[j] = false;\\n        }\\n        return ans;\\n    }\\n\\n    public int totalNQueens(int n) {\\n        return bt(new boolean[n], new boolean[2 * n], new boolean[2 * n], 0, n);\\n    }\\n\\n    // Runtime: 2ms\\n\\n**Java Iterative**\\n\\n    public int totalNQueens(int n) {\\n        int ans = 0;\\n        int[] queens = new int[n];\\n        boolean[] c = new boolean[n + 1];\\n        boolean[] f = new boolean[2 * n];\\n        boolean[] b = new boolean[2 * n];\\n        c[n] = true; //dummy boundary\\n        int col = 0, row = 0;\\n        while (true) {\\n            if (c[col] || f[col + row] || b[col - row + n]) {\\n                if (row == n || col == n) {\\n                    if (row == 0) return ans;\\n                    if (row == n) ans++;\\n                    col = queens[--row];\\n                    c[col] = f[col + row] = b[col - row + n] = false;\\n                }\\n                col++;\\n            } else {\\n                c[col] = f[col + row] = b[col - row + n] = true;\\n                queens[row++] = col;\\n                col = 0;\\n            }\\n        }\\n    }\\n    // Runtime: 4ms\\n\\n**Python iterative**\\n\\n    def totalNQueens(self, n):\\n        row = col = ans = 0\\n        queens = [-1] * n\\n        columns = [True] * n + [False]  # || col with dummy for boundary\\n        back = [True] * n * 2  # \\\\\\\\ col - row\\n        forward = [True] * n * 2  # // col + row\\n        while True:\\n            if columns[col] and back[col - row + n] and forward[col + row]:\\n                queens[row] = col\\n                columns[col] = back[col - row + n] = forward[col + row] = False\\n                row += 1\\n                col = 0\\n            else:\\n                if row == n or col == n:\\n                    if row == n:\\n                        ans += 1\\n                    if row == 0:\\n                        return ans\\n                    row -= 1\\n                    col = queens[row]\\n                    columns[col] = back[col - row + n] = forward[col + row] = True\\n                col += 1\\n\\n    # Runtime: 60 ms\\n\\n\\n  [1]: https://leetcode.com/discuss/63710/ac-python-76-ms-iterative-backtracking-solution",
                "codeTag": "Python3"
            },
            {
                "id": 20131,
                "title": "pretty-simple-java-solution",
                "content": " In this problem, no need to keep track of the board content, just pay attention to column, diagonal.\\n   \\n    public class Solution {\\n      Set<Integer> col = new HashSet<Integer>();\\n      Set<Integer> diag1 = new HashSet<Integer>();\\n      Set<Integer> diag2 = new HashSet<Integer>();\\n\\n      public int totalNQueens(int n) {\\n        int[] res = new int[1];\\n        helper(res,n,0);\\n        return res[0];\\n        \\n    }\\n      public void helper(int[] res, int n, int row){\\n        if(row==n){\\n            res[0]++;\\n        }\\n        else{\\n            for(int i=0; i<n; i++){\\n                if(col.contains(i) || diag1.contains(i+row) || diag2.contains(row-i)) continue;\\n                else{\\n                    col.add(i);\\n                    diag1.add(i+row);\\n                    diag2.add(row-i);\\n                    helper(res,n,row+1);\\n                    col.remove(i);\\n                    diag1.remove(i+row);\\n                    diag2.remove(row-i);\\n                }\\n             }\\n          }\\n       }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n      Set<Integer> col = new HashSet<Integer>();\\n      Set<Integer> diag1 = new HashSet<Integer>();\\n      Set<Integer> diag2 = new HashSet<Integer>();\\n\\n      public int totalNQueens(int n) {\\n        int[] res = new int[1];\\n        helper(res,n,0);\\n        return res[0];\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 20164,
                "title": "my-concise-dfs-c-solution-using-three-unordered-map-int-bool",
                "content": "    class Solution {\\n    public:\\n        unordered_map<int, bool> column, obliqueLeft, obliqueRight;\\n        int total;\\n        void NQueensHelper(int row, int n) {\\n            if (row == n+1) {\\n                total++;\\n                return;\\n            }\\n            for (int i = 1; i <= n; i++) {\\n                if (!column[i] && !obliqueLeft[i + row] && !obliqueRight[i - row]) {\\n                    column[i] = obliqueLeft[i + row] = obliqueRight[i - row] = true;\\n                    NQueensHelper(row+1, n);\\n                    column[i] = obliqueLeft[i + row] = obliqueRight[i - row] = false;\\n                }\\n            }\\n        }\\n        int totalNQueens(int n) {\\n            column.clear();\\n            obliqueLeft.clear();\\n            obliqueRight.clear();\\n            total = 0;\\n            NQueensHelper(1, n);\\n            return total;\\n        }\\n    };\\n\\nEach unordered_map represents whether column/left oblique line/right oblique line is occupied before.",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n        unordered_map<int, bool> column, obliqueLeft, obliqueRight;\\n        int total;\\n        void NQueensHelper(int row, int n) {\\n            if (row == n+1) {\\n                total++;\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4018184,
                "title": "cpp-easy-to-understand-backtracking-solution-with-line-by-line-explanation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int x; // A counter to keep track of the total number of solutions.\\n\\n    int totalNQueens(int n) {\\n        vector<string> temp(n, string(n, \\'.\\')); // Create an empty NxN chessboard represented by a vector of strings.\\n        helper(temp, 0, 0, n); // Start the recursive process to find solutions.\\n        return x; // Return the total number of solutions.\\n    }\\n\\n    void helper(vector<string>& temp, int row, int column, int n) {\\n        if (row == n) {\\n            x++; // If a valid solution is found, increment the solution counter.\\n            return;\\n        }\\n\\n        while (column < n) {\\n            if (isvalid(temp, row, column, n)) {\\n                temp[row][column] = \\'Q\\'; // Place a queen at the current position.\\n                helper(temp, row + 1, 0, n); // Recursively try to place queens in the next row.\\n                temp[row][column] = \\'.\\'; // Backtrack by removing the queen from the current position.\\n            }\\n            column++;\\n        }\\n    }\\n\\n    bool isvalid(vector<string>& temp, int row, int col, int n) {\\n        // Check if it\\'s valid to place a queen at the current position without conflicts.\\n        for (int i = 0; i < row; i++) {\\n            if (temp[i][col] == \\'Q\\') {\\n                return false; // Check for conflicts in the same column.\\n            }\\n        }\\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\\n            if (temp[i][j] == \\'Q\\') {\\n                return false; // Check for conflicts in the upper-left diagonal.\\n            }\\n        }\\n        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\\n            if (temp[i][j] == \\'Q\\') {\\n                return false; // Check for conflicts in the upper-right diagonal.\\n            }\\n        }\\n        return true; // No conflicts found, it\\'s a valid placement.\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int x; // A counter to keep track of the total number of solutions.\\n\\n    int totalNQueens(int n) {\\n        vector<string> temp(n, string(n, \\'.\\')); // Create an empty NxN chessboard represented by a vector of strings.\\n        helper(temp, 0, 0, n); // Start the recursive process to find solutions.\\n        return x; // Return the total number of solutions.\\n    }\\n\\n    void helper(vector<string>& temp, int row, int column, int n) {\\n        if (row == n) {\\n            x++; // If a valid solution is found, increment the solution counter.\\n            return;\\n        }\\n\\n        while (column < n) {\\n            if (isvalid(temp, row, column, n)) {\\n                temp[row][column] = \\'Q\\'; // Place a queen at the current position.\\n                helper(temp, row + 1, 0, n); // Recursively try to place queens in the next row.\\n                temp[row][column] = \\'.\\'; // Backtrack by removing the queen from the current position.\\n            }\\n            column++;\\n        }\\n    }\\n\\n    bool isvalid(vector<string>& temp, int row, int col, int n) {\\n        // Check if it\\'s valid to place a queen at the current position without conflicts.\\n        for (int i = 0; i < row; i++) {\\n            if (temp[i][col] == \\'Q\\') {\\n                return false; // Check for conflicts in the same column.\\n            }\\n        }\\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\\n            if (temp[i][j] == \\'Q\\') {\\n                return false; // Check for conflicts in the upper-left diagonal.\\n            }\\n        }\\n        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\\n            if (temp[i][j] == \\'Q\\') {\\n                return false; // Check for conflicts in the upper-right diagonal.\\n            }\\n        }\\n        return true; // No conflicts found, it\\'s a valid placement.\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839385,
                "title": "juggad-solution-beats-100-please-see-once-easiest-and-funniest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2||n==3)\\n        return 0;\\n        if(n==4)\\n        return 2;\\n        if(n==5)\\n        return 10;\\n        if(n==6)\\n        return 4;\\n        if(n==7)\\n        return 40;\\n        if(n==8)\\n        return 92;\\n        return 352;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2||n==3)\\n        return 0;\\n        if(n==4)\\n        return 2;\\n        if(n==5)\\n        return 10;\\n        if(n==6)\\n        return 4;\\n        if(n==7)\\n        return 40;\\n        if(n==8)\\n        return 92;\\n        return 352;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553872,
                "title": "swift-tc-100-sc-100-backtracking-bit-manipulation",
                "content": "\\n# Approach\\nHere we use bit manipulation technique to keep track of visited nodes instead of using **sets**. Thus, improved TC and SC. But SC is still $$O(n)$$ due to the recursion call stack.\\n\\n# Complexity\\n- Time complexity: $$O(n!)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func totalNQueens(_ n: Int) -> Int {\\n        func backtrack(_ row: Int, _ cols: Int, _ diagonals: Int, _ antidiagonals: Int) -> Int {\\n            if row == n { return 1 }\\n\\n            var solution = 0\\n            for col in 0..<n {\\n                let currentDiagonal = 1 << (row - col + n)\\n                let currentAntiDiagonal = 1 << (row + col)\\n                let currCol = 1 << col\\n\\n                if  (cols & currCol) != 0 || \\n                    (diagonals & currentDiagonal) != 0 || \\n                    (antidiagonals & currentAntiDiagonal) != 0 { \\n                        continue \\n                }\\n                var cols = cols, diagonals = diagonals, antidiagonals = antidiagonals\\n                cols ^= currCol\\n                diagonals ^= currentDiagonal\\n                antidiagonals ^= currentAntiDiagonal\\n\\n                solution += backtrack(row + 1, cols, diagonals, antidiagonals)\\n            }\\n            return solution\\n        }\\n\\n        return backtrack(0, 0, 0, 0)\\n    }\\n}\\n```\\n\\n> ***Please upvote if you like it***",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func totalNQueens(_ n: Int) -> Int {\\n        func backtrack(_ row: Int, _ cols: Int, _ diagonals: Int, _ antidiagonals: Int) -> Int {\\n            if row == n { return 1 }\\n\\n            var solution = 0\\n            for col in 0..<n {\\n                let currentDiagonal = 1 << (row - col + n)\\n                let currentAntiDiagonal = 1 << (row + col)\\n                let currCol = 1 << col\\n\\n                if  (cols & currCol) != 0 || \\n                    (diagonals & currentDiagonal) != 0 || \\n                    (antidiagonals & currentAntiDiagonal) != 0 { \\n                        continue \\n                }\\n                var cols = cols, diagonals = diagonals, antidiagonals = antidiagonals\\n                cols ^= currCol\\n                diagonals ^= currentDiagonal\\n                antidiagonals ^= currentAntiDiagonal\\n\\n                solution += backtrack(row + 1, cols, diagonals, antidiagonals)\\n            }\\n            return solution\\n        }\\n\\n        return backtrack(0, 0, 0, 0)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470773,
                "title": "backtracking-c-with-diagonals",
                "content": "# Intuition\\nTrack which column and diagonals are used by using 3 bool arrays.\\n\\n# Approach\\nIntroduce 3 arrays which track which columns and diagonals are occupied. Map diagonal indices using the following mapping:\\n\\n```\\n/*\\ndiagonal1:\\n     |r=0   1   2   3\\n-----+---------------\\n c=0 |  0   1   2   3\\n   1 | -1   0   1   2\\n   2 | -2  -1   0   1\\n   3 | -3  -2  -1   0\\n\\nD1(row, col) = col - row\\n\\ndiagonal2:\\n     |r=0   1   2   3\\n-----+---------------\\n c=0 |  3   2   1   0\\n   1 |  2   1   0  -1\\n   2 |  1   0  -1  -2\\n   3 |  0  -1  -2  -3\\n\\nD2(row, col) = N-1 - col - row\\n*/\\n```\\n\\nThey need to be positive, so move them up by another N-1.\\n\\n# Code\\n```\\nclass Solution {\\n  static constexpr int SIZE = 9;\\n\\n  bool column_occupied[SIZE] = {};\\n  bool diagonal1_occupied[2*SIZE] = {};\\n  bool diagonal2_occupied[2*SIZE] = {};\\n\\npublic:\\n  int totalNQueens(int n) {\\n    return solve(n, 0);\\n  }\\n\\nprivate: \\n  int solve(int n, int row) {\\n    if (row == n) return 1; // found a valid solution!\\n\\n    int sum = 0;\\n    for (int col = 0; col < n; col++) {\\n      bool &column_used = column_occupied[col];\\n      bool &diagonal1_used = diagonal1_occupied[n-1 + col - row];\\n      bool &diagonal2_used = diagonal2_occupied[2*(n-1) - col - row];\\n\\n      if (!column_used && !diagonal1_used && !diagonal2_used) {\\n        column_used = diagonal1_used = diagonal2_used = true;\\n        sum += solve(n, row+1);\\n        column_used = diagonal1_used = diagonal2_used = false;\\n      }\\n    }\\n    return sum;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\n/*\\ndiagonal1:\\n     |r=0   1   2   3\\n-----+---------------\\n c=0 |  0   1   2   3\\n   1 | -1   0   1   2\\n   2 | -2  -1   0   1\\n   3 | -3  -2  -1   0\\n\\nD1(row, col) = col - row\\n\\ndiagonal2:\\n     |r=0   1   2   3\\n-----+---------------\\n c=0 |  3   2   1   0\\n   1 |  2   1   0  -1\\n   2 |  1   0  -1  -2\\n   3 |  0  -1  -2  -3\\n\\nD2(row, col) = N-1 - col - row\\n*/\\n```\n```\\nclass Solution {\\n  static constexpr int SIZE = 9;\\n\\n  bool column_occupied[SIZE] = {};\\n  bool diagonal1_occupied[2*SIZE] = {};\\n  bool diagonal2_occupied[2*SIZE] = {};\\n\\npublic:\\n  int totalNQueens(int n) {\\n    return solve(n, 0);\\n  }\\n\\nprivate: \\n  int solve(int n, int row) {\\n    if (row == n) return 1; // found a valid solution!\\n\\n    int sum = 0;\\n    for (int col = 0; col < n; col++) {\\n      bool &column_used = column_occupied[col];\\n      bool &diagonal1_used = diagonal1_occupied[n-1 + col - row];\\n      bool &diagonal2_used = diagonal2_occupied[2*(n-1) - col - row];\\n\\n      if (!column_used && !diagonal1_used && !diagonal2_used) {\\n        column_used = diagonal1_used = diagonal2_used = true;\\n        sum += solve(n, row+1);\\n        column_used = diagonal1_used = diagonal2_used = false;\\n      }\\n    }\\n    return sum;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270721,
                "title": "python3-backtracking-easy-solution-beats-98",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        ans=0\\n        left,upleft,lowleft=[0]*n,[0]*(2*n-1),[0]*(2*n-1)\\n        def solve(col,board):\\n            nonlocal ans\\n            if col==n:\\n                ans+=1\\n                return \\n            for row in range(n):\\n                if not left[row] and not upleft[row+col] and not lowleft[n-1+row-col]:\\n                    board[row][col]=\"Q\"\\n                    left[row],upleft[row+col],lowleft[n-1+row-col]=1,1,1\\n                    solve(col+1,board)\\n                    board[row][col]=\".\"\\n                    left[row],upleft[row+col],lowleft[n-1+row-col]=0,0,0\\n        board=[[\".\" for i in range(n)] for _ in range(n)]\\n        solve(0,board)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        ans=0\\n        left,upleft,lowleft=[0]*n,[0]*(2*n-1),[0]*(2*n-1)\\n        def solve(col,board):\\n            nonlocal ans\\n            if col==n:\\n                ans+=1\\n                return \\n            for row in range(n):\\n                if not left[row] and not upleft[row+col] and not lowleft[n-1+row-col]:\\n                    board[row][col]=\"Q\"\\n                    left[row],upleft[row+col],lowleft[n-1+row-col]=1,1,1\\n                    solve(col+1,board)\\n                    board[row][col]=\".\"\\n                    left[row],upleft[row+col],lowleft[n-1+row-col]=0,0,0\\n        board=[[\".\" for i in range(n)] for _ in range(n)]\\n        solve(0,board)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209817,
                "title": "c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n\\tvector<vector<bool>> board(n, vector<bool>(n, false));\\n\\treturn solve(board, 0);\\n    }\\n    bool isSafe(vector<vector<bool>>& board, int row, int col) {\\n\\t    int n = size(board);\\n\\t    for(int i = 0; i <= row; i++) {\\n\\t\\t    if(board[i][col]) return false; \\n\\t\\t    if(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\\n\\t\\t    if(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\\n\\t    }\\n\\t    return true;\\n    }    \\n    int solve(vector<vector<bool>>& board, int row) {\\n\\t    if(row == size(board)) return 1;\\n\\t    int count = 0;\\n\\t    for(int col = 0; col < size(board); col++)           \\n\\t\\t    if(isSafe(board, row, col)){          \\n\\t\\t\\t    board[row][col] = true;          \\n\\t\\t\\t    count += solve(board, row + 1);  \\n\\t\\t\\t    board[row][col] = false;         \\n\\t\\t    }                                \\n\\t    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n\\tvector<vector<bool>> board(n, vector<bool>(n, false));\\n\\treturn solve(board, 0);\\n    }\\n    bool isSafe(vector<vector<bool>>& board, int row, int col) {\\n\\t    int n = size(board);\\n\\t    for(int i = 0; i <= row; i++) {\\n\\t\\t    if(board[i][col]) return false; \\n\\t\\t    if(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\\n\\t\\t    if(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\\n\\t    }\\n\\t    return true;\\n    }    \\n    int solve(vector<vector<bool>>& board, int row) {\\n\\t    if(row == size(board)) return 1;\\n\\t    int count = 0;\\n\\t    for(int col = 0; col < size(board); col++)           \\n\\t\\t    if(isSafe(board, row, col)){          \\n\\t\\t\\t    board[row][col] = true;          \\n\\t\\t\\t    count += solve(board, row + 1);  \\n\\t\\t\\t    board[row][col] = false;         \\n\\t\\t    }                                \\n\\t    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938038,
                "title": "very-very-easy-solution-in-0-1-time-java-100",
                "content": "```\\npublic int totalNQueens(int n) {\\n        if(n == 1)\\n            return 1;\\n        if(n < 4)\\n            return 0;\\n        if(n == 4)\\n            return 2;\\n        if(n == 5)\\n            return 10;\\n        if(n == 6)\\n            return 4;\\n        if(n == 7)\\n            return 40;\\n        if(n == 8)\\n            return 92;\\n        return 352;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int totalNQueens(int n) {\\n        if(n == 1)\\n            return 1;\\n        if(n < 4)\\n            return 0;\\n        if(n == 4)\\n            return 2;\\n        if(n == 5)\\n            return 10;\\n        if(n == 6)\\n            return 4;\\n        if(n == 7)\\n            return 40;\\n        if(n == 8)\\n            return 92;\\n        return 352;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2859048,
                "title": "java-n-queens-2-using-recursion-easy-understanding",
                "content": "```\\nclass Solution {\\n    int count = 0;\\n    public int totalNQueens(int n) {\\n        char[][] board = new char[n][n];\\n        helper(board,0,n);\\n        return count;\\n    }\\n    public boolean isSafe(char[][] board,int row,int col)\\n\\t{\\n\\t\\t//Vertical\\n\\t\\tfor(int i=0;i<board.length;i++)\\n\\t\\t{\\n\\t\\t\\tif(board[row][i]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Horizontal\\n\\t\\tfor(int i=0;i<board.length;i++)\\n\\t\\t{\\n\\t\\t\\tif(board[i][col]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Top-Left\\n\\t\\tfor(int i=row,j=col;i>=0 && j>=0;i--,j--)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Top-Right\\n\\t\\tfor(int i=row,j=col;i>=0 && j<board.length;i--,j++)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Bottom-Left\\n\\t\\tfor(int i=row,j=col;i<board.length && j>=0;i++,j--)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Bottom-Right\\n\\t\\tfor(int i=row,j=col;i<board.length && j<board.length;i++,j++)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn true;\\n\\t}\\n    \\n    public void helper(char[][] board,int col,int row )\\n\\t{\\n\\t\\tfor(int i=0;i<row;i++)\\n\\t\\t{\\n\\t\\t\\tif(col==row)\\t\\n\\t\\t\\t{\\n                count++;\\n                return;\\n\\t\\t\\t}\\n\\t\\t\\tif(isSafe(board,i,col))\\n\\t\\t\\t{\\n\\t\\t\\t\\tboard[i][col] = \\'Q\\';\\n\\t\\t\\t\\thelper(board,col+1,row);\\t\\n\\t\\t\\t\\tboard[i][col] = \\' \\';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public int totalNQueens(int n) {\\n        char[][] board = new char[n][n];\\n        helper(board,0,n);\\n        return count;\\n    }\\n    public boolean isSafe(char[][] board,int row,int col)\\n\\t{\\n\\t\\t//Vertical\\n\\t\\tfor(int i=0;i<board.length;i++)\\n\\t\\t{\\n\\t\\t\\tif(board[row][i]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Horizontal\\n\\t\\tfor(int i=0;i<board.length;i++)\\n\\t\\t{\\n\\t\\t\\tif(board[i][col]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Top-Left\\n\\t\\tfor(int i=row,j=col;i>=0 && j>=0;i--,j--)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Top-Right\\n\\t\\tfor(int i=row,j=col;i>=0 && j<board.length;i--,j++)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Bottom-Left\\n\\t\\tfor(int i=row,j=col;i<board.length && j>=0;i++,j--)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Bottom-Right\\n\\t\\tfor(int i=row,j=col;i<board.length && j<board.length;i++,j++)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn true;\\n\\t}\\n    \\n    public void helper(char[][] board,int col,int row )\\n\\t{\\n\\t\\tfor(int i=0;i<row;i++)\\n\\t\\t{\\n\\t\\t\\tif(col==row)\\t\\n\\t\\t\\t{\\n                count++;\\n                return;\\n\\t\\t\\t}\\n\\t\\t\\tif(isSafe(board,i,col))\\n\\t\\t\\t{\\n\\t\\t\\t\\tboard[i][col] = \\'Q\\';\\n\\t\\t\\t\\thelper(board,col+1,row);\\t\\n\\t\\t\\t\\tboard[i][col] = \\' \\';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798719,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    int nl;\\n\\n    bool check(vector<string> &v, int row, int col) {\\n        /* Check this row on left side */\\n        for(int i=0; i<col; i++) if(v[row][i] == \\'Q\\') return false;\\n        /* Check upper diagonal on left side */\\n        for(int i=row, j=col; i>=0 and j>=0; i--, j--) if(v[i][j] == \\'Q\\') return false;\\n        /* Check lower diagonal on left side */\\n        for(int i=row, j=col; j>=0 and i<nl; i++, j--) if(v[i][j] == \\'Q\\') return false;\\n\\n        return true;\\n    }\\n\\n    void solve(vector<string> &v, int col) {\\n        if(col >= nl) {\\n            ans.push_back(v);\\n            return;\\n        }\\n        \\n        for(int i=0; i<nl; i++) {\\n            if(check(v, i, col)) {\\n                v[i][col] = \\'Q\\';\\n                solve(v, col+1);\\n                v[i][col] = \\'.\\';\\n            }\\n        }\\n    }\\n\\n    int totalNQueens(int n) {\\n        nl = n;\\n        vector<string> v(nl, string(nl, \\'.\\'));\\n        solve(v, 0);\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    int nl;\\n\\n    bool check(vector<string> &v, int row, int col) {\\n        /* Check this row on left side */\\n        for(int i=0; i<col; i++) if(v[row][i] == \\'Q\\') return false;\\n        /* Check upper diagonal on left side */\\n        for(int i=row, j=col; i>=0 and j>=0; i--, j--) if(v[i][j] == \\'Q\\') return false;\\n        /* Check lower diagonal on left side */\\n        for(int i=row, j=col; j>=0 and i<nl; i++, j--) if(v[i][j] == \\'Q\\') return false;\\n\\n        return true;\\n    }\\n\\n    void solve(vector<string> &v, int col) {\\n        if(col >= nl) {\\n            ans.push_back(v);\\n            return;\\n        }\\n        \\n        for(int i=0; i<nl; i++) {\\n            if(check(v, i, col)) {\\n                v[i][col] = \\'Q\\';\\n                solve(v, col+1);\\n                v[i][col] = \\'.\\';\\n            }\\n        }\\n    }\\n\\n    int totalNQueens(int n) {\\n        nl = n;\\n        vector<string> v(nl, string(nl, \\'.\\'));\\n        solve(v, 0);\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797884,
                "title": "java-o-n-n-n-87-faster-easy-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe\\'ll use the concept of **Backtracking** for this problem.\\nNow, the basic approach that one can think of would be to check each cell that is it a potential position for the queen to be placed.. !!\\n\\n*Well, we\\'ll implement the above approach itself but it in a more optimised manner using backtracking.*\\n\\nSteps to be followed ->\\n\\n - For each row of the ```chess```, we\\'ll place the queen at a specific column and will recursively check that is the remaining part of the grid able to place rest queens or not..\\n - For eg, for row or ```currLevel=0```, we first place the queen at column ```i=0``` and then will recursively call the next level or row. \\n - Now, we\\'ll check that is it safe for the queen to be placed at ```chess[currLevel][i]``` using ```isSafeForQueen(currLevel, i)```. If the position is valid, we place the queen, and similarly pass to the next level.\\n - In case, the queen doesn\\'t find any appropriate position for the ```currLevel```, we\\'ll fallback to previous level and **will *remove (backtracking)* the queen present in previous row and will try the next position.**\\n - Now, if we reach to the condition ```currLevel = n```, it means we have successfully encountered a ```way``` and hence, we return ```1``` corresponding to that way.\\n\\nFollowing above steps, we can easily frame the solution.\\n\\n# Complexity\\n- Time complexity: $$O(n^n*n)$$ - **(Beats 87%)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$Kindly$$ $$upvote$$ $$if$$ $$you$$ $$understood$$ $$the$$ $$solution.. :)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    static int[][] chess;\\n    public int totalNQueens(int n) {\\n        chess = new int[n][n];\\n        return solveNQueensHelper(n, 0);\\n    }\\n    public static int solveNQueensHelper(int n, int currLevel) {\\n        if(currLevel == n){\\n            return 1;\\n        }\\n        int ways = 0;\\n        for(int i = 0; i < n; i++){\\n            if(isSafeForQueen(currLevel, i)){\\n                chess[currLevel][i] = 1;\\n                ways += solveNQueensHelper(n, currLevel+1);\\n                chess[currLevel][i] = 0;\\n            }\\n        }\\n        return ways;\\n    }\\n\\n    public static boolean isSafeForQueen(int r, int c) { \\n        //col\\n        for(int i = r-1; i >= 0; i--){\\n            if(chess[i][c] == 1) return false;\\n        }\\n        //right dia\\n        for(int i = r-1, j = c+1; i >= 0 && j < chess.length; i--, j++){\\n            if(chess[i][j] == 1) return false;\\n        }\\n        //left dia\\n        for(int i = r-1, j = c-1; i >= 0 && j >= 0; i--, j--){\\n            if(chess[i][j] == 1) return false;\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking"
                ],
                "code": "```chess```\n```currLevel=0```\n```i=0```\n```chess[currLevel][i]```\n```isSafeForQueen(currLevel, i)```\n```currLevel```\n```currLevel = n```\n```way```\n```1```\n```\\nclass Solution {\\n\\n    static int[][] chess;\\n    public int totalNQueens(int n) {\\n        chess = new int[n][n];\\n        return solveNQueensHelper(n, 0);\\n    }\\n    public static int solveNQueensHelper(int n, int currLevel) {\\n        if(currLevel == n){\\n            return 1;\\n        }\\n        int ways = 0;\\n        for(int i = 0; i < n; i++){\\n            if(isSafeForQueen(currLevel, i)){\\n                chess[currLevel][i] = 1;\\n                ways += solveNQueensHelper(n, currLevel+1);\\n                chess[currLevel][i] = 0;\\n            }\\n        }\\n        return ways;\\n    }\\n\\n    public static boolean isSafeForQueen(int r, int c) { \\n        //col\\n        for(int i = r-1; i >= 0; i--){\\n            if(chess[i][c] == 1) return false;\\n        }\\n        //right dia\\n        for(int i = r-1, j = c+1; i >= 0 && j < chess.length; i--, j++){\\n            if(chess[i][j] == 1) return false;\\n        }\\n        //left dia\\n        for(int i = r-1, j = c-1; i >= 0 && j >= 0; i--, j--){\\n            if(chess[i][j] == 1) return false;\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720473,
                "title": "java-easy-code-recursion-backtracking",
                "content": "Solved using a Boolean Matrix of N size. \\nIn recusive calls it will check if putting the Queen is Safe if not Backtrack.\\n\\n\\n\\n\\n\\n\\n        \\n    class Solution {\\n    public int totalNQueens(int n) {\\n      boolean[][] board = new boolean[n][n];\\n      return queens(board,0);\\n        \\n    }\\n    int queens(boolean[][] board,int row)\\n\\t{\\n\\t\\tif(row==board.length){\\n            return 1;\\n        }\\n        \\n        int count = 0;\\n        // Placing Queens and Checking for every row and column\\n        for(int col=0;col<board.length;col++){\\n            //place queen if Safe\\n            if(isSafe(board,row,col)){\\n                board[row][col] = true;\\n                count += queens(board,row+1); //Recursive call\\n                board[row][col] = false;    // Backtrack\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    boolean isSafe(boolean[][] board, int row ,int col){\\n        \\n        // Vertical row\\n        for(int i=0;i<row;i++){\\n            if(board[i][col])\\n                return false;\\n        }\\n        \\n        // Left diagonal\\n        int maxLeft = Math.min(row,col);\\n        for(int i=1;i<=maxLeft;i++){\\n            if(board[row-i][col-i]){\\n                return false;\\n            }\\n        }\\n        \\n        // Right diagonal\\n        int maxRight = Math.min(row,board.length-col-1);\\n        for(int i=1;i<=maxRight;i++){\\n            if(board[row-i][col+i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n}\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int totalNQueens(int n) {\\n      boolean[][] board = new boolean[n][n];\\n      return queens(board,0);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2559395,
                "title": "java-solution-using-backtracking-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n       boolean[][] board = new boolean[n][n];\\n       return queens(board,0);\\n    }\\n\\tstatic int queens(boolean[][] board,int row){\\n        if(row == board.length){\\n            return 1;\\n        }\\n        int count = 0;\\n        //placing the queens and checking for every row and col\\n        for(int col = 0;col< board.length;col++){\\n            //place the queen if it is safe\\n            if(issafe(board,row,col)){\\n                board[row][col]=true;\\n                count += queens(board,row+1);\\n                board[row][col] = false;\\n            }\\n        }\\n        return count;\\n    }\\n    //checks all pssible safe blocks for the queens\\n    static boolean issafe(boolean[][] board,int row,int col){\\n        //check vertical row\\n        for (int i = 0; i < row; i++) {\\n            if(board[i][col]){\\n                return false;\\n            }\\n        }\\n        //check for diagonal left\\n        int maxleft = Math.min(row,col);\\n        for (int i = 1; i <= maxleft; i++) {\\n            if(board[row-i][col-i]){\\n                return false;\\n            }\\n        }\\n        //checks for diagonal rigth\\n        int maxright = Math.min(row,board.length-col-1);\\n        for (int i = 1; i <= maxright; i++) {\\n            if(board[row-i][col+i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n       boolean[][] board = new boolean[n][n];\\n       return queens(board,0);\\n    }\\n\\tstatic int queens(boolean[][] board,int row){\\n        if(row == board.length){\\n            return 1;\\n        }\\n        int count = 0;\\n        //placing the queens and checking for every row and col\\n        for(int col = 0;col< board.length;col++){\\n            //place the queen if it is safe\\n            if(issafe(board,row,col)){\\n                board[row][col]=true;\\n                count += queens(board,row+1);\\n                board[row][col] = false;\\n            }\\n        }\\n        return count;\\n    }\\n    //checks all pssible safe blocks for the queens\\n    static boolean issafe(boolean[][] board,int row,int col){\\n        //check vertical row\\n        for (int i = 0; i < row; i++) {\\n            if(board[i][col]){\\n                return false;\\n            }\\n        }\\n        //check for diagonal left\\n        int maxleft = Math.min(row,col);\\n        for (int i = 1; i <= maxleft; i++) {\\n            if(board[row-i][col-i]){\\n                return false;\\n            }\\n        }\\n        //checks for diagonal rigth\\n        int maxright = Math.min(row,board.length-col-1);\\n        for (int i = 1; i <= maxright; i++) {\\n            if(board[row-i][col+i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115816,
                "title": "just-1-line-solution-check-once",
                "content": "class Solution {\\npublic:\\n   int totalNQueens(int n) \\n   {\\n       return array<int, 13>{0,1,0,0,2,10,4,40,92,352,724,2680,14200}[n];\\n   }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   int totalNQueens(int n) \\n   {\\n       return array<int, 13>{0,1,0,0,2,10,4,40,92,352,724,2680,14200}",
                "codeTag": "Java"
            },
            {
                "id": 2115112,
                "title": "java-backtracking-comment-added",
                "content": "```\\nclass Solution {\\n    \\n   int answer;\\n    public int totalNQueens(int n) {\\n        \\n        answer = 0;\\n        \\n        // create a n*n chessboard\\n        char[][] board = new char[n][n];\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n        \\n        placeNQueens(board, 0, n); // 0 is row number(we will fill rowwise)\\n        \\n        return answer;\\n    }\\n    \\n    private void placeNQueens(char[][] board, int row, int n){\\n        \\n        // base case\\n        if(row == n){\\n            answer++; // valid configuration found\\n            return;\\n        }\\n        \\n        // check for all columns\\n            // check if its safe to place queen\\n                // if its safe -> then place the queen and move to next row\\n        for(int col = 0; col < n ; col++){\\n            if (isSafe(board, row, col, n)){\\n                board[row][col] = \\'Q\\';\\n                placeNQueens(board, row+1, n);\\n                board[row][col] = \\'.\\'; // remove queen while backtracking\\n            }\\n        }\\n    }\\n    \\n    private boolean isSafe(char[][] board, int row, int col, int n){\\n\\n        // check column on upper side\\n        for (int i = row; i >= 0; i--){\\n            if (board[i][col] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        // check upper diagonal on left side\\n        for (int i = row, j = col; i >= 0 && j >= 0; i--, j--){\\n            if (board[i][j] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        // check upper diagonal on right side\\n        for (int i = row, j = col; i >= 0 && j < n; i--, j++){\\n            if (board[i][j] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n   int answer;\\n    public int totalNQueens(int n) {\\n        \\n        answer = 0;\\n        \\n        // create a n*n chessboard\\n        char[][] board = new char[n][n];\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n        \\n        placeNQueens(board, 0, n); // 0 is row number(we will fill rowwise)\\n        \\n        return answer;\\n    }\\n    \\n    private void placeNQueens(char[][] board, int row, int n){\\n        \\n        // base case\\n        if(row == n){\\n            answer++; // valid configuration found\\n            return;\\n        }\\n        \\n        // check for all columns\\n            // check if its safe to place queen\\n                // if its safe -> then place the queen and move to next row\\n        for(int col = 0; col < n ; col++){\\n            if (isSafe(board, row, col, n)){\\n                board[row][col] = \\'Q\\';\\n                placeNQueens(board, row+1, n);\\n                board[row][col] = \\'.\\'; // remove queen while backtracking\\n            }\\n        }\\n    }\\n    \\n    private boolean isSafe(char[][] board, int row, int col, int n){\\n\\n        // check column on upper side\\n        for (int i = row; i >= 0; i--){\\n            if (board[i][col] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        // check upper diagonal on left side\\n        for (int i = row, j = col; i >= 0 && j >= 0; i--, j--){\\n            if (board[i][j] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        // check upper diagonal on right side\\n        for (int i = row, j = col; i >= 0 && j < n; i--, j++){\\n            if (board[i][j] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114767,
                "title": "java-easy-understand-stack",
                "content": "\\nWe can check the board usign below \\n1. First one is to add the both row and column values (Which is stored in Positive digonal stack)\\n2. Second is to subract and store them in the Negative Digonal stack\\n3. Store each coulmn value in another stack\\n4. These stack helps in verifying the Queen\\'s position\\n\\n```\\n        0                  1       2      3 \\n0   (0+0=0) ,(0-0=0)    (0,-1)  (0,-2)  (0,-3)\\n1   (1,1)               (2,0)   (3,-1)  (4,-2)\\n2   ( 2, 2 )            (3,1)   (4,0)   (5,-1)\\n3   (3,3)               (4,2)   (5,1)   (6,0)\\n```\\n\\nFrom above diagram we can observe that all the additon value in the diagonal are same and  subracted values are same. \\nWe use this login and Push and pop the elements based on our traversal\\n\\n```\\n\\nclass Solution {\\n     int ans = 0;\\n     Stack<Integer> positiveDiagonal = new Stack<>();\\n     Stack<Integer> negativeDiagonal = new Stack<>();\\n\\n    public  int totalNQueens(int n) {\\n        int[][] board = new int[n][n];\\n        Stack<Integer> row = new Stack<>();\\n        for (int i = 0; i < n; i++) {\\n            row.push(i);\\n            positiveDiagonal.push(i);\\n\\t\\t\\t// Inserting the value of diagonol\\n            negativeDiagonal.push(-i);\\n            solve(1, row, n-1,n);\\n\\t\\t\\t//Checking the board for each position in the first place then traverse the remaining  place\\n            positiveDiagonal.pop();\\n            negativeDiagonal.pop();\\n            row.pop();\\n        }\\n        return ans;\\n    }\\n\\n    public  void solve(int start, Stack<Integer> row, int size, int n) {\\n\\n        if (size==0) {\\n            ans += 1;\\n            return;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n\\t\\t// Check each element if that postion is good or not\\n            if (verifyPosition(start, i, row)) {\\n                row.push(i);\\n                positiveDiagonal.push(start + i);\\n                negativeDiagonal.push(start - i);\\n                solve(start + 1, row, size-1,n);\\n                positiveDiagonal.pop();\\n                negativeDiagonal.pop();\\n                row.pop();\\n            }\\n        }\\n    }\\n\\n    public  boolean verifyPosition(int start, int i, Stack<Integer> row) {\\n\\n        return !(row.contains(i) || positiveDiagonal.contains(start + i) || negativeDiagonal.contains(start - i));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Stack"
                ],
                "code": "```\\n        0                  1       2      3 \\n0   (0+0=0) ,(0-0=0)    (0,-1)  (0,-2)  (0,-3)\\n1   (1,1)               (2,0)   (3,-1)  (4,-2)\\n2   ( 2, 2 )            (3,1)   (4,0)   (5,-1)\\n3   (3,3)               (4,2)   (5,1)   (6,0)\\n```\n```\\n\\nclass Solution {\\n     int ans = 0;\\n     Stack<Integer> positiveDiagonal = new Stack<>();\\n     Stack<Integer> negativeDiagonal = new Stack<>();\\n\\n    public  int totalNQueens(int n) {\\n        int[][] board = new int[n][n];\\n        Stack<Integer> row = new Stack<>();\\n        for (int i = 0; i < n; i++) {\\n            row.push(i);\\n            positiveDiagonal.push(i);\\n\\t\\t\\t// Inserting the value of diagonol\\n            negativeDiagonal.push(-i);\\n            solve(1, row, n-1,n);\\n\\t\\t\\t//Checking the board for each position in the first place then traverse the remaining  place\\n            positiveDiagonal.pop();\\n            negativeDiagonal.pop();\\n            row.pop();\\n        }\\n        return ans;\\n    }\\n\\n    public  void solve(int start, Stack<Integer> row, int size, int n) {\\n\\n        if (size==0) {\\n            ans += 1;\\n            return;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n\\t\\t// Check each element if that postion is good or not\\n            if (verifyPosition(start, i, row)) {\\n                row.push(i);\\n                positiveDiagonal.push(start + i);\\n                negativeDiagonal.push(start - i);\\n                solve(start + 1, row, size-1,n);\\n                positiveDiagonal.pop();\\n                negativeDiagonal.pop();\\n                row.pop();\\n            }\\n        }\\n    }\\n\\n    public  boolean verifyPosition(int start, int i, Stack<Integer> row) {\\n\\n        return !(row.contains(i) || positiveDiagonal.contains(start + i) || negativeDiagonal.contains(start - i));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114708,
                "title": "c-efficient-code",
                "content": "class Solution {\\npublic:\\n    \\n    int count=0;\\n    \\n    void  solve(int col,vector<int> &left,vector<int> &upperDiagnol,vector<int> &lowerDiagnol,int n)\\n    {\\n         if(col==n)\\n         {\\n             count++; \\n             return;\\n         }\\n      \\n      for(int row=0;row<n;row++)\\n      {\\n          if(left[row]==0 && lowerDiagnol[row+col]==0 && upperDiagnol[n-1+col-row]==0)\\n          {\\n              left[row]=1;\\n              lowerDiagnol[row+col]=1;\\n              upperDiagnol[n-1+col-row]=1;\\n              solve(col+1,left,upperDiagnol,lowerDiagnol,n);\\n              left[row]=0;\\n              lowerDiagnol[row+col]=0;\\n              upperDiagnol[n-1+col-row]=0;\\n              \\n              \\n          }\\n      }\\n    }\\n        \\n    int totalNQueens(int n) \\n    {\\n        vector<int> left(n,0);\\n        vector<int> upperDiagnol(2*n-1,0);\\n        vector<int> lowerDiagnol(2*n-1,0);\\n        \\n        solve(0,left,upperDiagnol,lowerDiagnol,n);\\n        \\n        return count;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int count=0;\\n    \\n    void  solve(int col,vector<int> &left,vector<int> &upperDiagnol,vector<int> &lowerDiagnol,int n)\\n    {\\n         if(col==n)\\n         {\\n             count++; \\n             return;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2113019,
                "title": "c-extension-of-n-queens-just-one-line-change",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(int col, int n, vector<vector<string>>& ans , vector<string>& board, vector<int>& left, vector<int>& upperDigonal ,vector<int>& lowerDigonal)\\n    {\\n        if(col==n)\\n        {\\n            ans.push_back(board);\\n            return;\\n        }\\n        \\n        for(int row=0;row<n;row++)\\n        {\\n            if(left[row]==0 && upperDigonal[row+col]==0 && lowerDigonal[col-row+n-1]==0)\\n            {\\n                board[row][col] = \\'Q\\';\\n                left[row] = 1;\\n                upperDigonal[row+col] = 1;\\n                lowerDigonal[col-row+n-1] = 1;\\n                \\n                helper(col+1,n,ans,board,left,upperDigonal,lowerDigonal);\\n                \\n                board[row][col] = \\'.\\';\\n                left[row] = 0;\\n                upperDigonal[row+col] = 0;\\n                lowerDigonal[col-row+n-1] = 0;\\n            }\\n        }\\n    }\\n        \\n    int totalNQueens(int n) \\n    {\\n        vector<vector<string>> ans;                 // created the data structure for storing the complete final ans\\n        vector<string> board(n);                    // store the current queue value\\n        string s(n,\\'.\\');                            // [\\'.\\',\\'.\\',\\'.\\',\\'.\\'] (n=4)\\n        \\n        for(int i=0;i<n;i++)                        // initialize whole board as a empty string\\n        {\\n            board[i]=s;\\n        }\\n        \\n        // we are going from left to right\\n        // so we need to check only behind the current cell because all the cells after current cell will surely empty\\n        // we can not check for upper and lower direction for current cell also because each column and row has only one queen\\n        \\n        // using hashing for check the collision\\n        vector<int> left(n,0);                      // for cheking the left side we will maintaining an array that will tell which row has already taken for placing queen\\n        vector<int> upperDigonal(2*n-1,0);          // for checking the upper digonal we will maintaiing an array that will tell which upperdigonal has already taken\\n        vector<int> lowerDigonal(2*n-1,0);          // for checking the lower digonal we will maintaiing an array that will tell which lowerdigonal has already taken\\n        \\n        helper(0,n,ans,board,left,upperDigonal,lowerDigonal);  // called the function\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int col, int n, vector<vector<string>>& ans , vector<string>& board, vector<int>& left, vector<int>& upperDigonal ,vector<int>& lowerDigonal)\\n    {\\n        if(col==n)\\n        {\\n            ans.push_back(board);\\n            return;\\n        }\\n        \\n        for(int row=0;row<n;row++)\\n        {\\n            if(left[row]==0 && upperDigonal[row+col]==0 && lowerDigonal[col-row+n-1]==0)\\n            {\\n                board[row][col] = \\'Q\\';\\n                left[row] = 1;\\n                upperDigonal[row+col] = 1;\\n                lowerDigonal[col-row+n-1] = 1;\\n                \\n                helper(col+1,n,ans,board,left,upperDigonal,lowerDigonal);\\n                \\n                board[row][col] = \\'.\\';\\n                left[row] = 0;\\n                upperDigonal[row+col] = 0;\\n                lowerDigonal[col-row+n-1] = 0;\\n            }\\n        }\\n    }\\n        \\n    int totalNQueens(int n) \\n    {\\n        vector<vector<string>> ans;                 // created the data structure for storing the complete final ans\\n        vector<string> board(n);                    // store the current queue value\\n        string s(n,\\'.\\');                            // [\\'.\\',\\'.\\',\\'.\\',\\'.\\'] (n=4)\\n        \\n        for(int i=0;i<n;i++)                        // initialize whole board as a empty string\\n        {\\n            board[i]=s;\\n        }\\n        \\n        // we are going from left to right\\n        // so we need to check only behind the current cell because all the cells after current cell will surely empty\\n        // we can not check for upper and lower direction for current cell also because each column and row has only one queen\\n        \\n        // using hashing for check the collision\\n        vector<int> left(n,0);                      // for cheking the left side we will maintaining an array that will tell which row has already taken for placing queen\\n        vector<int> upperDigonal(2*n-1,0);          // for checking the upper digonal we will maintaiing an array that will tell which upperdigonal has already taken\\n        vector<int> lowerDigonal(2*n-1,0);          // for checking the lower digonal we will maintaiing an array that will tell which lowerdigonal has already taken\\n        \\n        helper(0,n,ans,board,left,upperDigonal,lowerDigonal);  // called the function\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112855,
                "title": "all-we-need-to-do-is-to-return-ans-size-c",
                "content": "\\u27A1 If you have solved N-queens problem: \\n ***All we need to do is to return ans.size() [2d string vector of N-Queens]. As there in N-Queens problem we have returned distinct solutions to the N-queens puzzle ,i.e., all possible solution string Vector.***\\n\\n1. **N-Queens** [https://leetcode.com/problems/n-queens/](http://)\\nSolution:\\n```\\nclass Solution {\\npublic:\\n    bool isSafe1(int row, int col, vector < string > board, int n) {\\n      int duprow = row;\\n      int dupcol = col;\\n\\n      while (row >= 0 && col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        row--;\\n        col--;\\n      }\\n\\n      col = dupcol;\\n      row = duprow;\\n      while (col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        col--;\\n      }\\n\\n      row = duprow;\\n      col = dupcol;\\n      while (row < n && col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        row++;\\n        col--;\\n      }\\n      return true;\\n    }\\n    void solve(int col, vector < string > & board, vector < vector < string >> & ans, int n) {\\n      if (col == n) {\\n        ans.push_back(board);\\n        return;\\n      }\\n      for (int row = 0; row < n; row++) {\\n        if (isSafe1(row, col, board, n)) {\\n          board[row][col] = \\'Q\\';\\n          solve(col + 1, board, ans, n);\\n          board[row][col] = \\'.\\';\\n        }\\n      }\\n    }\\n\\n    vector < vector < string >> solveNQueens(int n) {\\n      vector < vector < string >> ans;\\n      vector < string > board(n);\\n      string s(n, \\'.\\');\\n      for (int i = 0; i < n; i++) {\\n        board[i] = s;\\n      }\\n      solve(0, board, ans, n);\\n      return ans;\\n    }\\n};\\n    \\n```\\n\\n2. **N-Queens ||** [https://leetcode.com/problems/n-queens-ii/](http://)\\nSolution:\\n\\n```\\nclass Solution {\\npublic:\\n    bool isSafe1(int row, int col, vector < string > board, int n) {\\n      int duprow = row;\\n      int dupcol = col;\\n\\n      while (row >= 0 && col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        row--;\\n        col--;\\n      }\\n\\n      col = dupcol;\\n      row = duprow;\\n      while (col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        col--;\\n      }\\n\\n      row = duprow;\\n      col = dupcol;\\n      while (row < n && col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        row++;\\n        col--;\\n      }\\n      return true;\\n    }\\n    void solve(int col, vector < string > & board, vector < vector < string >> & ans, int n) {\\n      if (col == n) {\\n        ans.push_back(board);\\n        return;\\n      }\\n      for (int row = 0; row < n; row++) {\\n        if (isSafe1(row, col, board, n)) {\\n          board[row][col] = \\'Q\\';\\n          solve(col + 1, board, ans, n);\\n          board[row][col] = \\'.\\';\\n        }\\n      }\\n    }\\n    int totalNQueens(int n) {\\n      vector < vector < string >> ans;\\n      vector < string > board(n);\\n      string s(n, \\'.\\');\\n      for (int i = 0; i < n; i++) {\\n        board[i] = s;\\n      }\\n      solve(0, board, ans, n);\\n      return ans.size();\\n    }\\n};\\n```\\n\\n**Upvote++ if it helped** \\u270C",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSafe1(int row, int col, vector < string > board, int n) {\\n      int duprow = row;\\n      int dupcol = col;\\n\\n      while (row >= 0 && col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        row--;\\n        col--;\\n      }\\n\\n      col = dupcol;\\n      row = duprow;\\n      while (col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        col--;\\n      }\\n\\n      row = duprow;\\n      col = dupcol;\\n      while (row < n && col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        row++;\\n        col--;\\n      }\\n      return true;\\n    }\\n    void solve(int col, vector < string > & board, vector < vector < string >> & ans, int n) {\\n      if (col == n) {\\n        ans.push_back(board);\\n        return;\\n      }\\n      for (int row = 0; row < n; row++) {\\n        if (isSafe1(row, col, board, n)) {\\n          board[row][col] = \\'Q\\';\\n          solve(col + 1, board, ans, n);\\n          board[row][col] = \\'.\\';\\n        }\\n      }\\n    }\\n\\n    vector < vector < string >> solveNQueens(int n) {\\n      vector < vector < string >> ans;\\n      vector < string > board(n);\\n      string s(n, \\'.\\');\\n      for (int i = 0; i < n; i++) {\\n        board[i] = s;\\n      }\\n      solve(0, board, ans, n);\\n      return ans;\\n    }\\n};\\n    \\n```\n```\\nclass Solution {\\npublic:\\n    bool isSafe1(int row, int col, vector < string > board, int n) {\\n      int duprow = row;\\n      int dupcol = col;\\n\\n      while (row >= 0 && col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        row--;\\n        col--;\\n      }\\n\\n      col = dupcol;\\n      row = duprow;\\n      while (col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        col--;\\n      }\\n\\n      row = duprow;\\n      col = dupcol;\\n      while (row < n && col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        row++;\\n        col--;\\n      }\\n      return true;\\n    }\\n    void solve(int col, vector < string > & board, vector < vector < string >> & ans, int n) {\\n      if (col == n) {\\n        ans.push_back(board);\\n        return;\\n      }\\n      for (int row = 0; row < n; row++) {\\n        if (isSafe1(row, col, board, n)) {\\n          board[row][col] = \\'Q\\';\\n          solve(col + 1, board, ans, n);\\n          board[row][col] = \\'.\\';\\n        }\\n      }\\n    }\\n    int totalNQueens(int n) {\\n      vector < vector < string >> ans;\\n      vector < string > board(n);\\n      string s(n, \\'.\\');\\n      for (int i = 0; i < n; i++) {\\n        board[i] = s;\\n      }\\n      solve(0, board, ans, n);\\n      return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112815,
                "title": "java-100-loophole-solution-correct-solution",
                "content": "I used switch case instead of if-else, and since we already know the number of queens per case, I output that.\\n\\n```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n        switch ( n)\\n        {\\n            case 1: return 1;\\n            case 2: return 0;\\n            case 3: return 0;\\n            case 4: return 2;\\n            case 5: return 10;\\n            case 6: return 4;\\n            case 7: return 40;\\n            case 8: return 92;\\n            default: return 352;\\n        }\\n    }\\n}\\n```\\n\\n### **Talking about the correct way of solving:**\\n**What\\'s Backtracking?**\\nBacktracking can be defined as a general algorithmic technique that considers searching every possible combination in order to solve a computational problem. \\n\\nIn this problem,\\n```\\nclass Solution {\\n    public int count=0;\\n    public int totalNQueens(int n) {\\n        System.out.println(solveNQueens(n));\\n        return count;\\n    } \\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> ans = new ArrayList<List<String>>();\\n        char[][] board = new char[n][n];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                board[i][j]=\\'.\\';\\n            }\\n        }\\n        solve(0,board,ans,n);\\n        return ans;\\n    }\\n\\n    private  void solve(int col, char[][] board, List<List<String>> ans, int n) {\\n        if(col==n){\\n            // ans.add(construct(board));\\n            count++;\\n            return;\\n        }\\n        for(int row=0;row< board.length;row++){\\n            if(valid(row,col,board)){\\n                board[row][col]=\\'Q\\';\\n                solve(col+1,board,ans,n);\\n                board[row][col]=\\'.\\';\\n            }\\n        }\\n    }\\n\\n    private  boolean valid(int row, int col, char[][] board) {\\n        int duprow=row;\\n        int dupcol=col;\\n\\n        while(row>=0 && col>=0){\\n            if(board[row][col]==\\'Q\\')return false;\\n            row--;\\n            col--;\\n        }\\n\\n        row =duprow;\\n        col=dupcol;\\n        while(col>=0){\\n            if(board[row][col]==\\'Q\\')return false;\\n            col--;\\n        }\\n        row =duprow;\\n        col=dupcol;\\n        while(col>=0 && row< board.length){\\n            if(board[row][col]==\\'Q\\')return false;\\n            row++;\\n            col--;\\n        }\\n        return true;\\n    }\\n\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n        switch ( n)\\n        {\\n            case 1: return 1;\\n            case 2: return 0;\\n            case 3: return 0;\\n            case 4: return 2;\\n            case 5: return 10;\\n            case 6: return 4;\\n            case 7: return 40;\\n            case 8: return 92;\\n            default: return 352;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int count=0;\\n    public int totalNQueens(int n) {\\n        System.out.println(solveNQueens(n));\\n        return count;\\n    } \\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> ans = new ArrayList<List<String>>();\\n        char[][] board = new char[n][n];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                board[i][j]=\\'.\\';\\n            }\\n        }\\n        solve(0,board,ans,n);\\n        return ans;\\n    }\\n\\n    private  void solve(int col, char[][] board, List<List<String>> ans, int n) {\\n        if(col==n){\\n            // ans.add(construct(board));\\n            count++;\\n            return;\\n        }\\n        for(int row=0;row< board.length;row++){\\n            if(valid(row,col,board)){\\n                board[row][col]=\\'Q\\';\\n                solve(col+1,board,ans,n);\\n                board[row][col]=\\'.\\';\\n            }\\n        }\\n    }\\n\\n    private  boolean valid(int row, int col, char[][] board) {\\n        int duprow=row;\\n        int dupcol=col;\\n\\n        while(row>=0 && col>=0){\\n            if(board[row][col]==\\'Q\\')return false;\\n            row--;\\n            col--;\\n        }\\n\\n        row =duprow;\\n        col=dupcol;\\n        while(col>=0){\\n            if(board[row][col]==\\'Q\\')return false;\\n            col--;\\n        }\\n        row =duprow;\\n        col=dupcol;\\n        while(col>=0 && row< board.length){\\n            if(board[row][col]==\\'Q\\')return false;\\n            row++;\\n            col--;\\n        }\\n        return true;\\n    }\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112338,
                "title": "c-simple-solution",
                "content": "class Solution {\\npublic:\\n\\n    //create ans vector to store all possible solutions\\n    vector<vector<string>>ans;\\n    \\n    //check whether other queen is present in column or not\\n    bool issafe(int r,int c,vector<string>&v,int n){\\n        for(int i=0;i<=r;i++){\\n            //if present return false\\n            if(v[i][c]==\\'Q\\') return false;\\n        }\\n    //check whether other queen is present in diagonally upper left position or not\\n        int row=r,col=c;\\n        while(row>=0&&col>=0){\\n         \\n            if(v[row][col]==\\'Q\\') return false;\\n            row--;col--;\\n        }\\n        //check whether other queen is present in diagonally upper right position or not\\n        row=r;col=c;\\n        while(row>=0&&c<n){\\n            if(v[row][col]==\\'Q\\') return false;\\n            row--;col++;\\n        }\\n        return true;\\n        //if no the queen is present in column and diagonally upper left and diagonally upper right positions return true(or is safe)\\n    }\\n    \\n    void solve(int r,vector<string>&v,int n){\\n        if(r==n){   \\n            ans.push_back(v);\\n            return;\\n        }\\n        //now fix the row and move over the column and check for safe position\\n        for(int i=0;i<n;i++){\\n            if(issafe(r,i,v,n)){\\n                v[r][i]=\\'Q\\';\\n                solve(r+1,v,n); \\n                v[r][i]=\\'.\\';\\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n        //we required a board of size n*n to store n number of queens\\n        \\n        vector<string>v(n,string (n,\\'.\\'));\\n        // create a board with all non queen index\\n        solve(0,v,n); \\n        // to palce n number of queens on there safe position call solve() function with row 0 \\n        \\n        return ans.size();\\n    }\\n    \\n};\\n\\n//Up-Vote if you like\\n//Thankyou",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    //create ans vector to store all possible solutions\\n    vector<vector<string>>ans;\\n    \\n    //check whether other queen is present in column or not\\n    bool issafe(int r,int c,vector<string>&v,int n){\\n        for(int i=0;i<=r;i++){\\n            //if present return false\\n            if(v[i][c]==\\'Q\\') return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2111826,
                "title": "c-solution-o-1-solution-very-easy",
                "content": "May god bless you to see this O(1) solution.\\nThis is not cheating my boi. Because the constraints are very small. 1 to 9 so for only 9 solutions i first coded up the main NQueen problem and from there, i found out the possible solutions and stored them in an array. BOOM!! you got O(1) Solution.\\n\\n```\\n\\nint totalNQueens(int n){\\n    int ar[9]={1,0,0,2,10,4,40,92,352};\\n    return ar[n-1];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nint totalNQueens(int n){\\n    int ar[9]={1,0,0,2,10,4,40,92,352};\\n    return ar[n-1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111606,
                "title": "c-0ms-short-easy-to-understand",
                "content": "In this problem, we can go row by row, and in each position, we need to check if the column, the left diagonal and the right diagonal had a queen before.\\n```\\nclass Solution {\\nprivate:\\n    int N,ans;\\n    bool board[9][9]={0};\\n    bool isValid(int row,int col){\\n        for(int i=0;i<row;i++) if(board[i][col])return 0; //check the column\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) if(board[i][j])return 0; //check the left digonal\\n        for(int i=row-1,j=col+1;i>=0 && j<N;i--,j++) if(board[i][j])return 0;  //check the right digonal\\n        return 1;\\n    }\\n    void nQueen(int row){\\n        if(row==N){\\n            ans++;\\n            return;\\n        }\\n        for(int i=0;i<N;i++){\\n           if(isValid(row,i)){\\n              board[row][i]=1;\\n              nQueen(row+1);\\n              board[row][i]=0;\\n           }\\n        }\\n    }\\npublic:\\n    int totalNQueens(int n) {\\n        N=n;ans=0;\\n        nQueen(0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int N,ans;\\n    bool board[9][9]={0};\\n    bool isValid(int row,int col){\\n        for(int i=0;i<row;i++) if(board[i][col])return 0; //check the column\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) if(board[i][j])return 0; //check the left digonal\\n        for(int i=row-1,j=col+1;i>=0 && j<N;i--,j++) if(board[i][j])return 0;  //check the right digonal\\n        return 1;\\n    }\\n    void nQueen(int row){\\n        if(row==N){\\n            ans++;\\n            return;\\n        }\\n        for(int i=0;i<N;i++){\\n           if(isValid(row,i)){\\n              board[row][i]=1;\\n              nQueen(row+1);\\n              board[row][i]=0;\\n           }\\n        }\\n    }\\npublic:\\n    int totalNQueens(int n) {\\n        N=n;ans=0;\\n        nQueen(0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111575,
                "title": "c-fast-solution",
                "content": "class Solution {\\npublic:\\n    int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n\\nprivate:\\n    int ans;\\n\\n    void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2111495,
                "title": "python-back-tracking",
                "content": "This is similar to the problem of N-Queens (yesterday\\'s daily challange). This video (https://www.youtube.com/watch?v=Ph95IHmRp5M) helped me understand N-Queens problem.\\nFor this problem, instead of appending the answer to an array, just increase the answer by one for a valid position. \\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        col = set()\\n        negDiag = set() ## row - column is constant\\n        posDiag = set() ## row + column is constant\\n        \\n        board = [[\\'.\\']*n for _ in range(n)]\\n        ans = 0\\n        \\n        def backtrack(r):\\n            nonlocal ans\\n            if r == n:\\n                ans += 1\\n                return\\n            for c in range(n):\\n                if c not in col and (r+c) not in posDiag and (r-c) not in negDiag:\\n                    col.add(c)\\n                    negDiag.add(r-c)\\n                    posDiag.add(r+c)\\n                    board[r][c] = \\'Q\\'\\n                    \\n                    backtrack(r+1)\\n                    \\n                    col.remove(c)\\n                    negDiag.remove(r-c)\\n                    posDiag.remove(r+c)\\n                    board[r][c] = \\'.\\'\\n        \\n        backtrack(0)\\n        return ans\\n```\\nHappy coding! Thanks.",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        col = set()\\n        negDiag = set() ## row - column is constant\\n        posDiag = set() ## row + column is constant\\n        \\n        board = [[\\'.\\']*n for _ in range(n)]\\n        ans = 0\\n        \\n        def backtrack(r):\\n            nonlocal ans\\n            if r == n:\\n                ans += 1\\n                return\\n            for c in range(n):\\n                if c not in col and (r+c) not in posDiag and (r-c) not in negDiag:\\n                    col.add(c)\\n                    negDiag.add(r-c)\\n                    posDiag.add(r+c)\\n                    board[r][c] = \\'Q\\'\\n                    \\n                    backtrack(r+1)\\n                    \\n                    col.remove(c)\\n                    negDiag.remove(r-c)\\n                    posDiag.remove(r+c)\\n                    board[r][c] = \\'.\\'\\n        \\n        backtrack(0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111001,
                "title": "python-o-1-solution-just-kidding-this-is-cheating",
                "content": "```\\nclass Solution:\\n    \\n    def totalNQueens(self, n: int) -> int:\\n        ans = [1, 0, 0, 2, 10, 4, 40, 92, 352]\\n        return ans[n - 1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def totalNQueens(self, n: int) -> int:\\n        ans = [1, 0, 0, 2, 10, 4, 40, 92, 352]\\n        return ans[n - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946703,
                "title": "c-backtracking-self-explainable-code",
                "content": "```\\nclass Solution {\\n    bool isSafe(int row,int col,vector<string>& board){\\n        //row traversal\\n        for(int i=row;i>=0;i--){\\n            if(board[i][col]==\\'Q\\')\\n                return false;\\n        }\\n        //diagonal left\\n        for(int i=row,j=col;i>=0&&j>=0;i--,j--){\\n            if(board[i][j]==\\'Q\\')\\n                return false;\\n        }\\n        //diagonal right\\n        for(int i=row,j=col;i>=0&&j<board.size();i--,j++){\\n            if(board[i][j]==\\'Q\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n    void helper(int row,int& ans,vector<string>& board){\\n        if(row==board.size()){\\n            ans++;\\n            return;\\n        }\\n        /*\\n        put the queen \\n        call for other rows\\n        backtrack i.e remove the queen\\n        */\\n        for(int j=0;j<board.size();j++){\\n            if(isSafe(row,j,board)){\\n                board[row][j]=\\'Q\\';\\n                helper(row+1,ans,board);\\n                board[row][j]=\\'.\\';\\n            }\\n        }\\n    }\\npublic:\\n    int totalNQueens(int n) {\\n        vector<string> board(n,string(n,\\'.\\'));\\n        int ans=0;\\n        helper(0,ans,board);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    bool isSafe(int row,int col,vector<string>& board){\\n        //row traversal\\n        for(int i=row;i>=0;i--){\\n            if(board[i][col]==\\'Q\\')\\n                return false;\\n        }\\n        //diagonal left\\n        for(int i=row,j=col;i>=0&&j>=0;i--,j--){\\n            if(board[i][j]==\\'Q\\')\\n                return false;\\n        }\\n        //diagonal right\\n        for(int i=row,j=col;i>=0&&j<board.size();i--,j++){\\n            if(board[i][j]==\\'Q\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n    void helper(int row,int& ans,vector<string>& board){\\n        if(row==board.size()){\\n            ans++;\\n            return;\\n        }\\n        /*\\n        put the queen \\n        call for other rows\\n        backtrack i.e remove the queen\\n        */\\n        for(int j=0;j<board.size();j++){\\n            if(isSafe(row,j,board)){\\n                board[row][j]=\\'Q\\';\\n                helper(row+1,ans,board);\\n                board[row][j]=\\'.\\';\\n            }\\n        }\\n    }\\npublic:\\n    int totalNQueens(int n) {\\n        vector<string> board(n,string(n,\\'.\\'));\\n        int ans=0;\\n        helper(0,ans,board);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764025,
                "title": "c-backtracking-faster-than-90-percent-space-optimised",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        int chessboard[9][9];\\n        memset(chessboard, -1, sizeof(chessboard));\\n        \\n        int total = 0;\\n        int row = 0;\\n        NQueens(chessboard, n, row, total);\\n        \\n        return total;\\n    }\\n    \\n    void NQueens(int chessboard[][9], int n, int row, int &total) {\\n        if(row == n) {\\n            total++;\\n            return;\\n        }\\n        \\n        for(int col = 0; col < n; ++col) {\\n            if(IsQueenSafe(chessboard, row, col, n) == true) {\\n                chessboard[row][col] = 0;\\n                NQueens(chessboard, n, row + 1, total);\\n                chessboard[row][col] = -1;\\n            }\\n        }\\n    }\\n    \\n    bool IsQueenSafe(int chessboard[][9], int row, int col, int n) {\\n        for(int i = row - 1, j = col; i >= 0; --i) {\\n            if(chessboard[i][j] == 0)\\n                return false;\\n        }\\n        \\n        for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j) {\\n            if(chessboard[i][j] == 0)\\n                return false;\\n        }\\n        \\n        for(int i = row - 1, j = col + 1; i >= 0 && j <= (n - 1); --i, ++j) {\\n            if(chessboard[i][j] == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        int chessboard[9][9];\\n        memset(chessboard, -1, sizeof(chessboard));\\n        \\n        int total = 0;\\n        int row = 0;\\n        NQueens(chessboard, n, row, total);\\n        \\n        return total;\\n    }\\n    \\n    void NQueens(int chessboard[][9], int n, int row, int &total) {\\n        if(row == n) {\\n            total++;\\n            return;\\n        }\\n        \\n        for(int col = 0; col < n; ++col) {\\n            if(IsQueenSafe(chessboard, row, col, n) == true) {\\n                chessboard[row][col] = 0;\\n                NQueens(chessboard, n, row + 1, total);\\n                chessboard[row][col] = -1;\\n            }\\n        }\\n    }\\n    \\n    bool IsQueenSafe(int chessboard[][9], int row, int col, int n) {\\n        for(int i = row - 1, j = col; i >= 0; --i) {\\n            if(chessboard[i][j] == 0)\\n                return false;\\n        }\\n        \\n        for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j) {\\n            if(chessboard[i][j] == 0)\\n                return false;\\n        }\\n        \\n        for(int i = row - 1, j = col + 1; i >= 0 && j <= (n - 1); --i, ++j) {\\n            if(chessboard[i][j] == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732593,
                "title": "python-easy-to-understand-backtracking-solution",
                "content": "```\\n\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        visitedCol = set()\\n        posDig = set() \\n        negDig = set() \\n        res = 0 \\n        def backtrack(row):\\n            if row == n: \\n                nonlocal res \\n                res += 1 \\n                return\\n            for col in range(n): \\n                if col in visitedCol or (row+col) in posDig or(row-col) in negDig: \\n                    continue \\n                visitedCol.add(col) \\n                negDig.add(row-col) \\n                posDig.add(row+col) \\n                backtrack(row+1) \\n                visitedCol.remove(col) \\n                negDig.remove(row-col) \\n                posDig.remove(row+col) \\n        backtrack(0)    \\n \\xA0 \\xA0 \\xA0 \\xA0return res",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\n\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        visitedCol = set()\\n        posDig = set() \\n        negDig = set() \\n        res = 0 \\n        def backtrack(row):\\n            if row == n: \\n                nonlocal res \\n                res += 1 \\n                return\\n            for col in range(n): \\n                if col in visitedCol or (row+col) in posDig or(row-col) in negDig: \\n                    continue \\n                visitedCol.add(col) \\n                negDig.add(row-col) \\n                posDig.add(row+col) \\n                backtrack(row+1) \\n                visitedCol.remove(col) \\n                negDig.remove(row-col) \\n                posDig.remove(row+col) \\n        backtrack(0)    \\n \\xA0 \\xA0 \\xA0 \\xA0return res",
                "codeTag": "Java"
            },
            {
                "id": 1691037,
                "title": "fastest-c-solution-0ms-100",
                "content": "```\\nint ans=0;\\n    void solve(int n, vector<bool>& cols, vector<bool>& d1, vector<bool>& d2, int i)\\n    {\\n        if(i==n) //last row: solution found\\n        {\\n            ans++;\\n        }\\n        for(int j=0; j<n; j++)\\n        {\\n            int id1=j-i+n;\\n            int id2=i+j;\\n            if(cols[j] || d1[id1] || d2[id2]) continue; //present in column, diagonal 1, diagonal 2\\n            \\n            cols[j]=true;\\n            d1[id1]=true;\\n            d2[id2]=true;\\n            solve(n, cols, d1, d2, i+1); //solve for next row\\n            cols[j]=false;\\n            d1[id1]=false;\\n            d2[id2]=false;\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        vector<bool> cols(n, false), d1(2*n, false), d2(2*n, false);\\n        solve(n, cols, d1, d2, 0);\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nint ans=0;\\n    void solve(int n, vector<bool>& cols, vector<bool>& d1, vector<bool>& d2, int i)\\n    {\\n        if(i==n) //last row: solution found\\n        {\\n            ans++;\\n        }\\n        for(int j=0; j<n; j++)\\n        {\\n            int id1=j-i+n;\\n            int id2=i+j;\\n            if(cols[j] || d1[id1] || d2[id2]) continue; //present in column, diagonal 1, diagonal 2\\n            \\n            cols[j]=true;\\n            d1[id1]=true;\\n            d2[id2]=true;\\n            solve(n, cols, d1, d2, i+1); //solve for next row\\n            cols[j]=false;\\n            d1[id1]=false;\\n            d2[id2]=false;\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        vector<bool> cols(n, false), d1(2*n, false), d2(2*n, false);\\n        solve(n, cols, d1, d2, 0);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1606350,
                "title": "faster-than-96-7-python-solutions",
                "content": "Very similar to the N-Queens Hard problem. The key difference is that we don\\'t have to maintain the board here instead just increment the count value everytime we find a solution (row==n)\\n```class Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        \\n        cols = set()\\n        diag = set() # signifies (r+c)\\n        anti_diag = set() #signifies (r-c)\\n        board = [[\\'.\\' for i in range(n)] for j in range(n)]\\n        self.count=0\\n    \\n        def backtrack(row):\\n            if row==n:\\n                self.count+=1\\n                return \\n            \\n            for col in range(n):\\n                if col in cols or (row+col) in diag or (row-col) in anti_diag:\\n                    continue\\n                #the queen can now be placed at this (row,col)\\n                \\n                cols.add(col)\\n                diag.add(row+col)\\n                anti_diag.add(row-col)\\n                \\n                #call backtrack function for next row\\n                backtrack(row+1)\\n                \\n                #remove the queen from this position (we backtrack from here because in the iteration part of the recursion we realized that this position is not going to return us the final answer)\\n                \\n                cols.remove(col)\\n                diag.remove(row+col)\\n                anti_diag.remove(row-col)\\n        backtrack(0)\\n        return self.count\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "Very similar to the N-Queens Hard problem. The key difference is that we don\\'t have to maintain the board here instead just increment the count value everytime we find a solution (row==n)\\n```class Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        \\n        cols = set()\\n        diag = set() # signifies (r+c)\\n        anti_diag = set() #signifies (r-c)\\n        board = [[\\'.\\' for i in range(n)] for j in range(n)]\\n        self.count=0\\n    \\n        def backtrack(row):\\n            if row==n:\\n                self.count+=1\\n                return \\n            \\n            for col in range(n):\\n                if col in cols or (row+col) in diag or (row-col) in anti_diag:\\n                    continue\\n                #the queen can now be placed at this (row,col)\\n                \\n                cols.add(col)\\n                diag.add(row+col)\\n                anti_diag.add(row-col)\\n                \\n                #call backtrack function for next row\\n                backtrack(row+1)\\n                \\n                #remove the queen from this position (we backtrack from here because in the iteration part of the recursion we realized that this position is not going to return us the final answer)\\n                \\n                cols.remove(col)\\n                diag.remove(row+col)\\n                anti_diag.remove(row-col)\\n        backtrack(0)\\n        return self.count\\n",
                "codeTag": "Java"
            },
            {
                "id": 1568714,
                "title": "n-queens-ii-using-backtracking-algorithm",
                "content": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\nint bt=0;\\nvector<vector<int> > result;\\n\\nbool isSafe(vector<vector<int> > board,int row, int col)\\n{\\n\\tint i, j;\\n\\tint N = board.size();\\n\\tfor (i = 0; i < col; i++)\\n\\t\\tif (board[row][i])\\n\\t\\t\\treturn false;\\n\\tfor (i = row, j = col; i >= 0 && j >= 0; i--, j--)\\n\\t\\tif (board[i][j])\\n\\t\\t\\treturn false;\\n\\n\\tfor (i = row, j = col; j >= 0 && i < N; i++, j--)\\n\\t\\tif (board[i][j])\\n\\t\\t\\treturn false;\\n\\n\\treturn true;\\n}\\nbool solveNQUtil(vector<vector<int> >& board, int col)\\n{\\n\\tint N = board.size();\\n\\tif (col == N) {\\n\\t\\tvector<int> v;\\n\\t\\tfor (int i = 0; i < N; i++) {\\n\\t\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\t\\tif (board[i][j] == 1)\\n\\t\\t\\t\\t\\tv.push_back(j + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult.push_back(v);\\n\\t\\treturn true;\\n\\t}\\n\\tbool res = false;\\n\\tfor (int i = 0; i < N; i++) {\\n\\t\\tif (isSafe(board, i, col)) {\\n\\t\\t\\tboard[i][col] = 1;\\n\\t\\t\\tres = solveNQUtil(board, col + 1) || res;\\n\\n\\t\\t\\tboard[i][col] = 0;\\n\\t\\t    bt++;\\n\\t\\t    \\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n\\nvector<vector<int> > nQueen(int n)\\n{\\n\\tresult.clear();\\n\\tvector<vector<int> > board(n, vector<int>(n, 0));\\n\\n\\tif (solveNQUtil(board, 0) == false) {\\n\\t    cout << \"\\\\n\\\\nSolution for n = \" << n << \" does not exist\";\\n\\t\\treturn {};\\n\\t}\\n\\n\\tsort(result.begin(), result.end());\\n\\treturn result;\\n}\\n\\nint main()\\n{\\n\\tint n;\\n\\tcout << \"Enter the value of n = \";\\n\\tcin >> n;\\n\\t{\\n\\t int count=0;   \\n\\t vector<vector<int> > v = nQueen(n);\\n     cout << \"\\\\n\\\\nPossible solutions for n = \" << n;   \\n\\t for (auto ar : v) {\\n\\t\\tcout << \"\\\\n[\";\\n\\t\\tfor (auto it : ar)\\n\\t\\t\\tcout << it << \" \";\\n\\t\\tcout << \"]\";\\n\\t\\tcount++;\\n\\t}\\n\\tcout << \"\\\\n\\\\nThus total possible solutions of N Queen problem for N = \" << n << \" are \" << count;\\n\\tcout << \"\\\\n\\\\nTotal no. of backtracks = \" << bt;\\n\\t}\\n\\n\\treturn 0;\\n}\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\nint bt=0;\\nvector<vector<int> > result;\\n\\nbool isSafe(vector<vector<int> > board,int row, int col)\\n{\\n\\tint i, j;\\n\\tint N = board.size();\\n\\tfor (i = 0; i < col; i++)\\n\\t\\tif (board[row][i])\\n\\t\\t\\treturn false;\\n\\tfor (i = row, j = col; i >= 0 && j >= 0; i--, j--)\\n\\t\\tif (board[i][j])\\n\\t\\t\\treturn false;\\n\\n\\tfor (i = row, j = col; j >= 0 && i < N; i++, j--)\\n\\t\\tif (board[i][j])\\n\\t\\t\\treturn false;\\n\\n\\treturn true;\\n}\\nbool solveNQUtil(vector<vector<int> >& board, int col)\\n{\\n\\tint N = board.size();\\n\\tif (col == N) {\\n\\t\\tvector<int> v;\\n\\t\\tfor (int i = 0; i < N; i++) {\\n\\t\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\t\\tif (board[i][j] == 1)\\n\\t\\t\\t\\t\\tv.push_back(j + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult.push_back(v);\\n\\t\\treturn true;\\n\\t}\\n\\tbool res = false;\\n\\tfor (int i = 0; i < N; i++) {\\n\\t\\tif (isSafe(board, i, col)) {\\n\\t\\t\\tboard[i][col] = 1;\\n\\t\\t\\tres = solveNQUtil(board, col + 1) || res;\\n\\n\\t\\t\\tboard[i][col] = 0;\\n\\t\\t    bt++;\\n\\t\\t    \\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n\\nvector<vector<int> > nQueen(int n)\\n{\\n\\tresult.clear();\\n\\tvector<vector<int> > board(n, vector<int>(n, 0));\\n\\n\\tif (solveNQUtil(board, 0) == false) {\\n\\t    cout << \"\\\\n\\\\nSolution for n = \" << n << \" does not exist\";\\n\\t\\treturn {};\\n\\t}\\n\\n\\tsort(result.begin(), result.end());\\n\\treturn result;\\n}\\n\\nint main()\\n{\\n\\tint n;\\n\\tcout << \"Enter the value of n = \";\\n\\tcin >> n;\\n\\t{\\n\\t int count=0;   \\n\\t vector<vector<int> > v = nQueen(n);\\n     cout << \"\\\\n\\\\nPossible solutions for n = \" << n;   \\n\\t for (auto ar : v) {\\n\\t\\tcout << \"\\\\n[\";\\n\\t\\tfor (auto it : ar)\\n\\t\\t\\tcout << it << \" \";\\n\\t\\tcout << \"]\";\\n\\t\\tcount++;\\n\\t}\\n\\tcout << \"\\\\n\\\\nThus total possible solutions of N Queen problem for N = \" << n << \" are \" << count;\\n\\tcout << \"\\\\n\\\\nTotal no. of backtracks = \" << bt;\\n\\t}\\n\\n\\treturn 0;\\n}\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1555851,
                "title": "python-recursive-solution-24-28ms-98",
                "content": "This was just a simplification of my solution for the preceding problem, [N-Queens](https://leetcode.com/problems/n-queens/discuss/1555836/Python-recursive-solution-28-32ms-(less~99)), so I found it interesting that the problems are presented in this order.\\n\\nIt led me to realize, however, that I don\\'t need to track the locations of queens (2D array) to generate the solutions for N-Queens (though it\\'s faster). The location of the queens can be inferred from the state of the three arrays (e.g. are the current square\\'s column and two diagonals all non-vacant?).\\n\\n```\\nclass Solution(object):\\n  def recurse(self, n, row, cols, diagsA, diagsB):\\n    if row == n:\\n      return 1\\n    r = 0\\n    for col in range(0, n):\\n      if cols[col] or diagsA[col + row] or diagsB[col - row]:\\n        continue\\n      cols[col] = diagsA[col + row] = diagsB[col - row] = True\\n      r += self.recurse(n, row + 1, cols, diagsA, diagsB)\\n      cols[col] = diagsA[col + row] = diagsB[col - row] = False\\n    return r\\n\\n\\n  def totalNQueens(self, n):\\n    cols = [0] * n\\n    diagsA = [0] * (n * 2 - 1)\\n    diagsB = [0] * (n * 2 - 1)\\n    return self.recurse(n, 0, cols, diagsA, diagsB)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n  def recurse(self, n, row, cols, diagsA, diagsB):\\n    if row == n:\\n      return 1\\n    r = 0\\n    for col in range(0, n):\\n      if cols[col] or diagsA[col + row] or diagsB[col - row]:\\n        continue\\n      cols[col] = diagsA[col + row] = diagsB[col - row] = True\\n      r += self.recurse(n, row + 1, cols, diagsA, diagsB)\\n      cols[col] = diagsA[col + row] = diagsB[col - row] = False\\n    return r\\n\\n\\n  def totalNQueens(self, n):\\n    cols = [0] * n\\n    diagsA = [0] * (n * 2 - 1)\\n    diagsB = [0] * (n * 2 - 1)\\n    return self.recurse(n, 0, cols, diagsA, diagsB)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524746,
                "title": "java-tc-o-n-2-sc-o-1-faster-than-100",
                "content": "**Do vote up if you like it :)**\\n\\nTime Complexity: O(N^2)\\nSpace Complexity: O(1)\\n\\n```\\nclass Solution {\\n        \\n    public int totalNQueens(int n) {\\n        boolean[] row = new boolean[n];\\n        boolean[] col = new boolean[n];\\n        boolean[] diagonal = new boolean[n + n - 1];\\n        boolean[] antiDiagonal = new boolean[n + n - 1];\\n        \\n        return totalNQueens(n, 0, row, col, diagonal, antiDiagonal);\\n    }\\n    \\n    public static int totalNQueens(int n, int r, boolean[] row, boolean[] col, boolean[] diagonal, boolean[] antiDiagonal) {\\n        if(r == n) return 1;\\n        \\n        int count = 0;\\n        for(int c = 0; c < n; c++) {\\n            if(!row[r] && !col[c] && !diagonal[r + c] && !antiDiagonal[r - c + n - 1]) {\\n                row[r] = col[c] = diagonal[r + c] = antiDiagonal[r - c + n - 1] = true;\\n                count += totalNQueens(n, r + 1, row, col, diagonal, antiDiagonal);\\n                row[r] = col[c] = diagonal[r + c] = antiDiagonal[r - c + n - 1] = false;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        \\n    public int totalNQueens(int n) {\\n        boolean[] row = new boolean[n];\\n        boolean[] col = new boolean[n];\\n        boolean[] diagonal = new boolean[n + n - 1];\\n        boolean[] antiDiagonal = new boolean[n + n - 1];\\n        \\n        return totalNQueens(n, 0, row, col, diagonal, antiDiagonal);\\n    }\\n    \\n    public static int totalNQueens(int n, int r, boolean[] row, boolean[] col, boolean[] diagonal, boolean[] antiDiagonal) {\\n        if(r == n) return 1;\\n        \\n        int count = 0;\\n        for(int c = 0; c < n; c++) {\\n            if(!row[r] && !col[c] && !diagonal[r + c] && !antiDiagonal[r - c + n - 1]) {\\n                row[r] = col[c] = diagonal[r + c] = antiDiagonal[r - c + n - 1] = true;\\n                count += totalNQueens(n, r + 1, row, col, diagonal, antiDiagonal);\\n                row[r] = col[c] = diagonal[r + c] = antiDiagonal[r - c + n - 1] = false;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383450,
                "title": "c-hint",
                "content": "You gotta do just a small lil\\' change in the NQueens util function.\\n```\\nint NQueensSolve(int column, vector<vector<int>> &mat, int n){\\n        if (column==n)\\n            return 1;\\n        int counter = 0;\\n        for (int row=0;row<n;row++)\\n            if (isSafe(row, column, mat, n)){\\n                mat[row][column] = 1;\\n                counter += NQueensSolve(column+1, mat, n);\\n                mat[row][column] = 0;\\n            }\\n        return counter;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint NQueensSolve(int column, vector<vector<int>> &mat, int n){\\n        if (column==n)\\n            return 1;\\n        int counter = 0;\\n        for (int row=0;row<n;row++)\\n            if (isSafe(row, column, mat, n)){\\n                mat[row][column] = 1;\\n                counter += NQueensSolve(column+1, mat, n);\\n                mat[row][column] = 0;\\n            }\\n        return counter;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1343553,
                "title": "java-recursion-backtracking-1ms-faster-than-85",
                "content": "```\\nclass Solution {\\n    int count;\\n    public int totalNQueens(int n) {\\n        boolean[][] queen = new boolean[n][n];\\n        count = 0;\\n        helper(0, n, queen);\\n        return count;\\n    }\\n    public void helper(int l, int n, boolean[][] queen){\\n        if(l == n){\\n            count++;\\n            return;\\n        }\\n        \\n        for(int i = 0; i < queen.length; i++){\\n            if(isSafe(l, i, queen)){\\n                queen[l][i] = true;\\n                helper(l + 1, n, queen);\\n                queen[l][i] = false;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int i, int j, boolean[][] queen){\\n        int r = i - 1, c = j;\\n        while(r >= 0)\\n            if(queen[r--][c])\\n                return false;\\n        r = i - 1;\\n        c = j - 1;\\n        while(r >= 0 && c >= 0)\\n            if(queen[r--][c--])\\n                return false;\\n        r = i - 1;\\n        c = j + 1;\\n        while(r >= 0 && c < queen.length) \\n            if(queen[r--][c++])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int count;\\n    public int totalNQueens(int n) {\\n        boolean[][] queen = new boolean[n][n];\\n        count = 0;\\n        helper(0, n, queen);\\n        return count;\\n    }\\n    public void helper(int l, int n, boolean[][] queen){\\n        if(l == n){\\n            count++;\\n            return;\\n        }\\n        \\n        for(int i = 0; i < queen.length; i++){\\n            if(isSafe(l, i, queen)){\\n                queen[l][i] = true;\\n                helper(l + 1, n, queen);\\n                queen[l][i] = false;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int i, int j, boolean[][] queen){\\n        int r = i - 1, c = j;\\n        while(r >= 0)\\n            if(queen[r--][c])\\n                return false;\\n        r = i - 1;\\n        c = j - 1;\\n        while(r >= 0 && c >= 0)\\n            if(queen[r--][c--])\\n                return false;\\n        r = i - 1;\\n        c = j + 1;\\n        while(r >= 0 && c < queen.length) \\n            if(queen[r--][c++])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304705,
                "title": "java-branch-and-bound-100-time",
                "content": "Here we will bound the attacking spots by the queen which is being placed currently. And will do work for only those spots which are not attacked by any queen. I am iterating on rows in recursion so i will make arrays of Column, Diagonal1, Diagonal2. \\n\\nMark the cloumn array and the diagonal array accordingly (which falls under attacking spots).\\n\\n```\\nclass Solution {\\n    \\n    public static int solve(boolean[] colArr, boolean[] d1, boolean[] d2, int i) {\\n        \\n        if(i == colArr.length) {            \\n            return 1;\\n        }\\n        int sum = 0;\\n        for(int col = 0; col < colArr.length; col++) {\\n            if(!colArr[col] && !d1[i + col] && !d2[i - col + colArr.length - 1]) {\\n                colArr[col] = true;\\n                d1[i + col] = true;\\n                d2[i - col + colArr.length - 1] = true;\\n                sum += solve( colArr, d1, d2, i + 1);\\n                colArr[col] = false;\\n                d1[i + col] = false;\\n                d2[i - col + colArr.length - 1] = false;\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n    \\n    public int totalNQueens(int n) {\\n        return solve(new boolean[n], new boolean[2*n - 1], new boolean[2*n - 1], 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public static int solve(boolean[] colArr, boolean[] d1, boolean[] d2, int i) {\\n        \\n        if(i == colArr.length) {            \\n            return 1;\\n        }\\n        int sum = 0;\\n        for(int col = 0; col < colArr.length; col++) {\\n            if(!colArr[col] && !d1[i + col] && !d2[i - col + colArr.length - 1]) {\\n                colArr[col] = true;\\n                d1[i + col] = true;\\n                d2[i - col + colArr.length - 1] = true;\\n                sum += solve( colArr, d1, d2, i + 1);\\n                colArr[col] = false;\\n                d1[i + col] = false;\\n                d2[i - col + colArr.length - 1] = false;\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n    \\n    public int totalNQueens(int n) {\\n        return solve(new boolean[n], new boolean[2*n - 1], new boolean[2*n - 1], 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240241,
                "title": "cpp-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int count=0;\\n    bool isSafe(vector<vector<int> >v1,int col,int row)\\n{\\n    int n=v1.size();\\n \\n    for(int i=0;i<row;i++){\\n       if(v1[i][col]==1)\\n           return false;\\n     }\\n   \\n     for(int i=row-1,j=col-1;i>=0&&j>=0;i--,j--)\\n       if(v1[i][j])\\n       return false;\\n \\n    for(int i=row-1,j=col+1;j<n&&i>=0;i--,j++)\\n     if(v1[i][j])\\n     return false;\\n     \\nreturn true;\\n}\\nvoid NQueen(vector<vector<int> >&v1,int row)\\n{\\n   \\n    if(row==v1.size()){\\n        count++;\\n      return;}\\n      for(int i=0;i<v1.size();i++)\\n      {\\n          if(isSafe(v1,i,row))\\n          {\\n              v1[row][i]=1;\\n              NQueen(v1,row+1);\\n            v1[row][i]=0;\\n          }\\n      }\\n      return ;\\n}\\n\\n    int totalNQueens(int n) {\\n        vector<vector<int> >v1;\\n    \\n    for(int i=0;i<n;i++){\\n        vector<int>v2(n,0);\\n    v1.push_back(v2);}\\n    \\n    NQueen(v1,0);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count=0;\\n    bool isSafe(vector<vector<int> >v1,int col,int row)\\n{\\n    int n=v1.size();\\n \\n    for(int i=0;i<row;i++){\\n       if(v1[i][col]==1)\\n           return false;\\n     }\\n   \\n     for(int i=row-1,j=col-1;i>=0&&j>=0;i--,j--)\\n       if(v1[i][j])\\n       return false;\\n \\n    for(int i=row-1,j=col+1;j<n&&i>=0;i--,j++)\\n     if(v1[i][j])\\n     return false;\\n     \\nreturn true;\\n}\\nvoid NQueen(vector<vector<int> >&v1,int row)\\n{\\n   \\n    if(row==v1.size()){\\n        count++;\\n      return;}\\n      for(int i=0;i<v1.size();i++)\\n      {\\n          if(isSafe(v1,i,row))\\n          {\\n              v1[row][i]=1;\\n              NQueen(v1,row+1);\\n            v1[row][i]=0;\\n          }\\n      }\\n      return ;\\n}\\n\\n    int totalNQueens(int n) {\\n        vector<vector<int> >v1;\\n    \\n    for(int i=0;i<n;i++){\\n        vector<int>v2(n,0);\\n    v1.push_back(v2);}\\n    \\n    NQueen(v1,0);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239159,
                "title": "c-backtracking-easy-to-understand-no-need-to-form-chess-board",
                "content": "```\\n/*\\n    A simple approach will be the same as N Queens problem. Instead of returning all the configurations of board (vector<vector<string>>),\\n    here we return the count of total configurations. Link : https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Backtracking/N-Queens.cpp\\n    \\n    But, you don\\'t need to form boards and configurations to count the total configurations. See the solution below.\\n*/\\nclass Solution {\\npublic:\\n    int count = 0;\\n    unordered_set<int> cols;\\n    unordered_set<int> diags;\\n    unordered_set<int> antiDiags;\\n    void dfs(int row, int n) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        \\n        for(int col = 0; col<n; col++) {\\n            int d  = row-col;\\n            int ad = row+col;\\n            \\n            if(cols.count(col) || diags.count(d) || antiDiags.count(ad))\\n                continue;\\n            \\n            cols.insert(col);\\n            diags.insert(d);\\n            antiDiags.insert(ad);\\n            \\n            dfs(row+1, n);\\n            \\n            cols.erase(col);\\n            diags.erase(d);\\n            antiDiags.erase(ad);\\n            \\n        }\\n    }\\n    vector<vector<string>> result;\\n    int totalNQueens(int n) {\\n        count = 0;\\n        if(n == 1)\\n            return 1;\\n        if(n <= 3)\\n            return count;\\n        \\n        dfs(0, n);\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    A simple approach will be the same as N Queens problem. Instead of returning all the configurations of board (vector<vector<string>>),\\n    here we return the count of total configurations. Link : https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Backtracking/N-Queens.cpp\\n    \\n    But, you don\\'t need to form boards and configurations to count the total configurations. See the solution below.\\n*/\\nclass Solution {\\npublic:\\n    int count = 0;\\n    unordered_set<int> cols;\\n    unordered_set<int> diags;\\n    unordered_set<int> antiDiags;\\n    void dfs(int row, int n) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        \\n        for(int col = 0; col<n; col++) {\\n            int d  = row-col;\\n            int ad = row+col;\\n            \\n            if(cols.count(col) || diags.count(d) || antiDiags.count(ad))\\n                continue;\\n            \\n            cols.insert(col);\\n            diags.insert(d);\\n            antiDiags.insert(ad);\\n            \\n            dfs(row+1, n);\\n            \\n            cols.erase(col);\\n            diags.erase(d);\\n            antiDiags.erase(ad);\\n            \\n        }\\n    }\\n    vector<vector<string>> result;\\n    int totalNQueens(int n) {\\n        count = 0;\\n        if(n == 1)\\n            return 1;\\n        if(n <= 3)\\n            return count;\\n        \\n        dfs(0, n);\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238410,
                "title": "c-easily-understandable-solution-derived-from-n-queens-hinglish-comments",
                "content": "class Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<string>> vec;\\n        vector<string> board(n,string(n,\\'.\\'));\\n        recurse(vec,board,0,n);\\n        return vec.size();\\n    }\\n    \\n      void recurse( vector<vector<string>> &vec ,vector<string> &board , int row , int &n)\\n    {\\n        \\n        if(row == n)\\n        {\\n            vec.push_back(board);\\n            return;\\n        }\\n        \\n        //ek particular row to already selected h and now for each cell we have to traverse through column \\n        \\n        \\n        for(int col = 0 ; col < n ; col++)\\n        {\\n             if(isValid(board,row,col,n))\\n            {\\n                 board[row][col] = \\'Q\\';\\n                 /*ek baar uss place pe Q ko rakh ke aage proceed kiya agar ispe se koi answer derive ho paega to vo apne aap end me base condition ki vajah se answer(vec) me pushback ho jaega ab backtrack karne ke baad iss postion se queen ko hatana bhi to padega taaki multiple configurations try kar sake   */\\n                 recurse(vec,board,row+1,n); // Recursing row by row\\n                 board[row][col] = \\'.\\';// yahan pe q ko hataya h \\n            }\\n        }    \\n    }\\n    \\n    \\n    bool isValid(vector<string> &board ,int &row , int &col , int &n  )\\n    {\\n        \\n        for(int i=0;i<row;++i) // If column has queen already\\n        {\\n            if(board[i][col] == \\'Q\\')\\n                return false;\\n        } \\n        \\n        // If left diagonals have queen already \\n        for(int i=1;row-i>=0&&col-i>=0;++i)\\n        {\\n            if(board[row-i][col-i] == \\'Q\\')\\n                return false;\\n        }\\n        \\n        // If right diagonal have queen already\\n        for(int i=1;row-i>=0&&col+i<n;++i)\\n        {\\n            if(board[row-i][col+i] == \\'Q\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<string>> vec;\\n        vector<string> board(n,string(n,\\'.\\'));\\n        recurse(vec,board,0,n);\\n        return vec.size();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1237841,
                "title": "python-short-recursion-easy-crisp",
                "content": "# N-Queens II\\n\\n**Complexity**\\n* Time Complexity -> `O(n!)` *(Since we have to check all possible permutations)*\\n* Space Complexity -> `O(n)` *(only set size of diagonals and columns)*\\n\\n\\n**[Note]**  *tot += soln(row+1, diag1|set([col-row]), diag2|set([col+row]), cols|set([col]))*\\n\\nIn the above line I have incremented **row** by 1 and used **set\\'s union method(Operator |)**  to include diagonals and columns . For eg let\\'s take n=2, *[[00, 01], [10, 11]]*, then for diagonal 1 (col-row) -> *[[0, 1], [-1, 0]]* so it gives **diag1** set `{0, 1, -1}` and for diagonal 2 (col+row) -> *[[0, 1], [1, 2]]* it gives **diag2** `set {0, 1, 2}` , and for columns **cols** `set {0, 1}`\\n\\n\\n*Please upvote if you like the solution and comment if have any queries* .\\n\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        \\n        def soln(row, diag1, diag2, cols):\\n            #if passing all the rows and columns of the grid then return 1 i.e. possible answer\\n            if row==n:\\n                return 1\\n            \\n            tot = 0\\n            for col in range(n):\\n                #checking for the grid of queen not in same diagonals and same columns \\n                if ((col-row) in diag1) or ((col+row) in diag2) or (col in cols):\\n                    continue\\n                 \\n                #if passed above condition then including this grid in diagonals and columns for next row\\n                tot += soln(row+1, diag1|set([col-row]), diag2|set([col+row]), cols|set([col]))\\n            \\n            #Finally returning total no. of soluntions\\n            return tot\\n         \\n        #taking starting from row 0 sets of diagonal1 , diagonal2, columns\\n        return soln(0, set(), set(), set())\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        \\n        def soln(row, diag1, diag2, cols):\\n            #if passing all the rows and columns of the grid then return 1 i.e. possible answer\\n            if row==n:\\n                return 1\\n            \\n            tot = 0\\n            for col in range(n):\\n                #checking for the grid of queen not in same diagonals and same columns \\n                if ((col-row) in diag1) or ((col+row) in diag2) or (col in cols):\\n                    continue\\n                 \\n                #if passed above condition then including this grid in diagonals and columns for next row\\n                tot += soln(row+1, diag1|set([col-row]), diag2|set([col+row]), cols|set([col]))\\n            \\n            #Finally returning total no. of soluntions\\n            return tot\\n         \\n        #taking starting from row 0 sets of diagonal1 , diagonal2, columns\\n        return soln(0, set(), set(), set())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237750,
                "title": "n-queens-ii-c",
                "content": "The code written here is similar to the code, I gave before to the 1st part of it.\\nOnly the difference is here we want to count the number, so whenever we find a possible arrangement of queens we do ``ans++`` and finally return ans\\nMy previous post to the 1st part : https://leetcode.com/discuss/explore/may-leetcoding-challenge-2021/1223128/n-queens-c-backtracking\\n\\n**CODE:**\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    bool isSafe(int &row, int &col, vector<vector<string>> &board, int &n)\\n    {\\n        // same row\\n        for(int j=0;j<n;j++)\\n            if(board[row][j]==\"Q\")\\n                return false;\\n\\t\\t\\t\\t\\n        // we do not need to check column clashes as we place queens in different columns only\\n\\t\\t\\n        // diagonals\\n        // since we are placing queens from left column to right column we need to check upper left and lower left diagonals only\\n        \\n        for(int i=row,j=col;i>=0 and j>=0; i--,j--)\\n            if(board[i][j]==\"Q\")\\n                return false;\\n        \\n        for(int i=row,j=col;i<n and j>=0; i++,j--)\\n            if(board[i][j]==\"Q\")\\n                return false;\\n        \\n        return true;\\n    }\\n    void solve(int col, vector<vector<string>> &board, int &n)\\n    {\\n        if(col==n)\\n        {\\n            ans++;   \\n            return;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(isSafe(i,col,board,n))\\n            {\\n                board[i][col]=\"Q\";\\n                solve(col+1, board, n);\\n                board[i][col]=\".\";\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        // we will place every queen in different columns so that one of the possible clashes (vertically) do not occurs\\n        vector<vector<string>> board(n, vector<string> (n,\".\"));\\n        solve(0,board,n);\\n        return ans;\\n    }\\n};\\n```\\nDO **UPVOTE** IF YOU LIKED IT !!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    bool isSafe(int &row, int &col, vector<vector<string>> &board, int &n)\\n    {\\n        // same row\\n        for(int j=0;j<n;j++)\\n            if(board[row][j]==\"Q\")\\n                return false;\\n\\t\\t\\t\\t\\n        // we do not need to check column clashes as we place queens in different columns only\\n\\t\\t\\n        // diagonals\\n        // since we are placing queens from left column to right column we need to check upper left and lower left diagonals only\\n        \\n        for(int i=row,j=col;i>=0 and j>=0; i--,j--)\\n            if(board[i][j]==\"Q\")\\n                return false;\\n        \\n        for(int i=row,j=col;i<n and j>=0; i++,j--)\\n            if(board[i][j]==\"Q\")\\n                return false;\\n        \\n        return true;\\n    }\\n    void solve(int col, vector<vector<string>> &board, int &n)\\n    {\\n        if(col==n)\\n        {\\n            ans++;   \\n            return;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(isSafe(i,col,board,n))\\n            {\\n                board[i][col]=\"Q\";\\n                solve(col+1, board, n);\\n                board[i][col]=\".\";\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        // we will place every queen in different columns so that one of the possible clashes (vertically) do not occurs\\n        vector<vector<string>> board(n, vector<string> (n,\".\"));\\n        solve(0,board,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224223,
                "title": "easy-to-understand-n-queens2-soln",
                "content": "```\\nclass Solution {\\n    \\n      char[][] board;\\n    List<List<String>> res;\\n    public int totalNQueens(int n) {\\n        solveNQueens(n);\\n      return res.size(); \\n    }\\n   List<List<String>> solveNQueens(int n) {\\n         board = new char[n][n];\\n         res = new ArrayList<List<String>>();\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++)\\n                board[i][j] = \\'.\\';\\n        \\n        solveRec(0);\\n        return res;\\n    }\\n    List<String> construct() {\\n        List<String> res = new LinkedList<String>();\\n        for(int i = 0; i < board.length; i++) {\\n            String s = new String(board[i]);\\n            res.add(s);\\n        }\\n        return res;\\n    }\\n\\tvoid solveRec(int col) {\\n\\t\\tint N = board.length;\\n\\t\\tif(col==N) {\\n          res.add(construct());\\n            return;\\n        }\\n\\t\\tfor(int i=0;i<N;i++) {\\n\\t\\t\\tif(isSafe(i,col)) {\\n\\t\\t\\t\\tboard[i][col]=\\'Q\\';\\n\\t\\t\\t\\tsolveRec(col+1);\\n\\t\\t\\t\\tboard[i][col]=\\'.\\';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tboolean isSafe(int row,int col) {\\n\\t\\tfor(int i=0;i<col;i++) {\\n\\t\\t\\tif(board[row][i]==\\'Q\\') return false;\\n\\t\\t}\\n\\t\\tfor(int i=row,j=col;i>=0 && j>=0;i--,j--) {\\n\\t\\t\\tif(board[i][j]==\\'Q\\') return false;\\n\\t\\t}\\n\\t\\tfor(int i=row,j=col;i< board.length&& j>=0;i++,j--) {\\n\\t\\t\\tif(board[i][j]==\\'Q\\') return false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n      char[][] board;\\n    List<List<String>> res;\\n    public int totalNQueens(int n) {\\n        solveNQueens(n);\\n      return res.size(); \\n    }\\n   List<List<String>> solveNQueens(int n) {\\n         board = new char[n][n];\\n         res = new ArrayList<List<String>>();\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++)\\n                board[i][j] = \\'.\\';\\n        \\n        solveRec(0);\\n        return res;\\n    }\\n    List<String> construct() {\\n        List<String> res = new LinkedList<String>();\\n        for(int i = 0; i < board.length; i++) {\\n            String s = new String(board[i]);\\n            res.add(s);\\n        }\\n        return res;\\n    }\\n\\tvoid solveRec(int col) {\\n\\t\\tint N = board.length;\\n\\t\\tif(col==N) {\\n          res.add(construct());\\n            return;\\n        }\\n\\t\\tfor(int i=0;i<N;i++) {\\n\\t\\t\\tif(isSafe(i,col)) {\\n\\t\\t\\t\\tboard[i][col]=\\'Q\\';\\n\\t\\t\\t\\tsolveRec(col+1);\\n\\t\\t\\t\\tboard[i][col]=\\'.\\';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tboolean isSafe(int row,int col) {\\n\\t\\tfor(int i=0;i<col;i++) {\\n\\t\\t\\tif(board[row][i]==\\'Q\\') return false;\\n\\t\\t}\\n\\t\\tfor(int i=row,j=col;i>=0 && j>=0;i--,j--) {\\n\\t\\t\\tif(board[i][j]==\\'Q\\') return false;\\n\\t\\t}\\n\\t\\tfor(int i=row,j=col;i< board.length&& j>=0;i++,j--) {\\n\\t\\t\\tif(board[i][j]==\\'Q\\') return false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223291,
                "title": "plain-backtracking-simple-c-code",
                "content": "Same as N-queen solution : \\nhttps://leetcode.com/problems/n-queens/discuss/1223282/Plain-Backtracking-Simple-C%2B%2B-code-with-comments\\n```\\nclass Solution {\\n    bool isRowFree(vector<string> &board, int row){\\n        int n = board.size();\\n        for(int col = 0; col < n; col++)\\n            if(board[row][col] == \\'Q\\') return false;\\n        return true;\\n    }\\n    bool isDiagonalFree(vector<string> &board, int row, int col){\\n        int n = board.size();\\n        int i = row, j = col;\\n        \\n        //Only need to check left side diagonals\\n        while(i >= 0 && j >= 0){\\n            if(board[i][j] == \\'Q\\') return false;\\n            i--, j--;\\n        }\\n        i = row, j = col;\\n        while(i < n && j >= 0){\\n            if(board[i][j] == \\'Q\\') return false;\\n            i++, j--;\\n        }\\n        return true;\\n    }\\npublic:\\n    void solve(vector<string> &board, int curr_col,int &ans){\\n        int n = board.size();\\n        \\n        if(curr_col == n){\\n            ans++;\\n            return;\\n        } \\n        \\n        //Check for valid row for curr_col where queen can be placed\\n        for(int curr_row = 0; curr_row < n; curr_row++){\\n            if(isRowFree(board, curr_row)  &&                \\n               isDiagonalFree(board, curr_row, curr_col))\\n            {\\n                board[curr_row][curr_col] = \\'Q\\';\\n                solve(board,curr_col+1,ans);\\n                board[curr_row][curr_col] = \\'.\\';   //backtrack step\\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n        vector<string> board (n ,string(n,\\'.\\'));\\n        int ans=0;\\n        \\n        solve(board, 0, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    bool isRowFree(vector<string> &board, int row){\\n        int n = board.size();\\n        for(int col = 0; col < n; col++)\\n            if(board[row][col] == \\'Q\\') return false;\\n        return true;\\n    }\\n    bool isDiagonalFree(vector<string> &board, int row, int col){\\n        int n = board.size();\\n        int i = row, j = col;\\n        \\n        //Only need to check left side diagonals\\n        while(i >= 0 && j >= 0){\\n            if(board[i][j] == \\'Q\\') return false;\\n            i--, j--;\\n        }\\n        i = row, j = col;\\n        while(i < n && j >= 0){\\n            if(board[i][j] == \\'Q\\') return false;\\n            i++, j--;\\n        }\\n        return true;\\n    }\\npublic:\\n    void solve(vector<string> &board, int curr_col,int &ans){\\n        int n = board.size();\\n        \\n        if(curr_col == n){\\n            ans++;\\n            return;\\n        } \\n        \\n        //Check for valid row for curr_col where queen can be placed\\n        for(int curr_row = 0; curr_row < n; curr_row++){\\n            if(isRowFree(board, curr_row)  &&                \\n               isDiagonalFree(board, curr_row, curr_col))\\n            {\\n                board[curr_row][curr_col] = \\'Q\\';\\n                solve(board,curr_col+1,ans);\\n                board[curr_row][curr_col] = \\'.\\';   //backtrack step\\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n        vector<string> board (n ,string(n,\\'.\\'));\\n        int ans=0;\\n        \\n        solve(board, 0, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147551,
                "title": "c-backtracking-4ms-memory-99-9",
                "content": "class Solution {\\npublic:\\n\\n    int vis[9][9] ={0};\\n    int cnt=0;\\n    bool isvalid( int i, int j, int n){\\n        int x = i -1;\\n        while(x>=0){\\n            if(vis[x][j]){\\n                return false;\\n            }\\n            x--;\\n        }\\n        x = i -1;\\n        int y= j -1;\\n        while(x>=0 && y>=0){\\n            if(vis[x][y]){\\n                return false;\\n            }\\n            x--;y--;\\n        }\\n        x = i-1;\\n        y = j+1;\\n        while(x>=0 && y<n){\\n            if(vis[x][y]){\\n                return false;\\n            }\\n            x--;y++;\\n        }\\n        return true;\\n    }\\n    \\n    void countNQ(int r, int n){\\n        if(r == n){\\n            cnt++;\\n            return;\\n        }\\n\\n        for(int c= 0; c<n; c++){\\n            if(isvalid(r, c,n)){\\n                vis[r][c] = 1;\\n                countNQ(r+1, n);\\n                vis[r][c] = 0;\\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n        // vector<vector<int>>vis(n, vector<int>(n));\\n        countNQ(0,n);\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int vis[9][9] ={0}",
                "codeTag": "Java"
            },
            {
                "id": 916375,
                "title": "python-easy-solution-with-comments-95-7-faster",
                "content": "class Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        \\n        \\n        #initializing the variables column, left digonal, right digonal, result\\n        col=[0]*(n+1); left_diag=[0]*(50); right_diag=[0]*(50);self.result=0\\n        \\n        #here is the main function\\n        def nqueen(c,n,ans):\\n            \\n            #if all columns are filled return True\\n            if c>=n: return True\\n            \\n            #traversing through every row\\n            for r in range(n):\\n                \\n                #if it is safe\\n                if col[r]!=1 and left_diag[r-c+n-1]!=1 and right_diag[r+c]!=1:\\n                    \\n                    #then we will update corresponding values to 1\\n                    col[r]=left_diag[r-c+n-1]=right_diag[r+c]=ans[r][c]=1\\n                    \\n                    #if the the total board is filled then we will make result+1\\n                    if nqueen(c+1,n,ans): self.result+=1\\n                        \\n                    #if there was no way to fill backtrack and set all values to 0\\n                    col[r]=left_diag[r-c+n-1]=right_diag[r+c]=ans[r][c]=0\\n        \\n        #here we are creating the empty grid\\n        grid=[[0]*n for i in range(n)]\\n        #calling main function\\n        nqueen(0,n,grid)\\n        \\n        return self.result",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "class Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        \\n        \\n        #initializing the variables column, left digonal, right digonal, result\\n        col=[0]*(n+1); left_diag=[0]*(50); right_diag=[0]*(50);self.result=0\\n        \\n        #here is the main function\\n        def nqueen(c,n,ans):\\n            \\n            #if all columns are filled return True\\n            if c>=n: return True\\n            \\n            #traversing through every row\\n            for r in range(n):\\n                \\n                #if it is safe\\n                if col[r]!=1 and left_diag[r-c+n-1]!=1 and right_diag[r+c]!=1:\\n                    \\n                    #then we will update corresponding values to 1\\n                    col[r]=left_diag[r-c+n-1]=right_diag[r+c]=ans[r][c]=1\\n                    \\n                    #if the the total board is filled then we will make result+1\\n                    if nqueen(c+1,n,ans): self.result+=1\\n                        \\n                    #if there was no way to fill backtrack and set all values to 0\\n                    col[r]=left_diag[r-c+n-1]=right_diag[r+c]=ans[r][c]=0\\n        \\n        #here we are creating the empty grid\\n        grid=[[0]*n for i in range(n)]\\n        #calling main function\\n        nqueen(0,n,grid)\\n        \\n        return self.result",
                "codeTag": "Java"
            },
            {
                "id": 827234,
                "title": "go-backtracking-solution",
                "content": "This is an easier version of #51.\\n\\nMore Go LC solutions:\\nhttps://github.com/phea/leetcode-go\\n\\n```go\\nfunc totalNQueens(n int) int {\\n\\tcol := make([]int, n)\\n\\tdiag := make([]int, n*2)\\n\\tdiag2 := make([]int, n*2)\\n\\tvar count int\\n\\tvar search func(y int)\\n\\tsearch = func(y int) {\\n\\t\\tif y == n {\\n\\t\\t\\tcount++\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tfor x := 0; x < n; x++ {\\n\\t\\t\\tif col[x] != 0 || diag[x+y] != 0 || diag2[x-y+n-1] != 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tcol[x], diag[x+y], diag2[x-y+n-1] = 1, 1, 1\\n\\t\\t\\tsearch(y + 1)\\n\\t\\t\\tcol[x], diag[x+y], diag2[x-y+n-1] = 0, 0, 0\\n\\t\\t}\\n\\t}\\n\\n\\tsearch(0)\\n\\treturn count\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```go\\nfunc totalNQueens(n int) int {\\n\\tcol := make([]int, n)\\n\\tdiag := make([]int, n*2)\\n\\tdiag2 := make([]int, n*2)\\n\\tvar count int\\n\\tvar search func(y int)\\n\\tsearch = func(y int) {\\n\\t\\tif y == n {\\n\\t\\t\\tcount++\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tfor x := 0; x < n; x++ {\\n\\t\\t\\tif col[x] != 0 || diag[x+y] != 0 || diag2[x-y+n-1] != 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tcol[x], diag[x+y], diag2[x-y+n-1] = 1, 1, 1\\n\\t\\t\\tsearch(y + 1)\\n\\t\\t\\tcol[x], diag[x+y], diag2[x-y+n-1] = 0, 0, 0\\n\\t\\t}\\n\\t}\\n\\n\\tsearch(0)\\n\\treturn count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 760728,
                "title": "java-backtracking-solution",
                "content": "If you found the solution helpful, kindly upvote. :)\\n\\n```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n           \\tList<List<Integer>> result= new ArrayList<List<Integer>>();\\n    \\tsolveNQueens(result, n, 0, new ArrayList<Integer>());\\n    \\treturn result.size();\\n    }\\n\\n\\tprivate static void solveNQueens(List<List<Integer>> result, int n, int row, ArrayList<Integer> colPlacement)\\n\\t{\\n\\t\\tif(row==n)\\n\\t\\t\\tresult.add(new ArrayList<Integer>(colPlacement));\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor(int col=0; col<n; col++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcolPlacement.add(col);\\n\\t\\t\\t\\tif(placementIsValid(colPlacement))\\n\\t\\t\\t\\t\\tsolveNQueens(result, n, row+1, colPlacement);\\n\\t\\t\\t\\tcolPlacement.remove(colPlacement.size()-1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tprivate static boolean placementIsValid(ArrayList<Integer> colPlacement) \\n\\t{\\n\\t\\tint row= colPlacement.size()-1;\\n\\t\\tfor(int i=0; i<row; i++)\\n\\t\\t{\\n\\t\\t\\tint diff= Math.abs(colPlacement.get(i)-colPlacement.get(row));\\n\\t\\t\\tif(diff==0 || diff==(row-i))\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n           \\tList<List<Integer>> result= new ArrayList<List<Integer>>();\\n    \\tsolveNQueens(result, n, 0, new ArrayList<Integer>());\\n    \\treturn result.size();\\n    }\\n\\n\\tprivate static void solveNQueens(List<List<Integer>> result, int n, int row, ArrayList<Integer> colPlacement)\\n\\t{\\n\\t\\tif(row==n)\\n\\t\\t\\tresult.add(new ArrayList<Integer>(colPlacement));\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor(int col=0; col<n; col++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcolPlacement.add(col);\\n\\t\\t\\t\\tif(placementIsValid(colPlacement))\\n\\t\\t\\t\\t\\tsolveNQueens(result, n, row+1, colPlacement);\\n\\t\\t\\t\\tcolPlacement.remove(colPlacement.size()-1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tprivate static boolean placementIsValid(ArrayList<Integer> colPlacement) \\n\\t{\\n\\t\\tint row= colPlacement.size()-1;\\n\\t\\tfor(int i=0; i<row; i++)\\n\\t\\t{\\n\\t\\t\\tint diff= Math.abs(colPlacement.get(i)-colPlacement.get(row));\\n\\t\\t\\tif(diff==0 || diff==(row-i))\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503671,
                "title": "swift-dsf-solution-beats-100",
                "content": "```\\nclass Solution {\\n    \\n    var total:Int = 0\\n    \\n    func totalNQueens(_ n: Int) -> Int{\\n        var arr:[Int] = Array(repeating: 0, count: n)\\n        helper(&arr, 0)\\n        return total\\n    }\\n    \\n    func helper(_ arr: inout [Int],_ current: Int) {\\n        if current == arr.count{\\n            total += 1\\n            return\\n        }\\n        for i in 0..<arr.count{\\n            if !hasConflict(&arr, current, i){\\n                arr[current] = i\\n                helper(&arr, current+1)\\n            }\\n        }\\n    }\\n    \\n    func hasConflict(_ arr:inout[Int],_ row:Int,_ col:Int)->Bool{\\n        for i in 0..<row {\\n            if arr[i] == col || arr[i] + i == col + row || arr[i] - i == col - row {\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    var total:Int = 0\\n    \\n    func totalNQueens(_ n: Int) -> Int{\\n        var arr:[Int] = Array(repeating: 0, count: n)\\n        helper(&arr, 0)\\n        return total\\n    }\\n    \\n    func helper(_ arr: inout [Int],_ current: Int) {\\n        if current == arr.count{\\n            total += 1\\n            return\\n        }\\n        for i in 0..<arr.count{\\n            if !hasConflict(&arr, current, i){\\n                arr[current] = i\\n                helper(&arr, current+1)\\n            }\\n        }\\n    }\\n    \\n    func hasConflict(_ arr:inout[Int],_ row:Int,_ col:Int)->Bool{\\n        for i in 0..<row {\\n            if arr[i] == col || arr[i] + i == col + row || arr[i] - i == col - row {\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480337,
                "title": "javascript-and-c-solutions",
                "content": "**Synopsis:**\\n\\nSame as [51. N-Queens](https://leetcode.com/problems/n-queens/discuss/480335/Javascript-and-C%2B%2B-solutions) except for the return value.  Instead of returning string reprenstations of the solutions, return the count of solutions.\\n\\n*Javascript*\\n```\\nvar totalNQueens = (N, cnt = 0) => {\\n    let A = Array(N).fill(-1); // index is the row and value is the column of each queen\\n    let ok = (i, j) => {\\n        if (A[i] > -1 || A.some(col => col == j) || A.some((col, row, A) => col > -1 && Math.abs(row - i) == Math.abs(col - j)))\\n            return false; // invalid row, col, or diag\\n        return true;\\n    };\\n    let dfs = (i = 0) => {\\n        if (i == N) {\\n            ++cnt;\\n            return;\\n        }\\n        for (let j = 0; j < N; ++j) {\\n            if (!ok(i, j))\\n                continue;\\n            A[i] = j,\\n            dfs(i + 1),\\n            A[i] = -1;            \\n        }\\n    };\\n    dfs();\\n    return cnt;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int totalNQueens(int N, VVI ans = {}, int cnt = 0) {\\n        VI A(N, -1); // row is index and col is value of each queen\\n        return dfs(A, ans);\\n    }\\nprivate:\\n    bool ok(VI& A, int i, int j) {\\n        if (A[i] > -1 || find(A.begin(), A.end(), j) != A.end())\\n            return false;\\n        for (auto row = 0; row < A.size(); ++row) {\\n            auto col = A[row];\\n            if (col > -1 && abs(row - i) == abs(col - j))\\n                return false;\\n        }\\n        return true;\\n    };\\n    int dfs(VI& A, VVI& ans, int i = 0, int cnt = 0) {\\n        auto N = A.size();\\n        if (i == N) {\\n            ans.push_back(A);\\n            return 1;\\n        }\\n        for (auto j = 0; j < N; ++j) {\\n            if (!ok(A, i, j))\\n                continue;\\n            A[i] = j;\\n            cnt += dfs(A, ans, i + 1);\\n            A[i] = -1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar totalNQueens = (N, cnt = 0) => {\\n    let A = Array(N).fill(-1); // index is the row and value is the column of each queen\\n    let ok = (i, j) => {\\n        if (A[i] > -1 || A.some(col => col == j) || A.some((col, row, A) => col > -1 && Math.abs(row - i) == Math.abs(col - j)))\\n            return false; // invalid row, col, or diag\\n        return true;\\n    };\\n    let dfs = (i = 0) => {\\n        if (i == N) {\\n            ++cnt;\\n            return;\\n        }\\n        for (let j = 0; j < N; ++j) {\\n            if (!ok(i, j))\\n                continue;\\n            A[i] = j,\\n            dfs(i + 1),\\n            A[i] = -1;            \\n        }\\n    };\\n    dfs();\\n    return cnt;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int totalNQueens(int N, VVI ans = {}, int cnt = 0) {\\n        VI A(N, -1); // row is index and col is value of each queen\\n        return dfs(A, ans);\\n    }\\nprivate:\\n    bool ok(VI& A, int i, int j) {\\n        if (A[i] > -1 || find(A.begin(), A.end(), j) != A.end())\\n            return false;\\n        for (auto row = 0; row < A.size(); ++row) {\\n            auto col = A[row];\\n            if (col > -1 && abs(row - i) == abs(col - j))\\n                return false;\\n        }\\n        return true;\\n    };\\n    int dfs(VI& A, VVI& ans, int i = 0, int cnt = 0) {\\n        auto N = A.size();\\n        if (i == N) {\\n            ans.push_back(A);\\n            return 1;\\n        }\\n        for (auto j = 0; j < N; ++j) {\\n            if (!ok(A, i, j))\\n                continue;\\n            A[i] = j;\\n            cnt += dfs(A, ans, i + 1);\\n            A[i] = -1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 386070,
                "title": "javascript",
                "content": "```\\nvar totalNQueens = function(n) {\\n    let res = 0;\\n    let board = [];\\n    function backtrack(r) {\\n        if(r === n) {\\n            res++;\\n            return;\\n        }\\n        for(let c = 0 ; c < n ; c++) {\\n            if(!board.some((bc, br) => \\n                          bc === c || bc - br === c - r || bc + br === c + r)) {\\n                board.push(c);\\n                backtrack(r + 1);\\n                board.pop();\\n            }\\n        }\\n    }\\n    backtrack(0);\\n    return res;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar totalNQueens = function(n) {\\n    let res = 0;\\n    let board = [];\\n    function backtrack(r) {\\n        if(r === n) {\\n            res++;\\n            return;\\n        }\\n        for(let c = 0 ; c < n ; c++) {\\n            if(!board.some((bc, br) => \\n                          bc === c || bc - br === c - r || bc + br === c + r)) {\\n                board.push(c);\\n                backtrack(r + 1);\\n                board.pop();\\n            }\\n        }\\n    }\\n    backtrack(0);\\n    return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 368847,
                "title": "java-backtracking-solution-traditional-and-clean",
                "content": "```\\nclass Solution {\\n    /*\\n    \\u5BF9\\u4E8E\\u8FD9\\u7C7B\\u95EE\\u9898\\uFF0C\\u6CA1\\u6709\\u592A\\u7B80\\u4FBF\\u7684\\u65B9\\u6CD5\\uFF0C\\u53EA\\u80FD\\u4F7F\\u7528\\u7A77\\u4E3E\\u6CD5\\uFF0C\\u5C31\\u662F\\u5C1D\\u8BD5\\u6240\\u6709\\u7684\\u7EC4\\u5408\\uFF0C\\u6BCF\\u653E\\u7F6E\\u4E00\\u4E2A\\u65B0\\u7684\\u7687\\u540E\\u7684\\u65F6\\u5019\\uFF0C\\u5FC5\\u987B\\u8981\\u4FDD\\u8BC1\\u8DDF\\u4E4B\\u524D\\u7684\\u6240\\u6709\\u7687\\u540E\\u4E0D\\u80FD\\u51B2\\u7A81\\uFF0C\\u82E5\\u53D1\\u751F\\u4E86\\u51B2\\u7A81\\uFF0C\\u8BF4\\u660E\\u5F53\\u524D\\u4F4D\\u7F6E\\u4E0D\\u80FD\\u653E\\uFF0C\\u8981\\u91CD\\u65B0\\u627E\\u5730\\u65B9\\uFF0C\\u8FD9\\u4E2A\\u903B\\u8F91\\u975E\\u5E38\\u9002\\u5408\\u7528\\u9012\\u5F52\\u6765\\u505A\\u3002\\n    \\u6240\\u8C13\\u9012\\u5F52\\u56DE\\u6EAF\\uFF0C\\u672C\\u8D28\\u4E0A\\u662F\\u4E00\\u79CD\\u679A\\u4E3E\\u6CD5\\u3002\\u8FD9\\u79CD\\u65B9\\u6CD5\\u4ECE\\u68CB\\u76D8\\u7684\\u7B2C\\u4E00\\u884C\\u5F00\\u59CB\\u5C1D\\u8BD5\\u6446\\u653E\\u7B2C\\u4E00\\u4E2A\\u7687\\u540E\\uFF0C\\u6446\\u653E\\u6210\\u529F\\u540E\\uFF0C\\u9012\\u5F52\\u4E00\\u5C42\\uFF0C\\u518D\\u9075\\u5FAA\\u89C4\\u5219\\u5728\\u68CB\\u76D8\\u7B2C\\u4E8C\\u884C\\u6765\\u6446\\u653E\\u7B2C\\u4E8C\\u4E2A\\u7687\\u540E\\u3002\\u5982\\u679C\\u5F53\\u524D\\u4F4D\\u7F6E\\u65E0\\u6CD5\\u6446\\u653E\\uFF0C\\u5219\\u5411\\u53F3\\u79FB\\u52A8\\u4E00\\u683C\\u518D\\u6B21\\u5C1D\\u8BD5\\uFF0C\\u5982\\u679C\\u6446\\u653E\\u6210\\u529F\\uFF0C\\u5219\\u7EE7\\u7EED\\u9012\\u5F52\\u4E00\\u5C42\\uFF0C\\u6446\\u653E\\u7B2C\\u4E09\\u4E2A\\u7687\\u540E......\\n    \\u5982\\u679C\\u67D0\\u4E00\\u5C42\\u770B\\u904D\\u4E86\\u6240\\u6709\\u683C\\u5B50\\uFF0C\\u90FD\\u65E0\\u6CD5\\u6210\\u529F\\u6446\\u653E\\uFF0C\\u5219\\u56DE\\u6EAF\\u5230\\u4E0A\\u4E00\\u4E2A\\u7687\\u540E\\uFF0C\\u8BA9\\u4E0A\\u4E00\\u4E2A\\u7687\\u540E\\u53F3\\u79FB\\u4E00\\u683C\\uFF0C\\u518D\\u8FDB\\u884C\\u9012\\u5F52\\u3002\\u5982\\u679C\\u516B\\u4E2A\\u7687\\u540E\\u90FD\\u6446\\u653E\\u5B8C\\u6BD5\\u4E14\\u7B26\\u5408\\u89C4\\u5219\\uFF0C\\u90A3\\u4E48\\u5C31\\u5F97\\u5230\\u4E86\\u5176\\u4E2D\\u4E00\\u79CD\\u6B63\\u786E\\u7684\\u89E3\\u6CD5\\u3002\\n    */\\n    int results = 0;\\n    public int totalNQueens(int n) {\\n        if (n <= 0) {\\n            return 0;\\n        }\\n        \\n        List<Integer> queenPos = new ArrayList<>();\\n        search(queenPos, n);\\n        return results;\\n    }\\n    \\n    /*\\n     * results store all of the chessboards\\n     * queenPos store the column indices or the position of queens for each row\\n     */\\n    private void search(List<Integer> queenPos,\\n                        int n) {\\n        \\n        // there are already n queens in the list, \\n        // which means every row has been assigned a queen\\n        if (queenPos.size() == n) {\\n            results++;\\n            return;\\n        }\\n        \\n        for (int colIndex = 0; colIndex < n; colIndex++) {\\n            if (!isValid(queenPos, colIndex)) {\\n                continue;\\n            }\\n            queenPos.add(colIndex);\\n            search(queenPos, n);\\n            // backtracking, and explore if the queen can be placed into the next column\\n            queenPos.remove(queenPos.size() - 1);\\n        }\\n    }\\n    \\n    private boolean isValid(List<Integer> queenPos, int column) {\\n        int row = queenPos.size();\\n        for (int rowIndex = 0; rowIndex < row; rowIndex++) {\\n            int preQueenPos = queenPos.get(rowIndex);\\n            // same column, fail\\n            if (preQueenPos == column) {\\n                return false;\\n            }\\n            // left diagonal or right diagonal, fail\\n            if (rowIndex + preQueenPos == row + column \\n                || rowIndex - preQueenPos == row - column) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    \\u5BF9\\u4E8E\\u8FD9\\u7C7B\\u95EE\\u9898\\uFF0C\\u6CA1\\u6709\\u592A\\u7B80\\u4FBF\\u7684\\u65B9\\u6CD5\\uFF0C\\u53EA\\u80FD\\u4F7F\\u7528\\u7A77\\u4E3E\\u6CD5\\uFF0C\\u5C31\\u662F\\u5C1D\\u8BD5\\u6240\\u6709\\u7684\\u7EC4\\u5408\\uFF0C\\u6BCF\\u653E\\u7F6E\\u4E00\\u4E2A\\u65B0\\u7684\\u7687\\u540E\\u7684\\u65F6\\u5019\\uFF0C\\u5FC5\\u987B\\u8981\\u4FDD\\u8BC1\\u8DDF\\u4E4B\\u524D\\u7684\\u6240\\u6709\\u7687\\u540E\\u4E0D\\u80FD\\u51B2\\u7A81\\uFF0C\\u82E5\\u53D1\\u751F\\u4E86\\u51B2\\u7A81\\uFF0C\\u8BF4\\u660E\\u5F53\\u524D\\u4F4D\\u7F6E\\u4E0D\\u80FD\\u653E\\uFF0C\\u8981\\u91CD\\u65B0\\u627E\\u5730\\u65B9\\uFF0C\\u8FD9\\u4E2A\\u903B\\u8F91\\u975E\\u5E38\\u9002\\u5408\\u7528\\u9012\\u5F52\\u6765\\u505A\\u3002\\n    \\u6240\\u8C13\\u9012\\u5F52\\u56DE\\u6EAF\\uFF0C\\u672C\\u8D28\\u4E0A\\u662F\\u4E00\\u79CD\\u679A\\u4E3E\\u6CD5\\u3002\\u8FD9\\u79CD\\u65B9\\u6CD5\\u4ECE\\u68CB\\u76D8\\u7684\\u7B2C\\u4E00\\u884C\\u5F00\\u59CB\\u5C1D\\u8BD5\\u6446\\u653E\\u7B2C\\u4E00\\u4E2A\\u7687\\u540E\\uFF0C\\u6446\\u653E\\u6210\\u529F\\u540E\\uFF0C\\u9012\\u5F52\\u4E00\\u5C42\\uFF0C\\u518D\\u9075\\u5FAA\\u89C4\\u5219\\u5728\\u68CB\\u76D8\\u7B2C\\u4E8C\\u884C\\u6765\\u6446\\u653E\\u7B2C\\u4E8C\\u4E2A\\u7687\\u540E\\u3002\\u5982\\u679C\\u5F53\\u524D\\u4F4D\\u7F6E\\u65E0\\u6CD5\\u6446\\u653E\\uFF0C\\u5219\\u5411\\u53F3\\u79FB\\u52A8\\u4E00\\u683C\\u518D\\u6B21\\u5C1D\\u8BD5\\uFF0C\\u5982\\u679C\\u6446\\u653E\\u6210\\u529F\\uFF0C\\u5219\\u7EE7\\u7EED\\u9012\\u5F52\\u4E00\\u5C42\\uFF0C\\u6446\\u653E\\u7B2C\\u4E09\\u4E2A\\u7687\\u540E......\\n    \\u5982\\u679C\\u67D0\\u4E00\\u5C42\\u770B\\u904D\\u4E86\\u6240\\u6709\\u683C\\u5B50\\uFF0C\\u90FD\\u65E0\\u6CD5\\u6210\\u529F\\u6446\\u653E\\uFF0C\\u5219\\u56DE\\u6EAF\\u5230\\u4E0A\\u4E00\\u4E2A\\u7687\\u540E\\uFF0C\\u8BA9\\u4E0A\\u4E00\\u4E2A\\u7687\\u540E\\u53F3\\u79FB\\u4E00\\u683C\\uFF0C\\u518D\\u8FDB\\u884C\\u9012\\u5F52\\u3002\\u5982\\u679C\\u516B\\u4E2A\\u7687\\u540E\\u90FD\\u6446\\u653E\\u5B8C\\u6BD5\\u4E14\\u7B26\\u5408\\u89C4\\u5219\\uFF0C\\u90A3\\u4E48\\u5C31\\u5F97\\u5230\\u4E86\\u5176\\u4E2D\\u4E00\\u79CD\\u6B63\\u786E\\u7684\\u89E3\\u6CD5\\u3002\\n    */\\n    int results = 0;\\n    public int totalNQueens(int n) {\\n        if (n <= 0) {\\n            return 0;\\n        }\\n        \\n        List<Integer> queenPos = new ArrayList<>();\\n        search(queenPos, n);\\n        return results;\\n    }\\n    \\n    /*\\n     * results store all of the chessboards\\n     * queenPos store the column indices or the position of queens for each row\\n     */\\n    private void search(List<Integer> queenPos,\\n                        int n) {\\n        \\n        // there are already n queens in the list, \\n        // which means every row has been assigned a queen\\n        if (queenPos.size() == n) {\\n            results++;\\n            return;\\n        }\\n        \\n        for (int colIndex = 0; colIndex < n; colIndex++) {\\n            if (!isValid(queenPos, colIndex)) {\\n                continue;\\n            }\\n            queenPos.add(colIndex);\\n            search(queenPos, n);\\n            // backtracking, and explore if the queen can be placed into the next column\\n            queenPos.remove(queenPos.size() - 1);\\n        }\\n    }\\n    \\n    private boolean isValid(List<Integer> queenPos, int column) {\\n        int row = queenPos.size();\\n        for (int rowIndex = 0; rowIndex < row; rowIndex++) {\\n            int preQueenPos = queenPos.get(rowIndex);\\n            // same column, fail\\n            if (preQueenPos == column) {\\n                return false;\\n            }\\n            // left diagonal or right diagonal, fail\\n            if (rowIndex + preQueenPos == row + column \\n                || rowIndex - preQueenPos == row - column) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 305056,
                "title": "c-99-beaten-using-backtracking-basic-hacking-code-the-road-coderz-codez",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        \\n        int aCol[n + 1];\\n        \\n        return countQueens(n, aCol, 0); \\n    }\\n    \\n    int countQueens(int n, int *pCol, int pIndex) {\\n        \\n        if (pIndex >= n) { return 1; }\\n        \\n        int aCount = 0;\\n        \\n        for (int i=0;i<n;i++) {\\n            \\n            bool aBlocked = false;\\n            \\n            for (int aBack=pIndex-1;aBack>=0;aBack--) {\\n                \\n                if (pCol[aBack] == i) { aBlocked = true; }\\n                \\n                int aDiff = pCol[aBack] - i;\\n                if (aDiff < 0) { aDiff = -aDiff; }\\n                \\n                if ((pIndex - aBack) == aDiff) {\\n                    aBlocked = true;\\n                }\\n            }\\n            if (aBlocked) { continue; }\\n            \\n            pCol[pIndex] = i;\\n            \\n            aCount += countQueens(n, pCol, pIndex + 1);   \\n        }\\n        return aCount;\\n    }\\n    \\n};\\n```\\n\\nGG",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        \\n        int aCol[n + 1];\\n        \\n        return countQueens(n, aCol, 0); \\n    }\\n    \\n    int countQueens(int n, int *pCol, int pIndex) {\\n        \\n        if (pIndex >= n) { return 1; }\\n        \\n        int aCount = 0;\\n        \\n        for (int i=0;i<n;i++) {\\n            \\n            bool aBlocked = false;\\n            \\n            for (int aBack=pIndex-1;aBack>=0;aBack--) {\\n                \\n                if (pCol[aBack] == i) { aBlocked = true; }\\n                \\n                int aDiff = pCol[aBack] - i;\\n                if (aDiff < 0) { aDiff = -aDiff; }\\n                \\n                if ((pIndex - aBack) == aDiff) {\\n                    aBlocked = true;\\n                }\\n            }\\n            if (aBlocked) { continue; }\\n            \\n            pCol[pIndex] = i;\\n            \\n            aCount += countQueens(n, pCol, pIndex + 1);   \\n        }\\n        return aCount;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 299715,
                "title": "java-clean-bitwise-implementation-beats-100-0ms",
                "content": "```\\nclass Solution {\\n  \\n  private int size;\\n  private int count;\\n\\n  private void solve(int row, int ld, int rd) {\\n    if (row == size) {\\n      count++;\\n      return;\\n    }\\n    int pos = size & (~(row | ld | rd));\\n    while (pos != 0) {\\n      int p = pos & (-pos);\\n      pos -= p;\\n      solve(row + p, (ld + p) << 1, (rd + p) >> 1);\\n    }\\n  }\\n  \\n  public int totalNQueens(int n) {\\n    count = 0;\\n    size = (1 << n) - 1;\\n    solve(0, 0, 0);\\n    return count;  \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n  \\n  private int size;\\n  private int count;\\n\\n  private void solve(int row, int ld, int rd) {\\n    if (row == size) {\\n      count++;\\n      return;\\n    }\\n    int pos = size & (~(row | ld | rd));\\n    while (pos != 0) {\\n      int p = pos & (-pos);\\n      pos -= p;\\n      solve(row + p, (ld + p) << 1, (rd + p) >> 1);\\n    }\\n  }\\n  \\n  public int totalNQueens(int n) {\\n    count = 0;\\n    size = (1 << n) - 1;\\n    solve(0, 0, 0);\\n    return count;  \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 196627,
                "title": "c-using-bit-manipulation",
                "content": "Need to consider the bit size.  \\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(int row, int cols, int pie, int na, int &n, int &count) {\\n        if (row >= n) {\\n            count++;\\n            return;\\n        }\\n\\n        int bits = ~(cols | pie | na) & (1 << n - 1);\\n        while (bits) {\\n            int x = bits & -bits;\\n            dfs(row + 1, cols | x, (pie | x) << 1, (na | x) >> 1, n, count);\\n            bits ^= x;\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        if (n < 1) {\\n            return 0;\\n        }\\n\\n        int ret = 0;\\n        dfs(0, 0, 0, 0, n, ret);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int row, int cols, int pie, int na, int &n, int &count) {\\n        if (row >= n) {\\n            count++;\\n            return;\\n        }\\n\\n        int bits = ~(cols | pie | na) & (1 << n - 1);\\n        while (bits) {\\n            int x = bits & -bits;\\n            dfs(row + 1, cols | x, (pie | x) << 1, (na | x) >> 1, n, count);\\n            bits ^= x;\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        if (n < 1) {\\n            return 0;\\n        }\\n\\n        int ret = 0;\\n        dfs(0, 0, 0, 0, n, ret);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152108,
                "title": "a-nice-hack-might-be-very-informative-specially-for-new-users",
                "content": "For those who don\\'t know, this site can be of very much use.\\nThere\\'s this site: https://oeis.org/ (The online encyclopedia of integer sequence) which has all popular integer sequences. Number of solutions of NQueens is one among them.\\n\\nJust search for nQueen, you can see it here: https://oeis.org/search?q=nqueen&language=english&go=Search\\n\\nNow coming to the code\\n```cpp\\nint totalNQueens(int n) {\\n    int ans[] = {1, 0, 0, 2, 10, 4, 40, 92, 352, 724, 2680, 14200, 73712, 365596, 2279184, 14772512, 95815104, 666090624};\\n    return ans[n - 1];\\n}\\n```\\n:P\\n",
                "solutionTags": [],
                "code": "```cpp\\nint totalNQueens(int n) {\\n    int ans[] = {1, 0, 0, 2, 10, 4, 40, 92, 352, 724, 2680, 14200, 73712, 365596, 2279184, 14772512, 95815104, 666090624};\\n    return ans[n - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 123480,
                "title": "java-beats-100-love-u-all",
                "content": "```\\nclass Solution {\\n    private static final int res[] = {1, 0, 0, 2, 10, 4, 40, 92, 352, 724, 2680, 14200, 73712, 365596, 2279184, 14772512, 95815104};\\n\\n    public int totalNQueens(int n) {\\n        if (n >= 1) {\\n            return res[n - 1];\\n        }\\n        return 0;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int res[] = {1, 0, 0, 2, 10, 4, 40, 92, 352, 724, 2680, 14200, 73712, 365596, 2279184, 14772512, 95815104};\\n\\n    public int totalNQueens(int n) {\\n        if (n >= 1) {\\n            return res[n - 1];\\n        }\\n        return 0;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20064,
                "title": "beat-me-fastest-c-15-queens-1000ms",
                "content": "15 queens ~ 1000ms\\n```\\nint N, NF;\\nint put(int n, int nw, int ne){\\n        if(n==NF)return 1;\\n        int res=0;\\n        nw>>=1;ne<<=1;\\n        int mask=( ~(n|nw|ne) ) & ( (1<<N) -1 );\\n        while(mask){\\n                int i=(mask&-mask);\\n                res+=put(n^i,nw^i,ne^i);\\n                mask-=i;\\n        }\\n        return res;\\n}\\nint totalNQueens(int n) {\\n        N=n;\\n        NF=(1<<N)-1;\\n        int i=1<<((N-1)/2);\\n        int mid=put(i,i,i);\\n        int res=mid;\\n        for(i>>=1;i;i>>=1){\\n                res+=put(i,i,i);\\n        }\\n        res+=res;\\n        if(N&1)res-=mid;\\n        return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint N, NF;\\nint put(int n, int nw, int ne){\\n        if(n==NF)return 1;\\n        int res=0;\\n        nw>>=1;ne<<=1;\\n        int mask=( ~(n|nw|ne) ) & ( (1<<N) -1 );\\n        while(mask){\\n                int i=(mask&-mask);\\n                res+=put(n^i,nw^i,ne^i);\\n                mask-=i;\\n        }\\n        return res;\\n}\\nint totalNQueens(int n) {\\n        N=n;\\n        NF=(1<<N)-1;\\n        int i=1<<((N-1)/2);\\n        int mid=put(i,i,i);\\n        int res=mid;\\n        for(i>>=1;i;i>>=1){\\n                res+=put(i,i,i);\\n        }\\n        res+=res;\\n        if(N&1)res-=mid;\\n        return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20096,
                "title": "java-ac-bit-m-over-98-low-space",
                "content": "public class Solution {\\n    \\n    int sum = 0, upperlim = 1;\\n    \\n    public int totalNQueens(int n) {\\n        upperlim = (upperlim << n) - 1; \\n        helper(0,0,0);\\n        return sum;\\n    }\\n    \\n    void helper(int row, int ld, int rd){  \\n        if (row != upperlim)  \\n        {  \\n            int pos = upperlim & ~(row | ld | rd);   \\n            while (pos>0)\\n            {  \\n                int p = pos & -pos;                                                \\n      \\n                pos -= p;                             \\n                \\n                helper(row + p, (ld + p) << 1, (rd + p) >> 1);                                \\n            }  \\n        }else{\\n            sum++;\\n        }  \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    \\n    int sum = 0, upperlim = 1;\\n    \\n    public int totalNQueens(int n) {\\n        upperlim = (upperlim << n) - 1; \\n        helper(0,0,0);\\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 20090,
                "title": "11-line-python-solution-easy-to-understand",
                "content": "    def totalNQueens(self, n):\\n        def dfs(board, row):\\n            if row == n: return 1\\n            count = 0\\n            for x in set_n - set(board):\\n                # check diagonal conflict\\n                if all(row - i != abs(x - y) for i, y in enumerate(board[:row])):\\n                    board[row] = x\\n                    count += dfs(board, row + 1)\\n                    board[row] = '.'\\n            return count\\n\\n        set_n = {i for i in xrange(n)}\\n        return dfs(['.'] * n, 0)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def totalNQueens(self, n):\\n        def dfs(board, row):\\n            if row == n: return 1\\n            count = 0\\n            for x in set_n - set(board):\\n                # check diagonal conflict\\n                if all(row - i != abs(x - y) for i, y in enumerate(board[:row])):\\n                    board[row] = x\\n                    count += dfs(board, row + 1)\\n                    board[row] = '.'\\n            return count\\n\\n        set_n = {i for i in xrange(n)}\\n        return dfs(['.'] * n, 0)",
                "codeTag": "Python3"
            },
            {
                "id": 20086,
                "title": "java-easy-version-to-understand",
                "content": "    \\tpublic static boolean checkOk(int[] columnNumber, int row) {\\n\\t\\tfor (int i = 0; i < row; i++) {\\n\\t\\t\\tif (columnNumber[row] == columnNumber[i]\\n\\t\\t\\t\\t\\t|| Math.abs(i - row) == Math.abs(columnNumber[i] - columnNumber[row]))\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tpublic static void DFS(int n, int row, int[] columnNumber, int[] count) {\\n\\t\\tif (row == n)\\n\\t\\t\\tcount[0]++;\\n\\t\\telse {\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\tcolumnNumber[row] = i;\\n\\t\\t\\t\\tif (checkOk(columnNumber, row))\\n\\t\\t\\t\\t\\tDFS(n, row + 1, columnNumber, count);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tpublic static int totalNQueens(int n) {\\n\\t\\tif (n <= 0)\\n\\t\\t\\treturn 0;\\n\\t\\tint[] columnNumber = new int[n];\\n\\t\\tint[] count = { 0 };\\n\\t\\tDFS(n, 0, columnNumber, count);\\n\\t\\treturn count[0];\\n\\t}",
                "solutionTags": [],
                "code": "    \\tpublic static boolean checkOk(int[] columnNumber, int row) {\\n\\t\\tfor (int i = 0; i < row; i++) {\\n\\t\\t\\tif (columnNumber[row] == columnNumber[i]\\n\\t\\t\\t\\t\\t|| Math.abs(i - row) == Math.abs(columnNumber[i] - columnNumber[row]))\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tpublic static void DFS(int n, int row, int[] columnNumber, int[] count) {\\n\\t\\tif (row == n)\\n\\t\\t\\tcount[0]++;\\n\\t\\telse {\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\tcolumnNumber[row] = i;\\n\\t\\t\\t\\tif (checkOk(columnNumber, row))\\n\\t\\t\\t\\t\\tDFS(n, row + 1, columnNumber, count);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tpublic static int totalNQueens(int n) {\\n\\t\\tif (n <= 0)\\n\\t\\t\\treturn 0;\\n\\t\\tint[] columnNumber = new int[n];\\n\\t\\tint[] count = { 0 };\\n\\t\\tDFS(n, 0, columnNumber, count);\\n\\t\\treturn count[0];\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 20137,
                "title": "java-accepted-clean-solutions-98-73",
                "content": "    public class Solution {\\n    int count=0;\\n    public int totalNQueens(int n) {\\n        \\n        \\n        dfs(new int[n],0,n);\\n        return count;\\n    }\\n    public void dfs(int[] pos,int step,int n) {\\n        if(step==n) {\\n            \\n            count++;\\n            return;\\n        }\\n        for(int i=0;i<n;i++) {\\n            pos[step]=i;\\n            if(isvalid(pos,step)) {\\n                dfs(pos,step+1,n);\\n            }\\n        }\\n    }\\n    public boolean isvalid(int[] pos, int step) {\\n        for(int i=0;i<step;i++) {\\n            if(pos[i]==pos[step]||(Math.abs(pos[i]-pos[step]))==(step-i)) return false;\\n            \\n        }\\n        return true;\\n    }\\n   \\n   \\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    int count=0;\\n    public int totalNQueens(int n) {\\n        \\n        \\n        dfs(new int[n],0,n);\\n        return count;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 20139,
                "title": "short-c-solution-representing-board-as-vector-int",
                "content": "The basic idea is to represent the board as a vector of int, where each index is a column of the board, and each value is the row the queen is on. We can do this because all solutions have exactly one queen on every column. Then, for each column, we place a queen on each row and check if the board is valid. If it is, we recurse on the next column. Checking if the board is valid is straightforward - we just check the row and diagonals of the newest queen against the existing queens:\\n\\n    class Solution {\\n    public:\\n        bool isValid(const vector<int>& columns, int col) {\\n            for (int c = 0; c < col; ++c) {\\n                if ((columns[c] == columns[col])\\n                    || (col - c == columns[col] - columns[c])\\n                    || (col - c == columns[c] - columns[col])) {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n    \\n        int totalNQueens(vector<int>& columns, int col) {\\n            if (col == columns.size()) {\\n                return 1;\\n            }\\n            int total = 0;\\n            for (int row = 0; row < columns.size(); ++row) {\\n                columns[col] = row;\\n                if (isValid(columns, col)) {\\n                    total += totalNQueens(columns, col + 1);\\n                }\\n            }\\n            return total;\\n        }\\n    \\n        int totalNQueens(int n) {\\n            vector<int> columns(n, 0);\\n            return totalNQueens(columns, 0);\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        bool isValid(const vector<int>& columns, int col) {\\n            for (int c = 0; c < col; ++c) {\\n                if ((columns[c] == columns[col])\\n                    || (col - c == columns[col] - columns[c])\\n                    || (col - c == columns[c] - columns[col])) {\\n                    return false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 20169,
                "title": "accepted-backtracking-python-solution-very-similar-to-the-solution-to-n-queens-i",
                "content": "    class Solution:\\n        # @return an integer\\n        def totalNQueens(self, n):\\n            self.num = 0\\n            self.board = [[\".\" for x in range(n)] for x in range(n)]\\n            self.n = n\\n            self.solve(0)\\n            return self.num\\n        \\n        def solve(self, col):\\n            if col == self.n:\\n                self.num += 1\\n                return\\n                \\n            for row in range(self.n):\\n                if self.isSafe(row, col):\\n                    self.board[row][col] = \"Q\"\\n                    self.solve(col+1)\\n                    self.board[row][col] = \".\"\\n            \\n        def isSafe(self, row, col):\\n            for c in range(col):\\n                if self.board[row][c] == \"Q\":\\n                    return False\\n            rup = row-1\\n            rdown = row+1\\n            c = col-1\\n            while c >= 0:\\n                if rup >= 0:\\n                    if self.board[rup][c] == \"Q\":\\n                        return False\\n                if rdown < self.n:\\n                    if self.board[rdown][c] == \"Q\":\\n                        return False\\n                rup -= 1\\n                rdown += 1\\n                c -= 1\\n            return True\\n\\nJust changed from appending all possible boards to self.result to incrementing self.num by 1 every time when a possible board is found.",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @return an integer\\n        def totalNQueens(self, n):\\n            self.num = 0\\n            self.board = [[\".\" for x in range(n)] for x in range(n)]\\n            self.n = n\\n            self.solve(0)\\n            return self.num\\n        \\n        def solve(self, col):\\n            if col == self.n:\\n                self.num += 1\\n                return\\n                \\n            for row in range(self.n):\\n                if self.isSafe(row, col):\\n                    self.board[row][col] = \"Q\"\\n                    self.solve(col+1)\\n                    self.board[row][col] = \".\"\\n            \\n        def isSafe(self, row, col):\\n            for c in range(col):\\n                if self.board[row][c] == \"Q\":\\n                    return False\\n            rup = row-1\\n            rdown = row+1\\n            c = col-1\\n            while c >= 0:\\n                if rup >= 0:\\n                    if self.board[rup][c] == \"Q\":\\n                        return False\\n                if rdown < self.n:\\n                    if self.board[rdown][c] == \"Q\":\\n                        return False\\n                rup -= 1\\n                rdown += 1\\n                c -= 1\\n            return True\\n\\nJust changed from appending all possible boards to self.result to incrementing self.num by 1 every time when a possible board is found.",
                "codeTag": "Java"
            },
            {
                "id": 4076593,
                "title": "easy-fast-solution-using-backtracking-and-recursion",
                "content": "# Code\\n```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n    boolean[][] board = new boolean[n][n];\\n        return queens(board, 0);\\n    }\\n    static int queens(boolean [][] board,int row) {\\n\\t\\tif(row == board.length) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tint count=0;\\n        for (int col = 0; col < board.length; col++) {\\n\\t\\t    if(isSafe(board,row,col)) {\\n\\t\\t\\t    board[row][col] = true;\\n\\t\\t\\t    count += queens(board, row+1);\\n\\t\\t\\t    board[row][col] = false;\\n\\t\\t    }\\n\\t    }\\n\\t\\treturn count;\\n\\t}\\n\\tstatic boolean isSafe(boolean[][] board, int row, int col) {\\n\\t\\t\\n\\t\\tfor (int i = 0; i < row; i++) {\\n\\t\\t\\tif(board[i][col]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint maxLeft = Math.min(row, col);\\n\\t\\tfor(int i= 1 ;i<=maxLeft;i++) {\\n\\t\\t\\tif (board[row-i][col-i]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint maxRight = Math.min(row, board.length-col-1);\\n\\t\\tfor (int i = 1; i <= maxRight; i++) {\\n\\t\\t\\tif(board[row-i][col+i]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n    boolean[][] board = new boolean[n][n];\\n        return queens(board, 0);\\n    }\\n    static int queens(boolean [][] board,int row) {\\n\\t\\tif(row == board.length) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tint count=0;\\n        for (int col = 0; col < board.length; col++) {\\n\\t\\t    if(isSafe(board,row,col)) {\\n\\t\\t\\t    board[row][col] = true;\\n\\t\\t\\t    count += queens(board, row+1);\\n\\t\\t\\t    board[row][col] = false;\\n\\t\\t    }\\n\\t    }\\n\\t\\treturn count;\\n\\t}\\n\\tstatic boolean isSafe(boolean[][] board, int row, int col) {\\n\\t\\t\\n\\t\\tfor (int i = 0; i < row; i++) {\\n\\t\\t\\tif(board[i][col]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint maxLeft = Math.min(row, col);\\n\\t\\tfor(int i= 1 ;i<=maxLeft;i++) {\\n\\t\\t\\tif (board[row-i][col-i]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint maxRight = Math.min(row, board.length-col-1);\\n\\t\\tfor (int i = 1; i <= maxRight; i++) {\\n\\t\\t\\tif(board[row-i][col+i]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018517,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n    boolean[][] board = new boolean[n][n];\\n        List<List<String>> solutions = new ArrayList<>();\\n       return solve(board, 0, solutions);\\n       \\n        \\n    }\\n     static int solve(boolean[][] board, int row, List<List<String>> solutions) {\\n        if (row == board.length) {\\n            solutions.add(display(board));\\n            return 1;\\n        }\\n            int count = 0;\\n        for (int col = 0; col < board.length; col++) {\\n            if (isSafe(board, row, col)) {\\n                board[row][col] = true;\\n               count+=solve(board, row + 1, solutions);\\n                board[row][col] = false;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private static boolean isSafe(boolean[][] board, int row, int col) {\\n        for (int i = 0; i < row; i++) {\\n            if (board[i][col]) {\\n                return false;\\n            }\\n        }\\n        int maxLeft = Math.min(row, col);\\n        for (int i = 1; i <= maxLeft; i++) {\\n            if (board[row - i][col - i]) {\\n                return false;\\n            }\\n        }\\n        int maxRight = Math.min(row, board.length - col - 1);\\n        for (int i = 1; i <= maxRight; i++) {\\n            if (board[row - i][col + i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private static ArrayList<String> display(boolean[][] board) {\\n        ArrayList<String> list = new ArrayList<>();\\n        for (boolean[] arr : board) {\\n            StringBuilder row = new StringBuilder();\\n            for (boolean num : arr) {\\n                if (num) {\\n                    row.append(\"Q\");\\n                } else {\\n                    row.append(\".\");\\n                }\\n            }\\n            list.add(row.toString());\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n    boolean[][] board = new boolean[n][n];\\n        List<List<String>> solutions = new ArrayList<>();\\n       return solve(board, 0, solutions);\\n       \\n        \\n    }\\n     static int solve(boolean[][] board, int row, List<List<String>> solutions) {\\n        if (row == board.length) {\\n            solutions.add(display(board));\\n            return 1;\\n        }\\n            int count = 0;\\n        for (int col = 0; col < board.length; col++) {\\n            if (isSafe(board, row, col)) {\\n                board[row][col] = true;\\n               count+=solve(board, row + 1, solutions);\\n                board[row][col] = false;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private static boolean isSafe(boolean[][] board, int row, int col) {\\n        for (int i = 0; i < row; i++) {\\n            if (board[i][col]) {\\n                return false;\\n            }\\n        }\\n        int maxLeft = Math.min(row, col);\\n        for (int i = 1; i <= maxLeft; i++) {\\n            if (board[row - i][col - i]) {\\n                return false;\\n            }\\n        }\\n        int maxRight = Math.min(row, board.length - col - 1);\\n        for (int i = 1; i <= maxRight; i++) {\\n            if (board[row - i][col + i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private static ArrayList<String> display(boolean[][] board) {\\n        ArrayList<String> list = new ArrayList<>();\\n        for (boolean[] arr : board) {\\n            StringBuilder row = new StringBuilder();\\n            for (boolean num : arr) {\\n                if (num) {\\n                    row.append(\"Q\");\\n                } else {\\n                    row.append(\".\");\\n                }\\n            }\\n            list.add(row.toString());\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929358,
                "title": "2-approaches-100-faster-o-1-lookup-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    // bool isSafe(int r, int c, vector<vector<int>> &board){\\n    //     //Upper\\n    //     for(int i = r-1; i >= 0; --i){\\n    //         if(board[i][c]) return false;\\n    //     }\\n\\n    //     //UL\\n    //     for(int i = r-1, j = c-1; i >= 0 && j >= 0; --i, --j){\\n    //         if(board[i][j]) return false;\\n    //     }\\n\\n    //     //UR\\n    //     for(int i = r-1, j = c+1; i >= 0 && j < n; --i, ++j){\\n    //         if(board[i][j]) return false;\\n    //     }\\n\\n    //     return true;\\n    // }\\n    // int f(int row, vector<vector<int>> &board){\\n    //     if(row == n) return 1;\\n\\n    //     int count = 0;\\n    //     for(int i = 0; i < n; ++i){\\n    //         if(isSafe(row, i, board)){\\n    //             board[row][i] = 1;\\n    //             count += f(row+1, board);\\n    //             board[row][i] = 0;\\n    //         }\\n    //     }\\n    //     return count;\\n    // }\\n    int f(int row, vector<bool> &u, vector<bool> &ul, vector<bool> &ur){\\n        if(row == n) return 1;\\n        int count = 0;\\n        for(int col = 0; col < n; ++col){\\n            if(u[col] && ul[n-1+row-col] && ur[row+col]){\\n                u[col] = false;\\n                ul[n-1+row-col] = false;\\n                ur[row+col] = false;\\n                count += f(row+1, u, ul, ur);\\n                u[col] = true;\\n                ul[n-1+row-col] = true;\\n                ur[row+col] = true;\\n            }\\n        }\\n        return count;\\n    }\\n    int totalNQueens(int N) {\\n        n = N;\\n        // vector<vector<int>> board(n, vector<int>(n, 0));\\n        vector<bool> u(n, true), ul(2*n-1, true), ur(2*n-1, true);\\n        return f(0, u, ul, ur);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    // bool isSafe(int r, int c, vector<vector<int>> &board){\\n    //     //Upper\\n    //     for(int i = r-1; i >= 0; --i){\\n    //         if(board[i][c]) return false;\\n    //     }\\n\\n    //     //UL\\n    //     for(int i = r-1, j = c-1; i >= 0 && j >= 0; --i, --j){\\n    //         if(board[i][j]) return false;\\n    //     }\\n\\n    //     //UR\\n    //     for(int i = r-1, j = c+1; i >= 0 && j < n; --i, ++j){\\n    //         if(board[i][j]) return false;\\n    //     }\\n\\n    //     return true;\\n    // }\\n    // int f(int row, vector<vector<int>> &board){\\n    //     if(row == n) return 1;\\n\\n    //     int count = 0;\\n    //     for(int i = 0; i < n; ++i){\\n    //         if(isSafe(row, i, board)){\\n    //             board[row][i] = 1;\\n    //             count += f(row+1, board);\\n    //             board[row][i] = 0;\\n    //         }\\n    //     }\\n    //     return count;\\n    // }\\n    int f(int row, vector<bool> &u, vector<bool> &ul, vector<bool> &ur){\\n        if(row == n) return 1;\\n        int count = 0;\\n        for(int col = 0; col < n; ++col){\\n            if(u[col] && ul[n-1+row-col] && ur[row+col]){\\n                u[col] = false;\\n                ul[n-1+row-col] = false;\\n                ur[row+col] = false;\\n                count += f(row+1, u, ul, ur);\\n                u[col] = true;\\n                ul[n-1+row-col] = true;\\n                ur[row+col] = true;\\n            }\\n        }\\n        return count;\\n    }\\n    int totalNQueens(int N) {\\n        n = N;\\n        // vector<vector<int>> board(n, vector<int>(n, 0));\\n        vector<bool> u(n, true), ul(2*n-1, true), ur(2*n-1, true);\\n        return f(0, u, ul, ur);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876811,
                "title": "beats-100-commented-bet-easiest-to-understand-used-safe-state-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool safe(int *place,int row,int col){\\n               for(int i=0;i<row;i++){\\n                   if(place[i]==col) return false;\\n                   if(abs(row-i)==abs(col-place[i])) return false;\\n               }\\n               return true;\\n    }\\n    void nqueen(int n,int row,int *place,int *sum){\\n                  for(int i=0;i<n;i++){\\n                if(safe(place,row,i)){\\n                   place[row]=i;\\n                   if(row==n-1) (*sum)+=1;\\n                   else nqueen(n,row+1,place,sum);\\n                }     \\n                \\n                \\n           }\\n    }\\n    int totalNQueens(int n) {\\n        int place[n];\\n        int sum=0;\\nnqueen(n,0,place,&sum);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool safe(int *place,int row,int col){\\n               for(int i=0;i<row;i++){\\n                   if(place[i]==col) return false;\\n                   if(abs(row-i)==abs(col-place[i])) return false;\\n               }\\n               return true;\\n    }\\n    void nqueen(int n,int row,int *place,int *sum){\\n                  for(int i=0;i<n;i++){\\n                if(safe(place,row,i)){\\n                   place[row]=i;\\n                   if(row==n-1) (*sum)+=1;\\n                   else nqueen(n,row+1,place,sum);\\n                }     \\n                \\n                \\n           }\\n    }\\n    int totalNQueens(int n) {\\n        int place[n];\\n        int sum=0;\\nnqueen(n,0,place,&sum);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862732,
                "title": "simplest-solution-100-sc-tc-using-recursion-backtracking",
                "content": "# Intuition\\nWe improve this from the N Quuens 1 by taking the advantage that we do not need the whole board, we just need to know the location of queens. We use a vector of pairs to store the location of our queens. We simply follow the recursive approach.\\n\\n# Approach\\nWe store the queens in a vector of pairs & increase the value of the counter whenever we get the size of the queens vector = n. To check the validity of placing queens we simply check if they\\'re in the same row or same column. Or check the mod of the difference between the row and previous rows & col and previous columns.\\n\\n# Complexity\\n- Time complexity:\\nO( N * 2^N ) - Because recursion is 2^N & our check function is N.\\n\\n# Space complexity:\\nO(N) - Because we just use a 1 dimensional vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        int count = 0;\\n        vector<pair<int , int>> queens;\\n        int col = 0;\\n        compute( col, queens, count, n);\\n\\n        return count;\\n    }\\n\\n    void compute( int col, vector<pair<int , int>>& queens, int& count, int n){\\n\\n        if( queens.size() == n){\\n            count++;\\n            return;\\n        }\\n\\n        for( int row = 0; row<n; row++ ){\\n            if( check( row, col, queens, n) ){\\n                queens.push_back({row, col});\\n                compute( col+ 1, queens, count, n);\\n                queens.pop_back();\\n            }\\n        }\\n\\n    }\\n\\n    bool check( int row, int col, vector<pair<int , int>>& queens, int n){\\n\\n        for( int i = 0; i< queens.size(); i++){\\n            int prow = queens[i].first;\\n            int pcol = queens[i].second;\\n\\n            if( pcol == col || abs(pcol - col) == abs(prow - row) || prow == row){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        int count = 0;\\n        vector<pair<int , int>> queens;\\n        int col = 0;\\n        compute( col, queens, count, n);\\n\\n        return count;\\n    }\\n\\n    void compute( int col, vector<pair<int , int>>& queens, int& count, int n){\\n\\n        if( queens.size() == n){\\n            count++;\\n            return;\\n        }\\n\\n        for( int row = 0; row<n; row++ ){\\n            if( check( row, col, queens, n) ){\\n                queens.push_back({row, col});\\n                compute( col+ 1, queens, count, n);\\n                queens.pop_back();\\n            }\\n        }\\n\\n    }\\n\\n    bool check( int row, int col, vector<pair<int , int>>& queens, int n){\\n\\n        for( int i = 0; i< queens.size(); i++){\\n            int prow = queens[i].first;\\n            int pcol = queens[i].second;\\n\\n            if( pcol == col || abs(pcol - col) == abs(prow - row) || prow == row){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862026,
                "title": "python-96-52-faster-two-approaches",
                "content": "**Brute Force Approch:**\\n```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def safe(row,col,board):\\n            i,j=row,col\\n            while i>=0 and j>=0: # for diagonaly upwards direction in left\\n                if board[i][j]==\\'Q\\':\\n                    return False\\n                i-=1\\n                j-=1\\n            i,j=row,col\\n            while i<n and j>=0: # for diagonaly downwards direction in left\\n                if board[i][j]==\\'Q\\':\\n                    return False\\n                i+=1\\n                j-=1\\n            while col>=0: # for checking the same column\\n                if board[row][col]==\\'Q\\':\\n                    return False\\n                col-=1\\n            return True\\n        \\n        def solve(c,board):\\n            if c==n:\\n                ans.append(board[:])\\n                return \\n            for i in range(n):\\n                if safe(i,c,board):\\n                    board[i]=board[i][:c]+\\'Q\\'+board[i][c+1:]\\n                    solve(c+1,board)\\n                    board[i]=board[i][:c]+\\'.\\'+board[i][c+1:]\\n                    \\n        board=[\\'.\\'*n for _ in range(n)]\\n        ans=[]\\n        solve(0,board)\\n        return len(ans)       \\n```\\n**Optimized Approach:**\\n```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def safe(row,col,same_row,left_up,left_down):\\n            if row in same_row:\\n                return False\\n            if (n-1+col-row) in left_up:\\n                return False\\n            if (row+col) in left_down:\\n                return False\\n            return True\\n        \\n        def solve(c,board,same_row,left_up,left_down):\\n            if c==n:\\n                ans.append(board[:])\\n                return \\n            for i in range(n):\\n                if safe(i,c,same_row,left_up,left_down):\\n                    board[i]=board[i][:c]+\\'Q\\'+board[i][c+1:]\\n                    same_row.add(i)\\n                    left_up.add(n-1+c-i)\\n                    left_down.add(i+c)\\n                    solve(c+1,board,same_row,left_up,left_down)\\n                    same_row.remove(i)\\n                    left_up.remove(n-1+c-i)\\n                    left_down.remove(i+c)\\n                    board[i]=board[i][:c]+\\'.\\'+board[i][c+1:]\\n                    \\n        board=[\\'.\\'*n for _ in range(n)]\\n        same_row=set()\\n        left_up=set()\\n        left_down=set()\\n        ans=[]\\n        solve(0,board,same_row,left_up,left_down)\\n        return len(ans)\\n```\\n**An upovte will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def safe(row,col,board):\\n            i,j=row,col\\n            while i>=0 and j>=0: # for diagonaly upwards direction in left\\n                if board[i][j]==\\'Q\\':\\n                    return False\\n                i-=1\\n                j-=1\\n            i,j=row,col\\n            while i<n and j>=0: # for diagonaly downwards direction in left\\n                if board[i][j]==\\'Q\\':\\n                    return False\\n                i+=1\\n                j-=1\\n            while col>=0: # for checking the same column\\n                if board[row][col]==\\'Q\\':\\n                    return False\\n                col-=1\\n            return True\\n        \\n        def solve(c,board):\\n            if c==n:\\n                ans.append(board[:])\\n                return \\n            for i in range(n):\\n                if safe(i,c,board):\\n                    board[i]=board[i][:c]+\\'Q\\'+board[i][c+1:]\\n                    solve(c+1,board)\\n                    board[i]=board[i][:c]+\\'.\\'+board[i][c+1:]\\n                    \\n        board=[\\'.\\'*n for _ in range(n)]\\n        ans=[]\\n        solve(0,board)\\n        return len(ans)       \\n```\n```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def safe(row,col,same_row,left_up,left_down):\\n            if row in same_row:\\n                return False\\n            if (n-1+col-row) in left_up:\\n                return False\\n            if (row+col) in left_down:\\n                return False\\n            return True\\n        \\n        def solve(c,board,same_row,left_up,left_down):\\n            if c==n:\\n                ans.append(board[:])\\n                return \\n            for i in range(n):\\n                if safe(i,c,same_row,left_up,left_down):\\n                    board[i]=board[i][:c]+\\'Q\\'+board[i][c+1:]\\n                    same_row.add(i)\\n                    left_up.add(n-1+c-i)\\n                    left_down.add(i+c)\\n                    solve(c+1,board,same_row,left_up,left_down)\\n                    same_row.remove(i)\\n                    left_up.remove(n-1+c-i)\\n                    left_down.remove(i+c)\\n                    board[i]=board[i][:c]+\\'.\\'+board[i][c+1:]\\n                    \\n        board=[\\'.\\'*n for _ in range(n)]\\n        same_row=set()\\n        left_up=set()\\n        left_down=set()\\n        ans=[]\\n        solve(0,board,same_row,left_up,left_down)\\n        return len(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847808,
                "title": "similar-n-queens-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public boolean issafe(int row,int col,char board[][]){\\n           //horizantal\\n           for(int j=0;j<board.length;j++){\\n               if(board[row][j]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //vertical\\n           for(int i=0;i<board[0].length;i++){\\n               if(board[i][col]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //upperleft\\n           int r=row;\\n           for(int c=col;c>=0&&r>=0;c--,r--){\\n               if(board[r][c]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //upperright\\n            r=row;\\n           for(int c=col;c<board.length&&r>=0;c++,r--){\\n               if(board[r][c]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //lowerleft\\n            r=row;\\n           for(int c=col;c>=0&&r<board[0].length;c--,r++){\\n                if(board[r][c]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //lowerright\\n           return true;\\n       }\\n    public void combine(List<List<String>> list,char board[][]){\\n        List<String> currboard=new ArrayList<>();\\n        for(int row=0;row<board.length;row++){\\n            String curr=\"\";\\n            for(int col=0;col<board[0].length;col++){\\n                if(board[row][col]==\\'Q\\'){\\n                    curr+=\\'Q\\';\\n                }\\n                else{\\n                    curr+=\\'.\\';\\n                }\\n            }\\n            currboard.add(curr);\\n        }\\n        list.add(currboard);\\n    }\\n    public void solve(List<List<String>> list,char board[][],int col){\\n        if(col==board.length){\\n            combine(list,board);\\n            return ;\\n        }\\n        for(int row=0;row<board.length;row++){\\n            if(issafe(row,col,board)){\\n                board[row][col]=\\'Q\\';\\n                solve(list,board,col+1);\\n                board[row][col]=\\'.\\';\\n            }\\n        }\\n    }\\n    public int totalNQueens(int n) {\\n        List<List<String>> list=new ArrayList<>();\\n        char board[][]=new char[n][n];\\n        solve(list,board,0);\\n        return list.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public boolean issafe(int row,int col,char board[][]){\\n           //horizantal\\n           for(int j=0;j<board.length;j++){\\n               if(board[row][j]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //vertical\\n           for(int i=0;i<board[0].length;i++){\\n               if(board[i][col]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //upperleft\\n           int r=row;\\n           for(int c=col;c>=0&&r>=0;c--,r--){\\n               if(board[r][c]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //upperright\\n            r=row;\\n           for(int c=col;c<board.length&&r>=0;c++,r--){\\n               if(board[r][c]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //lowerleft\\n            r=row;\\n           for(int c=col;c>=0&&r<board[0].length;c--,r++){\\n                if(board[r][c]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //lowerright\\n           return true;\\n       }\\n    public void combine(List<List<String>> list,char board[][]){\\n        List<String> currboard=new ArrayList<>();\\n        for(int row=0;row<board.length;row++){\\n            String curr=\"\";\\n            for(int col=0;col<board[0].length;col++){\\n                if(board[row][col]==\\'Q\\'){\\n                    curr+=\\'Q\\';\\n                }\\n                else{\\n                    curr+=\\'.\\';\\n                }\\n            }\\n            currboard.add(curr);\\n        }\\n        list.add(currboard);\\n    }\\n    public void solve(List<List<String>> list,char board[][],int col){\\n        if(col==board.length){\\n            combine(list,board);\\n            return ;\\n        }\\n        for(int row=0;row<board.length;row++){\\n            if(issafe(row,col,board)){\\n                board[row][col]=\\'Q\\';\\n                solve(list,board,col+1);\\n                board[row][col]=\\'.\\';\\n            }\\n        }\\n    }\\n    public int totalNQueens(int n) {\\n        List<List<String>> list=new ArrayList<>();\\n        char board[][]=new char[n][n];\\n        solve(list,board,0);\\n        return list.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764769,
                "title": "100-easy-fast-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n// IF THIS WILL BE HELPFUL TO YOU,PLEASE UPVOTE!\\n\\n![download.png](https://assets.leetcode.com/users/images/1e5393d0-c496-46d8-a339-1d7e7241754f_1689346738.066668.png)\\n```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n        boolean board[][]=new boolean[n][n];\\n        return queens(board,0);    }\\n      int queens(boolean[][]board,int row)\\n    {   if(row == board.length)  return 1;\\n        int count=0;\\n        // place the queen and check row and colum\\n        for(int col=0;col<board.length;col++)\\n         // place the queen if it is safe\\n        if(isSafe(board,row,col))\\n        { board[row][col]=true;\\n          count+=queens(board,row + 1);\\n          board[row][col]=false;\\n         }\\n          return count;\\n    }   \\n  boolean isSafe(boolean [][] board,int row,int col)\\n  { // checking verticle \\n    for(int i=0;i<row;i++)\\n    if(board[i][col]) return false;\\n     // checking left digonal\\n    int maxLeft=Math.min(row,col);\\n    for(int i=1;i<=maxLeft;i++)\\n    if(board[row -i][col -i]) return false;\\n    // checking right digonal\\n    int maxRight=Math.min(row,board.length - col -1);\\n    for( int i=1;i<=maxRight;i++)\\n    if(board[row - i][col + i]) return false;\\n     // if none of the check is false, means ans is true\\n     return true;\\n   }\\n }\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int totalNQueens(int n) {\\n        boolean board[][]=new boolean[n][n];\\n        return queens(board,0);    }",
                "codeTag": "Java"
            },
            {
                "id": 3700252,
                "title": "c-follows-from-n-queens-1",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<string>& temp,int i,int j){\\n        for(int k=0;k<temp.size();k++){\\n            if(temp[k][j]==\\'Q\\' || temp[i][k]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n        int a=i,b=j;\\n        while(a>=0 && b<temp.size()){\\n            if(temp[a][b]==\\'Q\\'){\\n                return false;\\n            }\\n            a--;b++;\\n        }\\n        int c=i,d=j;\\n        while(c>=0 && d>=0){\\n            if(temp[c][d]==\\'Q\\'){\\n                return false;\\n            }\\n            c--;\\n            d--;\\n        }\\n        return true;\\n    }\\n    bool helper(int i, vector<string>& temp, vector<vector<string>>& store){\\n        //base case\\n        if(i==temp.size()){\\n            store.push_back(temp);\\n            return false;\\n        }\\n        //recursive case\\n        for(int j=0;j<temp.size();j++){\\n            if(isValid(temp,i,j)){\\n                temp[i][j]=\\'Q\\';\\n                bool remaining= helper(i+1,temp,store);\\n                if(remaining==true){\\n                    return true;\\n                }\\n                temp[i][j]=\\'.\\';\\n            }\\n        }\\n        return false;\\n    }\\n    int totalNQueens(int n) {\\n        int ans1;\\n        vector<vector<string>> store;\\n        vector<string> temp;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++){\\n            ans += \".\";\\n        }\\n        for(int i=0;i<n;i++){\\n            temp.push_back(ans);\\n        }\\n        int i=0;\\n        helper(i,temp,store);\\n        ans1=store.size();\\n        return ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<string>& temp,int i,int j){\\n        for(int k=0;k<temp.size();k++){\\n            if(temp[k][j]==\\'Q\\' || temp[i][k]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n        int a=i,b=j;\\n        while(a>=0 && b<temp.size()){\\n            if(temp[a][b]==\\'Q\\'){\\n                return false;\\n            }\\n            a--;b++;\\n        }\\n        int c=i,d=j;\\n        while(c>=0 && d>=0){\\n            if(temp[c][d]==\\'Q\\'){\\n                return false;\\n            }\\n            c--;\\n            d--;\\n        }\\n        return true;\\n    }\\n    bool helper(int i, vector<string>& temp, vector<vector<string>>& store){\\n        //base case\\n        if(i==temp.size()){\\n            store.push_back(temp);\\n            return false;\\n        }\\n        //recursive case\\n        for(int j=0;j<temp.size();j++){\\n            if(isValid(temp,i,j)){\\n                temp[i][j]=\\'Q\\';\\n                bool remaining= helper(i+1,temp,store);\\n                if(remaining==true){\\n                    return true;\\n                }\\n                temp[i][j]=\\'.\\';\\n            }\\n        }\\n        return false;\\n    }\\n    int totalNQueens(int n) {\\n        int ans1;\\n        vector<vector<string>> store;\\n        vector<string> temp;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++){\\n            ans += \".\";\\n        }\\n        for(int i=0;i<n;i++){\\n            temp.push_back(ans);\\n        }\\n        int i=0;\\n        helper(i,temp,store);\\n        ans1=store.size();\\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629401,
                "title": "c-backtracking-solution-explained",
                "content": "# Intuition\\nWe need to place the queens such that they cannot cross eachother.\\n# Approach\\nWe keep check each row for a position where we can place a queen, then place it there and call recursion to place the queens in the other rows and then backtrack to find the other possibilities. \\nIf we get to the last row and are able to place a queen in that row, that means we have a possible combination, so we increment the total number of possible combinations by 1\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int count;\\n    bool checkValid(vector<string> &board, int row, int col, int size){\\n\\n        // check top up\\n        for(int i = row-1;i>=0; i--){\\n            if(board[i][col] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n\\n        // check diagonal\\n        for(int i = 1; i<=row; i++){\\n            if(col-i>=0){\\n                // left diagonal\\n                if(board[row-i][col-i] == \\'Q\\'){\\n                    return false;\\n                }\\n            }\\n            if(col+i <size){\\n                // right diagonal\\n                if(board[row-i][col+i] == \\'Q\\'){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    void helper(vector<string> &board, int row, int size){\\n        if(row == size){\\n            count++;\\n            return;\\n        }\\n\\n        for(int i = 0; i<size; i++){\\n            if(checkValid(board, row, i, size)){\\n                board[row][i] = \\'Q\\';\\n                helper(board, row+1, size);\\n                board[row][i] = \\'.\\';\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        string str;\\n        str.append(n, \\'.\\');\\n        vector<string> board(n, str);\\n        count = 0;\\n        helper(board, 0, n);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count;\\n    bool checkValid(vector<string> &board, int row, int col, int size){\\n\\n        // check top up\\n        for(int i = row-1;i>=0; i--){\\n            if(board[i][col] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n\\n        // check diagonal\\n        for(int i = 1; i<=row; i++){\\n            if(col-i>=0){\\n                // left diagonal\\n                if(board[row-i][col-i] == \\'Q\\'){\\n                    return false;\\n                }\\n            }\\n            if(col+i <size){\\n                // right diagonal\\n                if(board[row-i][col+i] == \\'Q\\'){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    void helper(vector<string> &board, int row, int size){\\n        if(row == size){\\n            count++;\\n            return;\\n        }\\n\\n        for(int i = 0; i<size; i++){\\n            if(checkValid(board, row, i, size)){\\n                board[row][i] = \\'Q\\';\\n                helper(board, row+1, size);\\n                board[row][i] = \\'.\\';\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        string str;\\n        str.append(n, \\'.\\');\\n        vector<string> board(n, str);\\n        count = 0;\\n        helper(board, 0, n);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624735,
                "title": "n-queens-bitmasking-0-ms-beats-100",
                "content": "x means safe position\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n, int row, int colMask, int leftDiagMask, int rightDiagMask) {\\n        if (row == n) {\\n            return 1;\\n        }\\n        int ans = 0;\\n        int rowState = (colMask | leftDiagMask | rightDiagMask) & ((1 << n) - 1);\\n        int x = rowState ^ ((1 << n) - 1);\\n        while (x) {\\n            int queenPos = x & (-x);\\n            x -= queenPos;\\n            if (!(queenPos & rowState)) {\\n                ans += solve(n, row + 1, colMask | queenPos, (leftDiagMask | queenPos) << 1, (rightDiagMask | queenPos) >> 1);\\n            }\\n        }\\n        return ans;\\n    }\\n    int totalNQueens(int n) {\\n        return solve(n, 0, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n, int row, int colMask, int leftDiagMask, int rightDiagMask) {\\n        if (row == n) {\\n            return 1;\\n        }\\n        int ans = 0;\\n        int rowState = (colMask | leftDiagMask | rightDiagMask) & ((1 << n) - 1);\\n        int x = rowState ^ ((1 << n) - 1);\\n        while (x) {\\n            int queenPos = x & (-x);\\n            x -= queenPos;\\n            if (!(queenPos & rowState)) {\\n                ans += solve(n, row + 1, colMask | queenPos, (leftDiagMask | queenPos) << 1, (rightDiagMask | queenPos) >> 1);\\n            }\\n        }\\n        return ans;\\n    }\\n    int totalNQueens(int n) {\\n        return solve(n, 0, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481133,
                "title": "c-using-recursion-backtracking-t-c-o-n-s-c-o-n-2",
                "content": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(n!)\\n        Space Complexity : O(n^2) + O(2*n) + O(n)\\n    */\\n    \\nprivate:\\n    vector<int> upperLeftDiagnal;\\n    vector<int> upperRightDiagnal;\\n    vector<int> upperCol;\\n    \\n    int res = 0;\\n    vector<string> board;\\n    \\n    void helper(int row, int size){\\n        if(row == size){\\n            res++;\\n            return;\\n        }\\n        \\n        for(int col=0; col<size; col++){\\n            if(upperCol[col]==0 and\\n               upperLeftDiagnal[row+col]==0 and\\n               upperRightDiagnal[(size-1)+col-row]==0\\n              ){\\n                board[row][col] = \\'Q\\';\\n                upperCol[col] = upperLeftDiagnal[row+col] = upperRightDiagnal[(size-1)+col-row] = 1;\\n                helper(row+1, size);\\n                upperCol[col] = upperLeftDiagnal[row+col] = upperRightDiagnal[(size-1)+col-row] = 0;\\n                board[row][col] = \\'.\\';\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int totalNQueens(int n) {\\n        upperLeftDiagnal.resize(2*n-1, 0);\\n        upperRightDiagnal.resize(2*n-1, 0);\\n        upperCol.resize(n, 0);\\n        \\n        board.resize(n);\\n        string s(n, \\'.\\');\\n        \\n        for(int i=0; i<n; i++){\\n            board[i] = s;\\n        }\\n        \\n        //row, size\\n        helper(0, n);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(n!)\\n        Space Complexity : O(n^2) + O(2*n) + O(n)\\n    */\\n    \\nprivate:\\n    vector<int> upperLeftDiagnal;\\n    vector<int> upperRightDiagnal;\\n    vector<int> upperCol;\\n    \\n    int res = 0;\\n    vector<string> board;\\n    \\n    void helper(int row, int size){\\n        if(row == size){\\n            res++;\\n            return;\\n        }\\n        \\n        for(int col=0; col<size; col++){\\n            if(upperCol[col]==0 and\\n               upperLeftDiagnal[row+col]==0 and\\n               upperRightDiagnal[(size-1)+col-row]==0\\n              ){\\n                board[row][col] = \\'Q\\';\\n                upperCol[col] = upperLeftDiagnal[row+col] = upperRightDiagnal[(size-1)+col-row] = 1;\\n                helper(row+1, size);\\n                upperCol[col] = upperLeftDiagnal[row+col] = upperRightDiagnal[(size-1)+col-row] = 0;\\n                board[row][col] = \\'.\\';\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int totalNQueens(int n) {\\n        upperLeftDiagnal.resize(2*n-1, 0);\\n        upperRightDiagnal.resize(2*n-1, 0);\\n        upperCol.resize(n, 0);\\n        \\n        board.resize(n);\\n        string s(n, \\'.\\');\\n        \\n        for(int i=0; i<n; i++){\\n            board[i] = s;\\n        }\\n        \\n        //row, size\\n        helper(0, n);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447118,
                "title": "o-1-c-fastest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        switch(n) {\\n            case 1: return 1;\\n            case 2:\\n            case 3: return 0;\\n            case 4: return 2;\\n            case 5: return 10;\\n            case 6: return 4;\\n            case 7: return 40;\\n            case 8: return 92;\\n            case 9: return 352;\\n            default: return 0;                \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        switch(n) {\\n            case 1: return 1;\\n            case 2:\\n            case 3: return 0;\\n            case 4: return 2;\\n            case 5: return 10;\\n            case 6: return 4;\\n            case 7: return 40;\\n            case 8: return 92;\\n            case 9: return 352;\\n            default: return 0;                \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384665,
                "title": "easy-solution-using-bitset",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bitset<30> col, d1, d2;\\n\\n    int solve(int i, int n) {\\n        if (i == n) {\\n            return 1;\\n        }\\n        int cunt = 0;\\n        for (int j = 0; j < n; j++) {\\n            if (!col[j] && !d1[i - j + n - 1] && !d2[i + j]) {\\n                col[j] = d1[i - j + n - 1] = d2[i + j] = 1;\\n                cunt += solve(i + 1, n);\\n                col[j] = d1[i - j + n - 1] = d2[i + j] = 0;  \\n            }\\n        }\\n        return cunt;\\n    }\\n\\n    int totalNQueens(int n) {\\n        int ans = solve(0, n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bitset<30> col, d1, d2;\\n\\n    int solve(int i, int n) {\\n        if (i == n) {\\n            return 1;\\n        }\\n        int cunt = 0;\\n        for (int j = 0; j < n; j++) {\\n            if (!col[j] && !d1[i - j + n - 1] && !d2[i + j]) {\\n                col[j] = d1[i - j + n - 1] = d2[i + j] = 1;\\n                cunt += solve(i + 1, n);\\n                col[j] = d1[i - j + n - 1] = d2[i + j] = 0;  \\n            }\\n        }\\n        return cunt;\\n    }\\n\\n    int totalNQueens(int n) {\\n        int ans = solve(0, n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346300,
                "title": "easiest-python-solution-beating-81-66",
                "content": "![image.png](https://assets.leetcode.com/users/images/a11c8897-726f-4336-9fa6-f93d594eed71_1679893956.642597.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def search(queens, dif, sum):\\n            l = len(queens)\\n            if l == n:\\n                self.ans += 1\\n                return None\\n            for q in range(n):\\n                if q not in queens and l-q not in dif and l+q not in sum:\\n                    search(queens+[q], dif+[l-q], sum+[l+q])\\n        \\n        self.ans = 0\\n        search([],[],[])\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def search(queens, dif, sum):\\n            l = len(queens)\\n            if l == n:\\n                self.ans += 1\\n                return None\\n            for q in range(n):\\n                if q not in queens and l-q not in dif and l+q not in sum:\\n                    search(queens+[q], dif+[l-q], sum+[l+q])\\n        \\n        self.ans = 0\\n        search([],[],[])\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309809,
                "title": "space-o-n-easy-understand-short-sweet-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(int i,int j,int n,vector<bool> &r,vector<bool> &c,vector<bool> &lr,vector<bool> &rl){\\n        if(r[i]||c[j]||lr[i-j+n]||rl[i+j]){\\n            return false;\\n        }\\n        return true;\\n    }\\n    void solve(int i,int n,vector<bool> &r,vector<bool> &c,vector<bool> &lr,vector<bool> &rl,vector<vector<string>> &ans,vector<string> &tmp){\\n        if(i==n){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        for(int j = 0; j < n; j++){\\n            if(check(i,j,n,r,c,lr,rl)){\\n                string str(n,\\'.\\');\\n                str[j] = \\'Q\\';\\n                tmp.push_back(str);\\n                r[i] = true;\\n                c[j] = true;\\n                rl[i+j] = true;\\n                lr[i-j+n] = true;\\n                solve(i+1,n,r,c,lr,rl,ans,tmp);\\n                r[i] = false;\\n                c[j] = false;\\n                rl[i+j] = false;\\n                lr[i-j+n] = false;\\n                tmp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<bool> r(n,false);\\n        vector<bool> c(n,false);\\n        vector<bool> lr(2*n,false);\\n        vector<bool> rl(2*n,false);\\n        vector<vector<string>> ans;\\n        vector<string> v;\\n        solve(0,n,r,c,lr,rl,ans,v);\\n        return ans;\\n    }\\n    int totalNQueens(int n) {\\n        return solveNQueens(n).size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int i,int j,int n,vector<bool> &r,vector<bool> &c,vector<bool> &lr,vector<bool> &rl){\\n        if(r[i]||c[j]||lr[i-j+n]||rl[i+j]){\\n            return false;\\n        }\\n        return true;\\n    }\\n    void solve(int i,int n,vector<bool> &r,vector<bool> &c,vector<bool> &lr,vector<bool> &rl,vector<vector<string>> &ans,vector<string> &tmp){\\n        if(i==n){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        for(int j = 0; j < n; j++){\\n            if(check(i,j,n,r,c,lr,rl)){\\n                string str(n,\\'.\\');\\n                str[j] = \\'Q\\';\\n                tmp.push_back(str);\\n                r[i] = true;\\n                c[j] = true;\\n                rl[i+j] = true;\\n                lr[i-j+n] = true;\\n                solve(i+1,n,r,c,lr,rl,ans,tmp);\\n                r[i] = false;\\n                c[j] = false;\\n                rl[i+j] = false;\\n                lr[i-j+n] = false;\\n                tmp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<bool> r(n,false);\\n        vector<bool> c(n,false);\\n        vector<bool> lr(2*n,false);\\n        vector<bool> rl(2*n,false);\\n        vector<vector<string>> ans;\\n        vector<string> v;\\n        solve(0,n,r,c,lr,rl,ans,v);\\n        return ans;\\n    }\\n    int totalNQueens(int n) {\\n        return solveNQueens(n).size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283759,
                "title": "cpp-backtracking-o-1-diagnol-check-beats-100",
                "content": "The N-Queen problem is one of the classic Backtracking problem out there.\\n\\nSince we have N queens, we place a queen in **each row of the board** and then move to the next row.\\n\\nIn each row, we have a queen placed in a column. To keep a track of the columns used, **We can use an array, where each index denotes a row and queens[i] is the coloumn used**.\\n\\nFor no queen to attack each other : \\n- No 2 queens should we on the same row\\n*Since we are placing one queen in each row this doesn\\'t require a check*\\n\\n- No 2 queens should be on the same column\\n*We can check this simply by queens array if any previous element of the array has the same value as our current candidate column for placing the queen.*\\n\\n- No 2 queens must be present on the same diagnol\\n*A diagnol on a chesboard is either 45 degrees or 135 degrees, i.e the sloped is 1 or -1. We can also say the slope is abs(1)*\\n**Calculating slope:** \\n**abs(previous_col - curr_col) / abs(previous_row - curr_row)**\\n*Thus a O(1) check*\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    bool check(int row, int col, vector<int> &queens, int &n){\\n        for(int i = 0; i < row; i++){\\n            int prev_row = i;\\n            int prev_col = queens[i];\\n\\n            if(prev_col == col || abs(row-prev_row) == abs(col - prev_col)){\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n\\n    int solve(int level, int &n, vector<int> &queens){\\n\\n        if(level == n){\\n            return 1;\\n        }\\n       int ans = 0;\\n        for(int col = 0; col < n; col++){\\n            if(check(level, col, queens, n)){\\n                queens[level] = col;\\n                ans += solve(level + 1, n, queens);\\n                queens[level] = -1;\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n\\n    int totalNQueens(int n) {\\n        vector<int> queens(n,-1);\\n        int res = solve(0, n, queens);\\n\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    bool check(int row, int col, vector<int> &queens, int &n){\\n        for(int i = 0; i < row; i++){\\n            int prev_row = i;\\n            int prev_col = queens[i];\\n\\n            if(prev_col == col || abs(row-prev_row) == abs(col - prev_col)){\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n\\n    int solve(int level, int &n, vector<int> &queens){\\n\\n        if(level == n){\\n            return 1;\\n        }\\n       int ans = 0;\\n        for(int col = 0; col < n; col++){\\n            if(check(level, col, queens, n)){\\n                queens[level] = col;\\n                ans += solve(level + 1, n, queens);\\n                queens[level] = -1;\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n\\n    int totalNQueens(int n) {\\n        vector<int> queens(n,-1);\\n        int res = solve(0, n, queens);\\n\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207915,
                "title": "python-fast-backtracking-horizontal-symmetry-97-39",
                "content": "# Intuition\\nTry to check all possible combinations with backtracking.\\nE.g.\\nFind a row where you can put a queen in the first column. \\nFind a row where you can put a queen in the second column.\\n...\\nIf it\\'s not last column, but you can\\'t put queen. Then go back to the previous column and find the next row where you can put queen.\\n... \\nIf it\\'s a last column and you found a row where you can put queen - you have plus one possible solution.\\n\\n# Approach\\n\\nNaive aproach would be to store state of a board in an array of arrays, where `False` empty cell and `True` is a cell with a queen. However, in this case you would need to check all placed queens, to verify position of the next queen.\\n\\nIt easier and more effective to store ocupied rows and diagonals separatly. Columns are not stored as backtracking goes from 1st to n-th one by one.\\n\\nThe easiest logical optimization would be to find solutions with a queen in the first column and first half or rows. For the second half of rows solutions are horizontaly symetric. And don\\'t forget about midde row. It would make any solution almost 2 times faster.\\nYou can go further and think of vertical symetry, and rotation symetry.\\n\\n# Code\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        rows = [0 for _ in range(n)]\\n        ldiags = [0 for _ in range(2 * n + 1)]\\n        rdiags = [0 for _ in range(2 * n + 1)]\\n        total = 0\\n\\n        def backtrack(i, j_range=None):\\n            nonlocal rows\\n            nonlocal ldiags\\n            nonlocal rdiags\\n            nonlocal total\\n\\n            for j in range(*j_range) if j_range else range(n):\\n                if not (\\n                    rows[j] or rdiags[(r := i + j)] or ldiags[(l := i - j + n - 1)]\\n                ):\\n                    if i + 1 == n:\\n                        total += 1\\n                    else:\\n                        rows[j] = 1\\n                        ldiags[l] = 1\\n                        rdiags[r] = 1\\n                        backtrack(i + 1)\\n                        rows[j] = 0\\n                        ldiags[l] = 0\\n                        rdiags[r] = 0\\n\\n        backtrack(0, (0, n // 2))\\n        total *= 2\\n        if n % 2:\\n            backtrack(0, (n // 2, n // 2 + 1))\\n\\n        return total\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        rows = [0 for _ in range(n)]\\n        ldiags = [0 for _ in range(2 * n + 1)]\\n        rdiags = [0 for _ in range(2 * n + 1)]\\n        total = 0\\n\\n        def backtrack(i, j_range=None):\\n            nonlocal rows\\n            nonlocal ldiags\\n            nonlocal rdiags\\n            nonlocal total\\n\\n            for j in range(*j_range) if j_range else range(n):\\n                if not (\\n                    rows[j] or rdiags[(r := i + j)] or ldiags[(l := i - j + n - 1)]\\n                ):\\n                    if i + 1 == n:\\n                        total += 1\\n                    else:\\n                        rows[j] = 1\\n                        ldiags[l] = 1\\n                        rdiags[r] = 1\\n                        backtrack(i + 1)\\n                        rows[j] = 0\\n                        ldiags[l] = 0\\n                        rdiags[r] = 0\\n\\n        backtrack(0, (0, n // 2))\\n        total *= 2\\n        if n % 2:\\n            backtrack(0, (n // 2, n // 2 + 1))\\n\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3199663,
                "title": "python-recursive-backtracking-just-print-the-length",
                "content": "# Code\\n```\\nclass Solution:\\n    def IsSafe(self,row,column,n,board):\\n        for i in range(column):\\n            if board[row][i] == \"Q\":\\n                return False\\n        i,j = row,column\\n        while(i>=0 and j>=0):\\n            if(board[i][j] == \"Q\"):\\n                return False\\n            i -= 1\\n            j -= 1\\n        i,j = row,column\\n        while(i<n and j>=0):\\n            if(board[i][j] == \"Q\"):\\n                return False\\n            i += 1\\n            j -= 1\\n        return True\\n    def solveQueens(self,column,n,board,result):\\n        if column == n:\\n            result.append([\"\".join(i) for i in board])\\n            return\\n        for row in range(n):\\n            if(self.IsSafe(row,column,n,board)):\\n                board[row][column] = \"Q\"\\n                self.solveQueens(column+1,n,board,result)\\n                board[row][column] = \".\"\\n        return\\n    def totalNQueens(self, n: int) -> int:\\n        board = [[\".\" for i in range(n)] for i in range(n)]\\n        result = []\\n        self.solveQueens(0,n,board,result)\\n        return len(result)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def IsSafe(self,row,column,n,board):\\n        for i in range(column):\\n            if board[row][i] == \"Q\":\\n                return False\\n        i,j = row,column\\n        while(i>=0 and j>=0):\\n            if(board[i][j] == \"Q\"):\\n                return False\\n            i -= 1\\n            j -= 1\\n        i,j = row,column\\n        while(i<n and j>=0):\\n            if(board[i][j] == \"Q\"):\\n                return False\\n            i += 1\\n            j -= 1\\n        return True\\n    def solveQueens(self,column,n,board,result):\\n        if column == n:\\n            result.append([\"\".join(i) for i in board])\\n            return\\n        for row in range(n):\\n            if(self.IsSafe(row,column,n,board)):\\n                board[row][column] = \"Q\"\\n                self.solveQueens(column+1,n,board,result)\\n                board[row][column] = \".\"\\n        return\\n    def totalNQueens(self, n: int) -> int:\\n        board = [[\".\" for i in range(n)] for i in range(n)]\\n        result = []\\n        self.solveQueens(0,n,board,result)\\n        return len(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176316,
                "title": "52-n-queens-ii-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- In this solution, we use depth first search (dfs) to find all solutions to the N-Queens problem\\n- The queens list keeps track of the row number for each column, where queens[i] represents the row number for the ith column.\\n- The dif list keeps track of the difference between the row number and the column number, where dif[i] = p - q and p is the row number and q is the column number.\\n- The sum list keeps track of the sum of the row number and the column number, where sum[i] = p + q and p is the row number and q is the column number.\\n- For each iteration, we check if the column q has not been used in the current solution and if the diagonal represented by dif[i] and the diagonal represented by sum[i] have not been used. If both conditions are met, we add q to the current solution and continue the search.\\n- If the length of the queens list is equal to n, it means we have found a solution and we increment the result by 1.\\n- Finally, we return the result which represents the number of solutions to the N-Queens problem.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def dfs(queens, dif, sum):\\n            p = len(queens)\\n            if p == n:\\n                self.result += 1\\n                return None\\n            for q in range(n):\\n                if q not in queens and p-q not in dif and p+q not in sum:\\n                    dfs(queens+[q], dif+[p-q], sum+[p+q])\\n        \\n        self.result = 0\\n        dfs([],[],[])\\n        return self.result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def dfs(queens, dif, sum):\\n            p = len(queens)\\n            if p == n:\\n                self.result += 1\\n                return None\\n            for q in range(n):\\n                if q not in queens and p-q not in dif and p+q not in sum:\\n                    dfs(queens+[q], dif+[p-q], sum+[p+q])\\n        \\n        self.result = 0\\n        dfs([],[],[])\\n        return self.result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158572,
                "title": "backtracking-and-bitmasking-better-than-backtracking-c",
                "content": "# Backtracking O(N! * N)\\n```\\nclass Solution {\\npublic:\\nint ans;\\nbool is_valid(vector<string> &board, int row, int col){\\n        for(int i=row;i>=0;--i)\\n            if(board[i][col] == \\'Q\\') return false;\\n        for(int i=row,j=col;i>=0&&j>=0;--i,--j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        for(int i=row,j=col;i>=0&&j<board.size();--i,++j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        return true;\\n    }\\n    void dfs(vector<string> &board, int row){\\n        if(row == board.size()){\\n            ans++;\\n            return;\\n        }\\n        for(int i=0;i<board.size();++i){\\n            if(is_valid(board,row,i)){\\n                board[row][i] = \\'Q\\';\\n                dfs(board,row+1);\\n                board[row][i] = \\'.\\';\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        if(n <= 0) return 0;\\n        ans=0;\\n        vector<string> board(n,string(n,\\'.\\'));\\n        dfs(board,0);\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n# Bitmasking O(N!)\\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        int res = 0;\\n        vector<int> col(n, 0), dg(2 * n, 0), udg(2 * n, 0);\\n        // Start the backtracking function from the first row\\n        solveNQueens(res, col, dg, udg, 0, n);\\n        return res;\\n    }\\n    void solveNQueens(int& res, vector<int>& col, vector<int>& dg,\\n                      vector<int>& udg, int row, int& n) {\\n        // If we have reached the last row, it means a valid solution is found\\n        if (row == n) {\\n            ++res; // Increment the number of solutions\\n            return;\\n        }\\n        for (int c = 0; c < n; ++c) {\\n            // Check if the current column, current diagonal (row + column) \\n            // and current anti-diagonal (n + row - column) are all empty\\n            if (!col[c] && !dg[row + c] && !udg[n + row - c]) {\\n                col[c] = dg[row + c] = udg[n + row - c] = 1;\\n                // Move to the next row and repeat the process\\n                solveNQueens(res, col, dg, udg, row + 1, n);\\n                col[c] = dg[row + c] = udg[n + row - c] = 0;\\n                // Backtrack to try other columns in the current row\\n            }\\n        }\\n    }\\n};\\n\\n```\\n\\nThe algorithm works as follows:\\n\\nIf row is equal to n, it means all n rows have been filled, and a possible solution has been found, so res is incremented.\\n\\nFor each column c from 0 to n-1:\\n\\nIf the column, diagonal, and anti-diagonal corresponding to the current row and column are not occupied (represented by the values in col, dg, and udg being 0), the current position is marked as occupied and the algorithm continues to the next row by calling solveNQueens recursively.\\n\\nAfter the recursive call returns, the current position is marked as unoccupied to backtrack to previous positions.\\n\\nThis algorithm has a time complexity of O(n!).\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint ans;\\nbool is_valid(vector<string> &board, int row, int col){\\n        for(int i=row;i>=0;--i)\\n            if(board[i][col] == \\'Q\\') return false;\\n        for(int i=row,j=col;i>=0&&j>=0;--i,--j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        for(int i=row,j=col;i>=0&&j<board.size();--i,++j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        return true;\\n    }\\n    void dfs(vector<string> &board, int row){\\n        if(row == board.size()){\\n            ans++;\\n            return;\\n        }\\n        for(int i=0;i<board.size();++i){\\n            if(is_valid(board,row,i)){\\n                board[row][i] = \\'Q\\';\\n                dfs(board,row+1);\\n                board[row][i] = \\'.\\';\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        if(n <= 0) return 0;\\n        ans=0;\\n        vector<string> board(n,string(n,\\'.\\'));\\n        dfs(board,0);\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        int res = 0;\\n        vector<int> col(n, 0), dg(2 * n, 0), udg(2 * n, 0);\\n        // Start the backtracking function from the first row\\n        solveNQueens(res, col, dg, udg, 0, n);\\n        return res;\\n    }\\n    void solveNQueens(int& res, vector<int>& col, vector<int>& dg,\\n                      vector<int>& udg, int row, int& n) {\\n        // If we have reached the last row, it means a valid solution is found\\n        if (row == n) {\\n            ++res; // Increment the number of solutions\\n            return;\\n        }\\n        for (int c = 0; c < n; ++c) {\\n            // Check if the current column, current diagonal (row + column) \\n            // and current anti-diagonal (n + row - column) are all empty\\n            if (!col[c] && !dg[row + c] && !udg[n + row - c]) {\\n                col[c] = dg[row + c] = udg[n + row - c] = 1;\\n                // Move to the next row and repeat the process\\n                solveNQueens(res, col, dg, udg, row + 1, n);\\n                col[c] = dg[row + c] = udg[n + row - c] = 0;\\n                // Backtrack to try other columns in the current row\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131987,
                "title": "0ms-100-faster-code-in-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool isSafe(vector<string> &board, int row, int col, vector<int> &lowerDiagonal, vector<int> &upperDiagonal, vector<int>&leftSideRow, int n) {\\n        if(upperDiagonal[n-1+col-row]!=1 && leftSideRow[row]!=1 && lowerDiagonal[row+col]!=1) return true;\\n        return false;\\n    }\\n\\n    void backtrack(int col, vector<string>&board, int&ans, int n, vector<int>&lowerDiagonal, vector<int>&upperDiagonal, vector<int>& leftSideRow) {\\n        if(col==n) {\\n            ans++;\\n            return;\\n        }\\n        for(int i=0; i<n; i++) {\\n            if(isSafe(board, i, col, lowerDiagonal, upperDiagonal, leftSideRow, n)) {\\n                board[i][col] = \\'Q\\';\\n                lowerDiagonal[i+col] = 1;\\n                upperDiagonal[n-1+col-i] = 1;\\n                leftSideRow[i] = 1;\\n                backtrack(col+1, board, ans, n, lowerDiagonal, upperDiagonal, leftSideRow);\\n                board[i][col] = \\'.\\';\\n                lowerDiagonal[i+col] = 0;\\n                upperDiagonal[n-1+col-i] = 0;\\n                leftSideRow[i] = 0;\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        int ans = 0;\\n        vector<string> board(n);\\n        vector<int> lowerDiagonal(2*n-1, 0);\\n        vector<int> upperDiagonal(2*n-1,0);\\n        vector<int> leftSideRow(n,0);\\n        string s(n, \\'.\\');\\n        for(int i=0; i<n; i++) {\\n            board[i] = s;\\n        }\\n        backtrack(0, board, ans, n, lowerDiagonal, upperDiagonal, leftSideRow);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool isSafe(vector<string> &board, int row, int col, vector<int> &lowerDiagonal, vector<int> &upperDiagonal, vector<int>&leftSideRow, int n) {\\n        if(upperDiagonal[n-1+col-row]!=1 && leftSideRow[row]!=1 && lowerDiagonal[row+col]!=1) return true;\\n        return false;\\n    }\\n\\n    void backtrack(int col, vector<string>&board, int&ans, int n, vector<int>&lowerDiagonal, vector<int>&upperDiagonal, vector<int>& leftSideRow) {\\n        if(col==n) {\\n            ans++;\\n            return;\\n        }\\n        for(int i=0; i<n; i++) {\\n            if(isSafe(board, i, col, lowerDiagonal, upperDiagonal, leftSideRow, n)) {\\n                board[i][col] = \\'Q\\';\\n                lowerDiagonal[i+col] = 1;\\n                upperDiagonal[n-1+col-i] = 1;\\n                leftSideRow[i] = 1;\\n                backtrack(col+1, board, ans, n, lowerDiagonal, upperDiagonal, leftSideRow);\\n                board[i][col] = \\'.\\';\\n                lowerDiagonal[i+col] = 0;\\n                upperDiagonal[n-1+col-i] = 0;\\n                leftSideRow[i] = 0;\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        int ans = 0;\\n        vector<string> board(n);\\n        vector<int> lowerDiagonal(2*n-1, 0);\\n        vector<int> upperDiagonal(2*n-1,0);\\n        vector<int> leftSideRow(n,0);\\n        string s(n, \\'.\\');\\n        for(int i=0; i<n; i++) {\\n            board[i] = s;\\n        }\\n        backtrack(0, board, ans, n, lowerDiagonal, upperDiagonal, leftSideRow);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085407,
                "title": "100-fastest-solution-using-the-back-tracking-and-recursion",
                "content": "# Intuition\\nTake a intution that the queen attacks only when either they are present in the same row,col or diagonally.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe try to make diagonal rl and lr and  lrow which ensures that the queen must be placed in different diagonal; and row respectively.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint c=0;\\n    void rec( vector<string>&board, vector<int>&lrow, vector<int>&lr, vector<int>&rl,int col,int n){\\n         if(col==n){\\n             c++;\\n              return;\\n         }\\n         for(int row=0;row<n;row++)\\n       {  \\n           if(lrow[row]==0 && lr[row+col]==0 && rl[n-1+col-row]==0){\\n             board[row][col]=\\'Q\\';\\n             lrow[row]=1;\\n             lr[row+col]=1;\\n             rl[n-1+col-row]=1;\\n            rec(board,lrow,lr,rl,col+1,n);\\n              board[row][col]=\\'.\\';\\n             lrow[row]=0;\\n             lr[row+col]=0;\\n             rl[n-1+col-row]=0;\\n          }\\n       }\\n    }\\n    int totalNQueens(int n) {\\n          vector<int>lrow(n,0),lr(2*n-1,0),rl(2*n-1,0);\\n       string s(n,\\'.\\');\\n       vector<string>board;\\n       for(int i=0;i<n;i++){\\n           board.push_back(s);\\n       }\\n        rec(board,lrow,lr,rl,0,n);\\n        return c;\\n    }\\n};\\n```\\nPls \\uD83D\\uDE4F\\uD83D\\uDE4FUpvote if u find this helpful",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint c=0;\\n    void rec( vector<string>&board, vector<int>&lrow, vector<int>&lr, vector<int>&rl,int col,int n){\\n         if(col==n){\\n             c++;\\n              return;\\n         }\\n         for(int row=0;row<n;row++)\\n       {  \\n           if(lrow[row]==0 && lr[row+col]==0 && rl[n-1+col-row]==0){\\n             board[row][col]=\\'Q\\';\\n             lrow[row]=1;\\n             lr[row+col]=1;\\n             rl[n-1+col-row]=1;\\n            rec(board,lrow,lr,rl,col+1,n);\\n              board[row][col]=\\'.\\';\\n             lrow[row]=0;\\n             lr[row+col]=0;\\n             rl[n-1+col-row]=0;\\n          }\\n       }\\n    }\\n    int totalNQueens(int n) {\\n          vector<int>lrow(n,0),lr(2*n-1,0),rl(2*n-1,0);\\n       string s(n,\\'.\\');\\n       vector<string>board;\\n       for(int i=0;i<n;i++){\\n           board.push_back(s);\\n       }\\n        rec(board,lrow,lr,rl,0,n);\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049726,
                "title": "begineer-friendly-code-to-understand-backtracking-easy-to-understand-python",
                "content": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        board = [[\\'\\' for i in range(n)] for j in range(n)]\\n        self.queens = n\\n        # self.placed = 0\\n        self.ans = 0\\n        # self.queen_pos = []\\n        self.place(0,board)\\n        return self.ans\\n    \\n    def place(self,i,board,queens=None,placed=0):\\n        if placed == self.queens:\\n            self.ans += 1\\n            return\\n        if i>= self.queens:\\n            return\\n        if not queens:\\n            queens = []\\n        for j in range(self.queens):\\n            if not self.intersect(queens+[[i,j]],placed,board):\\n                board[i][j] = \\'Q\\'\\n                self.place(i+1,board,queens+[[i,j]],placed+1)\\n                board[i][j] = \\'\\'\\n    \\n    def intersect(self,queens,placed,board):\\n        if placed < 1:\\n            return False\\n        for queen in queens:\\n            q_x,q_y = queen[0],queen[1]\\n            for i in range(self.queens):\\n                if board[i][q_y] == \\'Q\\' and i!=q_x:\\n                    return True\\n                if board[q_x][i] == \\'Q\\' and i!=q_y:\\n                    return True\\n                \\n            # right down diagonal check\\n            while q_x+1<self.queens and q_y+1<self.queens:\\n                q_x,q_y = q_x+1,q_y+1\\n                if board[q_x][q_y] == \\'Q\\':\\n                    return True\\n                \\n            # left down diagonal check\\n            q_x,q_y = queen[0],queen[1]\\n            while q_x-1>=0 and q_y+1<self.queens:\\n                q_x,q_y = q_x-1,q_y+1\\n                if board[q_x][q_y] == \\'Q\\':\\n                    return True\\n                \\n            # right up diagonal check\\n            q_x,q_y = queen[0],queen[1]\\n            while q_x+1<self.queens and q_y-1>=0:\\n                q_x,q_y = q_x+1,q_y-1\\n                if board[q_x][q_y] == \\'Q\\':\\n                    return True\\n                \\n            # left up diagonal check\\n            q_x,q_y = queen[0],queen[1]\\n            while q_x-1>=0 and q_y-1>=0:\\n                q_x,q_y = q_x-1,q_y-1\\n                if board[q_x][q_y] == \\'Q\\':\\n                    return True\\n        return False\\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        board = [[\\'\\' for i in range(n)] for j in range(n)]\\n        self.queens = n\\n        # self.placed = 0\\n        self.ans = 0\\n        # self.queen_pos = []\\n        self.place(0,board)\\n        return self.ans\\n    \\n    def place(self,i,board,queens=None,placed=0):\\n        if placed == self.queens:\\n            self.ans += 1\\n            return\\n        if i>= self.queens:\\n            return\\n        if not queens:\\n            queens = []\\n        for j in range(self.queens):\\n            if not self.intersect(queens+[[i,j]],placed,board):\\n                board[i][j] = \\'Q\\'\\n                self.place(i+1,board,queens+[[i,j]],placed+1)\\n                board[i][j] = \\'\\'\\n    \\n    def intersect(self,queens,placed,board):\\n        if placed < 1:\\n            return False\\n        for queen in queens:\\n            q_x,q_y = queen[0],queen[1]\\n            for i in range(self.queens):\\n                if board[i][q_y] == \\'Q\\' and i!=q_x:\\n                    return True\\n                if board[q_x][i] == \\'Q\\' and i!=q_y:\\n                    return True\\n                \\n            # right down diagonal check\\n            while q_x+1<self.queens and q_y+1<self.queens:\\n                q_x,q_y = q_x+1,q_y+1\\n                if board[q_x][q_y] == \\'Q\\':\\n                    return True\\n                \\n            # left down diagonal check\\n            q_x,q_y = queen[0],queen[1]\\n            while q_x-1>=0 and q_y+1<self.queens:\\n                q_x,q_y = q_x-1,q_y+1\\n                if board[q_x][q_y] == \\'Q\\':\\n                    return True\\n                \\n            # right up diagonal check\\n            q_x,q_y = queen[0],queen[1]\\n            while q_x+1<self.queens and q_y-1>=0:\\n                q_x,q_y = q_x+1,q_y-1\\n                if board[q_x][q_y] == \\'Q\\':\\n                    return True\\n                \\n            # left up diagonal check\\n            q_x,q_y = queen[0],queen[1]\\n            while q_x-1>=0 and q_y-1>=0:\\n                q_x,q_y = q_x-1,q_y-1\\n                if board[q_x][q_y] == \\'Q\\':\\n                    return True\\n        return False\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010025,
                "title": "n-queens-ii-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSafe(int row , int col , vector<vector<int>> &board , int n){\\n    //check for same row\\n    int x = row;\\n    int y = col;\\n    \\n    while(y >= 0){\\n        if(board[x][y] == 1)\\n            return false;\\n        y--;\\n    }\\n    \\n    //no need to check for columns as we are adding one queen in one column\\n    \\n    //check for diagonals\\n    //check for North West(NW) diagonal\\n    x = row;\\n    y = col;\\n    \\n    while(x>=0 && y >= 0){\\n        if(board[x][y] == 1)\\n            return false;\\n        y--;\\n        x--;\\n    }\\n    \\n    //check for SW diagonal\\n    x = row;\\n    y = col;\\n    \\n    while(x<n && y >= 0){\\n        if(board[x][y] == 1)\\n            return false;\\n        y--;\\n        x++;\\n    }\\n    //no need to check for NE and SE diagonals as queen hasn\\'t been added to the right.\\n    return true;\\n}\\n\\n    void solve(int col , vector<vector<int>> &ans , vector<vector<int>> &board , int n , int &count){\\n    //base case\\n    if(col == n){\\n        count++;\\n        return ;\\n    }\\n    \\n    //solve for 1 column, rest recursion will take care\\n    for(int row = 0 ; row < n ; row++){\\n        if(isSafe(row,col,board,n)){\\n            board[row][col] = 1;\\n            solve(col+1 , ans , board , n , count);\\n            //backtrack\\n            board[row][col] = 0;\\n        }\\n    }\\n}\\n\\n    int totalNQueens(int n) {\\n        vector<vector<int>> board(n , vector<int>(n,0));\\n        vector<vector<int>> ans;\\n        int count = 0;\\n        \\n        solve(0 , ans , board , n , count);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSafe(int row , int col , vector<vector<int>> &board , int n){\\n    //check for same row\\n    int x = row;\\n    int y = col;\\n    \\n    while(y >= 0){\\n        if(board[x][y] == 1)\\n            return false;\\n        y--;\\n    }\\n    \\n    //no need to check for columns as we are adding one queen in one column\\n    \\n    //check for diagonals\\n    //check for North West(NW) diagonal\\n    x = row;\\n    y = col;\\n    \\n    while(x>=0 && y >= 0){\\n        if(board[x][y] == 1)\\n            return false;\\n        y--;\\n        x--;\\n    }\\n    \\n    //check for SW diagonal\\n    x = row;\\n    y = col;\\n    \\n    while(x<n && y >= 0){\\n        if(board[x][y] == 1)\\n            return false;\\n        y--;\\n        x++;\\n    }\\n    //no need to check for NE and SE diagonals as queen hasn\\'t been added to the right.\\n    return true;\\n}\\n\\n    void solve(int col , vector<vector<int>> &ans , vector<vector<int>> &board , int n , int &count){\\n    //base case\\n    if(col == n){\\n        count++;\\n        return ;\\n    }\\n    \\n    //solve for 1 column, rest recursion will take care\\n    for(int row = 0 ; row < n ; row++){\\n        if(isSafe(row,col,board,n)){\\n            board[row][col] = 1;\\n            solve(col+1 , ans , board , n , count);\\n            //backtrack\\n            board[row][col] = 0;\\n        }\\n    }\\n}\\n\\n    int totalNQueens(int n) {\\n        vector<vector<int>> board(n , vector<int>(n,0));\\n        vector<vector<int>> ans;\\n        int count = 0;\\n        \\n        solve(0 , ans , board , n , count);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565873,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1569403,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1567140,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1565828,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1997219,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1571127,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1571126,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1983949,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1792088,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1576678,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1565873,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1569403,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1567140,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1565828,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1997219,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1571127,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1571126,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1983949,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1792088,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1576678,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 2064843,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 2029585,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 2016375,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 2000586,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 1991597,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 1981878,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 1883948,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 1841509,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 1823866,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 1808779,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Product Subarray",
        "question_content": "<p>Given an integer array <code>nums</code>, find a <span data-keyword=\"subarray-nonempty\">subarray</span> that has the largest product, and return <em>the product</em>.</p>\n\n<p>The test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,-2,4]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> [2,3] has the largest product 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-2,0,-1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The result cannot be 2, because [-2,-1] is not a subarray.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n\t<li>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 48230,
                "title": "possibly-simplest-solution-with-o-n-time-complexity",
                "content": "```\\nint maxProduct(int A[], int n) {\\n    // store the result that is the max we have found so far\\n    int r = A[0];\\n\\n    // imax/imin stores the max/min product of\\n    // subarray that ends with the current number A[i]\\n    for (int i = 1, imax = r, imin = r; i < n; i++) {\\n        // multiplied by a negative makes big number smaller, small number bigger\\n        // so we redefine the extremums by swapping them\\n        if (A[i] < 0)\\n            swap(imax, imin);\\n\\n        // max/min product for the current number is either the current number itself\\n        // or the max/min by the previous number times the current one\\n        imax = max(A[i], imax * A[i]);\\n        imin = min(A[i], imin * A[i]);\\n\\n        // the newly computed max value is a candidate for our global result\\n        r = max(r, imax);\\n    }\\n    return r;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maxProduct(int A[], int n) {\\n    // store the result that is the max we have found so far\\n    int r = A[0];\\n\\n    // imax/imin stores the max/min product of\\n    // subarray that ends with the current number A[i]\\n    for (int i = 1, imax = r, imin = r; i < n; i++) {\\n        // multiplied by a negative makes big number smaller, small number bigger\\n        // so we redefine the extremums by swapping them\\n        if (A[i] < 0)\\n            swap(imax, imin);\\n\\n        // max/min product for the current number is either the current number itself\\n        // or the max/min by the previous number times the current one\\n        imax = max(A[i], imax * A[i]);\\n        imin = min(A[i], imin * A[i]);\\n\\n        // the newly computed max value is a candidate for our global result\\n        r = max(r, imax);\\n    }\\n    return r;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 183483,
                "title": "java-c-python-it-can-be-more-simple",
                "content": "# **Intuition**\\nSeem to be a problem of 2014.\\nIs it too late to write one in 2018?\\n<br>\\n\\n# **Explanation**\\nCalculate prefix product in `A`.\\nCalculate suffix product in `A`.\\nReturn the max.\\n<br>\\n\\n**Python**\\n```python\\n    def maxProduct(self, A):\\n        B = A[::-1]\\n        for i in range(1, len(A)):\\n            A[i] *= A[i - 1] or 1\\n            B[i] *= B[i - 1] or 1\\n        return max(A + B)\\n```\\n\\n**Also wrote in C++ version**\\nO(N) time O(1) space\\n```cpp\\n    int maxProduct(vector<int> A) {\\n        int n = A.size(), res = A[0], l = 0, r = 0;\\n        for (int i = 0; i < n; i++) {\\n            l =  (l ? l : 1) * A[i];\\n            r =  (r ? r : 1) * A[n - 1 - i];\\n            res = max(res, max(l, r));\\n        }\\n        return res;\\n    }\\n```\\n\\n**Also wrote in Java version**\\nO(N) time O(1) space\\n```java\\n    public int maxProduct(int[] A) {\\n        int n = A.length, res = A[0], l = 0, r = 0;\\n        for (int i = 0; i < n; i++) {\\n            l =  (l == 0 ? 1 : l) * A[i];\\n            r =  (r == 0 ? 1 : r) * A[n - 1 - i];\\n            res = Math.max(res, Math.max(l, r));\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```python\\n    def maxProduct(self, A):\\n        B = A[::-1]\\n        for i in range(1, len(A)):\\n            A[i] *= A[i - 1] or 1\\n            B[i] *= B[i - 1] or 1\\n        return max(A + B)\\n```\n```cpp\\n    int maxProduct(vector<int> A) {\\n        int n = A.size(), res = A[0], l = 0, r = 0;\\n        for (int i = 0; i < n; i++) {\\n            l =  (l ? l : 1) * A[i];\\n            r =  (r ? r : 1) * A[n - 1 - i];\\n            res = max(res, max(l, r));\\n        }\\n        return res;\\n    }\\n```\n```java\\n    public int maxProduct(int[] A) {\\n        int n = A.length, res = A[0], l = 0, r = 0;\\n        for (int i = 0; i < n; i++) {\\n            l =  (l == 0 ? 1 : l) * A[i];\\n            r =  (r == 0 ? 1 : r) * A[n - 1 - i];\\n            res = Math.max(res, Math.max(l, r));\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1608862,
                "title": "java-3-solutions-detailed-explanation-using-image",
                "content": "**Intution:** Since we have to find the contiguous subarray having maximum product then your approach should be combination of following three cases :\\n* **Case1 :- All the elements are positive :** Then your answer will be product of all the elements in the array.\\n* **Case2 :- Array have positive and negative elements both :**\\n\\t1. \\tIf the number of negative elements is even then again your answer will be complete array because on multiplying all the negative numbers it will become positive.\\n\\t2. \\tIf the number of negative elements is odd then you have to remove just one negative element and for that u need to check your subarrays to get the max product.\\n* **Case3 :- Array also contains 0 :** Then there will be not much difference...its just that your array will be divided into subarray around that 0. What u have to so is just as soon as your product becomes 0 make it 1 for the next iteration, now u will be searching new subarray and previous max will already be updated.\\n*(These cases are much clear in approach 3)\\n\\n\\n** As it is said \"Talk is Cheap, Show me the Code\", so based on above discussion we can frame our code in many different ways, out of which I have mentioned 3 intutive approaches.\\n\\n**Approach 1:** For each index i keep updating the max and min. We are also keeping min because on multiplying with any negative number your min will become max and max will become min. So for every index i  we will take max of (i-th element, prevMax * i-th element, prevMin * i-th element).\\n\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        \\n        int max = nums[0], min = nums[0], ans = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            \\n            int temp = max;  // store the max because before updating min your max will already be updated\\n            \\n            max = Math.max(Math.max(max * nums[i], min * nums[i]), nums[i]);\\n            min = Math.min(Math.min(temp * nums[i], min * nums[i]), nums[i]);\\n            \\n            if (max > ans) {\\n                ans = max;\\n            }\\n        }\\n        \\n        return ans;\\n\\n    }\\n}\\n```\\n\\n**Approach 2:** Just the slight modification of previous approach. As we know that on multiplying with negative number max will become min and min will become max, so why not as soon as we encounter negative element, we swap the max and min already.\\n\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        \\n        int max = nums[0], min = nums[0], ans = nums[0];\\n        int n = nums.length;\\n        \\n        for (int i = 1; i < n; i++) {\\n        \\n\\t\\t\\t// Swapping min and max\\n            if (nums[i] < 0){\\n                int temp = max;\\n                max = min;\\n                min = temp;\\n            }\\n                \\n\\n\\n            max = Math.max(nums[i], max * nums[i]);\\n            min = Math.min(nums[i], min * nums[i]);\\n\\n\\n            ans = Math.max(ans, max);\\n        }\\n        \\n        return ans;\\n\\n    }\\n}\\n```\\n\\n**Approach 3:** Two pointer Approach\\nExplanation : \\n1.) Through intution explanation we know that if all the elements are positive or the negative elements are even then ur answer will be product of complete array which u will get in variable l and r at the last iteration.\\n2.) But if negative elements are odd then u have to remove one negative element and it is sure that it will be either right of max prefix product or left of max suffix product. So u need not to modify anything in your code as u are getting prefix product in l and suffix prduxt in r.\\n3.) If array also contains 0 then your l and r will become 0 at that point...then just update it to 1(or else u will keep multiplying with 0)  to get the product ahead making another subarray.\\n\\n![image](https://assets.leetcode.com/users/images/2ce0da10-9355-4018-a256-cba3a41af56d_1638500369.5001783.jpeg)\\n\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        \\n        int n = nums.length;\\n        int l=1,r=1;\\n        int ans=nums[0];\\n        \\n        for(int i=0;i<n;i++){\\n            \\n\\t\\t\\t//if any of l or r become 0 then update it to 1\\n            l = l==0 ? 1 : l;\\n            r = r==0 ? 1 : r;\\n            \\n            l *= nums[i];   //prefix product\\n            r *= nums[n-1-i];    //suffix product\\n            \\n            ans = Math.max(ans,Math.max(l,r));\\n            \\n        }\\n        \\n        return ans;\\n\\n    }\\n}\\n```\\n\\nThanks for giving it a read...I hope it helped u!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        \\n        int max = nums[0], min = nums[0], ans = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            \\n            int temp = max;  // store the max because before updating min your max will already be updated\\n            \\n            max = Math.max(Math.max(max * nums[i], min * nums[i]), nums[i]);\\n            min = Math.min(Math.min(temp * nums[i], min * nums[i]), nums[i]);\\n            \\n            if (max > ans) {\\n                ans = max;\\n            }\\n        }\\n        \\n        return ans;\\n\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        \\n        int max = nums[0], min = nums[0], ans = nums[0];\\n        int n = nums.length;\\n        \\n        for (int i = 1; i < n; i++) {\\n        \\n\\t\\t\\t// Swapping min and max\\n            if (nums[i] < 0){\\n                int temp = max;\\n                max = min;\\n                min = temp;\\n            }\\n                \\n\\n\\n            max = Math.max(nums[i], max * nums[i]);\\n            min = Math.min(nums[i], min * nums[i]);\\n\\n\\n            ans = Math.max(ans, max);\\n        }\\n        \\n        return ans;\\n\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        \\n        int n = nums.length;\\n        int l=1,r=1;\\n        int ans=nums[0];\\n        \\n        for(int i=0;i<n;i++){\\n            \\n\\t\\t\\t//if any of l or r become 0 then update it to 1\\n            l = l==0 ? 1 : l;\\n            r = r==0 ? 1 : r;\\n            \\n            l *= nums[i];   //prefix product\\n            r *= nums[n-1-i];    //suffix product\\n            \\n            ans = Math.max(ans,Math.max(l,r));\\n            \\n        }\\n        \\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48252,
                "title": "sharing-my-solution-o-1-space-o-n-running-time",
                "content": "    public int maxProduct(int[] A) {\\n        if (A.length == 0) {\\n            return 0;\\n        }\\n        \\n        int maxherepre = A[0];\\n        int minherepre = A[0];\\n        int maxsofar = A[0];\\n        int maxhere, minhere;\\n        \\n        for (int i = 1; i < A.length; i++) {\\n            maxhere = Math.max(Math.max(maxherepre * A[i], minherepre * A[i]), A[i]);\\n            minhere = Math.min(Math.min(maxherepre * A[i], minherepre * A[i]), A[i]);\\n            maxsofar = Math.max(maxhere, maxsofar);\\n            maxherepre = maxhere;\\n            minherepre = minhere;\\n        }\\n        return maxsofar;\\n    }\\n\\n\\n\\nNote:\\nThere's no need to use O(n) space, as all that you need is a minhere and maxhere. (local max and local min), then you can get maxsofar (which is global max) from them.\\n\\nThere's a chapter in Programming Pearls 2 that discussed the MaxSubArray problem, the idea is similar.",
                "solutionTags": [],
                "code": "    public int maxProduct(int[] A) {\\n        if (A.length == 0) {\\n            return 0;\\n        }\\n        \\n        int maxherepre = A[0];\\n        int minherepre = A[0];\\n        int maxsofar = A[0];\\n        int maxhere, minhere;\\n        \\n        for (int i = 1; i < A.length; i++) {\\n            maxhere = Math.max(Math.max(maxherepre * A[i], minherepre * A[i]), A[i]);\\n            minhere = Math.min(Math.min(maxherepre * A[i], minherepre * A[i]), A[i]);\\n            maxsofar = Math.max(maxhere, maxsofar);\\n            maxherepre = maxhere;\\n            minherepre = minhere;\\n        }\\n        return maxsofar;\\n    }\\n\\n\\n\\nNote:\\nThere's no need to use O(n) space, as all that you need is a minhere and maxhere. (local max and local min), then you can get maxsofar (which is global max) from them.\\n\\nThere's a chapter in Programming Pearls 2 that discussed the MaxSubArray problem, the idea is similar.",
                "codeTag": "Unknown"
            },
            {
                "id": 3321410,
                "title": "c-kadane-s-algo-full-explanation",
                "content": "# Intuition\\nThe Brute force method says we can simply apply 2 loops for calculaing all sub-arrays and finding the max product.\\n\\nBut, the Optizimed way to solve this problem is using Kadane\\'s Algorithm.\\n\\n# Approach\\nThe Approach to this question is exactly same as Kadane\\'s Algo the only differece is, we will be traversing the array from both sides i.e left to right ( lets say the max prod is maxi1 ) and from right to left ( say max prod is maxi2 ), now the final answer will we max of maxi1 and maxi2.\\n\\nQues : Why do we have a need to traverse from right to left ??\\nAns : lets take an example \\n    arr {-8,5,3,1,6}\\n\\n    // By traversing left to right we have an answer maxi1.\\n    maxi1 = -720 , which is clearly not the max prod value.\\n\\n**-> The whole concept lies in this statement -** **As we can see that there is only 1 negative no. ( if we consider that no. then the final answer can never be positive ), therefore to avoid this situation we also traverse from right to left to get the final maximum prod.**\\n\\n# Complexity\\n- Time complexity:\\nO(N) + O(N) = O(N), where N is size of array.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int maxi = INT_MIN;\\n        int prod=1;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          prod*=nums[i];\\n          maxi=max(prod,maxi);\\n          if(prod==0)\\n           prod=1;\\n        }\\n        prod=1;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n          prod*=nums[i];\\n\\n          maxi=max(prod,maxi);\\n          if(prod==0)\\n           prod=1;\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpg](https://assets.leetcode.com/users/images/ccc42d19-25d4-4441-9a37-8c5df943c6c9_1679339757.323656.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int maxi = INT_MIN;\\n        int prod=1;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          prod*=nums[i];\\n          maxi=max(prod,maxi);\\n          if(prod==0)\\n           prod=1;\\n        }\\n        prod=1;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n          prod*=nums[i];\\n\\n          maxi=max(prod,maxi);\\n          if(prod==0)\\n           prod=1;\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48302,
                "title": "2-passes-scan-beats-99",
                "content": "Here are my observations:\\n1. it's really about odd negative numbers or even negative numbers, if it's odd, either the left end one or the right end one should be counted, so it will be revealed by scanning from left and from right in 2 passes.\\n2. 0 is a kind of delimiter, product accumulation will be reset to 1\\n\\n\\n    public int maxProduct(int[] nums) {\\n        int max = Integer.MIN_VALUE, product = 1;\\n        int len = nums.length;\\n\\n        for(int i = 0; i < len; i++) {\\n            max = Math.max(product *= nums[i], max);\\n            if (nums[i] == 0) product = 1;\\n        }\\n\\n        product = 1;\\n        for(int i = len - 1; i >= 0; i--) {\\n            max = Math.max(product *= nums[i], max);\\n            if (nums[i] == 0) product = 1;\\n        }\\n\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "Here are my observations:\\n1. it's really about odd negative numbers or even negative numbers, if it's odd, either the left end one or the right end one should be counted, so it will be revealed by scanning from left and from right in 2 passes.\\n2. 0 is a kind of delimiter, product accumulation will be reset to 1\\n\\n\\n    public int maxProduct(int[] nums) {\\n        int max = Integer.MIN_VALUE, product = 1;\\n        int len = nums.length;\\n\\n        for(int i = 0; i < len; i++) {\\n            max = Math.max(product *= nums[i], max);\\n            if (nums[i] == 0) product = 1;\\n        }\\n\\n        product = 1;\\n        for(int i = len - 1; i >= 0; i--) {\\n            max = Math.max(product *= nums[i], max);\\n            if (nums[i] == 0) product = 1;\\n        }\\n\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 48330,
                "title": "simple-java-code",
                "content": "Loop through the array, each time remember the max and min value for the previous product, the most important thing is to update the max and min value: we have to compare among max * A[i], min * A[i] as well as A[i], since this is product, a negative * negative could be positive.\\n\\n    public class Solution {\\n        public int maxProduct(int[] A) {\\n            if (A == null || A.length == 0) {\\n                return 0;\\n            }\\n            int max = A[0], min = A[0], result = A[0];\\n            for (int i = 1; i < A.length; i++) {\\n                int temp = max;\\n                max = Math.max(Math.max(max * A[i], min * A[i]), A[i]);\\n                min = Math.min(Math.min(temp * A[i], min * A[i]), A[i]);\\n                if (max > result) {\\n                    result = max;\\n                }\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int maxProduct(int[] A) {\\n            if (A == null || A.length == 0) {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 203013,
                "title": "c-o-n-time-o-1-space-solution-with-explanation",
                "content": "Before jumping to the full solution, let\\'s take a step back and consider simpler versions of this problem (Please scroll to the bottom of this post for the full solution):\\n\\n* If the array only consisted of positive integers, the solution would be trivial: product of the entire array. We can implement this by calculating a _running_ product like so:\\n```\\nint runningProduct = 1;\\nfor (int n: nums) {\\n    runningProduct *= n;\\n}\\nreturn runningProduct;\\n```\\n\\n* If we add zeroes to the mix, now we have to get a bit smarter. As we loop over the array, if the current number `n` is zero, then `runningProduct` would be zero and be stuck there. So, we need to reset it. Intuitively, whenever `runningProduct` is less than the current number `n`, we start considering a new sub-array that starts from the current number. Since `runningProduct` will be reset, we will also need a variable to hold the max `runningProduct` that we have encountered. Enough said, let\\'s see how we can code this:\\n```\\nint best = INT_MIN;\\nint runningProduct = 1;\\nfor (int n: nums) {\\n    // Pick the larger of current number and the result of the multiplication\\n    // Picking n means we start considering a new sub-array\\n    runningProduct = max(runningProduct * n, n);\\n    // Keep track of the max runningProduct that we find\\n    best = max(runningProduct, best);\\n}\\nreturn best;\\n```\\n\\n* Above, we only cared about the maximum value we can achieve and started a new sub-array using `max` whenever we encountered a zero. Finally, let\\'s also consider negative numbers to find the general solution to the given problem. Consider the array `1, -2, -3, 4`. When we are at the second element, our runningProduct becomes `-2`. But at the third element it becomes `6`. So, as we encounter negative numbers they change the sign of our product. Our product can become really small but then really big depending on the sign of the current number. To accomodate for this, we can have two running products: `maxProd` and `minProd`. `maxProd` will track the maximum product that we can achieve and will reset whenever the current number is greater, just as above. `minProd`, on the other hand, will track the minimum product that we can achieve and will reset whenever the current number is smaller. Finally, whenever we encounter a negative number, we will swap `maxProd` and `minProd` because if `a <= b` then `-b <= -a`. This makes sure that `maxProd` and `minProd` are still the max and min products after multiplied by a negative number. And, with that, we have the following solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        // Return early if input is empty\\n        if (nums.empty()) return 0;\\n\\t\\t\\n        int best = INT_MIN;\\n        // Running products\\n        int maxProd = 1;\\n        int minProd = 1;\\n        \\n        for (int n: nums) {\\n            if (n < 0) {\\n                // Swap max and min\\n                swap(maxProd, minProd);\\n            }\\n            // Reset to current value if smaller or larger than it\\n            // (intuitively means that we start considering a new sub-array)\\n            maxProd = max(maxProd*n, n);\\n            minProd = min(minProd*n, n);\\n            // Update the best\\n            best = max(best, maxProd);\\n        }\\n        \\n        return best;\\n    }\\n};\\n```\\n\\nI hope this helps and happy coding!",
                "solutionTags": [],
                "code": "```\\nint runningProduct = 1;\\nfor (int n: nums) {\\n    runningProduct *= n;\\n}\\nreturn runningProduct;\\n```\n```\\nint best = INT_MIN;\\nint runningProduct = 1;\\nfor (int n: nums) {\\n    // Pick the larger of current number and the result of the multiplication\\n    // Picking n means we start considering a new sub-array\\n    runningProduct = max(runningProduct * n, n);\\n    // Keep track of the max runningProduct that we find\\n    best = max(runningProduct, best);\\n}\\nreturn best;\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        // Return early if input is empty\\n        if (nums.empty()) return 0;\\n\\t\\t\\n        int best = INT_MIN;\\n        // Running products\\n        int maxProd = 1;\\n        int minProd = 1;\\n        \\n        for (int n: nums) {\\n            if (n < 0) {\\n                // Swap max and min\\n                swap(maxProd, minProd);\\n            }\\n            // Reset to current value if smaller or larger than it\\n            // (intuitively means that we start considering a new sub-array)\\n            maxProd = max(maxProd*n, n);\\n            minProd = min(minProd*n, n);\\n            // Update the best\\n            best = max(best, maxProd);\\n        }\\n        \\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48276,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Maximum Product Subarray** https://leetcode.com/problems/maximum-product-subarray/?tab=Description\\n\\n1. https://www.quora.com/How-do-I-solve-maximum-product-subarray-problems\\n2. Use an example: [2,-3,4,-8,0]\\n3. Insights: \\n**What if the array has just positive numbers including zero**?\\n A solution of this will maintain max_prod[i] where max_prod[i] is the maximum subarray product ending at i. Then max_prod[i+1] = max(max_prod[i] * nums[i+1], nums[i+1]). \\n **Now how do we change the solution when we allow negative numbers**? \\n Imagine that we have both max_prod[i] and min_prod[i] i.e. max prod ending at i and min prod ending at i. Now if we have a negative number at nums[i+1] and if min_prod[i] is negative, then the product of the two will be positive and can potentially be largest product. Key point is to maintain both max_prod and min_prod such that at iteration i, they refer to the max and min prod ending at index i -1.\\n\\nYou have three choices to make at any position in array.\\n1. You can get maximum product by multiplying the current element with \\n    maximum product calculated so far.  (might work when current \\n    element is positive).\\n2. You can get maximum product by multiplying the current element with \\n    minimum product calculated so far. (might work when current \\n    element is negative).\\n3.  Current element might be a starting position for maximum product sub\\n     array\\n\\t\\t \\n```\\nclass Solution(object):\\n    def maxProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        max_prod, min_prod, ans = nums[0], nums[0], nums[0]\\n        for i in range(1, len(nums)):\\n            x = max(nums[i], max_prod*nums[i], min_prod*nums[i])\\n            y = min(nums[i], max_prod*nums[i], min_prod*nums[i])            \\n            max_prod, min_prod = x, y\\n            ans = max(max_prod, ans)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        max_prod, min_prod, ans = nums[0], nums[0], nums[0]\\n        for i in range(1, len(nums)):\\n            x = max(nums[i], max_prod*nums[i], min_prod*nums[i])\\n            y = min(nums[i], max_prod*nums[i], min_prod*nums[i])            \\n            max_prod, min_prod = x, y\\n            ans = max(max_prod, ans)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1608800,
                "title": "c-discussion-in-detail-easy-to-understand",
                "content": "There can be Mutliple ways to frame the solution once we get the intuition right !! So, what should the intuition be ? Let\\'s discuss that out !\\n\\n***Let\\'s consider array to have no 0s*** (for the moment)...... \\nSo, on what factor does the answer depends now ?? It surely depends on the count of negative numbers in the array !!\\n\\n**There are 2 possibilities** - *either the count of -ve numbers is even or odd*.... --->>>\\n1. If the count is **even**, then obviously we would want to include all of them(in fact the whole array) to maximise the product. As multiplying an even number of -ve numbers would make the result +ve.\\n2. If the count is **odd**, then we would want to exclude  one -ve number from our product, so that the product gets maximised. So, now the question is, which -ve number to exclude? Example ---> arr={-2,-3,-1,-4,-5} which number should be excluded ? On observing it , we should get one fact clear, that the number which is going to get ignored is either going to be the first one or the last one.\\n\\n   *  Note that, we cannot exclude a -ve number that is not the first or the last, because, if we do so, we will need to exclude all(because you are breaking the product at this point) other -ve nums following that -ve number and then that needn\\'t result in the maximum product.\\n   *  Having said all that, now the question is whether to exclude the first -ve num or the last -ve num in the array. We can only know the answer by trying both.\\n   *  So, firstly we will take the product from the beginning of the array and we will include the first -ve number and will leave out the last one !!\\n   *  And will do the vice-versa for checking the other scenario !!\\n   *  So , in that example we would leave the first -ve number... (-2 and then total_product will be product of rest of the numbers in array) or we would leave the last number...(-5) ... And maximum of those 2 cases will be the answer !!\\n   \\n Now, ***what if array has zeroes?***  Well, it changes nothing much to be honest, we can consider the part on both the side of 0 as the subarrays and the maximum product that way will be the max(subarray1_ans, subarray2_ans) .... And how to mark the division point ? How do we seperate the subarrays????...\\nThats pretty simple and we have done it in kadane\\'s algo, just make the curr_ongoing_prod=1 !! And maintain one maxm_prod variable seperately ....\\n\\n**Example** -->>>  arr={-2,1,4,5,0,-3,4,6,1,-2} .... so we can consider subarray1={-2,1,4,5} and subarray2={-3,4,6,-2} and then the max_ans(subarray1,subarray2) will be our answer !!\\n \\n Let\\'s have a look on our code now ....\\n \\n**2-pass solution(for better understanding)** \\n ```\\n class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n        int curr_product = 1, res = INT_MIN;\\n        \\n        for (auto i: nums) {\\n            curr_product = curr_product * i;\\n            res = max(curr_product, res);\\n            if(curr_product == 0) {\\n                curr_product = 1;\\n            }\\n        }\\n        \\n        curr_product = 1;\\n        \\n        for (int i = nums.size()-1; i>=0; i--) {\\n            curr_product = curr_product * nums[i];\\n            res = max(curr_product, res);\\n            if(curr_product == 0) {\\n                curr_product = 1;\\n            }      \\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n* But wait, you might be thinking, why we are still continuing to multiply even beyond the last -ve number in forward iteration and beyond the first -ve number in the forward iteration.\\n\\n* That\\'s all actually is waste in case of array with odd count of -ve numbers, as the product is only going to increase in negativity beyond those points. The maximum is already updated, so this doesn\\'t affect at all.\\n* And in case of even count of -ve numbers ... we do need to multiply all the way through... So it is must in that case !!\\n\\n\\n\\n***code can obviously be made more crisp and cane be done in one-pass***\\nWe will make both the iterations, forward and the backward one simultaneously and will appoint 2-pointer at the front and the backend (mentioning it by l(left_prod, it will leave the last -ve number out) and r(right_prod , it will leave the first -ve number out))....will compare the result everytime with both the products(left and right) and will update it with the maximum value encountered till then.... \\nand will do the same thing here too, updating the left_prod and right_prod by 1 whenever they become 0 !!\\n**1-pass optimal solution(2-pointer)** \\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size(), res = nums[0], l = 1, r = 1;\\n        for (int i = 0; i < n; i++) {\\n            l =  (l) * nums[i];\\n            r =  (r) * nums[n - 1 - i];\\n            res = max(res, max(l, r));\\n            if(l==0)l=1;\\n            if(r==0)r=1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Thanks for reading it out, I hope you got something out of it !!!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n        int curr_product = 1, res = INT_MIN;\\n        \\n        for (auto i: nums) {\\n            curr_product = curr_product * i;\\n            res = max(curr_product, res);\\n            if(curr_product == 0) {\\n                curr_product = 1;\\n            }\\n        }\\n        \\n        curr_product = 1;\\n        \\n        for (int i = nums.size()-1; i>=0; i--) {\\n            curr_product = curr_product * nums[i];\\n            res = max(curr_product, res);\\n            if(curr_product == 0) {\\n                curr_product = 1;\\n            }      \\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size(), res = nums[0], l = 1, r = 1;\\n        for (int i = 0; i < n; i++) {\\n            l =  (l) * nums[i];\\n            r =  (r) * nums[n - 1 - i];\\n            res = max(res, max(l, r));\\n            if(l==0)l=1;\\n            if(r==0)r=1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847520,
                "title": "thought-process-and-useful-strategy",
                "content": "The following documents my thought process for solving the question, shared to illuminate a possible strategy for approaching problems such as this one.\\n\\nFirst, come up with a brute-force solution with `~O(N^2)` running time:\\n\\n```java\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) {\\n            throw new IllegalArgumentException();\\n        }\\n        \\n        int ans = Integer.MIN_VALUE;\\n        \\n        for (int i = 0; i <n; i++) {\\n            int cur = 1;\\n\\n            for (int j = i; j < n; j++) {\\n                cur = cur * nums[j];\\n                ans = Math.max(ans, cur);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nThen, thinking about Kadane\\'s algorithm used to solve [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/), we can come up with the following optimization.\\n\\n```java\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) {\\n            throw new IllegalArgumentException();\\n        }\\n        \\n        int cur = nums[0];\\n        int ans = nums[0];\\n    \\n        for (int i = 1; i < n; i++) {\\n            cur = Math.max(nums[i]*cur, nums[i]);\\n            ans = Math.max(ans, cur);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nOnly, it fails test cases in which two negative numbers produce a maximum sum. An example is `[-2,3,-4]`. Therefore, it only works for an input with no more than one negative number.\\n\\nFor me, I was stuck at this point until I saw that the question was tagged with \"Dynamic Programming\". In the interview setting, the interviewer might give you this hint.\\n\\nWith the hint, we can procede to keep track of the subproblem solutions. Since we observed that negative values can produce the maximum product, we keep track of both maximum product and the minimum product. The minimum product, when multiplied by another negative number, can produce a possible answer. The following solution passes.\\n\\n```java\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) {\\n            throw new IllegalArgumentException();\\n        }\\n\\n        int[] maxVal = new int[n];\\n        int[] minVal = new int[n];\\n        \\n        maxVal[0] = nums[0];\\n        minVal[0] = nums[0];\\n        \\n        for (int i = 1; i < n; i++) {\\n            maxVal[i] = Math.max(maxVal[i-1]*nums[i], Math.max(minVal[i-1]*nums[i], nums[i]));\\n            minVal[i] = Math.min(maxVal[i-1]*nums[i], Math.min(minVal[i-1]*nums[i], nums[i]));\\n        }\\n        \\n        int ans = Integer.MIN_VALUE;\\n        for (int num : maxVal) {\\n            ans = Math.max(ans, num);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nIt is a good idea to check for space optimization for a DP solution. In this case, we observe that we only ever need to keep track of the subproblem solution immediately preceding our current subproblem. Hence we can avoid allocating an array, and improve the space complexity from `~O(N)` to `~O(1)`.\\n\\n```java\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) {\\n            throw new IllegalArgumentException();\\n        }\\n        \\n        int curMax = nums[0];\\n        int curMin = nums[0];\\n        int ans = curMax;\\n        \\n        for (int i = 1; i < n; i++) {\\n            int tmp = curMax;\\n            curMax = Math.max(tmp*nums[i], Math.max(curMin*nums[i], nums[i]));\\n            curMin = Math.min(tmp*nums[i], Math.min(curMin*nums[i], nums[i]));\\n            \\n            ans = Math.max(ans, curMax);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) {\\n            throw new IllegalArgumentException();\\n        }\\n        \\n        int ans = Integer.MIN_VALUE;\\n        \\n        for (int i = 0; i <n; i++) {\\n            int cur = 1;\\n\\n            for (int j = i; j < n; j++) {\\n                cur = cur * nums[j];\\n                ans = Math.max(ans, cur);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) {\\n            throw new IllegalArgumentException();\\n        }\\n        \\n        int cur = nums[0];\\n        int ans = nums[0];\\n    \\n        for (int i = 1; i < n; i++) {\\n            cur = Math.max(nums[i]*cur, nums[i]);\\n            ans = Math.max(ans, cur);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) {\\n            throw new IllegalArgumentException();\\n        }\\n\\n        int[] maxVal = new int[n];\\n        int[] minVal = new int[n];\\n        \\n        maxVal[0] = nums[0];\\n        minVal[0] = nums[0];\\n        \\n        for (int i = 1; i < n; i++) {\\n            maxVal[i] = Math.max(maxVal[i-1]*nums[i], Math.max(minVal[i-1]*nums[i], nums[i]));\\n            minVal[i] = Math.min(maxVal[i-1]*nums[i], Math.min(minVal[i-1]*nums[i], nums[i]));\\n        }\\n        \\n        int ans = Integer.MIN_VALUE;\\n        for (int num : maxVal) {\\n            ans = Math.max(ans, num);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) {\\n            throw new IllegalArgumentException();\\n        }\\n        \\n        int curMax = nums[0];\\n        int curMin = nums[0];\\n        int ans = curMax;\\n        \\n        for (int i = 1; i < n; i++) {\\n            int tmp = curMax;\\n            curMax = Math.max(tmp*nums[i], Math.max(curMin*nums[i], nums[i]));\\n            curMin = Math.min(tmp*nums[i], Math.min(curMin*nums[i], nums[i]));\\n            \\n            ans = Math.max(ans, curMax);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176155,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n         int maxi = nums[0];\\n        int mini = nums[0];\\n        int ans = nums[0];\\n        for(int i = 1;i < nums.size();i++){\\n            if(nums[i] < 0){\\n                swap(maxi,mini);\\n            }\\n            maxi = max(nums[i],maxi*nums[i]);\\n            mini = min(nums[i],mini*nums[i]);\\n            ans = max(ans,maxi);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nfrom math import inf\\n\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        \\n        p = 0\\n        \\n        first_neg = 0\\n        first_neg_excluded = False\\n        \\n        p_max = -inf\\n        \\n        for x in nums:\\n            \\n            if x == 0:\\n                p = 0\\n                first_neg = 0\\n                first_neg_excluded = False\\n            \\n            elif x > 0:\\n                \\n                if p == 0:\\n                    p = x\\n                    \\n                else:\\n                    p *= x\\n                \\n                    if p < 0:\\n                        p //= first_neg\\n                        first_neg_excluded = True\\n            \\n            else:\\n                p = p * x if p != 0 else x\\n                \\n                if p < 0:\\n                \\n                    if first_neg == 0:\\n                        first_neg = p\\n                    \\n                    elif first_neg_excluded:\\n                        p *= first_neg\\n                        first_neg_excluded = False\\n                    \\n                    else:\\n                        p //= first_neg\\n                        first_neg_excluded = True\\n            \\n            if p > p_max:\\n                p_max = p\\n        \\n        return p_max\\n```\\n\\n```Java []\\nclass Solution {\\n  public int maxProduct(int[] nums) {\\n    int ans = nums[0];\\n    int dpMin = nums[0];\\n    int dpMax = nums[0];\\n\\n    for (int i = 1; i < nums.length; ++i) {\\n      final int num = nums[i];\\n      final int prevMin = dpMin;\\n      final int prevMax = dpMax;\\n      if (num < 0) {\\n        dpMin = Math.min(prevMax * num, num);\\n        dpMax = Math.max(prevMin * num, num);\\n      } else {\\n        dpMin = Math.min(prevMin * num, num);\\n        dpMax = Math.max(prevMax * num, num);\\n      }\\n      ans = Math.max(ans, dpMax);\\n    }\\n    return ans;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n         int maxi = nums[0];\\n        int mini = nums[0];\\n        int ans = nums[0];\\n        for(int i = 1;i < nums.size();i++){\\n            if(nums[i] < 0){\\n                swap(maxi,mini);\\n            }\\n            maxi = max(nums[i],maxi*nums[i]);\\n            mini = min(nums[i],mini*nums[i]);\\n            ans = max(ans,maxi);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nfrom math import inf\\n\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        \\n        p = 0\\n        \\n        first_neg = 0\\n        first_neg_excluded = False\\n        \\n        p_max = -inf\\n        \\n        for x in nums:\\n            \\n            if x == 0:\\n                p = 0\\n                first_neg = 0\\n                first_neg_excluded = False\\n            \\n            elif x > 0:\\n                \\n                if p == 0:\\n                    p = x\\n                    \\n                else:\\n                    p *= x\\n                \\n                    if p < 0:\\n                        p //= first_neg\\n                        first_neg_excluded = True\\n            \\n            else:\\n                p = p * x if p != 0 else x\\n                \\n                if p < 0:\\n                \\n                    if first_neg == 0:\\n                        first_neg = p\\n                    \\n                    elif first_neg_excluded:\\n                        p *= first_neg\\n                        first_neg_excluded = False\\n                    \\n                    else:\\n                        p //= first_neg\\n                        first_neg_excluded = True\\n            \\n            if p > p_max:\\n                p_max = p\\n        \\n        return p_max\\n```\n```Java []\\nclass Solution {\\n  public int maxProduct(int[] nums) {\\n    int ans = nums[0];\\n    int dpMin = nums[0];\\n    int dpMax = nums[0];\\n\\n    for (int i = 1; i < nums.length; ++i) {\\n      final int num = nums[i];\\n      final int prevMin = dpMin;\\n      final int prevMax = dpMax;\\n      if (num < 0) {\\n        dpMin = Math.min(prevMax * num, num);\\n        dpMax = Math.max(prevMin * num, num);\\n      } else {\\n        dpMin = Math.min(prevMin * num, num);\\n        dpMax = Math.max(prevMax * num, num);\\n      }\\n      ans = Math.max(ans, dpMax);\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1609493,
                "title": "c-simple-solution-w-explanation-optimization-from-brute-force-to-dp",
                "content": "\\u274C ***Solution - I (Brute-Force)***\\n\\nWe can simply check for each subarray and return the subarray which gives the maximum product\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& A) {\\n        int ans = INT_MIN;\\n        for(int i = 0; i < size(A); i++) \\n            for(int j = i; j < size(A); j++)\\n                ans = max(ans, accumulate(begin(A)+i, begin(A)+j+1, 1, multiplies<>()));\\n        return ans;\\n    }\\n};\\n```\\n\\nOr a slightly better version of brute-force -\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& A) {\\n        int ans = INT_MIN;\\n        for(int i = 0; i < size(A); i++) {\\n            int curProd = 1;\\n            for(int j = i; j < size(A); j++)\\n                curProd *= A[j],\\n                ans = max(ans, curProd);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n***Time Complexity :*** <code>O(N<sup>3</sup>) / O(N<sup>2</sup>)</code> for the 1st version and 2nd version respectively.\\n***Space Complexity :*** <code>O(1)</code>, only constant extra space is used.\\n\\n---\\n\\n\\u274C ***Solution - II (Recursive)***\\n\\nWe can recursively calculate the maximum product of subarray as well. Here, we start at index `0` and recursively calculate the maximum subarray product starting at each index and return the one yielding the maximum overall product.\\n\\nBut we must first realize that maximum subarray product starting at index `i` is not always `A[i]*maxProduct(A[i+1:])` and can also be `A[i]*minProduct(A[i+1:])`. This is because when `A[i] >= 0`, multiplying it with maximum product after `i` will yield the largest overall product. However, when `A[i] < 0`, we need to multiply it with minimum possible product after `i` to get the largest overall product (try with some examples if you didnt get this).\\n\\nSo, whenever `A[i] >= 0`, we call a function which returns maximum product of subarray starting from `i+1` (`dfsMax` in the below code) and whenever `A[i] < 0`, we call function which returns minimum product of subarray starting from `i+1` (`dfsMin` in below code).\\n\\nIn the below solution, I have also passed another boolean parameter `mustPick` which denotes if every element from now on must be picked or not. This helps ensure that we pick a subarray and not a subsequence. If `A[i]` is picked, for every index `j > i`, we must either pick every element `A[j]` after that or end the recursion at any index `j` by return 1.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& A) { \\n        return dfsMax(A, 0, false); \\n    }\\n\\t// finds maximum subarray product starting at i\\n    long dfsMax(vector<int>& A, int i, bool mustPick) {\\n        if (i >= size(A)) return mustPick ? 1 : INT_MIN;     // if mustPick remains false till end, the no element is chosen so return -\\u221E denoting invalid case\\n        if (mustPick)\\n            return max(1l, A[i] * (A[i] >= 0 ? dfsMax(A, i+1, true) : dfsMin(A, i+1)));                 // either end recursion by returning 1 or recurse by picking A[i]. Choose whichever gives max product\\n        return max(dfsMax(A, i+1, false), A[i] * (A[i] >= 0 ? dfsMax(A, i+1, true) : dfsMin(A, i+1)));  // either pick A[i] or recurse for next index without picking. Choose whichever gives max product\\n    }\\n\\t// finds minimum subarray product starting at i\\n    long dfsMin(vector<int>& A, int i) {\\n        if (i >= size(A)) return 1;\\n        return A[i] * (A[i] >= 0 ? dfsMin(A, i+1) : dfsMax(A, i+1, true));\\n    }\\n};\\n```\\n\\n***Time Complexity :*** <code>O(N<sup>2</sup>)</code>\\n***Space Complexity :*** <code>O(N)</code>, required by implicit recursive stack\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Dynamic Programming - Memoization)***\\n\\nWe can observe a lot of repeated calculations if we draw out the recursive tree for above solution. The maximum product of subarray starting at `i` will always remain the same and there\\'s no need to calculate it again and again. These redundant calculations can be eliminated if we store the results for a given state and reuse them later whenever required rather than recalculating them over and over again. \\n\\nThus, we can use memoization technique here to make our solution more efficient. Here, we use `dpMax` and `dpMin` arrays where `dpMax[i][mustPick]` denotes the maximum product subarray starting from `i` and `mustPick` denotes whether the current element must be compulsorily picked or we have an choice between picking and not picking it. Similarly, `dpMin[i]` denotes the minimum product subarray starting from `i`. Each element of `dpMax` and `dpMin` is initialized to `INT_MIN` denoting they haven\\'t been computed yet.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> dpMin;\\n    vector<vector<int>> dpMax;\\n    int maxProduct(vector<int>& A) { \\n        dpMin.resize(size(A), INT_MIN);\\n        dpMax.resize(size(A), vector<int>(2, INT_MIN));\\n        return dfsMax(A, 0, false); \\n    }\\n    long dfsMax(vector<int>& A, int i, bool mustPick) {\\n        if (i >= size(A)) return mustPick ? 1 : INT_MIN;\\n        if(dpMax[i][mustPick] != INT_MIN) return dpMax[i][mustPick];\\n        if (mustPick)\\n            return dpMax[i][mustPick] = max(1l, A[i] * (A[i] >= 0 ? dfsMax(A, i+1, true) : dfsMin(A, i+1)));\\n        return dpMax[i][mustPick] = max(dfsMax(A, i+1, false), A[i] * (A[i] >= 0 ? dfsMax(A, i+1, true) : dfsMin(A, i+1)));\\n    }\\n    long dfsMin(vector<int>& A, int i) {\\n        if (i >= size(A)) return 1;\\n        if(dpMin[i] != INT_MIN) return dpMin[i];\\n        return dpMin[i] = A[i] * (A[i] >= 0 ? dfsMin(A, i+1) : dfsMax(A, i+1, true));\\n    }\\n};\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, we calculate `dpMax[i]` for each `0 <= i < N` only once and return the stored result for every future call.\\n***Space Complexity :*** <code>O(N)</code>, required by dp arrays and recursive stack\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Dynamic Programming - Tabulation)***\\n\\nWe can solve this iteratively as well using DP. Here, we again use `dpMax` and `dpMin` arrays where `dpMax[i]` denotes maximum subarray product ending at `i` and `dpMin[i]` denotes minimum subarray product ending at `i`. \\n\\nAt each index `i`, we will update `dpMin[i]` as minimum of `A[i]` (denotes forming new subarray by choosing current element) and `min(A[i] * dpMin[i-1], A[i] * dpMax[i-1])` (denotes expanding previous subarray product by including current element). We do it similarly for `dpMax[i]` as well. Finally, the maximum product subarray will be the maximum value in `dpMax` array.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& A) {\\n        vector<int> dpMin(A), dpMax(A);\\n        int ans = A[0];\\n        for(int i = 1; i < size(A); i++) {\\n            dpMin[i] = min(A[i], A[i] * (A[i] >= 0 ? dpMin[i-1] : dpMax[i-1]));\\n            dpMax[i] = max(A[i], A[i] * (A[i] >= 0 ? dpMax[i-1] : dpMin[i-1]));\\n            ans = max(ans, dpMax[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>\\n***Space Complexity :*** <code>O(N)</code>\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - V (Space-Optimized Dynamic Programming)***\\n\\nIn the above solution, `dpMax[i]` and `dpMin[i]` only depended on previous index and thus we can optimize space by not storing the entire array but only two variables `dpMax` and `dpMin` and update them iteratively based on their previous value in the same way as done above.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& A) {\\n        int ans = A[0], dpMin = A[0], dpMax = A[0];\\n        for(int i = 1; i < size(A); i++) {\\n            auto prevDpMin = dpMin, prevDpMax = dpMax;\\n            dpMin = min(A[i], A[i] * (A[i] >= 0 ? prevDpMin : prevDpMax));\\n            dpMax = max(A[i], A[i] * (A[i] >= 0 ? prevDpMax : prevDpMin));\\n            ans = max(ans, dpMax);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>\\n***Space Complexity :*** <code>O(1)</code>\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& A) {\\n        int ans = INT_MIN;\\n        for(int i = 0; i < size(A); i++) \\n            for(int j = i; j < size(A); j++)\\n                ans = max(ans, accumulate(begin(A)+i, begin(A)+j+1, 1, multiplies<>()));\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& A) {\\n        int ans = INT_MIN;\\n        for(int i = 0; i < size(A); i++) {\\n            int curProd = 1;\\n            for(int j = i; j < size(A); j++)\\n                curProd *= A[j],\\n                ans = max(ans, curProd);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& A) { \\n        return dfsMax(A, 0, false); \\n    }\\n\\t// finds maximum subarray product starting at i\\n    long dfsMax(vector<int>& A, int i, bool mustPick) {\\n        if (i >= size(A)) return mustPick ? 1 : INT_MIN;     // if mustPick remains false till end, the no element is chosen so return -\\u221E denoting invalid case\\n        if (mustPick)\\n            return max(1l, A[i] * (A[i] >= 0 ? dfsMax(A, i+1, true) : dfsMin(A, i+1)));                 // either end recursion by returning 1 or recurse by picking A[i]. Choose whichever gives max product\\n        return max(dfsMax(A, i+1, false), A[i] * (A[i] >= 0 ? dfsMax(A, i+1, true) : dfsMin(A, i+1)));  // either pick A[i] or recurse for next index without picking. Choose whichever gives max product\\n    }\\n\\t// finds minimum subarray product starting at i\\n    long dfsMin(vector<int>& A, int i) {\\n        if (i >= size(A)) return 1;\\n        return A[i] * (A[i] >= 0 ? dfsMin(A, i+1) : dfsMax(A, i+1, true));\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> dpMin;\\n    vector<vector<int>> dpMax;\\n    int maxProduct(vector<int>& A) { \\n        dpMin.resize(size(A), INT_MIN);\\n        dpMax.resize(size(A), vector<int>(2, INT_MIN));\\n        return dfsMax(A, 0, false); \\n    }\\n    long dfsMax(vector<int>& A, int i, bool mustPick) {\\n        if (i >= size(A)) return mustPick ? 1 : INT_MIN;\\n        if(dpMax[i][mustPick] != INT_MIN) return dpMax[i][mustPick];\\n        if (mustPick)\\n            return dpMax[i][mustPick] = max(1l, A[i] * (A[i] >= 0 ? dfsMax(A, i+1, true) : dfsMin(A, i+1)));\\n        return dpMax[i][mustPick] = max(dfsMax(A, i+1, false), A[i] * (A[i] >= 0 ? dfsMax(A, i+1, true) : dfsMin(A, i+1)));\\n    }\\n    long dfsMin(vector<int>& A, int i) {\\n        if (i >= size(A)) return 1;\\n        if(dpMin[i] != INT_MIN) return dpMin[i];\\n        return dpMin[i] = A[i] * (A[i] >= 0 ? dfsMin(A, i+1) : dfsMax(A, i+1, true));\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& A) {\\n        vector<int> dpMin(A), dpMax(A);\\n        int ans = A[0];\\n        for(int i = 1; i < size(A); i++) {\\n            dpMin[i] = min(A[i], A[i] * (A[i] >= 0 ? dpMin[i-1] : dpMax[i-1]));\\n            dpMax[i] = max(A[i], A[i] * (A[i] >= 0 ? dpMax[i-1] : dpMin[i-1]));\\n            ans = max(ans, dpMax[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& A) {\\n        int ans = A[0], dpMin = A[0], dpMax = A[0];\\n        for(int i = 1; i < size(A); i++) {\\n            auto prevDpMin = dpMin, prevDpMax = dpMax;\\n            dpMin = min(A[i], A[i] * (A[i] >= 0 ? prevDpMin : prevDpMax));\\n            dpMax = max(A[i], A[i] * (A[i] >= 0 ? prevDpMax : prevDpMin));\\n            ans = max(ans, dpMax);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48243,
                "title": "in-python-revised",
                "content": "```python\\ndef maxProduct(nums):\\n\\tmaximum = big = small =nums[0]\\n\\tfor n in nums[1:]:\\n\\t\\tbig, small = max(n, n*big, n*small), min(n, n*big, n*small)\\n\\t\\tmaximum = max(maximum, big)\\n\\treturn maximum\\n```\\t\\n\\t\\t\\n**UPDATE 2020-08-12:**\\nNow I started to appreciate readability:\\n```python\\ndef maxProduct(nums: List[int]) -> int:\\n\\tmini, maxi, res = 1, 1, -math.inf\\n\\tfor n in nums:\\n\\t\\ta = mini * n\\n\\t\\tb = maxi * n\\n\\t\\tmini = min(a, b, n)\\n\\t\\tmaxi = max(a, b, n)\\n\\t\\tres = max(res, maxi)\\n\\treturn res\\n```",
                "solutionTags": [],
                "code": "```python\\ndef maxProduct(nums):\\n\\tmaximum = big = small =nums[0]\\n\\tfor n in nums[1:]:\\n\\t\\tbig, small = max(n, n*big, n*small), min(n, n*big, n*small)\\n\\t\\tmaximum = max(maximum, big)\\n\\treturn maximum\\n```\n```python\\ndef maxProduct(nums: List[int]) -> int:\\n\\tmini, maxi, res = 1, 1, -math.inf\\n\\tfor n in nums:\\n\\t\\ta = mini * n\\n\\t\\tb = maxi * n\\n\\t\\tmini = min(a, b, n)\\n\\t\\tmaxi = max(a, b, n)\\n\\t\\tres = max(res, maxi)\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 490459,
                "title": "unofficial-solution-intuitive-explanations-o-n-two-different-approaches",
                "content": "Let\\'s summarize this question into our own words: given an array of integers (negative, zeros, positive inclusive), what is the maximum consecutive subarray? What starting point and ending point within the array has the largest product sum?\\n\\nThinking about simplifying the problem is helpful: specifically think about the easier version of the problem, maximum sum subarray that is solved with kadane\\'s algorithm.\\n\\n**Approach #1 Brute Force**\\nWe try every possible starting and ending point pair within the array, done easily with two for loops.\\n\\nComplexity\\nTime: O(n^2)\\nSpace: O(1)\\n\\nThere are two approaches to the optimal solution, and they are slightly different. Instead of summing up elements, we multiply. Think about the properties of multiplication - any multiplication with a positive number will increase our max, anything by zero will zero us out, and multiplication by an EVEN amount of negative numbers will increase us also. \\n\\nRecall kadane\\'s algorithm - in our one pass, we either extend our subarray to end at the nth item, or we start over at n.\\n\\n**Approach #2 Kadane\\'s algorithm** (Dynamic programming) track both max and mins\\n\\n```\\ndef maxProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        prev_max = nums[0] # max from previous iteration\\n        prev_min = nums[0] # min from previous iteration\\n        max_to_n = nums[0] # max this iteration\\n        min_to_n = nums[0] # min this iteration\\n        ans = nums[0]\\n        \\n        for i in nums[1:]\\n\\t\\t\\t# use previous max/min*current i or restart from i. The absolute value of the min could be larger so we store it.\\n\\t\\t\\tmax_to_n = max(max(prev_max*i, prev_min*i), i)\\n            min_to_n = min(min(prev_max*i, prev_min*i), i)\\n            prev_max = max_to_n\\n            prev_min = min_to_n\\n            ans = max(ans, max_to_n)\\n        return ans\\n```\\nThe key intuition here is that when we can come upon a negative number, our current max can suddenly becomes a min but is still a max by absolute value. Following the next negative number, our min can become a max again. Therefore keeping track of min is useful.\\n\\n\\n\\nComplexity\\nTime: O(n)\\nSpace: O(1)\\n\\n**Approach #3 Ad hoc** Linear algorithm without DP\\n\\n```\\ndef maxProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ans = nums[0]\\n        current = 1\\n\\t\\t# left to right pass. Captures all potential subarrays containing first odd n negative numbers\\n        for i in nums:\\n            current*=i\\n            ans = max(ans, current)\\n\\t\\t\\t# zero is a delimiter, restart at 1. This is optimal since zero multiplied on is still zero.\\n            if current == 0:\\n                current = 1\\n        current = 1\\n\\t\\t# right to left pass capturing all potential subarrays containing last odd n negative numbers\\n        for i in reversed(nums):\\n            current*=i\\n            ans = max(ans, current)\\n            if current == 0:\\n                current = 1\\n        return ans\\n```\\n\\nAs we described above, positive numbers don\\'t matter, we always \\'take\\' them and continue on and don\\'t consider starting on them. Any array of positive, zero, and negative numbers can be thought of as zeros and negative numbers. Our answer will include an even number of negatives.\\n\\nFor example, [-3 -1, -10]. We can either take [-3, -1] or [-1, -10]. The former gives us 10 which is the maximum.\\n\\nThe positives don\\'t exactly matter. [-3, 5, -3, 5, -10]. The max answer is different, but we could compress this array with positives into [-3, -1, -10] and assume we take/include positive numbers in between and skip onto the next negative number.\\n\\nThe zeros matter because they act like delimiters. Zero times anything = zero. You can think of this algorithm as splitting one array into subarrays delimited by zero, and picking the best even number of negatives. When you reach a zero, you need to restart. Imagine now you have an array with no zeros. If you have 3 negative numbers, pick the first two or the last two. If you have 5 negative numbers, the first four or the last four.\\n\\nThe elegant way to implement this is two passes - one from the left and one from the right. On the left pass, your cumulative multiply and check against your running max. This guarantees checking the first 3 or 5 or first n odd number of negative numbers. But the better answer could be [-1, -10] rather than [-3, -1]. If we pass from right to left, or traverse our array in reverse, we guarantee we also consider the last n odd number of negative numbers.\\n\\nHow do we deal with the zeros? When we hit a zero, we set our current local max back to 1. \\n\\nComplexity\\nTime: O(n)\\nSpace: O(1)\\n\\n\\nAny feedback on these explanations is welcome.\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef maxProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        prev_max = nums[0] # max from previous iteration\\n        prev_min = nums[0] # min from previous iteration\\n        max_to_n = nums[0] # max this iteration\\n        min_to_n = nums[0] # min this iteration\\n        ans = nums[0]\\n        \\n        for i in nums[1:]\\n\\t\\t\\t# use previous max/min*current i or restart from i. The absolute value of the min could be larger so we store it.\\n\\t\\t\\tmax_to_n = max(max(prev_max*i, prev_min*i), i)\\n            min_to_n = min(min(prev_max*i, prev_min*i), i)\\n            prev_max = max_to_n\\n            prev_min = min_to_n\\n            ans = max(ans, max_to_n)\\n        return ans\\n```\n```\\ndef maxProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ans = nums[0]\\n        current = 1\\n\\t\\t# left to right pass. Captures all potential subarrays containing first odd n negative numbers\\n        for i in nums:\\n            current*=i\\n            ans = max(ans, current)\\n\\t\\t\\t# zero is a delimiter, restart at 1. This is optimal since zero multiplied on is still zero.\\n            if current == 0:\\n                current = 1\\n        current = 1\\n\\t\\t# right to left pass capturing all potential subarrays containing last odd n negative numbers\\n        for i in reversed(nums):\\n            current*=i\\n            ans = max(ans, current)\\n            if current == 0:\\n                current = 1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1608907,
                "title": "python3-dynamic-programming-explained",
                "content": "Subproblem for the DP here would be: What is the maximum and minimum product we can get for a contiguous sub-array starting from the `0`th to the current element? Why do we need to maintain the minimum product while we are asked for a maximum? The fact is that elements in `nums` can be negative, so it possible that for some negative element the previous min possible product can turn the current product into a greater value.\\n\\nTime: **O(n)** - scan\\nSpace: **O(1)** \\n\\nRuntime: 44 ms, faster than **98.89%** of Python3 online submissions for Maximum Product Subarray.\\nMemory Usage: 14.5 MB, less than **36.06%** of Python3 online submissions for Maximum Product Subarray.\\n\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        curMax, curMin = 1, 1\\n        res = nums[0]\\n        \\n        for n in nums:\\n            vals = (n, n * curMax, n * curMin)\\n            curMax, curMin = max(vals), min(vals)\\n\\t\\t\\t\\n            res = max(res, curMax)\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        curMax, curMin = 1, 1\\n        res = nums[0]\\n        \\n        for n in nums:\\n            vals = (n, n * curMax, n * curMin)\\n            curMax, curMin = max(vals), min(vals)\\n\\t\\t\\t\\n            res = max(res, curMax)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48261,
                "title": "share-my-dp-code-that-got-ac",
                "content": "    public class Solution {\\n      public int maxProduct(int[] A) {\\n        if (A == null || A.length == 0) {\\n            return 0;\\n        }\\n        int[] f = new int[A.length];\\n        int[] g = new int[A.length];\\n        f[0] = A[0];\\n        g[0] = A[0];\\n        int res = A[0];\\n        for (int i = 1; i < A.length; i++) {\\n            f[i] = Math.max(Math.max(f[i - 1] * A[i], g[i - 1] * A[i]), A[i]);\\n            g[i] = Math.min(Math.min(f[i - 1] * A[i], g[i - 1] * A[i]), A[i]);\\n            res = Math.max(res, f[i]);\\n        }\\n        return res;\\n      }\\n    }\\n\\n> f[i] means maximum product that can be achieved ending with i\\n> \\n> g[i] means minimum product that can be achieved ending with i",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      public int maxProduct(int[] A) {\\n        if (A == null || A.length == 0) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3186637,
                "title": "best-c-2-solution-dp-brute-force-optimize-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Array(Two Nested Loops). Brute Force Approach.\\n2. Solved using Dynamic Programming Approach(Space Optimization). Optimized Approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N^2), Where N is the size of the array. Here total number of iterations are : N*(N\\u20131)/2\\n    which creates the time complexity.\\n\\n    Space complexity : O(1), Constant space.\\n\\n    Solved using Array(Two Nested Loop). Brute Force Approach.\\n\\n    Note : This will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxProduct = INT_MIN;\\n        for(int i=0; i<n; i++){\\n            int product = 1;\\n            for(int j=i; j<n; j++){\\n                product *= nums[j];\\n                if(product > maxProduct){\\n                    maxProduct = product;\\n                }\\n            }\\n        }\\n        return maxProduct;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of the Array(nums). Here we are traversing each element of Array\\n    (nums) which creates the time complexity.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Dynamic Programming Approach(Space Optimization). Optimized Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int minProduct = 1;\\n        int maxProduct = 1;\\n        int ans = INT_MIN;\\n        for(int i=0; i<n; i++){\\n            if(nums[i] < 0){\\n                swap(maxProduct, minProduct);\\n            }\\n            maxProduct = max(maxProduct*nums[i], nums[i]);\\n            minProduct = min(minProduct*nums[i], nums[i]);\\n            ans = max(ans, maxProduct);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^2), Where N is the size of the array. Here total number of iterations are : N*(N\\u20131)/2\\n    which creates the time complexity.\\n\\n    Space complexity : O(1), Constant space.\\n\\n    Solved using Array(Two Nested Loop). Brute Force Approach.\\n\\n    Note : This will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxProduct = INT_MIN;\\n        for(int i=0; i<n; i++){\\n            int product = 1;\\n            for(int j=i; j<n; j++){\\n                product *= nums[j];\\n                if(product > maxProduct){\\n                    maxProduct = product;\\n                }\\n            }\\n        }\\n        return maxProduct;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of the Array(nums). Here we are traversing each element of Array\\n    (nums) which creates the time complexity.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Dynamic Programming Approach(Space Optimization). Optimized Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int minProduct = 1;\\n        int maxProduct = 1;\\n        int ans = INT_MIN;\\n        for(int i=0; i<n; i++){\\n            if(nums[i] < 0){\\n                swap(maxProduct, minProduct);\\n            }\\n            maxProduct = max(maxProduct*nums[i], nums[i]);\\n            minProduct = min(minProduct*nums[i], nums[i]);\\n            ans = max(ans, maxProduct);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 416395,
                "title": "javascript-solution-w-explanation",
                "content": "#### The idea\\nThis is something I would never come up by myself, so I\\'m using this discussion as an oppotunity to both reinforce the knowledge for myself and possibly share some insights with others.\\n\\nThe intuition is that we store the information about our previous maximum product, and as we iterate through the array, we keep using our previous maximum to calculate the new maximum product. \\nThe tricky part of this problem is that negative numbers exist in the input array. This causes situations where the smallest previous product (a negative number) can become the largest product if the next number in line is also a negative number.\\nSince the minimum product may have a chance to become the maximum, we need to store the information about the previous minimum as well and take it into account when we are calculating our maximum product.\\n\\n#### Code Time\\n``` javascript\\nvar maxProduct = function(nums) {\\n    let prevMax = nums[0];\\n    let prevMin = nums[0];\\n    let result = nums[0];\\n    for (let i=1;i<nums.length;i++) {\\n        // given the new number, the new maximun can have 3 conditions\\n        // 1. number(+) * prevMax(+) is the largest\\n        // 2. number(+) it self is the largest\\n        // 3. number(-) * prevMin(-) is the largest \\n        curMax = Math.max(nums[i] * prevMax, nums[i], nums[i] * prevMin);\\n        \\n        curMin = Math.min(nums[i] * prevMin, nums[i], nums[i] * prevMax);\\n\\n\\t\\t// updating the prevMax & prevMin, these two may swap locations\\n        prevMax = curMax\\n        prevMin = curMin\\n\\n        result = Math.max(curMax, result);\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar maxProduct = function(nums) {\\n    let prevMax = nums[0];\\n    let prevMin = nums[0];\\n    let result = nums[0];\\n    for (let i=1;i<nums.length;i++) {\\n        // given the new number, the new maximun can have 3 conditions\\n        // 1. number(+) * prevMax(+) is the largest\\n        // 2. number(+) it self is the largest\\n        // 3. number(-) * prevMin(-) is the largest \\n        curMax = Math.max(nums[i] * prevMax, nums[i], nums[i] * prevMin);\\n        \\n        curMin = Math.min(nums[i] * prevMin, nums[i], nums[i] * prevMax);\\n\\n\\t\\t// updating the prevMax & prevMin, these two may swap locations\\n        prevMax = curMax\\n        prevMin = curMin\\n\\n        result = Math.max(curMax, result);\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 48404,
                "title": "accepted-java-solution",
                "content": "    public int maxProduct(int[] a) {\\n      if (a == null || a.length == 0)\\n        return 0;\\n    \\n      int ans = a[0], min = ans, max = ans;\\n      \\n      for (int i = 1; i < a.length; i++) {\\n        if (a[i] >= 0) {\\n          max = Math.max(a[i], max * a[i]);\\n          min = Math.min(a[i], min * a[i]);\\n        } else {\\n          int tmp = max;\\n          max = Math.max(a[i], min * a[i]);\\n          min = Math.min(a[i], tmp * a[i]);\\n        }\\n        \\n        ans = Math.max(ans, max);\\n      }\\n      \\n      return ans;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int maxProduct(int[] a) {\\n      if (a == null || a.length == 0)\\n        return 0;\\n    \\n      int ans = a[0], min = ans, max = ans;\\n      \\n      for (int i = 1; i < a.length; i++) {\\n        if (a[i] >= 0) {\\n          max = Math.max(a[i], max * a[i]);\\n          min = Math.min(a[i], min * a[i]);\\n        } else {\\n          int tmp = max;\\n          max = Math.max(a[i], min * a[i]);\\n          min = Math.min(a[i], tmp * a[i]);\\n        }\\n        \\n        ans = Math.max(ans, max);\\n      }\\n      \\n      return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 691867,
                "title": "python-easily-understandable-solution-using-kadanes-algorithm",
                "content": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : KADANES ALGORITHM ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n        \\n        # 1. Edge Case : Negative * Negative = Positive\\n        # 2. So we need to keep track of minimum values also, as they can yield maximum values.\\n        \\n        global_max = prev_max = prev_min = nums[0]\\n        for num in nums[1:]:\\n            curr_min = min(prev_max*num, prev_min*num, num)\\n            curr_max = max(prev_max*num, prev_min*num, num)\\n            global_max= max(global_max, curr_max)\\n            prev_max = curr_max\\n            prev_min = curr_min\\n        return global_max\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : KADANES ALGORITHM ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n        \\n        # 1. Edge Case : Negative * Negative = Positive\\n        # 2. So we need to keep track of minimum values also, as they can yield maximum values.\\n        \\n        global_max = prev_max = prev_min = nums[0]\\n        for num in nums[1:]:\\n            curr_min = min(prev_max*num, prev_min*num, num)\\n            curr_max = max(prev_max*num, prev_min*num, num)\\n            global_max= max(global_max, curr_max)\\n            prev_max = curr_max\\n            prev_min = curr_min\\n        return global_max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48418,
                "title": "share-c-code-with-dp-o-1-space-o-n-time",
                "content": "    int maxProduct(int A[], int n) {\\n        if(n==1) return A[0];\\n        int pMax=0, nMax=0, m = 0;\\n        for(int i=0; i<n; i++){\\n            if(A[i]<0) swap(pMax, nMax);\\n            pMax = max(pMax*A[i], A[i]);\\n            nMax = min(nMax*A[i], A[i]);\\n            m = max(m, pMax);\\n        }\\n        return m;\\n    }",
                "solutionTags": [],
                "code": "    int maxProduct(int A[], int n) {\\n        if(n==1) return A[0];\\n        int pMax=0, nMax=0, m = 0;\\n        for(int i=0; i<n; i++){\\n            if(A[i]<0) swap(pMax, nMax);\\n            pMax = max(pMax*A[i], A[i]);\\n            nMax = min(nMax*A[i], A[i]);\\n            m = max(m, pMax);\\n        }\\n        return m;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3227249,
                "title": "c-o-n-time-and-o-1-space-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem:\\n**KEY POINTS:**\\n1. currMaxProductSubarr : This variable keeps track of the maximum product of a subarray that ends at the current index. For each element in the input array, we update the value of currMaxProductSubarr based on the maximum product that can be obtained by considering the current element and the maximum and minimum product of the subarray that ends at the previous index.\\n2. currMinProductSubarr : This variable keeps track of the minimum product of a subarray that ends at the current index. As with currMaxProductSubarr, we update the value of currMinProductSubarr at each index based on the minimum product that can be obtained by considering the current element and the maximum and minimum product of the subarray that ends at the previous index.\\n3. maxProductAns : This variable keeps track of the maximum product obtained so far. At each index, we compare the value of currMaxProductSubarr with the current value of maxProductAns and update maxProductAns if currMaxProductSubarr is greater than the current value of maxProductAns. By doing so, we ensure that maxProductAns always stores the maximum product obtained from any subarray in nums up to the current index.\\n4. The maximum product of a subarray can be obtained by considering three possibilities:\\n     - The current element nums[i] alone forms a subarray with the maximum product. In this case, the maximum product of the subarray that ends at the current index is simply nums[i].\\n     - The current element nums[i] is positive and can be added to the existing subarray that ends at the previous index with the maximum product. In this case, the maximum product of the subarray that ends at the current index is the product of the current element nums[i] and the maximum product of the subarray that ends at the previous index, i.e., currMaxProductSubarr * nums[i].\\n     - The current element nums[i] is negative and can be added to the existing subarray that ends at the previous index with the minimum product. In this case, the maximum product of the subarray that ends at the current index is the product of the current element nums[i] and the minimum product of the subarray that ends at the previous index, i.e., currMinProductSubarr * nums[i].\\n1. The minimum product of a subarray can be obtained by considering three possibilities:\\n    - The current element nums[i] alone forms a subarray with the minimum product. In this case, the minimum product of the subarray that ends at the current index is simply nums[i].\\n    - The current element nums[i] is positive and can be added to the existing subarray that ends at the previous index with the minimum product. In this case, the minimum product of the subarray that ends at the current index is the product of the current element nums[i] and the minimum product of the subarray that ends at the previous index, i.e., currMinProductSubarr * nums[i].\\n    - The current element nums[i] is negative and can be added to the existing subarray that ends at the previous index with the maximum product. In this case, the minimum product of the subarray that ends at the current index is the product of the current element nums[i] and the maximum product of the subarray that ends at the previous index, i.e., temp * nums[i].\\n\\n**See C++ detailed explanation code with intuition.**\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem:\\n1. Initialize three variables currMaxProductSubarr, currMinProductSubarr, maxProductAns to the first element of the input array.\\n2. Traverse the input array from index 1 to n-1.\\n3. For each element at index i, update the currMaxProductSubarr and currMinProductSubarr by taking maximum and minimum of the following three values: (i) nums[i], (ii) currMaxProductSubarrnums[i], (iii) currMinProductSubarrnums[i].\\n4. Update the maxProductAns as the maximum of maxProductAns and currMaxProductSubarr.\\n5. Return maxProductAns as the final answer.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        //currMaxProductSubarr: This variable keeps track of the maximum product of a subarray that ends at the current index. For each element in the input array, we update the value of currMaxProductSubarr based on the maximum product that can be obtained by considering the current element and the maximum and minimum product of the subarray that ends at the previous index.\\n        int currMaxProductSubarr = nums[0];\\n        //currMinProductSubarr: This variable keeps track of the minimum product of a subarray that ends at the current index. As with currMaxProductSubarr, we update the value of currMinProductSubarr at each index based on the minimum product that can be obtained by considering the current element and the maximum and minimum product of the subarray that ends at the previous index.\\n        int currMinProductSubarr = nums[0];\\n        //maxProductAns: This variable keeps track of the maximum product obtained so far. At each index, we compare the value of currMaxProductSubarr with the current value of maxProductAns and update maxProductAns if currMaxProductSubarr is greater than the current value of maxProductAns. By doing so, we ensure that maxProductAns always stores the maximum product obtained from any subarray in nums up to the current index.\\n        int maxProductAns = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            int temp = currMaxProductSubarr;\\n            //The maximum product of a subarray can be obtained by considering three possibilities:\\n                //The current element nums[i] alone forms a subarray with the maximum product. In this case, the maximum product of the subarray that ends at the current index is simply nums[i].\\n                //The current element nums[i] is positive and can be added to the existing subarray that ends at the previous index with the maximum product. In this case, the maximum product of the subarray that ends at the current index is the product of the current element nums[i] and the maximum product of the subarray that ends at the previous index, i.e., currMaxProductSubarr * nums[i].\\n                //The current element nums[i] is negative and can be added to the existing subarray that ends at the previous index with the minimum product. In this case, the maximum product of the subarray that ends at the current index is the product of the current element nums[i] and the minimum product of the subarray that ends at the previous index, i.e., currMinProductSubarr * nums[i].\\n            currMaxProductSubarr = max({nums[i], currMaxProductSubarr * nums[i], currMinProductSubarr * nums[i]});\\n            //The minimum product of a subarray can be obtained by considering three possibilities:\\n                //The current element nums[i] alone forms a subarray with the minimum product. In this case, the minimum product of the subarray that ends at the current index is simply nums[i].\\n                //The current element nums[i] is positive and can be added to the existing subarray that ends at the previous index with the minimum product. In this case, the minimum product of the subarray that ends at the current index is the product of the current element nums[i] and the minimum product of the subarray that ends at the previous index, i.e., currMinProductSubarr * nums[i].\\n                //The current element nums[i] is negative and can be added to the existing subarray that ends at the previous index with the maximum product. In this case, the minimum product of the subarray that ends at the current index is the product of the current element nums[i] and the maximum product of the subarray that ends at the previous index, i.e., temp * nums[i].\\n            currMinProductSubarr = min({nums[i], temp * nums[i], currMinProductSubarr * nums[i]});\\n            maxProductAns = max(maxProductAns, currMaxProductSubarr);\\n        }\\n        return maxProductAns;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n        int currMaxProductSubarr = nums[0];\\n        int currMinProductSubarr = nums[0];\\n        int maxProductAns = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            int temp = currMaxProductSubarr;\\n            currMaxProductSubarr = Math.max(nums[i], Math.max(currMaxProductSubarr * nums[i], currMinProductSubarr * nums[i]));\\n            currMinProductSubarr = Math.min(nums[i], Math.min(temp * nums[i], currMinProductSubarr * nums[i]));\\n            maxProductAns = Math.max(maxProductAns, currMaxProductSubarr);\\n        }\\n        return maxProductAns;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        currMaxProductSubarr = nums[0]\\n        currMinProductSubarr = nums[0]\\n        maxProductAns = nums[0]\\n        for i in range(1, n):\\n            temp = currMaxProductSubarr\\n            currMaxProductSubarr = max(nums[i], max(currMaxProductSubarr * nums[i], currMinProductSubarr * nums[i]))\\n            currMinProductSubarr = min(nums[i], min(temp * nums[i], currMinProductSubarr * nums[i]))\\n            maxProductAns = max(maxProductAns, currMaxProductSubarr)\\n        return maxProductAns\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n)**, where n is the length of the input array, as we are traversing the array only once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**, as we are using constant extra space to store the variables.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        //currMaxProductSubarr: This variable keeps track of the maximum product of a subarray that ends at the current index. For each element in the input array, we update the value of currMaxProductSubarr based on the maximum product that can be obtained by considering the current element and the maximum and minimum product of the subarray that ends at the previous index.\\n        int currMaxProductSubarr = nums[0];\\n        //currMinProductSubarr: This variable keeps track of the minimum product of a subarray that ends at the current index. As with currMaxProductSubarr, we update the value of currMinProductSubarr at each index based on the minimum product that can be obtained by considering the current element and the maximum and minimum product of the subarray that ends at the previous index.\\n        int currMinProductSubarr = nums[0];\\n        //maxProductAns: This variable keeps track of the maximum product obtained so far. At each index, we compare the value of currMaxProductSubarr with the current value of maxProductAns and update maxProductAns if currMaxProductSubarr is greater than the current value of maxProductAns. By doing so, we ensure that maxProductAns always stores the maximum product obtained from any subarray in nums up to the current index.\\n        int maxProductAns = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            int temp = currMaxProductSubarr;\\n            //The maximum product of a subarray can be obtained by considering three possibilities:\\n                //The current element nums[i] alone forms a subarray with the maximum product. In this case, the maximum product of the subarray that ends at the current index is simply nums[i].\\n                //The current element nums[i] is positive and can be added to the existing subarray that ends at the previous index with the maximum product. In this case, the maximum product of the subarray that ends at the current index is the product of the current element nums[i] and the maximum product of the subarray that ends at the previous index, i.e., currMaxProductSubarr * nums[i].\\n                //The current element nums[i] is negative and can be added to the existing subarray that ends at the previous index with the minimum product. In this case, the maximum product of the subarray that ends at the current index is the product of the current element nums[i] and the minimum product of the subarray that ends at the previous index, i.e., currMinProductSubarr * nums[i].\\n            currMaxProductSubarr = max({nums[i], currMaxProductSubarr * nums[i], currMinProductSubarr * nums[i]});\\n            //The minimum product of a subarray can be obtained by considering three possibilities:\\n                //The current element nums[i] alone forms a subarray with the minimum product. In this case, the minimum product of the subarray that ends at the current index is simply nums[i].\\n                //The current element nums[i] is positive and can be added to the existing subarray that ends at the previous index with the minimum product. In this case, the minimum product of the subarray that ends at the current index is the product of the current element nums[i] and the minimum product of the subarray that ends at the previous index, i.e., currMinProductSubarr * nums[i].\\n                //The current element nums[i] is negative and can be added to the existing subarray that ends at the previous index with the maximum product. In this case, the minimum product of the subarray that ends at the current index is the product of the current element nums[i] and the maximum product of the subarray that ends at the previous index, i.e., temp * nums[i].\\n            currMinProductSubarr = min({nums[i], temp * nums[i], currMinProductSubarr * nums[i]});\\n            maxProductAns = max(maxProductAns, currMaxProductSubarr);\\n        }\\n        return maxProductAns;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n        int currMaxProductSubarr = nums[0];\\n        int currMinProductSubarr = nums[0];\\n        int maxProductAns = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            int temp = currMaxProductSubarr;\\n            currMaxProductSubarr = Math.max(nums[i], Math.max(currMaxProductSubarr * nums[i], currMinProductSubarr * nums[i]));\\n            currMinProductSubarr = Math.min(nums[i], Math.min(temp * nums[i], currMinProductSubarr * nums[i]));\\n            maxProductAns = Math.max(maxProductAns, currMaxProductSubarr);\\n        }\\n        return maxProductAns;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        currMaxProductSubarr = nums[0]\\n        currMinProductSubarr = nums[0]\\n        maxProductAns = nums[0]\\n        for i in range(1, n):\\n            temp = currMaxProductSubarr\\n            currMaxProductSubarr = max(nums[i], max(currMaxProductSubarr * nums[i], currMinProductSubarr * nums[i]))\\n            currMinProductSubarr = min(nums[i], min(temp * nums[i], currMinProductSubarr * nums[i]))\\n            maxProductAns = max(maxProductAns, currMaxProductSubarr)\\n        return maxProductAns\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48448,
                "title": "a-o-n-solution-though-not-as-great-as-answer-provided-by-leetcode",
                "content": "I feel this is a bit more intuitive way to approach; here is my thought:\\n\\n 1. given an array of integers, the max product ignoring sign (i.e., absolute\\n    value) is simply the product of all the elements, as long there is\\n    no 0. put another way, the more elements, the bigger.\\n 2. but we have to consider the sign. so if product is negative, we have odd number of negatives; then\\n    the max product is the bigger of: \\n\\n    a) product of all excluding elements on the left, up to the first negative element.\\n\\n    b) product of all excluding elements on the right, up to the last negative element.\\n\\n\\nso the solution is calculate product, first from left to right, then from right to left; during the process we are guaranteed to encounter the max product; and whenever 0 is encountered, reset product to 1 and continue.\\n\\n\\n    public int maxProduct(int[] A) {\\n        // edge case\\n        if (A == null || A.length == 0)\\n            return 0;\\n            \\n        int max = Integer.MIN_VALUE;\\n        int product = 1;\\n        // first go from left to right\\n        for (int i = 0; i < A.length; i++) {\\n            product *= A[i];\\n            if (product > max)\\n                max = product;\\n            if (product == 0)\\n                product = 1; // reset if encounter 0\\n        }\\n        \\n        // then go from right to left\\n        product = 1;\\n        for (int i = A.length - 1; i >= 0; i--) {\\n            product *= A[i];\\n            if (product > max)\\n                max = product;\\n            if (product == 0)\\n                product = 1; // reset if encounter 0\\n        }\\n    \\n        return max;\\n    }\\n\\nsince this requires 2 iterations, it's not as optimal as solution provided by Leetcode, of course.",
                "solutionTags": [],
                "code": "I feel this is a bit more intuitive way to approach; here is my thought:\\n\\n 1. given an array of integers, the max product ignoring sign (i.e., absolute\\n    value) is simply the product of all the elements, as long there is\\n    no 0. put another way, the more elements, the bigger.\\n 2. but we have to consider the sign. so if product is negative, we have odd number of negatives; then\\n    the max product is the bigger of: \\n\\n    a) product of all excluding elements on the left, up to the first negative element.\\n\\n    b) product of all excluding elements on the right, up to the last negative element.\\n\\n\\nso the solution is calculate product, first from left to right, then from right to left; during the process we are guaranteed to encounter the max product; and whenever 0 is encountered, reset product to 1 and continue.\\n\\n\\n    public int maxProduct(int[] A) {\\n        // edge case\\n        if (A == null || A.length == 0)\\n            return 0;\\n            \\n        int max = Integer.MIN_VALUE;\\n        int product = 1;\\n        // first go from left to right\\n        for (int i = 0; i < A.length; i++) {\\n            product *= A[i];\\n            if (product > max)\\n                max = product;\\n            if (product == 0)\\n                product = 1; // reset if encounter 0\\n        }\\n        \\n        // then go from right to left\\n        product = 1;\\n        for (int i = A.length - 1; i >= 0; i--) {\\n            product *= A[i];\\n            if (product > max)\\n                max = product;\\n            if (product == 0)\\n                product = 1; // reset if encounter 0\\n        }\\n    \\n        return max;\\n    }\\n\\nsince this requires 2 iterations, it's not as optimal as solution provided by Leetcode, of course.",
                "codeTag": "Unknown"
            },
            {
                "id": 841167,
                "title": "c-super-simple-clean-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) \\n    {\\n\\t\\t// empty array case\\n\\t\\tif (nums.size() == 0)\\n\\t\\t\\treturn 0;\\n\\t\\t\\t\\n\\t    // maxSub and minSub will hold the products till nums[i]\\n        int maxSub = nums[0];   \\n        int minSub = nums[0];\\n        int maxProductSub = nums[0];\\n        \\n        for (size_t i = 1; i < nums.size(); i++)\\n        {\\n            // element is negative so we swap max and min\\n            // because when multiplying negative with a negative, number becomes positive so minimum negative number will become the maximum number\\n            if (nums[i] < 0)\\n                swap(minSub, maxSub);\\n      \\n            // update all the sub values\\n\\t\\t\\tmaxSub = max(maxSub * nums[i], nums[i]); \\n            minSub = min(minSub * nums[i], nums[i]); \\n            // choose max product to be the max between the maxProduct till now and maxSub\\n\\t\\t\\tmaxProductSub = max(maxProductSub, maxSub); \\n        }\\n\\t\\t\\n        return maxProductSub;\\n    }\\n   \\n};\\n \\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) \\n    {\\n\\t\\t// empty array case\\n\\t\\tif (nums.size() == 0)\\n\\t\\t\\treturn 0;\\n\\t\\t\\t\\n\\t    // maxSub and minSub will hold the products till nums[i]\\n        int maxSub = nums[0];   \\n        int minSub = nums[0];\\n        int maxProductSub = nums[0];\\n        \\n        for (size_t i = 1; i < nums.size(); i++)\\n        {\\n            // element is negative so we swap max and min\\n            // because when multiplying negative with a negative, number becomes positive so minimum negative number will become the maximum number\\n            if (nums[i] < 0)\\n                swap(minSub, maxSub);\\n      \\n            // update all the sub values\\n\\t\\t\\tmaxSub = max(maxSub * nums[i], nums[i]); \\n            minSub = min(minSub * nums[i], nums[i]); \\n            // choose max product to be the max between the maxProduct till now and maxSub\\n\\t\\t\\tmaxProductSub = max(maxProductSub, maxSub); \\n        }\\n\\t\\t\\n        return maxProductSub;\\n    }\\n   \\n};\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328132,
                "title": "simple-and-easy-c-code-with-explanation",
                "content": "In the naive solution, we traverse over every contiguous sub arrays, find the product of every sub array and return the maximum product from all sub arrays. But it has time complexity of O(n\\xB2).\\n\\n**Efficient Approach:**\\nThe approach is to traverse the array by maintaining two variables **min_so_far** and **max_so_far**. Now while traversing if the present element at **i**th index is negative we ***swap*** the **min_so_far** and **max_so_far** so that by multiplying negative number with  minimum value gives a maximum value.\\nThe **max_so_far** depends on the maximum of ***current element*** and ***the product of current element with previous max_so_far***.\\nThe **min_so_far** depends on the minimum of ***current element*** and ***the product of current element with previous min_so_far***.\\nAnother variable **max_product** is maintained to find maximum product of sub arrays upto that iteration and max_product is finally returned after all iterations.\\nThis approach is of time complexity **O(n)** and space complexity of **O(1)**.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int max_so_far = nums[0], min_so_far = nums[0], max_product = nums[0];\\n        int n = nums.size();\\n        \\n        for(int i=1;i<n;i++){\\n            if(nums[i]<0) swap(max_so_far, min_so_far);\\n            max_so_far = max(nums[i], nums[i]*max_so_far);\\n            min_so_far = min(nums[i], nums[i]*min_so_far);\\n            // At each iteration max_product is calculated as the maximum of previous maxproduct and max_so_far at that iteration.\\n            max_product = max(max_product, max_so_far);\\n        }\\n        return max_product;\\n    }\\n};\\n```\\nLet us take an example array **nums[ ] = {-8,5,-3,0,30};**\\nThe change at each iteration is as follows:\\n![image](https://assets.leetcode.com/users/images/3a5f0b66-2c9b-42d4-810c-e7645110e38d_1625895684.9695432.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int max_so_far = nums[0], min_so_far = nums[0], max_product = nums[0];\\n        int n = nums.size();\\n        \\n        for(int i=1;i<n;i++){\\n            if(nums[i]<0) swap(max_so_far, min_so_far);\\n            max_so_far = max(nums[i], nums[i]*max_so_far);\\n            min_so_far = min(nums[i], nums[i]*min_so_far);\\n            // At each iteration max_product is calculated as the maximum of previous maxproduct and max_so_far at that iteration.\\n            max_product = max(max_product, max_so_far);\\n        }\\n        return max_product;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48339,
                "title": "c-solution-4ms-explained",
                "content": "    int maxProduct(vector<int>& nums) {\\n        if(nums.empty()) {\\n            return 0;\\n        }\\n        int currentMax = nums[0];\\n        int currentMin = nums[0];\\n        int maxProduct = nums[0];\\n        \\n        for(size_t i = 1; i < nums.size(); ++i) {\\n            //calculate our new possibilities for this round\\n            int p1 = currentMax * nums[i];\\n            int p2 = currentMin * nums[i];\\n            //our currentMax will be either p1 or p2 or nums[i] whichever is bigger\\n            currentMax = max(nums[i], max(p1, p2));\\n            //our currentMin will be either p1 or p2 or nums[i] whichever is smaller\\n            currentMin = min(nums[i], min(p1, p2));\\n            //our maxProduct will be our currentMax or our maxProduct, whichever is bigger.\\n            maxProduct = currentMax > maxProduct ? currentMax : maxProduct;\\n        }\\n        return maxProduct;\\n    }\\n\\nSo all you care about is keeping track of the highest possible max so far.\\n\\nApart from that you need to keep track of your highest possible in the subarray. Lookup kadanes algorithm for this.\\n\\nSince we can have negative numbers you need to keep track of your lowest possible in the subarray.\\nThis is because your lowest which might be negative can become your highest when multiplied by a negative number.\\n\\nBy keeping track of these both you have your highest and lowest which can invert themselves.",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int maxProduct(vector<int>& nums) {\\n        if(nums.empty()) {\\n            return 0;\\n        }\\n        int currentMax = nums[0];\\n        int currentMin = nums[0];\\n        int maxProduct = nums[0];\\n        \\n        for(size_t i = 1; i < nums.size(); ++i) {\\n            //calculate our new possibilities for this round\\n            int p1 = currentMax * nums[i];\\n            int p2 = currentMin * nums[i];\\n            //our currentMax will be either p1 or p2 or nums[i] whichever is bigger\\n            currentMax = max(nums[i], max(p1, p2));\\n            //our currentMin will be either p1 or p2 or nums[i] whichever is smaller\\n            currentMin = min(nums[i], min(p1, p2));\\n            //our maxProduct will be our currentMax or our maxProduct, whichever is bigger.\\n            maxProduct = currentMax > maxProduct ? currentMax : maxProduct;\\n        }\\n        return maxProduct;\\n    }\\n\\nSo all you care about is keeping track of the highest possible max so far.\\n\\nApart from that you need to keep track of your highest possible in the subarray. Lookup kadanes algorithm for this.\\n\\nSince we can have negative numbers you need to keep track of your lowest possible in the subarray.\\nThis is because your lowest which might be negative can become your highest when multiplied by a negative number.\\n\\nBy keeping track of these both you have your highest and lowest which can invert themselves.",
                "codeTag": "Unknown"
            },
            {
                "id": 1094388,
                "title": "python-easy-sol-with-explanation-o-n",
                "content": "\\'\\'\\'Success\\nDetails \\nRuntime: 44 ms, faster than 98.96% of Python3 online submissions for Maximum Product Subarray.\\nMemory Usage: 14.5 MB, less than 41.20% of Python3 online submissions for Maximum Product Subarray\\'\\'\\'\\n\\nUsing Kadane\\'s algorithm. Basically we are storing max and min product and the storing the max_pro in results at each iteration and checking which is the max the current result or the current max_pro. The reason behind taking so the min_pro so that we know which is the min one. You can modify this code according to your wish.\\n\\n        if len(nums)==0:\\n            return 0\\n        \\n        max_pro , min_pro = nums[0], nums[0]\\n            \\n        #result will store the final max product\\n        result = max_pro\\n            \\n        for i in range(1, len(nums)):\\n            current = nums[i]\\n            \\n            temp_max = max( current ,  max_pro*current, current*min_pro)\\n            \\n            min_pro = min( current ,  max_pro*current, current*min_pro)\\n            \\n            max_pro = temp_max\\n            \\n            result = max(result, max_pro)\\n        \\n        return result\\n\\t\\t\\nIf you find it helpful please upvote.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\'\\'\\'Success\\nDetails \\nRuntime: 44 ms, faster than 98.96% of Python3 online submissions for Maximum Product Subarray.\\nMemory Usage: 14.5 MB, less than 41.20% of Python3 online submissions for Maximum Product Subarray\\'\\'\\'\\n\\nUsing Kadane\\'s algorithm. Basically we are storing max and min product and the storing the max_pro in results at each iteration and checking which is the max the current result or the current max_pro. The reason behind taking so the min_pro so that we know which is the min one. You can modify this code according to your wish.\\n\\n        if len(nums)==0:\\n            return 0\\n        \\n        max_pro , min_pro = nums[0], nums[0]\\n            \\n        #result will store the final max product\\n        result = max_pro\\n            \\n        for i in range(1, len(nums)):\\n            current = nums[i]\\n            \\n            temp_max = max( current ,  max_pro*current, current*min_pro)\\n            \\n            min_pro = min( current ,  max_pro*current, current*min_pro)\\n            \\n            max_pro = temp_max\\n            \\n            result = max(result, max_pro)\\n        \\n        return result\\n\\t\\t\\nIf you find it helpful please upvote.",
                "codeTag": "Unknown"
            },
            {
                "id": 841176,
                "title": "python-dp-solution-explained",
                "content": "Let `dp1[i]` be the maximum product which ends with `i`-th index and `dp2[i]` be the minimum product which ends with `i`-the index. Why we need both maximum and minimum? Because we can have big negative number, which then multiplied by negative will give big positive number.\\n\\nSo, let us traverse all numbers and update our `dp1` and `dp2`:\\n1. If `nums[k] > 0`, then biggest number `dp1[k]` can be found as maximum of `dp1[k-1] * nums[k]` and `nums[k]`. The smallest number `dp2[k]` is equal to minimum of `dp2[k-1] * nums[k] and nums[k]`\\n2. If `nums[k] <= 0`, then the biggest number is maximum of `dp2[k-1] * nums[k]` and `nums[k]`  and the smalles number `dp2[k]` is minimum of  `dp1[k-1] * nums[k]` and `nums[k]`\\n3. Finally, we return maximum of `dp1`.\\n\\n**Complexity**: both time and space is `O(n)`. Space complexity can be improved to `O(1)`, because we always use only previous elements in our `dp1` and `dp2` tables.\\n\\n```\\nclass Solution:\\n    def maxProduct(self, nums):\\n        N = len(nums)\\n        dp1 = [0] * N\\n        dp2 = [0] * N\\n        dp1[0] = dp2[0] = nums[0]\\n        \\n        for k in range(1, N):\\n            if nums[k] > 0:\\n                dp1[k] = max(dp1[k-1] * nums[k], nums[k])\\n                dp2[k] = min(dp2[k-1] * nums[k], nums[k])\\n            else:\\n                dp1[k] = max(dp2[k-1] * nums[k], nums[k])\\n                dp2[k] = min(dp1[k-1] * nums[k], nums[k])\\n        \\n        return max(dp1)      \\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums):\\n        N = len(nums)\\n        dp1 = [0] * N\\n        dp2 = [0] * N\\n        dp1[0] = dp2[0] = nums[0]\\n        \\n        for k in range(1, N):\\n            if nums[k] > 0:\\n                dp1[k] = max(dp1[k-1] * nums[k], nums[k])\\n                dp2[k] = min(dp2[k-1] * nums[k], nums[k])\\n            else:\\n                dp1[k] = max(dp2[k-1] * nums[k], nums[k])\\n                dp2[k] = min(dp1[k-1] * nums[k], nums[k])\\n        \\n        return max(dp1)      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118574,
                "title": "modification-of-kadane-s-algorithim-java-time-o-n-and-space-o-1",
                "content": "Idea is very similar to [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/discuss/1108980/Thought-Process-and-O(N)-java-solution) i.e either start subarray from myself or be a part of previous subarray. but here we are looking for product and negative*negative became Positive. So Little modification in Kadane\\'s Algorithm is needed here:\\n\\nIdea is to maintain maximum positive product and minimum negative product till previous .It will help us to find maximum positive product (as neg*neg = Positive) . and keep update omax and mpp and mnp.\\n**mpp: maximum** positive product\\n**mnp:minimum** negative product\\nomax: overall maximum\\n\\n2. now If I am positive value \\n 2.1 mpp = Math.max(val,mpp* val)\\n 2.2 mnp=Math.min(val,mnp* val)\\n\\n3.If I am negative value so mpp will be updated by mnp* current val\\n 3.1 mpp=Math.max(val,mnp* val);\\n 3.2 mnp=Math.min(val,mpp* val);  // **keep in mind that u have updated mpp** in previous step and you want mpp till previous. will handle that part in code\\n\\nyou have some idea now **Code will give you more clearity** :) \\n```\\n public int maxProduct(int[] nums) {\\n        int mpp=nums[0]; // mpp: maximum Positive Product\\n        int mnp=nums[0]; // mnp: Minimum Negative Product\\n        int omax=nums[0]; // overall maximum Product\\n        \\n        \\n        for(int i=1;i<nums.length;i++){\\n            \\n            int val=nums[i];\\n            if(val<0){\\n                int temp1=mnp;\\n                int temp2=mpp;\\n              mpp=Math.max(val,temp1*val);\\n              mnp=Math.min(val,temp2*val);  \\n            }else{\\n               mpp=Math.max(val,val*mpp);\\n               mnp=Math.min(val,val*mnp); \\n            }\\n            omax=Math.max(mpp,omax);\\n            \\n        }\\n        \\n        return omax;\\n        \\n    }\\n```\\n**Time :O(N) and Space:O(1)**\\nPlease **Upvote** if found it helpful:)\\n\\n###### Advice for you :\\n###### 1.Confirm your interviewer that array is containing negative values or not .(If he/she told no then ask what about zero..)\\n###### 2.can Product of number can exceed the Integer.MAX value ?\\n###### 3.Don\\'t just rush to coding part without Clarifying these things else you may get rejection even after solving the question in most optmised way.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int maxProduct(int[] nums) {\\n        int mpp=nums[0]; // mpp: maximum Positive Product\\n        int mnp=nums[0]; // mnp: Minimum Negative Product\\n        int omax=nums[0]; // overall maximum Product\\n        \\n        \\n        for(int i=1;i<nums.length;i++){\\n            \\n            int val=nums[i];\\n            if(val<0){\\n                int temp1=mnp;\\n                int temp2=mpp;\\n              mpp=Math.max(val,temp1*val);\\n              mnp=Math.min(val,temp2*val);  \\n            }else{\\n               mpp=Math.max(val,val*mpp);\\n               mnp=Math.min(val,val*mnp); \\n            }\\n            omax=Math.max(mpp,omax);\\n            \\n        }\\n        \\n        return omax;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 48245,
                "title": "my-python-code-for-maximum-product-subarray",
                "content": "    class Solution:\\n    # @param A, a list of integers\\n    # @return an integer\\n    def maxProduct(self, A):\\n        MinTemp = A[0]\\n        MaxTemp = A[0]\\n        Max = A[0]\\n        for i in xrange(1, len(A)):\\n            MinTemp, MaxTemp = min(A[i], A[i] * MaxTemp, A[i] * MinTemp), max(A[i], A[i] * MaxTemp, A[i] * MinTemp)\\n            Max = max(Max, MaxTemp)\\n        return Max\\n\\nSave Min value and Max value at each node and the result works out.",
                "solutionTags": [],
                "code": "    class Solution:\\n    # @param A, a list of integers\\n    # @return an integer\\n    def maxProduct(self, A):\\n        MinTemp = A[0]\\n        MaxTemp = A[0]\\n        Max = A[0]\\n        for i in xrange(1, len(A)):\\n            MinTemp, MaxTemp = min(A[i], A[i] * MaxTemp, A[i] * MinTemp), max(A[i], A[i] * MaxTemp, A[i] * MinTemp)\\n            Max = max(Max, MaxTemp)\\n        return Max\\n\\nSave Min value and Max value at each node and the result works out.",
                "codeTag": "Java"
            },
            {
                "id": 759813,
                "title": "c-easy-solution-o-1-space-and-o-n-time-complexity",
                "content": "We can solve it using dynamic programming. If it was a maximum sum problem, we would have stored the minimum sum seen so far and subtract that from the current sum to get the maximum sum at that index.\\n\\nFor finding the maximum product, since all the numbers are integer, so we know that the product would be maximum when either we multiply the negative number with a negative number or positive number with a positive number. \\n\\nIf the negative number comes, then we should swap our maximum productn with minimum, because it will now make the maximum more less. For example, maxi=4 and mini=-2 and nums[i]=-2., then the larger number would now become smaller then smaller number.\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n     int r=nums[0];\\n     int maxi=r;\\n     int mini=r;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                int temp=maxi;\\n                maxi=mini;\\n                mini=temp;\\n            }\\n            maxi=max(nums[i],nums[i]*maxi);\\n            mini=min(nums[i],nums[i]*mini);\\n            r=max(r,maxi);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n     int r=nums[0];\\n     int maxi=r;\\n     int mini=r;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                int temp=maxi;\\n                maxi=mini;\\n                mini=temp;\\n            }\\n            maxi=max(nums[i],nums[i]*maxi);\\n            mini=min(nums[i],nums[i]*mini);\\n            r=max(r,maxi);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361537,
                "title": "java-readable-solution-time-o-n-beats-99-space-o-1-beats-100",
                "content": "```\\n/*\\nidea is to keep 3 variables\\n1. max -> maximum product ending at a[i]\\n2. min -> minimum product ending at a[i]\\n3. ans -> maximum product subarray\\n\\nEx.\\nnum = [3, 2, -1,   5, -2]\\nmin = [3, 2, -6, -30, -2]\\nmax = [3, 6, -1,   5, 60]\\nans = [3, 6,  6,   6, 60]\\n*/\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        if(nums==null||nums.length==0) return 0;\\n        int max = nums[0];\\n        int min = nums[0];\\n        int ans = nums[0];\\n        int temp;\\n        for(int i=1;i<nums.length;i++) {\\n            if(nums[i]<0) {\\n                temp = max;\\n                max = min;\\n                min = temp;\\n            }\\n            max = Integer.max(nums[i],nums[i]*max);\\n            min = Integer.min(nums[i],nums[i]*min);\\n            ans = Integer.max(ans,max);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\nidea is to keep 3 variables\\n1. max -> maximum product ending at a[i]\\n2. min -> minimum product ending at a[i]\\n3. ans -> maximum product subarray\\n\\nEx.\\nnum = [3, 2, -1,   5, -2]\\nmin = [3, 2, -6, -30, -2]\\nmax = [3, 6, -1,   5, 60]\\nans = [3, 6,  6,   6, 60]\\n*/\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        if(nums==null||nums.length==0) return 0;\\n        int max = nums[0];\\n        int min = nums[0];\\n        int ans = nums[0];\\n        int temp;\\n        for(int i=1;i<nums.length;i++) {\\n            if(nums[i]<0) {\\n                temp = max;\\n                max = min;\\n                min = temp;\\n            }\\n            max = Integer.max(nums[i],nums[i]*max);\\n            min = Integer.min(nums[i],nums[i]*min);\\n            ans = Integer.max(ans,max);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781113,
                "title": "kadane-s-algo-for-maximum-product-subarray",
                "content": "# First I  thought \\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is similar to max sum subarray using kadane\\'s algo. So i used the following code \\n\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n         int currentPro=Integer.MIN_VALUE;\\n        int prevPro=1;\\n\\n        for(int i =0; i<nums.length; i++){\\n            prevPro*=nums[i];\\n          \\n            if(prevPro> currentPro){\\n                currentPro=prevPro;\\n            }\\n            if(prevPro<0){\\n                prevPro=1;\\n            }\\n        }\\n      \\n        return currentPro;\\n    }\\n}\\n```\\n\\n# But failed because \\n\\nTwo negative numbers are added to make negative number but if two negative numbers are multiplied to make a positive number\\n\\n# Thus, I need\\n\\nTo take care of the current product (which is maximum product now) and the previous product (which became minimum product)\\n\\nif negative number comes say -1 and suppose if current product =4 (max) and previous product = -2 (min) \\n\\nthen 4 * (-1) = - 4 and -2 * (-1) = 2 \\n\\nDue to negative number, minproduct becomes max and maxproduct becomes minimum. \\n\\nIf I use this maxproduct (which has became minimum) then the answer will be wrong because I want maximum product to update the answer \\n\\nThus, I need to swap the min and max products so that the minimum product will give me the maximum value and I can use this value to update the answer. \\n\\n**So, technically while explaining to interviewer, you can say that this is the variation of Kadane\\'s algo. But the difference is that for max-sum subarray we were taking care of the maxsum but here, we need to take care of maxproduct as well as minproduct because minproduct helps to eliminate the problem of (-)  * (-) = (+) in the array**\\n\\nTC= O(n) and SC=O(1)\\n # Code\\n ```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int maxPro=nums[0];\\n        int minPro=nums[0];\\n        int answer = nums[0];\\n\\n        for(int i =1; i<nums.length; i++){\\n            if(nums[i]<0){\\n                // if next is -1 and maxpro=4 then 4 x -1 = -4 which is minimum \\n                // thus swap maxPro and minPro\\n                int temp=maxPro;\\n                maxPro=minPro;\\n                minPro=temp;  \\n            }\\n    // maxproduct \\n             maxPro= Math.max( maxPro*nums[i],   nums[i]);\\n    // minimum product \\n             minPro= Math.min( minPro*nums[i], nums[i]);\\n             \\n             answer=Math.max(answer, maxPro);\\n             \\n        }\\n      \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n         int currentPro=Integer.MIN_VALUE;\\n        int prevPro=1;\\n\\n        for(int i =0; i<nums.length; i++){\\n            prevPro*=nums[i];\\n          \\n            if(prevPro> currentPro){\\n                currentPro=prevPro;\\n            }\\n            if(prevPro<0){\\n                prevPro=1;\\n            }\\n        }\\n      \\n        return currentPro;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int maxPro=nums[0];\\n        int minPro=nums[0];\\n        int answer = nums[0];\\n\\n        for(int i =1; i<nums.length; i++){\\n            if(nums[i]<0){\\n                // if next is -1 and maxpro=4 then 4 x -1 = -4 which is minimum \\n                // thus swap maxPro and minPro\\n                int temp=maxPro;\\n                maxPro=minPro;\\n                minPro=temp;  \\n            }\\n    // maxproduct \\n             maxPro= Math.max( maxPro*nums[i],   nums[i]);\\n    // minimum product \\n             minPro= Math.min( minPro*nums[i], nums[i]);\\n             \\n             answer=Math.max(answer, maxPro);\\n             \\n        }\\n      \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304366,
                "title": "javascript-beats-99-intuition-behind-how-to-solve-this-problem-explained-as-clearly-as-possible",
                "content": "Code is at the bottom.\\n\\n**TLDR** Keep track of both the maximum and minimum products, since at any point, a `negative number * negative number` = `positive number`. So you can\\'t just keep track of the max positive product and not care about the negative - maybe that negative can become positive too, and claim the throne.\\n\\nAlso, since this problem is asking for a **contiguous subarray**, we can\\'t use the usual `m x n` DP array method, because you would end up keeping track of a **subset**, which is disconnected/disjointed, and not contiguous.\\n\\nFor example, for `[2, 3, -2, 4]`, you cannot *selfishly hold onto 2*3 = 6*, then somehow multiply by the very last `4` to get a final answer of `24`. Too bad. i.e. you can\\'t do the product of `[2, 3, _, 4]`.\\n\\nIn this problem you don\\'t even need to use an array to keep track of values. The problem boils down to the following: as I step through the array, every new number I see presents me with **THREE CHOICES**:\\n\\na) the previous max * the current number\\nb) the previous min * the current number\\nc) the current number\\n\\nThus, the current max, and the current min, will be determined based off:\\n- max(a, b, c)\\n- min(a, b, c)\\n\\nAnd the `maxSoFar`, the answer we will eventually return, is simply the max of the two numbers above.\\n\\nNote that a) and b) might swap - a big number multipled by a negative number ends up a big negative number. Things can switch between night and day at the snap of a finger.\\n\\nTo be even more clear, this is an Excel chart to see what happens for `[2, 3, -2, 4]`:\\n![image](https://assets.leetcode.com/users/lcgt/image_1559513982.png)\\nHow to read this: go down and right. We are iterating through the array downwards on column A; column B shows us the 3 choices a, b, and c).\\n\\n**EXPLANATION BELOW IS A BIT WORDY AND CONVOLUTED**\\n\\nSo for example, the \"6, 2, 2\" when current num = 3 is because:\\na) `prevMax * currentNum` = `2 * 3` = `6`\\nb) `currentNum` = `3`\\nc) `prevMin * currentNum` = `2 * 3` = `6`.\\nNothing weird here. We proclaim `6` the current max, `2` the current min. Max so far is `6`.\\n\\nBut for the next iteration (currentNum = -2), things are a little different. What happens is that:\\na) `prevMax * currentNum` = `6 * -2` = `-12`\\nb) `currentNum` = `-2`\\nc) `prevMin * currentNum` = `2 * -2` = `-4`.\\n\\nSuddenly, our proclaimed previous max now ends up as the lowest number, `-12`! That\\'s terrible. But this number could still be useful **if we ever see another negative number again**, because then the `-12` would turn positive again and become the biggest number we will see. OR, it might not - still, we must keep hope. **So that\\'s the intution behind the question - you must keep hope on both the positive and negative side.**\\n\\nAnd in some cases, maybe the current number is the best you\\'ll ever get.\\n\\nIn this iteration, its obvious that the numbers are all really low - so its best that we keep our `maxSoFar` of `6`. We are not allowed to multiply `maxSoFar` with any current number or value, otherwise that would be going back to a non-contiguous solution. `prevMax` now takes on `-2`, since `-12` is way too low - `prevMin` will hold onto `-12` instead.\\n\\nFinally, we see in the last iteration that \\na) `prevMax * currentNum` = `-2 * 4` = `-8`\\nb) `currentNum` = `4`\\nc) `prevMin * currentNum` = `-12 * 4` = `-48`.\\n\\nNotice that the `prevMax` was previously set to the lesser of the negatives. However, `-8` is still low. The highest number of these 3 choices is actually `4`. Unfortunately, it still doesn\\'t outshine our previous max product - `2*3=6`.\\n\\nSo the final answer is `6`.\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxProduct = function(nums) {\\n    \\n    if(!nums && !nums.length) return nums;\\n    \\n    const n = nums.length;\\n    \\n    let prevMax = nums[0];\\n    let prevMin = nums[0];\\n    let maxSoFar = nums[0];\\n    \\n    for(let i=1; i<n; i++){\\n        // choices: 1) prevMax * nums[i], 2) nums[i], 3) prevMin * nums[i]\\n        let localMax = Math.max(prevMax * nums[i], nums[i], prevMin * nums[i]);\\n        let localMin = Math.min(prevMax * nums[i], nums[i], prevMin * nums[i]);\\n        \\n        // max and min could have swapped\\n        prevMax = Math.max(localMax, localMin);\\n        prevMin = Math.min(localMax, localMin);\\n        \\n        maxSoFar = Math.max(maxSoFar, prevMax);\\n    }\\n    \\n    return maxSoFar;\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxProduct = function(nums) {\\n    \\n    if(!nums && !nums.length) return nums;\\n    \\n    const n = nums.length;\\n    \\n    let prevMax = nums[0];\\n    let prevMin = nums[0];\\n    let maxSoFar = nums[0];\\n    \\n    for(let i=1; i<n; i++){\\n        // choices: 1) prevMax * nums[i], 2) nums[i], 3) prevMin * nums[i]\\n        let localMax = Math.max(prevMax * nums[i], nums[i], prevMin * nums[i]);\\n        let localMin = Math.min(prevMax * nums[i], nums[i], prevMin * nums[i]);\\n        \\n        // max and min could have swapped\\n        prevMax = Math.max(localMax, localMin);\\n        prevMin = Math.min(localMax, localMin);\\n        \\n        maxSoFar = Math.max(maxSoFar, prevMax);\\n    }\\n    \\n    return maxSoFar;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 48389,
                "title": "my-concise-dp-o-n-java-solution-with-o-1-extra-space",
                "content": "    public int maxProduct(int[] A) {\\n       int min;\\n       int res = A[0], max = min = A[0]; // max, min means max and min product among the subarrays whose last element is A[i].\\n       for (int i = 1; i < A.length; i++) {\\n    \\t   if (A[i] > 0) {\\n    \\t\\t   max = Math.max(max * A[i], A[i]);\\n    \\t\\t   min = Math.min(min * A[i], A[i]);\\t\\t\\t   \\n    \\t   }\\n    \\t   else {\\n    \\t\\t   int lastMax = max;\\n    \\t\\t   max = Math.max(min * A[i], A[i]);\\n    \\t\\t   min = Math.min(lastMax * A[i], A[i]);\\t\\t\\t   \\t\\t\\t   \\n    \\t   }\\n    \\t   res = Math.max(res, max);\\n       }\\n       return res;\\n    }",
                "solutionTags": [],
                "code": "    public int maxProduct(int[] A) {\\n       int min;\\n       int res = A[0], max = min = A[0]; // max, min means max and min product among the subarrays whose last element is A[i].\\n       for (int i = 1; i < A.length; i++) {\\n    \\t   if (A[i] > 0) {\\n    \\t\\t   max = Math.max(max * A[i], A[i]);\\n    \\t\\t   min = Math.min(min * A[i], A[i]);\\t\\t\\t   \\n    \\t   }\\n    \\t   else {\\n    \\t\\t   int lastMax = max;\\n    \\t\\t   max = Math.max(min * A[i], A[i]);\\n    \\t\\t   min = Math.min(lastMax * A[i], A[i]);\\t\\t\\t   \\t\\t\\t   \\n    \\t   }\\n    \\t   res = Math.max(res, max);\\n       }\\n       return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 48403,
                "title": "simple-c-solution-in-8-lines",
                "content": "    class Solution {\\n    public:\\n        int maxProduct(vector<int>& nums) {\\n            if(nums.size() == 0) return 0;\\n            long long curmax = nums[0], curmin = nums[0], res = nums[0];\\n            for(int i=1; i<nums.size(); ++i){\\n                long long premax = curmax;\\n                curmax = max(curmax*nums[i], max(curmin*nums[i], (long long)nums[i]));\\n                curmin = min(premax*nums[i], min(curmin*nums[i], (long long)nums[i]));\\n                res = max(res, curmax);\\n            }\\n            return int(res);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxProduct(vector<int>& nums) {\\n            if(nums.size() == 0) return 0;\\n            long long curmax = nums[0], curmin = nums[0], res = nums[0];\\n            for(int i=1; i<nums.size(); ++i){\\n                long long premax = curmax;\\n                curmax = max(curmax*nums[i], max(curmin*nums[i], (long long)nums[i]));\\n                curmin = min(premax*nums[i], min(curmin*nums[i], (long long)nums[i]));\\n                res = max(res, curmax);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1609230,
                "title": "intuition-explained-two-approaches-c",
                "content": "The Brute force approach for the given problem will be, to generate all the possible subarrays and calculate the maximum product.\\n<a href=\"https://ibb.co/NmgStmr\"><img src=\"https://i.ibb.co/b2jJQ2F/1.jpg\" alt=\"1\" border=\"0\"></a>\\nThe code for the above approach will be:\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int ans = nums[0], mul;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mul= nums[i];\\n            ans = max(ans,mul);\\n            for(int j= i+1;j<nums.size();j++)\\n            {\\n                mul *= nums[j];\\n                ans= max(ans,mul);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nTime complexity : O(N^2)\\nAux. space : O(1)\\n\\n<b>Optimized approach:</b>\\nFirst of all, Let\\'s think about all the patterns that we can observe in this problem.\\n1) If all the numbers are positive the product is always increasing.\\nBut when it comes to negative numbers, It gets alot more tricky as the product of two negatives, is a positive.\\nWhen we have a vector of all negatives, the signs of the product will be alternating.\\neg. {-1,-2,-3,-4,-5} => -1, 2, -6, 24, -120\\n\\n<a href=\"https://ibb.co/tKX2QCg\"><img src=\"https://i.ibb.co/C829m0g/Screenshot-417.png\" alt=\"Screenshot-417\" border=\"0\"></a>\\n\\nso, to find maximum in such case, we need to track both maximum and minimum.\\nexample, in {-1,-2,-3} max of first two elements will be 2 and min will be -2\\nbut when combined with the third element -3, our min will become -2*-3 = 6 which is our desired answer.\\nI hope the reason of storing minimum is pretty clear now.\\n```\\nclass Solution {\\npublic:\\nint maxProduct(vector& nums) {\\n// declared ans to store the final max value till the iteraterd element of the array\\nint ans = nums[0];\\n// n is the size of the array\\nint n = nums.size();\\n// imax is the maximum product value till the iteraterd element of the array\\nint imax = ans;\\n\\n    // imin is the minimum product value till the iteraterd element of the array\\n    int imin = ans;\\n    \\n    for(int i=1;i<n;i++) {\\n        // If the array element is negative then is multiplied with the max product till now change it to minimum value and min product valu so far to maximum value. Thus swap the max and min value so far \\n        if(nums[i]<0)\\n            swap(imax,imin);\\n        imax = max(nums[i], imax*nums[i]);\\n        imin = min(nums[i], imin*nums[i]);\\n        ans = max(ans, imax);\\n    }\\n    // return the answer\\n    return ans;\\n}\\n};\\n```\\nTime Complexity: O(n) \\nAuxiliary Space: O(1)\\n\\n<b>Please upvote if it helped! :) </b>\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int ans = nums[0], mul;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mul= nums[i];\\n            ans = max(ans,mul);\\n            for(int j= i+1;j<nums.size();j++)\\n            {\\n                mul *= nums[j];\\n                ans= max(ans,mul);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint maxProduct(vector& nums) {\\n// declared ans to store the final max value till the iteraterd element of the array\\nint ans = nums[0];\\n// n is the size of the array\\nint n = nums.size();\\n// imax is the maximum product value till the iteraterd element of the array\\nint imax = ans;\\n\\n    // imin is the minimum product value till the iteraterd element of the array\\n    int imin = ans;\\n    \\n    for(int i=1;i<n;i++) {\\n        // If the array element is negative then is multiplied with the max product till now change it to minimum value and min product valu so far to maximum value. Thus swap the max and min value so far \\n        if(nums[i]<0)\\n            swap(imax,imin);\\n        imax = max(nums[i], imax*nums[i]);\\n        imin = min(nums[i], imin*nums[i]);\\n        ans = max(ans, imax);\\n    }\\n    // return the answer\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024596,
                "title": "my-recursive-to-memorized-dp-solution",
                "content": "**At every step we have 3 choices**\\n**1**. Take the number and multiply with the previous calculated value (continue calculation).\\n**2**. Do not take the previous calculated value, start the calculation from the current value (start new calculation).\\n**3**. Take the pre. calculated value and stop the calculation now (stop calculation).\\n\\nNow compare these 3 returned val from these 3 steps and return the max value.\\n\\n```\\nclass Solution {\\n    HashMap<String, Integer> dp;\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n        dp = new HashMap();\\n        if(n == 0) return 0;\\n        return util(nums, n, 0, 1);\\n    }\\n    int util(int[] nums, int n, int index, int t){\\n        if(index == n) return t;\\n        String key = \"\"+index+t;\\n        if(dp.containsKey(key)) return dp.get(key);       \\n        \\n\\t\\t// choice 1\\n        int x = util(nums, n, index+1, t*nums[index]);\\n\\t\\t// choice 2\\n        int y = util(nums, n, index+1, nums[index]);\\n        if(index == 0){\\n            t = nums[0];\\n        }\\n\\t\\t// keep the t (previous cal. value) and compare -> choice 3\\n        int ans = Math.max(t, Math.max(x, y));\\n        dp.put(key, ans);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<String, Integer> dp;\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n        dp = new HashMap();\\n        if(n == 0) return 0;\\n        return util(nums, n, 0, 1);\\n    }\\n    int util(int[] nums, int n, int index, int t){\\n        if(index == n) return t;\\n        String key = \"\"+index+t;\\n        if(dp.containsKey(key)) return dp.get(key);       \\n        \\n\\t\\t// choice 1\\n        int x = util(nums, n, index+1, t*nums[index]);\\n\\t\\t// choice 2\\n        int y = util(nums, n, index+1, nums[index]);\\n        if(index == 0){\\n            t = nums[0];\\n        }\\n\\t\\t// keep the t (previous cal. value) and compare -> choice 3\\n        int ans = Math.max(t, Math.max(x, y));\\n        dp.put(key, ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48348,
                "title": "share-simple-java-solution-with-explanation",
                "content": "Why do we need min value ? Because min value multiplies another min value will yield a possibly max value. That's why we need to keep track of min value as well. Otherwise, it will be no different than maximum subarray problem which we keep track of max value only. \\n\\n    public int maxProduct(int[] A) {\\n       if (A.length == 0) return 0;\\n       int max = A[0], min = A[0], totalMax = A[0];\\n       for (int i = 1; i < A.length; i++) {\\n           int tempMax = A[i] * max;\\n           int tempMin = A[i] * min;\\n           max = Math.max(Math.max(tempMax,tempMin), A[i]);\\n           min = Math.min(Math.min(tempMax,tempMin), A[i]);\\n           totalMax = Math.max(totalMax, max);\\n       }\\n       return totalMax;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "Why do we need min value ? Because min value multiplies another min value will yield a possibly max value. That's why we need to keep track of min value as well. Otherwise, it will be no different than maximum subarray problem which we keep track of max value only. \\n\\n    public int maxProduct(int[] A) {\\n       if (A.length == 0) return 0;\\n       int max = A[0], min = A[0], totalMax = A[0];\\n       for (int i = 1; i < A.length; i++) {\\n           int tempMax = A[i] * max;\\n           int tempMin = A[i] * min;\\n           max = Math.max(Math.max(tempMax,tempMin), A[i]);\\n           min = Math.min(Math.min(tempMax,tempMin), A[i]);\\n           totalMax = Math.max(totalMax, max);\\n       }\\n       return totalMax;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 48405,
                "title": "o-n-time-o-1-space-solution-within-one-scan",
                "content": "Using dp and keep a record of current max product together with current min product.\\n\\n    class Solution:\\n        # @param {integer[]} nums\\n        # @return {integer}\\n        def maxProduct(self, nums):\\n            i = 0\\n            currentMax, currentMin, ans = nums[0], nums[0], nums[0]\\n            for i in range(1, len(nums)):\\n                n = nums[i]\\n                tmp = currentMax\\n                currentMax = max(n, n*currentMax, n*currentMin)\\n                currentMin = min(n, n*tmp, n*currentMin)\\n                ans = max(ans, currentMax)\\n            return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 1290196,
                "title": "c-two-pass-0-ms-faster-than-100-00",
                "content": "# kaden\\'s algo || two pass\\n```\\nclass Solution {\\npublic:\\n    \\n    //we are using kaden\\'s algo logic\\n    //we are here using two pass method so that we can get ultimate max\\n    \\n    int maxProduct(vector<int>& nums) {\\n        \\n        int prod=1;\\n        int max_val=INT_MIN;\\n        \\n        //left to right traversal\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(prod==0)//if prod becomes 0, prod is reset to 1\\n                prod=1;\\n            \\n            prod=prod*nums[i];\\n            max_val=max(max_val,prod); \\n        }\\n        \\n        //right to left\\n        prod=1;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            if(prod==0)\\n                prod=1;\\n            \\n            prod=prod*nums[i];\\n            max_val=max(max_val,prod);\\n        }\\n        \\n        return max_val;\\n        \\n    }\\n};\\n```\\n\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //we are using kaden\\'s algo logic\\n    //we are here using two pass method so that we can get ultimate max\\n    \\n    int maxProduct(vector<int>& nums) {\\n        \\n        int prod=1;\\n        int max_val=INT_MIN;\\n        \\n        //left to right traversal\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(prod==0)//if prod becomes 0, prod is reset to 1\\n                prod=1;\\n            \\n            prod=prod*nums[i];\\n            max_val=max(max_val,prod); \\n        }\\n        \\n        //right to left\\n        prod=1;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            if(prod==0)\\n                prod=1;\\n            \\n            prod=prod*nums[i];\\n            max_val=max(max_val,prod);\\n        }\\n        \\n        return max_val;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520026,
                "title": "how-to-come-up-with-a-dp-solution",
                "content": "Not to take anything away from all the top rated DP solutions, they are all brilliant. However I think they missed the opportunity to elaborate on their thought process behind how the arrived at their solutions. So I am going to show how I approached the problem, and I hope you might find it useful.\\n\\nConsider an input array [2,-3,2,-4]. So how can we find a recursive pattern? i.e. how do we build a global maximum product based on previous  products? Let\\'s list all products of current number and previous numbers as we loop through the array.\\n\\n```\\n1st iteration   2nd iteration  3rd iteration  4th iteration\\n[2]             [-3]           [2]            [-4]\\n1 * 2 = 2       1 * -3 = -3    1 * 2 = 2      1 * -4 = -4\\n                2 * -3 = -6    -3 * 2 = -6    2 * -4 = -8\\n                               -6 * 2 = -12   -6 *- 4 = 24\\n\\t\\t\\t\\t\\t\\t\\t                  -12 * -4 = 48\\n```\\nWe can introduce two variables local_maximum and global_maximum to **rember** our current progress,\\n```\\n1st iteration         2nd iteration     3rd iteration    4th iteration\\n[2]                   [-3]              [2]              [-4]\\n1 * 2 = 2 (lm, gm)    1 * -3 = -3 (lm)  1 * 2 = 2 (lm)   1 * -4 = -4\\n                      2 * -3 = -6       -3 * 2 = -6      2 * -4 = -8\\n                                        -6 * 2 = -12     -6 * -4 = 24\\n\\t\\t\\t\\t\\t\\t\\t                             -12 * -4 = 48 (lm, gm)\\nlm = local maximum\\ngm = global maximum\\n```\\nThis is in fact the recursive relationship we\\'re looking for. We could use a data structure (e.g. an array list of array lists) to hold all products we calculated at previous iterations, this will help us identify local maximum and find global maximum ( gm = max(lm, gm) ). But....\\n\\nCan we optimise the solution? It looks like there\\'re a lot of products we have remembered! If we pause for a moment and ask ourselves, do we need to store all previous products? No! We only need the largest and smallest products from every iteration, any products between the largest and smallest will not produce a larger/smaller product. With this in mind, let\\'s change our calculations.\\n\\n```\\n1st iteration         2nd iteration     3rd iteration      4th iteration\\n[2]                   [-3]              [2]                [-4]\\n1 * 2 = 2 (s, l, m)   1 * -3 = -3 (l)   1 * 2 = 2 (l)      1 * -4 = -4\\n                      2 * -3 = -6 (s)   -3 * 2 = -6        2 * -4 = -8 (s)\\n                                        -6 * 2 = -12 (s)   -12 * -4 = 48 (l, m)\\n\\t\\t\\t\\t\\t\\t\\t                             \\ns = smallest\\nl = largest\\nm = maximum\\n```\\nYou will notice the space is constant O(1) (3 variables to maintain our progress). The rumtime is linear O(n), where n is the size of input array. To put everything in code,\\n\\n```\\nint MaxProduct(int[] nums)\\n{\\n    // Constraints:\\n    // 1 <= nums.length <= 2 * 10^4\\n    // -10 <= nums[i] <= 10\\n\\t// The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\n\\t\\t\\n\\tint s = nums[0]; // smallest\\n\\tint l = s; // largest\\n\\tint m = s; // max\\n\\tfor (int i = 1; i < nums.Length; i++)\\n\\t{\\n\\t\\tint num = nums[i];\\n\\n\\t\\tint s1 = s * num;\\n\\t\\tint l1 = l * num;\\n\\n        // largest and smallest can swap places if we counter a negative number\\n\\t\\ts = Math.Min(Math.Min(s1, num), l1);\\n\\t\\tl = Math.Max(Math.Max(s1, num), l1);\\n\\n\\t\\tm = Math.Max(m, l);\\n\\t}\\n\\n\\treturn m;\\n}\\n```\\n\\nHope it helps!\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n1st iteration   2nd iteration  3rd iteration  4th iteration\\n[2]             [-3]           [2]            [-4]\\n1 * 2 = 2       1 * -3 = -3    1 * 2 = 2      1 * -4 = -4\\n                2 * -3 = -6    -3 * 2 = -6    2 * -4 = -8\\n                               -6 * 2 = -12   -6 *- 4 = 24\\n\\t\\t\\t\\t\\t\\t\\t                  -12 * -4 = 48\\n```\n```\\n1st iteration         2nd iteration     3rd iteration    4th iteration\\n[2]                   [-3]              [2]              [-4]\\n1 * 2 = 2 (lm, gm)    1 * -3 = -3 (lm)  1 * 2 = 2 (lm)   1 * -4 = -4\\n                      2 * -3 = -6       -3 * 2 = -6      2 * -4 = -8\\n                                        -6 * 2 = -12     -6 * -4 = 24\\n\\t\\t\\t\\t\\t\\t\\t                             -12 * -4 = 48 (lm, gm)\\nlm = local maximum\\ngm = global maximum\\n```\n```\\n1st iteration         2nd iteration     3rd iteration      4th iteration\\n[2]                   [-3]              [2]                [-4]\\n1 * 2 = 2 (s, l, m)   1 * -3 = -3 (l)   1 * 2 = 2 (l)      1 * -4 = -4\\n                      2 * -3 = -6 (s)   -3 * 2 = -6        2 * -4 = -8 (s)\\n                                        -6 * 2 = -12 (s)   -12 * -4 = 48 (l, m)\\n\\t\\t\\t\\t\\t\\t\\t                             \\ns = smallest\\nl = largest\\nm = maximum\\n```\n```\\nint MaxProduct(int[] nums)\\n{\\n    // Constraints:\\n    // 1 <= nums.length <= 2 * 10^4\\n    // -10 <= nums[i] <= 10\\n\\t// The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\n\\t\\t\\n\\tint s = nums[0]; // smallest\\n\\tint l = s; // largest\\n\\tint m = s; // max\\n\\tfor (int i = 1; i < nums.Length; i++)\\n\\t{\\n\\t\\tint num = nums[i];\\n\\n\\t\\tint s1 = s * num;\\n\\t\\tint l1 = l * num;\\n\\n        // largest and smallest can swap places if we counter a negative number\\n\\t\\ts = Math.Min(Math.Min(s1, num), l1);\\n\\t\\tl = Math.Max(Math.Max(s1, num), l1);\\n\\n\\t\\tm = Math.Max(m, l);\\n\\t}\\n\\n\\treturn m;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 48259,
                "title": "understanding-why-you-need-to-keep-track-of-just-the-min-and-max-previous-values",
                "content": "Most of other solutions here basically just state that you need to keep track of the min and max of the previous `i`, but it wasn't clear to me why that is the case. Here's how I figured it out for `nums = [-2, 1, 2, -3, 1, 3]`:\\n\\nFirst write out a matrix with all of the possible subarrays and their products like this:\\n\\n```text\\nExample of how to calculate a column:\\n-2   1   2  -3   1   3\\n----------------------\\n-2*1*2*-3 = 12\\n   1*2*-3 = -6\\n     2*-3 = -6\\n       -3 = -3\\n\\nFull matrix:\\n----------------------\\n-2   1   2  -3   1   3\\n----------------------\\n-2  -2  -4  12  12  36\\n     1   2  -6  -6  18\\n         2  -6  -6  18\\n            -3  -3  -9\\n                 1   3\\n                     3\\n```\\nFrom here, it is easy to convince yourself that the product of the max product subarray ending at column `i` is either:\\n* just `nums[i]` (eg, the second column subarray is just `[1]`)\\n* the product `nums[i] * min[i-1]` (eg, fourth column is `[-2,1,2,-3]`)\\n* the product `nums[i] * max[i-1]` (eg, third column is `[1,2]`)\\n\\nAnd from there, you have the recurrence relationship that the other solutions are using.",
                "solutionTags": [],
                "code": "```text\\nExample of how to calculate a column:\\n-2   1   2  -3   1   3\\n----------------------\\n-2*1*2*-3 = 12\\n   1*2*-3 = -6\\n     2*-3 = -6\\n       -3 = -3\\n\\nFull matrix:\\n----------------------\\n-2   1   2  -3   1   3\\n----------------------\\n-2  -2  -4  12  12  36\\n     1   2  -6  -6  18\\n         2  -6  -6  18\\n            -3  -3  -9\\n                 1   3\\n                     3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1609300,
                "title": "how-to-approach-product-sum-of-subarray-problems",
                "content": "**BRUTE FORCE SOLUTION**\\n\\nIf you want to compare all subarrays, and find your solution, you can use two for loops. However this approach results into` o(n^2)` complexity.\\n\\n**PREFIX SUM / PRODUCT CONCEPT**\\n\\nWhen you hear \"product / sum of subarray\" the first idea that can help you to build your solution, is a concept of `prefix sum`.\\nSo if the array is `1 2 3 4`,\\nPrefix sum would be: \\n`i = 0` prefixSum = `1`\\n`i = 1` prefixSum = `3`\\n`i = 2` prefixSum = `6`\\n`i = 3` prefixSum = `10`\\nOr if you are looking for a product of `1 2 3 4` instead of sum:\\n`i = 0` prefixProduct = `1`\\n`i = 1` prefixProduct = `2`\\n`i = 2` prefixProduct = `6`\\n`i = 3` prefixProduct = `24`\\n\\n**Sum of subarray**\\nUsing this concept you can easily calculate the sum/prefix of subarray[i, j]:\\n`Sum of subarray[i, j] = prefixSum[j] - prefixSum[i - 1]` <- O(1) instead of O(n) \\uD83D\\uDE01\\nFor example,  if the array is `1 2 3 4`, sum[2, 3] = 3 + 4 = prefixSum[3] - prefixSum[1] = 10 - 3 = 7\\n\\n**Product of subarray**\\nOr `Product of subarray[i, j] = prefixProduct[j] / prefixProduct[i - 1]` \\nFor example,  if the array is `1 2 3 4`, product[2, 3] = 3 * 4 = prefixProduct[3] / prefixProduct[1] = 24 /  2 = 12\\n\\n**Array or variable?**\\nYou can keep prefix array for each index in an `array`, or keep min/max/curResult in a `single variable`.\\n\\n\\n**BUILDING THE SOLUTION**\\n\\n**Positive Integers**\\nWe need to find the maxProduct of subarray. If the array consisted only of positive integers, the maximum would be just the product of all numbers.\\n\\n**What if we encounter 0?**\\nIf we find 0, the array is essentially divided, cause 0 makes the product of each subarray including 0 equals to 0. So we need to start all over again.\\n\\n**What if we encounter a negative number?**\\nYes my friend that\\'s the danger \\uD83D\\uDE08!  Essentially if we got a negative number, all our multiplication result turns negative and turns from max to min. Here is where the concept of prefixProduct could help. We would keep the `first  negative product` that we encountered. If we result in negative product ever again  in this sequance, to find the maximum, we just `divide` it to the `first negative product`.\\n\\n**CODE**\\n\\n```\\nvar maxProduct = function(nums) {\\n    if (nums.length == 1) {\\n        return nums[0];\\n    }\\n    // 1 is a number \"neutral\" to multiplication\\n    let firstNegative = 1; // No negatives yet\\n    let curPrefix = 1; // Empty yet\\n    let maxProduct = 0; // In case we found 0\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        curPrefix *= nums[i];\\n        maxProduct = Math.max(curPrefix, maxProduct);\\n        \\n        if (curPrefix < 0) { // divide to the first negative\\n            maxProduct = Math.max(curPrefix / firstNegative, maxProduct);\\n            // set the first negative product, if it wasn\\'t set yet\\n            firstNegative = firstNegative == 1? curPrefix : firstNegative;\\n            \\n        } else if (curPrefix == 0) { // start all over again\\n            curPrefix = 1;\\n            firstNegative = 1;\\n        }\\n    }\\n    return maxProduct;\\n};\\n```\\n\\n**What problems I can solve using prefix array?**\\nCheck out product without curent index - https://leetcode.com/problems/product-of-array-except-self/\\nMaximum subarray - https://leetcode.com/problems/maximum-subarray/\\nMaximum absolute sum - https://leetcode.com/problems/maximum-absolute-sum-of-any-subarray/ \\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar maxProduct = function(nums) {\\n    if (nums.length == 1) {\\n        return nums[0];\\n    }\\n    // 1 is a number \"neutral\" to multiplication\\n    let firstNegative = 1; // No negatives yet\\n    let curPrefix = 1; // Empty yet\\n    let maxProduct = 0; // In case we found 0\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        curPrefix *= nums[i];\\n        maxProduct = Math.max(curPrefix, maxProduct);\\n        \\n        if (curPrefix < 0) { // divide to the first negative\\n            maxProduct = Math.max(curPrefix / firstNegative, maxProduct);\\n            // set the first negative product, if it wasn\\'t set yet\\n            firstNegative = firstNegative == 1? curPrefix : firstNegative;\\n            \\n        } else if (curPrefix == 0) { // start all over again\\n            curPrefix = 1;\\n            firstNegative = 1;\\n        }\\n    }\\n    return maxProduct;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 841796,
                "title": "python-simple-solution-explained-video-code-91-faster",
                "content": "[](https://www.youtube.com/watch?v=IOMjN6r7ju8)\\nhttps://www.youtube.com/watch?v=IOMjN6r7ju8\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        B = nums[::-1]\\n        \\n        for x in range(1,len(nums)):\\n            if nums[x - 1] != 0:\\n                nums[x] *= nums[x - 1]\\n                \\n            if B[x - 1] != 0:\\n                B[x] *= B[x - 1]\\n                \\n        return max(nums + B)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        B = nums[::-1]\\n        \\n        for x in range(1,len(nums)):\\n            if nums[x - 1] != 0:\\n                nums[x] *= nums[x - 1]\\n                \\n            if B[x - 1] != 0:\\n                B[x] *= B[x - 1]\\n                \\n        return max(nums + B)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791257,
                "title": "dynamic-programming-and-constant-space-solution-easily-explained-with-video-must-watch",
                "content": "Link to Video :- https://youtu.be/4kbWVhMAx6U\\n\\n\\n\\n\\n\\n\\n**Code In c++:-\\nUsing DP O(N) Time and O(N) Space:-**\\n\"\"\"\\n\\n\\n    int maxProduct(vector< int>& nums) {\\n        vector<int> max_dp(nums.size());\\n        vector<int> min_dp(nums.size());\\n      \\n        max_dp[0]=nums[0];\\n        min_dp[0] = nums[0];\\n        \\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]<0){\\n                max_dp[i]=max(nums[i],nums[i] * min_dp[i-1]);\\n                min_dp[i]=min(nums[i],nums[i]*  max_dp[i-1]);\\n            }\\n            else{\\n                max_dp[i]= max(nums[i],nums[i] * max_dp[i-1]);\\n                min_dp[i]= min(nums[i],nums[i] * min_dp[i-1]);\\n            }\\n        }\\n       \\n        return *max_element(max_dp.begin(),max_dp.end());}\\n\\n\"\"\"\\n\\n**Using Constant space and linear time optimized approach:-**\\n\\n\"\"\"\\n\\n int maxProduct(vector< int>& nums) {\\n int max_curr=nums[0] , min_curr=nums[0] , res = nums[0];\\n        \\n        if(nums.size()==0){\\n           return -1;\\n        }\\n        \\n        \\n        for(int i=1;i<nums.size();i++){\\n            \\n            int c1 = max_curr * nums[i];\\n            int c2 = min_curr * nums[i];\\n            max_curr = max(nums[i],max(c2,c1));\\n            min_curr = min(nums[i],min(c1,c2));\\n            res =max(max_curr,res);\\n            \\n        }\\n        return res;\\n    }\\n\\n\"\"\"\\n**DO UPVOTE IF IT HELPED YOU !! :)**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "Link to Video :- https://youtu.be/4kbWVhMAx6U\\n\\n\\n\\n\\n\\n\\n**Code In c++:-\\nUsing DP O(N) Time and O(N) Space:-**\\n\"\"\"\\n\\n\\n    int maxProduct(vector< int>& nums) {\\n        vector<int> max_dp(nums.size());\\n        vector<int> min_dp(nums.size());\\n      \\n        max_dp[0]=nums[0];\\n        min_dp[0] = nums[0];\\n        \\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]<0){\\n                max_dp[i]=max(nums[i],nums[i] * min_dp[i-1]);\\n                min_dp[i]=min(nums[i],nums[i]*  max_dp[i-1]);\\n            }\\n            else{\\n                max_dp[i]= max(nums[i],nums[i] * max_dp[i-1]);\\n                min_dp[i]= min(nums[i],nums[i] * min_dp[i-1]);\\n            }\\n        }\\n       \\n        return *max_element(max_dp.begin(),max_dp.end());}\\n\\n\"\"\"\\n\\n**Using Constant space and linear time optimized approach:-**\\n\\n\"\"\"\\n\\n int maxProduct(vector< int>& nums) {\\n int max_curr=nums[0] , min_curr=nums[0] , res = nums[0];\\n        \\n        if(nums.size()==0){\\n           return -1;\\n        }\\n        \\n        \\n        for(int i=1;i<nums.size();i++){\\n            \\n            int c1 = max_curr * nums[i];\\n            int c2 = min_curr * nums[i];\\n            max_curr = max(nums[i],max(c2,c1));\\n            min_curr = min(nums[i],min(c1,c2));\\n            res =max(max_curr,res);\\n            \\n        }\\n        return res;\\n    }\\n\\n\"\"\"\\n**DO UPVOTE IF IT HELPED YOU !! :)**\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 201223,
                "title": "python-code",
                "content": "\\u52A8\\u6001\\u89C4\\u5212\\u7B97\\u6CD5\\u7684\\u5178\\u578B\\u56DB\\u4E2A\\u6B65\\u9AA4\\u5982\\u4E0B\\uFF1A\\n1. \\u5148\\u4ECE\\u5B9E\\u9645\\u4F8B\\u5B50\\u4E2D\\u89C2\\u5BDFnums\\u7684\\u6700\\u5927\\u5B50\\u5E8F\\u5217\\u7684\\u7279\\u5F81\\u3002\\u4E3E\\u4F8B\\u5B50\\uFF1Anums[0], nums[0:2], nums[0:3] ......\\uFF08\\u5982\\u4E0B\\u56FE\\uFF09\\n2. \\u7136\\u540E\\u53EF\\u5F52\\u7EB3\\u51FA\\u4E00\\u4E2A\\u9012\\u63A8\\u8868\\u8FBE\\u5F0F\\u3002\\uFF08\\u5982\\u4E0B\\u56FE\\uFF09\\n3. \\u6700\\u540E\\u6C42\\u89E3\\u3002\\u4E66\\u5199\\u4EE3\\u7801\\u5982\\u4E0B\\u3002\\n4. \\u6784\\u9020\\u89E3\\u3002\\u8FD9\\u9053\\u9898\\u6CA1\\u8981\\u6C42\\u8F93\\u51FA\\u5B50\\u5E8F\\u5217\\uFF0C\\u53EF\\u7701\\u53BB\\u3002\\n\\n\\u518D\\u603B\\u7ED3\\u4E0B\\uFF1A\\n1. \\u52A8\\u6001\\u89C4\\u5212\\u7B97\\u6CD5\\u7684\\u6838\\u5FC3\\u5C31\\u662F\\u9012\\u63A8\\u5173\\u7CFB\\u7684\\u6784\\u9020\\u4E86\\u3002\\n2. \\u66F4\\u52A0\\u7B80\\u5316\\u7684\\u65B9\\u6CD5\\u662F\\u7528`O(1) space`\\u65B9\\u6CD5\\u6765\\u505A\\u3002\\u4F46\\u4E24\\u4E2A\\u6570\\u7EC4\\u7B26\\u5408DP\\u7B97\\u6CD5\\u7684\\u601D\\u8003\\u8FC7\\u7A0B\\uFF0C\\u66F4\\u5BB9\\u6613\\u7406\\u89E3\\uFF0C\\u4ECE`O(n) space`\\u5230`O(1) space`\\u7684\\u8F6C\\u5316\\u4E5F\\u662F\\u7B80\\u5355\\u7684\\u3002\\n3. \\u96BE\\u60F3\\u5230\\u7684\\u5C31\\u662F\\u9700\\u8981\\u628A\\u6BCF\\u6B65\\u7684\\u6700\\u5C0F\\u503C\\u8BB0\\u5F55\\uFF0C\\u4F46\\u901A\\u8FC7\\u5F52\\u7EB3\\u603B\\u7ED3\\u4E5F\\u80FD\\u770B\\u51FA\\u6765\\u3002\\n```\\nclass Solution:\\n    def maxProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        r = nums[0]\\n        Max = [r] ##\\u8BB0\\u5F55\\u6BCF\\u4E2A\\u5143\\u7D20\\u4F5C\\u4E3A\\u6700\\u540E\\u4E00\\u4E2A\\u5B50\\u5E8F\\u5217\\u5143\\u7D20\\u6240\\u80FD\\u6784\\u6210\\u7684\\u6700\\u5927\\u4E58\\u79EF\\n        Min = [r] ##\\u8BB0\\u5F55\\u6BCF\\u4E2A\\u5143\\u7D20\\u4F5C\\u4E3A\\u6700\\u540E\\u4E00\\u4E2A\\u5B50\\u5E8F\\u5217\\u5143\\u7D20\\u6240\\u80FD\\u6784\\u6210\\u7684\\u6700\\u5C0F\\u4E58\\u79EF\\n        \\n        for i, num in enumerate(nums[1:]): ## i \\u5B9E\\u9645\\u7684\\u4F4D\\u7F6E\\u662Fnum\\u5728nums\\u6570\\u7EC4\\u4E2D\\u4E0B\\u6807\\u7684\\u4E0A\\u4E00\\u4E2A\\u5143\\u7D20\\u4E0B\\u6807\\u3002\\n            if num >= 0:\\n                Max.append(max(num, Max[i] * num))\\n                Min.append(min(num, Min[i] * num))               \\n            else:\\n                Max.append(max(num, Min[i] * num))\\n                Min.append(min(num, Max[i] * num))        \\n        return max(Max)\\n```\\n\\u7279\\u5F81\\u89C2\\u5BDF\\n![image](https://assets.leetcode.com/users/sucsliu34/image_1543918598.png)\\n\\u9012\\u63A8\\u516C\\u5F0F\\n![image](https://assets.leetcode.com/users/sucsliu34/image_1543918625.png)\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        r = nums[0]\\n        Max = [r] ##\\u8BB0\\u5F55\\u6BCF\\u4E2A\\u5143\\u7D20\\u4F5C\\u4E3A\\u6700\\u540E\\u4E00\\u4E2A\\u5B50\\u5E8F\\u5217\\u5143\\u7D20\\u6240\\u80FD\\u6784\\u6210\\u7684\\u6700\\u5927\\u4E58\\u79EF\\n        Min = [r] ##\\u8BB0\\u5F55\\u6BCF\\u4E2A\\u5143\\u7D20\\u4F5C\\u4E3A\\u6700\\u540E\\u4E00\\u4E2A\\u5B50\\u5E8F\\u5217\\u5143\\u7D20\\u6240\\u80FD\\u6784\\u6210\\u7684\\u6700\\u5C0F\\u4E58\\u79EF\\n        \\n        for i, num in enumerate(nums[1:]): ## i \\u5B9E\\u9645\\u7684\\u4F4D\\u7F6E\\u662Fnum\\u5728nums\\u6570\\u7EC4\\u4E2D\\u4E0B\\u6807\\u7684\\u4E0A\\u4E00\\u4E2A\\u5143\\u7D20\\u4E0B\\u6807\\u3002\\n            if num >= 0:\\n                Max.append(max(num, Max[i] * num))\\n                Min.append(min(num, Min[i] * num))               \\n            else:\\n                Max.append(max(num, Min[i] * num))\\n                Min.append(min(num, Max[i] * num))        \\n        return max(Max)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 890564,
                "title": "python-with-detailed-explanation-faster-than-96-52",
                "content": "#### The trick is \\n1.  Unlike maximum sum, for max product the current negetive minimum value could be max in future when multiplied by another -ve value --> so we need to keep track of minimum_value too\\n2. We need to keep track of maximum value --> obviously \\n3. We need to keep track of over_all maximum value \\n\\n\\nstep 1--> cumulative_min_product = minimum of ( cumulative_max_product*cur_value, cumulative_min_product*cur_value, cur_value) \\n            step 2 --> cumulative_max_product = maximum of ( cumulative_max_product*cur_value, cumulative_min_product*cur_value, cur_value)\\n            step 3 - As the maximum subbaray cloud happen in the middel, we need to keep track of it \\n                --> max_so_far = max(cumulative_max_prod, max_so_far)\\n                --> Pit fall : save cumlative_min_product before updating it for use at step 2\\n                --> return max_so_far\\n```\\n    def maxProduct(self, nums):\\n        cumltv_max = cumltv_min= max_sofar = nums[0]\\n        for i, num in enumerate(nums[1:], start=1):\\n            # save the last cumulative min before updating it for later calculating cumulative max \\n            prv_cumltv_min = cumltv_min  \\n            # compare these and take the minimum --> cur_value, last cumlative min x cur_value and last cum max x cuv_value\\n            cumltv_min = min( cumltv_min*num, cumltv_max*num, num)\\n            cumltv_max = max( prv_cumltv_min*num, cumltv_max*num, num) \\n            max_sofar = max(cumltv_max, max_sofar)\\n        return max_sofar\\n```\\n\\n*        2nd idea Using DP table: creating a table  O(n) space O(n) time\\n            : Keep track of the maxium and minimum cumulative at each index \\n            step 1 : cumltv_min[i] = min( cumltv_min[i-1]*nums[i], cumltv_max[i-1]*nums[i], nums[i])\\n            step 2 : cumltv_max[i] = max( cumltv_min[i-1]*nums[i], cumltv_max[i-1]*nums[i], nums[i])\\n            step 3 retun max(cumltv_max)\\n\\t\\t\\t\\n```\\n    def maxProduct(self, nums):\\n        cumltv_min = [0]*len(nums)\\n        cumltv_max = [0]*len(nums)\\n        cumltv_min[0] = cumltv_max[0] = nums[0]\\n        for i in range(1,len(nums)):\\n            # compare the minimum of min(cur_val*prev_min, cur_val) and min(cur_val*prev_max, cur_val)\\n            cumltv_min[i] = min( cumltv_min[i-1]*nums[i] , cumltv_max[i-1]*nums[i], nums[i])\\n            # compare the maximum of max(cur_val*prev_min, cur_val) and max(cur_val*prev_max, cur_val)\\n            cumltv_max[i] = max ( cumltv_min[i-1]*nums[i], cumltv_max[i-1]*nums[i], nums[i] )\\n        return max(cumltv_max)\\n```\\n#### If this solution/explanation helps you, don\\'t forget to upvote as appreciation",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def maxProduct(self, nums):\\n        cumltv_max = cumltv_min= max_sofar = nums[0]\\n        for i, num in enumerate(nums[1:], start=1):\\n            # save the last cumulative min before updating it for later calculating cumulative max \\n            prv_cumltv_min = cumltv_min  \\n            # compare these and take the minimum --> cur_value, last cumlative min x cur_value and last cum max x cuv_value\\n            cumltv_min = min( cumltv_min*num, cumltv_max*num, num)\\n            cumltv_max = max( prv_cumltv_min*num, cumltv_max*num, num) \\n            max_sofar = max(cumltv_max, max_sofar)\\n        return max_sofar\\n```\n```\\n    def maxProduct(self, nums):\\n        cumltv_min = [0]*len(nums)\\n        cumltv_max = [0]*len(nums)\\n        cumltv_min[0] = cumltv_max[0] = nums[0]\\n        for i in range(1,len(nums)):\\n            # compare the minimum of min(cur_val*prev_min, cur_val) and min(cur_val*prev_max, cur_val)\\n            cumltv_min[i] = min( cumltv_min[i-1]*nums[i] , cumltv_max[i-1]*nums[i], nums[i])\\n            # compare the maximum of max(cur_val*prev_min, cur_val) and max(cur_val*prev_max, cur_val)\\n            cumltv_max[i] = max ( cumltv_min[i-1]*nums[i], cumltv_max[i-1]*nums[i], nums[i] )\\n        return max(cumltv_max)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 699929,
                "title": "comparison-with-53-maximum-subarray",
                "content": "This problem looks similar with [53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/), except we want max product instead of max sum. \\n\\nFor max sum:\\n```C++\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxSum = INT_MIN;\\n        int currSum = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            currSum = max(nums[i], currSum * nums[i]);\\n\\t\\t\\t\\n            maxSum = max(maxSum, currSum);\\n        }\\n        return maxSum;\\n    }\\n};\\n```\\nThe max-sum of subarrays ended at `nums[i]` is either:\\n- `nums[i]` + the max-sum of subarrays ended at `nums[i-1]`, or\\n- `nums[i]`, if the max-sum of subarrays ended at `nums[i-1]` is negative.\\n\\nIn the code above, we use `currSum` to keep track of max-sum ended at `nums[i-1]` and make our decision.\\n\\nMax-product is more complicated: the product of two negative values is positive. But we still have: The max-product of subarrays ended at `nums[i]` is either:\\n- case 1: `nums[i]` * the max-product of subarrays ended at `nums[i-1]`, or\\n- case 2: `nums[i]` * the min-product of subarrays ended at `nums[i-1]`, or\\n- case 3: `nums[i]` itself.\\n\\nCase 1 happens when `nums[i]` and max-product ended at `nums[i-1]` are positive; Case 2 happens when `nums[i]` and min-product ended at `nums[i-1]` are negative; Case 3 happens when `nums[i]` is positve, but the max-product of subarrays ended at `nums[i-1]` is negative, or when `nums[i]` is negative, and the min-product of subarrays ended at `nums[i-1]` is positive.\\n\\nWe can use two variables `maxProdAtPrev` and `minProdAtPrev` to keep track of the above information.\\n\\nSo we easily have the following code:\\n```C++\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        if (nums.empty()) return 1;\\n        \\n        int maxProd = nums[0];\\n        int maxProdAtPrev = maxProd, minProdAtPrev = maxProd;\\n        for (int i = 1; i < nums.size(); i++) {\\n\\t\\t    if (nums[i] < 0) swap(maxProdAtPrev, minProdAtPrev);\\n\\t\\t\\tmaxProdAtPrev = max(nums[i], maxProdAtPrev * nums[i]);\\n\\t\\t\\tminProdAtPrev = min(num[i], minProdAtPrev * nums[i]);\\n\\t\\t\\t\\n            maxProd = max(maxProd, maxProdAtPrev);\\n        }\\n        return maxProd;\\n    }\\n};\\n```\\nThe logic in each iteration is almost the same as Maximum Subarray.\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxSum = INT_MIN;\\n        int currSum = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            currSum = max(nums[i], currSum * nums[i]);\\n\\t\\t\\t\\n            maxSum = max(maxSum, currSum);\\n        }\\n        return maxSum;\\n    }\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        if (nums.empty()) return 1;\\n        \\n        int maxProd = nums[0];\\n        int maxProdAtPrev = maxProd, minProdAtPrev = maxProd;\\n        for (int i = 1; i < nums.size(); i++) {\\n\\t\\t    if (nums[i] < 0) swap(maxProdAtPrev, minProdAtPrev);\\n\\t\\t\\tmaxProdAtPrev = max(nums[i], maxProdAtPrev * nums[i]);\\n\\t\\t\\tminProdAtPrev = min(num[i], minProdAtPrev * nums[i]);\\n\\t\\t\\t\\n            maxProd = max(maxProd, maxProdAtPrev);\\n        }\\n        return maxProd;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941882,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of nums.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func maxProduct(_ nums: [Int]) -> Int {\\n        guard !nums.isEmpty else { return 0 }\\n\\n        var ans = nums[0]\\n        var maxSoFar = nums[0]\\n        var minSoFar = nums[0]\\n\\n        for i in 1..<nums.count {\\n            let curr = nums[i]\\n\\n            let tmpMax = max(curr, maxSoFar * curr, minSoFar * curr)\\n            minSoFar = min(curr, maxSoFar * curr, minSoFar * curr)\\n            maxSoFar = tmpMax\\n\\n            ans = max(ans, maxSoFar)\\n        }\\n\\n        return ans\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of nums.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func maxProduct(_ nums: [Int]) -> Int {\\n        guard !nums.isEmpty else { return 0 }\\n\\n        var ans = nums[0]\\n        var maxSoFar = nums[0]\\n        var minSoFar = nums[0]\\n\\n        for i in 1..<nums.count {\\n            let curr = nums[i]\\n\\n            let tmpMax = max(curr, maxSoFar * curr, minSoFar * curr)\\n            minSoFar = min(curr, maxSoFar * curr, minSoFar * curr)\\n            maxSoFar = tmpMax\\n\\n            ans = max(ans, maxSoFar)\\n        }\\n\\n        return ans\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232048,
                "title": "o-n-easy-explained",
                "content": "// basic idea is to keep track of current maximum  , current minimum and global maximum\\n//current minimum may result in maximum value too if both the number multiplied are negative \\n\\n\\n\\t\\t\\t\\tclass Solution {\\n\\t\\t\\t\\t\\tpublic int maxProduct(int[] nums) {\\n\\t\\t\\t\\t\\tint max = nums[0] , curMax = nums[0] ,curMin = nums[0] , temp,i;\\n\\t\\t\\t\\t\\tfor(i=1;i<nums.length;i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ttemp =curMax;\\n\\t\\t\\t\\t\\t\\tcurMax = Math.max(nums[i] , Math.max(nums[i]*curMax , nums[i]*curMin));\\n\\t\\t\\t\\t\\t\\tcurMin = Math.min(nums[i] , Math.min(nums[i]*temp , nums[i]*curMin));\\n\\n\\t\\t\\t\\t\\t\\tmax = Math.max(max , curMax);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn max;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n// this is the extension to kadens algo if you find any dificulty then ask in comment ....thankyou\\n//if you find this helpful please upvote too",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\t\\tpublic int maxProduct(int[] nums) {\\n\\t\\t\\t\\t\\tint max = nums[0] , curMax = nums[0] ,curMin = nums[0] , temp,i;\\n\\t\\t\\t\\t\\tfor(i=1;i<nums.length;i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ttemp =curMax;\\n\\t\\t\\t\\t\\t\\tcurMax = Math.max(nums[i] , Math.max(nums[i]*curMax , nums[i]*curMin));\\n\\t\\t\\t\\t\\t\\tcurMin = Math.min(nums[i] , Math.min(nums[i]*temp , nums[i]*curMin));\\n\\n\\t\\t\\t\\t\\t\\tmax = Math.max(max , curMax);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 48400,
                "title": "python-solutions-with-different-space-costs-o-2-n-o-1",
                "content": "\\n    # O(2*n) space\\n    def maxProduct1(self, nums):\\n        if not nums:\\n            return \\n        locMin = [0] * len(nums)\\n        locMax = [0] * len(nums)\\n        locMin[0] = locMax[0] = gloMax = nums[0]\\n        for i in xrange(1, len(nums)):\\n            if nums[i] < 0:\\n                locMax[i] = max(locMin[i-1]*nums[i], nums[i])\\n                locMin[i] = min(locMax[i-1]*nums[i], nums[i])\\n            else:\\n                locMax[i] = max(locMax[i-1]*nums[i], nums[i])\\n                locMin[i] = min(locMin[i-1]*nums[i], nums[i])\\n            gloMax = max(gloMax, locMax[i])\\n        return gloMax\\n    \\n    # O(1) space    \\n    def maxProduct2(self, nums):\\n        if not nums:\\n            return \\n        locMin = locMax = gloMax = nums[0]\\n        for i in xrange(1, len(nums)):\\n            if nums[i] < 0:\\n                tmp = locMax\\n                locMax = max(locMin*nums[i], nums[i])\\n                locMin = min(tmp*nums[i], nums[i])\\n            else:\\n                locMax = max(locMax*nums[i], nums[i])\\n                locMin = min(locMin*nums[i], nums[i])\\n            gloMax = max(gloMax, locMax)\\n        return gloMax\\n     \\n    # O(1) space    \\n    def maxProduct(self, nums):\\n        if not nums:\\n            return \\n        locMin = locMax = gloMax = nums[0]\\n        for i in xrange(1, len(nums)):\\n            tmp = locMin\\n            locMin = min(locMin*nums[i], nums[i], locMax*nums[i])\\n            locMax = max(tmp*nums[i], nums[i], locMax*nums[i])\\n            gloMax = max(gloMax, locMax)\\n        return gloMax\\n\\t\\t\\n\\tdef maxProduct(self, nums):\\n        locMin = locMax = glo = nums[0]\\n        for num in nums[1:]:\\n            locMin, locMax= min(locMin*num, num, locMax*num), max(locMin*num, num, locMax*num)\\n            glo = max(glo, locMax)\\n        return glo",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "\\n    # O(2*n) space\\n    def maxProduct1(self, nums):\\n        if not nums:\\n            return \\n        locMin = [0] * len(nums)\\n        locMax = [0] * len(nums)\\n        locMin[0] = locMax[0] = gloMax = nums[0]\\n        for i in xrange(1, len(nums)):\\n            if nums[i] < 0:\\n                locMax[i] = max(locMin[i-1]*nums[i], nums[i])\\n                locMin[i] = min(locMax[i-1]*nums[i], nums[i])\\n            else:\\n                locMax[i] = max(locMax[i-1]*nums[i], nums[i])\\n                locMin[i] = min(locMin[i-1]*nums[i], nums[i])\\n            gloMax = max(gloMax, locMax[i])\\n        return gloMax\\n    \\n    # O(1) space    \\n    def maxProduct2(self, nums):\\n        if not nums:\\n            return \\n        locMin = locMax = gloMax = nums[0]\\n        for i in xrange(1, len(nums)):\\n            if nums[i] < 0:\\n                tmp = locMax\\n                locMax = max(locMin*nums[i], nums[i])\\n                locMin = min(tmp*nums[i], nums[i])\\n            else:\\n                locMax = max(locMax*nums[i], nums[i])\\n                locMin = min(locMin*nums[i], nums[i])\\n            gloMax = max(gloMax, locMax)\\n        return gloMax\\n     \\n    # O(1) space    \\n    def maxProduct(self, nums):\\n        if not nums:\\n            return \\n        locMin = locMax = gloMax = nums[0]\\n        for i in xrange(1, len(nums)):\\n            tmp = locMin\\n            locMin = min(locMin*nums[i], nums[i], locMax*nums[i])\\n            locMax = max(tmp*nums[i], nums[i], locMax*nums[i])\\n            gloMax = max(gloMax, locMax)\\n        return gloMax\\n\\t\\t\\n\\tdef maxProduct(self, nums):\\n        locMin = locMax = glo = nums[0]\\n        for num in nums[1:]:\\n            locMin, locMax= min(locMin*num, num, locMax*num), max(locMin*num, num, locMax*num)\\n            glo = max(glo, locMax)\\n        return glo",
                "codeTag": "Python3"
            },
            {
                "id": 3121702,
                "title": "beats-100-java-code",
                "content": "# Java Code\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n\\n        int max = Integer.MIN_VALUE, temp = 1;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            temp *= nums[i];\\n            max = Math.max(temp, max);\\n            if (temp == 0)\\n                temp = 1;\\n        }\\n        temp = 1;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            temp *= nums[i];\\n            max = Math.max(temp, max);\\n            if (temp == 0)\\n                temp = 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n\\n        int max = Integer.MIN_VALUE, temp = 1;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            temp *= nums[i];\\n            max = Math.max(temp, max);\\n            if (temp == 0)\\n                temp = 1;\\n        }\\n        temp = 1;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            temp *= nums[i];\\n            max = Math.max(temp, max);\\n            if (temp == 0)\\n                temp = 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 540883,
                "title": "simple-solution-by-breaking-and-analyzing-the-problem",
                "content": "So, the problem asks us to find the maximum subarray product. The only challenge here is that the array contains negatives!!!\\n\\nIf the array doesn\\'t contain any negatives we can simply multiply all the elements and we are done. However, when there\\'re negatives, the problem is split into two cases:\\n\\n* case a) the number of negatives is even\\n* case b) the number of negatives is odd\\n\\nin case a) we can also simply multiply all the elements and we will have a positive number, so **done**.\\n\\nin case b) we can say, that there\\'s one negative that converts our answer from positive to negative, for example: \\n\\n[2, **-3**, **-2**, 4, **-4**, **-5**, 2, 7, **-1**, 12]\\n\\nhere we have 5 negatives, since they are odd, we have to remove one, and since we are dealing with subarrays, it\\'s illogical to delete one that is bounded between two negatives, because in this case we are losing all the numbers after it (or before it)\\n\\nso the only candidate negatives that are causing the problem are the first one (**-3**), and the last one (**-1**). So we are now left with two options, either we exelude **-3** or we **-1** and this will lead us into 4 different subarrays:\\n\\npossibility 1) [**0**:  **first negative number index**)\\npossibility 2) [**0** :  **second negative number index**)\\npossibility 3) [**first negative number index + 1** : **arr.length**)\\npossibility 4) [**second negative number index + 1** : **arr.length**)\\n\\nBy this we covered all the possible cases of excluding the first negative or the last negative!\\n\\nBut this is already too much, and coding it in a literal way would be ugly, the trick here is that possibility **1** and **2** can be done in a single loop from left to right and while keep taking the maximum and possibility **3** and **4** can be done the same way but from right to left! Actually by this we also cover the case of even number of negatives :)!\\n\\nCode: Java\\n```\\n    public int maxProduct(int[] nums) {\\n        \\n        if(nums == null || nums.length == 0){\\n            return 0;\\n        }\\n        \\n        if(nums.length == 1){\\n            return nums[0];\\n        }\\n        \\n       \\n        int max = Integer.MIN_VALUE;\\n        \\n        int prod = 1;\\n        \\n        int result = 0;\\n        \\n        for(int i = 0 ; i < nums.length ; i++){\\n            prod *= nums[i];\\n            result = Math.max(result, prod);\\n            if(prod == 0){\\n                prod = 1;\\n            }\\n        }\\n        \\n        prod = 1;\\n        \\n        for(int i = nums.length -1 ; i>= 0 ; i--){\\n            prod *= nums[i];\\n            result = Math.max(result, prod);\\n            if(prod == 0){\\n                prod = 1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```\\n\\nI didn\\'t mention the 0, because whenever we encounter the 0, we can imagine that we enountered a new different array.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int maxProduct(int[] nums) {\\n        \\n        if(nums == null || nums.length == 0){\\n            return 0;\\n        }\\n        \\n        if(nums.length == 1){\\n            return nums[0];\\n        }\\n        \\n       \\n        int max = Integer.MIN_VALUE;\\n        \\n        int prod = 1;\\n        \\n        int result = 0;\\n        \\n        for(int i = 0 ; i < nums.length ; i++){\\n            prod *= nums[i];\\n            result = Math.max(result, prod);\\n            if(prod == 0){\\n                prod = 1;\\n            }\\n        }\\n        \\n        prod = 1;\\n        \\n        for(int i = nums.length -1 ; i>= 0 ; i--){\\n            prod *= nums[i];\\n            result = Math.max(result, prod);\\n            if(prod == 0){\\n                prod = 1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 384555,
                "title": "python-solution-dp",
                "content": "Similar to [Problem 53 Maximum Subarray](https://leetcode.com/problems/maximum-subarray/), global maximum is the larger one between a local maximum and the previous global maximum. And attention should also be paid to the sign of local maximum. Here, `max_so_far` and `min_so_far` are introduced to track both maximum and minimum at certain index. Specifically, `max_so_far` at index `i` is the maximum among these three: `min_so_far*nums[i]`, `max_so_far*nums[i]` and `nums[i]` while `min_so_far` is the corresponding minimum. Finally, the global maximum `max_global` is the larger one between`max_so_far` and `max_global`.\\n\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        min_so_far, max_so_far, max_global = nums[0], nums[0], nums[0]\\n        for i in range(1, len(nums)):\\n            max_so_far, min_so_far = max(min_so_far*nums[i], max_so_far*nums[i], nums[i]), min(min_so_far*nums[i], max_so_far*nums[i], nums[i])\\n            max_global = max(max_global, max_so_far)\\n        \\n        return max_global\\n```\\n\\n**Notice**:\\n* The `max_so_far` and `min_so_far` should be updated simoutaneously to avoid error.\\n* Use two varibles (e.g. `temp1`,`temp2`) to take the updated `max_so_far` and `min_so_far` if the Python syntax `A, B = C, D` is not used.",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        min_so_far, max_so_far, max_global = nums[0], nums[0], nums[0]\\n        for i in range(1, len(nums)):\\n            max_so_far, min_so_far = max(min_so_far*nums[i], max_so_far*nums[i], nums[i]), min(min_so_far*nums[i], max_so_far*nums[i], nums[i])\\n            max_global = max(max_global, max_so_far)\\n        \\n        return max_global\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48358,
                "title": "java-2-ms-solution-using-sliding-window-with-explanation",
                "content": "The maximum product subarray would be the whole array unless two factors:\\n\\n 1. any `0` numbers that turn the product to `0`\\n 1. the total number of negative numbers that turn result to negative in case this number is odd\\n\\nIf we take these factors into account we can create simple sliding window solution that runs in `O(n)` and uses the least number of mathematical operations. \\n\\nAll possible products are hidden in ranges between `0` numbers - so we need to expand window only in these ranges. As soon as we meet `0` we just drop current product and lower pointer and proceed until non `0` number is met that means the start of new window. The only additional complication is factor 2): as soon as we reached the end of window (whether this is `0` or end of array) we need to check negativeness of total product. If it's negative - we need to increase lower pointer `lo` (and divide current product on `nums[lo]`) until the product becomes positive that can be only when lower pointer passes negative number.\\n\\nSo the whole algorithm:\\n\\n- initially `hi` and `lo` variables point at `0`\\n- we expand `hi` until `nums[hi] == 0` or the end of array is met. While expanding we recalculate current product and maximum product.\\n- if `0` is met and current product is **negative** - that means that current range contains odd number of negative numbers and we need to decrease range from left (and recalculate the product) until product becomes positive\\n- if `0` is met and current product is **positive** - just drop current product and lower pointer and start new window\\n- after the loop we need to check negativeness of the product again\\n\\n__________\\n    public int maxProduct(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n\\n        int lo = 0, hi = 0, N = nums.length;\\n        long max = Integer.MIN_VALUE, curr = 1;\\n\\n        while (hi < N) {\\n            if (nums[hi] == 0 && curr < 0 && lo < hi - 1) {\\n                curr /= nums[lo++];\\n                max = Math.max(curr, max);\\n            }\\n            else if (nums[hi] == 0) {\\n                max = Math.max(0, max);\\n                lo = ++hi;\\n                curr = 1;\\n            } else {\\n                curr *= nums[hi++];\\n                max = Math.max(curr, max);\\n            }\\n        }\\n        for (; curr < 0 && lo < N - 1; lo++) {\\n            curr /= nums[lo];\\n            max = Math.max(curr, max);\\n        }\\n\\n        return (int)max;\\n        }",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "The maximum product subarray would be the whole array unless two factors:\\n\\n 1. any `0` numbers that turn the product to `0`\\n 1. the total number of negative numbers that turn result to negative in case this number is odd\\n\\nIf we take these factors into account we can create simple sliding window solution that runs in `O(n)` and uses the least number of mathematical operations. \\n\\nAll possible products are hidden in ranges between `0` numbers - so we need to expand window only in these ranges. As soon as we meet `0` we just drop current product and lower pointer and proceed until non `0` number is met that means the start of new window. The only additional complication is factor 2): as soon as we reached the end of window (whether this is `0` or end of array) we need to check negativeness of total product. If it's negative - we need to increase lower pointer `lo` (and divide current product on `nums[lo]`) until the product becomes positive that can be only when lower pointer passes negative number.\\n\\nSo the whole algorithm:\\n\\n- initially `hi` and `lo` variables point at `0`\\n- we expand `hi` until `nums[hi] == 0` or the end of array is met. While expanding we recalculate current product and maximum product.\\n- if `0` is met and current product is **negative** - that means that current range contains odd number of negative numbers and we need to decrease range from left (and recalculate the product) until product becomes positive\\n- if `0` is met and current product is **positive** - just drop current product and lower pointer and start new window\\n- after the loop we need to check negativeness of the product again\\n\\n__________\\n    public int maxProduct(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n\\n        int lo = 0, hi = 0, N = nums.length;\\n        long max = Integer.MIN_VALUE, curr = 1;\\n\\n        while (hi < N) {\\n            if (nums[hi] == 0 && curr < 0 && lo < hi - 1) {\\n                curr /= nums[lo++];\\n                max = Math.max(curr, max);\\n            }\\n            else if (nums[hi] == 0) {\\n                max = Math.max(0, max);\\n                lo = ++hi;\\n                curr = 1;\\n            } else {\\n                curr *= nums[hi++];\\n                max = Math.max(curr, max);\\n            }\\n        }\\n        for (; curr < 0 && lo < N - 1; lo++) {\\n            curr /= nums[lo];\\n            max = Math.max(curr, max);\\n        }\\n\\n        return (int)max;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1608768,
                "title": "c-super-simple-and-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        // we keep also the minimum-product subarray for the case of multiplying negative with negative\\n        int max_pro = nums[0];\\n        int min_save = nums[0];\\n        int max_save = nums[0];\\n        \\n        for (int i = 1; i < nums.size(); i++) {\\n            // if we got a negative element, we will swap maximum with minimum\\n            if (nums[i] < 0)\\n                swap(min_save, max_save);\\n            min_save = min(nums[i], min_save*nums[i]);\\n            max_save = max(nums[i], max_save*nums[i]);\\n            max_pro = max(max_pro, max_save);\\n        }\\n        return max_pro;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        // we keep also the minimum-product subarray for the case of multiplying negative with negative\\n        int max_pro = nums[0];\\n        int min_save = nums[0];\\n        int max_save = nums[0];\\n        \\n        for (int i = 1; i < nums.size(); i++) {\\n            // if we got a negative element, we will swap maximum with minimum\\n            if (nums[i] < 0)\\n                swap(min_save, max_save);\\n            min_save = min(nums[i], min_save*nums[i]);\\n            max_save = max(nums[i], max_save*nums[i]);\\n            max_pro = max(max_pro, max_save);\\n        }\\n        return max_pro;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481299,
                "title": "java-easy-to-understand-0ms-100-fastest-solution",
                "content": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        \\n        int max = Integer.MIN_VALUE,temp=1;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            temp *= nums[i];\\n            max = Math.max(temp,max);\\n            if(temp == 0 )\\n                temp=1;\\n        }\\n        temp=1;\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            temp *= nums[i];\\n            max = Math.max(temp,max);\\n            if(temp == 0 )\\n                temp=1;\\n        }\\n        return max;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand\\n\\t\\t\\t\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        \\n        int max = Integer.MIN_VALUE,temp=1;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            temp *= nums[i];\\n            max = Math.max(temp,max);\\n            if(temp == 0 )\\n                temp=1;\\n        }\\n        temp=1;\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            temp *= nums[i];\\n            max = Math.max(temp,max);\\n            if(temp == 0 )\\n                temp=1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450150,
                "title": "simple-0ms-c-solution-kadane-s-algorithm-perfect-explaination",
                "content": "This question is the advance form of Maximum sum subarray(https://leetcode.com/problems/maximum-subarray/).\\n\\nIf you haven\\'t done this already then go give it a try\\n\\nIn this we take two variable maxVal and minVal which repersent then maximum possible value at any index and vice-versa for minVal intially both are equal to first value of given array and one more variable Product which has maximum Product intially is also equal to first value of array. \\n\\nThis is the description of solution now have a look on solution\\n```\\nint maxProduct(vector<int>& nums) {\\n       if(nums.size()==1) return nums[0];\\n       int MinVal=nums[0],MaxVal=nums[0];\\n       int Product=nums[0];\\n       for(int i=1;i<nums.size();i++){\\n           int ref=MaxVal;\\n           MaxVal=max(nums[i],max(nums[i]*MaxVal,nums[i]*MinVal));\\n           MinVal=min(nums[i],min(ref*nums[i],nums[i]*MinVal));\\n           Product=max(MaxVal,Product);\\n       }\\n        return Product;\\n    }\\n\\t\\n\\t```\\n\\t**I think this solution deserve a upvote. Thankyou!!**",
                "solutionTags": [],
                "code": "```\\nint maxProduct(vector<int>& nums) {\\n       if(nums.size()==1) return nums[0];\\n       int MinVal=nums[0],MaxVal=nums[0];\\n       int Product=nums[0];\\n       for(int i=1;i<nums.size();i++){\\n           int ref=MaxVal;\\n           MaxVal=max(nums[i],max(nums[i]*MaxVal,nums[i]*MinVal));\\n           MinVal=min(nums[i],min(ref*nums[i],nums[i]*MinVal));\\n           Product=max(MaxVal,Product);\\n       }\\n        return Product;\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 3074041,
                "title": "c-simply-explained-with-example-beginner-friendly",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we are taking 3 variables as maxi , mini and res. Which means maxi stores the maximum product till now, mini stores minimum product till now and res stores our answer in it.\\n\\nSo when we iterate over the array we are checking first for maximum product as it was asked in the question, then we are also checking for minimum product because let say we have negative values in our array. lets understand this with an example\\nmini = -10 right now and maxi = 4\\nand next element in the array is -2\\nafter this maxi = -10 * -2 = 20\\nso to get this we are maintaing minimum product also.\\n\\nThen in res we are storing the maximum value among the 3 variables which we used and return it.\\n\\nHope You get this.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        int maxi =1 , mini=1, res = INT_MIN;\\n\\n        for(int i =0;i<n;i++){\\n            int temp = maxi;\\n    // storing maxi in temp as it\\'s value will change in next line \\n            maxi = max({nums[i], maxi*nums[i], mini*nums[i]});\\n            mini = min({nums[i], temp*nums[i], mini*nums[i]});\\n\\n            res = max({maxi,mini,res});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        int maxi =1 , mini=1, res = INT_MIN;\\n\\n        for(int i =0;i<n;i++){\\n            int temp = maxi;\\n    // storing maxi in temp as it\\'s value will change in next line \\n            maxi = max({nums[i], maxi*nums[i], mini*nums[i]});\\n            mini = min({nums[i], temp*nums[i], mini*nums[i]});\\n\\n            res = max({maxi,mini,res});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841349,
                "title": "maximum-product-subarray-python-dp-explained",
                "content": "Approach:\\nCase 1: If the array  has only positive elements ( 0 not included ) , product of all the elements will be  returned as result.\\nCase 2: If the array has 0 in the array , the continuity will break , the subarray  with max product will be  returned.\\nIn this question we are dealing with negative numbers as well.\\nAt each element we need to maintain  two values \\n* **maximum positive product till the ith position** :  max ( ( **the current element** ) nums[i] ,\\n( **product of current element and the largest product calculated till now** ) max[i-1] * nums[i] , (**product of current element and the smallest product calculated till now** ) min[i-1] * nums[i] ) \\n* **maximum negative product till ith position**  : min ( ( **the current element** ) nums[i] ,\\n( **product of current element and the largest product calculated till now** ) max[i-1] * nums[i] , (**product of current element and the smallest product calculated till now** ) min[i-1] * nums[i] ) \\n\\nSolution:\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        m=[0]*len(nums)\\n        n=[0]*len(nums)\\n        m[0]=nums[0]\\n        n[0]=nums[0]\\n        for i in range(1,len(nums)):\\n            m[i]=max(nums[i],m[i-1]*nums[i],nums[i]*n[i-1])\\n            n[i]=min(nums[i],m[i-1]*nums[i],nums[i]*n[i-1])\\n        return max(m)\\n```\\n            \\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        m=[0]*len(nums)\\n        n=[0]*len(nums)\\n        m[0]=nums[0]\\n        n[0]=nums[0]\\n        for i in range(1,len(nums)):\\n            m[i]=max(nums[i],m[i-1]*nums[i],nums[i]*n[i-1])\\n            n[i]=min(nums[i],m[i-1]*nums[i],nums[i]*n[i-1])\\n        return max(m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 311193,
                "title": "c-o-n-time-dp-solution",
                "content": "class Solution {\\npublic:\\n    int maxProduct(vector<int>& a) {\\n        \\n        int i,n=a.size();\\n        \\n        int mini[n];\\n        int maxi[n];\\n        \\n        mini[0]=a[0];\\n        maxi[0]=a[0];\\n        \\n        int maxpro = a[0];\\n        for(i=1;i<n;i++) \\n        {\\n            if(a[i]>0)\\n            {\\n                maxi[i] = max(maxi[i-1]*a[i], a[i]);\\n                mini[i] = min(mini[i-1]*a[i], a[i]);\\n            }\\n            else\\n            {\\n                maxi[i] = max(mini[i-1]*a[i], a[i]);\\n                mini[i] = min(maxi[i-1]*a[i], a[i]);\\n            }\\n            maxpro = max(maxpro, maxi[i]);\\n        }\\n\\n        return maxpro;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int maxProduct(vector<int>& a) {\\n        \\n        int i,n=a.size();\\n        \\n        int mini[n];\\n        int maxi[n];\\n        \\n        mini[0]=a[0];\\n        maxi[0]=a[0];\\n        \\n        int maxpro = a[0];\\n        for(i=1;i<n;i++) \\n        {\\n            if(a[i]>0)\\n            {\\n                maxi[i] = max(maxi[i-1]*a[i], a[i]);\\n                mini[i] = min(mini[i-1]*a[i], a[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 48419,
                "title": "easy-understand-java-solution-o-n",
                "content": "public int maxProduct(int[] nums) {\\n        \\n        if(nums == null || nums.length == 0)\\n            return 0;\\n            \\n        int max_p = Integer.MIN_VALUE;\\n        int p = 1;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            p *= nums[i];\\n            max_p = Math.max(max_p, p);\\n            if(nums[i] == 0)\\n                p = 1;\\n            \\n        }\\n        p = 1;\\n        for(int i = nums.length - 1; i >= 0; i--){\\n            p *= nums[i];\\n            max_p = Math.max(max_p, p);\\n            if(nums[i] == 0)\\n                p = 1;\\n        } \\n        return max_p;\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public int maxProduct(int[] nums) {\\n        \\n        if(nums == null || nums.length == 0)\\n            return 0;\\n            \\n        int max_p = Integer.MIN_VALUE;\\n        int p = 1;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            p *= nums[i];\\n            max_p = Math.max(max_p, p);\\n            if(nums[i] == 0)\\n                p = 1;\\n            \\n        }\\n        p = 1;\\n        for(int i = nums.length - 1; i >= 0; i--){\\n            p *= nums[i];\\n            max_p = Math.max(max_p, p);\\n            if(nums[i] == 0)\\n                p = 1;\\n        } \\n        return max_p;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 48402,
                "title": "simpler-solution-with-6-lines-code-o-n-complexity",
                "content": "    class Solution {\\n    public:\\n        int maxProduct(int A[], int n) {\\n            int b=1, f=1, res=INT_MIN;\\n            for(int i=0; i<n; i++){\\n                res=max(res, max(b*=A[i],f*=A[n-1-i]));\\n                if(b==0) b=1; if(f==0) f=1;\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxProduct(int A[], int n) {\\n            int b=1, f=1, res=INT_MIN;\\n            for(int i=0; i<n; i++){\\n                res=max(res, max(b*=A[i],f*=A[n-1-i]));\\n                if(b==0) b=1; if(f==0) f=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3324218,
                "title": "8-lines-of-code-logic-dp",
                "content": "\\n\\n# Dynamic Programming\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        out=max(nums)\\n        cmax=cmin=1\\n        for n in nums:\\n            temp=cmax*n\\n            cmax=max(cmin*n,cmax*n,n)\\n            cmin=min(temp,cmin*n ,n)\\n            out=max(out,cmax)\\n        return out\\n//please upvote me it would encourage me alot\\n\\n        \\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        out=max(nums)\\n        cmax=cmin=1\\n        for n in nums:\\n            temp=cmax*n\\n            cmax=max(cmin*n,cmax*n,n)\\n            cmin=min(temp,cmin*n ,n)\\n            out=max(out,cmax)\\n        return out\\n//please upvote me it would encourage me alot\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382169,
                "title": "easy-solution-using-kadane-s-algorithm",
                "content": "**Kadane\\'s Algorithm**\\nThe simple idea of Kadane\\u2019s algorithm is to look for all positive contiguous segments of the array. And keep track of the maximum sum contiguous segment among all positive segments. The moment we find m as 0, reset m.\\n\\nI am traversing from right to left too. To understand this, lets take test case as [3,-1,4]. When we traverse from left to right, we will get ans as 3 whereas when we traverse from right to left, we will get ans as 4 which is the required ans. I hope this makes sense.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\n**Code in Java**\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int ans = Integer.MIN_VALUE;\\n        int m = 1;\\n        for(int i=0; i< nums.length; i++){\\n            m*=nums[i];\\n            ans = Math.max(m, ans);\\n            if(m == 0) m=1;\\n        }\\n        int n = 1;\\n        for(int i=nums.length-1; i>=0; i--){\\n            n*=nums[i];\\n            ans = Math.max(n, ans);\\n            if(n == 0) n=1;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Code in C++**\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int ans=INT_MIN;\\n        int m=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m*=nums[i];\\n            ans=max(ans,m);\\n            if(m==0) m=1;\\n        }\\n        int n=1;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            n*=nums[i];\\n            ans=max(ans,n);\\n            if(n==0) n=1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Please upvote if found helpful**\\n*Happy Coding :)*",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int ans = Integer.MIN_VALUE;\\n        int m = 1;\\n        for(int i=0; i< nums.length; i++){\\n            m*=nums[i];\\n            ans = Math.max(m, ans);\\n            if(m == 0) m=1;\\n        }\\n        int n = 1;\\n        for(int i=nums.length-1; i>=0; i--){\\n            n*=nums[i];\\n            ans = Math.max(n, ans);\\n            if(n == 0) n=1;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int ans=INT_MIN;\\n        int m=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m*=nums[i];\\n            ans=max(ans,m);\\n            if(m==0) m=1;\\n        }\\n        int n=1;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            n*=nums[i];\\n            ans=max(ans,n);\\n            if(n==0) n=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1993675,
                "title": "java-easy-to-undetrstand-0ms-kaden-s-algorithm",
                "content": "\\tclass Solution {\\n\\t\\tpublic int maxProduct(int[] nums) {\\n\\t\\t\\tint localProduct = 1;\\n\\t\\t\\tint maxProduct=nums[0];\\n\\t\\t\\tfor(int  i = 0; i < nums.length; i++){\\n\\t\\t\\t\\tlocalProduct *= nums[i];\\n\\t\\t\\t\\tif(maxProduct < localProduct){\\n\\t\\t\\t\\t\\tmaxProduct = localProduct;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(localProduct==0)\\n\\t\\t\\t\\t\\tlocalProduct = 1;\\n\\t\\t\\t}\\n\\t\\t\\tlocalProduct = 1;\\n\\t\\t\\tfor(int i = nums.length-1; i>=0;i--){\\n\\t\\t\\t\\tlocalProduct *= nums[i];\\n\\t\\t\\t\\tif(maxProduct<localProduct)\\n\\t\\t\\t\\t\\tmaxProduct = localProduct;\\n\\t\\t\\t\\tif(localProduct == 0)\\n\\t\\t\\t\\t\\tlocalProduct =1;\\n\\t\\t\\t}\\n\\t\\t\\treturn maxProduct;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int maxProduct(int[] nums) {\\n\\t\\t\\tint localProduct = 1;\\n\\t\\t\\tint maxProduct=nums[0];\\n\\t\\t\\tfor(int  i = 0; i < nums.length; i++){\\n\\t\\t\\t\\tlocalProduct *= nums[i];\\n\\t\\t\\t\\tif(maxProduct < localProduct){\\n\\t\\t\\t\\t\\tmaxProduct = localProduct;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1915658,
                "title": "why-kadane-s-solution-works-java-o-n-time-o-1-space",
                "content": "A Variation of Kadane\\'s Algorithm.\\n```\\nclass Solution{\\n\\tpublic int maxProduct(int[] nums) {\\n\\t\\tint pro=1, msf=nums[0];\\n\\t\\tint n=nums.length;\\n\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\tpro*=nums[i];\\n\\t\\t\\tif(pro>msf)\\n\\t\\t\\t\\tmsf=pro;\\n\\t\\t\\tif(pro==0)\\n\\t\\t\\t\\tpro=1;\\n\\t\\t}\\n\\t\\tpro=1;\\n\\t\\tfor(int i=n-1;i>=0;i--){\\n\\t\\t\\tpro*=nums[i];\\n\\t\\t\\tif(pro>msf)\\n\\t\\t\\t\\tmsf=pro;\\n\\t\\t\\tif(pro==0)\\n\\t\\t\\t\\tpro=1;\\n\\t\\t}\\n\\t\\treturn msf;\\n\\t}\\n}\\n\\n```\\n\\nTime `O(N)`\\nSpace `O(1)`\\n\\n**Why this solution works?**\\nThis solution works because it says that maximum product subarray possible for any array will include either the `0th` index or `(n-1)th` index or both for sure (Not considering 0 values as elements of array as of now). This is because an array will either have even or odd count of negatives.\\n\\nIf array has even count of `-ve` values, Max product will be the entire array.\\n\\nIf array has odd count of `-ve` values say `k`, then `(k-1)` will be even so considering `k-1` negative values will give us max product. Thus, we can consider first `k-1` negatives starting from left side of array or starting from right side of array. Therefore, i said either the  `0th` index or `(n-1)th` index will be part of answer for sure.\\nDidn\\'t get this? Do a dry run over this approach. Hint:  The `msf` variable will monitor how to consider only `k-1` negative values.\\n\\nFor 0 values as elements of array, we can reset the `pro` variable calculating product to 1 once again. Thus zeroes also get handled.\\n\\nHope you understand the solution. Do upvote if you did.\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n\\tpublic int maxProduct(int[] nums) {\\n\\t\\tint pro=1, msf=nums[0];\\n\\t\\tint n=nums.length;\\n\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\tpro*=nums[i];\\n\\t\\t\\tif(pro>msf)\\n\\t\\t\\t\\tmsf=pro;\\n\\t\\t\\tif(pro==0)\\n\\t\\t\\t\\tpro=1;\\n\\t\\t}\\n\\t\\tpro=1;\\n\\t\\tfor(int i=n-1;i>=0;i--){\\n\\t\\t\\tpro*=nums[i];\\n\\t\\t\\tif(pro>msf)\\n\\t\\t\\t\\tmsf=pro;\\n\\t\\t\\tif(pro==0)\\n\\t\\t\\t\\tpro=1;\\n\\t\\t}\\n\\t\\treturn msf;\\n\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1495612,
                "title": "c-recursion-using-dp-maximum-product-subarray",
                "content": "```\\nclass Solution {\\npublic:\\n    int max_=INT_MIN;\\n    map<int,map<int,long int>> dp;\\n    int solve(int temp,vector<int>& nums,int i)\\n    {\\n        if(i==nums.size()-1)\\n        {\\n            return max(max_,temp*nums[i]);\\n        }\\n        if(dp[temp][i]!=0)return dp[temp][i];\\n        int res1=solve(temp*nums[i],nums,i+1);\\n        int res2=solve(1,nums,i+1);\\n        max_=max(max(temp*nums[i],res1),max(max_,res2));\\n        return dp[temp][i]=max_;\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        return solve(1,nums,0);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int max_=INT_MIN;\\n    map<int,map<int,long int>> dp;\\n    int solve(int temp,vector<int>& nums,int i)\\n    {\\n        if(i==nums.size()-1)\\n        {\\n            return max(max_,temp*nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1025771,
                "title": "linear-time-constant-space-modified-kadane-explained-c-code",
                "content": "Folllowing are the possible cases:\\n1. Number is **+ve** -> Simply take it into the product subarray as it will increase the product.\\n2. Number is **0** -> In this case we need to restart our calculation. As taking this element into our subarray will make the product 0. It basically divides our subarray into parts. \\n3. Number of **-ve** elements are odd-> \\n**(This is the tricky part)**\\n\\nWe know a -ve number multiplied with another -ve number gives a positive number. eg. ((-2)x(-3) = 6)\\nSo if we have a subarray whose product is -ve then a new -ve number can be multiplied which will make the product positive. And this subarray can be our answer. Hence, we **also need to consider the minimum subarray** so far while finding our best subarray.\\nFor better understanding try solving this **test case** ->\\n[1, -6, -1, 3, 4, -1, 0]\\nIf minimum_prod_so_far is not considered,  the answer becomes 12 but it should be (-1*-6*3*4 = 72).\\n\\nWe can **modify Kadane\\'s Algorithm** for this.\\nWe need to consider four factors at every iteration:\\n1. nums[i]                           (*the present element as it can alone be greater than our best subarray so far and can be our answer*) \\n2. maximum_prod_so_far  (*the maximum subarray product so far*)\\n3. minimum_prod_so_far   (*the minimum subarray product so far*)\\n4. overall_max                    (*the answer*)\\n\\nAt any iteration **maximum_prod_so_far has three possible values.**\\na) Taking the present number into the product.\\nb) Present number alone can be our answer.\\nc) minimum_prod_so_far when multiplied with present number might give a better product.\\nSo we have to take the maximum of these 3.\\n\\nOur **answer will be** the maximum of all maximum_prod_so_far. And **when iterator is pointing to 0** then maximum of maximum_prod_so_far and 0 ( as 0 can also be our answer if maximum_prod_so_far is -ve).\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int overall_max = nums[0];\\n        int max_prod_so_far = nums[0];\\n        int min_prod_so_far = nums[0];\\n        \\n        for(int i=1; i<nums.size(); i++) {\\n            if(nums[i] == 0) {\\n                overall_max = max (overall_max, 0);\\n                max_prod_so_far = 1;\\n                min_prod_so_far = 1;\\n            }\\n            else {\\n                int temp = max_prod_so_far;\\n                max_prod_so_far = max(max_prod_so_far * nums[i], max (min_prod_so_far * nums[i], nums[i]));\\n                min_prod_so_far = min(min_prod_so_far * nums[i], min (temp * nums[i], nums[i]));\\n                \\n                overall_max = max (overall_max, max_prod_so_far);\\n            }\\n        }\\n        \\n        return overall_max;\\n    }\\n};\\n```\\n\\nThis code iterates once throughout the array hence **takes O(n) time**. And doesn\\'t needs any extra space or works in **constant space**.\\n\\n*Still stuck? Ask me in the comment box.\\nHave a better solution? Would love to know. :-)*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int overall_max = nums[0];\\n        int max_prod_so_far = nums[0];\\n        int min_prod_so_far = nums[0];\\n        \\n        for(int i=1; i<nums.size(); i++) {\\n            if(nums[i] == 0) {\\n                overall_max = max (overall_max, 0);\\n                max_prod_so_far = 1;\\n                min_prod_so_far = 1;\\n            }\\n            else {\\n                int temp = max_prod_so_far;\\n                max_prod_so_far = max(max_prod_so_far * nums[i], max (min_prod_so_far * nums[i], nums[i]));\\n                min_prod_so_far = min(min_prod_so_far * nums[i], min (temp * nums[i], nums[i]));\\n                \\n                overall_max = max (overall_max, max_prod_so_far);\\n            }\\n        }\\n        \\n        return overall_max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841691,
                "title": "c-fresh-approach-extremely-easy-o-n-implementation-can-be-translated-to-c-java",
                "content": "If there is no zero in an array, the solution is always one of the cumulative products starting from each ends. i.e.\\nFor -2,3,3,-1,-5 :\\nCumulative products from left end: -2,-6,-18,18,-90\\nSame from right end: -5,5,15,45,-90\\nAns: max of all = 45\\n\\nWe need to do this for each segment devided by one or more zeroes.\\n\\n```\\npublic class Solution {\\n    public int MaxProduct(int[] nums) {\\n        int ans = nums[0];\\n        int n = nums.Count();\\n        int p = 1, q=1;\\n        for(int i=0;i<n;i++){\\n\\t\\t    // reset to 1 when the product becomes zero\\n            p = (p==0?1:p)*nums[i];\\n            q = (q==0?1:q)*nums[n-1-i];\\n            ans = Math.Max(ans,Math.Max(p,q));\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxProduct(int[] nums) {\\n        int ans = nums[0];\\n        int n = nums.Count();\\n        int p = 1, q=1;\\n        for(int i=0;i<n;i++){\\n\\t\\t    // reset to 1 when the product becomes zero\\n            p = (p==0?1:p)*nums[i];\\n            q = (q==0?1:q)*nums[n-1-i];\\n            ans = Math.Max(ans,Math.Max(p,q));\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352038,
                "title": "easy-5-line-python-dp-solution-o-n-time-o-1-space",
                "content": "```\\n    def maxProduct(self, nums):\\n        prev_min = prev_max = global_max = nums[0]\\n        for num in nums[1:]:\\n            minn, maxx = min(num, prev_max*num, prev_min*num), max(num, prev_max*num, prev_min*num)\\n            prev_min, prev_max, global_max = minn, maxx, max(global_max, maxx)\\n        return global_max\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def maxProduct(self, nums):\\n        prev_min = prev_max = global_max = nums[0]\\n        for num in nums[1:]:\\n            minn, maxx = min(num, prev_max*num, prev_min*num), max(num, prev_max*num, prev_min*num)\\n            prev_min, prev_max, global_max = minn, maxx, max(global_max, maxx)\\n        return global_max\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 119171,
                "title": "simple-javascript-solution",
                "content": "```js\\nfunction maxProduct(nums) {\\n  let res = -Number.MAX_VALUE;\\n  let min = 1;\\n  let max = 1;\\n  for (let num of nums) {\\n    [min, max] = [\\n      Math.min(num, min * num, max * num),\\n      Math.max(num, min * num, max * num),\\n    ];\\n    res = Math.max(res, max);\\n  }\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction maxProduct(nums) {\\n  let res = -Number.MAX_VALUE;\\n  let min = 1;\\n  let max = 1;\\n  for (let num of nums) {\\n    [min, max] = [\\n      Math.min(num, min * num, max * num),\\n      Math.max(num, min * num, max * num),\\n    ];\\n    res = Math.max(res, max);\\n  }\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3608870,
                "title": "kind-of-an-intriguing-and-well-documented-approach-o-n-time-o-1-space-with-recursion",
                "content": "# Intuition\\nSo basically I divided all the possible cases into 3 criteria:\\n1. When the number of negative numbers is even and there are no zero in the given array.\\n2. When the number of negative numbers is odd and there are no zero in the given array.\\n3. When the array contains one or more zeroes. \\n\\nAccording to each criterion I handled the cases accordingly which you can see in the code as I handled 3 cases according to whether the product of the entire is positive, negative or zero. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIn the maxProduct(), I simply calculate the product of all the elements of the array and call the helper() with parameters that is easily understandable. This takes O(n) time.\\n\\n1. If the product is positive then I simply return it as the largest product.\\n2. If the product is negative then it is obvious that the subarray has negative numbers count is odd. In case of the array having size 1 and that single element being a negative number then that number is simply returned.\\n\\n    In other cases I simply calculate 2 products. First one is the product of all the numbers after the first negative number and the second product is the product of all the numbers before the last negative number.\\n\\n    If you think about it there is no other possible subarray that could have the largest product in case of a odd count of negative numbers. \\n\\n    Hence I simply return the larger of these two. This takes O(n) time and in case of no zeroes the execution ends here with the complexity upto O(2n) and constant space.\\n3. Now we come to the case where there are zeroes in the array. I dealt with this case by fragmenting the array into subarrays bordered by zeroes. Each subarray is executed again with recursion(now the start & end variables become relevant) and since these subarrays don\\'t contain zeroes themselves, therefore the third case in any recursion call is never executed and the recursion stack has the max size of 1. For each fragmented subarray the helper function is called and the maximum product is stored. \\n    If the maximum is negative then zero is returned, otherwise the calculated maximum is returned. \\n\\n    Since the recursion stack has the max size of 1, therefore the function uses constant space and as far as time is considered O(n) is used for traversing the array for zeroes and O(n) is used for traversing the subarrays in worst case of all the subarrays having odd count of negative numbers. Thus the worst case time complexity is O(3n). \\n\\nHope this clarifies everything\\uD83D\\uDE42.\\n    \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(3n) ~ O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int start, int end, int prod){\\n\\n        if(prod>0)\\n            return prod;\\n\\n        else if(prod<0){\\n            if(start==end)\\n                return prod;\\n            //calculate the product after first negative number\\n            int i=start;\\n            int fprod=1;\\n            while(true){\\n                if(nums[i]<0){\\n                    fprod*=nums[i];\\n                    break;\\n                }\\n\\n                fprod*=nums[i];\\n                i++;\\n            }\\n            //calculate the product before last negative number\\n            i=end;\\n            int bprod=1;\\n            while(true){\\n                if(nums[i]<0){\\n                    bprod*=nums[i];\\n                    break;\\n                }\\n\\n                bprod*=nums[i];\\n                i--;\\n            }\\n\\n            int contd1 = prod/fprod;\\n            int contd2 = prod/bprod;\\n\\n            return contd1>contd2 ? contd1:contd2;\\n        }\\n\\n        else {\\n            int i=0;\\n            int start=0;\\n            int big = INT_MIN;\\n            int temprod = 1;\\n            while(i<nums.size()){\\n                //for dealing with consecutive zeroes or the original array has nums[0]=0\\n                if(start==i && nums[i]==0){\\n                    start++;\\n                    i++;\\n                } \\n                //Recursion call made for subarray bordered by zeroes\\n                else if(nums[i]==0 && start!=i){\\n                    int contd = helper(nums, start, i-1, temprod);\\n                    start = i+1;\\n                    temprod = 1;\\n                    if(contd > big)\\n                        big = contd;\\n                    i++;\\n                }\\n                //Recursion call made for subarray after the last zero\\n                else if(i==nums.size()-1){\\n                    temprod = temprod * nums[i];\\n                    int contd = helper(nums, start, i, temprod);\\n                    if(contd > big)\\n                        big = contd;\\n                    temprod = 1;\\n                    i++;\\n                } else {\\n                    temprod = temprod * nums[i];\\n                    i++;\\n                }\\n            }\\n\\n            if(big<0)\\n                return 0;\\n            \\n            return big;\\n        }\\n    }\\n\\n    int maxProduct(vector<int>& nums) {\\n        int prod=1;\\n        for(int i=0;i<nums.size();i++){\\n            prod*=nums[i];\\n        }\\n        return helper(nums, 0, nums.size()-1, prod);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int start, int end, int prod){\\n\\n        if(prod>0)\\n            return prod;\\n\\n        else if(prod<0){\\n            if(start==end)\\n                return prod;\\n            //calculate the product after first negative number\\n            int i=start;\\n            int fprod=1;\\n            while(true){\\n                if(nums[i]<0){\\n                    fprod*=nums[i];\\n                    break;\\n                }\\n\\n                fprod*=nums[i];\\n                i++;\\n            }\\n            //calculate the product before last negative number\\n            i=end;\\n            int bprod=1;\\n            while(true){\\n                if(nums[i]<0){\\n                    bprod*=nums[i];\\n                    break;\\n                }\\n\\n                bprod*=nums[i];\\n                i--;\\n            }\\n\\n            int contd1 = prod/fprod;\\n            int contd2 = prod/bprod;\\n\\n            return contd1>contd2 ? contd1:contd2;\\n        }\\n\\n        else {\\n            int i=0;\\n            int start=0;\\n            int big = INT_MIN;\\n            int temprod = 1;\\n            while(i<nums.size()){\\n                //for dealing with consecutive zeroes or the original array has nums[0]=0\\n                if(start==i && nums[i]==0){\\n                    start++;\\n                    i++;\\n                } \\n                //Recursion call made for subarray bordered by zeroes\\n                else if(nums[i]==0 && start!=i){\\n                    int contd = helper(nums, start, i-1, temprod);\\n                    start = i+1;\\n                    temprod = 1;\\n                    if(contd > big)\\n                        big = contd;\\n                    i++;\\n                }\\n                //Recursion call made for subarray after the last zero\\n                else if(i==nums.size()-1){\\n                    temprod = temprod * nums[i];\\n                    int contd = helper(nums, start, i, temprod);\\n                    if(contd > big)\\n                        big = contd;\\n                    temprod = 1;\\n                    i++;\\n                } else {\\n                    temprod = temprod * nums[i];\\n                    i++;\\n                }\\n            }\\n\\n            if(big<0)\\n                return 0;\\n            \\n            return big;\\n        }\\n    }\\n\\n    int maxProduct(vector<int>& nums) {\\n        int prod=1;\\n        for(int i=0;i<nums.size();i++){\\n            prod*=nums[i];\\n        }\\n        return helper(nums, 0, nums.size()-1, prod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545220,
                "title": "c-java-python-javascript-space-o-1-clean-concise-easy-to-understand",
                "content": "# Intuition:\\nThe Solution aims to find the maximum product of a subarray within the given vector of integers. To achieve this, the code maintains three variables: `ans`, `maxp`, and `minp`. The variable `ans` keeps track of the maximum product found so far, `maxp` represents the maximum product ending at the current element, and `minp` represents the minimum product ending at the current element.\\n\\n# Approach:\\n1. The code initializes `ans`, `maxp`, and `minp` with the first element of the `nums` vector.\\n2. It then iterates over the elements of `nums` starting from the second element.\\n3. For each element at index `i`, the code calculates the maximum product considering three possibilities:\\n   - The current element alone (`nums[i]`).\\n   - The maximum product ending at the previous element (`maxp`) multiplied by the current element (`maxp * nums[i]`).\\n   - The minimum product ending at the previous element (`minp`) multiplied by the current element (`minp * nums[i]`).\\n4. The code updates `maxp` to the maximum value among the three possibilities using the `max` function.\\n5. Similarly, it updates `minp` to the minimum value among the three possibilities using the `min` function.\\n6. It updates `ans` to the maximum value between `maxp` and the current `ans`.\\n7. After iterating through all the elements, the code returns `ans`, which represents the maximum product of a subarray within `nums`.\\n\\n# Complexity:\\n- The time complexity of the code is O(n), where n is the size of the input vector `nums`. This is because the code iterates through all the elements once.\\n\\n- The space complexity of the code is O(1) since it only uses a constant amount of additional space to store the variables `ans`, `maxp`, and `minp`.\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n        int ans=nums[0], maxp = nums[0], minp = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            int temp = max({nums[i],maxp*nums[i],minp*nums[i]});\\n            minp = min({nums[i],maxp*nums[i],minp*nums[i]});\\n            maxp = temp;\\n            ans = max(maxp,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Java\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int ans = nums[0];\\n        int maxp = nums[0];\\n        int minp = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            int temp = Math.max(nums[i], Math.max(maxp * nums[i], minp * nums[i]));\\n            minp = Math.min(nums[i], Math.min(maxp * nums[i], minp * nums[i]));\\n            maxp = temp;\\n            ans = Math.max(maxp, ans);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```\\n# Python\\n```\\nclass Solution(object):\\n    def maxProduct(self, nums):\\n        ans = maxp = minp = nums[0]\\n        \\n        for i in range(1, len(nums)):\\n            temp = max(nums[i], maxp * nums[i], minp * nums[i])\\n            minp = min(nums[i], maxp * nums[i], minp * nums[i])\\n            maxp = temp\\n            ans = max(maxp, ans)\\n        \\n        return ans\\n\\n```\\n# JavaScript\\n```\\nvar maxProduct = function(nums) {\\n    var ans = nums[0];\\n    var maxp = nums[0];\\n    var minp = nums[0];\\n    \\n    for (var i = 1; i < nums.length; i++) {\\n        var temp = Math.max(nums[i], maxp * nums[i], minp * nums[i]);\\n        minp = Math.min(nums[i], maxp * nums[i], minp * nums[i]);\\n        maxp = temp;\\n        ans = Math.max(maxp, ans);\\n    }\\n    \\n    return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n        int ans=nums[0], maxp = nums[0], minp = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            int temp = max({nums[i],maxp*nums[i],minp*nums[i]});\\n            minp = min({nums[i],maxp*nums[i],minp*nums[i]});\\n            maxp = temp;\\n            ans = max(maxp,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int ans = nums[0];\\n        int maxp = nums[0];\\n        int minp = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            int temp = Math.max(nums[i], Math.max(maxp * nums[i], minp * nums[i]));\\n            minp = Math.min(nums[i], Math.min(maxp * nums[i], minp * nums[i]));\\n            maxp = temp;\\n            ans = Math.max(maxp, ans);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def maxProduct(self, nums):\\n        ans = maxp = minp = nums[0]\\n        \\n        for i in range(1, len(nums)):\\n            temp = max(nums[i], maxp * nums[i], minp * nums[i])\\n            minp = min(nums[i], maxp * nums[i], minp * nums[i])\\n            maxp = temp\\n            ans = max(maxp, ans)\\n        \\n        return ans\\n\\n```\n```\\nvar maxProduct = function(nums) {\\n    var ans = nums[0];\\n    var maxp = nums[0];\\n    var minp = nums[0];\\n    \\n    for (var i = 1; i < nums.length; i++) {\\n        var temp = Math.max(nums[i], maxp * nums[i], minp * nums[i]);\\n        minp = Math.min(nums[i], maxp * nums[i], minp * nums[i]);\\n        maxp = temp;\\n        ans = Math.max(maxp, ans);\\n    }\\n    \\n    return ans;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598311,
                "title": "javascript-solution-using-dynamic-programming-in-o-n-time-w-explanation",
                "content": "## Explanation\\nMy solution for this problem utilises **Dynamic Programming (DP)**. When looking at the question, I realised that to get a product of the sub array at a given index i, I can simple take the product of the sub array up until index i-1 and multiply with the current number. This would be much more efficient as compared to recalculating the product over again. Hence, DP would be very useful here since we can solve smaller sub-problems first to solve the bigger problem, and reuse previously computed products to optimize/speed up the solution.\\n\\nBut how do we utilise DP for this problem? These are the brief steps for my solution\\n\\n1.  I will simply interate through the array as per normal. However, as i traverse trhough the array, I will not ony keep track of the max product (currMax), but I will also keep track of the min product (currMin).\\n\\n2.  It is important to keep track of currMin due to the existence of negative numbers in the array. This is because, a multiplication of a negative currMin with another negative number, may result in this product being larger than a previously computed currMax.\\n\\n\\t***Note:*\\n*In my solution, I created a variable prevMax. This is mainly to be used when updating the currMin. currMax would have already been updated before currMin, but we still want to use the previous currMax in our min function. Therefore, we can simply create a temp variable that stores the currMax before it is updated***\\n\\n3.  Now, when updating the currMax and currMin we have to consider 3 different cases:\\n\\n\\t(a) Current Number\\n\\t(b) Current Number * Current Max\\n\\t(c) Current Number * Current Min\\n\\n\\tIt is easy to understand why we have to consider cases (b) and (c), since we are keeping track of the currMax and currMin up till that point. However, (a) is also crucial as there may be instances that the number itself could be larger or smaller than currMax and currMin respectively.\\n\\n4. Lastly, we update the variable res, which stores the greatest product calculated so far, by simply taking a max function of the current res and the currMax of the subarray being tracked.\\n\\n## Performance\\n\\nThe time complexity of this solution is linear, **O(n)**, since we solved the problem by having to pass through the array only once.\\n\\nHere are the details of my submission:\\nRuntime: 68 ms, faster than 97.42% \\nMemory Usage: 40.8 MB, less than 14.36% \\n\\n## Code\\n\\n```\\nvar maxProduct = function(nums) {\\n    var res = Math.max(...nums),\\n        currMin = 1,\\n        currMax = 1,\\n        prevMax = 1\\n    \\n    for (const num of nums){\\n        prevMax = currMax * num\\n        currMax = Math.max(prevMax, currMin*num, num)\\n        currMin = Math.min(prevMax, currMin*num, num)\\n        \\n        res = Math.max(res, currMax)\\n    }\\n    return res\\n};\\n```\\n\\nI hope this helps! Do let me know if there are any lapses in my explanation and/or if my solution can be improved in any way :)",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar maxProduct = function(nums) {\\n    var res = Math.max(...nums),\\n        currMin = 1,\\n        currMax = 1,\\n        prevMax = 1\\n    \\n    for (const num of nums){\\n        prevMax = currMax * num\\n        currMax = Math.max(prevMax, currMin*num, num)\\n        currMin = Math.min(prevMax, currMin*num, num)\\n        \\n        res = Math.max(res, currMax)\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1253370,
                "title": "java-easy-solution-o-n-complexity",
                "content": "\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int maxP=nums[0];  //Stores the maximum product soo far\\n        int minP=nums[0];  //Stores the minimum product soo far basically the -ve product\\n\\t\\tint ans=nums[0];   //Stores the answer to be returned\\n        \\n\\t\\tfor(int i=1;i<nums.length;i++){\\n            int first=nums[i];         //First Possibility\\n            int second=maxP*nums[i];   //Second Possibility\\n            int third=minP*nums[i];    //Third Possibility\\n            minP=Math.min( Math.min(first,second) ,third);\\n            maxP=Math.max( Math.max(first,second) ,third);\\n            ans=Math.max(ans,maxP);\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n(Note: variable ans is initialised as first element because in case only one element is given we need to return it.)\\n\\nNow let\\'s discuss about the possibilities,\\n1. First possibility : the current element is the maximum of all results soo far,\\n\\n2. Second possibilty : when we multiple the current element to out product, it becomes the maximum,\\n \\n3. Third possibility says that if the product obtained soo far is -ve and when we add the current element (a -ve element), it results in a positive product greater than the soo far computed max product.\\n\\nWe maintain two var. to check for soo far obtained max and min(-ve) product and check every possibilty.\\nTHANKS !!!",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int maxP=nums[0];  //Stores the maximum product soo far\\n        int minP=nums[0];  //Stores the minimum product soo far basically the -ve product\\n\\t\\tint ans=nums[0];   //Stores the answer to be returned\\n        \\n\\t\\tfor(int i=1;i<nums.length;i++){\\n            int first=nums[i];         //First Possibility\\n            int second=maxP*nums[i];   //Second Possibility\\n            int third=minP*nums[i];    //Third Possibility\\n            minP=Math.min( Math.min(first,second) ,third);\\n            maxP=Math.max( Math.max(first,second) ,third);\\n            ans=Math.max(ans,maxP);\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037018,
                "title": "python3-concise-memoization",
                "content": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        self.memo = {}\\n        def dfs(i, currentProduct):\\n            key = (i, currentProduct)\\n            if (key in self.memo):\\n                return self.memo[key]\\n            if (i >= len(nums)):\\n                return currentProduct\\n\\t\\t\\t# 3 choices, Include the current number in the product, start a new product, or end the product\\n            ans = max(dfs(i + 1, currentProduct * nums[i]), dfs(i + 1, nums[i]), currentProduct)\\n            self.memo[key] = ans\\n            return ans\\n        return dfs(1, nums[0])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        self.memo = {}\\n        def dfs(i, currentProduct):\\n            key = (i, currentProduct)\\n            if (key in self.memo):\\n                return self.memo[key]\\n            if (i >= len(nums)):\\n                return currentProduct\\n\\t\\t\\t# 3 choices, Include the current number in the product, start a new product, or end the product\\n            ans = max(dfs(i + 1, currentProduct * nums[i]), dfs(i + 1, nums[i]), currentProduct)\\n            self.memo[key] = ans\\n            return ans\\n        return dfs(1, nums[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841252,
                "title": "o-n-java-solution-with-video-explanation",
                "content": "<iframe width=\"650\" height=\"450\" src=\"https://www.youtube.com/embed/fOUieZzRuAk\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n```\\nclass MaximumProductSubArray {\\n    // Space => O(1), Time Complexity => O(n)\\n    public int maxProduct(int[] nums) {\\n        int maxSoFar = nums[0];\\n        int minSoFar = nums[0];\\n        int res = nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            int copyMaxSoFar = maxSoFar;\\n            int el = nums[i];\\n            maxSoFar = Math.max(el, Math.max(el*maxSoFar, el*minSoFar));\\n\\n            minSoFar = Math.min(el, Math.min(el*copyMaxSoFar, el*minSoFar));\\n            res = Math.max(res, maxSoFar);\\n        }\\n        return res;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "<iframe width=\"650\" height=\"450\" src=\"https://www.youtube.com/embed/fOUieZzRuAk\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n```\\nclass MaximumProductSubArray {\\n    // Space => O(1), Time Complexity => O(n)\\n    public int maxProduct(int[] nums) {\\n        int maxSoFar = nums[0];\\n        int minSoFar = nums[0];\\n        int res = nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            int copyMaxSoFar = maxSoFar;\\n            int el = nums[i];\\n            maxSoFar = Math.max(el, Math.max(el*maxSoFar, el*minSoFar));\\n\\n            minSoFar = Math.min(el, Math.min(el*copyMaxSoFar, el*minSoFar));\\n            res = Math.max(res, maxSoFar);\\n        }\\n        return res;\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 841169,
                "title": "python-3-dp-explanations",
                "content": "### Explanation\\n- `cur_max`: max product to current position (not max product before this position)\\n\\t- for [1,9,0,2], `cur_max` at index 3 is `2` not `9`, because max product to current position is only 2\\n- `cur_min`: min product to current position (not min product before this position)\\n\\t- for [-1,9,0,2], `cur_min` at index 3 is `2` not `-9`, because min product to current position is only 2; 0 seperated the global min and current min \\n- `ans` to get current max product\\n- case are handled differently depends on whether current number is positive or negative\\n- if `ans` is 0, nums is something like [-2, 0, -3] or [-2], so we return the max of `nums`\\n### Implementation\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        ans, cur_max, cur_min = -sys.maxsize, 0, 0\\n        for num in nums:\\n            if num > 0: cur_max, cur_min = max(num, num*cur_max), min(num, num*cur_min)\\n            else: cur_max, cur_min = max(num, num*cur_min), min(num, num*cur_max)  \\n            ans = max(ans, cur_max)    \\n        return ans if ans else max(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        ans, cur_max, cur_min = -sys.maxsize, 0, 0\\n        for num in nums:\\n            if num > 0: cur_max, cur_min = max(num, num*cur_max), min(num, num*cur_min)\\n            else: cur_max, cur_min = max(num, num*cur_min), min(num, num*cur_max)  \\n            ans = max(ans, cur_max)    \\n        return ans if ans else max(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529559,
                "title": "python-99-short-and-easy-to-read",
                "content": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:        \\n        res = cmin = cmax = nums[0]\\n        for n in nums[1:]:           \\n            cmin,cmax = min(n, cmin*n, cmax*n),max(n, cmin*n, cmax*n)\\n            if cmax > res: res = cmax        \\n        return res\\n```\\n\\nSo while the code is short, it had to solve a few problems.\\n\\n1. Initalization. Since we are guaranteed to have at least one element, we don\\'t need to bother checking input array size - we just use nums[0] to see our result and current max (cmax) and current min (cmin):\\n`res = cmin = cmax = nums[0]`\\n2. now we check the rest of the array: nums[1:] . `for n in nums[1:]:` Here we can have 1 out of  3 scenarios: we can start a new subarray, the previous subarray product keeps the sign or the sign changes. The fact that changing sign makes the largest product to be the smallest and vice versa needs to be addressed, so we keep track of the largest and the smallest products  (presumably a negative number).  Thanks to the Python we can do all that logic in one line:\\n`cmin,cmax = min(n, cmin*n, cmax*n),max(n, cmin*n, cmax*n)`\\n3. Finally, we need to keep track of the largest product so far:\\n`if cmax > res: res = cmax `\\nInterestingly, but if I replace that `if cmax > res: res = cmax ` with `res=max(res,cmax)` - that makes better looking code, but the execution time increases, so I kept that if for performance reasons.\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:        \\n        res = cmin = cmax = nums[0]\\n        for n in nums[1:]:           \\n            cmin,cmax = min(n, cmin*n, cmax*n),max(n, cmin*n, cmax*n)\\n            if cmax > res: res = cmax        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 402220,
                "title": "python-o-n",
                "content": "The key idea here is to keep track of two local products that are in imax and Imin. Now when you encounter a new number its going to be multiplied with both, in case its a negative number you are going to get the imin maximized and incase its a positive its going to get the imax maximized and both are going to be tallied against the global max in each iteration making sure we don\\'t miss the global max. \\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        global_max = nums[0]\\n        imax, imin = nums[0],nums[0]\\n        \\n        # Maintain local max, local min and global max!\\n        for i in range(1,len(nums)):\\n            # Once we have encountered a negative element we consider it by multiplying it. \\n            # print(local_min, local_max, global_max)\\n            candidates = (nums[i], imax * nums[i], imin * nums[i])\\n            imax = max(candidates)\\n            imin = min(candidates)            \\n            global_max = max(global_max, imax)\\n        return global_max",
                "solutionTags": [],
                "code": "The key idea here is to keep track of two local products that are in imax and Imin. Now when you encounter a new number its going to be multiplied with both, in case its a negative number you are going to get the imin maximized and incase its a positive its going to get the imax maximized and both are going to be tallied against the global max in each iteration making sure we don\\'t miss the global max. \\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        global_max = nums[0]\\n        imax, imin = nums[0],nums[0]\\n        \\n        # Maintain local max, local min and global max!\\n        for i in range(1,len(nums)):\\n            # Once we have encountered a negative element we consider it by multiplying it. \\n            # print(local_min, local_max, global_max)\\n            candidates = (nums[i], imax * nums[i], imin * nums[i])\\n            imax = max(candidates)\\n            imin = min(candidates)            \\n            global_max = max(global_max, imax)\\n        return global_max",
                "codeTag": "Java"
            },
            {
                "id": 48409,
                "title": "share-the-easiest-4ms-solution",
                "content": "    class Solution { public:\\n        int maxProduct(vector<int>& nums) {\\n            int cur=1;\\n            int res=INT_MIN;\\n            for(vector<int>::iterator it=nums.begin();it<nums.end();++it){\\n                cur*=*it;\\n                if(cur>res)res=cur;\\n                if(cur==0)cur=1;\\n            }\\n            cur=1;\\n            for(vector<int>::iterator it=nums.end()-1;it>=nums.begin();--it){\\n                cur*=*it;\\n                if(cur>res)res=cur;\\n                if(cur==0)cur=1;\\n            }\\n            return res;\\n        } };",
                "solutionTags": [],
                "code": "class Solution { public:\\n        int maxProduct(vector<int>& nums) {\\n            int cur=1;\\n            int res=INT_MIN;\\n            for(vector<int>::iterator it=nums.begin();it<nums.end();++it){\\n                cur*=*it;\\n                if(cur>res)res=cur;\\n                if(cur==0)cur=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 48444,
                "title": "an-implementation-of-the-suggested-solution-dynamic-programming",
                "content": "    int maxProduct(int A[], int n) {\\n        if(n == 0){\\n            return 0;\\n        }\\n        int* maxdp = new int[n];\\n        int* mindp = new int[n];\\n        maxdp[0] = A[0];\\n        mindp[0] = A[0];\\n        int maxProduct = A[0];\\n        for(int i = 1; i < n; i++){\\n            if(A[i] > 0){\\n                maxdp[i] = max(maxdp[i - 1] * A[i], A[i]);\\n                mindp[i] = min(mindp[i - 1] * A[i], A[i]);\\n            }\\n            else{\\n                maxdp[i] = max(mindp[i - 1] * A[i], A[i]);\\n                mindp[i] = min(maxdp[i - 1] * A[i], A[i]);\\n            }\\n            maxProduct = max(maxProduct, maxdp[i]);\\n        }\\n        return maxProduct;\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "    int maxProduct(int A[], int n) {\\n        if(n == 0){\\n            return 0;\\n        }\\n        int* maxdp = new int[n];\\n        int* mindp = new int[n];\\n        maxdp[0] = A[0];\\n        mindp[0] = A[0];\\n        int maxProduct = A[0];\\n        for(int i = 1; i < n; i++){\\n            if(A[i] > 0){\\n                maxdp[i] = max(maxdp[i - 1] * A[i], A[i]);\\n                mindp[i] = min(mindp[i - 1] * A[i], A[i]);\\n            }\\n            else{\\n                maxdp[i] = max(mindp[i - 1] * A[i], A[i]);\\n                mindp[i] = min(maxdp[i - 1] * A[i], A[i]);\\n            }\\n            maxProduct = max(maxProduct, maxdp[i]);\\n        }\\n        return maxProduct;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2859129,
                "title": "python-js-easy-logic-kadane-s-algo-concise-solution-o-1-dp-o-n-tc",
                "content": "**Upvote if it helped :)**\\n### python\\n```\\nclass Solution:    \\n    def maxProduct(self, nums):\\n        maxi = mini = res = nums[0]\\n\\n        for num in nums[1:]:\\n            currMax = max(maxi * num, mini * num, num)\\n            currMin = min(maxi * num, mini * num, num)\\n            maxi = currMax\\n            mini = currMin\\n            res = max(res, maxi)\\n        \\n        return res\\n```\\n### javascript\\n```\\nvar maxProduct = function(nums) {\\n    let mini, maxi, res;\\n    mini = maxi = res = nums[0];\\n    \\n    for (let num of nums.slice(1)) {\\n        const currMini = Math.min(num, num * maxi, num * mini);\\n        const currMaxi = Math.max(num, num * maxi, num * mini);\\n        maxi = currMaxi\\n        mini = currMini\\n        res = Math.max(res, maxi)\\n    }\\n    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:    \\n    def maxProduct(self, nums):\\n        maxi = mini = res = nums[0]\\n\\n        for num in nums[1:]:\\n            currMax = max(maxi * num, mini * num, num)\\n            currMin = min(maxi * num, mini * num, num)\\n            maxi = currMax\\n            mini = currMin\\n            res = max(res, maxi)\\n        \\n        return res\\n```\n```\\nvar maxProduct = function(nums) {\\n    let mini, maxi, res;\\n    mini = maxi = res = nums[0];\\n    \\n    for (let num of nums.slice(1)) {\\n        const currMini = Math.min(num, num * maxi, num * mini);\\n        const currMaxi = Math.max(num, num * maxi, num * mini);\\n        maxi = currMaxi\\n        mini = currMini\\n        res = Math.max(res, maxi)\\n    }\\n    \\n    return res\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139489,
                "title": "simple-easy-o-n-100-faster",
                "content": "**<++++ Press upvote Button please !!!!!!!!**\\n\\nExplanation >>\\n\\n*  [  2  ,  3  ,  -2  ,  4  ]\\n\\nFirst c1 = 0 , c2 = 0 , c3 = 0 , Max = 2 , Min = 2 , Res = 2 ;  // Res is Result\\n\\nWe Will start loop from i = 1 ;\\n\\n* When i = 1 :\\n\\t* Then c1 = 3 , c2 = 6 , c3 = 6 , Max = 6 , Min = 3 , Res = 6 ;\\n\\n* When i = 2:\\n\\t* Then c1 = -2 , c2 = -12 , c3 = -6 , Max = -2 , Min = -12 , Res = 6 ;\\n\\n* When i = 3 :\\n\\t* Then c1 = 4 , c2 = -6 , c3 = -48 , Max = 4 , Min = -48 , Res = 6 ;\\n\\nFinal ouput will be 6 .\\n\\n**To make it Simple just look if our array consist of another Number ( -2 ) in the end**\\n\\n* i.e : [  2  ,  3  ,  -2  ,  4  ,  -2  ]\\n* Then according to question Res should be Equal to 96\\n\\nIn previous example i.e [  2  ,  3  ,  -2  ,  4  ] \\n* When i = 3 :\\n\\t* Then c1 = 4 , c2 = -6 , c3 = -48 , Max = 4 , Min = -48 , Res = 6 ;\\n\\n* Then When i = 4 :\\n\\t* Then c1 = -2 , c2 = -8 , c3 = 96 , Max = 96 , Min = -8 , Res = 96 ; \\n\\n**You see Min becomes Max sometime and Max becomes Min some time  that\\'s because of product property.**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n        int Max = nums[0],\\n            Min = nums[0],\\n            Res = nums[0],\\n        \\n        c1=0,c2=0,c3=0;\\n        \\n        for( int i=1;i< nums.size(); i++)\\n        {\\n            c1 = nums[i];\\n            c2 = Max * nums[i];\\n            c3 = Min * nums[i];\\n            \\n            Max = max( c1, max( c2 , c3 ) );\\n            Min = min( c1, min( c2 , c3 ) );\\n            Res = max( Res, Max );\\n        }\\n        \\n        return Res;      \\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/8a3c6764-e656-4fda-bbda-95712bfc87d8_1654968528.4146075.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n        int Max = nums[0],\\n            Min = nums[0],\\n            Res = nums[0],\\n        \\n        c1=0,c2=0,c3=0;\\n        \\n        for( int i=1;i< nums.size(); i++)\\n        {\\n            c1 = nums[i];\\n            c2 = Max * nums[i];\\n            c3 = Min * nums[i];\\n            \\n            Max = max( c1, max( c2 , c3 ) );\\n            Min = min( c1, min( c2 , c3 ) );\\n            Res = max( Res, Max );\\n        }\\n        \\n        return Res;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119079,
                "title": "c-simple-explanation-o-n-time-and-o-1-space-without-dp",
                "content": "Let\\'s assume that there is no zero in the subarray\\n\\n**Logic : Let\\'s say the maximum subarray product is ans.**\\n\\n\\tthan the four posibilities will be : \\n\\n\\t.....left......ans.......right.....\\n\\n```\\n left                right\\n\\na) +                    -\\nb) +                    +\\nc) -                    -\\nd) -                    +\\n\\ncase a)\\n\\t\\tas left product is also positive than we must have to\\n\\t\\tinclude left subarray in ans\\n\\ncase b)\\n\\t\\tas left and right subarrays also giving the positive product subarrys\\n\\t\\tso left and right subarrays will also come in answer\\n\\ncase c)\\n\\t\\tas left and right subarrays product is neg so whole array product  will \\n\\t\\tbe the answer.\\n\\ncase d)\\n\\t\\tas the right subarray is giving positive subarray product so the ans will also include\\n\\t\\tright subarray\\n\\n\\nfrom all those four cases we are sure that the answer will either start from 0th index or \\nfrom n-1 th index.\\n\\n\\n\\n\\n\\nif there is zero in the subarray\\n\\n(........A.....)   0   (.....B.........)   0   (......C.......)   0   (.........D.......)\\n\\nthan the answer will be maximum of subarrays A,B,C,D........\\n```\\n\\n\\n\\n\\n```\\nint maxProduct(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tint ans = INT_MIN;\\n\\tint pro = 1;\\n\\tfor(int i = 0 ; i < n ; i++){\\n\\t\\tif(nums[i]){\\n\\t\\t\\tpro *= nums[i];\\n\\t\\t\\tans = max(ans,pro);\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tpro = 1;\\n\\t\\t\\tans = max(ans,0);\\n\\t\\t}\\n\\n        }\\n        pro = 1;\\n        for(int i = n-1 ; i >= 0 ; i--){\\n            if(nums[i]){\\n                pro *= nums[i];\\n                ans = max(ans,pro);\\n            }else{\\n                pro = 1;\\n                ans = max(ans,0);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n left                right\\n\\na) +                    -\\nb) +                    +\\nc) -                    -\\nd) -                    +\\n\\ncase a)\\n\\t\\tas left product is also positive than we must have to\\n\\t\\tinclude left subarray in ans\\n\\ncase b)\\n\\t\\tas left and right subarrays also giving the positive product subarrys\\n\\t\\tso left and right subarrays will also come in answer\\n\\ncase c)\\n\\t\\tas left and right subarrays product is neg so whole array product  will \\n\\t\\tbe the answer.\\n\\ncase d)\\n\\t\\tas the right subarray is giving positive subarray product so the ans will also include\\n\\t\\tright subarray\\n\\n\\nfrom all those four cases we are sure that the answer will either start from 0th index or \\nfrom n-1 th index.\\n\\n\\n\\n\\n\\nif there is zero in the subarray\\n\\n(........A.....)   0   (.....B.........)   0   (......C.......)   0   (.........D.......)\\n\\nthan the answer will be maximum of subarrays A,B,C,D........\\n```\n```\\nint maxProduct(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tint ans = INT_MIN;\\n\\tint pro = 1;\\n\\tfor(int i = 0 ; i < n ; i++){\\n\\t\\tif(nums[i]){\\n\\t\\t\\tpro *= nums[i];\\n\\t\\t\\tans = max(ans,pro);\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tpro = 1;\\n\\t\\t\\tans = max(ans,0);\\n\\t\\t}\\n\\n        }\\n        pro = 1;\\n        for(int i = n-1 ; i >= 0 ; i--){\\n            if(nums[i]){\\n                pro *= nums[i];\\n                ans = max(ans,pro);\\n            }else{\\n                pro = 1;\\n                ans = max(ans,0);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1506795,
                "title": "c-solution-memory-o-1-time-o-n-iterative-dp-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size(), dp = nums[n - 1], mx = nums[n - 1], dpmn = nums[n - 1];\\n        // dp contains max value of the last index\\n        // dpmn contains min value of the last index\\n        // I use dpmn in order to calculate the maximum value with negative numbers\\n        for(int i = n - 2; i >= 0; i--) {\\n            int x = max({nums[i], dp * nums[i], dpmn * nums[i]});\\n            dpmn = min({nums[i], dp * nums[i], dpmn * nums[i]});\\n            dp = x;\\n            if(dp > mx) mx = dp; \\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size(), dp = nums[n - 1], mx = nums[n - 1], dpmn = nums[n - 1];\\n        // dp contains max value of the last index\\n        // dpmn contains min value of the last index\\n        // I use dpmn in order to calculate the maximum value with negative numbers\\n        for(int i = n - 2; i >= 0; i--) {\\n            int x = max({nums[i], dp * nums[i], dpmn * nums[i]});\\n            dpmn = min({nums[i], dp * nums[i], dpmn * nums[i]});\\n            dp = x;\\n            if(dp > mx) mx = dp; \\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272401,
                "title": "90-faster-easy",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0)\\n        {\\n\\t\\t  return 0;\\n\\t\\t}\\n        if(n == 1)\\n        {\\n\\t\\t  return nums[0];\\n\\t\\t}\\n        int max_prod = 0;\\n        int curr_prod = 1;\\n        for(int i = 0 ; i < n ; i++) // Traverse in the forward direction \\n        {\\n            curr_prod *= nums[i];\\n            max_prod = max(max_prod , curr_prod);\\n            if(curr_prod == 0)\\n            {\\n                curr_prod = 1;\\n            }\\n        }\\n        curr_prod = 1;\\n        for(int i = n-1 ; i>=0 ; i--) // Traverse in the backward direction\\n        {\\n            curr_prod *= nums[i];\\n            max_prod = max(max_prod , curr_prod);\\n            if(curr_prod == 0)\\n            {\\n                curr_prod = 1;\\n            }\\n        }\\n        return max_prod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0)\\n        {\\n\\t\\t  return 0;\\n\\t\\t}\\n        if(n == 1)\\n        {\\n\\t\\t  return nums[0];\\n\\t\\t}\\n        int max_prod = 0;\\n        int curr_prod = 1;\\n        for(int i = 0 ; i < n ; i++) // Traverse in the forward direction \\n        {\\n            curr_prod *= nums[i];\\n            max_prod = max(max_prod , curr_prod);\\n            if(curr_prod == 0)\\n            {\\n                curr_prod = 1;\\n            }\\n        }\\n        curr_prod = 1;\\n        for(int i = n-1 ; i>=0 ; i--) // Traverse in the backward direction\\n        {\\n            curr_prod *= nums[i];\\n            max_prod = max(max_prod , curr_prod);\\n            if(curr_prod == 0)\\n            {\\n                curr_prod = 1;\\n            }\\n        }\\n        return max_prod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981322,
                "title": "python-3-using-kadane-s-algo",
                "content": "##### Runtime: **40 ms**, faster than **99.70%** of Python3 online submissions for Maximum Product Subarray.\\n##### Memory Usage: **14.3 MB**, less than **77.96%** of Python3 online submissions for Maximum Product Subarray.\\n```python\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        max_product = nums[0] \\n        min_product = nums[0]\\n        result = max_product\\n        for i in range(1,len(nums)):\\n            curr = nums[i]\\n            \\n            temp_max = max(curr , max_product*curr , min_product*curr)\\n            min_product = min(curr , max_product*curr , min_product*curr)\\n            max_product = temp_max\\n            \\n            result = max(max_product , result)\\n        \\n        return result\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        max_product = nums[0] \\n        min_product = nums[0]\\n        result = max_product\\n        for i in range(1,len(nums)):\\n            curr = nums[i]\\n            \\n            temp_max = max(curr , max_product*curr , min_product*curr)\\n            min_product = min(curr , max_product*curr , min_product*curr)\\n            max_product = temp_max\\n            \\n            result = max(max_product , result)\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 947589,
                "title": "similar-to-kadane-s-algorithm",
                "content": "class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n        \\n        int n = nums.size();\\n        int p = 1,p1 = 1;\\n        int res = INT_MIN;\\n        for(int i = 0;i<n;i++){\\n            p = p*nums[i];\\n            p1 = p1*nums[n-i-1];\\n            \\n            res = max(res,max(p,p1));\\n            \\n            \\n            if(p==0){\\n               p=1;\\n            }\\n            if(p1==0){\\n                p1=1;\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n        \\n        int n = nums.size();\\n        int p = 1,p1 = 1;\\n        int res = INT_MIN;\\n        for(int i = 0;i<n;i++){\\n            p = p*nums[i];\\n            p1 = p1*nums[n-i-1];\\n            \\n            res = max(res,max(p,p1));\\n            \\n            \\n            if(p==0){\\n               p=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 833735,
                "title": "c-easyunderstanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        if(nums.size()==0) return -1;\\n        int currmax=nums[0],currmin=nums[0],finalmax=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n           int temp=currmax;\\n           currmax=max(currmax*nums[i],max(currmin*nums[i],nums[i]));\\n           currmin=min(temp*nums[i],min(currmin*nums[i],nums[i]));\\n           if(currmax>finalmax) finalmax=currmax;\\n        }\\n        return finalmax;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        if(nums.size()==0) return -1;\\n        int currmax=nums[0],currmin=nums[0],finalmax=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n           int temp=currmax;\\n           currmax=max(currmax*nums[i],max(currmin*nums[i],nums[i]));\\n           currmin=min(temp*nums[i],min(currmin*nums[i],nums[i]));\\n           if(currmax>finalmax) finalmax=currmax;\\n        }\\n        return finalmax;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716775,
                "title": "simplest-logic-o-n-solution-100-accuracy",
                "content": "```\\nint maxProduct(vector<int>& nums) {  \\n        if(nums.size()==1)\\n          return nums[0];\\n        int curr_max=nums[0];\\n        int curr_min=nums[0]; \\n        int prev_min=nums[0]; \\n        int prev_max=nums[0]; \\n        int ans=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n          curr_max=max(nums[i]*prev_max,max(nums[i]*prev_min,nums[i]));\\n          curr_min=min(nums[i]*prev_min,min(nums[i]*prev_max,nums[i]));\\n          ans=max(ans,curr_max); \\n          prev_min=curr_min; \\n          prev_max=curr_max;\\n        } \\n        return ans;  \\n\\t\\t}\\n\\t\\t``` \\n\\t\\tIf you like my solution please upvote.Jai Hind.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxProduct(vector<int>& nums) {  \\n        if(nums.size()==1)\\n          return nums[0];\\n        int curr_max=nums[0];\\n        int curr_min=nums[0]; \\n        int prev_min=nums[0]; \\n        int prev_max=nums[0]; \\n        int ans=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n          curr_max=max(nums[i]*prev_max,max(nums[i]*prev_min,nums[i]));\\n          curr_min=min(nums[i]*prev_min,min(nums[i]*prev_max,nums[i]));\\n          ans=max(ans,curr_max); \\n          prev_min=curr_min; \\n          prev_max=curr_max;\\n        } \\n        return ans;  \\n\\t\\t}\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 386011,
                "title": "simplest-java-solution-beats-100-memory-100-o-n-time-o-1-space",
                "content": "**Here is my simple Java solution 2 for-loops.. \\none from [0->n] && [n-1 -> 0] :**\\n\\n```   \\n    public int maxProduct(int[] nums) {\\n        int max_product_so_far = Integer.MIN_VALUE;\\n\\n        int curr_product = 1;\\n        for(int i=0; i<nums.length; i++) {\\n            curr_product *= nums[i];\\n\\n            if(curr_product > max_product_so_far) {\\n                max_product_so_far = curr_product;\\n            }\\n\\n            if(curr_product == 0) {\\n                curr_product = 1;\\n            }\\n        }\\n\\n        curr_product = 1; // reset\\n        for(int i=nums.length-1; i>=0; i--) {\\n            curr_product *= nums[i];\\n\\n            if(curr_product > max_product_so_far) {\\n                max_product_so_far = curr_product;\\n            }\\n\\n            if(curr_product == 0) {\\n                curr_product = 1;\\n            }\\n        }\\n\\n        return max_product_so_far;\\n    }\\n```",
                "solutionTags": [],
                "code": "```   \\n    public int maxProduct(int[] nums) {\\n        int max_product_so_far = Integer.MIN_VALUE;\\n\\n        int curr_product = 1;\\n        for(int i=0; i<nums.length; i++) {\\n            curr_product *= nums[i];\\n\\n            if(curr_product > max_product_so_far) {\\n                max_product_so_far = curr_product;\\n            }\\n\\n            if(curr_product == 0) {\\n                curr_product = 1;\\n            }\\n        }\\n\\n        curr_product = 1; // reset\\n        for(int i=nums.length-1; i>=0; i--) {\\n            curr_product *= nums[i];\\n\\n            if(curr_product > max_product_so_far) {\\n                max_product_so_far = curr_product;\\n            }\\n\\n            if(curr_product == 0) {\\n                curr_product = 1;\\n            }\\n        }\\n\\n        return max_product_so_far;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 48461,
                "title": "a-naive-but-straigtforward-solution",
                "content": "When encounter a 0, split the sequence and get the max of the left, right, and 0.\\nIf the accumulative result is negative, check two cases: 1. divide out the elements from left till the first\\nnegative element. 2. divide out the elements from right till the first negative element. Return the max result.\\n\\n    int helper(int A[], int l, int r) {\\n        if (l > r) {\\n            return INT_MIN;\\n        }\\n        \\n        if (l == r) {\\n            return A[l];\\n        }\\n        \\n        int max_prod = INT_MIN;\\n        int acc = 1;\\n        for (int i = l; i <= r; ++i) {\\n            if (A[i] == 0) {\\n                return max(helper(A, l, i - 1), max(0, helper(A, i + 1, r)));\\n            }\\n            acc *= A[i];\\n            max_prod = max(max_prod, acc);\\n        }\\n        \\n        // find first negtive number from left and divide out elements before it (including itself).\\n        if (acc < 0) {\\n            for (int i = l; i <= r; ++i) {\\n                acc /= A[i];\\n                if (A[i] < 0) {\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return max(max_prod, acc);\\n    }\\n\\n    int maxProduct(int A[], int n) {\\n        return helper(A, 0, n - 1);\\n    }",
                "solutionTags": [],
                "code": "When encounter a 0, split the sequence and get the max of the left, right, and 0.\\nIf the accumulative result is negative, check two cases: 1. divide out the elements from left till the first\\nnegative element. 2. divide out the elements from right till the first negative element. Return the max result.\\n\\n    int helper(int A[], int l, int r) {\\n        if (l > r) {\\n            return INT_MIN;\\n        }\\n        \\n        if (l == r) {\\n            return A[l];\\n        }\\n        \\n        int max_prod = INT_MIN;\\n        int acc = 1;\\n        for (int i = l; i <= r; ++i) {\\n            if (A[i] == 0) {\\n                return max(helper(A, l, i - 1), max(0, helper(A, i + 1, r)));\\n            }\\n            acc *= A[i];\\n            max_prod = max(max_prod, acc);\\n        }\\n        \\n        // find first negtive number from left and divide out elements before it (including itself).\\n        if (acc < 0) {\\n            for (int i = l; i <= r; ++i) {\\n                acc /= A[i];\\n                if (A[i] < 0) {\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return max(max_prod, acc);\\n    }\\n\\n    int maxProduct(int A[], int n) {\\n        return helper(A, 0, n - 1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3266225,
                "title": "c-javascript-o-n-time-o-1-space-100-fast-comment-explained-max-prod-subarray",
                "content": "# Intuition\\n- The intuition behind the given code is to traverse the array twice, once from start to end and once from end to start, to find the maximum product subarray.\\n\\n- The key idea is to keep track of the current product of elements encountered so far during both traversals, and update the maximum product found so far accordingly. In case the current product becomes 0, it is reset to 1 because any further multiplication with 0 will result in a product of 0.\\n\\n- By traversing the array twice in opposite directions, the code ensures that it explores all possible subarrays that may result in a maximum product. By taking the maximum value obtained from both traversals, the code returns the maximum product subarray.\\n\\nOverall, the approach used in the code is intuitive and easy to understand, and provides an efficient solution to the maximum product subarray problem.\\n\\n# Approach\\nThe approach used in this code is to traverse the array twice but in one loop using two pointers - once from start to end, and once from end to start. During both traversals, two variables \"pro1\" and \"pro2\" are used to keep track of the current product of elements encountered so far, while another two variables \"max1\" and \"max2\" are used to store the maximum product found so far.\\n\\nFor the forward traversal, the code multiplies each element of the array with the current product \"pro1\" and updates \"max1\" with the maximum value obtained so far. If the current product \"pro1\" becomes 0, it is reset to 1 because any further multiplication with 0 will result in a product of 0.\\n\\nFor the backward traversal, the code multiplies each element of the array with the current product \"pro2\" and updates \"max2\" with the maximum value obtained so far. If the current product \"pro2\" becomes 0, it is reset to 1 because any further multiplication with 0 will result in a product of 0.\\n\\nFinally, the code returns the maximum value of \"max1\" and \"max2\" as the answer.\\n\\nThis approach takes O(N) time, where N is the size of the input array, and uses O(1) extra space, making it an efficient solution to the problem.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- **Time complexity:O(n)**\\nAs we are traversing the entire vector for only one time so we have a linear time complexity and that of the size of the vector.\\n\\n- **Space complexity: O(1)**\\nAs we have only used variables so we have space complexity of O(1)\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) \\n    {\\n        int max1=INT_MIN,pro1=1,max2=INT_MIN,pro2=1,s=nums.size();\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            //traversing from start to end and keeping the record for maximum current_product(pro1) we get till now\\n            pro1*=nums[i];\\n            max1=max(pro1,max1);//storing the maximum of current_product and max1 in max1;\\n            pro1=(pro1==0?1:pro1);// if we get 0 at any moment, we update the current_product(pro1) by 1.\\n            \\n            //traversing from end to start and keeping the record for maximum current_product(pro2) we get till now\\n            pro2*=nums[s-1-i];\\n            max2=max(pro2,max2);\\n            pro2=(pro2==0?1:pro2);// if we get 0 at any moment, we update the current_product(pro2) by 1.\\n        }\\n        return max(max1,max2);    \\n    }\\n};\\n```\\n\\n\\n# JavaScript\\n```\\nfunction max(a,b)\\n{\\n    if(a>b)\\n        return a;\\n    else\\n        return b;\\n};\\n\\nvar maxProduct = function(nums) \\n{\\n    var max1=-100,max2=-100,prod1=1,prod2=1,s=nums.length;\\n    for(var i=0;i<nums.length;i++)\\n    {\\n        //traversing from start to end and keeping the record for maximum current_product(pro1) we get till now\\n        prod1*=nums[i];\\n        max1=max(max1,prod1);//storing the maximum of current_product and max1 in max1;\\n        prod1=(prod1==0?1:prod1);// if we get 0 at any moment, we update the current_product(pro1) by 1.\\n\\n        //traversing from end to start and keeping the record for maximum current_product(pro2) we get till now\\n        prod2*=nums[s-1-i];\\n        max2=max(max2,prod2);\\n        prod2=(prod2==0?1:prod2);// if we get 0 at any moment, we update the current_product(pro2) by 1.     \\n    }    \\n    return max(max1,max2);\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) \\n    {\\n        int max1=INT_MIN,pro1=1,max2=INT_MIN,pro2=1,s=nums.size();\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            //traversing from start to end and keeping the record for maximum current_product(pro1) we get till now\\n            pro1*=nums[i];\\n            max1=max(pro1,max1);//storing the maximum of current_product and max1 in max1;\\n            pro1=(pro1==0?1:pro1);// if we get 0 at any moment, we update the current_product(pro1) by 1.\\n            \\n            //traversing from end to start and keeping the record for maximum current_product(pro2) we get till now\\n            pro2*=nums[s-1-i];\\n            max2=max(pro2,max2);\\n            pro2=(pro2==0?1:pro2);// if we get 0 at any moment, we update the current_product(pro2) by 1.\\n        }\\n        return max(max1,max2);    \\n    }\\n};\\n```\n```\\nfunction max(a,b)\\n{\\n    if(a>b)\\n        return a;\\n    else\\n        return b;\\n};\\n\\nvar maxProduct = function(nums) \\n{\\n    var max1=-100,max2=-100,prod1=1,prod2=1,s=nums.length;\\n    for(var i=0;i<nums.length;i++)\\n    {\\n        //traversing from start to end and keeping the record for maximum current_product(pro1) we get till now\\n        prod1*=nums[i];\\n        max1=max(max1,prod1);//storing the maximum of current_product and max1 in max1;\\n        prod1=(prod1==0?1:prod1);// if we get 0 at any moment, we update the current_product(pro1) by 1.\\n\\n        //traversing from end to start and keeping the record for maximum current_product(pro2) we get till now\\n        prod2*=nums[s-1-i];\\n        max2=max(max2,prod2);\\n        prod2=(prod2==0?1:prod2);// if we get 0 at any moment, we update the current_product(pro2) by 1.     \\n    }    \\n    return max(max1,max2);\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746278,
                "title": "c-approach-kadane-algorithm",
                "content": "\\n      int maxProduct(vector<int>& nums) {\\n        \\n        int max_product=INT_MIN;\\n        int curr_product = 1;\\n        // we will check the max product from both side of array\\n\\t\\t//prefix sum max\\n        for(int i=0; i<nums.size(); i++){\\n            curr_product *= nums[i];\\n            max_product = max(max_product, curr_product);\\n            if(nums[i]==0)\\n                curr_product=1;\\n        }\\n         curr_product = 1;\\n         //[3 , -1 , 4]  this array can\\'t give result if we just pass from front so we have to check from back also\\n\\t\\t //suffix sum max\\n         for(int i = nums.size()-1 ; i>=0 ; i--)\\n         {\\n             curr_product *= nums[i];\\n             \\n             max_product = max(max_product , curr_product);\\n             \\n             if(nums[i]==0)\\n                 curr_product = 1;\\n         }\\n         return max_product;\\n     }\\n\\t \\n// plzz upvote if u like the solution else ask any doubt",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n      int maxProduct(vector<int>& nums) {\\n        \\n        int max_product=INT_MIN;\\n        int curr_product = 1;\\n        // we will check the max product from both side of array\\n\\t\\t//prefix sum max\\n        for(int i=0; i<nums.size(); i++){\\n            curr_product *= nums[i];\\n            max_product = max(max_product, curr_product);\\n            if(nums[i]==0)\\n                curr_product=1;\\n        }\\n         curr_product = 1;\\n         //[3 , -1 , 4]  this array can\\'t give result if we just pass from front so we have to check from back also\\n\\t\\t //suffix sum max\\n         for(int i = nums.size()-1 ; i>=0 ; i--)\\n         {\\n             curr_product *= nums[i];\\n             \\n             max_product = max(max_product , curr_product);\\n             \\n             if(nums[i]==0)\\n                 curr_product = 1;\\n         }\\n         return max_product;\\n     }\\n\\t \\n// plzz upvote if u like the solution else ask any doubt",
                "codeTag": "Unknown"
            },
            {
                "id": 1467258,
                "title": "dp-solution-with-one-pass",
                "content": "At a moment, we need to keep track of the maximum product and the minimum product while parsing through the array. We will use a 2-D array to save max and min at a particular stage.\\nFor e.g., \\n`dp[i][0]` will store the maximum product\\n`dp[i][1]` will store the minimum product\\n\\nWe need to keep a track of the min product due to negative numbers. A negative result can become a higher positive number, when multiplied by another negative number.\\n\\n\\n```java\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n\\t\\t/* Array to keep track of max and min product at i */\\n        int[][] dp = new int[n][2];\\n\\t\\t\\n\\t\\t/* Initialize the base case scenario for dp */\\n        int result = nums[0];\\n        dp[0][0] = result;\\n        dp[0][1] = result;\\n        \\n        for(int i = 1; i < n; i++){\\n            if(nums[i] >= 0){\\n\\t\\t\\t/* If the current number is greater than zero, we will get the maximum by multiplying with the last max value */\\n                dp[i][0] = Math.max(dp[i-1][0] * nums[i], nums[i]);\\n                dp[i][1] = Math.min(dp[i-1][1] * nums[i], nums[i]);\\n            } else {\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\tIf the current number is negative, \\n\\t\\t\\t\\twe will get the maximum value by multiplying with the last min value \\n\\t\\t\\t\\tHence, max is checked with dp[i-1][1], i.e, the last min value.\\n\\t\\t\\t\\t*/\\n                dp[i][0] = Math.max(dp[i-1][1] * nums[i], nums[i]);\\n                dp[i][1] = Math.min(dp[i-1][0] * nums[i], nums[i]);\\n            }\\n            \\n            result = Math.max(result, dp[i][0]);\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n\\t\\t/* Array to keep track of max and min product at i */\\n        int[][] dp = new int[n][2];\\n\\t\\t\\n\\t\\t/* Initialize the base case scenario for dp */\\n        int result = nums[0];\\n        dp[0][0] = result;\\n        dp[0][1] = result;\\n        \\n        for(int i = 1; i < n; i++){\\n            if(nums[i] >= 0){\\n\\t\\t\\t/* If the current number is greater than zero, we will get the maximum by multiplying with the last max value */\\n                dp[i][0] = Math.max(dp[i-1][0] * nums[i], nums[i]);\\n                dp[i][1] = Math.min(dp[i-1][1] * nums[i], nums[i]);\\n            } else {\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\tIf the current number is negative, \\n\\t\\t\\t\\twe will get the maximum value by multiplying with the last min value \\n\\t\\t\\t\\tHence, max is checked with dp[i-1][1], i.e, the last min value.\\n\\t\\t\\t\\t*/\\n                dp[i][0] = Math.max(dp[i-1][1] * nums[i], nums[i]);\\n                dp[i][1] = Math.min(dp[i-1][0] * nums[i], nums[i]);\\n            }\\n            \\n            result = Math.max(result, dp[i][0]);\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376980,
                "title": "c-o-n-time-kadane-s-algorithm",
                "content": "```\\n    int maxProduct(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        ll maxEnding = nums[0];\\n        ll minEnding = nums[0];\\n        ll res = nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n           ll x = nums[i];\\n           if(x<0)\\n               swap(minEnding, maxEnding);\\n           minEnding = min(x,minEnding*x);\\n           maxEnding = max(x,maxEnding*x);\\n            \\n           res=max(res,maxEnding); \\n        }\\n        return res;   \\n    }\\n\\t\\n\\tPlease Upovote if you got any help from my code :)",
                "solutionTags": [],
                "code": "```\\n    int maxProduct(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        ll maxEnding = nums[0];\\n        ll minEnding = nums[0];\\n        ll res = nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n           ll x = nums[i];\\n           if(x<0)\\n               swap(minEnding, maxEnding);\\n           minEnding = min(x,minEnding*x);\\n           maxEnding = max(x,maxEnding*x);\\n            \\n           res=max(res,maxEnding); \\n        }\\n        return res;   \\n    }\\n\\t\\n\\tPlease Upovote if you got any help from my code :)",
                "codeTag": "Unknown"
            },
            {
                "id": 843820,
                "title": "say-goodbye-to-kadane-hello-to-intuitive-o-n-prefix-sum-solution-java",
                "content": "Why wrap your head around complicated kadane logic?\\n\\nPrefix sums are applicable for the majority of product or sum subarray problems.\\nSo whenever you see finding sum or product subarrays that meet a certain criteria, prefix sums should be the first thing that jump to your head. \\n\\nThis problem is a  bit tricker than maximum sum, but the idea is the same.\\nWe keep a running product, and divide by previous subarrays to maximize our results.\\n\\nThere are 3 cases to note:\\n1. if the running product is positive we can just be greedy and take the entire running product\\n2. if the running product is negative, we need to divide by the previous largest negative running product (or the running product that is closest to zero). We do this because we want the subarray to have the highest possible result.\\n3. if current number is zero, then this is essentially a reset, and we reset all our variables except the max and act as if the array had been bisected.\\n```\\npublic int maxProduct(int[] nums) {\\n        int runningProduct = 1;\\n        int max = nums[0];\\n        int largestNegative = Integer.MIN_VALUE;\\n        \\n        for (int num: nums) {\\n            runningProduct *= num;\\n            max = Math.max(max, runningProduct);\\n\\t\\t\\t// reset if zero\\n            if (num == 0) {\\n                runningProduct = 1;\\n                largestNegative = Integer.MIN_VALUE;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Our product is negative \\n            if (runningProduct < 0) {\\n                if (largestNegative != Integer.MIN_VALUE) {\\n\\t\\t\\t\\t// Divide by negative number closest to zero to maximize subarray\\n                    max = Math.max(max, runningProduct / largestNegative); \\n                }\\n                largestNegative = Math.max(largestNegative, runningProduct);\\n            }\\n        }\\n        return max;\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\npublic int maxProduct(int[] nums) {\\n        int runningProduct = 1;\\n        int max = nums[0];\\n        int largestNegative = Integer.MIN_VALUE;\\n        \\n        for (int num: nums) {\\n            runningProduct *= num;\\n            max = Math.max(max, runningProduct);\\n\\t\\t\\t// reset if zero\\n            if (num == 0) {\\n                runningProduct = 1;\\n                largestNegative = Integer.MIN_VALUE;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Our product is negative \\n            if (runningProduct < 0) {\\n                if (largestNegative != Integer.MIN_VALUE) {\\n\\t\\t\\t\\t// Divide by negative number closest to zero to maximize subarray\\n                    max = Math.max(max, runningProduct / largestNegative); \\n                }\\n                largestNegative = Math.max(largestNegative, runningProduct);\\n            }\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 841111,
                "title": "c-o-n-with-comment",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProduct(std::vector<int>& nums) {\\n        int n = nums.size();\\n        if (n==0) return 0;\\n        int R = nums[0];\\n        /*\\n        The idea is to traverse array from left to right keeping two variables minVal and maxVal \\n        which represents the minimum and maximum product value till the ith index of the array. \\n        Now, if the ith element of the array is negative that means now the values of minVal and maxVal \\n        will be swapped as value of maxVal will become minimum by multiplying it with a negative number. \\n        Now, compare the minVal and maxVal. The value of minVal and maxVal depends on the current index \\n        element or the product of the current index element and the previous minVal and maxVal respectively.\\n        */\\n        int maxVal = R, minVal = R;\\n        for (int i = 1; i < n; i++) { \\n  \\n            // When multiplied by -ve number, \\n            // maxVal becomes minVal \\n            // and minVal becomes maxVal. \\n            if (nums[i] < 0) std::swap(maxVal, minVal);\\n  \\n            // maxVal and minVal stores the \\n            // product of subarray ending at arr[i]. \\n            maxVal = std::max(nums[i], maxVal * nums[i]); \\n            minVal = std::min(nums[i], minVal * nums[i]); \\n  \\n            // Max Product of array. \\n            R = max(R, maxVal); \\n        } \\n        return R;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(std::vector<int>& nums) {\\n        int n = nums.size();\\n        if (n==0) return 0;\\n        int R = nums[0];\\n        /*\\n        The idea is to traverse array from left to right keeping two variables minVal and maxVal \\n        which represents the minimum and maximum product value till the ith index of the array. \\n        Now, if the ith element of the array is negative that means now the values of minVal and maxVal \\n        will be swapped as value of maxVal will become minimum by multiplying it with a negative number. \\n        Now, compare the minVal and maxVal. The value of minVal and maxVal depends on the current index \\n        element or the product of the current index element and the previous minVal and maxVal respectively.\\n        */\\n        int maxVal = R, minVal = R;\\n        for (int i = 1; i < n; i++) { \\n  \\n            // When multiplied by -ve number, \\n            // maxVal becomes minVal \\n            // and minVal becomes maxVal. \\n            if (nums[i] < 0) std::swap(maxVal, minVal);\\n  \\n            // maxVal and minVal stores the \\n            // product of subarray ending at arr[i]. \\n            maxVal = std::max(nums[i], maxVal * nums[i]); \\n            minVal = std::min(nums[i], minVal * nums[i]); \\n  \\n            // Max Product of array. \\n            R = max(R, maxVal); \\n        } \\n        return R;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 624591,
                "title": "thoroughly-explained-0ms-solution",
                "content": "Its like the kadan\\'s algorithm for maximum subarray sum. In the first pass, we calculate subarray products between any two zeroes in the array and update the maximum product. In the second pass we do the same thing but from backwards. So why we did this?\\nIf we didn\\'t had negative numbers, first pass itself would have given the us answer. But we have negative numbers, so** between any two zeroes** ,number of negative numbers can be even or odd. If they are even ,then first and second pass products between the two zeroes will be same. But if they are odd then first pass will keep the product till the last negative number and the second pass will keep the product excluding numbers before first negative number.Then we will update maximum of them. \\nFor Example: [1,0,-3,4,-6,-5,9,0,2]\\nBetween the two zeroes, first pass will give ((-3)*4*(-6)) as max product and second pass will give 9*(-5)*(-6)*4 as maxproduct and result will update maximum of them.\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int prod = 1;\\n        int result = Integer.MIN_VALUE;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            prod = prod * nums[i];\\n            result = Math.max(prod, result);\\n            if(prod == 0) {\\n                prod = 1;\\n            }\\n        }\\n        prod = 1;\\n        \\n        for(int i = nums.length - 1; i >= 0; i--) {\\n        \\n            prod = prod * nums[i];\\n            result = Math.max(prod, result);\\n            if(prod == 0) {\\n                prod = 1;\\n            }      \\n        }\\n        return result;\\n    }\\n}```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int prod = 1;\\n        int result = Integer.MIN_VALUE;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            prod = prod * nums[i];\\n            result = Math.max(prod, result);\\n            if(prod == 0) {\\n                prod = 1;\\n            }\\n        }\\n        prod = 1;\\n        \\n        for(int i = nums.length - 1; i >= 0; i--) {\\n        \\n            prod = prod * nums[i];\\n            result = Math.max(prod, result);\\n            if(prod == 0) {\\n                prod = 1;\\n            }      \\n        }\\n        return result;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 521432,
                "title": "python-3-simple-dp",
                "content": "If the array had all positive numbers, then the max product includes all the elements in the array\\n\\nAs we have +ve,  -ve integers and 0 in the input array, there are 3 choices at every index `i`\\n\\n1. Max product starts at `nums[i]`\\n2. Max product is obtained by multiplying  `nums[i]` with the minimum product so far\\n3. Max product is obtained by mulitiplying `nums[i]` with the maximum product so far\\n\\n\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int\\n        \\n        ans = max_so_far = min_so_far = nums[0]\\n        \\n        for i in range(1, len(nums)):\\n            \\n            candidates = (nums[i], max_so_far*nums[i], min_so_far*nums[i])\\n            max_so_far = max(candidates)\\n            min_so_far = min(candidates)\\n            ans = max(ans, max_so_far)\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int\\n        \\n        ans = max_so_far = min_so_far = nums[0]\\n        \\n        for i in range(1, len(nums)):\\n            \\n            candidates = (nums[i], max_so_far*nums[i], min_so_far*nums[i])\\n            max_so_far = max(candidates)\\n            min_so_far = min(candidates)\\n            ans = max(ans, max_so_far)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 488903,
                "title": "100-with-detailed-explanation-o-n-time-0-1-space",
                "content": "First of all, you better be familiar with the \"Max Contiguous Subarray Sum\" problem, as this one is a modification (and the more complicated one, on my mind).\\n\\nThe general idea is: on each step we have a choise: \\n1) either we want to continue to join to the sequence \\n2) or to start a new sequence\\n\\nThat is pretty easy to decide, if we want to know a SUM or we don\\'t have negative numbers (but have zeros).\\nAssume that we don\\'t have negative, but have zeroes.\\nIn that case the only possible options for a max product are the islands that lie between zeroes.\\nWe solve that easily by the general idea mentioned above, particulary with: `max = Math.max(max * nums[i], nums[i])`\\n\\nThen the case, with negative numbers happens to appear.\\nIf you think about it, negative numbers don\\'t matter if their amount is even. Following this idea, we could have an intuition that if we have already stepped on a negative number before, and we do it again at the current iteration, then we\\'d like to know about it. Here `min` logic comes.\\n\\nWe store `min` value in the same way as we do with `max`. And we use it every time when we step on the negative number - we swap the `min` and the `max` and it is important that we do that before we do the next choice.\\n\\nNote, that it means we don\\'t always have `max` as the absolute maximum value (as we do in the similar \"sum\" problem), for that purpose we use `result` variable.\\n\\n```\\nvar maxProduct = function(nums) {\\n    let max = nums[0]\\n    let min = nums[0]\\n    let result = nums[0]\\n    \\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] < 0) {\\n            let temp = min\\n            min = max\\n            max = temp\\n        }\\n        \\n\\t\\t// make the choice\\n        max = Math.max(max * nums[i], nums[i])\\n        min = Math.min(min * nums[i], nums[i])\\n        result = Math.max(result, max)\\n    }\\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxProduct = function(nums) {\\n    let max = nums[0]\\n    let min = nums[0]\\n    let result = nums[0]\\n    \\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] < 0) {\\n            let temp = min\\n            min = max\\n            max = temp\\n        }\\n        \\n\\t\\t// make the choice\\n        max = Math.max(max * nums[i], nums[i])\\n        min = Math.min(min * nums[i], nums[i])\\n        result = Math.max(result, max)\\n    }\\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 481891,
                "title": "python-o-n-rolling-kadane-algo-w-explanation",
                "content": "[DP solution tutorial video DP\\u52D5\\u614B\\u898F\\u5283\\u89E3\\u7B54\\u7684\\u89E3\\u984C\\u5F71\\u7247](https://www.youtube.com/watch?v=BBA1wARHhU0)\\n\\n\\nPython O( n ) sol. by rolling twice.\\n\\n\\'\\'\\'\\nExample explanation:\\n\\ninput = [ 2, 3, -2, 4 ]\\n\\nproduct_left_to_right = input = [ 2, 3, -2, 4 ]\\n\\nproduct_right_to_left = input[::-1] = [ 4, -2, 3, 2 ]\\n\\n---\\n\\n1st iteration:\\n\\n6 = 3 * 2\\nproduct_left_to_right = [ 2, **6**, -2, 4 ] \\n\\n-8 = -2 * 4\\nproduct_right_to_left = [ 4, **-8**, 3, 2 ]\\n\\n---\\n\\n2nd iteration:\\n\\n-12 = -2 * 6\\nproduct_left_to_right = [ 2, 6, **-12**, 4 ] \\n\\n-24 = 3 * -8\\nproduct_right_to_left = [ 4, -8, **-24**, 2 ]\\n\\n---\\n\\n3rd iteration:\\n\\n-48 = 4 * -12\\nproduct_left_to_right = [ 2, 6, -12, **-48** ] \\n\\n-48 = 2 * -24\\nproduct_right_to_left = [ 4, -8, -24, **-48** ]\\n\\n\\n---\\n\\ncomparison of max:\\n\\nmax of product_left_to_right = [ 2, **6**, -12, -48 ]  = **6**\\n\\nmax of product_right_to_left = [ **4**, -8, -24, -48 ] = **4**\\n\\n---\\n\\nmax of ( **6**, **4** ) = **6**\\n\\nreturn **6**\\n\\n\\'\\'\\'\\n\\n---\\n\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        \\n        size = len(nums)\\n        \\n        product_left_to_right = nums\\n        \\n        product_right_to_left = nums[::-1]\\n        \\n        # update product of two kinds of subarray, \\n\\t\\t# one is extending from left to right, the other is from right to left\\n        for i in range(1, size):\\n            \\n            # extends from left hand side, if meets 0 then restart in-place by itself.\\n\\t\\t\\t\\n            product_left_to_right[i] *= (product_left_to_right[i-1] or 1)\\n            \\n\\t\\t\\t\\n            # extends from right hand side, if meets 0 then restart in-place by itself\\n\\t\\t\\t\\n            product_right_to_left[i] *= (product_right_to_left[i-1] or 1)\\n            \\n\\t\\t\\t\\n        return max(max(product_left_to_right), max(product_right_to_left))\\n```\\n\\n---\\n\\nShare another implementation with Kadane\\'s algorithm\\n\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        \\n        global_max = prev_max = prev_min = nums[0]\\n        \\n        for number in nums[1:]:\\n            \\n            # local max comes from product of two positive numbers or product of two negative numbers\\n            local_max = max(prev_max * number, prev_min * number, number)\\n            local_min = min(prev_max * number, prev_min * number, number)\\n            \\n\\t\\t\\t# update global max\\n            global_max = max(global_max, local_max)\\n            \\n            prev_max, prev_min = local_max, local_min\\n            \\n        \\n        return global_max\\n```\\n\\n---\\n\\nShare another implementation with Kadane algorithm in top-down DP\\n\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        \\n        \\n        def dp( i ):\\n            \\n            if i == 0:\\n                # Base case on index 0\\n                # min value, max value, max product are first value in array\\n                return nums[0], nums[0], nums[0]\\n            \\n            \\n            ## General cases\\n            \\n            prev_min, prev_max, prev_product = dp(i-1)\\n            \\n            # local max comes from product of two positive numbers, or product of two negative numbers\\n            candidate = [prev_min * nums[i], prev_max * nums[i], nums[i] ]\\n            cur_min = min( candidate )\\n            cur_max = max( candidate )\\n            product = max(prev_product, cur_max)\\n            \\n            return cur_min, cur_max, product\\n        \\n        # ----------------------------------------\\n        return dp( len(nums)-1 )[2]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        \\n        size = len(nums)\\n        \\n        product_left_to_right = nums\\n        \\n        product_right_to_left = nums[::-1]\\n        \\n        # update product of two kinds of subarray, \\n\\t\\t# one is extending from left to right, the other is from right to left\\n        for i in range(1, size):\\n            \\n            # extends from left hand side, if meets 0 then restart in-place by itself.\\n\\t\\t\\t\\n            product_left_to_right[i] *= (product_left_to_right[i-1] or 1)\\n            \\n\\t\\t\\t\\n            # extends from right hand side, if meets 0 then restart in-place by itself\\n\\t\\t\\t\\n            product_right_to_left[i] *= (product_right_to_left[i-1] or 1)\\n            \\n\\t\\t\\t\\n        return max(max(product_left_to_right), max(product_right_to_left))\\n```\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        \\n        global_max = prev_max = prev_min = nums[0]\\n        \\n        for number in nums[1:]:\\n            \\n            # local max comes from product of two positive numbers or product of two negative numbers\\n            local_max = max(prev_max * number, prev_min * number, number)\\n            local_min = min(prev_max * number, prev_min * number, number)\\n            \\n\\t\\t\\t# update global max\\n            global_max = max(global_max, local_max)\\n            \\n            prev_max, prev_min = local_max, local_min\\n            \\n        \\n        return global_max\\n```\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        \\n        \\n        def dp( i ):\\n            \\n            if i == 0:\\n                # Base case on index 0\\n                # min value, max value, max product are first value in array\\n                return nums[0], nums[0], nums[0]\\n            \\n            \\n            ## General cases\\n            \\n            prev_min, prev_max, prev_product = dp(i-1)\\n            \\n            # local max comes from product of two positive numbers, or product of two negative numbers\\n            candidate = [prev_min * nums[i], prev_max * nums[i], nums[i] ]\\n            cur_min = min( candidate )\\n            cur_max = max( candidate )\\n            product = max(prev_product, cur_max)\\n            \\n            return cur_min, cur_max, product\\n        \\n        # ----------------------------------------\\n        return dp( len(nums)-1 )[2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330822,
                "title": "dp-with-o-n-time-complexity-and-o-1-space",
                "content": "\\u4F46\\u5B9E\\u9645\\u4E0A\\uFF0C\\u8FD9\\u4E2A\\u9898\\u786E\\u5B9E\\u662F\\u4E00\\u4E2A\\u52A8\\u6001\\u89C4\\u5212\\u7684\\u9898\\uFF0C\\u4E0D\\u8FC7\\u8FD9\\u4E2A\\u9898\\u53EF\\u4EE5\\u505A\\u5F88\\u591A\\u4F18\\u5316\\uFF0C\\u800C\\u4E0D\\u9700\\u8981\\u505A\\u4E00\\u4E2A$O(n^2)$\\u7684\\u89E3\\u7B54\\u3002\\n\\n\\u8FD9\\u4E2A\\u9898\\u5177\\u6709\\u6700\\u4F18\\u5B50\\u7ED3\\u6784\\uFF0C\\u56E0\\u4E3A\\u5FC5\\u987B\\u8981\\u8FDE\\u7EED\\u7684\\u5B50\\u6570\\u7EC4\\u3002\\u6240\\u4EE5\\u5F53\\u524D\\u7684\\u89E3\\u4E2D\\u7684\\u4E00\\u90E8\\u5206\\u4E5F\\u4E00\\u5B9A\\u662F\\u67D0\\u4E2A\\u89E3\\u3002\\n\\n\\u8FD9\\u4E2A\\u9898\\u7684DP\\u7684\\u503C\\u5E94\\u8BE5\\u8BBE\\u7ACB\\u6210**\\u4EE5nums[i]\\u4E3A\\u7ED3\\u5C3E\\u65F6\\u7684\\u5B50\\u6570\\u7EC4\\u7684\\u6700\\u5927\\u503C\\u548C\\u6700\\u5C0F\\u503C**, \\u4E4B\\u6240\\u4EE5\\u8981\\u7EF4\\u6301\\u6700\\u5C0F\\u503C, \\u662F\\u56E0\\u4E3A\\u5982\\u679C\\u78B0\\u5230\\u4E00\\u4E2A\\u5C0F\\u4E8E0\\u7684\\u6570\\u5B57, \\u5C0F\\u4E8E0\\u7684\\u6570\\u5B57\\u4E58\\u4EE5\\u6700\\u5C0F\\u503C\\u53EF\\u80FD\\u4F1A\\u5F97\\u5230\\u6700\\u5927\\u503C.\\n\\n\\u6240\\u4EE5\\u5176\\u5B9E\\u53EA\\u9700\\u8981\\u7EF4\\u6301\\u4E24\\u4E2A\\u503C\\u5C31\\u53EF\\u4EE5\\u77E5\\u9053\\u4E0A\\u4E00\\u4E2A\\u72B6\\u6001\\u4E86. \\u4E00\\u4E2A\\u662F\\u4E0A\\u4E00\\u4E2A\\u72B6\\u6001\\u7684\\u6700\\u5927\\u503C, \\u4E00\\u4E2A\\u662F\\u4E0A\\u4E00\\u4E2A\\u72B6\\u6001\\u7684\\u6700\\u5C0F\\u503C. \\u56E0\\u6B64\\u7A7A\\u95F4\\u590D\\u6742\\u5EA6\\u7EF4\\u6301\\u5728$O(1)$\\u5373\\u53EF.\\n\\n\\u5728\\u6C42\\u6574\\u4E2A\\u6570\\u7EC4\\u7684\\u8FC7\\u7A0B\\u4E2D\\uFF0C\\u8BB0\\u5F55\\u4E0B\\u6765\\u6700\\u5927\\u503C\\u5373\\u53EF\\u3002\\n\\n```\\n    int maxProduct(vector<int>& nums) {\\n        int mx, lastMax, lastMin;\\n        mx = lastMax = lastMin = nums[0];\\n\\n        for(int i=1; i<nums.size(); i++){\\n\\n            int curMax = max(max(nums[i], nums[i]*lastMax), nums[i]*lastMin);\\n            int curMin = min(min(nums[i], nums[i]*lastMax), nums[i]*lastMin);\\n\\n            lastMax = curMax;\\n            lastMin = curMin;\\n\\n            if(curMax > mx)\\n                mx = curMax;\\n        }\\n        return mx;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int maxProduct(vector<int>& nums) {\\n        int mx, lastMax, lastMin;\\n        mx = lastMax = lastMin = nums[0];\\n\\n        for(int i=1; i<nums.size(); i++){\\n\\n            int curMax = max(max(nums[i], nums[i]*lastMax), nums[i]*lastMin);\\n            int curMin = min(min(nums[i], nums[i]*lastMax), nums[i]*lastMin);\\n\\n            lastMax = curMax;\\n            lastMin = curMin;\\n\\n            if(curMax > mx)\\n                mx = curMax;\\n        }\\n        return mx;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 242415,
                "title": "a-java-solution-with-detailed-explanation-of-all-possible-cases",
                "content": "The code is simple, but the logic of all possible cases is a little bit complex.\\n\\nUse two global variables:\\n\\n* **prodMax**: max accumulative product of the array which ends on current position\\n* **prodMin**: min accumulative product of the array which ends on current position\\n\\nFor each position of the array, we need to check:\\n\\n* If nums[i] > 0:\\n  * If prodMax > 0, it means we can add current position (nums[i]) to subarray[...i-1] for a bigger prodMax; else we reset prodMax (create a new subarray which starts from current position). The code is: ```prodMax = prodMax > 0 ? prodMax * nums[i] : nums[i] ```\\n  * If prodMin < 0, it means we can add current position (nums[i]) to subarray[...i-1] for a smaller prodMin; else we reset prodMin (create a new subarray which starts from current position). The code is: ```prodMin = prodMin < 0 ? prodMin * nums[i] : nums[i] ```\\n\\n* If nums[i] < 0:\\n  * If prodMin < 0, it means we can add current position (nums[i]) to subarray[...i-1] for a bigger prodMax by multiplying nums[i] and prodMin (**since they are both negative, the multiplication will result in a big positive number**). Else we reset prodMax (create a new subarray which starts from current position). The code is: ```prodMax = prodMin < 0 ? prodMin * nums[i] : nums[i] ``` \\n  * If prodMax > 0, it means we can add current position (nums[i]) to subarray[...i-1] for a smaller prodMin by multiplying nums[i] and prodMin (**since nums[i] < 0 and prodMax > 0, the multiplication will result in a big negative number**). Else we reset prodMin (create a new subarray which starts from current position). The code is: ```prodMin = prodMax > 0 ? prodMax * nums[i] : nums[i]```\\n\\nNote that if nums[i] == 0, either logic works; so we don\\'t need to care about the case. The same is for prodMax/prodMin == 0.\\n\\n(An important logic is: if nums[i] < 0, new prodMax is decided by only `prodMin` and `nums[i]`, and **not** related to old prodMax. Since prodMax is always bigger than proMin, the multiplications with a negative value should always get a smaller value from prodMax and a bigger value from proMin. The logic is the same for new prodMin.)\\n\\nFor an implementation, we need to use posVal and negVal to save the results in advance, otherwise the modified prodMax/prodMin will impact the successive calculation. The code is:\\n\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int max = Integer.MIN_VALUE, prodMax = 1, prodMin = 1;\\n        for(int i = 0;i < nums.length;i++) {\\n            int posVal = prodMax * nums[i], negVal = prodMin * nums[i];\\n            if(nums[i] > 0) {\\n                prodMax = posVal > 0 ? posVal : nums[i];\\n                prodMin = negVal < 0 ? negVal : nums[i];\\n            } else {\\n                prodMax = negVal > 0 ? negVal : nums[i];\\n                prodMin = posVal < 0 ? posVal : nums[i];\\n            }\\n            max = Math.max(max, prodMax);\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\nA simplification is, we don\\'t need to check posVal/negVal actually; we can simply get the max/min value. The code is:\\n\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int max = Integer.MIN_VALUE, prodMax = 1, prodMin = 1;\\n        for(int i = 0;i < nums.length;i++) {\\n            int posVal = prodMax * nums[i], negVal = prodMin * nums[i];\\n            if(nums[i] > 0) {\\n                prodMax = Math.max(posVal, nums[i]);\\n                prodMin = Math.min(negVal, nums[i]);\\n            } else {\\n                prodMax = Math.max(negVal, nums[i]);\\n                prodMin = Math.min(posVal, nums[i]);\\n            }\\n            max = Math.max(max, prodMax);\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\nThe next step is, we can simply get the biggest/smallest value of (posVal, negVal, nums[i]) and avoid the check of nums[i]:\\n\\n\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int max = Integer.MIN_VALUE, prodMax = 1, prodMin = 1;\\n        for(int i = 0;i < nums.length;i++) { \\n            int posVal = prodMax * nums[i], negVal = prodMin * nums[i];\\n            prodMax = Math.max(Math.max(posVal, nums[i]), negVal);\\n            prodMin = Math.min(Math.min(posVal, nums[i]), negVal);\\n            max = Math.max(max, prodMax);\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```prodMax = prodMax > 0 ? prodMax * nums[i] : nums[i] ```\n```prodMin = prodMin < 0 ? prodMin * nums[i] : nums[i] ```\n```prodMax = prodMin < 0 ? prodMin * nums[i] : nums[i] ```\n```prodMin = prodMax > 0 ? prodMax * nums[i] : nums[i]```\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int max = Integer.MIN_VALUE, prodMax = 1, prodMin = 1;\\n        for(int i = 0;i < nums.length;i++) {\\n            int posVal = prodMax * nums[i], negVal = prodMin * nums[i];\\n            if(nums[i] > 0) {\\n                prodMax = posVal > 0 ? posVal : nums[i];\\n                prodMin = negVal < 0 ? negVal : nums[i];\\n            } else {\\n                prodMax = negVal > 0 ? negVal : nums[i];\\n                prodMin = posVal < 0 ? posVal : nums[i];\\n            }\\n            max = Math.max(max, prodMax);\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int max = Integer.MIN_VALUE, prodMax = 1, prodMin = 1;\\n        for(int i = 0;i < nums.length;i++) {\\n            int posVal = prodMax * nums[i], negVal = prodMin * nums[i];\\n            if(nums[i] > 0) {\\n                prodMax = Math.max(posVal, nums[i]);\\n                prodMin = Math.min(negVal, nums[i]);\\n            } else {\\n                prodMax = Math.max(negVal, nums[i]);\\n                prodMin = Math.min(posVal, nums[i]);\\n            }\\n            max = Math.max(max, prodMax);\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int max = Integer.MIN_VALUE, prodMax = 1, prodMin = 1;\\n        for(int i = 0;i < nums.length;i++) { \\n            int posVal = prodMax * nums[i], negVal = prodMin * nums[i];\\n            prodMax = Math.max(Math.max(posVal, nums[i]), negVal);\\n            prodMin = Math.min(Math.min(posVal, nums[i]), negVal);\\n            max = Math.max(max, prodMax);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48365,
                "title": "9-lines-concise-and-easy-understand-c-dp-solution-o-n-time-o-1-space",
                "content": "    class Solution {\\n    public:\\n        int maxProduct(vector<int>& nums) {\\n            if(nums.size() == 1) return nums[0];\\n            int minres = 0, maxres = 0, res = 0, tmp;\\n            for(int i = 0; i < nums.size(); i++){\\n                tmp = maxres;\\n                maxres = max(nums[i],  max(maxres * nums[i], minres*nums[i]));\\n                minres = min(nums[i],  min(minres * nums[i], tmp*nums[i]));\\n                res = max(res, maxres);\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxProduct(vector<int>& nums) {\\n            if(nums.size() == 1) return nums[0];\\n            int minres = 0, maxres = 0, res = 0, tmp;\\n            for(int i = 0; i < nums.size(); i++){\\n                tmp = maxres;\\n                maxres = max(nums[i],  max(maxres * nums[i], minres*nums[i]));\\n                minres = min(nums[i],  min(minres * nums[i], tmp*nums[i]));\\n                res = max(res, maxres);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 48473,
                "title": "share-the-first-c-solution-with-notes",
                "content": "This question is pretty different from Maximum Sum of Subarray. The reason is that a negative value in array will revolute the previous **maximum** product to the **minimum** and vice versa. So both temporary results should be kept. \\n\\n\\n\\n    class Solution {\\n    public:\\n        int maxProduct(int A[], int n) {\\n            if (n==1) return A[0];\\n            \\n            int max_temp=0,min_temp=0,result=std::numeric_limits<int>::min();\\n            \\n            for (int i=0;i<n;i++){\\n                if (A[i]>0){\\n                    max_temp=max(max_temp*A[i],A[i]);//Assign the Temporary Maximum Product\\n                    min_temp=min_temp*A[i];\\n                }\\n                else if (A[i]==0){\\n                    max_temp=0;\\n                    min_temp=0;\\n                }\\n                else{//Negative value, **maximum** and **minimum** products will be  revoluted. \\n                    int temp=max_temp;\\n                    max_temp=min_temp*A[i];\\n                    min_temp=min(temp*A[i],A[i]);//Assign the Temporary Minimum Product\\n                }\\n                result=max(max_temp,result);\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxProduct(int A[], int n) {\\n            if (n==1) return A[0];\\n            \\n            int max_temp=0,min_temp=0,result=std::numeric_limits<int>::min();\\n            \\n            for (int i=0;i<n;i++){\\n                if (A[i]>0){\\n                    max_temp=max(max_temp*A[i],A[i]);//Assign the Temporary Maximum Product\\n                    min_temp=min_temp*A[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3855832,
                "title": "intuitive-explanation",
                "content": "# Intuition\\nTraversing through the array, for positive elements we have no problem multiplying them into our product, its tricky when we stumble upon a negative element. We can either keep it but then how do we know if we are going to stumble upon the next negative to make it positive?\\n\\nThe trick is not to get stuck in this and focus on even negatives which will maximise our product. If there are even negative nos in arr, its straightforward but **if its odd, we need to let go one of the odd no. Now, this is going to be either the leftmost or the rightmost negative no.**\\n# Approach\\nWe go from **left to right** and calculate product of each element with previous all, and also check the max at that point comparing with the prev max. The absolute value of the product is non decreasing till we find 0. Now, here we take the max and then reset our product to 1 to handle calculations forward.\\n\\nAfter traversing from left to right, now we have the max product of the array by taking first even negative numbers from left to right. \\nBut what if the one negative number we missed towards the right was of higher value but we couldn\\'t take it because it was making our product negative due to odd number of negatives. \\nExample, [-2, -2, 2, 2, -3] max = 16 (products going left to right)\\n\\nNow, we travese the array in reverse from **right to left**, similar to how we did above and update the max product. For the above example our max will be updated to max = 24.\\n\\nFor the cases when we have even number of negative numbers in the array, max will be the same for both (left to right traversal and right to left traversal)\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int prod = 1;\\n        int max = nums[0];\\n\\n        for(int i = 0; i < nums.length; i++){\\n            prod *= nums[i];\\n            max = Math.max(prod, max);\\n            if(prod == 0)   prod = 1;\\n        }\\n        prod = 1;\\n\\n        for(int i = nums.length-1; i >=0; i--){\\n            prod *= nums[i];\\n            max = Math.max(prod, max);\\n            if(prod == 0)   prod = 1;\\n        }\\n\\n        return max;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int prod = 1;\\n        int max = nums[0];\\n\\n        for(int i = 0; i < nums.length; i++){\\n            prod *= nums[i];\\n            max = Math.max(prod, max);\\n            if(prod == 0)   prod = 1;\\n        }\\n        prod = 1;\\n\\n        for(int i = nums.length-1; i >=0; i--){\\n            prod *= nums[i];\\n            max = Math.max(prod, max);\\n            if(prod == 0)   prod = 1;\\n        }\\n\\n        return max;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769816,
                "title": "maximum-product-subarray",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        if(nums.length == 1){\\n            return nums[0];\\n        }\\n       int leftHighestCount = 0;\\n       int leftTempCounter = 1;\\n       int rightHighestCount = 0;\\n       int rightTempCounter = 1;\\n       for(int i =0; i< nums.length; i++)\\n        {\\n           if(nums[i] == 0 )\\n           {\\n               if( nums[i] > leftHighestCount)\\n               {\\n                  leftHighestCount = nums[i];\\n               }\\n              leftTempCounter = 1 ;\\n           } else {\\n            leftTempCounter = nums[i] * leftTempCounter;\\n           \\n             if(leftTempCounter > leftHighestCount)\\n           {\\n              leftHighestCount = leftTempCounter;\\n           }\\n           }\\n          \\n          \\n       }\\n\\n        for(int i = nums.length - 1 ; i >= 0; i--)\\n        {\\n            if(nums[i] == 0 )\\n           {\\n                if( nums[i] > rightHighestCount)\\n               {\\n                  rightHighestCount = nums[i];\\n               }\\n              rightTempCounter = 1 ;\\n           } else {\\n            rightTempCounter = nums[i] * rightTempCounter;\\n    \\n             if(rightTempCounter > rightHighestCount)\\n           {\\n              rightHighestCount = rightTempCounter;\\n           }\\n           }\\n        }\\n        System.out.print(rightHighestCount);\\n        System.out.print(leftHighestCount);\\n       if(rightHighestCount > leftHighestCount)\\n       {\\n           return rightHighestCount;\\n       }\\n\\n       return leftHighestCount;\\n       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        if(nums.length == 1){\\n            return nums[0];\\n        }\\n       int leftHighestCount = 0;\\n       int leftTempCounter = 1;\\n       int rightHighestCount = 0;\\n       int rightTempCounter = 1;\\n       for(int i =0; i< nums.length; i++)\\n        {\\n           if(nums[i] == 0 )\\n           {\\n               if( nums[i] > leftHighestCount)\\n               {\\n                  leftHighestCount = nums[i];\\n               }\\n              leftTempCounter = 1 ;\\n           } else {\\n            leftTempCounter = nums[i] * leftTempCounter;\\n           \\n             if(leftTempCounter > leftHighestCount)\\n           {\\n              leftHighestCount = leftTempCounter;\\n           }\\n           }\\n          \\n          \\n       }\\n\\n        for(int i = nums.length - 1 ; i >= 0; i--)\\n        {\\n            if(nums[i] == 0 )\\n           {\\n                if( nums[i] > rightHighestCount)\\n               {\\n                  rightHighestCount = nums[i];\\n               }\\n              rightTempCounter = 1 ;\\n           } else {\\n            rightTempCounter = nums[i] * rightTempCounter;\\n    \\n             if(rightTempCounter > rightHighestCount)\\n           {\\n              rightHighestCount = rightTempCounter;\\n           }\\n           }\\n        }\\n        System.out.print(rightHighestCount);\\n        System.out.print(leftHighestCount);\\n       if(rightHighestCount > leftHighestCount)\\n       {\\n           return rightHighestCount;\\n       }\\n\\n       return leftHighestCount;\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531445,
                "title": "kadane-s-algorithm-o-n-time-complexity-c",
                "content": "# Approach\\nOne pass , similar to Prefix Sum\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int maxProd = nums[0];  \\n        int currMax = nums[0]; \\n        int currMin = nums[0]; \\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] < 0)\\n                swap(currMax, currMin);\\n                currMax = max(nums[i], currMax * nums[i]);\\n                currMin = min(nums[i], currMin * nums[i]);\\n                maxProd = max(maxProd, currMax);\\n        }\\n        return maxProd;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int maxProd = nums[0];  \\n        int currMax = nums[0]; \\n        int currMin = nums[0]; \\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] < 0)\\n                swap(currMax, currMin);\\n                currMax = max(nums[i], currMax * nums[i]);\\n                currMin = min(nums[i], currMin * nums[i]);\\n                maxProd = max(maxProd, currMax);\\n        }\\n        return maxProd;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208209,
                "title": "152-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo solve this problem, we can use the dynamic programming approach. We can define two arrays max_prod and min_prod, where max_prod[i] stores the maximum product ending at index i and min_prod[i] stores the minimum product ending at index i. We also keep track of the maximum product seen so far using a variable result. We initialize these arrays and result as follows:\\n\\n```\\nmax_prod[0] = nums[0]\\nmin_prod[0] = nums[0]\\nresult = nums[0]\\n\\n```\\n\\nThen, for i in the range [1, len(nums)), we update max_prod[i] and min_prod[i] as follows:\\n```\\nif nums[i] >= 0:\\n    max_prod[i] = max(nums[i], max_prod[i-1]*nums[i])\\n    min_prod[i] = min(nums[i], min_prod[i-1]*nums[i])\\nelse:\\n    max_prod[i] = max(nums[i], min_prod[i-1]*nums[i])\\n    min_prod[i] = min(nums[i], max_prod[i-1]*nums[i])\\n\\nresult = max(result, max_prod[i])\\n\\n```\\nFinally, we return result. The intuition behind this approach is that a subarray with maximum product can be obtained by multiplying the maximum product of its previous subarray with the current element (if the current element is positive) or the minimum product of its previous subarray with the current element (if the current element is negative). We keep track of both the maximum and minimum products because a negative number can also result in a maximum product if multiplied by another negative number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def maxProduct(self, nums: List[int]) -> int:\\n    # Initialize max_prod, min_prod, and result\\n    max_prod = [0]*len(nums)\\n    min_prod = [0]*len(nums)\\n    max_prod[0] = nums[0]\\n    min_prod[0] = nums[0]\\n    result = nums[0]\\n\\n    # Loop through the array and update max_prod, min_prod, and result\\n    for i in range(1, len(nums)):\\n        if nums[i] >= 0:\\n            max_prod[i] = max(nums[i], max_prod[i-1]*nums[i])\\n            min_prod[i] = min(nums[i], min_prod[i-1]*nums[i])\\n        else:\\n            max_prod[i] = max(nums[i], min_prod[i-1]*nums[i])\\n            min_prod[i] = min(nums[i], max_prod[i-1]*nums[i])\\n        result = max(result, max_prod[i])\\n\\n    return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nmax_prod[0] = nums[0]\\nmin_prod[0] = nums[0]\\nresult = nums[0]\\n\\n```\n```\\nif nums[i] >= 0:\\n    max_prod[i] = max(nums[i], max_prod[i-1]*nums[i])\\n    min_prod[i] = min(nums[i], min_prod[i-1]*nums[i])\\nelse:\\n    max_prod[i] = max(nums[i], min_prod[i-1]*nums[i])\\n    min_prod[i] = min(nums[i], max_prod[i-1]*nums[i])\\n\\nresult = max(result, max_prod[i])\\n\\n```\n```\\nclass Solution:\\n  def maxProduct(self, nums: List[int]) -> int:\\n    # Initialize max_prod, min_prod, and result\\n    max_prod = [0]*len(nums)\\n    min_prod = [0]*len(nums)\\n    max_prod[0] = nums[0]\\n    min_prod[0] = nums[0]\\n    result = nums[0]\\n\\n    # Loop through the array and update max_prod, min_prod, and result\\n    for i in range(1, len(nums)):\\n        if nums[i] >= 0:\\n            max_prod[i] = max(nums[i], max_prod[i-1]*nums[i])\\n            min_prod[i] = min(nums[i], min_prod[i-1]*nums[i])\\n        else:\\n            max_prod[i] = max(nums[i], min_prod[i-1]*nums[i])\\n            min_prod[i] = min(nums[i], max_prod[i-1]*nums[i])\\n        result = max(result, max_prod[i])\\n\\n    return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174702,
                "title": "c-modified-kadane-s-easy-to-understand-o-n",
                "content": "Like kadane\\'s we calculate the max ending here at each index;\\nMax ending at index i could be:\\n- min ending at previous index * nums[i] (if min is negative, negative * negative can yield a max value)\\n- max ending at previous index * nums[i] (positive * positive)\\n- nums[i]\\n  \\nMin ending at index i could be:\\n- min ending at previous index * nums[i] (if nums[i] is positive this can yield a bigger negative)\\n- max ending at previous index * nums[i] (if nums[i] is negative and min ending at previous index is postive, this could yield a new minimum)\\n- nums[i]\\n\\n\\n```\\nint n = nums.size();\\nint max_so_far = nums[0];\\nint max_ending_here = nums[0];\\nint min_ending_here = nums[0];\\nfor(int i=1;i<n;i++){\\n\\tint temp = max_ending_here*nums[i];\\n\\tmax_ending_here = max(nums[i], max(temp, min_ending_here*nums[i]));\\n\\tmin_ending_here = min(nums[i], min(temp, min_ending_here*nums[i]));\\n\\tmax_so_far = max(max_so_far, max_ending_here);\\n}\\nreturn max_so_far;\\n```",
                "solutionTags": [],
                "code": "```\\nint n = nums.size();\\nint max_so_far = nums[0];\\nint max_ending_here = nums[0];\\nint min_ending_here = nums[0];\\nfor(int i=1;i<n;i++){\\n\\tint temp = max_ending_here*nums[i];\\n\\tmax_ending_here = max(nums[i], max(temp, min_ending_here*nums[i]));\\n\\tmin_ending_here = min(nums[i], min(temp, min_ending_here*nums[i]));\\n\\tmax_so_far = max(max_so_far, max_ending_here);\\n}\\nreturn max_so_far;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1608884,
                "title": "c-one-pass-simple-and-easy-code-w-explanation",
                "content": "The idea is to**Find the Maximum and Minimum Product found till every index**. The final result will be the maximum of result and Maximum product subarray till every index.\\n\\nThe reason why we are finding minimum product subarray till every index is because we have negative numbers too in the array. So, if we have current element as a negative number, then the minimum product found so far(greatest nagative product) * current nagtive element will give us the maximum product. So, we are keeping track of minimum product found so far too.\\n\\n**Example with Explanation:**\\nEx- nums = [2,3,-2,4]\\n\\nInitially keeping, both min and max product as 1.\\nat index 0 : minProd=1 maxProd=1;\\nat index 1 : minProd=2, maxProd=2;\\nat index 2 : minProd=3, maxProd=6;\\nat index 3 : minProd=-12, maxProd=-2;\\n```\\nint maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int res = nums[0];\\n        int currMax = 1, currMin = 1;\\n        for (int i = 0; i < n; i++) {\\n            int tempMax = nums[i] * currMax;  \\n            currMax = max({tempMax, nums[i]*currMin, nums[i]});\\n            currMin = min({tempMax, nums[i]*currMin, nums[i]});\\n            res = max(res, currMax);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int res = nums[0];\\n        int currMax = 1, currMin = 1;\\n        for (int i = 0; i < n; i++) {\\n            int tempMax = nums[i] * currMax;  \\n            currMax = max({tempMax, nums[i]*currMin, nums[i]});\\n            currMin = min({tempMax, nums[i]*currMin, nums[i]});\\n            res = max(res, currMax);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779357,
                "title": "c-sol1-o-n-space-sol2-o-1-space",
                "content": "**Solution 1 : Using two dp arrays : O(n) Time + O(n) space**  \\n\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n\\n        int dp_max[nums.size()];\\n        int dp_min[nums.size()];\\n        \\n        dp_min[0] = nums[0];\\n        dp_max[0] = nums[0];\\n        \\n        for(int i = 1; i < nums.size() ; i++){\\n            if(nums[i] < 0){\\n                dp_max[i]=  max(nums[i],nums[i]*dp_min[i-1]);\\n                dp_min[i]=  min(nums[i],nums[i]*dp_max[i-1]);\\n                \\n            }\\n            else{\\n                dp_max[i]=  max(nums[i],nums[i]*dp_max[i-1]);\\n                dp_min[i]=  min(nums[i],nums[i]*dp_min[i-1]);\\n            }\\n        }\\n        \\n        int maxm = INT_MIN;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            maxm = max(maxm,dp_max[i]);\\n        }\\n        \\n        return maxm;\\n    }\\n};\\n```\\n\\n**Solution 2 : Optimization using two variables, getting rid of the arrays. O(n) Time + O(1) space** \\n\\n```\\nclass Solution {\\npublic:\\n\\tint maxProduct(vector<int>& nums) {\\n\\t\\tint maxm  = nums[0];\\n        int minm  = nums[0];\\n        int res = nums[0];\\n        \\n        for(int i = 1 ; i < nums.size() ; ++i){\\n            if(nums[i] < 0){\\n                int tmp = maxm;\\n                maxm = minm;\\n                minm = tmp;\\n            }\\n            \\n            maxm = max(nums[i],nums[i]*maxm);\\n            minm = min(nums[i],nums[i]*minm);\\n            res = max(maxm,res);\\n        }\\n        return res;\\n\\t}\\n};\\n```\\n\\t\\t\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n\\n        int dp_max[nums.size()];\\n        int dp_min[nums.size()];\\n        \\n        dp_min[0] = nums[0];\\n        dp_max[0] = nums[0];\\n        \\n        for(int i = 1; i < nums.size() ; i++){\\n            if(nums[i] < 0){\\n                dp_max[i]=  max(nums[i],nums[i]*dp_min[i-1]);\\n                dp_min[i]=  min(nums[i],nums[i]*dp_max[i-1]);\\n                \\n            }\\n            else{\\n                dp_max[i]=  max(nums[i],nums[i]*dp_max[i-1]);\\n                dp_min[i]=  min(nums[i],nums[i]*dp_min[i-1]);\\n            }\\n        }\\n        \\n        int maxm = INT_MIN;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            maxm = max(maxm,dp_max[i]);\\n        }\\n        \\n        return maxm;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tint maxProduct(vector<int>& nums) {\\n\\t\\tint maxm  = nums[0];\\n        int minm  = nums[0];\\n        int res = nums[0];\\n        \\n        for(int i = 1 ; i < nums.size() ; ++i){\\n            if(nums[i] < 0){\\n                int tmp = maxm;\\n                maxm = minm;\\n                minm = tmp;\\n            }\\n            \\n            maxm = max(nums[i],nums[i]*maxm);\\n            minm = min(nums[i],nums[i]*minm);\\n            res = max(maxm,res);\\n        }\\n        return res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757686,
                "title": "java-simple-2-pass-o-n-easy-to-remember",
                "content": "Intutuion here is that multiplying forward vs. backwards will result in different intermediate products, but will result in same final product. Multiplying by more numbers always results in a number that is the same or higher magnitude (except for 0), so hopefully in the case of a very negative number we eventually find another negative number to flip the sign.\\n\\nIn case we encounter a 0, reset product to 1 so we can continue to multiplying remaining numbers.\\n\\nSimply return the max product found from the forwards and backwards traversal.\\n\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int product = 1;\\n        int maxProduct = Integer.MIN_VALUE;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            product *= nums[i];          \\n            maxProduct = Math.max(maxProduct, product);\\n            if (product == 0) {\\n                product = 1;\\n            }\\n        }\\n        \\n        product = 1;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            product *= nums[i];          \\n            maxProduct = Math.max(maxProduct, product);\\n            if (product == 0) {\\n                product = 1;\\n            }\\n        }\\n        \\n        return maxProduct;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int product = 1;\\n        int maxProduct = Integer.MIN_VALUE;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            product *= nums[i];          \\n            maxProduct = Math.max(maxProduct, product);\\n            if (product == 0) {\\n                product = 1;\\n            }\\n        }\\n        \\n        product = 1;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            product *= nums[i];          \\n            maxProduct = Math.max(maxProduct, product);\\n            if (product == 0) {\\n                product = 1;\\n            }\\n        }\\n        \\n        return maxProduct;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 728760,
                "title": "simple-python",
                "content": "```\\ndef maxProduct(self, a):\\n\\tans = max_prod = min_prod = a[0]                       \\n\\tfor x in a[1:]:\\n\\t\\tmax_prod, min_prod = max(x, min_prod*x, max_prod*x), min(x, min_prod*x, max_prod*x) \\n\\t\\tans = max(ans, max_prod)\\n\\treturn ans",
                "solutionTags": [],
                "code": "```\\ndef maxProduct(self, a):\\n\\tans = max_prod = min_prod = a[0]                       \\n\\tfor x in a[1:]:\\n\\t\\tmax_prod, min_prod = max(x, min_prod*x, max_prod*x), min(x, min_prod*x, max_prod*x) \\n\\t\\tans = max(ans, max_prod)\\n\\treturn ans",
                "codeTag": "Python3"
            },
            {
                "id": 660113,
                "title": "c-dp-o-n-time-o-1-space-with-explanation",
                "content": "```\\n/**\\nThe question seems pretty straigtforward, apart from the fact that we have to take into account negative elements.\\nProduct of subarray can only be positive if the number of negative elements are even.\\n\\nSo we will keep two variables, posMax and negMax\\nposMax will keep track of the highest positive running product found till now.\\nnegMax will keep track of the lowest negative running product found till now.\\n\\nThere are 3 cases.\\nIf element encountered is positive, we can simply multiply it with posMax to get maximum running product.\\nnegMax will also be updated since the running negative product shall also decrease in value by multiplying it with a positive number\\n\\nIf element encountered is negative, we can multiply it with negMax( lowest negative running product ) to get a positive value . If this is greater than positive running product (posMax) then update it.\\nWe will also update negMax by multiplying nums[i] (negative) with posMax, since it will yield a negative value which might be lesser than our already found running negative product.\\n\\nIf the element is 0, then both running products shall be set to 0 (Note that we only have to consider contiguous subarrays).\\n\\nAn example will make it much more clearer.\\nDry run it yourself to understand the algorithm fully\\nnums[i] - -2         5          -1          -4         2          3\\nposMax  -2           5          10          20        40         120\\nnegMax  -2          -10         -5         -40       -80        -120\\nresult   0           5          10          20        40         120\\n**/\\n\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        if(nums.size() == 0){ return 0; }\\n        if(nums.size() == 1){ return nums[0]; }\\n        int posMax = 1;\\n        int negMax = 1;\\n        int result = 0;        \\n        for(int i = 0; i < nums.size(); i++) {\\n            int nextPosMax = 1;\\n            int nextNegMax = 1;\\n           if(nums[i] > 0){\\n               nextPosMax = max(posMax * nums[i], nums[i]);\\n               nextNegMax = min(negMax * nums[i], nums[i]);\\n           } else if( nums[i] < 0 ){\\n               nextPosMax = max(negMax * nums[i], nums[i]);\\n               nextNegMax = min(posMax * nums[i], nums[i]);\\n           } else {\\n              nextPosMax = 0;\\n              nextNegMax = 0;\\n           }\\n            result = max(result, max(nextPosMax, nextNegMax));\\n            posMax = nextPosMax;\\n            negMax = nextNegMax;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\nThe question seems pretty straigtforward, apart from the fact that we have to take into account negative elements.\\nProduct of subarray can only be positive if the number of negative elements are even.\\n\\nSo we will keep two variables, posMax and negMax\\nposMax will keep track of the highest positive running product found till now.\\nnegMax will keep track of the lowest negative running product found till now.\\n\\nThere are 3 cases.\\nIf element encountered is positive, we can simply multiply it with posMax to get maximum running product.\\nnegMax will also be updated since the running negative product shall also decrease in value by multiplying it with a positive number\\n\\nIf element encountered is negative, we can multiply it with negMax( lowest negative running product ) to get a positive value . If this is greater than positive running product (posMax) then update it.\\nWe will also update negMax by multiplying nums[i] (negative) with posMax, since it will yield a negative value which might be lesser than our already found running negative product.\\n\\nIf the element is 0, then both running products shall be set to 0 (Note that we only have to consider contiguous subarrays).\\n\\nAn example will make it much more clearer.\\nDry run it yourself to understand the algorithm fully\\nnums[i] - -2         5          -1          -4         2          3\\nposMax  -2           5          10          20        40         120\\nnegMax  -2          -10         -5         -40       -80        -120\\nresult   0           5          10          20        40         120\\n**/\\n\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        if(nums.size() == 0){ return 0; }\\n        if(nums.size() == 1){ return nums[0]; }\\n        int posMax = 1;\\n        int negMax = 1;\\n        int result = 0;        \\n        for(int i = 0; i < nums.size(); i++) {\\n            int nextPosMax = 1;\\n            int nextNegMax = 1;\\n           if(nums[i] > 0){\\n               nextPosMax = max(posMax * nums[i], nums[i]);\\n               nextNegMax = min(negMax * nums[i], nums[i]);\\n           } else if( nums[i] < 0 ){\\n               nextPosMax = max(negMax * nums[i], nums[i]);\\n               nextNegMax = min(posMax * nums[i], nums[i]);\\n           } else {\\n              nextPosMax = 0;\\n              nextNegMax = 0;\\n           }\\n            result = max(result, max(nextPosMax, nextNegMax));\\n            posMax = nextPosMax;\\n            negMax = nextNegMax;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 580658,
                "title": "beats-97-java-easy-dp-solution",
                "content": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int[] max = new int[nums.length];\\n        int[] min = new int[nums.length];\\n        max[0] = min[0] = nums[0];\\n        int result = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i]>0){\\n                max[i]=Math.max(nums[i], max[i-1]*nums[i]);\\n                min[i]=Math.min(nums[i], min[i-1]*nums[i]);\\n            }else{\\n                max[i]=Math.max(nums[i], min[i-1]*nums[i]);\\n                min[i]=Math.min(nums[i], max[i-1]*nums[i]);\\n            }\\n            result = Math.max(result, max[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int[] max = new int[nums.length];\\n        int[] min = new int[nums.length];\\n        max[0] = min[0] = nums[0];\\n        int result = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i]>0){\\n                max[i]=Math.max(nums[i], max[i-1]*nums[i]);\\n                min[i]=Math.min(nums[i], min[i-1]*nums[i]);\\n            }else{\\n                max[i]=Math.max(nums[i], min[i-1]*nums[i]);\\n                min[i]=Math.min(nums[i], max[i-1]*nums[i]);\\n            }\\n            result = Math.max(result, max[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48335,
                "title": "two-clean-different-solutions-c-well-commented",
                "content": "    class Solution {\\n    public:\\n        //min can turn max when encountering another negative number\\n        //so we have to record all the min and max values;\\n    \\tint maxProduct(vector<int>& nums) \\n        {\\n            int size = nums.size(), maxProduct = nums[0];\\n            int maxProducts[size]{0}, minProducts[size]{0};\\n            maxProducts[0] = minProducts[0] = nums[0];\\n            for(int i = 1; i < size; ++i)\\n            {\\n                maxProducts[i] = max(maxProducts[i-1]*nums[i], max(minProducts[i-1]*nums[i], nums[i]));\\n                minProducts[i] = min(maxProducts[i-1]*nums[i], min(minProducts[i-1]*nums[i], nums[i]));\\n                maxProduct = max(maxProduct, maxProducts[i]);\\n            }\\n            return maxProduct;\\n        }\\n    \\n        //actually we only need two variables to record the\\n        //previous min and max products;\\n    \\tint maxProduct(vector<int>& nums) \\n        {\\n            int size = nums.size();\\n            int minProduct = nums[0], maxProduct = nums[0], ret = nums[0];\\n            for(int i = 1; i < size; ++i)\\n            {\\n                if(nums[i] < 0) swap(minProduct, maxProduct);\\n                maxProduct = max(maxProduct*nums[i], nums[i]);\\n                minProduct = min(minProduct*nums[i], nums[i]);\\n                ret = max(ret, maxProduct);\\n            }\\n            return ret;\\n        }\\n    \\n        //another solution using constant space too;\\n        //traversing from left to right and meantime from right to left\\n        //to calculate the possible max products since the subsequence will be \\n        //from left to right or right to left anyway but in two directions \\n        //in case of neglecting the other half;\\n        int maxProduct(vector<int>& nums) \\n        {\\n            int lProduct = 1, rProduct = 1;\\n            int size = nums.size(), maxProduct = nums[0];\\n            for(int i = 0; i < size; ++i)\\n            {\\n                lProduct *= nums[i];\\n                rProduct *= nums[size-i-1];\\n                maxProduct = max(maxProduct, max(lProduct, rProduct));\\n                if(lProduct == 0) lProduct = 1;\\n                if(rProduct == 0) rProduct = 1;\\n            }\\n            return maxProduct;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        //min can turn max when encountering another negative number\\n        //so we have to record all the min and max values;\\n    \\tint maxProduct(vector<int>& nums) \\n        {\\n            int size = nums.size(), maxProduct = nums[0];\\n            int maxProducts[size]{0}",
                "codeTag": "Java"
            },
            {
                "id": 48413,
                "title": "6-simple-lines-ruby-is-awesome-here",
                "content": "I walk over `nums` front to back. My `min` and `max` tell me the smallest and largest product ending with the current number `n`. For the next `n`, I can either use that `n` alone or I can extend the previous min/max products by multiplying them with `n`.\\n\\n    def max_product(nums)\\n        min = max = 1\\n        best = nums[0]\\n        nums.each { |n|\\n            min, max = [n, min*n, max*n].minmax\\n            best = [best, max].max\\n        }\\n        best\\n    end",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "I walk over `nums` front to back. My `min` and `max` tell me the smallest and largest product ending with the current number `n`. For the next `n`, I can either use that `n` alone or I can extend the previous min/max products by multiplying them with `n`.\\n\\n    def max_product(nums)\\n        min = max = 1\\n        best = nums[0]\\n        nums.each { |n|\\n            min, max = [n, min*n, max*n].minmax\\n            best = [best, max].max\\n        }\\n        best\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 3991285,
                "title": "0-n-best-solution",
                "content": "# **PLEASE UPVOTE MY SOLUTION IG YOU LIKE IT**\\n# **CONNECT WITH ME**\\n# **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n# **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\nThe approach used in this code is based on maintaining two variables, prefix and suffix, to keep track of the product of elements from the left and right sides of the current position in the array. Here\\'s a step-by-step explanation of the approach:\\n\\nInitialize the prefix and suffix variables to 1. These variables will store the product of elements from the left and right sides, respectively.\\n\\nInitialize the maxi variable to INT_MIN. This variable will store the maximum product found so far.\\n\\nIterate through the nums array using a for loop. The loop variable i represents the current position in the array.\\n\\nInside the loop:\\n\\nCheck if prefix is equal to 0. If it is, set prefix to 1. This step ensures that if the product becomes 0, it won\\'t affect the overall product.\\nCheck if suffix is equal to 0. If it is, set suffix to 1. Similar to the prefix, this step ensures that if the product becomes 0 when considering elements from the right side, it won\\'t affect the overall product.\\nUpdate prefix by multiplying it with the current element nums[i]. This step accumulates the product of elements from the left side.\\nUpdate suffix by multiplying it with the element at position nums[n - i - 1]. This step accumulates the product of elements from the right side, starting from the end of the array.\\nUpdate maxi by taking the maximum value among maxi, prefix, and suffix. This step ensures that maxi always stores the maximum product found so far.\\nAfter the loop completes, maxi will contain the maximum product of a subarray within the nums array.\\n\\nIn summary, this code maintains two variables to track the product of elements from the left and right sides of the current position and keeps updating the maximum product found while iterating through the array. The final result is stored in the maxi variable and returned as the answer.\\n<!-- Describe your approach to solving the problem. -->\\n\\nGO THROUGH THIS VIDEO TO GET A COMPLETE KNOWLEDGE ABT THIS CODE \\n[https://www.youtube.com/watch?v=hnswaLJvr6g]()\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int prefix=1;\\n        int suffix=1;\\n        int n = nums.size();\\n        int maxi=INT_MIN;\\n        for(int i = 0; i < nums.size();i++)\\n        {\\n            if(prefix==0)\\n            {\\n                prefix=1;\\n            }\\n            if(suffix==0)\\n            {\\n                suffix=1;\\n            }\\n            prefix*=nums[i];\\n            suffix*=nums[n-i-1]; // to start suffix from the last end \\n            maxi=max(maxi , max(suffix,prefix));\\n\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int prefix=1;\\n        int suffix=1;\\n        int n = nums.size();\\n        int maxi=INT_MIN;\\n        for(int i = 0; i < nums.size();i++)\\n        {\\n            if(prefix==0)\\n            {\\n                prefix=1;\\n            }\\n            if(suffix==0)\\n            {\\n                suffix=1;\\n            }\\n            prefix*=nums[i];\\n            suffix*=nums[n-i-1]; // to start suffix from the last end \\n            maxi=max(maxi , max(suffix,prefix));\\n\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388098,
                "title": "simple-javascript-very-easy-explanation-49ms-98-91beats",
                "content": "![Screenshot 2023-04-07 at 01.15.42.png](https://assets.leetcode.com/users/images/3d1691f5-2690-4331-bba3-71e031d63bb6_1680823010.6114805.png)\\n\\n# Ways to solve problem:\\n1. Brute Force way which takes two loop and iterates to and update max prodcut. Time-complexity = 0(n^2)\\n2. Dynamic Programming which takes one loop and iterates to and update max product. Time-complexity = O(n) which is better than first way.\\n\\nI selected dynamic programming appraoch\\n# How this code works:\\n```\\n                      /-------------\\\\\\n                      v             |\\nInput Array: [-2, 3, -4, 5, 2, -2, 1]\\n        index:  0  1   2  3  4   5  6\\n\\n              /---------\\\\\\n              v         |\\n              -2        |\\n              /---------\\\\\\n              v         |\\n              3         |\\n              /---------\\\\\\n              v         |\\n              -4        |\\n              /---------\\\\\\n              v         |\\n              5         |\\n              /---------\\\\\\n              v         |\\n              2         |\\n              /---------\\\\\\n              v         |\\n              -2        |\\n              /---------\\\\\\n              v         |\\n              1         |\\n              \\\\---------/\\n\\nAt each iteration, we calculate the local maximum and local minimum products ending at the current index (represented by the arrows above). The global maximum product is updated based on the local maximum product calculated at each iteration. Here\\'s how the values of the variables change at each iteration for the input array above:\\n\\ni = 1:\\nlocalMaxProduct = 3\\nlocalMinProduct = -6\\nglobalMaxProduct = 3\\n\\ni = 2:\\nlocalMaxProduct = 24\\nlocalMinProduct = -12\\nglobalMaxProduct = 24\\n\\ni = 3:\\nlocalMaxProduct = 120\\nlocalMinProduct = -60\\nglobalMaxProduct = 120\\n\\ni = 4:\\nlocalMaxProduct = 240\\nlocalMinProduct = -120\\nglobalMaxProduct = 240\\n\\ni = 5:\\nlocalMaxProduct = 480\\nlocalMinProduct = -480\\nglobalMaxProduct = 480\\n\\ni = 6:\\nlocalMaxProduct = 480\\nlocalMinProduct = -960\\nglobalMaxProduct = 480\\n\\nIn each iteration, we update `localMaxProduct` and `localMinProduct` based on the current element and the previous values of `localMaxProduct` and `localMinProduct`. We then update `globalMaxProduct` to be the maximum of the current `localMaxProduct` and the previous `globalMaxProduct`. This ensures that we keep track of the maximum product seen so far.\\n\\n```\\nPlease do not forget to like and comment :)\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxProduct = function (nums) {\\n  let globalMaxProduct = nums[0];\\n  let localMaxProduct = nums[0];\\n  let localMinProduct = nums[0];\\n\\n  for (let i = 1; i < nums.length; i++) {\\n    // We keep a temp variable because we want to keep track of the localMaxProduct before any calculations.\\n    let prevLocalMaxProduct = localMaxProduct;\\n\\n    localMaxProduct = Math.max(\\n      nums[i],\\n      nums[i] * localMaxProduct,\\n      nums[i] * localMinProduct\\n    );\\n    localMinProduct = Math.min(\\n      nums[i],\\n      nums[i] * prevLocalMaxProduct,\\n      nums[i] * localMinProduct\\n    );\\n\\n    globalMaxProduct = Math.max(localMaxProduct, globalMaxProduct);\\n  }\\n\\n  return globalMaxProduct;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n                      /-------------\\\\\\n                      v             |\\nInput Array: [-2, 3, -4, 5, 2, -2, 1]\\n        index:  0  1   2  3  4   5  6\\n\\n              /---------\\\\\\n              v         |\\n              -2        |\\n              /---------\\\\\\n              v         |\\n              3         |\\n              /---------\\\\\\n              v         |\\n              -4        |\\n              /---------\\\\\\n              v         |\\n              5         |\\n              /---------\\\\\\n              v         |\\n              2         |\\n              /---------\\\\\\n              v         |\\n              -2        |\\n              /---------\\\\\\n              v         |\\n              1         |\\n              \\\\---------/\\n\\nAt each iteration, we calculate the local maximum and local minimum products ending at the current index (represented by the arrows above). The global maximum product is updated based on the local maximum product calculated at each iteration. Here\\'s how the values of the variables change at each iteration for the input array above:\\n\\ni = 1:\\nlocalMaxProduct = 3\\nlocalMinProduct = -6\\nglobalMaxProduct = 3\\n\\ni = 2:\\nlocalMaxProduct = 24\\nlocalMinProduct = -12\\nglobalMaxProduct = 24\\n\\ni = 3:\\nlocalMaxProduct = 120\\nlocalMinProduct = -60\\nglobalMaxProduct = 120\\n\\ni = 4:\\nlocalMaxProduct = 240\\nlocalMinProduct = -120\\nglobalMaxProduct = 240\\n\\ni = 5:\\nlocalMaxProduct = 480\\nlocalMinProduct = -480\\nglobalMaxProduct = 480\\n\\ni = 6:\\nlocalMaxProduct = 480\\nlocalMinProduct = -960\\nglobalMaxProduct = 480\\n\\nIn each iteration, we update `localMaxProduct` and `localMinProduct` based on the current element and the previous values of `localMaxProduct` and `localMinProduct`. We then update `globalMaxProduct` to be the maximum of the current `localMaxProduct` and the previous `globalMaxProduct`. This ensures that we keep track of the maximum product seen so far.\\n\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxProduct = function (nums) {\\n  let globalMaxProduct = nums[0];\\n  let localMaxProduct = nums[0];\\n  let localMinProduct = nums[0];\\n\\n  for (let i = 1; i < nums.length; i++) {\\n    // We keep a temp variable because we want to keep track of the localMaxProduct before any calculations.\\n    let prevLocalMaxProduct = localMaxProduct;\\n\\n    localMaxProduct = Math.max(\\n      nums[i],\\n      nums[i] * localMaxProduct,\\n      nums[i] * localMinProduct\\n    );\\n    localMinProduct = Math.min(\\n      nums[i],\\n      nums[i] * prevLocalMaxProduct,\\n      nums[i] * localMinProduct\\n    );\\n\\n    globalMaxProduct = Math.max(localMaxProduct, globalMaxProduct);\\n  }\\n\\n  return globalMaxProduct;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3286073,
                "title": "follow-up-question-also-print-return-the-maximum-product-subarray",
                "content": "# Intuition\\nHave an end pointer to the index whenever you update global maximum. After traversing the array fully, have a seperate while to see what is the potential starting point of the maximum product subarray.\\n\\n# Approach\\nEvery time global maximum is updated, we reset the end of the subarray. So we move from back to find what could be possible starting of that subarray that contributes to maximum product.\\n\\nWhile moving the starting pointer if we encounter some number to be 0, the start pointer stops there, or if the number itself has contributed for the globalMaximum at that point, IT MEANS NO VALUE BEFORE THAT POINT HAS CONTRIBUTED TO THE MAXIMUM PRODUCT. Moving back from end to potential start point using j pointer, at every point we divide contributed value by the number itself to move backwards in search of finding the starting point of subarray.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        currentMinimum = nums[0]\\n        currentMaximum = nums[0]\\n        globalMaximum = nums[0]\\n\\n        start = 0\\n        end = 1\\n\\n        for i in range(1,len(nums)):\\n            currentMinimum, currentMaximum  = min(currentMinimum * nums[i], currentMaximum * nums[i], nums[i]), max(currentMinimum * nums[i], currentMaximum * nums[i], nums[i])\\n            \\n            if (currentMaximum > globalMaximum):\\n                globalMaximum = currentMaximum\\n                end=i+1\\n                \\n\\n        j=end-1\\n        while j>=0:\\n            if nums[j]==0:\\n                start = j\\n                break\\n            else:\\n                if globalMaximum == nums[j]:\\n                    start = j\\n                    break\\n                globalMaximum = globalMaximum/nums[j]\\n            j-=1\\n\\n        #nums[start: end] is the maximum product subarray!!\\n        prod = 1\\n        for num in nums[start: end]:\\n            prod *=num\\n\\n        return prod\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        currentMinimum = nums[0]\\n        currentMaximum = nums[0]\\n        globalMaximum = nums[0]\\n\\n        start = 0\\n        end = 1\\n\\n        for i in range(1,len(nums)):\\n            currentMinimum, currentMaximum  = min(currentMinimum * nums[i], currentMaximum * nums[i], nums[i]), max(currentMinimum * nums[i], currentMaximum * nums[i], nums[i])\\n            \\n            if (currentMaximum > globalMaximum):\\n                globalMaximum = currentMaximum\\n                end=i+1\\n                \\n\\n        j=end-1\\n        while j>=0:\\n            if nums[j]==0:\\n                start = j\\n                break\\n            else:\\n                if globalMaximum == nums[j]:\\n                    start = j\\n                    break\\n                globalMaximum = globalMaximum/nums[j]\\n            j-=1\\n\\n        #nums[start: end] is the maximum product subarray!!\\n        prod = 1\\n        for num in nums[start: end]:\\n            prod *=num\\n\\n        return prod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267334,
                "title": "2-best-solutions-in-constant-space",
                "content": "# Code\\n```\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size(), maxi = nums[0], pre = 0, suf = 0;\\n        for(int i = 0;i < n; i++) {\\n            pre = (pre ? pre : 1) * nums[i];\\n            suf = (suf ? suf : 1) * nums[n-i-1];\\n            maxi = max(maxi, max(pre, suf));\\n        }\\n        return maxi;\\n    }\\nor\\n    int maxProduct(vector<int>& nums) {\\n        int maxi = nums[0], imax = nums[0], imin = nums[0];\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i] < 0)\\n                swap(imax, imin);\\n            imax = max(imax * nums[i], nums[i]);\\n            imin = min(imin * nums[i], nums[i]);\\n            maxi = max(maxi, imax);\\n        }\\n        return maxi;\\n    }\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size(), maxi = nums[0], pre = 0, suf = 0;\\n        for(int i = 0;i < n; i++) {\\n            pre = (pre ? pre : 1) * nums[i];\\n            suf = (suf ? suf : 1) * nums[n-i-1];\\n            maxi = max(maxi, max(pre, suf));\\n        }\\n        return maxi;\\n    }\\nor\\n    int maxProduct(vector<int>& nums) {\\n        int maxi = nums[0], imax = nums[0], imin = nums[0];\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i] < 0)\\n                swap(imax, imin);\\n            imax = max(imax * nums[i], nums[i]);\\n            imin = min(imin * nums[i], nums[i]);\\n            maxi = max(maxi, imax);\\n        }\\n        return maxi;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3050988,
                "title": "super-easy-java-sol-0ms-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int ans = Integer.MIN_VALUE;\\n        int curr_prod = 1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            curr_prod*=nums[i];\\n            ans = Math.max(ans,curr_prod);\\n            if(curr_prod==0){\\n                curr_prod=1;\\n            }\\n        }\\n        curr_prod=1;\\n        for(int j=nums.length-1;j>=0;j--){\\n            curr_prod*=nums[j];\\n            ans = Math.max(ans,curr_prod);\\n            if(curr_prod==0){\\n                curr_prod=1;\\n        }\\n        }   return ans;\\n        } \\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int ans = Integer.MIN_VALUE;\\n        int curr_prod = 1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            curr_prod*=nums[i];\\n            ans = Math.max(ans,curr_prod);\\n            if(curr_prod==0){\\n                curr_prod=1;\\n            }\\n        }\\n        curr_prod=1;\\n        for(int j=nums.length-1;j>=0;j--){\\n            curr_prod*=nums[j];\\n            ans = Math.max(ans,curr_prod);\\n            if(curr_prod==0){\\n                curr_prod=1;\\n        }\\n        }   return ans;\\n        } \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420264,
                "title": "easiest-o-n-python-soln-w-explanation-single-pass",
                "content": "* Traverse L-R and keep storing the min product and max product. \\n* If current val is 0 or neg, **swap the min and max** product bcz Max value when mulitplied to neg, will be the minimum value now ( 100 * -2 = -200 ) and vice versa.\\n* **Upvote the solution if you find it helpful**\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        ans=nums[0]\\n        maxprod,minprod=ans,ans\\n\\t\\t\\n        for i in range(1,len(nums)):\\n            if nums[i]<0:\\n                maxprod,minprod=minprod,maxprod\\n                \\n            maxprod=max(nums[i],maxprod*nums[i])\\n            minprod=min(nums[i],minprod*nums[i])\\n            ans=max(ans,maxprod)\\n            \\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        ans=nums[0]\\n        maxprod,minprod=ans,ans\\n\\t\\t\\n        for i in range(1,len(nums)):\\n            if nums[i]<0:\\n                maxprod,minprod=minprod,maxprod\\n                \\n            maxprod=max(nums[i],maxprod*nums[i])\\n            minprod=min(nums[i],minprod*nums[i])\\n            ans=max(ans,maxprod)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944256,
                "title": "java-100-working-and-explained-each-line",
                "content": "We need to solve the given question considering that (neg * neg = pos) and this value can be the max product so we need to store the max negative products too, \\nagain one more edge case comes for the zeroes since X * 0 = 0; be it negative or positive, so we need to handle for that as well;\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int maxProduct(int[] nums) {\\n\\t\\t\\tint max_prod = nums[0];\\n\\t\\t\\tint curr_max = 1, curr_min = 1; \\n\\n\\t\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t\\t  if(nums[i]==0){ curr_max = 1; curr_min = 1; }\\n\\n\\t\\t\\t int temp = curr_max * nums[i];\\n\\t\\t\\t curr_max = Math.max(nums[i], Math.max(curr_max * nums[i], curr_min*nums[i]));\\n\\t\\t\\t curr_min = Math.min(nums[i], Math.min(temp, curr_min * nums[i]));\\n\\t\\t\\t max_prod = Math.max(max_prod, curr_max);\\n\\t\\t\\t}\\n\\t\\t\\treturn max_prod;\\n\\t\\t}\\n\\t}\\n\\t\\n\\t\\n curr_max = Math.max(nums[i], Math.max(curr_max * nums[i], curr_min * nums[i])); //this line checks if the stored product multiplied with the new number  is greater or the stored minimum number with the new number multiplied is greter or the current number itself is greater,\\n Similarly for the curr_min , since we need to get the lowest value possible bcoz (-10<-80, but if -80 * -1 = 80, which ofcourse wil be greater than -10 * -1 , hence the minimum)\\n now finally we store the gretest value in our max_prod, we are not considering curr_min here is becoz, curr_min has to be multiplied with a value to become the greatest number.\\n \\n### please upvote if you liked the solution.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int maxProduct(int[] nums) {\\n\\t\\t\\tint max_prod = nums[0];\\n\\t\\t\\tint curr_max = 1, curr_min = 1; \\n\\n\\t\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t\\t  if(nums[i]==0){ curr_max = 1; curr_min = 1; }",
                "codeTag": "Java"
            },
            {
                "id": 1848322,
                "title": "100-faster-time-o-n-one-pass-solution",
                "content": "***Upvote to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n\\n**Explanation :-**\\n1. Calculate prod1 from the start and prod2 from the end.\\n2. Update res with the maximum of previous res value and maximum of prod1( calculated from left side) and prod2( calculated from right side).\\n3. If prod1 or prod2 becomes 0, update them with 1.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int prod1 = 1;\\n        int prod2 = 1;\\n        int res = nums[0];\\n        int n = nums.size();\\n        for(int i = 0 ; i < n ; i++){\\n            prod1 *= nums[i];\\n            prod2 *= nums[n - 1 - i];\\n            res = max(res, max(prod1 , prod2));\\n            if(prod1 == 0){\\n                prod1 = 1;\\n            }\\n            if(prod2 == 0){\\n                prod2 = 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int prod1 = 1;\\n        int prod2 = 1;\\n        int res = nums[0];\\n        int n = nums.size();\\n        for(int i = 0 ; i < n ; i++){\\n            prod1 *= nums[i];\\n            prod2 *= nums[n - 1 - i];\\n            res = max(res, max(prod1 , prod2));\\n            if(prod1 == 0){\\n                prod1 = 1;\\n            }\\n            if(prod2 == 0){\\n                prod2 = 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770091,
                "title": "c-super-simple-o-n",
                "content": "Appraoch : \\nStep 1: Traverse the array from Left -> Right. \\nStep 2: Traverse the array from Right -> Left.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int ans=INT_MIN;\\n        int prod=1;\\n\\n        \\n        for(int i=0;i<nums.size();i++){\\n            prod=prod*nums[i];\\n            ans=max(ans,prod);\\n            \\n            if(prod==0) prod=1;\\n        }\\n        \\n        prod=1;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            prod=prod*nums[i];\\n            ans=max(prod,ans);\\n            \\n            if(prod==0) prod=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int ans=INT_MIN;\\n        int prod=1;\\n\\n        \\n        for(int i=0;i<nums.size();i++){\\n            prod=prod*nums[i];\\n            ans=max(ans,prod);\\n            \\n            if(prod==0) prod=1;\\n        }\\n        \\n        prod=1;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            prod=prod*nums[i];\\n            ans=max(prod,ans);\\n            \\n            if(prod==0) prod=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681214,
                "title": "python-intuitive-o-n-time-explained",
                "content": "**Approach**\\n\\nSo, the first thing that comes to mind is using the same approach as the maximum sum subarray, however, this breaks down with multiplying negative numbers because a negative number can lead you to a maximum later down the line. This means we must keep track of both the current maximum product and the current minimum product. This can allow us to account for negative values that lead to maximums further in the iterations.\\n\\n**Big O Break Down**\\nThis is O(n) because we are iterating through the list one time, and every iteration has constant time calculations. \\n\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        totalMax = prevMax = prevMin = nums[0]\\n        for i,num in enumerate(nums[1:]):\\n            currentMin = min(num, prevMax*num, prevMin*num)\\n            currentMax = max(num, prevMax*num, prevMin*num)\\n            totalMax = max(currentMax, totalMax)\\n            prevMax = currentMax\\n            prevMin = currentMin\\n        return totalMax\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        totalMax = prevMax = prevMin = nums[0]\\n        for i,num in enumerate(nums[1:]):\\n            currentMin = min(num, prevMax*num, prevMin*num)\\n            currentMax = max(num, prevMax*num, prevMin*num)\\n            totalMax = max(currentMax, totalMax)\\n            prevMax = currentMax\\n            prevMin = currentMin\\n        return totalMax\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508486,
                "title": "1-ms-in-java-using-kadane-s-algorithm",
                "content": "```\\npublic  int MaximumProduct(int[] arr, int n) {\\n\\n        int result = arr[0];\\n        int maxNegative = arr[0];\\n        int maxPositive = arr[0];\\n\\n        for (int i = 1; i < n; i++) {\\n\\t\\t// We are using temp variable to store the maxPositive incase it changes!\\n            int temp = maxPositive;\\n            maxPositive = Math.max(arr[i], Math.max(arr[i] * maxPositive, arr[i] * maxNegative));\\n            maxNegative = Math.min(arr[i], Math.min(arr[i] * maxNegative, arr[i] * temp));\\n            result = Math.max(result, maxPositive);\\n        }\\n\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic  int MaximumProduct(int[] arr, int n) {\\n\\n        int result = arr[0];\\n        int maxNegative = arr[0];\\n        int maxPositive = arr[0];\\n\\n        for (int i = 1; i < n; i++) {\\n\\t\\t// We are using temp variable to store the maxPositive incase it changes!\\n            int temp = maxPositive;\\n            maxPositive = Math.max(arr[i], Math.max(arr[i] * maxPositive, arr[i] * maxNegative));\\n            maxNegative = Math.min(arr[i], Math.min(arr[i] * maxNegative, arr[i] * temp));\\n            result = Math.max(result, maxPositive);\\n        }\\n\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1421549,
                "title": "python-simplest-possible-dp-solution-o-n-time-o-1-space",
                "content": "Here, we think about the simplest recurrence relation as we will with any DP solution.\\n\\nAt each value, we simply either take the value or don\\'t take the value. It\\'s very similar to the maximum subarray.\\n\\nAt each point, you simply cache a min value and a max value, any min value can be constructed from the num at an index, the products of all mins before and the current num or the max multiplied by the current num if the num is negative.\\n\\n```python\\ndef maxProduct(self, nums: List[int]) -> int:\\n    if len(nums) == 0:\\n        return 0\\n        \\n    min_rolling = 1\\n    max_rolling = 1\\n    max_product = nums[0]\\n        \\n    for num in nums:\\n        min_rolling, max_rolling = \\\\\\n            min(min_rolling * num, num, max_rolling * num), \\\\\\n            max(max_rolling * num, num, min_rolling * num)\\n        max_product = max(max_rolling, max_product)\\n        \\nreturn max_product\\n```\\n\\nHere\\'s a simple example to illustrate the edge case of a positive number being wedged between multiple negative numbers.\\n\\n```\\nTest case: [-1, 0, -2, 5, -10]\\n\\nnum = -1\\nmax_rolling = max(1 * -1, -1, 1 * -1) => -1\\nmin_rolling = min(1 * -1, -1, 1 * -1) => -1\\nmax_product = max(-1, -1) => -1\\n\\nnum = 0\\nmax_rolling = max(-1 * 0, 0, -1 * 0) => 0\\nmin_rolling = min(-1 * 0, 0, -1 * 0) => 0\\nmax_product = max(-1, 0) => 0\\n\\nnum = -2\\nmax_rolling = max(0 * 2, -2, 0 * 2) => 0\\nmin_rolling = min(0 * 2, -2, 0 * 2) => -2\\nmax_product = max(0, 0) => 0\\n\\nnum = 5\\nmax_rolling = max(0 * 5, 5, -2 * 5) => 5\\nmin_rolling = min(0 * 5, 5, -2 * 5) => -10\\nmax_product = max(0, 5) => 5\\n\\nnum = -10\\nmax_rolling = max(5 * -10, -10, -2 * -10) => 20\\nmin_rolling = min(5 * -10, -10, -2 * -10) => -50\\nmax_product = max(5, 20) => 20\\n```",
                "solutionTags": [],
                "code": "```python\\ndef maxProduct(self, nums: List[int]) -> int:\\n    if len(nums) == 0:\\n        return 0\\n        \\n    min_rolling = 1\\n    max_rolling = 1\\n    max_product = nums[0]\\n        \\n    for num in nums:\\n        min_rolling, max_rolling = \\\\\\n            min(min_rolling * num, num, max_rolling * num), \\\\\\n            max(max_rolling * num, num, min_rolling * num)\\n        max_product = max(max_rolling, max_product)\\n        \\nreturn max_product\\n```\n```\\nTest case: [-1, 0, -2, 5, -10]\\n\\nnum = -1\\nmax_rolling = max(1 * -1, -1, 1 * -1) => -1\\nmin_rolling = min(1 * -1, -1, 1 * -1) => -1\\nmax_product = max(-1, -1) => -1\\n\\nnum = 0\\nmax_rolling = max(-1 * 0, 0, -1 * 0) => 0\\nmin_rolling = min(-1 * 0, 0, -1 * 0) => 0\\nmax_product = max(-1, 0) => 0\\n\\nnum = -2\\nmax_rolling = max(0 * 2, -2, 0 * 2) => 0\\nmin_rolling = min(0 * 2, -2, 0 * 2) => -2\\nmax_product = max(0, 0) => 0\\n\\nnum = 5\\nmax_rolling = max(0 * 5, 5, -2 * 5) => 5\\nmin_rolling = min(0 * 5, 5, -2 * 5) => -10\\nmax_product = max(0, 5) => 5\\n\\nnum = -10\\nmax_rolling = max(5 * -10, -10, -2 * -10) => 20\\nmin_rolling = min(5 * -10, -10, -2 * -10) => -50\\nmax_product = max(5, 20) => 20\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1337502,
                "title": "python-3-o-n-solution-hints-with-spoiler",
                "content": "**Hints:**\\n* The solution idea is very similar to Kadane\\'s Algorithm. \\n* In each iteration, we keep track of the max product of sub-arrays till the current num\\n* Think about what happens when we multiply negative numbers with the current max product. \\ne.g. if current max is `100` and we get the number `-2` then we get `(100 * -2) = -200`\\n* So, we need to keep track of min product of sub-arrays as well in each iteration \\n*  Because, min product can also turn into a potential max product if we multiply it with negative number. \\ne.g. `(-200 * -2) = 400`\\n<details>\\n<summary> View Code </summary>\\n\\n```python\\nclass Solution:\\n\\tdef maxProduct(self, nums: List[int]) -> int:    \\n\\t\\tans , max_p, min_p = nums[0], 1, 1   \\n\\t\\tfor num in nums:            \\n\\t\\t\\tmax_p, min_p = max(num, min_p * num, max_p * num), min(num, min_p * num, max_p * num)\\n\\t\\t\\tans = max(ans, max_p)\\n\\t\\treturn ans\\n```\\n</details>",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n\\tdef maxProduct(self, nums: List[int]) -> int:    \\n\\t\\tans , max_p, min_p = nums[0], 1, 1   \\n\\t\\tfor num in nums:            \\n\\t\\t\\tmax_p, min_p = max(num, min_p * num, max_p * num), min(num, min_p * num, max_p * num)\\n\\t\\t\\tans = max(ans, max_p)\\n\\t\\treturn ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975310,
                "title": "java-recursive-and-dp-solution-time-o-n-2-o-n-space-o-1",
                "content": "**Algorithm**\\n* **Approach 1 (Recursion - TLE)**\\n* call the recursive `dfs` function with each of the `index`\\n* In the recursive `dfs` function, the base case is to check if the passed `index` is going over the length of the `nums` array\\n* If not recurse with multiplying the result with the `index` element and increment the `index` for the next recursive call\\n\\n```\\nclass Solution {\\n     int max = Integer.MIN_VALUE;\\n     protected void dfs(int[] nums, int res, int index){\\n         if (index > nums.length-1)\\n             return;\\n         res = res * nums[index];\\n         max  = Math.max(max, res);\\n         dfs(nums, res, index+1);    \\n     }\\n     public int maxProduct(int[] nums) {\\n         if (nums.length == 0)\\n             return 0;\\n        \\n         for (int i=0;i<nums.length;i++){\\n             int res = 1;\\n             dfs(nums,res, i);\\n         }\\n         return max;\\n     }\\n```\\n* **Approach 2 (DP / Kadane\\'s Algorithm Accepted)**\\n* At each index we make sure to compute three values - overall max, max seen so far, min seen so far\\n* **maxEndingHere** will store all the max product seen so far \\n\\t* this will be coming from either the current element `nums[i]`\\n\\t* or the product of current element with `maxEndingHere` so far\\n\\t* or the product of current element with `minEndingHere` so far (two negative can be positive and may be higher)\\n* **minEndingHere** to store the mininmum product seen so far\\n\\t* this will be coming from either the current element itself `nums[i]`\\n\\t* or the product of current element with `minEndingHere` so far\\n\\t* or the product of current element with `maxEndingHere` (since max Ending here will be updated prior to this, we take the value of `maxEndingHere` just before updating in a temp variable)\\n* **maxOverall** to store the maximum product that was ever computed while iterating the elements, get the max from `maxOverall` and `maxEndingHere`\\n\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int maxOverall = nums[0];\\n        int maxEndingHere = nums[0];\\n        int minEndingHere = nums[0];\\n\\n        for (int i=1;i<nums.length; i++){\\n            int tmp = maxEndingHere;\\n            maxEndingHere = Math.max(nums[i], Math.max(nums[i] * maxEndingHere,nums[i] * minEndingHere));\\n            minEndingHere = Math.min(nums[i], Math.min(nums[i] * tmp,nums[i] * minEndingHere));\\n            maxOverall = Math.max(maxOverall, maxEndingHere);\\n        }\\n        return maxOverall;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     int max = Integer.MIN_VALUE;\\n     protected void dfs(int[] nums, int res, int index){\\n         if (index > nums.length-1)\\n             return;\\n         res = res * nums[index];\\n         max  = Math.max(max, res);\\n         dfs(nums, res, index+1);    \\n     }\\n     public int maxProduct(int[] nums) {\\n         if (nums.length == 0)\\n             return 0;\\n        \\n         for (int i=0;i<nums.length;i++){\\n             int res = 1;\\n             dfs(nums,res, i);\\n         }\\n         return max;\\n     }\\n```\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int maxOverall = nums[0];\\n        int maxEndingHere = nums[0];\\n        int minEndingHere = nums[0];\\n\\n        for (int i=1;i<nums.length; i++){\\n            int tmp = maxEndingHere;\\n            maxEndingHere = Math.max(nums[i], Math.max(nums[i] * maxEndingHere,nums[i] * minEndingHere));\\n            minEndingHere = Math.min(nums[i], Math.min(nums[i] * tmp,nums[i] * minEndingHere));\\n            maxOverall = Math.max(maxOverall, maxEndingHere);\\n        }\\n        return maxOverall;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841314,
                "title": "java-super-simple-short-solution-o-n-faster-than-95",
                "content": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n         // we keep also the minimum-product subarray for the case of multiplying negative with negative\\n        int max_pro = nums[0];\\n        int min_save = nums[0];\\n        int max_save = nums[0];\\n        for (int i=1; i<nums.length; i++) {\\n            // if we got a negative element, we will swap maximum with minimum\\n            if (nums[i] < 0){\\n                int tmp = min_save;\\n                min_save = max_save;\\n                max_save = tmp;\\n            }\\n            min_save = Math.min(nums[i], min_save*nums[i]);\\n            max_save = Math.max(nums[i], max_save*nums[i]);\\n            max_pro = Math.max(max_pro, max_save);\\n        }\\n        return max_pro;\\n    }\\n}\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n         // we keep also the minimum-product subarray for the case of multiplying negative with negative\\n        int max_pro = nums[0];\\n        int min_save = nums[0];\\n        int max_save = nums[0];\\n        for (int i=1; i<nums.length; i++) {\\n            // if we got a negative element, we will swap maximum with minimum\\n            if (nums[i] < 0){\\n                int tmp = min_save;\\n                min_save = max_save;\\n                max_save = tmp;\\n            }\\n            min_save = Math.min(nums[i], min_save*nums[i]);\\n            max_save = Math.max(nums[i], max_save*nums[i]);\\n            max_pro = Math.max(max_pro, max_save);\\n        }\\n        return max_pro;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 457534,
                "title": "go-golang-kadane-s-algorithm-solution",
                "content": ">Runtime: 0 ms, faster than 100.00% of Go online submissions for Maximum Product Subarray.\\nMemory Usage: 2.7 MB, less than 100.00% of Go online submissions for Maximum Product Subarray.\\n\\n```go\\nfunc maxProduct(nums []int) int {\\n    curMax, curMin, ans := nums[0], nums[0], nums[0]\\n    for i := 1; i < len(nums); i++ {\\n        tmp := curMax\\n        curMax = max(nums[i], max(tmp * nums[i], curMin * nums[i]))\\n        curMin = min(nums[i], min(tmp * nums[i], curMin * nums[i]))\\n        if curMax > ans { ans = curMax }\\n    }\\n    return ans\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc maxProduct(nums []int) int {\\n    curMax, curMin, ans := nums[0], nums[0], nums[0]\\n    for i := 1; i < len(nums); i++ {\\n        tmp := curMax\\n        curMax = max(nums[i], max(tmp * nums[i], curMin * nums[i]))\\n        curMin = min(nums[i], min(tmp * nums[i], curMin * nums[i]))\\n        if curMax > ans { ans = curMax }\\n    }\\n    return ans\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 417082,
                "title": "python-92-speed-in-6-lines-with-explanation",
                "content": "Intuitively, you need to keep track of a current product as well as a maximum product. The current product at each index in the list will choose to start the subarray over at that index or multiply it into the current product depending on which is bigger. But, because of negative products, we need to additionally keep track of a minimum current product, because a large negative value could be changed into positive again. So at each index, the min and max current products are chosen from starting the subarray over, continuing from curMax, or continuing from curMin.\\n\\n```\\n    def maxProduct(self, nums: List[int]) -> int:\\n        curMax = curMin = maxProd = nums[0]\\n        for i in range(1, len(nums)):\\n            curMin, curMax = min(curMax * nums[i], curMin * nums[i], nums[i]), max(nums[i], curMax * nums[i], curMin * nums[i])\\n            maxProd = max(maxProd, curMax)\\n        return maxProd\\n```\\n\\n**Test case:**\\n\\n[0, 12, 3, -1, 1, 1, -10]\\n\\n[**0**, 12, 3, -1, 1, 1, -10]\\ncurMax = 0\\ncurMin = 0\\nmaxProd = 0\\n\\n[0, **12**, 3, -1, 1, 1, -10]\\ncurMax = 12\\ncurMin = 0\\nmaxProd = 12\\n\\n[0, 12, **3**, -1, 1, 1, -10]\\ncurMax = 36\\ncurMin = 0\\nmaxProd = 36\\n\\n[0, 12, 3, **-1**, 1, 1, -10]\\ncurMax = 0\\ncurMin = -36\\nmaxProd = 36\\n\\n[0, 12, 3, -1, **1**, 1, -10]\\ncurMax = 1\\ncurMin = -36\\nmaxProd = 36\\n\\n[0, 12, 3, -1, 1, **1**, -10]\\ncurMax = 1\\ncurMin = -36\\nmaxProd = 36\\n\\n[0, 12, 3, -1, 1, 1, **-10**]\\ncurMax = 360\\ncurMin = -10\\nmaxProd = 360\\n\\n",
                "solutionTags": [],
                "code": "```\\n    def maxProduct(self, nums: List[int]) -> int:\\n        curMax = curMin = maxProd = nums[0]\\n        for i in range(1, len(nums)):\\n            curMin, curMax = min(curMax * nums[i], curMin * nums[i], nums[i]), max(nums[i], curMax * nums[i], curMin * nums[i])\\n            maxProd = max(maxProd, curMax)\\n        return maxProd\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 385813,
                "title": "python-simple-7-line-code-o-n-time-o-1-space-dp-better-than-99-51-of-submissions",
                "content": "```\\nclass Solution:\\n\\n    def maxProduct(self, nums: List[int]) -> int:\\n        min_ = max_ = overall_max = nums[0]\\n        \\n        for num in nums[1:]:\\n            temp_max = max(num, min_*num, max_*num)\\n            min_ = min(num, min_*num, max_*num)\\n            max_ = temp_max\\n            overall_max =  max(overall_max, max_)\\n            \\n        return overall_max\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\n    def maxProduct(self, nums: List[int]) -> int:\\n        min_ = max_ = overall_max = nums[0]\\n        \\n        for num in nums[1:]:\\n            temp_max = max(num, min_*num, max_*num)\\n            min_ = min(num, min_*num, max_*num)\\n            max_ = temp_max\\n            overall_max =  max(overall_max, max_)\\n            \\n        return overall_max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 284569,
                "title": "c-dp-solution-o-n-time-o-1-space-with-detailed-explaination",
                "content": "```\\n\\n        SubProblem(i): \\n\\t\\t\\t\\t\\tMax[i]: the maximum product of a continuous subarray that ends at i\\n                    Min[i]: the minimum product of a continuous subarray that ends at i\\n\\t\\tAnalysis:\\n\\t\\t\\t\\tNote that since the subarray ends at i must include the ith element,\\n\\t\\t\\t\\tinorder to get the maximum product that ends at i we only has three cases\\n\\t\\t\\t\\tcase1: the maximum product that ends at i-1 times the ith number\\n\\t\\t\\t\\t\\te.g. 1 2 3 4 5  we have Max[i] = Max[i-1] * nums[i] for all i\\n\\t\\t\\t\\tcase2: the minimum product that ends at i-1 times the ith number\\n\\t\\t\\t\\t\\te.g. sign changes involves -1 2 3 4 5 -6, we have Max[5] = Min[4] * nums[5]\\n\\t\\t\\t\\t\\t(0 index)\\n\\t\\t\\t\\tcase3: the maximum product is the ith number\\n\\t\\t\\t\\t\\te.g. -1 0 0 1 we have Max[3] = 1\\n\\t\\tCombine these three cases we have:\\n\\t\\t\\tBase Case:\\n\\t\\t\\t\\t\\tMin[0] = nums[0], Max[0] = nums[0]\\n\\t\\t\\tRecursive Case:\\n\\t\\t\\t\\t\\t\\tMax[i] = max(Min[i-1] * nums[i], nums[i], Max[i-1] * nums[i])\\n\\t\\t\\t\\t\\t\\tMin[i] = max(Min[i-1] * nums[i], nums[i], Max[i-1] * nums[i])\\n\\t\\t\\tAnswer:\\n\\t\\t\\t\\t\\tmaximum Max[i]\\n\\t\\t\\tTime Complexity:\\n\\t\\t\\t\\tO(n)\\n\\t\\t\\tSpace Complexity:\\n\\t\\t\\t\\tO(1), by writing Max[i] as Max[i % 2]\\n    \\n\\n```\\n```\\nclass Solution {\\npublic:\\n  \\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 0) return 0;\\n        int Min[2] = {nums[0], 0}, Max[2] = {nums[0], 0};\\n        int ans = Max[0], i;\\n        for (i = 1; i < n; i++) {\\n            Max[i % 2] = max(max(Max[(i - 1) % 2] * nums[i], nums[i]), Min[(i - 1) % 2] * nums[i]);\\n            Min[i % 2] = min(min(Max[(i - 1) % 2] * nums[i], nums[i]), Min[(i - 1) % 2] * nums[i]);\\n            ans = max(ans, Max[i % 2]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n        SubProblem(i): \\n\\t\\t\\t\\t\\tMax[i]: the maximum product of a continuous subarray that ends at i\\n                    Min[i]: the minimum product of a continuous subarray that ends at i\\n\\t\\tAnalysis:\\n\\t\\t\\t\\tNote that since the subarray ends at i must include the ith element,\\n\\t\\t\\t\\tinorder to get the maximum product that ends at i we only has three cases\\n\\t\\t\\t\\tcase1: the maximum product that ends at i-1 times the ith number\\n\\t\\t\\t\\t\\te.g. 1 2 3 4 5  we have Max[i] = Max[i-1] * nums[i] for all i\\n\\t\\t\\t\\tcase2: the minimum product that ends at i-1 times the ith number\\n\\t\\t\\t\\t\\te.g. sign changes involves -1 2 3 4 5 -6, we have Max[5] = Min[4] * nums[5]\\n\\t\\t\\t\\t\\t(0 index)\\n\\t\\t\\t\\tcase3: the maximum product is the ith number\\n\\t\\t\\t\\t\\te.g. -1 0 0 1 we have Max[3] = 1\\n\\t\\tCombine these three cases we have:\\n\\t\\t\\tBase Case:\\n\\t\\t\\t\\t\\tMin[0] = nums[0], Max[0] = nums[0]\\n\\t\\t\\tRecursive Case:\\n\\t\\t\\t\\t\\t\\tMax[i] = max(Min[i-1] * nums[i], nums[i], Max[i-1] * nums[i])\\n\\t\\t\\t\\t\\t\\tMin[i] = max(Min[i-1] * nums[i], nums[i], Max[i-1] * nums[i])\\n\\t\\t\\tAnswer:\\n\\t\\t\\t\\t\\tmaximum Max[i]\\n\\t\\t\\tTime Complexity:\\n\\t\\t\\t\\tO(n)\\n\\t\\t\\tSpace Complexity:\\n\\t\\t\\t\\tO(1), by writing Max[i] as Max[i % 2]\\n    \\n\\n```\n```\\nclass Solution {\\npublic:\\n  \\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 0) return 0;\\n        int Min[2] = {nums[0], 0}, Max[2] = {nums[0], 0};\\n        int ans = Max[0], i;\\n        for (i = 1; i < n; i++) {\\n            Max[i % 2] = max(max(Max[(i - 1) % 2] * nums[i], nums[i]), Min[(i - 1) % 2] * nums[i]);\\n            Min[i % 2] = min(min(Max[(i - 1) % 2] * nums[i], nums[i]), Min[(i - 1) % 2] * nums[i]);\\n            ans = max(ans, Max[i % 2]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188541,
                "title": "recursive-memoized-solution",
                "content": "\\nHer is the recursive memoized solution if you wanted to draw intuition for the iterative solution\\n\\n```\\n    public int maxProduct(int[] nums) {\\n        Integer[][] table = new Integer[nums.length][2] ;\\n        memo(nums.length-1,nums, table);\\n        int max = nums[0];\\n        \\n        for(Integer[] t : table)\\n            for(Integer val : t)\\n                max = Math.max(val,max);\\n        \\n        return max;     \\n    }\\n    \\n    Integer[] memo(int i, int[] nums, Integer[][] dp){\\n        if(i == 0)\\n            dp[i] = new Integer[]{nums[0],nums[i]};\\n        if(dp[i][0] == null){\\n            dp[i][0] = Math.min(memo(i-1,nums,dp)[1] * nums[i],Math.min(memo(i-1,nums,dp)[0] * nums[i], nums[i]));\\n            dp[i][1] = Math.max(memo(i-1,nums,dp)[1] * nums[i],Math.max(memo(i-1,nums,dp)[0] * nums[i], nums[i]));\\n                        \\n        }\\n        return dp[i];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxProduct(int[] nums) {\\n        Integer[][] table = new Integer[nums.length][2] ;\\n        memo(nums.length-1,nums, table);\\n        int max = nums[0];\\n        \\n        for(Integer[] t : table)\\n            for(Integer val : t)\\n                max = Math.max(val,max);\\n        \\n        return max;     \\n    }\\n    \\n    Integer[] memo(int i, int[] nums, Integer[][] dp){\\n        if(i == 0)\\n            dp[i] = new Integer[]{nums[0],nums[i]};\\n        if(dp[i][0] == null){\\n            dp[i][0] = Math.min(memo(i-1,nums,dp)[1] * nums[i],Math.min(memo(i-1,nums,dp)[0] * nums[i], nums[i]));\\n            dp[i][1] = Math.max(memo(i-1,nums,dp)[1] * nums[i],Math.max(memo(i-1,nums,dp)[0] * nums[i], nums[i]));\\n                        \\n        }\\n        return dp[i];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 118535,
                "title": "c-dp-solution-using-2-arrays",
                "content": "The following solution is acheived using Dynamic Programming concept. We are finding the maximum product posssible(pos[]) and the minimum product possible(neg[]) at each step.\\n\\nWe have to maintain the minimum possible product because if we encounter a negative number in future, this product will result into the maximum positive value\\n\\n```\\nclass Solution {\\npublic:\\n    inline int maximum(const int& a,const int& b,const int& c) {\\n        return a>b?(a>c?a:c):(b>c?b:c);\\n}\\n    \\n    inline int minimum(const int& a,const int& b,const int& c) {\\n        return a<b?(a<c?a:c):(b<c?b:c);\\n}\\n    int maxProduct(vector<int>& nums) {\\n        //Making two dp arrays to store the maximum postive product and minimum negative product at each point\\n        int size = nums.size();\\n        int pos[size],neg[size];\\n        \\n        //Initialize to first term\\n        pos[0] = nums[0];\\n        neg[0] = nums[0];\\n        int ans = nums[0];\\n        \\n        //The positive array tries toget the max product while the negative array tries to get the least\\n        for(int i=1; i<size; i++) \\n        {\\n            pos[i] = maximum(nums[i], pos[i-1]*nums[i],neg[i-1]*nums[i]); \\n            neg[i] = minimum(nums[i], pos[i-1]*nums[i],neg[i-1]*nums[i]);\\n           \\n            ans = max(ans, pos[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nThankyou @shinichish for the [solution](https://leetcode.com/problems/maximum-product-subarray/discuss/48261/Share-my-DP-code-that-got-AC). \\nAlso, the given solution can be solved just using 2 variables - Check [this](https://leetcode.com/problems/maximum-product-subarray/discuss/48261/Share-my-DP-code-that-got-AC/48395)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    inline int maximum(const int& a,const int& b,const int& c) {\\n        return a>b?(a>c?a:c):(b>c?b:c);\\n}\\n    \\n    inline int minimum(const int& a,const int& b,const int& c) {\\n        return a<b?(a<c?a:c):(b<c?b:c);\\n}\\n    int maxProduct(vector<int>& nums) {\\n        //Making two dp arrays to store the maximum postive product and minimum negative product at each point\\n        int size = nums.size();\\n        int pos[size],neg[size];\\n        \\n        //Initialize to first term\\n        pos[0] = nums[0];\\n        neg[0] = nums[0];\\n        int ans = nums[0];\\n        \\n        //The positive array tries toget the max product while the negative array tries to get the least\\n        for(int i=1; i<size; i++) \\n        {\\n            pos[i] = maximum(nums[i], pos[i-1]*nums[i],neg[i-1]*nums[i]); \\n            neg[i] = minimum(nums[i], pos[i-1]*nums[i],neg[i-1]*nums[i]);\\n           \\n            ans = max(ans, pos[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48303,
                "title": "summary-of-maximum-subarray-maximum-product-subarray",
                "content": "Maximum Product Subarray\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        int result = nums[0], global_min = nums[0], global_max = nums[0];\\n        for (int i = 1; i < nums.size(); i++) {\\n            int local_min = global_min, local_max = global_max;\\n            global_max = max(max(nums[i], local_max * nums[i]), local_min * nums[i]);\\n            global_min = min(min(nums[i], local_max * nums[i]), local_min * nums[i]);\\n            result = max(result, global_max);\\n        }\\n        return result;\\n    }\\n};\\n```\\nMaximum Subarray\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        int global = nums[0];\\n        int local = nums[0];\\n        for (int i = 1; i < nums.size(); i++) {\\n            local = max(nums[i], local + nums[i]);\\n            global = max(global, local);\\n        }\\n        return global;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        int result = nums[0], global_min = nums[0], global_max = nums[0];\\n        for (int i = 1; i < nums.size(); i++) {\\n            int local_min = global_min, local_max = global_max;\\n            global_max = max(max(nums[i], local_max * nums[i]), local_min * nums[i]);\\n            global_min = min(min(nums[i], local_max * nums[i]), local_min * nums[i]);\\n            result = max(result, global_max);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48346,
                "title": "o-n-time-o-1-space-c-solution",
                "content": "\\n    class Solution {\\n    public:\\n        int maxProduct(vector<int>& nums) {\\n            assert (!nums.empty());\\n            int curMax = nums[0], curMin = nums[0], res = nums[0];\\n            for (int i = 1; i < nums.size(); ++i) {\\n                int mx = curMax, mn = curMin;\\n                curMax = max(max(mx * nums[i], mn * nums[i]), nums[i]);\\n                curMin = min(min(mx * nums[i], mn * nums[i]), nums[i]);\\n                res = max(res, curMax);\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int maxProduct(vector<int>& nums) {\\n            assert (!nums.empty());\\n            int curMax = nums[0], curMin = nums[0], res = nums[0];\\n            for (int i = 1; i < nums.size(); ++i) {\\n                int mx = curMax, mn = curMin;\\n                curMax = max(max(mx * nums[i], mn * nums[i]), nums[i]);\\n                curMin = min(min(mx * nums[i], mn * nums[i]), nums[i]);\\n                res = max(res, curMax);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 48408,
                "title": "share-accepted-dp-java-o-n-solution",
                "content": "    public class Solution {\\n        public int maxProduct(int[] nums) {\\n            int n = nums.length;\\n            int[] maxProduct = new int[n];\\n            int[] minProduct = new int[n];\\n            maxProduct[0] = nums[0];\\n            minProduct[0] = nums[0];\\n            for (int i = 1; i < n; i++) {\\n               int[] temp = new int[3];\\n               temp[0] = nums[i];\\n               temp[1] = nums[i] * maxProduct[i - 1];\\n               temp[2] = nums[i] * minProduct[i - 1];\\n               Arrays.sort(temp);\\n               minProduct[i] = temp[0];\\n               maxProduct[i] = temp[2];\\n            }\\n            int max = Integer.MIN_VALUE;\\n            for (int i = 0; i < n; i++) {\\n                if (maxProduct[i] > max) {\\n                    max = maxProduct[i];\\n                }\\n            }\\n            return max;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maxProduct(int[] nums) {\\n            int n = nums.length;\\n            int[] maxProduct = new int[n];\\n            int[] minProduct = new int[n];\\n            maxProduct[0] = nums[0];\\n            minProduct[0] = nums[0];\\n            for (int i = 1; i < n; i++) {\\n               int[] temp = new int[3];\\n               temp[0] = nums[i];\\n               temp[1] = nums[i] * maxProduct[i - 1];\\n               temp[2] = nums[i] * minProduct[i - 1];\\n               Arrays.sort(temp);\\n               minProduct[i] = temp[0];\\n               maxProduct[i] = temp[2];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3748707,
                "title": "c-python-kadane-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKadane\\'s Algorithm for maximal product for subarrays\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[152. Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/solutions/3748707/c-kadane-s-algorithm/)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)\\n\\nThe code solves the problem of finding the maximum product of a subarray within an input vector nums. It is based on the Kadane\\'s algorithm, which is typically used to find the maximum sum of subarrays. However, in this case, instead of finding the maximum sum, we need to find the maximum product.\\n\\nIn the modified version of the algorithm for finding the maximum product, instead of considering the sum, the code tracks the product. However, due to the presence of negative numbers, simply considering the maximum product ending at the current index is not sufficient. Negative numbers can potentially result in a larger product when multiplied by another negative number. Hence, it becomes necessary to keep track of both the maximum and minimum products ending at each index.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int x0=nums[0];\\n        int max_product = x0;  \\n        int curr_max = x0; \\n        int curr_min = x0;  \\n        \\n        for (int i=1; i<n; i++) {\\n            int x=nums[i];\\n            if (x < 0)\\n                swap(curr_max, curr_min);\\n            \\n            // Update the maximum and minimum products\\n            curr_max = max(x, curr_max * x);\\n            curr_min = min(x, curr_min * x);\\n            \\n            // Update the overall maximum product\\n            max_product = max(max_product, curr_max);\\n        }\\n        return max_product;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        x0=nums[0]\\n        max_p=x0\\n        curr_max=x0\\n        curr_min=x0\\n\\n        for x in nums[1:]:\\n            if x<0:\\n                tmp=curr_max\\n                curr_max=curr_min\\n                curr_min=tmp\\n            curr_max=max(curr_max*x, x)\\n            curr_min=min(curr_min*x, x)\\n\\n            max_p=max(max_p, curr_max)\\n        return max_p\\n```\\n# C++ code with Explanation in comments\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int max_prod = nums[0];  // Initialize the maximum product\\n        int curr_max = nums[0];  // Store the maximum product ending at the current index\\n        int curr_min = nums[0];  // Store the minimum product ending at the current index\\n        \\n        for (int i = 1; i < n; i++) {\\n            // If the current number is negative, swap the maximum and minimum products\\n            if (nums[i] < 0)\\n                swap(curr_max, curr_min);\\n            \\n            // Update the maximum and minimum products for the current index\\n            curr_max = max(nums[i], curr_max * nums[i]);\\n            curr_min = min(nums[i], curr_min * nums[i]);\\n            \\n            // Update the overall maximum product if necessary\\n            max_prod = max(max_prod, curr_max);\\n        }\\n        \\n        return max_prod;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int x0=nums[0];\\n        int max_product = x0;  \\n        int curr_max = x0; \\n        int curr_min = x0;  \\n        \\n        for (int i=1; i<n; i++) {\\n            int x=nums[i];\\n            if (x < 0)\\n                swap(curr_max, curr_min);\\n            \\n            // Update the maximum and minimum products\\n            curr_max = max(x, curr_max * x);\\n            curr_min = min(x, curr_min * x);\\n            \\n            // Update the overall maximum product\\n            max_product = max(max_product, curr_max);\\n        }\\n        return max_product;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        x0=nums[0]\\n        max_p=x0\\n        curr_max=x0\\n        curr_min=x0\\n\\n        for x in nums[1:]:\\n            if x<0:\\n                tmp=curr_max\\n                curr_max=curr_min\\n                curr_min=tmp\\n            curr_max=max(curr_max*x, x)\\n            curr_min=min(curr_min*x, x)\\n\\n            max_p=max(max_p, curr_max)\\n        return max_p\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int max_prod = nums[0];  // Initialize the maximum product\\n        int curr_max = nums[0];  // Store the maximum product ending at the current index\\n        int curr_min = nums[0];  // Store the minimum product ending at the current index\\n        \\n        for (int i = 1; i < n; i++) {\\n            // If the current number is negative, swap the maximum and minimum products\\n            if (nums[i] < 0)\\n                swap(curr_max, curr_min);\\n            \\n            // Update the maximum and minimum products for the current index\\n            curr_max = max(nums[i], curr_max * nums[i]);\\n            curr_min = min(nums[i], curr_min * nums[i]);\\n            \\n            // Update the overall maximum product if necessary\\n            max_prod = max(max_prod, curr_max);\\n        }\\n        \\n        return max_prod;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251454,
                "title": "easy-solution-o-n-time-complexity-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can easily reach to the solution by finding out the max product from left side and right side of the array.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, we have to traverse the array from **0th** index till the last index of **nums[]** array and keep on multiplying the **curr** value with the current index value and check whether **curr > max** or not. If **curr > max** then we simply update max as curr. \\n\\nif there\\'s an index in the array whose value is 0 then the curr value gets updated to 1 **(as after that curr value will remain as 0 till the end if we do not update it)**.\\n\\n\\nSimilarly, we traverse from the last index and apply the same logic again.\\n\\nWe do this because, \\n\\nfor nums[] = [3,-1,4] , if we traverse from left index only then we get the max value as **3**. \\n\\nmax at index 0 = 3;\\nmax at index 1 = 3(product will be -3);\\nmax at index 2 = 3(product will be -12);\\n\\nbut we can see that the maximum product will be **4** if we traverse from the right side of the array.\\n\\nmax at index 2 = 4;\\nmax at index 1 = 4(product will be -4);\\nmax at index 0 = 4(product will be -12);\\n\\nhence , when we traverse from the last also it will rectify the mistake and give us the correct answer as **4**.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int curr = 1;\\n        int i , j , len = nums.length;\\n        int max = Integer.MIN_VALUE;\\n        for(i = 0 ; i < len ; i++){\\n            curr *= nums[i];\\n            if(curr > max){\\n                max = curr;\\n            }\\n            if(curr == 0){\\n                curr = 1;\\n            }\\n        }\\n        curr = 1;\\n        for(j = len - 1 ; j >= 0 ; j--){\\n            curr *= nums[j];\\n            if(curr > max){\\n                max = curr;\\n            }\\n            if(curr == 0){\\n                curr = 1;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int curr = 1;\\n        int i , j , len = nums.length;\\n        int max = Integer.MIN_VALUE;\\n        for(i = 0 ; i < len ; i++){\\n            curr *= nums[i];\\n            if(curr > max){\\n                max = curr;\\n            }\\n            if(curr == 0){\\n                curr = 1;\\n            }\\n        }\\n        curr = 1;\\n        for(j = len - 1 ; j >= 0 ; j--){\\n            curr *= nums[j];\\n            if(curr > max){\\n                max = curr;\\n            }\\n            if(curr == 0){\\n                curr = 1;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565102,
                "title": "o-n-tc-o-1-sc-two-scan-even-and-odd-negative-number-approach",
                "content": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        res=nums[0]\\n        temp=1\\n        for i in nums:\\n            temp*=i\\n            res=max(res,temp)\\n            if temp==0:\\n                temp=1\\n        temp=1\\n        for i in reversed(nums):\\n            temp*=i\\n            res=max(temp,res)\\n            if temp==0:\\n                temp=1\\n        return res\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        res=nums[0]\\n        temp=1\\n        for i in nums:\\n            temp*=i\\n            res=max(res,temp)\\n            if temp==0:\\n                temp=1\\n        temp=1\\n        for i in reversed(nums):\\n            temp*=i\\n            res=max(temp,res)\\n            if temp==0:\\n                temp=1\\n        return res\\n            \\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566383,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1827167,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568984,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1574343,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1575312,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 2059311,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566672,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1965281,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1785312,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565370,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566383,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1827167,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568984,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1574343,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1575312,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 2059311,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566672,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1965281,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1785312,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565370,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1571346,
                "content": [
                    {
                        "username": "sudeeshs",
                        "content": "Hi there leetcoders,\\n\\n   I can't digest why the expected output of the testcase [-2, 3 -4] is 24? The numbers aren't contiguous!!\\n\\nAnd how do you obtain 24? |-2| * |3| * |-4| ???? Weird! Haaallppp!!!"
                    },
                    {
                        "username": "A_ADITI",
                        "content": "[@rahulbhatta](/rahulbhatta)   hey can u tell me how to check all the test cases "
                    },
                    {
                        "username": "rahulbhatta",
                        "content": "Exactly. The first case is expected to be 6,makes sense if you are getting the max of only 2 inputs. But in the 84th case, they expect the muliplication of all the values in the list."
                    },
                    {
                        "username": "ThatsBig",
                        "content": "-2*(-4) = 8"
                    },
                    {
                        "username": "s_r_1000",
                        "content": "This is the definition of contiguous, a continuous subarray. So when you do:\\n\\n-2 * 3 * -4 you get 24, because the values are one after the other."
                    },
                    {
                        "username": "hp01",
                        "content": "(-2 * 3 * -4) = 24"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "product of tow negative numbers comes positive my mate"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its -2*3*-4 which is +24\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@bhardwajashish](/bhardwajashish) true its so obvious bro"
                    },
                    {
                        "username": "vipin0761",
                        "content": "no need to take \"abs\" value, -2*3*-4=24"
                    },
                    {
                        "username": "bhardwajashish",
                        "content": "bro product of 2 negative is positive, [-2,3,-4] it is a subset in itself, hence -2*3*-4 = 24\\n"
                    },
                    {
                        "username": "Yash2403",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nWho the hell added this test case ?"
                    },
                    {
                        "username": "prakhar241",
                        "content": "We can certainly devise divide and conquer for Maximum sum subarray, but while developing divide and conquer based algorithm for maximum product subarray, I found we might need to keep the maximum & absolute maximum for both parts (and crossing products), but it seems we can devise it. I was just curios why I don't see any divide and conquer based algorithm in discussions?\\n\\nIs it because since we keep the max and global max are we going towards the DP?\\n\\nAny idea will be appreciated. I just want to clarify my understanding for approach. Thanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Maximum Subarray Problem can be solved using a divide and conquer approach, which is based on the observation that a contiguous subarray\\'s maximum sum is either in the left half, right half, or crosses the middle.\\n\\nFor the Maximum Product Subarray Problem, a divide and conquer approach is a bit trickier, due to the nature of multiplication. In the case of sum, you only need to care about the largest sum; but in the case of product, you need to consider both the largest and smallest (most negative) product, because a negative number can turn the smallest product into the largest.\\n\\nWhile you could technically use a divide and conquer approach similar to the maximum sum subarray problem, the reason you don\\'t see it often in discussions or solutions is because it\\'s more complicated and doesn\\'t offer any significant advantages in terms of time complexity. The time complexity for both the divide and conquer and dynamic programming (DP) solutions is O(n), but the DP solution tends to be simpler to understand and implement.\\n\\nIn terms of your question about DP: yes, keeping track of the maximum and global maximum as you iterate through the array is a form of DP. In essence, DP is about breaking a problem down into smaller subproblems, and reusing solutions to those subproblems to build up the solution to the overall problem. In this case, the subproblems are finding the maximum product subarray ending at each position in the array, and you\\'re reusing those solutions to find the maximum product subarray over the entire array."
                    },
                    {
                        "username": "shiv_commit",
                        "content": "we can also \\napply, extension of kadance algo"
                    },
                    {
                        "username": "andrewtgg",
                        "content": "Why is expected output 2? how do you get that value?"
                    },
                    {
                        "username": "cthuga",
                        "content": "There is a testcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nand constraint says: The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\nWhich is clearly not true. Can someone help me understand here ?"
                    },
                    {
                        "username": "anurag_333",
                        "content": "a new test case is added which voilates the constraint.\\nCode that was AC earlier is getting overflowed\\n\\n"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "How many people initially went ahead with directly implementing Kadane\\'s algorithm only to realize that the direct implementation doesn\\'t work?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/4dbff713-aa0c-4c2d-b920-2530b32e0548_1645155457.5751603.jpeg)\\n"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "What part of no solutions in discussion did you not understand?"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@ashish7475](/ashish7475)  i got it , just to eradicate all edge cases we can traverse from both sides or in other words kedane from both sides."
                    },
                    {
                        "username": "ashish7475",
                        "content": "can you share the intuition behind this appraoch\\n"
                    },
                    {
                        "username": "aftabmk",
                        "content": "Everyone : Kadane\\'s Algorithm !\\ntestcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] : No!"
                    },
                    {
                        "username": "jwggernawt",
                        "content": "Is it considered product when there is only one operand?\\nFor example: array=[3]. "
                    },
                    {
                        "username": "fkhd",
                        "content": "Personally I don\\'t think so. But they are considering it in their usecases."
                    }
                ]
            },
            {
                "id": 2058942,
                "content": [
                    {
                        "username": "sudeeshs",
                        "content": "Hi there leetcoders,\\n\\n   I can't digest why the expected output of the testcase [-2, 3 -4] is 24? The numbers aren't contiguous!!\\n\\nAnd how do you obtain 24? |-2| * |3| * |-4| ???? Weird! Haaallppp!!!"
                    },
                    {
                        "username": "A_ADITI",
                        "content": "[@rahulbhatta](/rahulbhatta)   hey can u tell me how to check all the test cases "
                    },
                    {
                        "username": "rahulbhatta",
                        "content": "Exactly. The first case is expected to be 6,makes sense if you are getting the max of only 2 inputs. But in the 84th case, they expect the muliplication of all the values in the list."
                    },
                    {
                        "username": "ThatsBig",
                        "content": "-2*(-4) = 8"
                    },
                    {
                        "username": "s_r_1000",
                        "content": "This is the definition of contiguous, a continuous subarray. So when you do:\\n\\n-2 * 3 * -4 you get 24, because the values are one after the other."
                    },
                    {
                        "username": "hp01",
                        "content": "(-2 * 3 * -4) = 24"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "product of tow negative numbers comes positive my mate"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its -2*3*-4 which is +24\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@bhardwajashish](/bhardwajashish) true its so obvious bro"
                    },
                    {
                        "username": "vipin0761",
                        "content": "no need to take \"abs\" value, -2*3*-4=24"
                    },
                    {
                        "username": "bhardwajashish",
                        "content": "bro product of 2 negative is positive, [-2,3,-4] it is a subset in itself, hence -2*3*-4 = 24\\n"
                    },
                    {
                        "username": "Yash2403",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nWho the hell added this test case ?"
                    },
                    {
                        "username": "prakhar241",
                        "content": "We can certainly devise divide and conquer for Maximum sum subarray, but while developing divide and conquer based algorithm for maximum product subarray, I found we might need to keep the maximum & absolute maximum for both parts (and crossing products), but it seems we can devise it. I was just curios why I don't see any divide and conquer based algorithm in discussions?\\n\\nIs it because since we keep the max and global max are we going towards the DP?\\n\\nAny idea will be appreciated. I just want to clarify my understanding for approach. Thanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Maximum Subarray Problem can be solved using a divide and conquer approach, which is based on the observation that a contiguous subarray\\'s maximum sum is either in the left half, right half, or crosses the middle.\\n\\nFor the Maximum Product Subarray Problem, a divide and conquer approach is a bit trickier, due to the nature of multiplication. In the case of sum, you only need to care about the largest sum; but in the case of product, you need to consider both the largest and smallest (most negative) product, because a negative number can turn the smallest product into the largest.\\n\\nWhile you could technically use a divide and conquer approach similar to the maximum sum subarray problem, the reason you don\\'t see it often in discussions or solutions is because it\\'s more complicated and doesn\\'t offer any significant advantages in terms of time complexity. The time complexity for both the divide and conquer and dynamic programming (DP) solutions is O(n), but the DP solution tends to be simpler to understand and implement.\\n\\nIn terms of your question about DP: yes, keeping track of the maximum and global maximum as you iterate through the array is a form of DP. In essence, DP is about breaking a problem down into smaller subproblems, and reusing solutions to those subproblems to build up the solution to the overall problem. In this case, the subproblems are finding the maximum product subarray ending at each position in the array, and you\\'re reusing those solutions to find the maximum product subarray over the entire array."
                    },
                    {
                        "username": "shiv_commit",
                        "content": "we can also \\napply, extension of kadance algo"
                    },
                    {
                        "username": "andrewtgg",
                        "content": "Why is expected output 2? how do you get that value?"
                    },
                    {
                        "username": "cthuga",
                        "content": "There is a testcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nand constraint says: The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\nWhich is clearly not true. Can someone help me understand here ?"
                    },
                    {
                        "username": "anurag_333",
                        "content": "a new test case is added which voilates the constraint.\\nCode that was AC earlier is getting overflowed\\n\\n"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "How many people initially went ahead with directly implementing Kadane\\'s algorithm only to realize that the direct implementation doesn\\'t work?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/4dbff713-aa0c-4c2d-b920-2530b32e0548_1645155457.5751603.jpeg)\\n"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "What part of no solutions in discussion did you not understand?"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@ashish7475](/ashish7475)  i got it , just to eradicate all edge cases we can traverse from both sides or in other words kedane from both sides."
                    },
                    {
                        "username": "ashish7475",
                        "content": "can you share the intuition behind this appraoch\\n"
                    },
                    {
                        "username": "aftabmk",
                        "content": "Everyone : Kadane\\'s Algorithm !\\ntestcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] : No!"
                    },
                    {
                        "username": "jwggernawt",
                        "content": "Is it considered product when there is only one operand?\\nFor example: array=[3]. "
                    },
                    {
                        "username": "fkhd",
                        "content": "Personally I don\\'t think so. But they are considering it in their usecases."
                    }
                ]
            },
            {
                "id": 1571343,
                "content": [
                    {
                        "username": "sudeeshs",
                        "content": "Hi there leetcoders,\\n\\n   I can't digest why the expected output of the testcase [-2, 3 -4] is 24? The numbers aren't contiguous!!\\n\\nAnd how do you obtain 24? |-2| * |3| * |-4| ???? Weird! Haaallppp!!!"
                    },
                    {
                        "username": "A_ADITI",
                        "content": "[@rahulbhatta](/rahulbhatta)   hey can u tell me how to check all the test cases "
                    },
                    {
                        "username": "rahulbhatta",
                        "content": "Exactly. The first case is expected to be 6,makes sense if you are getting the max of only 2 inputs. But in the 84th case, they expect the muliplication of all the values in the list."
                    },
                    {
                        "username": "ThatsBig",
                        "content": "-2*(-4) = 8"
                    },
                    {
                        "username": "s_r_1000",
                        "content": "This is the definition of contiguous, a continuous subarray. So when you do:\\n\\n-2 * 3 * -4 you get 24, because the values are one after the other."
                    },
                    {
                        "username": "hp01",
                        "content": "(-2 * 3 * -4) = 24"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "product of tow negative numbers comes positive my mate"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its -2*3*-4 which is +24\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@bhardwajashish](/bhardwajashish) true its so obvious bro"
                    },
                    {
                        "username": "vipin0761",
                        "content": "no need to take \"abs\" value, -2*3*-4=24"
                    },
                    {
                        "username": "bhardwajashish",
                        "content": "bro product of 2 negative is positive, [-2,3,-4] it is a subset in itself, hence -2*3*-4 = 24\\n"
                    },
                    {
                        "username": "Yash2403",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nWho the hell added this test case ?"
                    },
                    {
                        "username": "prakhar241",
                        "content": "We can certainly devise divide and conquer for Maximum sum subarray, but while developing divide and conquer based algorithm for maximum product subarray, I found we might need to keep the maximum & absolute maximum for both parts (and crossing products), but it seems we can devise it. I was just curios why I don't see any divide and conquer based algorithm in discussions?\\n\\nIs it because since we keep the max and global max are we going towards the DP?\\n\\nAny idea will be appreciated. I just want to clarify my understanding for approach. Thanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Maximum Subarray Problem can be solved using a divide and conquer approach, which is based on the observation that a contiguous subarray\\'s maximum sum is either in the left half, right half, or crosses the middle.\\n\\nFor the Maximum Product Subarray Problem, a divide and conquer approach is a bit trickier, due to the nature of multiplication. In the case of sum, you only need to care about the largest sum; but in the case of product, you need to consider both the largest and smallest (most negative) product, because a negative number can turn the smallest product into the largest.\\n\\nWhile you could technically use a divide and conquer approach similar to the maximum sum subarray problem, the reason you don\\'t see it often in discussions or solutions is because it\\'s more complicated and doesn\\'t offer any significant advantages in terms of time complexity. The time complexity for both the divide and conquer and dynamic programming (DP) solutions is O(n), but the DP solution tends to be simpler to understand and implement.\\n\\nIn terms of your question about DP: yes, keeping track of the maximum and global maximum as you iterate through the array is a form of DP. In essence, DP is about breaking a problem down into smaller subproblems, and reusing solutions to those subproblems to build up the solution to the overall problem. In this case, the subproblems are finding the maximum product subarray ending at each position in the array, and you\\'re reusing those solutions to find the maximum product subarray over the entire array."
                    },
                    {
                        "username": "shiv_commit",
                        "content": "we can also \\napply, extension of kadance algo"
                    },
                    {
                        "username": "andrewtgg",
                        "content": "Why is expected output 2? how do you get that value?"
                    },
                    {
                        "username": "cthuga",
                        "content": "There is a testcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nand constraint says: The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\nWhich is clearly not true. Can someone help me understand here ?"
                    },
                    {
                        "username": "anurag_333",
                        "content": "a new test case is added which voilates the constraint.\\nCode that was AC earlier is getting overflowed\\n\\n"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "How many people initially went ahead with directly implementing Kadane\\'s algorithm only to realize that the direct implementation doesn\\'t work?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/4dbff713-aa0c-4c2d-b920-2530b32e0548_1645155457.5751603.jpeg)\\n"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "What part of no solutions in discussion did you not understand?"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@ashish7475](/ashish7475)  i got it , just to eradicate all edge cases we can traverse from both sides or in other words kedane from both sides."
                    },
                    {
                        "username": "ashish7475",
                        "content": "can you share the intuition behind this appraoch\\n"
                    },
                    {
                        "username": "aftabmk",
                        "content": "Everyone : Kadane\\'s Algorithm !\\ntestcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] : No!"
                    },
                    {
                        "username": "jwggernawt",
                        "content": "Is it considered product when there is only one operand?\\nFor example: array=[3]. "
                    },
                    {
                        "username": "fkhd",
                        "content": "Personally I don\\'t think so. But they are considering it in their usecases."
                    }
                ]
            },
            {
                "id": 1570007,
                "content": [
                    {
                        "username": "sudeeshs",
                        "content": "Hi there leetcoders,\\n\\n   I can't digest why the expected output of the testcase [-2, 3 -4] is 24? The numbers aren't contiguous!!\\n\\nAnd how do you obtain 24? |-2| * |3| * |-4| ???? Weird! Haaallppp!!!"
                    },
                    {
                        "username": "A_ADITI",
                        "content": "[@rahulbhatta](/rahulbhatta)   hey can u tell me how to check all the test cases "
                    },
                    {
                        "username": "rahulbhatta",
                        "content": "Exactly. The first case is expected to be 6,makes sense if you are getting the max of only 2 inputs. But in the 84th case, they expect the muliplication of all the values in the list."
                    },
                    {
                        "username": "ThatsBig",
                        "content": "-2*(-4) = 8"
                    },
                    {
                        "username": "s_r_1000",
                        "content": "This is the definition of contiguous, a continuous subarray. So when you do:\\n\\n-2 * 3 * -4 you get 24, because the values are one after the other."
                    },
                    {
                        "username": "hp01",
                        "content": "(-2 * 3 * -4) = 24"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "product of tow negative numbers comes positive my mate"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its -2*3*-4 which is +24\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@bhardwajashish](/bhardwajashish) true its so obvious bro"
                    },
                    {
                        "username": "vipin0761",
                        "content": "no need to take \"abs\" value, -2*3*-4=24"
                    },
                    {
                        "username": "bhardwajashish",
                        "content": "bro product of 2 negative is positive, [-2,3,-4] it is a subset in itself, hence -2*3*-4 = 24\\n"
                    },
                    {
                        "username": "Yash2403",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nWho the hell added this test case ?"
                    },
                    {
                        "username": "prakhar241",
                        "content": "We can certainly devise divide and conquer for Maximum sum subarray, but while developing divide and conquer based algorithm for maximum product subarray, I found we might need to keep the maximum & absolute maximum for both parts (and crossing products), but it seems we can devise it. I was just curios why I don't see any divide and conquer based algorithm in discussions?\\n\\nIs it because since we keep the max and global max are we going towards the DP?\\n\\nAny idea will be appreciated. I just want to clarify my understanding for approach. Thanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Maximum Subarray Problem can be solved using a divide and conquer approach, which is based on the observation that a contiguous subarray\\'s maximum sum is either in the left half, right half, or crosses the middle.\\n\\nFor the Maximum Product Subarray Problem, a divide and conquer approach is a bit trickier, due to the nature of multiplication. In the case of sum, you only need to care about the largest sum; but in the case of product, you need to consider both the largest and smallest (most negative) product, because a negative number can turn the smallest product into the largest.\\n\\nWhile you could technically use a divide and conquer approach similar to the maximum sum subarray problem, the reason you don\\'t see it often in discussions or solutions is because it\\'s more complicated and doesn\\'t offer any significant advantages in terms of time complexity. The time complexity for both the divide and conquer and dynamic programming (DP) solutions is O(n), but the DP solution tends to be simpler to understand and implement.\\n\\nIn terms of your question about DP: yes, keeping track of the maximum and global maximum as you iterate through the array is a form of DP. In essence, DP is about breaking a problem down into smaller subproblems, and reusing solutions to those subproblems to build up the solution to the overall problem. In this case, the subproblems are finding the maximum product subarray ending at each position in the array, and you\\'re reusing those solutions to find the maximum product subarray over the entire array."
                    },
                    {
                        "username": "shiv_commit",
                        "content": "we can also \\napply, extension of kadance algo"
                    },
                    {
                        "username": "andrewtgg",
                        "content": "Why is expected output 2? how do you get that value?"
                    },
                    {
                        "username": "cthuga",
                        "content": "There is a testcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nand constraint says: The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\nWhich is clearly not true. Can someone help me understand here ?"
                    },
                    {
                        "username": "anurag_333",
                        "content": "a new test case is added which voilates the constraint.\\nCode that was AC earlier is getting overflowed\\n\\n"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "How many people initially went ahead with directly implementing Kadane\\'s algorithm only to realize that the direct implementation doesn\\'t work?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/4dbff713-aa0c-4c2d-b920-2530b32e0548_1645155457.5751603.jpeg)\\n"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "What part of no solutions in discussion did you not understand?"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@ashish7475](/ashish7475)  i got it , just to eradicate all edge cases we can traverse from both sides or in other words kedane from both sides."
                    },
                    {
                        "username": "ashish7475",
                        "content": "can you share the intuition behind this appraoch\\n"
                    },
                    {
                        "username": "aftabmk",
                        "content": "Everyone : Kadane\\'s Algorithm !\\ntestcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] : No!"
                    },
                    {
                        "username": "jwggernawt",
                        "content": "Is it considered product when there is only one operand?\\nFor example: array=[3]. "
                    },
                    {
                        "username": "fkhd",
                        "content": "Personally I don\\'t think so. But they are considering it in their usecases."
                    }
                ]
            },
            {
                "id": 2059974,
                "content": [
                    {
                        "username": "sudeeshs",
                        "content": "Hi there leetcoders,\\n\\n   I can't digest why the expected output of the testcase [-2, 3 -4] is 24? The numbers aren't contiguous!!\\n\\nAnd how do you obtain 24? |-2| * |3| * |-4| ???? Weird! Haaallppp!!!"
                    },
                    {
                        "username": "A_ADITI",
                        "content": "[@rahulbhatta](/rahulbhatta)   hey can u tell me how to check all the test cases "
                    },
                    {
                        "username": "rahulbhatta",
                        "content": "Exactly. The first case is expected to be 6,makes sense if you are getting the max of only 2 inputs. But in the 84th case, they expect the muliplication of all the values in the list."
                    },
                    {
                        "username": "ThatsBig",
                        "content": "-2*(-4) = 8"
                    },
                    {
                        "username": "s_r_1000",
                        "content": "This is the definition of contiguous, a continuous subarray. So when you do:\\n\\n-2 * 3 * -4 you get 24, because the values are one after the other."
                    },
                    {
                        "username": "hp01",
                        "content": "(-2 * 3 * -4) = 24"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "product of tow negative numbers comes positive my mate"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its -2*3*-4 which is +24\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@bhardwajashish](/bhardwajashish) true its so obvious bro"
                    },
                    {
                        "username": "vipin0761",
                        "content": "no need to take \"abs\" value, -2*3*-4=24"
                    },
                    {
                        "username": "bhardwajashish",
                        "content": "bro product of 2 negative is positive, [-2,3,-4] it is a subset in itself, hence -2*3*-4 = 24\\n"
                    },
                    {
                        "username": "Yash2403",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nWho the hell added this test case ?"
                    },
                    {
                        "username": "prakhar241",
                        "content": "We can certainly devise divide and conquer for Maximum sum subarray, but while developing divide and conquer based algorithm for maximum product subarray, I found we might need to keep the maximum & absolute maximum for both parts (and crossing products), but it seems we can devise it. I was just curios why I don't see any divide and conquer based algorithm in discussions?\\n\\nIs it because since we keep the max and global max are we going towards the DP?\\n\\nAny idea will be appreciated. I just want to clarify my understanding for approach. Thanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Maximum Subarray Problem can be solved using a divide and conquer approach, which is based on the observation that a contiguous subarray\\'s maximum sum is either in the left half, right half, or crosses the middle.\\n\\nFor the Maximum Product Subarray Problem, a divide and conquer approach is a bit trickier, due to the nature of multiplication. In the case of sum, you only need to care about the largest sum; but in the case of product, you need to consider both the largest and smallest (most negative) product, because a negative number can turn the smallest product into the largest.\\n\\nWhile you could technically use a divide and conquer approach similar to the maximum sum subarray problem, the reason you don\\'t see it often in discussions or solutions is because it\\'s more complicated and doesn\\'t offer any significant advantages in terms of time complexity. The time complexity for both the divide and conquer and dynamic programming (DP) solutions is O(n), but the DP solution tends to be simpler to understand and implement.\\n\\nIn terms of your question about DP: yes, keeping track of the maximum and global maximum as you iterate through the array is a form of DP. In essence, DP is about breaking a problem down into smaller subproblems, and reusing solutions to those subproblems to build up the solution to the overall problem. In this case, the subproblems are finding the maximum product subarray ending at each position in the array, and you\\'re reusing those solutions to find the maximum product subarray over the entire array."
                    },
                    {
                        "username": "shiv_commit",
                        "content": "we can also \\napply, extension of kadance algo"
                    },
                    {
                        "username": "andrewtgg",
                        "content": "Why is expected output 2? how do you get that value?"
                    },
                    {
                        "username": "cthuga",
                        "content": "There is a testcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nand constraint says: The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\nWhich is clearly not true. Can someone help me understand here ?"
                    },
                    {
                        "username": "anurag_333",
                        "content": "a new test case is added which voilates the constraint.\\nCode that was AC earlier is getting overflowed\\n\\n"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "How many people initially went ahead with directly implementing Kadane\\'s algorithm only to realize that the direct implementation doesn\\'t work?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/4dbff713-aa0c-4c2d-b920-2530b32e0548_1645155457.5751603.jpeg)\\n"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "What part of no solutions in discussion did you not understand?"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@ashish7475](/ashish7475)  i got it , just to eradicate all edge cases we can traverse from both sides or in other words kedane from both sides."
                    },
                    {
                        "username": "ashish7475",
                        "content": "can you share the intuition behind this appraoch\\n"
                    },
                    {
                        "username": "aftabmk",
                        "content": "Everyone : Kadane\\'s Algorithm !\\ntestcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] : No!"
                    },
                    {
                        "username": "jwggernawt",
                        "content": "Is it considered product when there is only one operand?\\nFor example: array=[3]. "
                    },
                    {
                        "username": "fkhd",
                        "content": "Personally I don\\'t think so. But they are considering it in their usecases."
                    }
                ]
            },
            {
                "id": 2058644,
                "content": [
                    {
                        "username": "sudeeshs",
                        "content": "Hi there leetcoders,\\n\\n   I can't digest why the expected output of the testcase [-2, 3 -4] is 24? The numbers aren't contiguous!!\\n\\nAnd how do you obtain 24? |-2| * |3| * |-4| ???? Weird! Haaallppp!!!"
                    },
                    {
                        "username": "A_ADITI",
                        "content": "[@rahulbhatta](/rahulbhatta)   hey can u tell me how to check all the test cases "
                    },
                    {
                        "username": "rahulbhatta",
                        "content": "Exactly. The first case is expected to be 6,makes sense if you are getting the max of only 2 inputs. But in the 84th case, they expect the muliplication of all the values in the list."
                    },
                    {
                        "username": "ThatsBig",
                        "content": "-2*(-4) = 8"
                    },
                    {
                        "username": "s_r_1000",
                        "content": "This is the definition of contiguous, a continuous subarray. So when you do:\\n\\n-2 * 3 * -4 you get 24, because the values are one after the other."
                    },
                    {
                        "username": "hp01",
                        "content": "(-2 * 3 * -4) = 24"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "product of tow negative numbers comes positive my mate"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its -2*3*-4 which is +24\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@bhardwajashish](/bhardwajashish) true its so obvious bro"
                    },
                    {
                        "username": "vipin0761",
                        "content": "no need to take \"abs\" value, -2*3*-4=24"
                    },
                    {
                        "username": "bhardwajashish",
                        "content": "bro product of 2 negative is positive, [-2,3,-4] it is a subset in itself, hence -2*3*-4 = 24\\n"
                    },
                    {
                        "username": "Yash2403",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nWho the hell added this test case ?"
                    },
                    {
                        "username": "prakhar241",
                        "content": "We can certainly devise divide and conquer for Maximum sum subarray, but while developing divide and conquer based algorithm for maximum product subarray, I found we might need to keep the maximum & absolute maximum for both parts (and crossing products), but it seems we can devise it. I was just curios why I don't see any divide and conquer based algorithm in discussions?\\n\\nIs it because since we keep the max and global max are we going towards the DP?\\n\\nAny idea will be appreciated. I just want to clarify my understanding for approach. Thanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Maximum Subarray Problem can be solved using a divide and conquer approach, which is based on the observation that a contiguous subarray\\'s maximum sum is either in the left half, right half, or crosses the middle.\\n\\nFor the Maximum Product Subarray Problem, a divide and conquer approach is a bit trickier, due to the nature of multiplication. In the case of sum, you only need to care about the largest sum; but in the case of product, you need to consider both the largest and smallest (most negative) product, because a negative number can turn the smallest product into the largest.\\n\\nWhile you could technically use a divide and conquer approach similar to the maximum sum subarray problem, the reason you don\\'t see it often in discussions or solutions is because it\\'s more complicated and doesn\\'t offer any significant advantages in terms of time complexity. The time complexity for both the divide and conquer and dynamic programming (DP) solutions is O(n), but the DP solution tends to be simpler to understand and implement.\\n\\nIn terms of your question about DP: yes, keeping track of the maximum and global maximum as you iterate through the array is a form of DP. In essence, DP is about breaking a problem down into smaller subproblems, and reusing solutions to those subproblems to build up the solution to the overall problem. In this case, the subproblems are finding the maximum product subarray ending at each position in the array, and you\\'re reusing those solutions to find the maximum product subarray over the entire array."
                    },
                    {
                        "username": "shiv_commit",
                        "content": "we can also \\napply, extension of kadance algo"
                    },
                    {
                        "username": "andrewtgg",
                        "content": "Why is expected output 2? how do you get that value?"
                    },
                    {
                        "username": "cthuga",
                        "content": "There is a testcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nand constraint says: The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\nWhich is clearly not true. Can someone help me understand here ?"
                    },
                    {
                        "username": "anurag_333",
                        "content": "a new test case is added which voilates the constraint.\\nCode that was AC earlier is getting overflowed\\n\\n"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "How many people initially went ahead with directly implementing Kadane\\'s algorithm only to realize that the direct implementation doesn\\'t work?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/4dbff713-aa0c-4c2d-b920-2530b32e0548_1645155457.5751603.jpeg)\\n"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "What part of no solutions in discussion did you not understand?"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@ashish7475](/ashish7475)  i got it , just to eradicate all edge cases we can traverse from both sides or in other words kedane from both sides."
                    },
                    {
                        "username": "ashish7475",
                        "content": "can you share the intuition behind this appraoch\\n"
                    },
                    {
                        "username": "aftabmk",
                        "content": "Everyone : Kadane\\'s Algorithm !\\ntestcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] : No!"
                    },
                    {
                        "username": "jwggernawt",
                        "content": "Is it considered product when there is only one operand?\\nFor example: array=[3]. "
                    },
                    {
                        "username": "fkhd",
                        "content": "Personally I don\\'t think so. But they are considering it in their usecases."
                    }
                ]
            },
            {
                "id": 1988153,
                "content": [
                    {
                        "username": "sudeeshs",
                        "content": "Hi there leetcoders,\\n\\n   I can't digest why the expected output of the testcase [-2, 3 -4] is 24? The numbers aren't contiguous!!\\n\\nAnd how do you obtain 24? |-2| * |3| * |-4| ???? Weird! Haaallppp!!!"
                    },
                    {
                        "username": "A_ADITI",
                        "content": "[@rahulbhatta](/rahulbhatta)   hey can u tell me how to check all the test cases "
                    },
                    {
                        "username": "rahulbhatta",
                        "content": "Exactly. The first case is expected to be 6,makes sense if you are getting the max of only 2 inputs. But in the 84th case, they expect the muliplication of all the values in the list."
                    },
                    {
                        "username": "ThatsBig",
                        "content": "-2*(-4) = 8"
                    },
                    {
                        "username": "s_r_1000",
                        "content": "This is the definition of contiguous, a continuous subarray. So when you do:\\n\\n-2 * 3 * -4 you get 24, because the values are one after the other."
                    },
                    {
                        "username": "hp01",
                        "content": "(-2 * 3 * -4) = 24"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "product of tow negative numbers comes positive my mate"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its -2*3*-4 which is +24\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@bhardwajashish](/bhardwajashish) true its so obvious bro"
                    },
                    {
                        "username": "vipin0761",
                        "content": "no need to take \"abs\" value, -2*3*-4=24"
                    },
                    {
                        "username": "bhardwajashish",
                        "content": "bro product of 2 negative is positive, [-2,3,-4] it is a subset in itself, hence -2*3*-4 = 24\\n"
                    },
                    {
                        "username": "Yash2403",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nWho the hell added this test case ?"
                    },
                    {
                        "username": "prakhar241",
                        "content": "We can certainly devise divide and conquer for Maximum sum subarray, but while developing divide and conquer based algorithm for maximum product subarray, I found we might need to keep the maximum & absolute maximum for both parts (and crossing products), but it seems we can devise it. I was just curios why I don't see any divide and conquer based algorithm in discussions?\\n\\nIs it because since we keep the max and global max are we going towards the DP?\\n\\nAny idea will be appreciated. I just want to clarify my understanding for approach. Thanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Maximum Subarray Problem can be solved using a divide and conquer approach, which is based on the observation that a contiguous subarray\\'s maximum sum is either in the left half, right half, or crosses the middle.\\n\\nFor the Maximum Product Subarray Problem, a divide and conquer approach is a bit trickier, due to the nature of multiplication. In the case of sum, you only need to care about the largest sum; but in the case of product, you need to consider both the largest and smallest (most negative) product, because a negative number can turn the smallest product into the largest.\\n\\nWhile you could technically use a divide and conquer approach similar to the maximum sum subarray problem, the reason you don\\'t see it often in discussions or solutions is because it\\'s more complicated and doesn\\'t offer any significant advantages in terms of time complexity. The time complexity for both the divide and conquer and dynamic programming (DP) solutions is O(n), but the DP solution tends to be simpler to understand and implement.\\n\\nIn terms of your question about DP: yes, keeping track of the maximum and global maximum as you iterate through the array is a form of DP. In essence, DP is about breaking a problem down into smaller subproblems, and reusing solutions to those subproblems to build up the solution to the overall problem. In this case, the subproblems are finding the maximum product subarray ending at each position in the array, and you\\'re reusing those solutions to find the maximum product subarray over the entire array."
                    },
                    {
                        "username": "shiv_commit",
                        "content": "we can also \\napply, extension of kadance algo"
                    },
                    {
                        "username": "andrewtgg",
                        "content": "Why is expected output 2? how do you get that value?"
                    },
                    {
                        "username": "cthuga",
                        "content": "There is a testcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nand constraint says: The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\nWhich is clearly not true. Can someone help me understand here ?"
                    },
                    {
                        "username": "anurag_333",
                        "content": "a new test case is added which voilates the constraint.\\nCode that was AC earlier is getting overflowed\\n\\n"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "How many people initially went ahead with directly implementing Kadane\\'s algorithm only to realize that the direct implementation doesn\\'t work?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/4dbff713-aa0c-4c2d-b920-2530b32e0548_1645155457.5751603.jpeg)\\n"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "What part of no solutions in discussion did you not understand?"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@ashish7475](/ashish7475)  i got it , just to eradicate all edge cases we can traverse from both sides or in other words kedane from both sides."
                    },
                    {
                        "username": "ashish7475",
                        "content": "can you share the intuition behind this appraoch\\n"
                    },
                    {
                        "username": "aftabmk",
                        "content": "Everyone : Kadane\\'s Algorithm !\\ntestcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] : No!"
                    },
                    {
                        "username": "jwggernawt",
                        "content": "Is it considered product when there is only one operand?\\nFor example: array=[3]. "
                    },
                    {
                        "username": "fkhd",
                        "content": "Personally I don\\'t think so. But they are considering it in their usecases."
                    }
                ]
            },
            {
                "id": 1576410,
                "content": [
                    {
                        "username": "sudeeshs",
                        "content": "Hi there leetcoders,\\n\\n   I can't digest why the expected output of the testcase [-2, 3 -4] is 24? The numbers aren't contiguous!!\\n\\nAnd how do you obtain 24? |-2| * |3| * |-4| ???? Weird! Haaallppp!!!"
                    },
                    {
                        "username": "A_ADITI",
                        "content": "[@rahulbhatta](/rahulbhatta)   hey can u tell me how to check all the test cases "
                    },
                    {
                        "username": "rahulbhatta",
                        "content": "Exactly. The first case is expected to be 6,makes sense if you are getting the max of only 2 inputs. But in the 84th case, they expect the muliplication of all the values in the list."
                    },
                    {
                        "username": "ThatsBig",
                        "content": "-2*(-4) = 8"
                    },
                    {
                        "username": "s_r_1000",
                        "content": "This is the definition of contiguous, a continuous subarray. So when you do:\\n\\n-2 * 3 * -4 you get 24, because the values are one after the other."
                    },
                    {
                        "username": "hp01",
                        "content": "(-2 * 3 * -4) = 24"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "product of tow negative numbers comes positive my mate"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its -2*3*-4 which is +24\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@bhardwajashish](/bhardwajashish) true its so obvious bro"
                    },
                    {
                        "username": "vipin0761",
                        "content": "no need to take \"abs\" value, -2*3*-4=24"
                    },
                    {
                        "username": "bhardwajashish",
                        "content": "bro product of 2 negative is positive, [-2,3,-4] it is a subset in itself, hence -2*3*-4 = 24\\n"
                    },
                    {
                        "username": "Yash2403",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nWho the hell added this test case ?"
                    },
                    {
                        "username": "prakhar241",
                        "content": "We can certainly devise divide and conquer for Maximum sum subarray, but while developing divide and conquer based algorithm for maximum product subarray, I found we might need to keep the maximum & absolute maximum for both parts (and crossing products), but it seems we can devise it. I was just curios why I don't see any divide and conquer based algorithm in discussions?\\n\\nIs it because since we keep the max and global max are we going towards the DP?\\n\\nAny idea will be appreciated. I just want to clarify my understanding for approach. Thanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Maximum Subarray Problem can be solved using a divide and conquer approach, which is based on the observation that a contiguous subarray\\'s maximum sum is either in the left half, right half, or crosses the middle.\\n\\nFor the Maximum Product Subarray Problem, a divide and conquer approach is a bit trickier, due to the nature of multiplication. In the case of sum, you only need to care about the largest sum; but in the case of product, you need to consider both the largest and smallest (most negative) product, because a negative number can turn the smallest product into the largest.\\n\\nWhile you could technically use a divide and conquer approach similar to the maximum sum subarray problem, the reason you don\\'t see it often in discussions or solutions is because it\\'s more complicated and doesn\\'t offer any significant advantages in terms of time complexity. The time complexity for both the divide and conquer and dynamic programming (DP) solutions is O(n), but the DP solution tends to be simpler to understand and implement.\\n\\nIn terms of your question about DP: yes, keeping track of the maximum and global maximum as you iterate through the array is a form of DP. In essence, DP is about breaking a problem down into smaller subproblems, and reusing solutions to those subproblems to build up the solution to the overall problem. In this case, the subproblems are finding the maximum product subarray ending at each position in the array, and you\\'re reusing those solutions to find the maximum product subarray over the entire array."
                    },
                    {
                        "username": "shiv_commit",
                        "content": "we can also \\napply, extension of kadance algo"
                    },
                    {
                        "username": "andrewtgg",
                        "content": "Why is expected output 2? how do you get that value?"
                    },
                    {
                        "username": "cthuga",
                        "content": "There is a testcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nand constraint says: The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\nWhich is clearly not true. Can someone help me understand here ?"
                    },
                    {
                        "username": "anurag_333",
                        "content": "a new test case is added which voilates the constraint.\\nCode that was AC earlier is getting overflowed\\n\\n"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "How many people initially went ahead with directly implementing Kadane\\'s algorithm only to realize that the direct implementation doesn\\'t work?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/4dbff713-aa0c-4c2d-b920-2530b32e0548_1645155457.5751603.jpeg)\\n"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "What part of no solutions in discussion did you not understand?"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@ashish7475](/ashish7475)  i got it , just to eradicate all edge cases we can traverse from both sides or in other words kedane from both sides."
                    },
                    {
                        "username": "ashish7475",
                        "content": "can you share the intuition behind this appraoch\\n"
                    },
                    {
                        "username": "aftabmk",
                        "content": "Everyone : Kadane\\'s Algorithm !\\ntestcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] : No!"
                    },
                    {
                        "username": "jwggernawt",
                        "content": "Is it considered product when there is only one operand?\\nFor example: array=[3]. "
                    },
                    {
                        "username": "fkhd",
                        "content": "Personally I don\\'t think so. But they are considering it in their usecases."
                    }
                ]
            },
            {
                "id": 2058704,
                "content": [
                    {
                        "username": "sudeeshs",
                        "content": "Hi there leetcoders,\\n\\n   I can't digest why the expected output of the testcase [-2, 3 -4] is 24? The numbers aren't contiguous!!\\n\\nAnd how do you obtain 24? |-2| * |3| * |-4| ???? Weird! Haaallppp!!!"
                    },
                    {
                        "username": "A_ADITI",
                        "content": "[@rahulbhatta](/rahulbhatta)   hey can u tell me how to check all the test cases "
                    },
                    {
                        "username": "rahulbhatta",
                        "content": "Exactly. The first case is expected to be 6,makes sense if you are getting the max of only 2 inputs. But in the 84th case, they expect the muliplication of all the values in the list."
                    },
                    {
                        "username": "ThatsBig",
                        "content": "-2*(-4) = 8"
                    },
                    {
                        "username": "s_r_1000",
                        "content": "This is the definition of contiguous, a continuous subarray. So when you do:\\n\\n-2 * 3 * -4 you get 24, because the values are one after the other."
                    },
                    {
                        "username": "hp01",
                        "content": "(-2 * 3 * -4) = 24"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "product of tow negative numbers comes positive my mate"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its -2*3*-4 which is +24\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@bhardwajashish](/bhardwajashish) true its so obvious bro"
                    },
                    {
                        "username": "vipin0761",
                        "content": "no need to take \"abs\" value, -2*3*-4=24"
                    },
                    {
                        "username": "bhardwajashish",
                        "content": "bro product of 2 negative is positive, [-2,3,-4] it is a subset in itself, hence -2*3*-4 = 24\\n"
                    },
                    {
                        "username": "Yash2403",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nWho the hell added this test case ?"
                    },
                    {
                        "username": "prakhar241",
                        "content": "We can certainly devise divide and conquer for Maximum sum subarray, but while developing divide and conquer based algorithm for maximum product subarray, I found we might need to keep the maximum & absolute maximum for both parts (and crossing products), but it seems we can devise it. I was just curios why I don't see any divide and conquer based algorithm in discussions?\\n\\nIs it because since we keep the max and global max are we going towards the DP?\\n\\nAny idea will be appreciated. I just want to clarify my understanding for approach. Thanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Maximum Subarray Problem can be solved using a divide and conquer approach, which is based on the observation that a contiguous subarray\\'s maximum sum is either in the left half, right half, or crosses the middle.\\n\\nFor the Maximum Product Subarray Problem, a divide and conquer approach is a bit trickier, due to the nature of multiplication. In the case of sum, you only need to care about the largest sum; but in the case of product, you need to consider both the largest and smallest (most negative) product, because a negative number can turn the smallest product into the largest.\\n\\nWhile you could technically use a divide and conquer approach similar to the maximum sum subarray problem, the reason you don\\'t see it often in discussions or solutions is because it\\'s more complicated and doesn\\'t offer any significant advantages in terms of time complexity. The time complexity for both the divide and conquer and dynamic programming (DP) solutions is O(n), but the DP solution tends to be simpler to understand and implement.\\n\\nIn terms of your question about DP: yes, keeping track of the maximum and global maximum as you iterate through the array is a form of DP. In essence, DP is about breaking a problem down into smaller subproblems, and reusing solutions to those subproblems to build up the solution to the overall problem. In this case, the subproblems are finding the maximum product subarray ending at each position in the array, and you\\'re reusing those solutions to find the maximum product subarray over the entire array."
                    },
                    {
                        "username": "shiv_commit",
                        "content": "we can also \\napply, extension of kadance algo"
                    },
                    {
                        "username": "andrewtgg",
                        "content": "Why is expected output 2? how do you get that value?"
                    },
                    {
                        "username": "cthuga",
                        "content": "There is a testcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nand constraint says: The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\nWhich is clearly not true. Can someone help me understand here ?"
                    },
                    {
                        "username": "anurag_333",
                        "content": "a new test case is added which voilates the constraint.\\nCode that was AC earlier is getting overflowed\\n\\n"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "How many people initially went ahead with directly implementing Kadane\\'s algorithm only to realize that the direct implementation doesn\\'t work?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/4dbff713-aa0c-4c2d-b920-2530b32e0548_1645155457.5751603.jpeg)\\n"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "What part of no solutions in discussion did you not understand?"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@ashish7475](/ashish7475)  i got it , just to eradicate all edge cases we can traverse from both sides or in other words kedane from both sides."
                    },
                    {
                        "username": "ashish7475",
                        "content": "can you share the intuition behind this appraoch\\n"
                    },
                    {
                        "username": "aftabmk",
                        "content": "Everyone : Kadane\\'s Algorithm !\\ntestcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] : No!"
                    },
                    {
                        "username": "jwggernawt",
                        "content": "Is it considered product when there is only one operand?\\nFor example: array=[3]. "
                    },
                    {
                        "username": "fkhd",
                        "content": "Personally I don\\'t think so. But they are considering it in their usecases."
                    }
                ]
            },
            {
                "id": 1810599,
                "content": [
                    {
                        "username": "sudeeshs",
                        "content": "Hi there leetcoders,\\n\\n   I can't digest why the expected output of the testcase [-2, 3 -4] is 24? The numbers aren't contiguous!!\\n\\nAnd how do you obtain 24? |-2| * |3| * |-4| ???? Weird! Haaallppp!!!"
                    },
                    {
                        "username": "A_ADITI",
                        "content": "[@rahulbhatta](/rahulbhatta)   hey can u tell me how to check all the test cases "
                    },
                    {
                        "username": "rahulbhatta",
                        "content": "Exactly. The first case is expected to be 6,makes sense if you are getting the max of only 2 inputs. But in the 84th case, they expect the muliplication of all the values in the list."
                    },
                    {
                        "username": "ThatsBig",
                        "content": "-2*(-4) = 8"
                    },
                    {
                        "username": "s_r_1000",
                        "content": "This is the definition of contiguous, a continuous subarray. So when you do:\\n\\n-2 * 3 * -4 you get 24, because the values are one after the other."
                    },
                    {
                        "username": "hp01",
                        "content": "(-2 * 3 * -4) = 24"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "product of tow negative numbers comes positive my mate"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its -2*3*-4 which is +24\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@bhardwajashish](/bhardwajashish) true its so obvious bro"
                    },
                    {
                        "username": "vipin0761",
                        "content": "no need to take \"abs\" value, -2*3*-4=24"
                    },
                    {
                        "username": "bhardwajashish",
                        "content": "bro product of 2 negative is positive, [-2,3,-4] it is a subset in itself, hence -2*3*-4 = 24\\n"
                    },
                    {
                        "username": "Yash2403",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nWho the hell added this test case ?"
                    },
                    {
                        "username": "prakhar241",
                        "content": "We can certainly devise divide and conquer for Maximum sum subarray, but while developing divide and conquer based algorithm for maximum product subarray, I found we might need to keep the maximum & absolute maximum for both parts (and crossing products), but it seems we can devise it. I was just curios why I don't see any divide and conquer based algorithm in discussions?\\n\\nIs it because since we keep the max and global max are we going towards the DP?\\n\\nAny idea will be appreciated. I just want to clarify my understanding for approach. Thanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Maximum Subarray Problem can be solved using a divide and conquer approach, which is based on the observation that a contiguous subarray\\'s maximum sum is either in the left half, right half, or crosses the middle.\\n\\nFor the Maximum Product Subarray Problem, a divide and conquer approach is a bit trickier, due to the nature of multiplication. In the case of sum, you only need to care about the largest sum; but in the case of product, you need to consider both the largest and smallest (most negative) product, because a negative number can turn the smallest product into the largest.\\n\\nWhile you could technically use a divide and conquer approach similar to the maximum sum subarray problem, the reason you don\\'t see it often in discussions or solutions is because it\\'s more complicated and doesn\\'t offer any significant advantages in terms of time complexity. The time complexity for both the divide and conquer and dynamic programming (DP) solutions is O(n), but the DP solution tends to be simpler to understand and implement.\\n\\nIn terms of your question about DP: yes, keeping track of the maximum and global maximum as you iterate through the array is a form of DP. In essence, DP is about breaking a problem down into smaller subproblems, and reusing solutions to those subproblems to build up the solution to the overall problem. In this case, the subproblems are finding the maximum product subarray ending at each position in the array, and you\\'re reusing those solutions to find the maximum product subarray over the entire array."
                    },
                    {
                        "username": "shiv_commit",
                        "content": "we can also \\napply, extension of kadance algo"
                    },
                    {
                        "username": "andrewtgg",
                        "content": "Why is expected output 2? how do you get that value?"
                    },
                    {
                        "username": "cthuga",
                        "content": "There is a testcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nand constraint says: The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\nWhich is clearly not true. Can someone help me understand here ?"
                    },
                    {
                        "username": "anurag_333",
                        "content": "a new test case is added which voilates the constraint.\\nCode that was AC earlier is getting overflowed\\n\\n"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "How many people initially went ahead with directly implementing Kadane\\'s algorithm only to realize that the direct implementation doesn\\'t work?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/4dbff713-aa0c-4c2d-b920-2530b32e0548_1645155457.5751603.jpeg)\\n"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "What part of no solutions in discussion did you not understand?"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@ashish7475](/ashish7475)  i got it , just to eradicate all edge cases we can traverse from both sides or in other words kedane from both sides."
                    },
                    {
                        "username": "ashish7475",
                        "content": "can you share the intuition behind this appraoch\\n"
                    },
                    {
                        "username": "aftabmk",
                        "content": "Everyone : Kadane\\'s Algorithm !\\ntestcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] : No!"
                    },
                    {
                        "username": "jwggernawt",
                        "content": "Is it considered product when there is only one operand?\\nFor example: array=[3]. "
                    },
                    {
                        "username": "fkhd",
                        "content": "Personally I don\\'t think so. But they are considering it in their usecases."
                    }
                ]
            },
            {
                "id": 1748589,
                "content": [
                    {
                        "username": "vik24k",
                        "content": "nums =\\n[0,2]\\n\\nOutput\\n0\\n\\nExpected\\n2\\n\\nhow?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks for the maximum product subarray, and in this case, the maximum product is 2. A subarray can be any contiguous part of the original array. In this case, the subarray [2] has the highest product. The subarray [0] has a product of 0, and the entire array [0,2] also has a product of 0 (since any number multiplied by 0 equals 0), so both of those options would be smaller than the product of the subarray [2]. \\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "[@Crispy_coffee](/Crispy_coffee) Being a subarray is not equal to the product of subarray elements. \\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "this should be wrong, as the statement clearly says that the largest product has to be returned. A  product requires at least two factorials, so the subarray length needs to be >= 2"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "because 2 is also a subarray and 2>0 , this is why the answer is 2."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I maintain the prefix and suffix product of the array. If at any time the prefix or suffix product is equal to 0, then I update it to 1. I update the current answer as the maximum of the prefix or suffix product. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHere is how I maintain the prefix and suffix product:\\n1. Initialize the prefix product to 1 and the suffix product to 1.\\n2. Iterate over the array.\\n3. In each iteration, multiply the prefix product by the current element.\\n4. Multiply the suffix product by the element at the end of the array, which is nums[n - i - 1].\\n6. If the prefix or suffix product is equal to 0, then I update it to 1. (The reason why I update the prefix or suffix product to 1 if it is equal to 0 is because I want to ensure that the product is never 0. If the product is 0, then the maximum product subarray will be 0.)\\n7. I update the current answer as the maximum of the prefix or suffix product.\\n8. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHOPE IT HELPS !\\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "Any product involves atleast two numbers. Even if it is a subarray there should me no possible product for the single element.  For the usecase : [0,2]. The output they are expecting is 2.  It must be 0.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The term \"product\" in mathematics generally refers to the result of multiplying two or more numbers together. However, in the context of this problem, when considering a subarray of just one element, the \"product\" of the subarray is simply the number itself. \\n\\nThis convention allows us to handle cases where the input array contains just one element, or the maximum product is achieved with a single-element subarray. In this sense, a product of a single number can be considered as that number \"multiplied by 1\". \\n\\nSo, for the array [0,2], the maximum product subarray is [2], and thus the maximum product is 2. \\n\\nThis may seem a little counter-intuitive based on the traditional definition of \"product\", but it\\'s a useful abstraction for the purposes of solving this type of problem."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "Python solution:\\n\\ndef maxProduct(self, nums: List[int]) -> int:\\n        maxProduct = nums[0]\\n        minProduct = nums[0]\\n        result = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] < 0:\\n                maxProduct, minProduct = minProduct , maxProduct \\n            maxProduct = max(nums[i], maxProduct * nums[i])\\n            minProduct = min(nums[i], minProduct * nums[i])\\n            result = max(result, maxProduct)\\n        return result \\n\\n        #time O(N)  n is the lenght of the input array \\n        #space O(1) using constant spance"
                    },
                    {
                        "username": "alexTheCoder",
                        "content": "From the known cases, the sequence of 2 , -3 , 1 , 2 , 3 , -2 is considered contiguous, so is -1, 1, it seems to me that zero is omitted, and duplicates are allowed, so, what is the requirement?"
                    },
                    {
                        "username": "ZonaZZZ",
                        "content": "Shouldn't it be -1? There is no contiguous number in this array except for itself."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a subarray can consist of a single number. So if the array only has one number, then that number itself is considered a subarray. Therefore, if you have an array [3] (with just one number 3), then the maximum product subarray is 3, which is the number itself.\\n\\nSimilarly, for an array [-1], the maximum product subarray is -1, because -1 is the only element and thus the only subarray.\\n\\nThis is a valid interpretation because in mathematics, the product of a single number is the number itself. In this problem, we\\'re looking for the maximum product of numbers in a subarray, so a single number counts as its own product. \\n\\nThe statement \"find the contiguous subarray within an array (containing at least one number) that has the largest product\" allows for this interpretation because it specifies \"at least one number,\" meaning a single number can constitute a subarray."
                    },
                    {
                        "username": "onesong2021",
                        "content": "If we have a non-zero array, that has the max product in the middle which doesn\\'t contains start and end number, then sliding window will not work.\\nBut, because the input is an integer array, the max product will not appear in the middle, it must at least contains one of start and end.\\n\\nLet\\'s assume, we have a non-zero integer array, which has the max product(P) in the middle.\\nThen this P will surround by two non-zero integers(a, b).\\nwhen a >= 1 && b >= 1 (P must > a , b > 0),  P <= P * a * b\\nwhen a >= 1 && b <= -1 (P must > a , b > 0), P <= P * a\\nwhen a <=-1 && b >= 1 (P must > a , b > 0), P <= P * b\\nwhen a <= -1 && b <= -1:\\n\\twhen P > 0, P <= P * a * b\\n\\twhen P < 0, P < P * a / P * b\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "[-2,0,1,-2] contradicts your assumption (max product is 1, doesn\\'t include the first nor the last - the 0 there nullifies the product of extremes)"
                    },
                    {
                        "username": "revenant7",
                        "content": "A good example which shows understanding the question clearly is important before coding. I thought of product as multiplication of two numbers (a * b), which means [2] gives result as 0. But this problem answers 2 for input [2] which made my code to fail for some test-cases."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for O(n) time solution with constant space in C++/Java/Python\\nhttps://www.techiedelight.com/find-maximum-product-subarray-given-array/"
                    },
                    {
                        "username": "Manashi",
                        "content": "Some wrong solutions pass, as my own solution is wrong."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha... Funny "
                    }
                ]
            },
            {
                "id": 1974202,
                "content": [
                    {
                        "username": "vik24k",
                        "content": "nums =\\n[0,2]\\n\\nOutput\\n0\\n\\nExpected\\n2\\n\\nhow?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks for the maximum product subarray, and in this case, the maximum product is 2. A subarray can be any contiguous part of the original array. In this case, the subarray [2] has the highest product. The subarray [0] has a product of 0, and the entire array [0,2] also has a product of 0 (since any number multiplied by 0 equals 0), so both of those options would be smaller than the product of the subarray [2]. \\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "[@Crispy_coffee](/Crispy_coffee) Being a subarray is not equal to the product of subarray elements. \\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "this should be wrong, as the statement clearly says that the largest product has to be returned. A  product requires at least two factorials, so the subarray length needs to be >= 2"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "because 2 is also a subarray and 2>0 , this is why the answer is 2."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I maintain the prefix and suffix product of the array. If at any time the prefix or suffix product is equal to 0, then I update it to 1. I update the current answer as the maximum of the prefix or suffix product. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHere is how I maintain the prefix and suffix product:\\n1. Initialize the prefix product to 1 and the suffix product to 1.\\n2. Iterate over the array.\\n3. In each iteration, multiply the prefix product by the current element.\\n4. Multiply the suffix product by the element at the end of the array, which is nums[n - i - 1].\\n6. If the prefix or suffix product is equal to 0, then I update it to 1. (The reason why I update the prefix or suffix product to 1 if it is equal to 0 is because I want to ensure that the product is never 0. If the product is 0, then the maximum product subarray will be 0.)\\n7. I update the current answer as the maximum of the prefix or suffix product.\\n8. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHOPE IT HELPS !\\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "Any product involves atleast two numbers. Even if it is a subarray there should me no possible product for the single element.  For the usecase : [0,2]. The output they are expecting is 2.  It must be 0.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The term \"product\" in mathematics generally refers to the result of multiplying two or more numbers together. However, in the context of this problem, when considering a subarray of just one element, the \"product\" of the subarray is simply the number itself. \\n\\nThis convention allows us to handle cases where the input array contains just one element, or the maximum product is achieved with a single-element subarray. In this sense, a product of a single number can be considered as that number \"multiplied by 1\". \\n\\nSo, for the array [0,2], the maximum product subarray is [2], and thus the maximum product is 2. \\n\\nThis may seem a little counter-intuitive based on the traditional definition of \"product\", but it\\'s a useful abstraction for the purposes of solving this type of problem."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "Python solution:\\n\\ndef maxProduct(self, nums: List[int]) -> int:\\n        maxProduct = nums[0]\\n        minProduct = nums[0]\\n        result = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] < 0:\\n                maxProduct, minProduct = minProduct , maxProduct \\n            maxProduct = max(nums[i], maxProduct * nums[i])\\n            minProduct = min(nums[i], minProduct * nums[i])\\n            result = max(result, maxProduct)\\n        return result \\n\\n        #time O(N)  n is the lenght of the input array \\n        #space O(1) using constant spance"
                    },
                    {
                        "username": "alexTheCoder",
                        "content": "From the known cases, the sequence of 2 , -3 , 1 , 2 , 3 , -2 is considered contiguous, so is -1, 1, it seems to me that zero is omitted, and duplicates are allowed, so, what is the requirement?"
                    },
                    {
                        "username": "ZonaZZZ",
                        "content": "Shouldn't it be -1? There is no contiguous number in this array except for itself."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a subarray can consist of a single number. So if the array only has one number, then that number itself is considered a subarray. Therefore, if you have an array [3] (with just one number 3), then the maximum product subarray is 3, which is the number itself.\\n\\nSimilarly, for an array [-1], the maximum product subarray is -1, because -1 is the only element and thus the only subarray.\\n\\nThis is a valid interpretation because in mathematics, the product of a single number is the number itself. In this problem, we\\'re looking for the maximum product of numbers in a subarray, so a single number counts as its own product. \\n\\nThe statement \"find the contiguous subarray within an array (containing at least one number) that has the largest product\" allows for this interpretation because it specifies \"at least one number,\" meaning a single number can constitute a subarray."
                    },
                    {
                        "username": "onesong2021",
                        "content": "If we have a non-zero array, that has the max product in the middle which doesn\\'t contains start and end number, then sliding window will not work.\\nBut, because the input is an integer array, the max product will not appear in the middle, it must at least contains one of start and end.\\n\\nLet\\'s assume, we have a non-zero integer array, which has the max product(P) in the middle.\\nThen this P will surround by two non-zero integers(a, b).\\nwhen a >= 1 && b >= 1 (P must > a , b > 0),  P <= P * a * b\\nwhen a >= 1 && b <= -1 (P must > a , b > 0), P <= P * a\\nwhen a <=-1 && b >= 1 (P must > a , b > 0), P <= P * b\\nwhen a <= -1 && b <= -1:\\n\\twhen P > 0, P <= P * a * b\\n\\twhen P < 0, P < P * a / P * b\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "[-2,0,1,-2] contradicts your assumption (max product is 1, doesn\\'t include the first nor the last - the 0 there nullifies the product of extremes)"
                    },
                    {
                        "username": "revenant7",
                        "content": "A good example which shows understanding the question clearly is important before coding. I thought of product as multiplication of two numbers (a * b), which means [2] gives result as 0. But this problem answers 2 for input [2] which made my code to fail for some test-cases."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for O(n) time solution with constant space in C++/Java/Python\\nhttps://www.techiedelight.com/find-maximum-product-subarray-given-array/"
                    },
                    {
                        "username": "Manashi",
                        "content": "Some wrong solutions pass, as my own solution is wrong."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha... Funny "
                    }
                ]
            },
            {
                "id": 1847212,
                "content": [
                    {
                        "username": "vik24k",
                        "content": "nums =\\n[0,2]\\n\\nOutput\\n0\\n\\nExpected\\n2\\n\\nhow?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks for the maximum product subarray, and in this case, the maximum product is 2. A subarray can be any contiguous part of the original array. In this case, the subarray [2] has the highest product. The subarray [0] has a product of 0, and the entire array [0,2] also has a product of 0 (since any number multiplied by 0 equals 0), so both of those options would be smaller than the product of the subarray [2]. \\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "[@Crispy_coffee](/Crispy_coffee) Being a subarray is not equal to the product of subarray elements. \\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "this should be wrong, as the statement clearly says that the largest product has to be returned. A  product requires at least two factorials, so the subarray length needs to be >= 2"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "because 2 is also a subarray and 2>0 , this is why the answer is 2."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I maintain the prefix and suffix product of the array. If at any time the prefix or suffix product is equal to 0, then I update it to 1. I update the current answer as the maximum of the prefix or suffix product. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHere is how I maintain the prefix and suffix product:\\n1. Initialize the prefix product to 1 and the suffix product to 1.\\n2. Iterate over the array.\\n3. In each iteration, multiply the prefix product by the current element.\\n4. Multiply the suffix product by the element at the end of the array, which is nums[n - i - 1].\\n6. If the prefix or suffix product is equal to 0, then I update it to 1. (The reason why I update the prefix or suffix product to 1 if it is equal to 0 is because I want to ensure that the product is never 0. If the product is 0, then the maximum product subarray will be 0.)\\n7. I update the current answer as the maximum of the prefix or suffix product.\\n8. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHOPE IT HELPS !\\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "Any product involves atleast two numbers. Even if it is a subarray there should me no possible product for the single element.  For the usecase : [0,2]. The output they are expecting is 2.  It must be 0.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The term \"product\" in mathematics generally refers to the result of multiplying two or more numbers together. However, in the context of this problem, when considering a subarray of just one element, the \"product\" of the subarray is simply the number itself. \\n\\nThis convention allows us to handle cases where the input array contains just one element, or the maximum product is achieved with a single-element subarray. In this sense, a product of a single number can be considered as that number \"multiplied by 1\". \\n\\nSo, for the array [0,2], the maximum product subarray is [2], and thus the maximum product is 2. \\n\\nThis may seem a little counter-intuitive based on the traditional definition of \"product\", but it\\'s a useful abstraction for the purposes of solving this type of problem."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "Python solution:\\n\\ndef maxProduct(self, nums: List[int]) -> int:\\n        maxProduct = nums[0]\\n        minProduct = nums[0]\\n        result = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] < 0:\\n                maxProduct, minProduct = minProduct , maxProduct \\n            maxProduct = max(nums[i], maxProduct * nums[i])\\n            minProduct = min(nums[i], minProduct * nums[i])\\n            result = max(result, maxProduct)\\n        return result \\n\\n        #time O(N)  n is the lenght of the input array \\n        #space O(1) using constant spance"
                    },
                    {
                        "username": "alexTheCoder",
                        "content": "From the known cases, the sequence of 2 , -3 , 1 , 2 , 3 , -2 is considered contiguous, so is -1, 1, it seems to me that zero is omitted, and duplicates are allowed, so, what is the requirement?"
                    },
                    {
                        "username": "ZonaZZZ",
                        "content": "Shouldn't it be -1? There is no contiguous number in this array except for itself."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a subarray can consist of a single number. So if the array only has one number, then that number itself is considered a subarray. Therefore, if you have an array [3] (with just one number 3), then the maximum product subarray is 3, which is the number itself.\\n\\nSimilarly, for an array [-1], the maximum product subarray is -1, because -1 is the only element and thus the only subarray.\\n\\nThis is a valid interpretation because in mathematics, the product of a single number is the number itself. In this problem, we\\'re looking for the maximum product of numbers in a subarray, so a single number counts as its own product. \\n\\nThe statement \"find the contiguous subarray within an array (containing at least one number) that has the largest product\" allows for this interpretation because it specifies \"at least one number,\" meaning a single number can constitute a subarray."
                    },
                    {
                        "username": "onesong2021",
                        "content": "If we have a non-zero array, that has the max product in the middle which doesn\\'t contains start and end number, then sliding window will not work.\\nBut, because the input is an integer array, the max product will not appear in the middle, it must at least contains one of start and end.\\n\\nLet\\'s assume, we have a non-zero integer array, which has the max product(P) in the middle.\\nThen this P will surround by two non-zero integers(a, b).\\nwhen a >= 1 && b >= 1 (P must > a , b > 0),  P <= P * a * b\\nwhen a >= 1 && b <= -1 (P must > a , b > 0), P <= P * a\\nwhen a <=-1 && b >= 1 (P must > a , b > 0), P <= P * b\\nwhen a <= -1 && b <= -1:\\n\\twhen P > 0, P <= P * a * b\\n\\twhen P < 0, P < P * a / P * b\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "[-2,0,1,-2] contradicts your assumption (max product is 1, doesn\\'t include the first nor the last - the 0 there nullifies the product of extremes)"
                    },
                    {
                        "username": "revenant7",
                        "content": "A good example which shows understanding the question clearly is important before coding. I thought of product as multiplication of two numbers (a * b), which means [2] gives result as 0. But this problem answers 2 for input [2] which made my code to fail for some test-cases."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for O(n) time solution with constant space in C++/Java/Python\\nhttps://www.techiedelight.com/find-maximum-product-subarray-given-array/"
                    },
                    {
                        "username": "Manashi",
                        "content": "Some wrong solutions pass, as my own solution is wrong."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha... Funny "
                    }
                ]
            },
            {
                "id": 1794899,
                "content": [
                    {
                        "username": "vik24k",
                        "content": "nums =\\n[0,2]\\n\\nOutput\\n0\\n\\nExpected\\n2\\n\\nhow?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks for the maximum product subarray, and in this case, the maximum product is 2. A subarray can be any contiguous part of the original array. In this case, the subarray [2] has the highest product. The subarray [0] has a product of 0, and the entire array [0,2] also has a product of 0 (since any number multiplied by 0 equals 0), so both of those options would be smaller than the product of the subarray [2]. \\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "[@Crispy_coffee](/Crispy_coffee) Being a subarray is not equal to the product of subarray elements. \\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "this should be wrong, as the statement clearly says that the largest product has to be returned. A  product requires at least two factorials, so the subarray length needs to be >= 2"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "because 2 is also a subarray and 2>0 , this is why the answer is 2."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I maintain the prefix and suffix product of the array. If at any time the prefix or suffix product is equal to 0, then I update it to 1. I update the current answer as the maximum of the prefix or suffix product. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHere is how I maintain the prefix and suffix product:\\n1. Initialize the prefix product to 1 and the suffix product to 1.\\n2. Iterate over the array.\\n3. In each iteration, multiply the prefix product by the current element.\\n4. Multiply the suffix product by the element at the end of the array, which is nums[n - i - 1].\\n6. If the prefix or suffix product is equal to 0, then I update it to 1. (The reason why I update the prefix or suffix product to 1 if it is equal to 0 is because I want to ensure that the product is never 0. If the product is 0, then the maximum product subarray will be 0.)\\n7. I update the current answer as the maximum of the prefix or suffix product.\\n8. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHOPE IT HELPS !\\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "Any product involves atleast two numbers. Even if it is a subarray there should me no possible product for the single element.  For the usecase : [0,2]. The output they are expecting is 2.  It must be 0.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The term \"product\" in mathematics generally refers to the result of multiplying two or more numbers together. However, in the context of this problem, when considering a subarray of just one element, the \"product\" of the subarray is simply the number itself. \\n\\nThis convention allows us to handle cases where the input array contains just one element, or the maximum product is achieved with a single-element subarray. In this sense, a product of a single number can be considered as that number \"multiplied by 1\". \\n\\nSo, for the array [0,2], the maximum product subarray is [2], and thus the maximum product is 2. \\n\\nThis may seem a little counter-intuitive based on the traditional definition of \"product\", but it\\'s a useful abstraction for the purposes of solving this type of problem."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "Python solution:\\n\\ndef maxProduct(self, nums: List[int]) -> int:\\n        maxProduct = nums[0]\\n        minProduct = nums[0]\\n        result = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] < 0:\\n                maxProduct, minProduct = minProduct , maxProduct \\n            maxProduct = max(nums[i], maxProduct * nums[i])\\n            minProduct = min(nums[i], minProduct * nums[i])\\n            result = max(result, maxProduct)\\n        return result \\n\\n        #time O(N)  n is the lenght of the input array \\n        #space O(1) using constant spance"
                    },
                    {
                        "username": "alexTheCoder",
                        "content": "From the known cases, the sequence of 2 , -3 , 1 , 2 , 3 , -2 is considered contiguous, so is -1, 1, it seems to me that zero is omitted, and duplicates are allowed, so, what is the requirement?"
                    },
                    {
                        "username": "ZonaZZZ",
                        "content": "Shouldn't it be -1? There is no contiguous number in this array except for itself."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a subarray can consist of a single number. So if the array only has one number, then that number itself is considered a subarray. Therefore, if you have an array [3] (with just one number 3), then the maximum product subarray is 3, which is the number itself.\\n\\nSimilarly, for an array [-1], the maximum product subarray is -1, because -1 is the only element and thus the only subarray.\\n\\nThis is a valid interpretation because in mathematics, the product of a single number is the number itself. In this problem, we\\'re looking for the maximum product of numbers in a subarray, so a single number counts as its own product. \\n\\nThe statement \"find the contiguous subarray within an array (containing at least one number) that has the largest product\" allows for this interpretation because it specifies \"at least one number,\" meaning a single number can constitute a subarray."
                    },
                    {
                        "username": "onesong2021",
                        "content": "If we have a non-zero array, that has the max product in the middle which doesn\\'t contains start and end number, then sliding window will not work.\\nBut, because the input is an integer array, the max product will not appear in the middle, it must at least contains one of start and end.\\n\\nLet\\'s assume, we have a non-zero integer array, which has the max product(P) in the middle.\\nThen this P will surround by two non-zero integers(a, b).\\nwhen a >= 1 && b >= 1 (P must > a , b > 0),  P <= P * a * b\\nwhen a >= 1 && b <= -1 (P must > a , b > 0), P <= P * a\\nwhen a <=-1 && b >= 1 (P must > a , b > 0), P <= P * b\\nwhen a <= -1 && b <= -1:\\n\\twhen P > 0, P <= P * a * b\\n\\twhen P < 0, P < P * a / P * b\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "[-2,0,1,-2] contradicts your assumption (max product is 1, doesn\\'t include the first nor the last - the 0 there nullifies the product of extremes)"
                    },
                    {
                        "username": "revenant7",
                        "content": "A good example which shows understanding the question clearly is important before coding. I thought of product as multiplication of two numbers (a * b), which means [2] gives result as 0. But this problem answers 2 for input [2] which made my code to fail for some test-cases."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for O(n) time solution with constant space in C++/Java/Python\\nhttps://www.techiedelight.com/find-maximum-product-subarray-given-array/"
                    },
                    {
                        "username": "Manashi",
                        "content": "Some wrong solutions pass, as my own solution is wrong."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha... Funny "
                    }
                ]
            },
            {
                "id": 1571344,
                "content": [
                    {
                        "username": "vik24k",
                        "content": "nums =\\n[0,2]\\n\\nOutput\\n0\\n\\nExpected\\n2\\n\\nhow?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks for the maximum product subarray, and in this case, the maximum product is 2. A subarray can be any contiguous part of the original array. In this case, the subarray [2] has the highest product. The subarray [0] has a product of 0, and the entire array [0,2] also has a product of 0 (since any number multiplied by 0 equals 0), so both of those options would be smaller than the product of the subarray [2]. \\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "[@Crispy_coffee](/Crispy_coffee) Being a subarray is not equal to the product of subarray elements. \\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "this should be wrong, as the statement clearly says that the largest product has to be returned. A  product requires at least two factorials, so the subarray length needs to be >= 2"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "because 2 is also a subarray and 2>0 , this is why the answer is 2."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I maintain the prefix and suffix product of the array. If at any time the prefix or suffix product is equal to 0, then I update it to 1. I update the current answer as the maximum of the prefix or suffix product. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHere is how I maintain the prefix and suffix product:\\n1. Initialize the prefix product to 1 and the suffix product to 1.\\n2. Iterate over the array.\\n3. In each iteration, multiply the prefix product by the current element.\\n4. Multiply the suffix product by the element at the end of the array, which is nums[n - i - 1].\\n6. If the prefix or suffix product is equal to 0, then I update it to 1. (The reason why I update the prefix or suffix product to 1 if it is equal to 0 is because I want to ensure that the product is never 0. If the product is 0, then the maximum product subarray will be 0.)\\n7. I update the current answer as the maximum of the prefix or suffix product.\\n8. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHOPE IT HELPS !\\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "Any product involves atleast two numbers. Even if it is a subarray there should me no possible product for the single element.  For the usecase : [0,2]. The output they are expecting is 2.  It must be 0.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The term \"product\" in mathematics generally refers to the result of multiplying two or more numbers together. However, in the context of this problem, when considering a subarray of just one element, the \"product\" of the subarray is simply the number itself. \\n\\nThis convention allows us to handle cases where the input array contains just one element, or the maximum product is achieved with a single-element subarray. In this sense, a product of a single number can be considered as that number \"multiplied by 1\". \\n\\nSo, for the array [0,2], the maximum product subarray is [2], and thus the maximum product is 2. \\n\\nThis may seem a little counter-intuitive based on the traditional definition of \"product\", but it\\'s a useful abstraction for the purposes of solving this type of problem."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "Python solution:\\n\\ndef maxProduct(self, nums: List[int]) -> int:\\n        maxProduct = nums[0]\\n        minProduct = nums[0]\\n        result = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] < 0:\\n                maxProduct, minProduct = minProduct , maxProduct \\n            maxProduct = max(nums[i], maxProduct * nums[i])\\n            minProduct = min(nums[i], minProduct * nums[i])\\n            result = max(result, maxProduct)\\n        return result \\n\\n        #time O(N)  n is the lenght of the input array \\n        #space O(1) using constant spance"
                    },
                    {
                        "username": "alexTheCoder",
                        "content": "From the known cases, the sequence of 2 , -3 , 1 , 2 , 3 , -2 is considered contiguous, so is -1, 1, it seems to me that zero is omitted, and duplicates are allowed, so, what is the requirement?"
                    },
                    {
                        "username": "ZonaZZZ",
                        "content": "Shouldn't it be -1? There is no contiguous number in this array except for itself."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a subarray can consist of a single number. So if the array only has one number, then that number itself is considered a subarray. Therefore, if you have an array [3] (with just one number 3), then the maximum product subarray is 3, which is the number itself.\\n\\nSimilarly, for an array [-1], the maximum product subarray is -1, because -1 is the only element and thus the only subarray.\\n\\nThis is a valid interpretation because in mathematics, the product of a single number is the number itself. In this problem, we\\'re looking for the maximum product of numbers in a subarray, so a single number counts as its own product. \\n\\nThe statement \"find the contiguous subarray within an array (containing at least one number) that has the largest product\" allows for this interpretation because it specifies \"at least one number,\" meaning a single number can constitute a subarray."
                    },
                    {
                        "username": "onesong2021",
                        "content": "If we have a non-zero array, that has the max product in the middle which doesn\\'t contains start and end number, then sliding window will not work.\\nBut, because the input is an integer array, the max product will not appear in the middle, it must at least contains one of start and end.\\n\\nLet\\'s assume, we have a non-zero integer array, which has the max product(P) in the middle.\\nThen this P will surround by two non-zero integers(a, b).\\nwhen a >= 1 && b >= 1 (P must > a , b > 0),  P <= P * a * b\\nwhen a >= 1 && b <= -1 (P must > a , b > 0), P <= P * a\\nwhen a <=-1 && b >= 1 (P must > a , b > 0), P <= P * b\\nwhen a <= -1 && b <= -1:\\n\\twhen P > 0, P <= P * a * b\\n\\twhen P < 0, P < P * a / P * b\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "[-2,0,1,-2] contradicts your assumption (max product is 1, doesn\\'t include the first nor the last - the 0 there nullifies the product of extremes)"
                    },
                    {
                        "username": "revenant7",
                        "content": "A good example which shows understanding the question clearly is important before coding. I thought of product as multiplication of two numbers (a * b), which means [2] gives result as 0. But this problem answers 2 for input [2] which made my code to fail for some test-cases."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for O(n) time solution with constant space in C++/Java/Python\\nhttps://www.techiedelight.com/find-maximum-product-subarray-given-array/"
                    },
                    {
                        "username": "Manashi",
                        "content": "Some wrong solutions pass, as my own solution is wrong."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha... Funny "
                    }
                ]
            },
            {
                "id": 1571345,
                "content": [
                    {
                        "username": "vik24k",
                        "content": "nums =\\n[0,2]\\n\\nOutput\\n0\\n\\nExpected\\n2\\n\\nhow?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks for the maximum product subarray, and in this case, the maximum product is 2. A subarray can be any contiguous part of the original array. In this case, the subarray [2] has the highest product. The subarray [0] has a product of 0, and the entire array [0,2] also has a product of 0 (since any number multiplied by 0 equals 0), so both of those options would be smaller than the product of the subarray [2]. \\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "[@Crispy_coffee](/Crispy_coffee) Being a subarray is not equal to the product of subarray elements. \\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "this should be wrong, as the statement clearly says that the largest product has to be returned. A  product requires at least two factorials, so the subarray length needs to be >= 2"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "because 2 is also a subarray and 2>0 , this is why the answer is 2."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I maintain the prefix and suffix product of the array. If at any time the prefix or suffix product is equal to 0, then I update it to 1. I update the current answer as the maximum of the prefix or suffix product. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHere is how I maintain the prefix and suffix product:\\n1. Initialize the prefix product to 1 and the suffix product to 1.\\n2. Iterate over the array.\\n3. In each iteration, multiply the prefix product by the current element.\\n4. Multiply the suffix product by the element at the end of the array, which is nums[n - i - 1].\\n6. If the prefix or suffix product is equal to 0, then I update it to 1. (The reason why I update the prefix or suffix product to 1 if it is equal to 0 is because I want to ensure that the product is never 0. If the product is 0, then the maximum product subarray will be 0.)\\n7. I update the current answer as the maximum of the prefix or suffix product.\\n8. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHOPE IT HELPS !\\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "Any product involves atleast two numbers. Even if it is a subarray there should me no possible product for the single element.  For the usecase : [0,2]. The output they are expecting is 2.  It must be 0.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The term \"product\" in mathematics generally refers to the result of multiplying two or more numbers together. However, in the context of this problem, when considering a subarray of just one element, the \"product\" of the subarray is simply the number itself. \\n\\nThis convention allows us to handle cases where the input array contains just one element, or the maximum product is achieved with a single-element subarray. In this sense, a product of a single number can be considered as that number \"multiplied by 1\". \\n\\nSo, for the array [0,2], the maximum product subarray is [2], and thus the maximum product is 2. \\n\\nThis may seem a little counter-intuitive based on the traditional definition of \"product\", but it\\'s a useful abstraction for the purposes of solving this type of problem."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "Python solution:\\n\\ndef maxProduct(self, nums: List[int]) -> int:\\n        maxProduct = nums[0]\\n        minProduct = nums[0]\\n        result = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] < 0:\\n                maxProduct, minProduct = minProduct , maxProduct \\n            maxProduct = max(nums[i], maxProduct * nums[i])\\n            minProduct = min(nums[i], minProduct * nums[i])\\n            result = max(result, maxProduct)\\n        return result \\n\\n        #time O(N)  n is the lenght of the input array \\n        #space O(1) using constant spance"
                    },
                    {
                        "username": "alexTheCoder",
                        "content": "From the known cases, the sequence of 2 , -3 , 1 , 2 , 3 , -2 is considered contiguous, so is -1, 1, it seems to me that zero is omitted, and duplicates are allowed, so, what is the requirement?"
                    },
                    {
                        "username": "ZonaZZZ",
                        "content": "Shouldn't it be -1? There is no contiguous number in this array except for itself."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a subarray can consist of a single number. So if the array only has one number, then that number itself is considered a subarray. Therefore, if you have an array [3] (with just one number 3), then the maximum product subarray is 3, which is the number itself.\\n\\nSimilarly, for an array [-1], the maximum product subarray is -1, because -1 is the only element and thus the only subarray.\\n\\nThis is a valid interpretation because in mathematics, the product of a single number is the number itself. In this problem, we\\'re looking for the maximum product of numbers in a subarray, so a single number counts as its own product. \\n\\nThe statement \"find the contiguous subarray within an array (containing at least one number) that has the largest product\" allows for this interpretation because it specifies \"at least one number,\" meaning a single number can constitute a subarray."
                    },
                    {
                        "username": "onesong2021",
                        "content": "If we have a non-zero array, that has the max product in the middle which doesn\\'t contains start and end number, then sliding window will not work.\\nBut, because the input is an integer array, the max product will not appear in the middle, it must at least contains one of start and end.\\n\\nLet\\'s assume, we have a non-zero integer array, which has the max product(P) in the middle.\\nThen this P will surround by two non-zero integers(a, b).\\nwhen a >= 1 && b >= 1 (P must > a , b > 0),  P <= P * a * b\\nwhen a >= 1 && b <= -1 (P must > a , b > 0), P <= P * a\\nwhen a <=-1 && b >= 1 (P must > a , b > 0), P <= P * b\\nwhen a <= -1 && b <= -1:\\n\\twhen P > 0, P <= P * a * b\\n\\twhen P < 0, P < P * a / P * b\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "[-2,0,1,-2] contradicts your assumption (max product is 1, doesn\\'t include the first nor the last - the 0 there nullifies the product of extremes)"
                    },
                    {
                        "username": "revenant7",
                        "content": "A good example which shows understanding the question clearly is important before coding. I thought of product as multiplication of two numbers (a * b), which means [2] gives result as 0. But this problem answers 2 for input [2] which made my code to fail for some test-cases."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for O(n) time solution with constant space in C++/Java/Python\\nhttps://www.techiedelight.com/find-maximum-product-subarray-given-array/"
                    },
                    {
                        "username": "Manashi",
                        "content": "Some wrong solutions pass, as my own solution is wrong."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha... Funny "
                    }
                ]
            },
            {
                "id": 1575812,
                "content": [
                    {
                        "username": "vik24k",
                        "content": "nums =\\n[0,2]\\n\\nOutput\\n0\\n\\nExpected\\n2\\n\\nhow?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks for the maximum product subarray, and in this case, the maximum product is 2. A subarray can be any contiguous part of the original array. In this case, the subarray [2] has the highest product. The subarray [0] has a product of 0, and the entire array [0,2] also has a product of 0 (since any number multiplied by 0 equals 0), so both of those options would be smaller than the product of the subarray [2]. \\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "[@Crispy_coffee](/Crispy_coffee) Being a subarray is not equal to the product of subarray elements. \\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "this should be wrong, as the statement clearly says that the largest product has to be returned. A  product requires at least two factorials, so the subarray length needs to be >= 2"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "because 2 is also a subarray and 2>0 , this is why the answer is 2."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I maintain the prefix and suffix product of the array. If at any time the prefix or suffix product is equal to 0, then I update it to 1. I update the current answer as the maximum of the prefix or suffix product. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHere is how I maintain the prefix and suffix product:\\n1. Initialize the prefix product to 1 and the suffix product to 1.\\n2. Iterate over the array.\\n3. In each iteration, multiply the prefix product by the current element.\\n4. Multiply the suffix product by the element at the end of the array, which is nums[n - i - 1].\\n6. If the prefix or suffix product is equal to 0, then I update it to 1. (The reason why I update the prefix or suffix product to 1 if it is equal to 0 is because I want to ensure that the product is never 0. If the product is 0, then the maximum product subarray will be 0.)\\n7. I update the current answer as the maximum of the prefix or suffix product.\\n8. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHOPE IT HELPS !\\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "Any product involves atleast two numbers. Even if it is a subarray there should me no possible product for the single element.  For the usecase : [0,2]. The output they are expecting is 2.  It must be 0.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The term \"product\" in mathematics generally refers to the result of multiplying two or more numbers together. However, in the context of this problem, when considering a subarray of just one element, the \"product\" of the subarray is simply the number itself. \\n\\nThis convention allows us to handle cases where the input array contains just one element, or the maximum product is achieved with a single-element subarray. In this sense, a product of a single number can be considered as that number \"multiplied by 1\". \\n\\nSo, for the array [0,2], the maximum product subarray is [2], and thus the maximum product is 2. \\n\\nThis may seem a little counter-intuitive based on the traditional definition of \"product\", but it\\'s a useful abstraction for the purposes of solving this type of problem."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "Python solution:\\n\\ndef maxProduct(self, nums: List[int]) -> int:\\n        maxProduct = nums[0]\\n        minProduct = nums[0]\\n        result = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] < 0:\\n                maxProduct, minProduct = minProduct , maxProduct \\n            maxProduct = max(nums[i], maxProduct * nums[i])\\n            minProduct = min(nums[i], minProduct * nums[i])\\n            result = max(result, maxProduct)\\n        return result \\n\\n        #time O(N)  n is the lenght of the input array \\n        #space O(1) using constant spance"
                    },
                    {
                        "username": "alexTheCoder",
                        "content": "From the known cases, the sequence of 2 , -3 , 1 , 2 , 3 , -2 is considered contiguous, so is -1, 1, it seems to me that zero is omitted, and duplicates are allowed, so, what is the requirement?"
                    },
                    {
                        "username": "ZonaZZZ",
                        "content": "Shouldn't it be -1? There is no contiguous number in this array except for itself."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a subarray can consist of a single number. So if the array only has one number, then that number itself is considered a subarray. Therefore, if you have an array [3] (with just one number 3), then the maximum product subarray is 3, which is the number itself.\\n\\nSimilarly, for an array [-1], the maximum product subarray is -1, because -1 is the only element and thus the only subarray.\\n\\nThis is a valid interpretation because in mathematics, the product of a single number is the number itself. In this problem, we\\'re looking for the maximum product of numbers in a subarray, so a single number counts as its own product. \\n\\nThe statement \"find the contiguous subarray within an array (containing at least one number) that has the largest product\" allows for this interpretation because it specifies \"at least one number,\" meaning a single number can constitute a subarray."
                    },
                    {
                        "username": "onesong2021",
                        "content": "If we have a non-zero array, that has the max product in the middle which doesn\\'t contains start and end number, then sliding window will not work.\\nBut, because the input is an integer array, the max product will not appear in the middle, it must at least contains one of start and end.\\n\\nLet\\'s assume, we have a non-zero integer array, which has the max product(P) in the middle.\\nThen this P will surround by two non-zero integers(a, b).\\nwhen a >= 1 && b >= 1 (P must > a , b > 0),  P <= P * a * b\\nwhen a >= 1 && b <= -1 (P must > a , b > 0), P <= P * a\\nwhen a <=-1 && b >= 1 (P must > a , b > 0), P <= P * b\\nwhen a <= -1 && b <= -1:\\n\\twhen P > 0, P <= P * a * b\\n\\twhen P < 0, P < P * a / P * b\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "[-2,0,1,-2] contradicts your assumption (max product is 1, doesn\\'t include the first nor the last - the 0 there nullifies the product of extremes)"
                    },
                    {
                        "username": "revenant7",
                        "content": "A good example which shows understanding the question clearly is important before coding. I thought of product as multiplication of two numbers (a * b), which means [2] gives result as 0. But this problem answers 2 for input [2] which made my code to fail for some test-cases."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for O(n) time solution with constant space in C++/Java/Python\\nhttps://www.techiedelight.com/find-maximum-product-subarray-given-array/"
                    },
                    {
                        "username": "Manashi",
                        "content": "Some wrong solutions pass, as my own solution is wrong."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha... Funny "
                    }
                ]
            },
            {
                "id": 1575634,
                "content": [
                    {
                        "username": "vik24k",
                        "content": "nums =\\n[0,2]\\n\\nOutput\\n0\\n\\nExpected\\n2\\n\\nhow?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks for the maximum product subarray, and in this case, the maximum product is 2. A subarray can be any contiguous part of the original array. In this case, the subarray [2] has the highest product. The subarray [0] has a product of 0, and the entire array [0,2] also has a product of 0 (since any number multiplied by 0 equals 0), so both of those options would be smaller than the product of the subarray [2]. \\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "[@Crispy_coffee](/Crispy_coffee) Being a subarray is not equal to the product of subarray elements. \\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "this should be wrong, as the statement clearly says that the largest product has to be returned. A  product requires at least two factorials, so the subarray length needs to be >= 2"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "because 2 is also a subarray and 2>0 , this is why the answer is 2."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I maintain the prefix and suffix product of the array. If at any time the prefix or suffix product is equal to 0, then I update it to 1. I update the current answer as the maximum of the prefix or suffix product. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHere is how I maintain the prefix and suffix product:\\n1. Initialize the prefix product to 1 and the suffix product to 1.\\n2. Iterate over the array.\\n3. In each iteration, multiply the prefix product by the current element.\\n4. Multiply the suffix product by the element at the end of the array, which is nums[n - i - 1].\\n6. If the prefix or suffix product is equal to 0, then I update it to 1. (The reason why I update the prefix or suffix product to 1 if it is equal to 0 is because I want to ensure that the product is never 0. If the product is 0, then the maximum product subarray will be 0.)\\n7. I update the current answer as the maximum of the prefix or suffix product.\\n8. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHOPE IT HELPS !\\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "Any product involves atleast two numbers. Even if it is a subarray there should me no possible product for the single element.  For the usecase : [0,2]. The output they are expecting is 2.  It must be 0.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The term \"product\" in mathematics generally refers to the result of multiplying two or more numbers together. However, in the context of this problem, when considering a subarray of just one element, the \"product\" of the subarray is simply the number itself. \\n\\nThis convention allows us to handle cases where the input array contains just one element, or the maximum product is achieved with a single-element subarray. In this sense, a product of a single number can be considered as that number \"multiplied by 1\". \\n\\nSo, for the array [0,2], the maximum product subarray is [2], and thus the maximum product is 2. \\n\\nThis may seem a little counter-intuitive based on the traditional definition of \"product\", but it\\'s a useful abstraction for the purposes of solving this type of problem."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "Python solution:\\n\\ndef maxProduct(self, nums: List[int]) -> int:\\n        maxProduct = nums[0]\\n        minProduct = nums[0]\\n        result = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] < 0:\\n                maxProduct, minProduct = minProduct , maxProduct \\n            maxProduct = max(nums[i], maxProduct * nums[i])\\n            minProduct = min(nums[i], minProduct * nums[i])\\n            result = max(result, maxProduct)\\n        return result \\n\\n        #time O(N)  n is the lenght of the input array \\n        #space O(1) using constant spance"
                    },
                    {
                        "username": "alexTheCoder",
                        "content": "From the known cases, the sequence of 2 , -3 , 1 , 2 , 3 , -2 is considered contiguous, so is -1, 1, it seems to me that zero is omitted, and duplicates are allowed, so, what is the requirement?"
                    },
                    {
                        "username": "ZonaZZZ",
                        "content": "Shouldn't it be -1? There is no contiguous number in this array except for itself."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a subarray can consist of a single number. So if the array only has one number, then that number itself is considered a subarray. Therefore, if you have an array [3] (with just one number 3), then the maximum product subarray is 3, which is the number itself.\\n\\nSimilarly, for an array [-1], the maximum product subarray is -1, because -1 is the only element and thus the only subarray.\\n\\nThis is a valid interpretation because in mathematics, the product of a single number is the number itself. In this problem, we\\'re looking for the maximum product of numbers in a subarray, so a single number counts as its own product. \\n\\nThe statement \"find the contiguous subarray within an array (containing at least one number) that has the largest product\" allows for this interpretation because it specifies \"at least one number,\" meaning a single number can constitute a subarray."
                    },
                    {
                        "username": "onesong2021",
                        "content": "If we have a non-zero array, that has the max product in the middle which doesn\\'t contains start and end number, then sliding window will not work.\\nBut, because the input is an integer array, the max product will not appear in the middle, it must at least contains one of start and end.\\n\\nLet\\'s assume, we have a non-zero integer array, which has the max product(P) in the middle.\\nThen this P will surround by two non-zero integers(a, b).\\nwhen a >= 1 && b >= 1 (P must > a , b > 0),  P <= P * a * b\\nwhen a >= 1 && b <= -1 (P must > a , b > 0), P <= P * a\\nwhen a <=-1 && b >= 1 (P must > a , b > 0), P <= P * b\\nwhen a <= -1 && b <= -1:\\n\\twhen P > 0, P <= P * a * b\\n\\twhen P < 0, P < P * a / P * b\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "[-2,0,1,-2] contradicts your assumption (max product is 1, doesn\\'t include the first nor the last - the 0 there nullifies the product of extremes)"
                    },
                    {
                        "username": "revenant7",
                        "content": "A good example which shows understanding the question clearly is important before coding. I thought of product as multiplication of two numbers (a * b), which means [2] gives result as 0. But this problem answers 2 for input [2] which made my code to fail for some test-cases."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for O(n) time solution with constant space in C++/Java/Python\\nhttps://www.techiedelight.com/find-maximum-product-subarray-given-array/"
                    },
                    {
                        "username": "Manashi",
                        "content": "Some wrong solutions pass, as my own solution is wrong."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha... Funny "
                    }
                ]
            },
            {
                "id": 1573941,
                "content": [
                    {
                        "username": "vik24k",
                        "content": "nums =\\n[0,2]\\n\\nOutput\\n0\\n\\nExpected\\n2\\n\\nhow?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks for the maximum product subarray, and in this case, the maximum product is 2. A subarray can be any contiguous part of the original array. In this case, the subarray [2] has the highest product. The subarray [0] has a product of 0, and the entire array [0,2] also has a product of 0 (since any number multiplied by 0 equals 0), so both of those options would be smaller than the product of the subarray [2]. \\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "[@Crispy_coffee](/Crispy_coffee) Being a subarray is not equal to the product of subarray elements. \\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "this should be wrong, as the statement clearly says that the largest product has to be returned. A  product requires at least two factorials, so the subarray length needs to be >= 2"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "because 2 is also a subarray and 2>0 , this is why the answer is 2."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I maintain the prefix and suffix product of the array. If at any time the prefix or suffix product is equal to 0, then I update it to 1. I update the current answer as the maximum of the prefix or suffix product. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHere is how I maintain the prefix and suffix product:\\n1. Initialize the prefix product to 1 and the suffix product to 1.\\n2. Iterate over the array.\\n3. In each iteration, multiply the prefix product by the current element.\\n4. Multiply the suffix product by the element at the end of the array, which is nums[n - i - 1].\\n6. If the prefix or suffix product is equal to 0, then I update it to 1. (The reason why I update the prefix or suffix product to 1 if it is equal to 0 is because I want to ensure that the product is never 0. If the product is 0, then the maximum product subarray will be 0.)\\n7. I update the current answer as the maximum of the prefix or suffix product.\\n8. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHOPE IT HELPS !\\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "Any product involves atleast two numbers. Even if it is a subarray there should me no possible product for the single element.  For the usecase : [0,2]. The output they are expecting is 2.  It must be 0.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The term \"product\" in mathematics generally refers to the result of multiplying two or more numbers together. However, in the context of this problem, when considering a subarray of just one element, the \"product\" of the subarray is simply the number itself. \\n\\nThis convention allows us to handle cases where the input array contains just one element, or the maximum product is achieved with a single-element subarray. In this sense, a product of a single number can be considered as that number \"multiplied by 1\". \\n\\nSo, for the array [0,2], the maximum product subarray is [2], and thus the maximum product is 2. \\n\\nThis may seem a little counter-intuitive based on the traditional definition of \"product\", but it\\'s a useful abstraction for the purposes of solving this type of problem."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "Python solution:\\n\\ndef maxProduct(self, nums: List[int]) -> int:\\n        maxProduct = nums[0]\\n        minProduct = nums[0]\\n        result = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] < 0:\\n                maxProduct, minProduct = minProduct , maxProduct \\n            maxProduct = max(nums[i], maxProduct * nums[i])\\n            minProduct = min(nums[i], minProduct * nums[i])\\n            result = max(result, maxProduct)\\n        return result \\n\\n        #time O(N)  n is the lenght of the input array \\n        #space O(1) using constant spance"
                    },
                    {
                        "username": "alexTheCoder",
                        "content": "From the known cases, the sequence of 2 , -3 , 1 , 2 , 3 , -2 is considered contiguous, so is -1, 1, it seems to me that zero is omitted, and duplicates are allowed, so, what is the requirement?"
                    },
                    {
                        "username": "ZonaZZZ",
                        "content": "Shouldn't it be -1? There is no contiguous number in this array except for itself."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a subarray can consist of a single number. So if the array only has one number, then that number itself is considered a subarray. Therefore, if you have an array [3] (with just one number 3), then the maximum product subarray is 3, which is the number itself.\\n\\nSimilarly, for an array [-1], the maximum product subarray is -1, because -1 is the only element and thus the only subarray.\\n\\nThis is a valid interpretation because in mathematics, the product of a single number is the number itself. In this problem, we\\'re looking for the maximum product of numbers in a subarray, so a single number counts as its own product. \\n\\nThe statement \"find the contiguous subarray within an array (containing at least one number) that has the largest product\" allows for this interpretation because it specifies \"at least one number,\" meaning a single number can constitute a subarray."
                    },
                    {
                        "username": "onesong2021",
                        "content": "If we have a non-zero array, that has the max product in the middle which doesn\\'t contains start and end number, then sliding window will not work.\\nBut, because the input is an integer array, the max product will not appear in the middle, it must at least contains one of start and end.\\n\\nLet\\'s assume, we have a non-zero integer array, which has the max product(P) in the middle.\\nThen this P will surround by two non-zero integers(a, b).\\nwhen a >= 1 && b >= 1 (P must > a , b > 0),  P <= P * a * b\\nwhen a >= 1 && b <= -1 (P must > a , b > 0), P <= P * a\\nwhen a <=-1 && b >= 1 (P must > a , b > 0), P <= P * b\\nwhen a <= -1 && b <= -1:\\n\\twhen P > 0, P <= P * a * b\\n\\twhen P < 0, P < P * a / P * b\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "[-2,0,1,-2] contradicts your assumption (max product is 1, doesn\\'t include the first nor the last - the 0 there nullifies the product of extremes)"
                    },
                    {
                        "username": "revenant7",
                        "content": "A good example which shows understanding the question clearly is important before coding. I thought of product as multiplication of two numbers (a * b), which means [2] gives result as 0. But this problem answers 2 for input [2] which made my code to fail for some test-cases."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for O(n) time solution with constant space in C++/Java/Python\\nhttps://www.techiedelight.com/find-maximum-product-subarray-given-array/"
                    },
                    {
                        "username": "Manashi",
                        "content": "Some wrong solutions pass, as my own solution is wrong."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha... Funny "
                    }
                ]
            },
            {
                "id": 1573099,
                "content": [
                    {
                        "username": "vik24k",
                        "content": "nums =\\n[0,2]\\n\\nOutput\\n0\\n\\nExpected\\n2\\n\\nhow?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks for the maximum product subarray, and in this case, the maximum product is 2. A subarray can be any contiguous part of the original array. In this case, the subarray [2] has the highest product. The subarray [0] has a product of 0, and the entire array [0,2] also has a product of 0 (since any number multiplied by 0 equals 0), so both of those options would be smaller than the product of the subarray [2]. \\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "[@Crispy_coffee](/Crispy_coffee) Being a subarray is not equal to the product of subarray elements. \\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "this should be wrong, as the statement clearly says that the largest product has to be returned. A  product requires at least two factorials, so the subarray length needs to be >= 2"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "because 2 is also a subarray and 2>0 , this is why the answer is 2."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I maintain the prefix and suffix product of the array. If at any time the prefix or suffix product is equal to 0, then I update it to 1. I update the current answer as the maximum of the prefix or suffix product. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHere is how I maintain the prefix and suffix product:\\n1. Initialize the prefix product to 1 and the suffix product to 1.\\n2. Iterate over the array.\\n3. In each iteration, multiply the prefix product by the current element.\\n4. Multiply the suffix product by the element at the end of the array, which is nums[n - i - 1].\\n6. If the prefix or suffix product is equal to 0, then I update it to 1. (The reason why I update the prefix or suffix product to 1 if it is equal to 0 is because I want to ensure that the product is never 0. If the product is 0, then the maximum product subarray will be 0.)\\n7. I update the current answer as the maximum of the prefix or suffix product.\\n8. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHOPE IT HELPS !\\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "Any product involves atleast two numbers. Even if it is a subarray there should me no possible product for the single element.  For the usecase : [0,2]. The output they are expecting is 2.  It must be 0.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The term \"product\" in mathematics generally refers to the result of multiplying two or more numbers together. However, in the context of this problem, when considering a subarray of just one element, the \"product\" of the subarray is simply the number itself. \\n\\nThis convention allows us to handle cases where the input array contains just one element, or the maximum product is achieved with a single-element subarray. In this sense, a product of a single number can be considered as that number \"multiplied by 1\". \\n\\nSo, for the array [0,2], the maximum product subarray is [2], and thus the maximum product is 2. \\n\\nThis may seem a little counter-intuitive based on the traditional definition of \"product\", but it\\'s a useful abstraction for the purposes of solving this type of problem."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "Python solution:\\n\\ndef maxProduct(self, nums: List[int]) -> int:\\n        maxProduct = nums[0]\\n        minProduct = nums[0]\\n        result = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] < 0:\\n                maxProduct, minProduct = minProduct , maxProduct \\n            maxProduct = max(nums[i], maxProduct * nums[i])\\n            minProduct = min(nums[i], minProduct * nums[i])\\n            result = max(result, maxProduct)\\n        return result \\n\\n        #time O(N)  n is the lenght of the input array \\n        #space O(1) using constant spance"
                    },
                    {
                        "username": "alexTheCoder",
                        "content": "From the known cases, the sequence of 2 , -3 , 1 , 2 , 3 , -2 is considered contiguous, so is -1, 1, it seems to me that zero is omitted, and duplicates are allowed, so, what is the requirement?"
                    },
                    {
                        "username": "ZonaZZZ",
                        "content": "Shouldn't it be -1? There is no contiguous number in this array except for itself."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a subarray can consist of a single number. So if the array only has one number, then that number itself is considered a subarray. Therefore, if you have an array [3] (with just one number 3), then the maximum product subarray is 3, which is the number itself.\\n\\nSimilarly, for an array [-1], the maximum product subarray is -1, because -1 is the only element and thus the only subarray.\\n\\nThis is a valid interpretation because in mathematics, the product of a single number is the number itself. In this problem, we\\'re looking for the maximum product of numbers in a subarray, so a single number counts as its own product. \\n\\nThe statement \"find the contiguous subarray within an array (containing at least one number) that has the largest product\" allows for this interpretation because it specifies \"at least one number,\" meaning a single number can constitute a subarray."
                    },
                    {
                        "username": "onesong2021",
                        "content": "If we have a non-zero array, that has the max product in the middle which doesn\\'t contains start and end number, then sliding window will not work.\\nBut, because the input is an integer array, the max product will not appear in the middle, it must at least contains one of start and end.\\n\\nLet\\'s assume, we have a non-zero integer array, which has the max product(P) in the middle.\\nThen this P will surround by two non-zero integers(a, b).\\nwhen a >= 1 && b >= 1 (P must > a , b > 0),  P <= P * a * b\\nwhen a >= 1 && b <= -1 (P must > a , b > 0), P <= P * a\\nwhen a <=-1 && b >= 1 (P must > a , b > 0), P <= P * b\\nwhen a <= -1 && b <= -1:\\n\\twhen P > 0, P <= P * a * b\\n\\twhen P < 0, P < P * a / P * b\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "[-2,0,1,-2] contradicts your assumption (max product is 1, doesn\\'t include the first nor the last - the 0 there nullifies the product of extremes)"
                    },
                    {
                        "username": "revenant7",
                        "content": "A good example which shows understanding the question clearly is important before coding. I thought of product as multiplication of two numbers (a * b), which means [2] gives result as 0. But this problem answers 2 for input [2] which made my code to fail for some test-cases."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for O(n) time solution with constant space in C++/Java/Python\\nhttps://www.techiedelight.com/find-maximum-product-subarray-given-array/"
                    },
                    {
                        "username": "Manashi",
                        "content": "Some wrong solutions pass, as my own solution is wrong."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha... Funny "
                    }
                ]
            },
            {
                "id": 2067626,
                "content": [
                    {
                        "username": "yogiwaran2003",
                        "content": "why can't be the sub array be {3,4} or {2,4} it has the maximum product?\n"
                    },
                    {
                        "username": "kaylent",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] testcase moves this task from an interesting one to the edge-case-hell..."
                    },
                    {
                        "username": "anmay007",
                        "content": "I am failing at only one test case that is [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]  my output is 1981284352   and the expected one is1000000000.. I am not able to understand how i am getting this wrong..remaining all test cases are fine..please help"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "If(res == 1000000000) break;\\n\\nPut this base case in your loop\\nIt will surely be fixed"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "how to solve this test case\\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n??"
                    },
                    {
                        "username": "codepout",
                        "content": "Remove this testcase please, [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0], for everyone just add an edgecase to check for 1000000000 and return true. "
                    },
                    {
                        "username": "Sharad_pal",
                        "content": "My Recursive approach solution got accepted Successfully ,but when i copy pasted this testcase, it gave me Wrong Answer lol...is this testcase removed or something now?                                                                   [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nOutput\\n1981284352\\nExpected\\n1000000000"
                    },
                    {
                        "username": "caldempsey",
                        "content": "This is a doozy but its worth really having a go, you will come to learn that Kadanes prefix sum is the way to go and you will add it to your toolkit, but I tried a tonne of stuff, including filtering out all of the zeros and trying to move two pointers :D"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You only need to worry about the **zeros** and the **negative** values. `Hint`\\nReaching a zero should reset the current product. Otherwise, it will stay at 0. `Hint`\\nDividing two negative values gives a positive. `Hint`\\n\\nWith these in mind, you should be able to solve the problem by yourself. If you do, your follow-up would be cleaning up your code."
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "here is my code it is getting stuck in [-2] edge case\\n\\n public int maxProduct(int[] nums) {\\n        int count =0 ; \\n        for(int i =0;i<nums.length -1;i=i+2){\\n            int max = nums[i] + nums[i+1];\\n            if(nums.length != nums.length-1 && max > count){\\n                count=  max;\\n            }\\n            else {\\n                int maxelse = nums[nums.length-1] + nums[0];\\n                if(maxelse>count){\\n                    count = maxelse;\\n                }\\n\\n            }\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "abhinavsinha19",
                        "content": "I tried using recursion to solve the problem, but could not find a way to memoize it, can somebody help me with it or where I am lacking?\\n\\n```\\nclass Solution {\\n    int maxp = -1e9;\\npublic: \\n    void f(vector<int>& nums, int ind, int product) {\\n        if (ind == nums.size()) return;\\n\\n        maxp = max(maxp, product*nums[ind]);\\n\\n        f(nums, ind+1, product*nums[ind]);\\n        f(nums, ind+1, 1);\\n    }\\n\\n    int maxProduct(vector<int>& nums) {\\n        f(nums, 0, 1);\\n        return maxp;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "sobo",
                        "content": "Why this solution doesn\\'t work...It gets stuck at the last test case the I am not able to see the test case either.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int maxProduct(vector<int> &nums, int index, int prevMul, unordered_map<string, int> &dp) {\\n        if (index >= nums.size()) {\\n            return prevMul;\\n        }\\n        string key = to_string(index) + \":\" + to_string(prevMul);\\n        if (dp.find(key) != dp.end()) {\\n            return dp[key];\\n        }\\n        // Srart fresh\\n        // no prev + no current + only future (may be)\\n        int ans1 = maxProduct(nums, index+1, INT_MIN, dp); \\n\\n        // prev + current + only future (may be)\\n        int k = prevMul==INT_MIN?1:prevMul;\\n        int ans2 = maxProduct(nums, index+1,  k*nums[index], dp);\\n\\n        // prev + no current + no future (because it is a subarray)\\n        // which means we can not take the future elements if we\\n        // do take the current and take the previous.\\n        int ans3 = prevMul;\\n        return dp[key] = max({ans3, ans1, ans2});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        unordered_map<string, int> dp;\\n        int ans = maxProduct(nums, 0, INT_MIN, dp);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 2062140,
                "content": [
                    {
                        "username": "yogiwaran2003",
                        "content": "why can't be the sub array be {3,4} or {2,4} it has the maximum product?\n"
                    },
                    {
                        "username": "kaylent",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] testcase moves this task from an interesting one to the edge-case-hell..."
                    },
                    {
                        "username": "anmay007",
                        "content": "I am failing at only one test case that is [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]  my output is 1981284352   and the expected one is1000000000.. I am not able to understand how i am getting this wrong..remaining all test cases are fine..please help"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "If(res == 1000000000) break;\\n\\nPut this base case in your loop\\nIt will surely be fixed"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "how to solve this test case\\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n??"
                    },
                    {
                        "username": "codepout",
                        "content": "Remove this testcase please, [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0], for everyone just add an edgecase to check for 1000000000 and return true. "
                    },
                    {
                        "username": "Sharad_pal",
                        "content": "My Recursive approach solution got accepted Successfully ,but when i copy pasted this testcase, it gave me Wrong Answer lol...is this testcase removed or something now?                                                                   [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nOutput\\n1981284352\\nExpected\\n1000000000"
                    },
                    {
                        "username": "caldempsey",
                        "content": "This is a doozy but its worth really having a go, you will come to learn that Kadanes prefix sum is the way to go and you will add it to your toolkit, but I tried a tonne of stuff, including filtering out all of the zeros and trying to move two pointers :D"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You only need to worry about the **zeros** and the **negative** values. `Hint`\\nReaching a zero should reset the current product. Otherwise, it will stay at 0. `Hint`\\nDividing two negative values gives a positive. `Hint`\\n\\nWith these in mind, you should be able to solve the problem by yourself. If you do, your follow-up would be cleaning up your code."
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "here is my code it is getting stuck in [-2] edge case\\n\\n public int maxProduct(int[] nums) {\\n        int count =0 ; \\n        for(int i =0;i<nums.length -1;i=i+2){\\n            int max = nums[i] + nums[i+1];\\n            if(nums.length != nums.length-1 && max > count){\\n                count=  max;\\n            }\\n            else {\\n                int maxelse = nums[nums.length-1] + nums[0];\\n                if(maxelse>count){\\n                    count = maxelse;\\n                }\\n\\n            }\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "abhinavsinha19",
                        "content": "I tried using recursion to solve the problem, but could not find a way to memoize it, can somebody help me with it or where I am lacking?\\n\\n```\\nclass Solution {\\n    int maxp = -1e9;\\npublic: \\n    void f(vector<int>& nums, int ind, int product) {\\n        if (ind == nums.size()) return;\\n\\n        maxp = max(maxp, product*nums[ind]);\\n\\n        f(nums, ind+1, product*nums[ind]);\\n        f(nums, ind+1, 1);\\n    }\\n\\n    int maxProduct(vector<int>& nums) {\\n        f(nums, 0, 1);\\n        return maxp;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "sobo",
                        "content": "Why this solution doesn\\'t work...It gets stuck at the last test case the I am not able to see the test case either.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int maxProduct(vector<int> &nums, int index, int prevMul, unordered_map<string, int> &dp) {\\n        if (index >= nums.size()) {\\n            return prevMul;\\n        }\\n        string key = to_string(index) + \":\" + to_string(prevMul);\\n        if (dp.find(key) != dp.end()) {\\n            return dp[key];\\n        }\\n        // Srart fresh\\n        // no prev + no current + only future (may be)\\n        int ans1 = maxProduct(nums, index+1, INT_MIN, dp); \\n\\n        // prev + current + only future (may be)\\n        int k = prevMul==INT_MIN?1:prevMul;\\n        int ans2 = maxProduct(nums, index+1,  k*nums[index], dp);\\n\\n        // prev + no current + no future (because it is a subarray)\\n        // which means we can not take the future elements if we\\n        // do take the current and take the previous.\\n        int ans3 = prevMul;\\n        return dp[key] = max({ans3, ans1, ans2});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        unordered_map<string, int> dp;\\n        int ans = maxProduct(nums, 0, INT_MIN, dp);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 2062075,
                "content": [
                    {
                        "username": "yogiwaran2003",
                        "content": "why can't be the sub array be {3,4} or {2,4} it has the maximum product?\n"
                    },
                    {
                        "username": "kaylent",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] testcase moves this task from an interesting one to the edge-case-hell..."
                    },
                    {
                        "username": "anmay007",
                        "content": "I am failing at only one test case that is [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]  my output is 1981284352   and the expected one is1000000000.. I am not able to understand how i am getting this wrong..remaining all test cases are fine..please help"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "If(res == 1000000000) break;\\n\\nPut this base case in your loop\\nIt will surely be fixed"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "how to solve this test case\\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n??"
                    },
                    {
                        "username": "codepout",
                        "content": "Remove this testcase please, [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0], for everyone just add an edgecase to check for 1000000000 and return true. "
                    },
                    {
                        "username": "Sharad_pal",
                        "content": "My Recursive approach solution got accepted Successfully ,but when i copy pasted this testcase, it gave me Wrong Answer lol...is this testcase removed or something now?                                                                   [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nOutput\\n1981284352\\nExpected\\n1000000000"
                    },
                    {
                        "username": "caldempsey",
                        "content": "This is a doozy but its worth really having a go, you will come to learn that Kadanes prefix sum is the way to go and you will add it to your toolkit, but I tried a tonne of stuff, including filtering out all of the zeros and trying to move two pointers :D"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You only need to worry about the **zeros** and the **negative** values. `Hint`\\nReaching a zero should reset the current product. Otherwise, it will stay at 0. `Hint`\\nDividing two negative values gives a positive. `Hint`\\n\\nWith these in mind, you should be able to solve the problem by yourself. If you do, your follow-up would be cleaning up your code."
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "here is my code it is getting stuck in [-2] edge case\\n\\n public int maxProduct(int[] nums) {\\n        int count =0 ; \\n        for(int i =0;i<nums.length -1;i=i+2){\\n            int max = nums[i] + nums[i+1];\\n            if(nums.length != nums.length-1 && max > count){\\n                count=  max;\\n            }\\n            else {\\n                int maxelse = nums[nums.length-1] + nums[0];\\n                if(maxelse>count){\\n                    count = maxelse;\\n                }\\n\\n            }\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "abhinavsinha19",
                        "content": "I tried using recursion to solve the problem, but could not find a way to memoize it, can somebody help me with it or where I am lacking?\\n\\n```\\nclass Solution {\\n    int maxp = -1e9;\\npublic: \\n    void f(vector<int>& nums, int ind, int product) {\\n        if (ind == nums.size()) return;\\n\\n        maxp = max(maxp, product*nums[ind]);\\n\\n        f(nums, ind+1, product*nums[ind]);\\n        f(nums, ind+1, 1);\\n    }\\n\\n    int maxProduct(vector<int>& nums) {\\n        f(nums, 0, 1);\\n        return maxp;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "sobo",
                        "content": "Why this solution doesn\\'t work...It gets stuck at the last test case the I am not able to see the test case either.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int maxProduct(vector<int> &nums, int index, int prevMul, unordered_map<string, int> &dp) {\\n        if (index >= nums.size()) {\\n            return prevMul;\\n        }\\n        string key = to_string(index) + \":\" + to_string(prevMul);\\n        if (dp.find(key) != dp.end()) {\\n            return dp[key];\\n        }\\n        // Srart fresh\\n        // no prev + no current + only future (may be)\\n        int ans1 = maxProduct(nums, index+1, INT_MIN, dp); \\n\\n        // prev + current + only future (may be)\\n        int k = prevMul==INT_MIN?1:prevMul;\\n        int ans2 = maxProduct(nums, index+1,  k*nums[index], dp);\\n\\n        // prev + no current + no future (because it is a subarray)\\n        // which means we can not take the future elements if we\\n        // do take the current and take the previous.\\n        int ans3 = prevMul;\\n        return dp[key] = max({ans3, ans1, ans2});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        unordered_map<string, int> dp;\\n        int ans = maxProduct(nums, 0, INT_MIN, dp);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 2061987,
                "content": [
                    {
                        "username": "yogiwaran2003",
                        "content": "why can't be the sub array be {3,4} or {2,4} it has the maximum product?\n"
                    },
                    {
                        "username": "kaylent",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] testcase moves this task from an interesting one to the edge-case-hell..."
                    },
                    {
                        "username": "anmay007",
                        "content": "I am failing at only one test case that is [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]  my output is 1981284352   and the expected one is1000000000.. I am not able to understand how i am getting this wrong..remaining all test cases are fine..please help"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "If(res == 1000000000) break;\\n\\nPut this base case in your loop\\nIt will surely be fixed"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "how to solve this test case\\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n??"
                    },
                    {
                        "username": "codepout",
                        "content": "Remove this testcase please, [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0], for everyone just add an edgecase to check for 1000000000 and return true. "
                    },
                    {
                        "username": "Sharad_pal",
                        "content": "My Recursive approach solution got accepted Successfully ,but when i copy pasted this testcase, it gave me Wrong Answer lol...is this testcase removed or something now?                                                                   [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nOutput\\n1981284352\\nExpected\\n1000000000"
                    },
                    {
                        "username": "caldempsey",
                        "content": "This is a doozy but its worth really having a go, you will come to learn that Kadanes prefix sum is the way to go and you will add it to your toolkit, but I tried a tonne of stuff, including filtering out all of the zeros and trying to move two pointers :D"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You only need to worry about the **zeros** and the **negative** values. `Hint`\\nReaching a zero should reset the current product. Otherwise, it will stay at 0. `Hint`\\nDividing two negative values gives a positive. `Hint`\\n\\nWith these in mind, you should be able to solve the problem by yourself. If you do, your follow-up would be cleaning up your code."
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "here is my code it is getting stuck in [-2] edge case\\n\\n public int maxProduct(int[] nums) {\\n        int count =0 ; \\n        for(int i =0;i<nums.length -1;i=i+2){\\n            int max = nums[i] + nums[i+1];\\n            if(nums.length != nums.length-1 && max > count){\\n                count=  max;\\n            }\\n            else {\\n                int maxelse = nums[nums.length-1] + nums[0];\\n                if(maxelse>count){\\n                    count = maxelse;\\n                }\\n\\n            }\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "abhinavsinha19",
                        "content": "I tried using recursion to solve the problem, but could not find a way to memoize it, can somebody help me with it or where I am lacking?\\n\\n```\\nclass Solution {\\n    int maxp = -1e9;\\npublic: \\n    void f(vector<int>& nums, int ind, int product) {\\n        if (ind == nums.size()) return;\\n\\n        maxp = max(maxp, product*nums[ind]);\\n\\n        f(nums, ind+1, product*nums[ind]);\\n        f(nums, ind+1, 1);\\n    }\\n\\n    int maxProduct(vector<int>& nums) {\\n        f(nums, 0, 1);\\n        return maxp;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "sobo",
                        "content": "Why this solution doesn\\'t work...It gets stuck at the last test case the I am not able to see the test case either.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int maxProduct(vector<int> &nums, int index, int prevMul, unordered_map<string, int> &dp) {\\n        if (index >= nums.size()) {\\n            return prevMul;\\n        }\\n        string key = to_string(index) + \":\" + to_string(prevMul);\\n        if (dp.find(key) != dp.end()) {\\n            return dp[key];\\n        }\\n        // Srart fresh\\n        // no prev + no current + only future (may be)\\n        int ans1 = maxProduct(nums, index+1, INT_MIN, dp); \\n\\n        // prev + current + only future (may be)\\n        int k = prevMul==INT_MIN?1:prevMul;\\n        int ans2 = maxProduct(nums, index+1,  k*nums[index], dp);\\n\\n        // prev + no current + no future (because it is a subarray)\\n        // which means we can not take the future elements if we\\n        // do take the current and take the previous.\\n        int ans3 = prevMul;\\n        return dp[key] = max({ans3, ans1, ans2});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        unordered_map<string, int> dp;\\n        int ans = maxProduct(nums, 0, INT_MIN, dp);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 2060675,
                "content": [
                    {
                        "username": "yogiwaran2003",
                        "content": "why can't be the sub array be {3,4} or {2,4} it has the maximum product?\n"
                    },
                    {
                        "username": "kaylent",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] testcase moves this task from an interesting one to the edge-case-hell..."
                    },
                    {
                        "username": "anmay007",
                        "content": "I am failing at only one test case that is [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]  my output is 1981284352   and the expected one is1000000000.. I am not able to understand how i am getting this wrong..remaining all test cases are fine..please help"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "If(res == 1000000000) break;\\n\\nPut this base case in your loop\\nIt will surely be fixed"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "how to solve this test case\\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n??"
                    },
                    {
                        "username": "codepout",
                        "content": "Remove this testcase please, [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0], for everyone just add an edgecase to check for 1000000000 and return true. "
                    },
                    {
                        "username": "Sharad_pal",
                        "content": "My Recursive approach solution got accepted Successfully ,but when i copy pasted this testcase, it gave me Wrong Answer lol...is this testcase removed or something now?                                                                   [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nOutput\\n1981284352\\nExpected\\n1000000000"
                    },
                    {
                        "username": "caldempsey",
                        "content": "This is a doozy but its worth really having a go, you will come to learn that Kadanes prefix sum is the way to go and you will add it to your toolkit, but I tried a tonne of stuff, including filtering out all of the zeros and trying to move two pointers :D"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You only need to worry about the **zeros** and the **negative** values. `Hint`\\nReaching a zero should reset the current product. Otherwise, it will stay at 0. `Hint`\\nDividing two negative values gives a positive. `Hint`\\n\\nWith these in mind, you should be able to solve the problem by yourself. If you do, your follow-up would be cleaning up your code."
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "here is my code it is getting stuck in [-2] edge case\\n\\n public int maxProduct(int[] nums) {\\n        int count =0 ; \\n        for(int i =0;i<nums.length -1;i=i+2){\\n            int max = nums[i] + nums[i+1];\\n            if(nums.length != nums.length-1 && max > count){\\n                count=  max;\\n            }\\n            else {\\n                int maxelse = nums[nums.length-1] + nums[0];\\n                if(maxelse>count){\\n                    count = maxelse;\\n                }\\n\\n            }\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "abhinavsinha19",
                        "content": "I tried using recursion to solve the problem, but could not find a way to memoize it, can somebody help me with it or where I am lacking?\\n\\n```\\nclass Solution {\\n    int maxp = -1e9;\\npublic: \\n    void f(vector<int>& nums, int ind, int product) {\\n        if (ind == nums.size()) return;\\n\\n        maxp = max(maxp, product*nums[ind]);\\n\\n        f(nums, ind+1, product*nums[ind]);\\n        f(nums, ind+1, 1);\\n    }\\n\\n    int maxProduct(vector<int>& nums) {\\n        f(nums, 0, 1);\\n        return maxp;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "sobo",
                        "content": "Why this solution doesn\\'t work...It gets stuck at the last test case the I am not able to see the test case either.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int maxProduct(vector<int> &nums, int index, int prevMul, unordered_map<string, int> &dp) {\\n        if (index >= nums.size()) {\\n            return prevMul;\\n        }\\n        string key = to_string(index) + \":\" + to_string(prevMul);\\n        if (dp.find(key) != dp.end()) {\\n            return dp[key];\\n        }\\n        // Srart fresh\\n        // no prev + no current + only future (may be)\\n        int ans1 = maxProduct(nums, index+1, INT_MIN, dp); \\n\\n        // prev + current + only future (may be)\\n        int k = prevMul==INT_MIN?1:prevMul;\\n        int ans2 = maxProduct(nums, index+1,  k*nums[index], dp);\\n\\n        // prev + no current + no future (because it is a subarray)\\n        // which means we can not take the future elements if we\\n        // do take the current and take the previous.\\n        int ans3 = prevMul;\\n        return dp[key] = max({ans3, ans1, ans2});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        unordered_map<string, int> dp;\\n        int ans = maxProduct(nums, 0, INT_MIN, dp);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 2056191,
                "content": [
                    {
                        "username": "yogiwaran2003",
                        "content": "why can't be the sub array be {3,4} or {2,4} it has the maximum product?\n"
                    },
                    {
                        "username": "kaylent",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] testcase moves this task from an interesting one to the edge-case-hell..."
                    },
                    {
                        "username": "anmay007",
                        "content": "I am failing at only one test case that is [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]  my output is 1981284352   and the expected one is1000000000.. I am not able to understand how i am getting this wrong..remaining all test cases are fine..please help"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "If(res == 1000000000) break;\\n\\nPut this base case in your loop\\nIt will surely be fixed"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "how to solve this test case\\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n??"
                    },
                    {
                        "username": "codepout",
                        "content": "Remove this testcase please, [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0], for everyone just add an edgecase to check for 1000000000 and return true. "
                    },
                    {
                        "username": "Sharad_pal",
                        "content": "My Recursive approach solution got accepted Successfully ,but when i copy pasted this testcase, it gave me Wrong Answer lol...is this testcase removed or something now?                                                                   [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nOutput\\n1981284352\\nExpected\\n1000000000"
                    },
                    {
                        "username": "caldempsey",
                        "content": "This is a doozy but its worth really having a go, you will come to learn that Kadanes prefix sum is the way to go and you will add it to your toolkit, but I tried a tonne of stuff, including filtering out all of the zeros and trying to move two pointers :D"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You only need to worry about the **zeros** and the **negative** values. `Hint`\\nReaching a zero should reset the current product. Otherwise, it will stay at 0. `Hint`\\nDividing two negative values gives a positive. `Hint`\\n\\nWith these in mind, you should be able to solve the problem by yourself. If you do, your follow-up would be cleaning up your code."
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "here is my code it is getting stuck in [-2] edge case\\n\\n public int maxProduct(int[] nums) {\\n        int count =0 ; \\n        for(int i =0;i<nums.length -1;i=i+2){\\n            int max = nums[i] + nums[i+1];\\n            if(nums.length != nums.length-1 && max > count){\\n                count=  max;\\n            }\\n            else {\\n                int maxelse = nums[nums.length-1] + nums[0];\\n                if(maxelse>count){\\n                    count = maxelse;\\n                }\\n\\n            }\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "abhinavsinha19",
                        "content": "I tried using recursion to solve the problem, but could not find a way to memoize it, can somebody help me with it or where I am lacking?\\n\\n```\\nclass Solution {\\n    int maxp = -1e9;\\npublic: \\n    void f(vector<int>& nums, int ind, int product) {\\n        if (ind == nums.size()) return;\\n\\n        maxp = max(maxp, product*nums[ind]);\\n\\n        f(nums, ind+1, product*nums[ind]);\\n        f(nums, ind+1, 1);\\n    }\\n\\n    int maxProduct(vector<int>& nums) {\\n        f(nums, 0, 1);\\n        return maxp;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "sobo",
                        "content": "Why this solution doesn\\'t work...It gets stuck at the last test case the I am not able to see the test case either.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int maxProduct(vector<int> &nums, int index, int prevMul, unordered_map<string, int> &dp) {\\n        if (index >= nums.size()) {\\n            return prevMul;\\n        }\\n        string key = to_string(index) + \":\" + to_string(prevMul);\\n        if (dp.find(key) != dp.end()) {\\n            return dp[key];\\n        }\\n        // Srart fresh\\n        // no prev + no current + only future (may be)\\n        int ans1 = maxProduct(nums, index+1, INT_MIN, dp); \\n\\n        // prev + current + only future (may be)\\n        int k = prevMul==INT_MIN?1:prevMul;\\n        int ans2 = maxProduct(nums, index+1,  k*nums[index], dp);\\n\\n        // prev + no current + no future (because it is a subarray)\\n        // which means we can not take the future elements if we\\n        // do take the current and take the previous.\\n        int ans3 = prevMul;\\n        return dp[key] = max({ans3, ans1, ans2});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        unordered_map<string, int> dp;\\n        int ans = maxProduct(nums, 0, INT_MIN, dp);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 2047587,
                "content": [
                    {
                        "username": "yogiwaran2003",
                        "content": "why can't be the sub array be {3,4} or {2,4} it has the maximum product?\n"
                    },
                    {
                        "username": "kaylent",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] testcase moves this task from an interesting one to the edge-case-hell..."
                    },
                    {
                        "username": "anmay007",
                        "content": "I am failing at only one test case that is [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]  my output is 1981284352   and the expected one is1000000000.. I am not able to understand how i am getting this wrong..remaining all test cases are fine..please help"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "If(res == 1000000000) break;\\n\\nPut this base case in your loop\\nIt will surely be fixed"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "how to solve this test case\\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n??"
                    },
                    {
                        "username": "codepout",
                        "content": "Remove this testcase please, [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0], for everyone just add an edgecase to check for 1000000000 and return true. "
                    },
                    {
                        "username": "Sharad_pal",
                        "content": "My Recursive approach solution got accepted Successfully ,but when i copy pasted this testcase, it gave me Wrong Answer lol...is this testcase removed or something now?                                                                   [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nOutput\\n1981284352\\nExpected\\n1000000000"
                    },
                    {
                        "username": "caldempsey",
                        "content": "This is a doozy but its worth really having a go, you will come to learn that Kadanes prefix sum is the way to go and you will add it to your toolkit, but I tried a tonne of stuff, including filtering out all of the zeros and trying to move two pointers :D"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You only need to worry about the **zeros** and the **negative** values. `Hint`\\nReaching a zero should reset the current product. Otherwise, it will stay at 0. `Hint`\\nDividing two negative values gives a positive. `Hint`\\n\\nWith these in mind, you should be able to solve the problem by yourself. If you do, your follow-up would be cleaning up your code."
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "here is my code it is getting stuck in [-2] edge case\\n\\n public int maxProduct(int[] nums) {\\n        int count =0 ; \\n        for(int i =0;i<nums.length -1;i=i+2){\\n            int max = nums[i] + nums[i+1];\\n            if(nums.length != nums.length-1 && max > count){\\n                count=  max;\\n            }\\n            else {\\n                int maxelse = nums[nums.length-1] + nums[0];\\n                if(maxelse>count){\\n                    count = maxelse;\\n                }\\n\\n            }\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "abhinavsinha19",
                        "content": "I tried using recursion to solve the problem, but could not find a way to memoize it, can somebody help me with it or where I am lacking?\\n\\n```\\nclass Solution {\\n    int maxp = -1e9;\\npublic: \\n    void f(vector<int>& nums, int ind, int product) {\\n        if (ind == nums.size()) return;\\n\\n        maxp = max(maxp, product*nums[ind]);\\n\\n        f(nums, ind+1, product*nums[ind]);\\n        f(nums, ind+1, 1);\\n    }\\n\\n    int maxProduct(vector<int>& nums) {\\n        f(nums, 0, 1);\\n        return maxp;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "sobo",
                        "content": "Why this solution doesn\\'t work...It gets stuck at the last test case the I am not able to see the test case either.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int maxProduct(vector<int> &nums, int index, int prevMul, unordered_map<string, int> &dp) {\\n        if (index >= nums.size()) {\\n            return prevMul;\\n        }\\n        string key = to_string(index) + \":\" + to_string(prevMul);\\n        if (dp.find(key) != dp.end()) {\\n            return dp[key];\\n        }\\n        // Srart fresh\\n        // no prev + no current + only future (may be)\\n        int ans1 = maxProduct(nums, index+1, INT_MIN, dp); \\n\\n        // prev + current + only future (may be)\\n        int k = prevMul==INT_MIN?1:prevMul;\\n        int ans2 = maxProduct(nums, index+1,  k*nums[index], dp);\\n\\n        // prev + no current + no future (because it is a subarray)\\n        // which means we can not take the future elements if we\\n        // do take the current and take the previous.\\n        int ans3 = prevMul;\\n        return dp[key] = max({ans3, ans1, ans2});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        unordered_map<string, int> dp;\\n        int ans = maxProduct(nums, 0, INT_MIN, dp);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 2046387,
                "content": [
                    {
                        "username": "yogiwaran2003",
                        "content": "why can't be the sub array be {3,4} or {2,4} it has the maximum product?\n"
                    },
                    {
                        "username": "kaylent",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] testcase moves this task from an interesting one to the edge-case-hell..."
                    },
                    {
                        "username": "anmay007",
                        "content": "I am failing at only one test case that is [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]  my output is 1981284352   and the expected one is1000000000.. I am not able to understand how i am getting this wrong..remaining all test cases are fine..please help"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "If(res == 1000000000) break;\\n\\nPut this base case in your loop\\nIt will surely be fixed"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "how to solve this test case\\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n??"
                    },
                    {
                        "username": "codepout",
                        "content": "Remove this testcase please, [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0], for everyone just add an edgecase to check for 1000000000 and return true. "
                    },
                    {
                        "username": "Sharad_pal",
                        "content": "My Recursive approach solution got accepted Successfully ,but when i copy pasted this testcase, it gave me Wrong Answer lol...is this testcase removed or something now?                                                                   [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nOutput\\n1981284352\\nExpected\\n1000000000"
                    },
                    {
                        "username": "caldempsey",
                        "content": "This is a doozy but its worth really having a go, you will come to learn that Kadanes prefix sum is the way to go and you will add it to your toolkit, but I tried a tonne of stuff, including filtering out all of the zeros and trying to move two pointers :D"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You only need to worry about the **zeros** and the **negative** values. `Hint`\\nReaching a zero should reset the current product. Otherwise, it will stay at 0. `Hint`\\nDividing two negative values gives a positive. `Hint`\\n\\nWith these in mind, you should be able to solve the problem by yourself. If you do, your follow-up would be cleaning up your code."
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "here is my code it is getting stuck in [-2] edge case\\n\\n public int maxProduct(int[] nums) {\\n        int count =0 ; \\n        for(int i =0;i<nums.length -1;i=i+2){\\n            int max = nums[i] + nums[i+1];\\n            if(nums.length != nums.length-1 && max > count){\\n                count=  max;\\n            }\\n            else {\\n                int maxelse = nums[nums.length-1] + nums[0];\\n                if(maxelse>count){\\n                    count = maxelse;\\n                }\\n\\n            }\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "abhinavsinha19",
                        "content": "I tried using recursion to solve the problem, but could not find a way to memoize it, can somebody help me with it or where I am lacking?\\n\\n```\\nclass Solution {\\n    int maxp = -1e9;\\npublic: \\n    void f(vector<int>& nums, int ind, int product) {\\n        if (ind == nums.size()) return;\\n\\n        maxp = max(maxp, product*nums[ind]);\\n\\n        f(nums, ind+1, product*nums[ind]);\\n        f(nums, ind+1, 1);\\n    }\\n\\n    int maxProduct(vector<int>& nums) {\\n        f(nums, 0, 1);\\n        return maxp;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "sobo",
                        "content": "Why this solution doesn\\'t work...It gets stuck at the last test case the I am not able to see the test case either.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int maxProduct(vector<int> &nums, int index, int prevMul, unordered_map<string, int> &dp) {\\n        if (index >= nums.size()) {\\n            return prevMul;\\n        }\\n        string key = to_string(index) + \":\" + to_string(prevMul);\\n        if (dp.find(key) != dp.end()) {\\n            return dp[key];\\n        }\\n        // Srart fresh\\n        // no prev + no current + only future (may be)\\n        int ans1 = maxProduct(nums, index+1, INT_MIN, dp); \\n\\n        // prev + current + only future (may be)\\n        int k = prevMul==INT_MIN?1:prevMul;\\n        int ans2 = maxProduct(nums, index+1,  k*nums[index], dp);\\n\\n        // prev + no current + no future (because it is a subarray)\\n        // which means we can not take the future elements if we\\n        // do take the current and take the previous.\\n        int ans3 = prevMul;\\n        return dp[key] = max({ans3, ans1, ans2});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        unordered_map<string, int> dp;\\n        int ans = maxProduct(nums, 0, INT_MIN, dp);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 2043534,
                "content": [
                    {
                        "username": "yogiwaran2003",
                        "content": "why can't be the sub array be {3,4} or {2,4} it has the maximum product?\n"
                    },
                    {
                        "username": "kaylent",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] testcase moves this task from an interesting one to the edge-case-hell..."
                    },
                    {
                        "username": "anmay007",
                        "content": "I am failing at only one test case that is [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]  my output is 1981284352   and the expected one is1000000000.. I am not able to understand how i am getting this wrong..remaining all test cases are fine..please help"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "If(res == 1000000000) break;\\n\\nPut this base case in your loop\\nIt will surely be fixed"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "how to solve this test case\\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n??"
                    },
                    {
                        "username": "codepout",
                        "content": "Remove this testcase please, [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0], for everyone just add an edgecase to check for 1000000000 and return true. "
                    },
                    {
                        "username": "Sharad_pal",
                        "content": "My Recursive approach solution got accepted Successfully ,but when i copy pasted this testcase, it gave me Wrong Answer lol...is this testcase removed or something now?                                                                   [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nOutput\\n1981284352\\nExpected\\n1000000000"
                    },
                    {
                        "username": "caldempsey",
                        "content": "This is a doozy but its worth really having a go, you will come to learn that Kadanes prefix sum is the way to go and you will add it to your toolkit, but I tried a tonne of stuff, including filtering out all of the zeros and trying to move two pointers :D"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You only need to worry about the **zeros** and the **negative** values. `Hint`\\nReaching a zero should reset the current product. Otherwise, it will stay at 0. `Hint`\\nDividing two negative values gives a positive. `Hint`\\n\\nWith these in mind, you should be able to solve the problem by yourself. If you do, your follow-up would be cleaning up your code."
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "here is my code it is getting stuck in [-2] edge case\\n\\n public int maxProduct(int[] nums) {\\n        int count =0 ; \\n        for(int i =0;i<nums.length -1;i=i+2){\\n            int max = nums[i] + nums[i+1];\\n            if(nums.length != nums.length-1 && max > count){\\n                count=  max;\\n            }\\n            else {\\n                int maxelse = nums[nums.length-1] + nums[0];\\n                if(maxelse>count){\\n                    count = maxelse;\\n                }\\n\\n            }\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "abhinavsinha19",
                        "content": "I tried using recursion to solve the problem, but could not find a way to memoize it, can somebody help me with it or where I am lacking?\\n\\n```\\nclass Solution {\\n    int maxp = -1e9;\\npublic: \\n    void f(vector<int>& nums, int ind, int product) {\\n        if (ind == nums.size()) return;\\n\\n        maxp = max(maxp, product*nums[ind]);\\n\\n        f(nums, ind+1, product*nums[ind]);\\n        f(nums, ind+1, 1);\\n    }\\n\\n    int maxProduct(vector<int>& nums) {\\n        f(nums, 0, 1);\\n        return maxp;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "sobo",
                        "content": "Why this solution doesn\\'t work...It gets stuck at the last test case the I am not able to see the test case either.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int maxProduct(vector<int> &nums, int index, int prevMul, unordered_map<string, int> &dp) {\\n        if (index >= nums.size()) {\\n            return prevMul;\\n        }\\n        string key = to_string(index) + \":\" + to_string(prevMul);\\n        if (dp.find(key) != dp.end()) {\\n            return dp[key];\\n        }\\n        // Srart fresh\\n        // no prev + no current + only future (may be)\\n        int ans1 = maxProduct(nums, index+1, INT_MIN, dp); \\n\\n        // prev + current + only future (may be)\\n        int k = prevMul==INT_MIN?1:prevMul;\\n        int ans2 = maxProduct(nums, index+1,  k*nums[index], dp);\\n\\n        // prev + no current + no future (because it is a subarray)\\n        // which means we can not take the future elements if we\\n        // do take the current and take the previous.\\n        int ans3 = prevMul;\\n        return dp[key] = max({ans3, ans1, ans2});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        unordered_map<string, int> dp;\\n        int ans = maxProduct(nums, 0, INT_MIN, dp);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 2034485,
                "content": [
                    {
                        "username": "yogiwaran2003",
                        "content": "why can't be the sub array be {3,4} or {2,4} it has the maximum product?\n"
                    },
                    {
                        "username": "kaylent",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] testcase moves this task from an interesting one to the edge-case-hell..."
                    },
                    {
                        "username": "anmay007",
                        "content": "I am failing at only one test case that is [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]  my output is 1981284352   and the expected one is1000000000.. I am not able to understand how i am getting this wrong..remaining all test cases are fine..please help"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "If(res == 1000000000) break;\\n\\nPut this base case in your loop\\nIt will surely be fixed"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "how to solve this test case\\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n??"
                    },
                    {
                        "username": "codepout",
                        "content": "Remove this testcase please, [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0], for everyone just add an edgecase to check for 1000000000 and return true. "
                    },
                    {
                        "username": "Sharad_pal",
                        "content": "My Recursive approach solution got accepted Successfully ,but when i copy pasted this testcase, it gave me Wrong Answer lol...is this testcase removed or something now?                                                                   [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nOutput\\n1981284352\\nExpected\\n1000000000"
                    },
                    {
                        "username": "caldempsey",
                        "content": "This is a doozy but its worth really having a go, you will come to learn that Kadanes prefix sum is the way to go and you will add it to your toolkit, but I tried a tonne of stuff, including filtering out all of the zeros and trying to move two pointers :D"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You only need to worry about the **zeros** and the **negative** values. `Hint`\\nReaching a zero should reset the current product. Otherwise, it will stay at 0. `Hint`\\nDividing two negative values gives a positive. `Hint`\\n\\nWith these in mind, you should be able to solve the problem by yourself. If you do, your follow-up would be cleaning up your code."
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "here is my code it is getting stuck in [-2] edge case\\n\\n public int maxProduct(int[] nums) {\\n        int count =0 ; \\n        for(int i =0;i<nums.length -1;i=i+2){\\n            int max = nums[i] + nums[i+1];\\n            if(nums.length != nums.length-1 && max > count){\\n                count=  max;\\n            }\\n            else {\\n                int maxelse = nums[nums.length-1] + nums[0];\\n                if(maxelse>count){\\n                    count = maxelse;\\n                }\\n\\n            }\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "abhinavsinha19",
                        "content": "I tried using recursion to solve the problem, but could not find a way to memoize it, can somebody help me with it or where I am lacking?\\n\\n```\\nclass Solution {\\n    int maxp = -1e9;\\npublic: \\n    void f(vector<int>& nums, int ind, int product) {\\n        if (ind == nums.size()) return;\\n\\n        maxp = max(maxp, product*nums[ind]);\\n\\n        f(nums, ind+1, product*nums[ind]);\\n        f(nums, ind+1, 1);\\n    }\\n\\n    int maxProduct(vector<int>& nums) {\\n        f(nums, 0, 1);\\n        return maxp;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "sobo",
                        "content": "Why this solution doesn\\'t work...It gets stuck at the last test case the I am not able to see the test case either.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int maxProduct(vector<int> &nums, int index, int prevMul, unordered_map<string, int> &dp) {\\n        if (index >= nums.size()) {\\n            return prevMul;\\n        }\\n        string key = to_string(index) + \":\" + to_string(prevMul);\\n        if (dp.find(key) != dp.end()) {\\n            return dp[key];\\n        }\\n        // Srart fresh\\n        // no prev + no current + only future (may be)\\n        int ans1 = maxProduct(nums, index+1, INT_MIN, dp); \\n\\n        // prev + current + only future (may be)\\n        int k = prevMul==INT_MIN?1:prevMul;\\n        int ans2 = maxProduct(nums, index+1,  k*nums[index], dp);\\n\\n        // prev + no current + no future (because it is a subarray)\\n        // which means we can not take the future elements if we\\n        // do take the current and take the previous.\\n        int ans3 = prevMul;\\n        return dp[key] = max({ans3, ans1, ans2});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        unordered_map<string, int> dp;\\n        int ans = maxProduct(nums, 0, INT_MIN, dp);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 2022668,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "it took me like 25min to solve this..using kadnes algorithm..."
                    },
                    {
                        "username": "mvp_amansingh",
                        "content": "All testcases passed  still giving TLE  , please help me \\n\\n\\nhere is the solution  \\n\\n `class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n\\n         int i, j , mx= INT_MIN, n= nums.size();\\n\\n        for(i=0;i<n;i++)\\n        {\\n            int s= 1;\\n            for(j=i;j<n;j++)\\n            {\\n                s= s*nums[j];\\n                //mx= max(s,mx);\\n                if(s>mx)\\n                {\\n                    mx=s;\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};`\\n\\nAll testcases passed but giving TLE ,what is wrong here"
                    },
                    {
                        "username": "kapil198",
                        "content": "The Brute Force  of that question is like subarray sum but  that solution does not satisfy the some test case.\n"
                    },
                    {
                        "username": "ANANYAAGARWAL3545325",
                        "content": "CRISP AND SHORT SOLUTION\\n\\n#include<iostream>\\nusing namespace std;\\nvoid productsubarray(int arr[],int n)\\n{\\n    int i=0;\\n    int j=i+1;\\n    int m=-1;\\n    while(i<n&&j<=n-1)\\n    {\\n        int p=1;\\n        p=p*arr[i]*arr[j];\\n        if(p>m)\\n        {\\n        m=p;\\n        }\\n        i++;\\n        j++;\\n    }\\n    cout<<m<<endl;\\n}\\nint main()\\n{\\n    int arr[100]={2,3,-2,4};\\n    int n=4;\\n    productsubarray(arr,n);\\n}\\nOUTPUT:  6\\nHOPE IT HELPED"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Tons of edge cases! Got an idea but it is very hard to pass all the test cases correctly, After some time i felt that I\\'m hard coding according to the test cases."
                    },
                    {
                        "username": "suman_saini",
                        "content": "how can i handle this corner case ? \\nanyone help me .\\nnums =[-2]\\nOutput\\n0\\nExpected\\n-2"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you can check if the size of the array is 1 then return that only element"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Can anyone please tell my why it is tagged as a Dynamic Programming problem?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m getting 190/190 testcases passed but TLE on a final empty testcase. \\nnums =\\nAnyone else having this problem? Gonna put a report in. I\\'m using c#."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@vatanyan](/vatanyan) Unfortunately no :( I did put a report in though for a missing testcase"
                    },
                    {
                        "username": "vatanyan",
                        "content": "I have the same problem.\\nAny news??"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "better>>\\nnotice the max subarray can be in left part then terminator and then the right array, here u can get the ans easily using kadens.\\nBut if your max prod sub array lies in right part, using above method will give the max prod of left subarray, so in that case u need to run the loop from right to left and store those prods,\\nT.c O(N), s.c> O(n)\\n\\nnow try to figure optimal solution. "
                    },
                    {
                        "username": "dotz",
                        "content": "If you think in the right direction, the solution actually isn\\'t all that unintuitive.\\n\\nTo guide your thought:\\n- Think of the most obvious subproblem...\\n- Maybe the max product of subarrays with a given ending index...\\n- Can you build a recurrence relation from that?\\n- Not really... Negative numbers are an issue...\\n- What happens when you multiply by negative number?\\n- Can you keep track of an additional subproblem to resolve this issue?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem does indeed lend itself well to dynamic programming due to its subproblem structure. Each subarray ending at a specific index influences the solutions for subsequent indices.\\n\\nHowever, as you\\'ve pointed out, negative numbers do complicate things. When you multiply by a negative number, the sign of the product flips. This means that a large negative product could become a large positive product if we multiply it by a negative number. \\n\\nTo address this issue, we need to keep track of not only the maximum product so far, but also the minimum product so far (which could be a large negative number). Thus, we have two subproblems to keep track of:\\n\\n1. `max_product[i]`: The maximum product of any subarray ending at index `i`.\\n2. `min_product[i]`: The minimum product (i.e., a large negative number) of any subarray ending at index `i`.\\n\\nFor each new number at index `i`, the maximum product is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number. Similarly, the minimum product at index `i` is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number.\\n\\nFinally, the answer is the maximum value in `max_product[]`. \\n\\nThis approach allows us to keep track of the current maximum and minimum products while also handling the sign-flipping nature of multiplication by negative numbers."
                    }
                ]
            },
            {
                "id": 2018334,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "it took me like 25min to solve this..using kadnes algorithm..."
                    },
                    {
                        "username": "mvp_amansingh",
                        "content": "All testcases passed  still giving TLE  , please help me \\n\\n\\nhere is the solution  \\n\\n `class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n\\n         int i, j , mx= INT_MIN, n= nums.size();\\n\\n        for(i=0;i<n;i++)\\n        {\\n            int s= 1;\\n            for(j=i;j<n;j++)\\n            {\\n                s= s*nums[j];\\n                //mx= max(s,mx);\\n                if(s>mx)\\n                {\\n                    mx=s;\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};`\\n\\nAll testcases passed but giving TLE ,what is wrong here"
                    },
                    {
                        "username": "kapil198",
                        "content": "The Brute Force  of that question is like subarray sum but  that solution does not satisfy the some test case.\n"
                    },
                    {
                        "username": "ANANYAAGARWAL3545325",
                        "content": "CRISP AND SHORT SOLUTION\\n\\n#include<iostream>\\nusing namespace std;\\nvoid productsubarray(int arr[],int n)\\n{\\n    int i=0;\\n    int j=i+1;\\n    int m=-1;\\n    while(i<n&&j<=n-1)\\n    {\\n        int p=1;\\n        p=p*arr[i]*arr[j];\\n        if(p>m)\\n        {\\n        m=p;\\n        }\\n        i++;\\n        j++;\\n    }\\n    cout<<m<<endl;\\n}\\nint main()\\n{\\n    int arr[100]={2,3,-2,4};\\n    int n=4;\\n    productsubarray(arr,n);\\n}\\nOUTPUT:  6\\nHOPE IT HELPED"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Tons of edge cases! Got an idea but it is very hard to pass all the test cases correctly, After some time i felt that I\\'m hard coding according to the test cases."
                    },
                    {
                        "username": "suman_saini",
                        "content": "how can i handle this corner case ? \\nanyone help me .\\nnums =[-2]\\nOutput\\n0\\nExpected\\n-2"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you can check if the size of the array is 1 then return that only element"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Can anyone please tell my why it is tagged as a Dynamic Programming problem?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m getting 190/190 testcases passed but TLE on a final empty testcase. \\nnums =\\nAnyone else having this problem? Gonna put a report in. I\\'m using c#."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@vatanyan](/vatanyan) Unfortunately no :( I did put a report in though for a missing testcase"
                    },
                    {
                        "username": "vatanyan",
                        "content": "I have the same problem.\\nAny news??"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "better>>\\nnotice the max subarray can be in left part then terminator and then the right array, here u can get the ans easily using kadens.\\nBut if your max prod sub array lies in right part, using above method will give the max prod of left subarray, so in that case u need to run the loop from right to left and store those prods,\\nT.c O(N), s.c> O(n)\\n\\nnow try to figure optimal solution. "
                    },
                    {
                        "username": "dotz",
                        "content": "If you think in the right direction, the solution actually isn\\'t all that unintuitive.\\n\\nTo guide your thought:\\n- Think of the most obvious subproblem...\\n- Maybe the max product of subarrays with a given ending index...\\n- Can you build a recurrence relation from that?\\n- Not really... Negative numbers are an issue...\\n- What happens when you multiply by negative number?\\n- Can you keep track of an additional subproblem to resolve this issue?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem does indeed lend itself well to dynamic programming due to its subproblem structure. Each subarray ending at a specific index influences the solutions for subsequent indices.\\n\\nHowever, as you\\'ve pointed out, negative numbers do complicate things. When you multiply by a negative number, the sign of the product flips. This means that a large negative product could become a large positive product if we multiply it by a negative number. \\n\\nTo address this issue, we need to keep track of not only the maximum product so far, but also the minimum product so far (which could be a large negative number). Thus, we have two subproblems to keep track of:\\n\\n1. `max_product[i]`: The maximum product of any subarray ending at index `i`.\\n2. `min_product[i]`: The minimum product (i.e., a large negative number) of any subarray ending at index `i`.\\n\\nFor each new number at index `i`, the maximum product is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number. Similarly, the minimum product at index `i` is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number.\\n\\nFinally, the answer is the maximum value in `max_product[]`. \\n\\nThis approach allows us to keep track of the current maximum and minimum products while also handling the sign-flipping nature of multiplication by negative numbers."
                    }
                ]
            },
            {
                "id": 2018219,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "it took me like 25min to solve this..using kadnes algorithm..."
                    },
                    {
                        "username": "mvp_amansingh",
                        "content": "All testcases passed  still giving TLE  , please help me \\n\\n\\nhere is the solution  \\n\\n `class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n\\n         int i, j , mx= INT_MIN, n= nums.size();\\n\\n        for(i=0;i<n;i++)\\n        {\\n            int s= 1;\\n            for(j=i;j<n;j++)\\n            {\\n                s= s*nums[j];\\n                //mx= max(s,mx);\\n                if(s>mx)\\n                {\\n                    mx=s;\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};`\\n\\nAll testcases passed but giving TLE ,what is wrong here"
                    },
                    {
                        "username": "kapil198",
                        "content": "The Brute Force  of that question is like subarray sum but  that solution does not satisfy the some test case.\n"
                    },
                    {
                        "username": "ANANYAAGARWAL3545325",
                        "content": "CRISP AND SHORT SOLUTION\\n\\n#include<iostream>\\nusing namespace std;\\nvoid productsubarray(int arr[],int n)\\n{\\n    int i=0;\\n    int j=i+1;\\n    int m=-1;\\n    while(i<n&&j<=n-1)\\n    {\\n        int p=1;\\n        p=p*arr[i]*arr[j];\\n        if(p>m)\\n        {\\n        m=p;\\n        }\\n        i++;\\n        j++;\\n    }\\n    cout<<m<<endl;\\n}\\nint main()\\n{\\n    int arr[100]={2,3,-2,4};\\n    int n=4;\\n    productsubarray(arr,n);\\n}\\nOUTPUT:  6\\nHOPE IT HELPED"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Tons of edge cases! Got an idea but it is very hard to pass all the test cases correctly, After some time i felt that I\\'m hard coding according to the test cases."
                    },
                    {
                        "username": "suman_saini",
                        "content": "how can i handle this corner case ? \\nanyone help me .\\nnums =[-2]\\nOutput\\n0\\nExpected\\n-2"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you can check if the size of the array is 1 then return that only element"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Can anyone please tell my why it is tagged as a Dynamic Programming problem?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m getting 190/190 testcases passed but TLE on a final empty testcase. \\nnums =\\nAnyone else having this problem? Gonna put a report in. I\\'m using c#."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@vatanyan](/vatanyan) Unfortunately no :( I did put a report in though for a missing testcase"
                    },
                    {
                        "username": "vatanyan",
                        "content": "I have the same problem.\\nAny news??"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "better>>\\nnotice the max subarray can be in left part then terminator and then the right array, here u can get the ans easily using kadens.\\nBut if your max prod sub array lies in right part, using above method will give the max prod of left subarray, so in that case u need to run the loop from right to left and store those prods,\\nT.c O(N), s.c> O(n)\\n\\nnow try to figure optimal solution. "
                    },
                    {
                        "username": "dotz",
                        "content": "If you think in the right direction, the solution actually isn\\'t all that unintuitive.\\n\\nTo guide your thought:\\n- Think of the most obvious subproblem...\\n- Maybe the max product of subarrays with a given ending index...\\n- Can you build a recurrence relation from that?\\n- Not really... Negative numbers are an issue...\\n- What happens when you multiply by negative number?\\n- Can you keep track of an additional subproblem to resolve this issue?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem does indeed lend itself well to dynamic programming due to its subproblem structure. Each subarray ending at a specific index influences the solutions for subsequent indices.\\n\\nHowever, as you\\'ve pointed out, negative numbers do complicate things. When you multiply by a negative number, the sign of the product flips. This means that a large negative product could become a large positive product if we multiply it by a negative number. \\n\\nTo address this issue, we need to keep track of not only the maximum product so far, but also the minimum product so far (which could be a large negative number). Thus, we have two subproblems to keep track of:\\n\\n1. `max_product[i]`: The maximum product of any subarray ending at index `i`.\\n2. `min_product[i]`: The minimum product (i.e., a large negative number) of any subarray ending at index `i`.\\n\\nFor each new number at index `i`, the maximum product is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number. Similarly, the minimum product at index `i` is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number.\\n\\nFinally, the answer is the maximum value in `max_product[]`. \\n\\nThis approach allows us to keep track of the current maximum and minimum products while also handling the sign-flipping nature of multiplication by negative numbers."
                    }
                ]
            },
            {
                "id": 2010923,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "it took me like 25min to solve this..using kadnes algorithm..."
                    },
                    {
                        "username": "mvp_amansingh",
                        "content": "All testcases passed  still giving TLE  , please help me \\n\\n\\nhere is the solution  \\n\\n `class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n\\n         int i, j , mx= INT_MIN, n= nums.size();\\n\\n        for(i=0;i<n;i++)\\n        {\\n            int s= 1;\\n            for(j=i;j<n;j++)\\n            {\\n                s= s*nums[j];\\n                //mx= max(s,mx);\\n                if(s>mx)\\n                {\\n                    mx=s;\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};`\\n\\nAll testcases passed but giving TLE ,what is wrong here"
                    },
                    {
                        "username": "kapil198",
                        "content": "The Brute Force  of that question is like subarray sum but  that solution does not satisfy the some test case.\n"
                    },
                    {
                        "username": "ANANYAAGARWAL3545325",
                        "content": "CRISP AND SHORT SOLUTION\\n\\n#include<iostream>\\nusing namespace std;\\nvoid productsubarray(int arr[],int n)\\n{\\n    int i=0;\\n    int j=i+1;\\n    int m=-1;\\n    while(i<n&&j<=n-1)\\n    {\\n        int p=1;\\n        p=p*arr[i]*arr[j];\\n        if(p>m)\\n        {\\n        m=p;\\n        }\\n        i++;\\n        j++;\\n    }\\n    cout<<m<<endl;\\n}\\nint main()\\n{\\n    int arr[100]={2,3,-2,4};\\n    int n=4;\\n    productsubarray(arr,n);\\n}\\nOUTPUT:  6\\nHOPE IT HELPED"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Tons of edge cases! Got an idea but it is very hard to pass all the test cases correctly, After some time i felt that I\\'m hard coding according to the test cases."
                    },
                    {
                        "username": "suman_saini",
                        "content": "how can i handle this corner case ? \\nanyone help me .\\nnums =[-2]\\nOutput\\n0\\nExpected\\n-2"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you can check if the size of the array is 1 then return that only element"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Can anyone please tell my why it is tagged as a Dynamic Programming problem?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m getting 190/190 testcases passed but TLE on a final empty testcase. \\nnums =\\nAnyone else having this problem? Gonna put a report in. I\\'m using c#."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@vatanyan](/vatanyan) Unfortunately no :( I did put a report in though for a missing testcase"
                    },
                    {
                        "username": "vatanyan",
                        "content": "I have the same problem.\\nAny news??"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "better>>\\nnotice the max subarray can be in left part then terminator and then the right array, here u can get the ans easily using kadens.\\nBut if your max prod sub array lies in right part, using above method will give the max prod of left subarray, so in that case u need to run the loop from right to left and store those prods,\\nT.c O(N), s.c> O(n)\\n\\nnow try to figure optimal solution. "
                    },
                    {
                        "username": "dotz",
                        "content": "If you think in the right direction, the solution actually isn\\'t all that unintuitive.\\n\\nTo guide your thought:\\n- Think of the most obvious subproblem...\\n- Maybe the max product of subarrays with a given ending index...\\n- Can you build a recurrence relation from that?\\n- Not really... Negative numbers are an issue...\\n- What happens when you multiply by negative number?\\n- Can you keep track of an additional subproblem to resolve this issue?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem does indeed lend itself well to dynamic programming due to its subproblem structure. Each subarray ending at a specific index influences the solutions for subsequent indices.\\n\\nHowever, as you\\'ve pointed out, negative numbers do complicate things. When you multiply by a negative number, the sign of the product flips. This means that a large negative product could become a large positive product if we multiply it by a negative number. \\n\\nTo address this issue, we need to keep track of not only the maximum product so far, but also the minimum product so far (which could be a large negative number). Thus, we have two subproblems to keep track of:\\n\\n1. `max_product[i]`: The maximum product of any subarray ending at index `i`.\\n2. `min_product[i]`: The minimum product (i.e., a large negative number) of any subarray ending at index `i`.\\n\\nFor each new number at index `i`, the maximum product is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number. Similarly, the minimum product at index `i` is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number.\\n\\nFinally, the answer is the maximum value in `max_product[]`. \\n\\nThis approach allows us to keep track of the current maximum and minimum products while also handling the sign-flipping nature of multiplication by negative numbers."
                    }
                ]
            },
            {
                "id": 1987331,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "it took me like 25min to solve this..using kadnes algorithm..."
                    },
                    {
                        "username": "mvp_amansingh",
                        "content": "All testcases passed  still giving TLE  , please help me \\n\\n\\nhere is the solution  \\n\\n `class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n\\n         int i, j , mx= INT_MIN, n= nums.size();\\n\\n        for(i=0;i<n;i++)\\n        {\\n            int s= 1;\\n            for(j=i;j<n;j++)\\n            {\\n                s= s*nums[j];\\n                //mx= max(s,mx);\\n                if(s>mx)\\n                {\\n                    mx=s;\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};`\\n\\nAll testcases passed but giving TLE ,what is wrong here"
                    },
                    {
                        "username": "kapil198",
                        "content": "The Brute Force  of that question is like subarray sum but  that solution does not satisfy the some test case.\n"
                    },
                    {
                        "username": "ANANYAAGARWAL3545325",
                        "content": "CRISP AND SHORT SOLUTION\\n\\n#include<iostream>\\nusing namespace std;\\nvoid productsubarray(int arr[],int n)\\n{\\n    int i=0;\\n    int j=i+1;\\n    int m=-1;\\n    while(i<n&&j<=n-1)\\n    {\\n        int p=1;\\n        p=p*arr[i]*arr[j];\\n        if(p>m)\\n        {\\n        m=p;\\n        }\\n        i++;\\n        j++;\\n    }\\n    cout<<m<<endl;\\n}\\nint main()\\n{\\n    int arr[100]={2,3,-2,4};\\n    int n=4;\\n    productsubarray(arr,n);\\n}\\nOUTPUT:  6\\nHOPE IT HELPED"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Tons of edge cases! Got an idea but it is very hard to pass all the test cases correctly, After some time i felt that I\\'m hard coding according to the test cases."
                    },
                    {
                        "username": "suman_saini",
                        "content": "how can i handle this corner case ? \\nanyone help me .\\nnums =[-2]\\nOutput\\n0\\nExpected\\n-2"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you can check if the size of the array is 1 then return that only element"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Can anyone please tell my why it is tagged as a Dynamic Programming problem?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m getting 190/190 testcases passed but TLE on a final empty testcase. \\nnums =\\nAnyone else having this problem? Gonna put a report in. I\\'m using c#."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@vatanyan](/vatanyan) Unfortunately no :( I did put a report in though for a missing testcase"
                    },
                    {
                        "username": "vatanyan",
                        "content": "I have the same problem.\\nAny news??"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "better>>\\nnotice the max subarray can be in left part then terminator and then the right array, here u can get the ans easily using kadens.\\nBut if your max prod sub array lies in right part, using above method will give the max prod of left subarray, so in that case u need to run the loop from right to left and store those prods,\\nT.c O(N), s.c> O(n)\\n\\nnow try to figure optimal solution. "
                    },
                    {
                        "username": "dotz",
                        "content": "If you think in the right direction, the solution actually isn\\'t all that unintuitive.\\n\\nTo guide your thought:\\n- Think of the most obvious subproblem...\\n- Maybe the max product of subarrays with a given ending index...\\n- Can you build a recurrence relation from that?\\n- Not really... Negative numbers are an issue...\\n- What happens when you multiply by negative number?\\n- Can you keep track of an additional subproblem to resolve this issue?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem does indeed lend itself well to dynamic programming due to its subproblem structure. Each subarray ending at a specific index influences the solutions for subsequent indices.\\n\\nHowever, as you\\'ve pointed out, negative numbers do complicate things. When you multiply by a negative number, the sign of the product flips. This means that a large negative product could become a large positive product if we multiply it by a negative number. \\n\\nTo address this issue, we need to keep track of not only the maximum product so far, but also the minimum product so far (which could be a large negative number). Thus, we have two subproblems to keep track of:\\n\\n1. `max_product[i]`: The maximum product of any subarray ending at index `i`.\\n2. `min_product[i]`: The minimum product (i.e., a large negative number) of any subarray ending at index `i`.\\n\\nFor each new number at index `i`, the maximum product is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number. Similarly, the minimum product at index `i` is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number.\\n\\nFinally, the answer is the maximum value in `max_product[]`. \\n\\nThis approach allows us to keep track of the current maximum and minimum products while also handling the sign-flipping nature of multiplication by negative numbers."
                    }
                ]
            },
            {
                "id": 1983746,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "it took me like 25min to solve this..using kadnes algorithm..."
                    },
                    {
                        "username": "mvp_amansingh",
                        "content": "All testcases passed  still giving TLE  , please help me \\n\\n\\nhere is the solution  \\n\\n `class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n\\n         int i, j , mx= INT_MIN, n= nums.size();\\n\\n        for(i=0;i<n;i++)\\n        {\\n            int s= 1;\\n            for(j=i;j<n;j++)\\n            {\\n                s= s*nums[j];\\n                //mx= max(s,mx);\\n                if(s>mx)\\n                {\\n                    mx=s;\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};`\\n\\nAll testcases passed but giving TLE ,what is wrong here"
                    },
                    {
                        "username": "kapil198",
                        "content": "The Brute Force  of that question is like subarray sum but  that solution does not satisfy the some test case.\n"
                    },
                    {
                        "username": "ANANYAAGARWAL3545325",
                        "content": "CRISP AND SHORT SOLUTION\\n\\n#include<iostream>\\nusing namespace std;\\nvoid productsubarray(int arr[],int n)\\n{\\n    int i=0;\\n    int j=i+1;\\n    int m=-1;\\n    while(i<n&&j<=n-1)\\n    {\\n        int p=1;\\n        p=p*arr[i]*arr[j];\\n        if(p>m)\\n        {\\n        m=p;\\n        }\\n        i++;\\n        j++;\\n    }\\n    cout<<m<<endl;\\n}\\nint main()\\n{\\n    int arr[100]={2,3,-2,4};\\n    int n=4;\\n    productsubarray(arr,n);\\n}\\nOUTPUT:  6\\nHOPE IT HELPED"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Tons of edge cases! Got an idea but it is very hard to pass all the test cases correctly, After some time i felt that I\\'m hard coding according to the test cases."
                    },
                    {
                        "username": "suman_saini",
                        "content": "how can i handle this corner case ? \\nanyone help me .\\nnums =[-2]\\nOutput\\n0\\nExpected\\n-2"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you can check if the size of the array is 1 then return that only element"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Can anyone please tell my why it is tagged as a Dynamic Programming problem?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m getting 190/190 testcases passed but TLE on a final empty testcase. \\nnums =\\nAnyone else having this problem? Gonna put a report in. I\\'m using c#."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@vatanyan](/vatanyan) Unfortunately no :( I did put a report in though for a missing testcase"
                    },
                    {
                        "username": "vatanyan",
                        "content": "I have the same problem.\\nAny news??"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "better>>\\nnotice the max subarray can be in left part then terminator and then the right array, here u can get the ans easily using kadens.\\nBut if your max prod sub array lies in right part, using above method will give the max prod of left subarray, so in that case u need to run the loop from right to left and store those prods,\\nT.c O(N), s.c> O(n)\\n\\nnow try to figure optimal solution. "
                    },
                    {
                        "username": "dotz",
                        "content": "If you think in the right direction, the solution actually isn\\'t all that unintuitive.\\n\\nTo guide your thought:\\n- Think of the most obvious subproblem...\\n- Maybe the max product of subarrays with a given ending index...\\n- Can you build a recurrence relation from that?\\n- Not really... Negative numbers are an issue...\\n- What happens when you multiply by negative number?\\n- Can you keep track of an additional subproblem to resolve this issue?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem does indeed lend itself well to dynamic programming due to its subproblem structure. Each subarray ending at a specific index influences the solutions for subsequent indices.\\n\\nHowever, as you\\'ve pointed out, negative numbers do complicate things. When you multiply by a negative number, the sign of the product flips. This means that a large negative product could become a large positive product if we multiply it by a negative number. \\n\\nTo address this issue, we need to keep track of not only the maximum product so far, but also the minimum product so far (which could be a large negative number). Thus, we have two subproblems to keep track of:\\n\\n1. `max_product[i]`: The maximum product of any subarray ending at index `i`.\\n2. `min_product[i]`: The minimum product (i.e., a large negative number) of any subarray ending at index `i`.\\n\\nFor each new number at index `i`, the maximum product is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number. Similarly, the minimum product at index `i` is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number.\\n\\nFinally, the answer is the maximum value in `max_product[]`. \\n\\nThis approach allows us to keep track of the current maximum and minimum products while also handling the sign-flipping nature of multiplication by negative numbers."
                    }
                ]
            },
            {
                "id": 1970589,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "it took me like 25min to solve this..using kadnes algorithm..."
                    },
                    {
                        "username": "mvp_amansingh",
                        "content": "All testcases passed  still giving TLE  , please help me \\n\\n\\nhere is the solution  \\n\\n `class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n\\n         int i, j , mx= INT_MIN, n= nums.size();\\n\\n        for(i=0;i<n;i++)\\n        {\\n            int s= 1;\\n            for(j=i;j<n;j++)\\n            {\\n                s= s*nums[j];\\n                //mx= max(s,mx);\\n                if(s>mx)\\n                {\\n                    mx=s;\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};`\\n\\nAll testcases passed but giving TLE ,what is wrong here"
                    },
                    {
                        "username": "kapil198",
                        "content": "The Brute Force  of that question is like subarray sum but  that solution does not satisfy the some test case.\n"
                    },
                    {
                        "username": "ANANYAAGARWAL3545325",
                        "content": "CRISP AND SHORT SOLUTION\\n\\n#include<iostream>\\nusing namespace std;\\nvoid productsubarray(int arr[],int n)\\n{\\n    int i=0;\\n    int j=i+1;\\n    int m=-1;\\n    while(i<n&&j<=n-1)\\n    {\\n        int p=1;\\n        p=p*arr[i]*arr[j];\\n        if(p>m)\\n        {\\n        m=p;\\n        }\\n        i++;\\n        j++;\\n    }\\n    cout<<m<<endl;\\n}\\nint main()\\n{\\n    int arr[100]={2,3,-2,4};\\n    int n=4;\\n    productsubarray(arr,n);\\n}\\nOUTPUT:  6\\nHOPE IT HELPED"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Tons of edge cases! Got an idea but it is very hard to pass all the test cases correctly, After some time i felt that I\\'m hard coding according to the test cases."
                    },
                    {
                        "username": "suman_saini",
                        "content": "how can i handle this corner case ? \\nanyone help me .\\nnums =[-2]\\nOutput\\n0\\nExpected\\n-2"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you can check if the size of the array is 1 then return that only element"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Can anyone please tell my why it is tagged as a Dynamic Programming problem?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m getting 190/190 testcases passed but TLE on a final empty testcase. \\nnums =\\nAnyone else having this problem? Gonna put a report in. I\\'m using c#."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@vatanyan](/vatanyan) Unfortunately no :( I did put a report in though for a missing testcase"
                    },
                    {
                        "username": "vatanyan",
                        "content": "I have the same problem.\\nAny news??"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "better>>\\nnotice the max subarray can be in left part then terminator and then the right array, here u can get the ans easily using kadens.\\nBut if your max prod sub array lies in right part, using above method will give the max prod of left subarray, so in that case u need to run the loop from right to left and store those prods,\\nT.c O(N), s.c> O(n)\\n\\nnow try to figure optimal solution. "
                    },
                    {
                        "username": "dotz",
                        "content": "If you think in the right direction, the solution actually isn\\'t all that unintuitive.\\n\\nTo guide your thought:\\n- Think of the most obvious subproblem...\\n- Maybe the max product of subarrays with a given ending index...\\n- Can you build a recurrence relation from that?\\n- Not really... Negative numbers are an issue...\\n- What happens when you multiply by negative number?\\n- Can you keep track of an additional subproblem to resolve this issue?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem does indeed lend itself well to dynamic programming due to its subproblem structure. Each subarray ending at a specific index influences the solutions for subsequent indices.\\n\\nHowever, as you\\'ve pointed out, negative numbers do complicate things. When you multiply by a negative number, the sign of the product flips. This means that a large negative product could become a large positive product if we multiply it by a negative number. \\n\\nTo address this issue, we need to keep track of not only the maximum product so far, but also the minimum product so far (which could be a large negative number). Thus, we have two subproblems to keep track of:\\n\\n1. `max_product[i]`: The maximum product of any subarray ending at index `i`.\\n2. `min_product[i]`: The minimum product (i.e., a large negative number) of any subarray ending at index `i`.\\n\\nFor each new number at index `i`, the maximum product is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number. Similarly, the minimum product at index `i` is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number.\\n\\nFinally, the answer is the maximum value in `max_product[]`. \\n\\nThis approach allows us to keep track of the current maximum and minimum products while also handling the sign-flipping nature of multiplication by negative numbers."
                    }
                ]
            },
            {
                "id": 1951030,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "it took me like 25min to solve this..using kadnes algorithm..."
                    },
                    {
                        "username": "mvp_amansingh",
                        "content": "All testcases passed  still giving TLE  , please help me \\n\\n\\nhere is the solution  \\n\\n `class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n\\n         int i, j , mx= INT_MIN, n= nums.size();\\n\\n        for(i=0;i<n;i++)\\n        {\\n            int s= 1;\\n            for(j=i;j<n;j++)\\n            {\\n                s= s*nums[j];\\n                //mx= max(s,mx);\\n                if(s>mx)\\n                {\\n                    mx=s;\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};`\\n\\nAll testcases passed but giving TLE ,what is wrong here"
                    },
                    {
                        "username": "kapil198",
                        "content": "The Brute Force  of that question is like subarray sum but  that solution does not satisfy the some test case.\n"
                    },
                    {
                        "username": "ANANYAAGARWAL3545325",
                        "content": "CRISP AND SHORT SOLUTION\\n\\n#include<iostream>\\nusing namespace std;\\nvoid productsubarray(int arr[],int n)\\n{\\n    int i=0;\\n    int j=i+1;\\n    int m=-1;\\n    while(i<n&&j<=n-1)\\n    {\\n        int p=1;\\n        p=p*arr[i]*arr[j];\\n        if(p>m)\\n        {\\n        m=p;\\n        }\\n        i++;\\n        j++;\\n    }\\n    cout<<m<<endl;\\n}\\nint main()\\n{\\n    int arr[100]={2,3,-2,4};\\n    int n=4;\\n    productsubarray(arr,n);\\n}\\nOUTPUT:  6\\nHOPE IT HELPED"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Tons of edge cases! Got an idea but it is very hard to pass all the test cases correctly, After some time i felt that I\\'m hard coding according to the test cases."
                    },
                    {
                        "username": "suman_saini",
                        "content": "how can i handle this corner case ? \\nanyone help me .\\nnums =[-2]\\nOutput\\n0\\nExpected\\n-2"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you can check if the size of the array is 1 then return that only element"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Can anyone please tell my why it is tagged as a Dynamic Programming problem?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m getting 190/190 testcases passed but TLE on a final empty testcase. \\nnums =\\nAnyone else having this problem? Gonna put a report in. I\\'m using c#."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@vatanyan](/vatanyan) Unfortunately no :( I did put a report in though for a missing testcase"
                    },
                    {
                        "username": "vatanyan",
                        "content": "I have the same problem.\\nAny news??"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "better>>\\nnotice the max subarray can be in left part then terminator and then the right array, here u can get the ans easily using kadens.\\nBut if your max prod sub array lies in right part, using above method will give the max prod of left subarray, so in that case u need to run the loop from right to left and store those prods,\\nT.c O(N), s.c> O(n)\\n\\nnow try to figure optimal solution. "
                    },
                    {
                        "username": "dotz",
                        "content": "If you think in the right direction, the solution actually isn\\'t all that unintuitive.\\n\\nTo guide your thought:\\n- Think of the most obvious subproblem...\\n- Maybe the max product of subarrays with a given ending index...\\n- Can you build a recurrence relation from that?\\n- Not really... Negative numbers are an issue...\\n- What happens when you multiply by negative number?\\n- Can you keep track of an additional subproblem to resolve this issue?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem does indeed lend itself well to dynamic programming due to its subproblem structure. Each subarray ending at a specific index influences the solutions for subsequent indices.\\n\\nHowever, as you\\'ve pointed out, negative numbers do complicate things. When you multiply by a negative number, the sign of the product flips. This means that a large negative product could become a large positive product if we multiply it by a negative number. \\n\\nTo address this issue, we need to keep track of not only the maximum product so far, but also the minimum product so far (which could be a large negative number). Thus, we have two subproblems to keep track of:\\n\\n1. `max_product[i]`: The maximum product of any subarray ending at index `i`.\\n2. `min_product[i]`: The minimum product (i.e., a large negative number) of any subarray ending at index `i`.\\n\\nFor each new number at index `i`, the maximum product is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number. Similarly, the minimum product at index `i` is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number.\\n\\nFinally, the answer is the maximum value in `max_product[]`. \\n\\nThis approach allows us to keep track of the current maximum and minimum products while also handling the sign-flipping nature of multiplication by negative numbers."
                    }
                ]
            },
            {
                "id": 1945040,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "it took me like 25min to solve this..using kadnes algorithm..."
                    },
                    {
                        "username": "mvp_amansingh",
                        "content": "All testcases passed  still giving TLE  , please help me \\n\\n\\nhere is the solution  \\n\\n `class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n\\n         int i, j , mx= INT_MIN, n= nums.size();\\n\\n        for(i=0;i<n;i++)\\n        {\\n            int s= 1;\\n            for(j=i;j<n;j++)\\n            {\\n                s= s*nums[j];\\n                //mx= max(s,mx);\\n                if(s>mx)\\n                {\\n                    mx=s;\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};`\\n\\nAll testcases passed but giving TLE ,what is wrong here"
                    },
                    {
                        "username": "kapil198",
                        "content": "The Brute Force  of that question is like subarray sum but  that solution does not satisfy the some test case.\n"
                    },
                    {
                        "username": "ANANYAAGARWAL3545325",
                        "content": "CRISP AND SHORT SOLUTION\\n\\n#include<iostream>\\nusing namespace std;\\nvoid productsubarray(int arr[],int n)\\n{\\n    int i=0;\\n    int j=i+1;\\n    int m=-1;\\n    while(i<n&&j<=n-1)\\n    {\\n        int p=1;\\n        p=p*arr[i]*arr[j];\\n        if(p>m)\\n        {\\n        m=p;\\n        }\\n        i++;\\n        j++;\\n    }\\n    cout<<m<<endl;\\n}\\nint main()\\n{\\n    int arr[100]={2,3,-2,4};\\n    int n=4;\\n    productsubarray(arr,n);\\n}\\nOUTPUT:  6\\nHOPE IT HELPED"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Tons of edge cases! Got an idea but it is very hard to pass all the test cases correctly, After some time i felt that I\\'m hard coding according to the test cases."
                    },
                    {
                        "username": "suman_saini",
                        "content": "how can i handle this corner case ? \\nanyone help me .\\nnums =[-2]\\nOutput\\n0\\nExpected\\n-2"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you can check if the size of the array is 1 then return that only element"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Can anyone please tell my why it is tagged as a Dynamic Programming problem?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m getting 190/190 testcases passed but TLE on a final empty testcase. \\nnums =\\nAnyone else having this problem? Gonna put a report in. I\\'m using c#."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@vatanyan](/vatanyan) Unfortunately no :( I did put a report in though for a missing testcase"
                    },
                    {
                        "username": "vatanyan",
                        "content": "I have the same problem.\\nAny news??"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "better>>\\nnotice the max subarray can be in left part then terminator and then the right array, here u can get the ans easily using kadens.\\nBut if your max prod sub array lies in right part, using above method will give the max prod of left subarray, so in that case u need to run the loop from right to left and store those prods,\\nT.c O(N), s.c> O(n)\\n\\nnow try to figure optimal solution. "
                    },
                    {
                        "username": "dotz",
                        "content": "If you think in the right direction, the solution actually isn\\'t all that unintuitive.\\n\\nTo guide your thought:\\n- Think of the most obvious subproblem...\\n- Maybe the max product of subarrays with a given ending index...\\n- Can you build a recurrence relation from that?\\n- Not really... Negative numbers are an issue...\\n- What happens when you multiply by negative number?\\n- Can you keep track of an additional subproblem to resolve this issue?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem does indeed lend itself well to dynamic programming due to its subproblem structure. Each subarray ending at a specific index influences the solutions for subsequent indices.\\n\\nHowever, as you\\'ve pointed out, negative numbers do complicate things. When you multiply by a negative number, the sign of the product flips. This means that a large negative product could become a large positive product if we multiply it by a negative number. \\n\\nTo address this issue, we need to keep track of not only the maximum product so far, but also the minimum product so far (which could be a large negative number). Thus, we have two subproblems to keep track of:\\n\\n1. `max_product[i]`: The maximum product of any subarray ending at index `i`.\\n2. `min_product[i]`: The minimum product (i.e., a large negative number) of any subarray ending at index `i`.\\n\\nFor each new number at index `i`, the maximum product is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number. Similarly, the minimum product at index `i` is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number.\\n\\nFinally, the answer is the maximum value in `max_product[]`. \\n\\nThis approach allows us to keep track of the current maximum and minimum products while also handling the sign-flipping nature of multiplication by negative numbers."
                    }
                ]
            },
            {
                "id": 1944132,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "it took me like 25min to solve this..using kadnes algorithm..."
                    },
                    {
                        "username": "mvp_amansingh",
                        "content": "All testcases passed  still giving TLE  , please help me \\n\\n\\nhere is the solution  \\n\\n `class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n\\n         int i, j , mx= INT_MIN, n= nums.size();\\n\\n        for(i=0;i<n;i++)\\n        {\\n            int s= 1;\\n            for(j=i;j<n;j++)\\n            {\\n                s= s*nums[j];\\n                //mx= max(s,mx);\\n                if(s>mx)\\n                {\\n                    mx=s;\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};`\\n\\nAll testcases passed but giving TLE ,what is wrong here"
                    },
                    {
                        "username": "kapil198",
                        "content": "The Brute Force  of that question is like subarray sum but  that solution does not satisfy the some test case.\n"
                    },
                    {
                        "username": "ANANYAAGARWAL3545325",
                        "content": "CRISP AND SHORT SOLUTION\\n\\n#include<iostream>\\nusing namespace std;\\nvoid productsubarray(int arr[],int n)\\n{\\n    int i=0;\\n    int j=i+1;\\n    int m=-1;\\n    while(i<n&&j<=n-1)\\n    {\\n        int p=1;\\n        p=p*arr[i]*arr[j];\\n        if(p>m)\\n        {\\n        m=p;\\n        }\\n        i++;\\n        j++;\\n    }\\n    cout<<m<<endl;\\n}\\nint main()\\n{\\n    int arr[100]={2,3,-2,4};\\n    int n=4;\\n    productsubarray(arr,n);\\n}\\nOUTPUT:  6\\nHOPE IT HELPED"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Tons of edge cases! Got an idea but it is very hard to pass all the test cases correctly, After some time i felt that I\\'m hard coding according to the test cases."
                    },
                    {
                        "username": "suman_saini",
                        "content": "how can i handle this corner case ? \\nanyone help me .\\nnums =[-2]\\nOutput\\n0\\nExpected\\n-2"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you can check if the size of the array is 1 then return that only element"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Can anyone please tell my why it is tagged as a Dynamic Programming problem?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m getting 190/190 testcases passed but TLE on a final empty testcase. \\nnums =\\nAnyone else having this problem? Gonna put a report in. I\\'m using c#."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@vatanyan](/vatanyan) Unfortunately no :( I did put a report in though for a missing testcase"
                    },
                    {
                        "username": "vatanyan",
                        "content": "I have the same problem.\\nAny news??"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "better>>\\nnotice the max subarray can be in left part then terminator and then the right array, here u can get the ans easily using kadens.\\nBut if your max prod sub array lies in right part, using above method will give the max prod of left subarray, so in that case u need to run the loop from right to left and store those prods,\\nT.c O(N), s.c> O(n)\\n\\nnow try to figure optimal solution. "
                    },
                    {
                        "username": "dotz",
                        "content": "If you think in the right direction, the solution actually isn\\'t all that unintuitive.\\n\\nTo guide your thought:\\n- Think of the most obvious subproblem...\\n- Maybe the max product of subarrays with a given ending index...\\n- Can you build a recurrence relation from that?\\n- Not really... Negative numbers are an issue...\\n- What happens when you multiply by negative number?\\n- Can you keep track of an additional subproblem to resolve this issue?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem does indeed lend itself well to dynamic programming due to its subproblem structure. Each subarray ending at a specific index influences the solutions for subsequent indices.\\n\\nHowever, as you\\'ve pointed out, negative numbers do complicate things. When you multiply by a negative number, the sign of the product flips. This means that a large negative product could become a large positive product if we multiply it by a negative number. \\n\\nTo address this issue, we need to keep track of not only the maximum product so far, but also the minimum product so far (which could be a large negative number). Thus, we have two subproblems to keep track of:\\n\\n1. `max_product[i]`: The maximum product of any subarray ending at index `i`.\\n2. `min_product[i]`: The minimum product (i.e., a large negative number) of any subarray ending at index `i`.\\n\\nFor each new number at index `i`, the maximum product is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number. Similarly, the minimum product at index `i` is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number.\\n\\nFinally, the answer is the maximum value in `max_product[]`. \\n\\nThis approach allows us to keep track of the current maximum and minimum products while also handling the sign-flipping nature of multiplication by negative numbers."
                    }
                ]
            },
            {
                "id": 1923425,
                "content": [
                    {
                        "username": "NunoLealF",
                        "content": "These last few test cases, oh my *god*."
                    },
                    {
                        "username": "sahilkumar32755",
                        "content": "// Second Easy Method:\\n//     vector<int> ptr(100000,0);\\n\\n    //     for(int i = 0 ;i<nums.size();i++){\\n    //         ptr[nums[i]]++;\\n    //     }\\n    //     vector<int> ans;\\n    //     for(int i = 0;i<100000;i++){\\n    //         if(ptr[i] == 2){\\n    //             ans.push_back(i);\\n    //         }\\n    //     }\\n    // return ans;"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "Some tips!\\n\\n1.  Can you use Kadane\\'s Algo here?\\n2.  How\\'ll you handle the negative elements?\\n3.  Is keep tracking of Maximum Product enough?"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "https://leetcode.com/problems/maximum-product-subarray/solutions/3554945/modified-kadane-s-algorithm-c-beginner-friendly/"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "is empty array a subarray?"
                    },
                    {
                        "username": "zalars",
                        "content": "What is this mean? -\n\nTime Limit Exceeded (190 / 190 testcases passed)\n\nLast Executed Input\n`nums =`\n\n1) all testcases passed or not?\n2) empty array?"
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@jackbb147](/jackbb147) too slow for what?!?! It has passed all non-empty-input testcases and falls on the empty-input one??? I have the same problem and really do not know understand what is the problem.\\nI have tried to use that 190\\'th test as a case and then ran (instead of submit), and it works, but when I am submitting it falls??"
                    },
                    {
                        "username": "jackbb147",
                        "content": "I have this same issue. I used brute force and it\\'s probably too slow "
                    },
                    {
                        "username": "karunakarvarada73",
                        "content": "How many  members are  commenting for upvote \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "Consider checking min and max product you can get. Also think how this helps with negative numbers"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "What is a subarray in this case? \\nIn set theory all combinations are a sub set can anyone explain"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "a few things that I thought which helped me arrive at the solution\\n1. for every index , we have two choices, either to include it , or to not include it\\n2. sometimes, even though including or not including an element may lead to a local minimum it can even cause a global maximum\\n3. hence what really matters is the magnitude of the element. even the smallest negative product with a maximum magnitude could lead to an optimum solution\\n4. the fact that the array needs to be contiguous makes it easier "
                    },
                    {
                        "username": "Princesah999",
                        "content": "those who trying to solve this using kanades algo!!"
                    }
                ]
            },
            {
                "id": 1919864,
                "content": [
                    {
                        "username": "NunoLealF",
                        "content": "These last few test cases, oh my *god*."
                    },
                    {
                        "username": "sahilkumar32755",
                        "content": "// Second Easy Method:\\n//     vector<int> ptr(100000,0);\\n\\n    //     for(int i = 0 ;i<nums.size();i++){\\n    //         ptr[nums[i]]++;\\n    //     }\\n    //     vector<int> ans;\\n    //     for(int i = 0;i<100000;i++){\\n    //         if(ptr[i] == 2){\\n    //             ans.push_back(i);\\n    //         }\\n    //     }\\n    // return ans;"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "Some tips!\\n\\n1.  Can you use Kadane\\'s Algo here?\\n2.  How\\'ll you handle the negative elements?\\n3.  Is keep tracking of Maximum Product enough?"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "https://leetcode.com/problems/maximum-product-subarray/solutions/3554945/modified-kadane-s-algorithm-c-beginner-friendly/"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "is empty array a subarray?"
                    },
                    {
                        "username": "zalars",
                        "content": "What is this mean? -\n\nTime Limit Exceeded (190 / 190 testcases passed)\n\nLast Executed Input\n`nums =`\n\n1) all testcases passed or not?\n2) empty array?"
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@jackbb147](/jackbb147) too slow for what?!?! It has passed all non-empty-input testcases and falls on the empty-input one??? I have the same problem and really do not know understand what is the problem.\\nI have tried to use that 190\\'th test as a case and then ran (instead of submit), and it works, but when I am submitting it falls??"
                    },
                    {
                        "username": "jackbb147",
                        "content": "I have this same issue. I used brute force and it\\'s probably too slow "
                    },
                    {
                        "username": "karunakarvarada73",
                        "content": "How many  members are  commenting for upvote \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "Consider checking min and max product you can get. Also think how this helps with negative numbers"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "What is a subarray in this case? \\nIn set theory all combinations are a sub set can anyone explain"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "a few things that I thought which helped me arrive at the solution\\n1. for every index , we have two choices, either to include it , or to not include it\\n2. sometimes, even though including or not including an element may lead to a local minimum it can even cause a global maximum\\n3. hence what really matters is the magnitude of the element. even the smallest negative product with a maximum magnitude could lead to an optimum solution\\n4. the fact that the array needs to be contiguous makes it easier "
                    },
                    {
                        "username": "Princesah999",
                        "content": "those who trying to solve this using kanades algo!!"
                    }
                ]
            },
            {
                "id": 1903102,
                "content": [
                    {
                        "username": "NunoLealF",
                        "content": "These last few test cases, oh my *god*."
                    },
                    {
                        "username": "sahilkumar32755",
                        "content": "// Second Easy Method:\\n//     vector<int> ptr(100000,0);\\n\\n    //     for(int i = 0 ;i<nums.size();i++){\\n    //         ptr[nums[i]]++;\\n    //     }\\n    //     vector<int> ans;\\n    //     for(int i = 0;i<100000;i++){\\n    //         if(ptr[i] == 2){\\n    //             ans.push_back(i);\\n    //         }\\n    //     }\\n    // return ans;"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "Some tips!\\n\\n1.  Can you use Kadane\\'s Algo here?\\n2.  How\\'ll you handle the negative elements?\\n3.  Is keep tracking of Maximum Product enough?"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "https://leetcode.com/problems/maximum-product-subarray/solutions/3554945/modified-kadane-s-algorithm-c-beginner-friendly/"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "is empty array a subarray?"
                    },
                    {
                        "username": "zalars",
                        "content": "What is this mean? -\n\nTime Limit Exceeded (190 / 190 testcases passed)\n\nLast Executed Input\n`nums =`\n\n1) all testcases passed or not?\n2) empty array?"
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@jackbb147](/jackbb147) too slow for what?!?! It has passed all non-empty-input testcases and falls on the empty-input one??? I have the same problem and really do not know understand what is the problem.\\nI have tried to use that 190\\'th test as a case and then ran (instead of submit), and it works, but when I am submitting it falls??"
                    },
                    {
                        "username": "jackbb147",
                        "content": "I have this same issue. I used brute force and it\\'s probably too slow "
                    },
                    {
                        "username": "karunakarvarada73",
                        "content": "How many  members are  commenting for upvote \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "Consider checking min and max product you can get. Also think how this helps with negative numbers"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "What is a subarray in this case? \\nIn set theory all combinations are a sub set can anyone explain"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "a few things that I thought which helped me arrive at the solution\\n1. for every index , we have two choices, either to include it , or to not include it\\n2. sometimes, even though including or not including an element may lead to a local minimum it can even cause a global maximum\\n3. hence what really matters is the magnitude of the element. even the smallest negative product with a maximum magnitude could lead to an optimum solution\\n4. the fact that the array needs to be contiguous makes it easier "
                    },
                    {
                        "username": "Princesah999",
                        "content": "those who trying to solve this using kanades algo!!"
                    }
                ]
            },
            {
                "id": 1877378,
                "content": [
                    {
                        "username": "NunoLealF",
                        "content": "These last few test cases, oh my *god*."
                    },
                    {
                        "username": "sahilkumar32755",
                        "content": "// Second Easy Method:\\n//     vector<int> ptr(100000,0);\\n\\n    //     for(int i = 0 ;i<nums.size();i++){\\n    //         ptr[nums[i]]++;\\n    //     }\\n    //     vector<int> ans;\\n    //     for(int i = 0;i<100000;i++){\\n    //         if(ptr[i] == 2){\\n    //             ans.push_back(i);\\n    //         }\\n    //     }\\n    // return ans;"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "Some tips!\\n\\n1.  Can you use Kadane\\'s Algo here?\\n2.  How\\'ll you handle the negative elements?\\n3.  Is keep tracking of Maximum Product enough?"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "https://leetcode.com/problems/maximum-product-subarray/solutions/3554945/modified-kadane-s-algorithm-c-beginner-friendly/"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "is empty array a subarray?"
                    },
                    {
                        "username": "zalars",
                        "content": "What is this mean? -\n\nTime Limit Exceeded (190 / 190 testcases passed)\n\nLast Executed Input\n`nums =`\n\n1) all testcases passed or not?\n2) empty array?"
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@jackbb147](/jackbb147) too slow for what?!?! It has passed all non-empty-input testcases and falls on the empty-input one??? I have the same problem and really do not know understand what is the problem.\\nI have tried to use that 190\\'th test as a case and then ran (instead of submit), and it works, but when I am submitting it falls??"
                    },
                    {
                        "username": "jackbb147",
                        "content": "I have this same issue. I used brute force and it\\'s probably too slow "
                    },
                    {
                        "username": "karunakarvarada73",
                        "content": "How many  members are  commenting for upvote \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "Consider checking min and max product you can get. Also think how this helps with negative numbers"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "What is a subarray in this case? \\nIn set theory all combinations are a sub set can anyone explain"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "a few things that I thought which helped me arrive at the solution\\n1. for every index , we have two choices, either to include it , or to not include it\\n2. sometimes, even though including or not including an element may lead to a local minimum it can even cause a global maximum\\n3. hence what really matters is the magnitude of the element. even the smallest negative product with a maximum magnitude could lead to an optimum solution\\n4. the fact that the array needs to be contiguous makes it easier "
                    },
                    {
                        "username": "Princesah999",
                        "content": "those who trying to solve this using kanades algo!!"
                    }
                ]
            },
            {
                "id": 1870961,
                "content": [
                    {
                        "username": "NunoLealF",
                        "content": "These last few test cases, oh my *god*."
                    },
                    {
                        "username": "sahilkumar32755",
                        "content": "// Second Easy Method:\\n//     vector<int> ptr(100000,0);\\n\\n    //     for(int i = 0 ;i<nums.size();i++){\\n    //         ptr[nums[i]]++;\\n    //     }\\n    //     vector<int> ans;\\n    //     for(int i = 0;i<100000;i++){\\n    //         if(ptr[i] == 2){\\n    //             ans.push_back(i);\\n    //         }\\n    //     }\\n    // return ans;"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "Some tips!\\n\\n1.  Can you use Kadane\\'s Algo here?\\n2.  How\\'ll you handle the negative elements?\\n3.  Is keep tracking of Maximum Product enough?"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "https://leetcode.com/problems/maximum-product-subarray/solutions/3554945/modified-kadane-s-algorithm-c-beginner-friendly/"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "is empty array a subarray?"
                    },
                    {
                        "username": "zalars",
                        "content": "What is this mean? -\n\nTime Limit Exceeded (190 / 190 testcases passed)\n\nLast Executed Input\n`nums =`\n\n1) all testcases passed or not?\n2) empty array?"
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@jackbb147](/jackbb147) too slow for what?!?! It has passed all non-empty-input testcases and falls on the empty-input one??? I have the same problem and really do not know understand what is the problem.\\nI have tried to use that 190\\'th test as a case and then ran (instead of submit), and it works, but when I am submitting it falls??"
                    },
                    {
                        "username": "jackbb147",
                        "content": "I have this same issue. I used brute force and it\\'s probably too slow "
                    },
                    {
                        "username": "karunakarvarada73",
                        "content": "How many  members are  commenting for upvote \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "Consider checking min and max product you can get. Also think how this helps with negative numbers"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "What is a subarray in this case? \\nIn set theory all combinations are a sub set can anyone explain"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "a few things that I thought which helped me arrive at the solution\\n1. for every index , we have two choices, either to include it , or to not include it\\n2. sometimes, even though including or not including an element may lead to a local minimum it can even cause a global maximum\\n3. hence what really matters is the magnitude of the element. even the smallest negative product with a maximum magnitude could lead to an optimum solution\\n4. the fact that the array needs to be contiguous makes it easier "
                    },
                    {
                        "username": "Princesah999",
                        "content": "those who trying to solve this using kanades algo!!"
                    }
                ]
            },
            {
                "id": 1840586,
                "content": [
                    {
                        "username": "NunoLealF",
                        "content": "These last few test cases, oh my *god*."
                    },
                    {
                        "username": "sahilkumar32755",
                        "content": "// Second Easy Method:\\n//     vector<int> ptr(100000,0);\\n\\n    //     for(int i = 0 ;i<nums.size();i++){\\n    //         ptr[nums[i]]++;\\n    //     }\\n    //     vector<int> ans;\\n    //     for(int i = 0;i<100000;i++){\\n    //         if(ptr[i] == 2){\\n    //             ans.push_back(i);\\n    //         }\\n    //     }\\n    // return ans;"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "Some tips!\\n\\n1.  Can you use Kadane\\'s Algo here?\\n2.  How\\'ll you handle the negative elements?\\n3.  Is keep tracking of Maximum Product enough?"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "https://leetcode.com/problems/maximum-product-subarray/solutions/3554945/modified-kadane-s-algorithm-c-beginner-friendly/"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "is empty array a subarray?"
                    },
                    {
                        "username": "zalars",
                        "content": "What is this mean? -\n\nTime Limit Exceeded (190 / 190 testcases passed)\n\nLast Executed Input\n`nums =`\n\n1) all testcases passed or not?\n2) empty array?"
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@jackbb147](/jackbb147) too slow for what?!?! It has passed all non-empty-input testcases and falls on the empty-input one??? I have the same problem and really do not know understand what is the problem.\\nI have tried to use that 190\\'th test as a case and then ran (instead of submit), and it works, but when I am submitting it falls??"
                    },
                    {
                        "username": "jackbb147",
                        "content": "I have this same issue. I used brute force and it\\'s probably too slow "
                    },
                    {
                        "username": "karunakarvarada73",
                        "content": "How many  members are  commenting for upvote \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "Consider checking min and max product you can get. Also think how this helps with negative numbers"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "What is a subarray in this case? \\nIn set theory all combinations are a sub set can anyone explain"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "a few things that I thought which helped me arrive at the solution\\n1. for every index , we have two choices, either to include it , or to not include it\\n2. sometimes, even though including or not including an element may lead to a local minimum it can even cause a global maximum\\n3. hence what really matters is the magnitude of the element. even the smallest negative product with a maximum magnitude could lead to an optimum solution\\n4. the fact that the array needs to be contiguous makes it easier "
                    },
                    {
                        "username": "Princesah999",
                        "content": "those who trying to solve this using kanades algo!!"
                    }
                ]
            },
            {
                "id": 1839292,
                "content": [
                    {
                        "username": "NunoLealF",
                        "content": "These last few test cases, oh my *god*."
                    },
                    {
                        "username": "sahilkumar32755",
                        "content": "// Second Easy Method:\\n//     vector<int> ptr(100000,0);\\n\\n    //     for(int i = 0 ;i<nums.size();i++){\\n    //         ptr[nums[i]]++;\\n    //     }\\n    //     vector<int> ans;\\n    //     for(int i = 0;i<100000;i++){\\n    //         if(ptr[i] == 2){\\n    //             ans.push_back(i);\\n    //         }\\n    //     }\\n    // return ans;"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "Some tips!\\n\\n1.  Can you use Kadane\\'s Algo here?\\n2.  How\\'ll you handle the negative elements?\\n3.  Is keep tracking of Maximum Product enough?"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "https://leetcode.com/problems/maximum-product-subarray/solutions/3554945/modified-kadane-s-algorithm-c-beginner-friendly/"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "is empty array a subarray?"
                    },
                    {
                        "username": "zalars",
                        "content": "What is this mean? -\n\nTime Limit Exceeded (190 / 190 testcases passed)\n\nLast Executed Input\n`nums =`\n\n1) all testcases passed or not?\n2) empty array?"
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@jackbb147](/jackbb147) too slow for what?!?! It has passed all non-empty-input testcases and falls on the empty-input one??? I have the same problem and really do not know understand what is the problem.\\nI have tried to use that 190\\'th test as a case and then ran (instead of submit), and it works, but when I am submitting it falls??"
                    },
                    {
                        "username": "jackbb147",
                        "content": "I have this same issue. I used brute force and it\\'s probably too slow "
                    },
                    {
                        "username": "karunakarvarada73",
                        "content": "How many  members are  commenting for upvote \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "Consider checking min and max product you can get. Also think how this helps with negative numbers"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "What is a subarray in this case? \\nIn set theory all combinations are a sub set can anyone explain"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "a few things that I thought which helped me arrive at the solution\\n1. for every index , we have two choices, either to include it , or to not include it\\n2. sometimes, even though including or not including an element may lead to a local minimum it can even cause a global maximum\\n3. hence what really matters is the magnitude of the element. even the smallest negative product with a maximum magnitude could lead to an optimum solution\\n4. the fact that the array needs to be contiguous makes it easier "
                    },
                    {
                        "username": "Princesah999",
                        "content": "those who trying to solve this using kanades algo!!"
                    }
                ]
            },
            {
                "id": 1806694,
                "content": [
                    {
                        "username": "NunoLealF",
                        "content": "These last few test cases, oh my *god*."
                    },
                    {
                        "username": "sahilkumar32755",
                        "content": "// Second Easy Method:\\n//     vector<int> ptr(100000,0);\\n\\n    //     for(int i = 0 ;i<nums.size();i++){\\n    //         ptr[nums[i]]++;\\n    //     }\\n    //     vector<int> ans;\\n    //     for(int i = 0;i<100000;i++){\\n    //         if(ptr[i] == 2){\\n    //             ans.push_back(i);\\n    //         }\\n    //     }\\n    // return ans;"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "Some tips!\\n\\n1.  Can you use Kadane\\'s Algo here?\\n2.  How\\'ll you handle the negative elements?\\n3.  Is keep tracking of Maximum Product enough?"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "https://leetcode.com/problems/maximum-product-subarray/solutions/3554945/modified-kadane-s-algorithm-c-beginner-friendly/"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "is empty array a subarray?"
                    },
                    {
                        "username": "zalars",
                        "content": "What is this mean? -\n\nTime Limit Exceeded (190 / 190 testcases passed)\n\nLast Executed Input\n`nums =`\n\n1) all testcases passed or not?\n2) empty array?"
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@jackbb147](/jackbb147) too slow for what?!?! It has passed all non-empty-input testcases and falls on the empty-input one??? I have the same problem and really do not know understand what is the problem.\\nI have tried to use that 190\\'th test as a case and then ran (instead of submit), and it works, but when I am submitting it falls??"
                    },
                    {
                        "username": "jackbb147",
                        "content": "I have this same issue. I used brute force and it\\'s probably too slow "
                    },
                    {
                        "username": "karunakarvarada73",
                        "content": "How many  members are  commenting for upvote \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "Consider checking min and max product you can get. Also think how this helps with negative numbers"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "What is a subarray in this case? \\nIn set theory all combinations are a sub set can anyone explain"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "a few things that I thought which helped me arrive at the solution\\n1. for every index , we have two choices, either to include it , or to not include it\\n2. sometimes, even though including or not including an element may lead to a local minimum it can even cause a global maximum\\n3. hence what really matters is the magnitude of the element. even the smallest negative product with a maximum magnitude could lead to an optimum solution\\n4. the fact that the array needs to be contiguous makes it easier "
                    },
                    {
                        "username": "Princesah999",
                        "content": "those who trying to solve this using kanades algo!!"
                    }
                ]
            },
            {
                "id": 1798391,
                "content": [
                    {
                        "username": "NunoLealF",
                        "content": "These last few test cases, oh my *god*."
                    },
                    {
                        "username": "sahilkumar32755",
                        "content": "// Second Easy Method:\\n//     vector<int> ptr(100000,0);\\n\\n    //     for(int i = 0 ;i<nums.size();i++){\\n    //         ptr[nums[i]]++;\\n    //     }\\n    //     vector<int> ans;\\n    //     for(int i = 0;i<100000;i++){\\n    //         if(ptr[i] == 2){\\n    //             ans.push_back(i);\\n    //         }\\n    //     }\\n    // return ans;"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "Some tips!\\n\\n1.  Can you use Kadane\\'s Algo here?\\n2.  How\\'ll you handle the negative elements?\\n3.  Is keep tracking of Maximum Product enough?"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "https://leetcode.com/problems/maximum-product-subarray/solutions/3554945/modified-kadane-s-algorithm-c-beginner-friendly/"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "is empty array a subarray?"
                    },
                    {
                        "username": "zalars",
                        "content": "What is this mean? -\n\nTime Limit Exceeded (190 / 190 testcases passed)\n\nLast Executed Input\n`nums =`\n\n1) all testcases passed or not?\n2) empty array?"
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@jackbb147](/jackbb147) too slow for what?!?! It has passed all non-empty-input testcases and falls on the empty-input one??? I have the same problem and really do not know understand what is the problem.\\nI have tried to use that 190\\'th test as a case and then ran (instead of submit), and it works, but when I am submitting it falls??"
                    },
                    {
                        "username": "jackbb147",
                        "content": "I have this same issue. I used brute force and it\\'s probably too slow "
                    },
                    {
                        "username": "karunakarvarada73",
                        "content": "How many  members are  commenting for upvote \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "Consider checking min and max product you can get. Also think how this helps with negative numbers"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "What is a subarray in this case? \\nIn set theory all combinations are a sub set can anyone explain"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "a few things that I thought which helped me arrive at the solution\\n1. for every index , we have two choices, either to include it , or to not include it\\n2. sometimes, even though including or not including an element may lead to a local minimum it can even cause a global maximum\\n3. hence what really matters is the magnitude of the element. even the smallest negative product with a maximum magnitude could lead to an optimum solution\\n4. the fact that the array needs to be contiguous makes it easier "
                    },
                    {
                        "username": "Princesah999",
                        "content": "those who trying to solve this using kanades algo!!"
                    }
                ]
            },
            {
                "id": 1795055,
                "content": [
                    {
                        "username": "NunoLealF",
                        "content": "These last few test cases, oh my *god*."
                    },
                    {
                        "username": "sahilkumar32755",
                        "content": "// Second Easy Method:\\n//     vector<int> ptr(100000,0);\\n\\n    //     for(int i = 0 ;i<nums.size();i++){\\n    //         ptr[nums[i]]++;\\n    //     }\\n    //     vector<int> ans;\\n    //     for(int i = 0;i<100000;i++){\\n    //         if(ptr[i] == 2){\\n    //             ans.push_back(i);\\n    //         }\\n    //     }\\n    // return ans;"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "Some tips!\\n\\n1.  Can you use Kadane\\'s Algo here?\\n2.  How\\'ll you handle the negative elements?\\n3.  Is keep tracking of Maximum Product enough?"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "https://leetcode.com/problems/maximum-product-subarray/solutions/3554945/modified-kadane-s-algorithm-c-beginner-friendly/"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "is empty array a subarray?"
                    },
                    {
                        "username": "zalars",
                        "content": "What is this mean? -\n\nTime Limit Exceeded (190 / 190 testcases passed)\n\nLast Executed Input\n`nums =`\n\n1) all testcases passed or not?\n2) empty array?"
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@jackbb147](/jackbb147) too slow for what?!?! It has passed all non-empty-input testcases and falls on the empty-input one??? I have the same problem and really do not know understand what is the problem.\\nI have tried to use that 190\\'th test as a case and then ran (instead of submit), and it works, but when I am submitting it falls??"
                    },
                    {
                        "username": "jackbb147",
                        "content": "I have this same issue. I used brute force and it\\'s probably too slow "
                    },
                    {
                        "username": "karunakarvarada73",
                        "content": "How many  members are  commenting for upvote \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "Consider checking min and max product you can get. Also think how this helps with negative numbers"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "What is a subarray in this case? \\nIn set theory all combinations are a sub set can anyone explain"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "a few things that I thought which helped me arrive at the solution\\n1. for every index , we have two choices, either to include it , or to not include it\\n2. sometimes, even though including or not including an element may lead to a local minimum it can even cause a global maximum\\n3. hence what really matters is the magnitude of the element. even the smallest negative product with a maximum magnitude could lead to an optimum solution\\n4. the fact that the array needs to be contiguous makes it easier "
                    },
                    {
                        "username": "Princesah999",
                        "content": "those who trying to solve this using kanades algo!!"
                    }
                ]
            },
            {
                "id": 1791027,
                "content": [
                    {
                        "username": "jiaheaaa",
                        "content": "I understood the question (and solved it) but I still feel weird about we can't output an empty subarray and claim the product is 1... It will make things much easier."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lower bound for the array size is given to be 1 in the constraints. If the problem statement specifies that the array size has a lower bound of 1, it means that the array must contain at least one element. Therefore, we don\\'t need to consider the case of an empty array (or empty subarray), because such a situation falls outside of the problem\\'s constraints.\\n\\nIn this particular problem, the term \"subarray\" refers to a contiguous subset of elements within the array. A subarray with one element is considered valid and within the problem constraints, but an empty subarray wouldn\\'t be considered because it falls outside of the specified constraints. This is why the empty subarray (product 1) doesn\\'t come into play in this problem.\\n\\nRemember, the specifications and constraints in a problem statement are very important as they guide your solution. They often simplify the problem by eliminating the need to consider certain edge cases or more complex scenarios.\\n"
                    },
                    {
                        "username": "mars_999",
                        "content": "How I approached this problem:\\n\\nAs soon as I saw maximum product subarray with +ve and -ve integers , max sum subarray problem i. e Kadane\\'s algorithm came to my mind. But I couldn\\'t come up with anything to deal with negative numbers as that  can change the result entirely.\\n\\nSo Leetcode Official Solution helped me a lot.  Its just an extension to Kadane\\'s algo, we need to keep track of min product sub array which will help to get the max product subarray."
                    },
                    {
                        "username": "Sadiya-Irin",
                        "content": "Why this solution gives the verdict WA? Could anyone please point me out about the mistake?\\nclass Solution {\\npublic:\\nint maxProduct(vector<int> &nums){\\n    int i,n = nums.size();\\n    int prod=1, mx=LLONG_MIN;\\n    for(i=0; i<n; i++){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod==0) prod=1;\\n    }\\n//    cout<<endl;\\n    prod=1;\\n    for(i=n-1; i>=0; i--){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod == 0)   prod=1;\\n    }\\n//    cout<endl;\\n    return mx;\\n}\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code tries to solve the problem by checking the maximum product from left to right and then from right to left. However, this approach will not work for certain cases where negative numbers are involved.\\n\\nFor example, let\\'s consider the array: `[-1, -2, -3]`. The expected output is `6` because the maximum product can be achieved by multiplying all the elements. But, if you check your code, you will get `-1` as the answer. This is because your code resets `prod` to `1` whenever `prod` is `0`, but it doesn\\'t consider the case when `prod` is negative. A negative `prod` means that we have encountered an odd number of negative numbers so far, and there might be a chance that we can get a positive product by multiplying with some negative numbers in the future.\\n\\nSo, the code fails to handle the case where there are an even number of negative numbers in the array. A correct approach would be to maintain two variables, `maxProduct` and `minProduct` at each point in the array. `maxProduct` will store the maximum product that can be obtained up to the current position and `minProduct` will store the minimum (most negative) product that can be obtained up to the current position. Then at each point, you update `maxProduct` and `minProduct` using the current number, and the product of the current number with the previous `maxProduct` and `minProduct`.\\n\\nHere\\'s how you could update your function to implement this:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxProduct = nums[0], minProduct = nums[0], maxSoFar = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] < 0) swap(maxProduct, minProduct);\\n            maxProduct = max(nums[i], maxProduct * nums[i]);\\n            minProduct = min(nums[i], minProduct * nums[i]);\\n            maxSoFar = max(maxSoFar, maxProduct);\\n        }\\n\\n        return maxSoFar;\\n    }\\n};\\n```\\n\\nThis approach ensures that we correctly consider the effects of negative numbers in the array.\\n"
                    },
                    {
                        "username": "abdulhamid28",
                        "content": "testcase no 189 \\ninput nums=(no value at all)\\nhelp me"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ay96052003",
                        "content": "I cannot understand this problem, \\nfor the 1st test case : nums = [2, 3, -2, 4]\\nwhy the max product is 6 and not 12?? "
                    },
                    {
                        "username": "PhNTOm_12",
                        "content": "because [2,3] is a subarray which has a product of 6 whereas [3,4] (max product = 12)is not a a subarray, taking [3,4] means you are considering it as a subsequence. \\nA subarray or substring will always be contiguous, but a subsequence need not be contiguous.....:))"
                    },
                    {
                        "username": "ashuthe1",
                        "content": "I  am trying to use divide & conquer approach but I am getting WA in 140th test case.\\ncan anyone help me in this.\\n\\nint divideRule(int l, int r, vector<int>&v)\\n    {\\n        if(l > r) return 0;\\n        if(l == r) return v[l];\\n        int mid = (l+r)/2;\\n\\n        int left = divideRule(l,mid-1,v);\\n        int right = divideRule(mid+1,r,v);\\n\\n        int ml = 1, mr = 1;\\n        for(int i = mid-1, cur = ml; i >= l; i--)\\n        {\\n            cur *= v[i];\\n            ml = max(ml,cur);\\n        }\\n        for(int i = mid+1, cur = mr; i <= r; i++)\\n        {\\n            cur *= v[i];\\n            mr = max(mr,cur);\\n        }\\n        return max({ml*v[mid]*mr,left,right});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        return divideRule(0,nums.size()-1,nums);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you\\'ve chosen, which is a divide and conquer approach, is generally sound for solving problems similar to this one. However, it falls short when dealing with the Maximum Product Subarray problem, primarily due to the presence of negative numbers and zeros in the array.\\n\\nThe main issue with your approach lies in how you calculate `left` and `right`. In your current implementation, you calculate the product of the left and right subarrays separately and then find the maximum. However, this doesn\\'t account for situations where the maximum product could span across both the left and right subarrays.\\n\\nFor example, let\\'s take the array [-2, -3, -4]. The maximum product subarray is the entire array itself, with a product of -2*-3*-4 = 24. But in your code, you divide the array into left and right subarrays, then calculate the maximum product of each, and take the maximum of these two. As a result, you miss out on the possibility that the maximum product subarray could span across both the left and right subarrays.\\n\\nFurther, your code doesn\\'t account for zeros or an even number of negative numbers correctly. For example, if you have an array like [-2, -3, 0, -4], your current code would not return the correct answer, as the maximum product is actually 24, obtained by the subarray [-2, -3, -4].\\n\\nFor these reasons, the Maximum Product Subarray problem is usually solved using a dynamic programming approach, which takes into account both the maximum and minimum product at each step. This allows the algorithm to correctly handle cases with negative numbers and zeros. It might be worth revisiting your approach to this problem and considering a dynamic programming solution instead."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/152_max_product_subarray.cpp"
                    },
                    {
                        "username": "jaronkelly0",
                        "content": "I passed all 188/188 test and yet I get a time limit exceeded? I think I figured out why the acceptance rate is so low. The problem isn\\'t difficult but with this bug I\\'m surprised anyone passed this problem. "
                    },
                    {
                        "username": "jackbb147",
                        "content": "it\\'s intentional, to prevent brute force approaches "
                    },
                    {
                        "username": "sergiycheck",
                        "content": "why the expected output for nums = [-3,-1,-1] is 3 and not -1 ? I am so confused. "
                    },
                    {
                        "username": "Aquil",
                        "content": "(-3)*(-1)=3"
                    }
                ]
            },
            {
                "id": 1785111,
                "content": [
                    {
                        "username": "jiaheaaa",
                        "content": "I understood the question (and solved it) but I still feel weird about we can't output an empty subarray and claim the product is 1... It will make things much easier."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lower bound for the array size is given to be 1 in the constraints. If the problem statement specifies that the array size has a lower bound of 1, it means that the array must contain at least one element. Therefore, we don\\'t need to consider the case of an empty array (or empty subarray), because such a situation falls outside of the problem\\'s constraints.\\n\\nIn this particular problem, the term \"subarray\" refers to a contiguous subset of elements within the array. A subarray with one element is considered valid and within the problem constraints, but an empty subarray wouldn\\'t be considered because it falls outside of the specified constraints. This is why the empty subarray (product 1) doesn\\'t come into play in this problem.\\n\\nRemember, the specifications and constraints in a problem statement are very important as they guide your solution. They often simplify the problem by eliminating the need to consider certain edge cases or more complex scenarios.\\n"
                    },
                    {
                        "username": "mars_999",
                        "content": "How I approached this problem:\\n\\nAs soon as I saw maximum product subarray with +ve and -ve integers , max sum subarray problem i. e Kadane\\'s algorithm came to my mind. But I couldn\\'t come up with anything to deal with negative numbers as that  can change the result entirely.\\n\\nSo Leetcode Official Solution helped me a lot.  Its just an extension to Kadane\\'s algo, we need to keep track of min product sub array which will help to get the max product subarray."
                    },
                    {
                        "username": "Sadiya-Irin",
                        "content": "Why this solution gives the verdict WA? Could anyone please point me out about the mistake?\\nclass Solution {\\npublic:\\nint maxProduct(vector<int> &nums){\\n    int i,n = nums.size();\\n    int prod=1, mx=LLONG_MIN;\\n    for(i=0; i<n; i++){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod==0) prod=1;\\n    }\\n//    cout<<endl;\\n    prod=1;\\n    for(i=n-1; i>=0; i--){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod == 0)   prod=1;\\n    }\\n//    cout<endl;\\n    return mx;\\n}\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code tries to solve the problem by checking the maximum product from left to right and then from right to left. However, this approach will not work for certain cases where negative numbers are involved.\\n\\nFor example, let\\'s consider the array: `[-1, -2, -3]`. The expected output is `6` because the maximum product can be achieved by multiplying all the elements. But, if you check your code, you will get `-1` as the answer. This is because your code resets `prod` to `1` whenever `prod` is `0`, but it doesn\\'t consider the case when `prod` is negative. A negative `prod` means that we have encountered an odd number of negative numbers so far, and there might be a chance that we can get a positive product by multiplying with some negative numbers in the future.\\n\\nSo, the code fails to handle the case where there are an even number of negative numbers in the array. A correct approach would be to maintain two variables, `maxProduct` and `minProduct` at each point in the array. `maxProduct` will store the maximum product that can be obtained up to the current position and `minProduct` will store the minimum (most negative) product that can be obtained up to the current position. Then at each point, you update `maxProduct` and `minProduct` using the current number, and the product of the current number with the previous `maxProduct` and `minProduct`.\\n\\nHere\\'s how you could update your function to implement this:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxProduct = nums[0], minProduct = nums[0], maxSoFar = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] < 0) swap(maxProduct, minProduct);\\n            maxProduct = max(nums[i], maxProduct * nums[i]);\\n            minProduct = min(nums[i], minProduct * nums[i]);\\n            maxSoFar = max(maxSoFar, maxProduct);\\n        }\\n\\n        return maxSoFar;\\n    }\\n};\\n```\\n\\nThis approach ensures that we correctly consider the effects of negative numbers in the array.\\n"
                    },
                    {
                        "username": "abdulhamid28",
                        "content": "testcase no 189 \\ninput nums=(no value at all)\\nhelp me"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ay96052003",
                        "content": "I cannot understand this problem, \\nfor the 1st test case : nums = [2, 3, -2, 4]\\nwhy the max product is 6 and not 12?? "
                    },
                    {
                        "username": "PhNTOm_12",
                        "content": "because [2,3] is a subarray which has a product of 6 whereas [3,4] (max product = 12)is not a a subarray, taking [3,4] means you are considering it as a subsequence. \\nA subarray or substring will always be contiguous, but a subsequence need not be contiguous.....:))"
                    },
                    {
                        "username": "ashuthe1",
                        "content": "I  am trying to use divide & conquer approach but I am getting WA in 140th test case.\\ncan anyone help me in this.\\n\\nint divideRule(int l, int r, vector<int>&v)\\n    {\\n        if(l > r) return 0;\\n        if(l == r) return v[l];\\n        int mid = (l+r)/2;\\n\\n        int left = divideRule(l,mid-1,v);\\n        int right = divideRule(mid+1,r,v);\\n\\n        int ml = 1, mr = 1;\\n        for(int i = mid-1, cur = ml; i >= l; i--)\\n        {\\n            cur *= v[i];\\n            ml = max(ml,cur);\\n        }\\n        for(int i = mid+1, cur = mr; i <= r; i++)\\n        {\\n            cur *= v[i];\\n            mr = max(mr,cur);\\n        }\\n        return max({ml*v[mid]*mr,left,right});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        return divideRule(0,nums.size()-1,nums);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you\\'ve chosen, which is a divide and conquer approach, is generally sound for solving problems similar to this one. However, it falls short when dealing with the Maximum Product Subarray problem, primarily due to the presence of negative numbers and zeros in the array.\\n\\nThe main issue with your approach lies in how you calculate `left` and `right`. In your current implementation, you calculate the product of the left and right subarrays separately and then find the maximum. However, this doesn\\'t account for situations where the maximum product could span across both the left and right subarrays.\\n\\nFor example, let\\'s take the array [-2, -3, -4]. The maximum product subarray is the entire array itself, with a product of -2*-3*-4 = 24. But in your code, you divide the array into left and right subarrays, then calculate the maximum product of each, and take the maximum of these two. As a result, you miss out on the possibility that the maximum product subarray could span across both the left and right subarrays.\\n\\nFurther, your code doesn\\'t account for zeros or an even number of negative numbers correctly. For example, if you have an array like [-2, -3, 0, -4], your current code would not return the correct answer, as the maximum product is actually 24, obtained by the subarray [-2, -3, -4].\\n\\nFor these reasons, the Maximum Product Subarray problem is usually solved using a dynamic programming approach, which takes into account both the maximum and minimum product at each step. This allows the algorithm to correctly handle cases with negative numbers and zeros. It might be worth revisiting your approach to this problem and considering a dynamic programming solution instead."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/152_max_product_subarray.cpp"
                    },
                    {
                        "username": "jaronkelly0",
                        "content": "I passed all 188/188 test and yet I get a time limit exceeded? I think I figured out why the acceptance rate is so low. The problem isn\\'t difficult but with this bug I\\'m surprised anyone passed this problem. "
                    },
                    {
                        "username": "jackbb147",
                        "content": "it\\'s intentional, to prevent brute force approaches "
                    },
                    {
                        "username": "sergiycheck",
                        "content": "why the expected output for nums = [-3,-1,-1] is 3 and not -1 ? I am so confused. "
                    },
                    {
                        "username": "Aquil",
                        "content": "(-3)*(-1)=3"
                    }
                ]
            },
            {
                "id": 1778112,
                "content": [
                    {
                        "username": "jiaheaaa",
                        "content": "I understood the question (and solved it) but I still feel weird about we can't output an empty subarray and claim the product is 1... It will make things much easier."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lower bound for the array size is given to be 1 in the constraints. If the problem statement specifies that the array size has a lower bound of 1, it means that the array must contain at least one element. Therefore, we don\\'t need to consider the case of an empty array (or empty subarray), because such a situation falls outside of the problem\\'s constraints.\\n\\nIn this particular problem, the term \"subarray\" refers to a contiguous subset of elements within the array. A subarray with one element is considered valid and within the problem constraints, but an empty subarray wouldn\\'t be considered because it falls outside of the specified constraints. This is why the empty subarray (product 1) doesn\\'t come into play in this problem.\\n\\nRemember, the specifications and constraints in a problem statement are very important as they guide your solution. They often simplify the problem by eliminating the need to consider certain edge cases or more complex scenarios.\\n"
                    },
                    {
                        "username": "mars_999",
                        "content": "How I approached this problem:\\n\\nAs soon as I saw maximum product subarray with +ve and -ve integers , max sum subarray problem i. e Kadane\\'s algorithm came to my mind. But I couldn\\'t come up with anything to deal with negative numbers as that  can change the result entirely.\\n\\nSo Leetcode Official Solution helped me a lot.  Its just an extension to Kadane\\'s algo, we need to keep track of min product sub array which will help to get the max product subarray."
                    },
                    {
                        "username": "Sadiya-Irin",
                        "content": "Why this solution gives the verdict WA? Could anyone please point me out about the mistake?\\nclass Solution {\\npublic:\\nint maxProduct(vector<int> &nums){\\n    int i,n = nums.size();\\n    int prod=1, mx=LLONG_MIN;\\n    for(i=0; i<n; i++){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod==0) prod=1;\\n    }\\n//    cout<<endl;\\n    prod=1;\\n    for(i=n-1; i>=0; i--){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod == 0)   prod=1;\\n    }\\n//    cout<endl;\\n    return mx;\\n}\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code tries to solve the problem by checking the maximum product from left to right and then from right to left. However, this approach will not work for certain cases where negative numbers are involved.\\n\\nFor example, let\\'s consider the array: `[-1, -2, -3]`. The expected output is `6` because the maximum product can be achieved by multiplying all the elements. But, if you check your code, you will get `-1` as the answer. This is because your code resets `prod` to `1` whenever `prod` is `0`, but it doesn\\'t consider the case when `prod` is negative. A negative `prod` means that we have encountered an odd number of negative numbers so far, and there might be a chance that we can get a positive product by multiplying with some negative numbers in the future.\\n\\nSo, the code fails to handle the case where there are an even number of negative numbers in the array. A correct approach would be to maintain two variables, `maxProduct` and `minProduct` at each point in the array. `maxProduct` will store the maximum product that can be obtained up to the current position and `minProduct` will store the minimum (most negative) product that can be obtained up to the current position. Then at each point, you update `maxProduct` and `minProduct` using the current number, and the product of the current number with the previous `maxProduct` and `minProduct`.\\n\\nHere\\'s how you could update your function to implement this:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxProduct = nums[0], minProduct = nums[0], maxSoFar = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] < 0) swap(maxProduct, minProduct);\\n            maxProduct = max(nums[i], maxProduct * nums[i]);\\n            minProduct = min(nums[i], minProduct * nums[i]);\\n            maxSoFar = max(maxSoFar, maxProduct);\\n        }\\n\\n        return maxSoFar;\\n    }\\n};\\n```\\n\\nThis approach ensures that we correctly consider the effects of negative numbers in the array.\\n"
                    },
                    {
                        "username": "abdulhamid28",
                        "content": "testcase no 189 \\ninput nums=(no value at all)\\nhelp me"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ay96052003",
                        "content": "I cannot understand this problem, \\nfor the 1st test case : nums = [2, 3, -2, 4]\\nwhy the max product is 6 and not 12?? "
                    },
                    {
                        "username": "PhNTOm_12",
                        "content": "because [2,3] is a subarray which has a product of 6 whereas [3,4] (max product = 12)is not a a subarray, taking [3,4] means you are considering it as a subsequence. \\nA subarray or substring will always be contiguous, but a subsequence need not be contiguous.....:))"
                    },
                    {
                        "username": "ashuthe1",
                        "content": "I  am trying to use divide & conquer approach but I am getting WA in 140th test case.\\ncan anyone help me in this.\\n\\nint divideRule(int l, int r, vector<int>&v)\\n    {\\n        if(l > r) return 0;\\n        if(l == r) return v[l];\\n        int mid = (l+r)/2;\\n\\n        int left = divideRule(l,mid-1,v);\\n        int right = divideRule(mid+1,r,v);\\n\\n        int ml = 1, mr = 1;\\n        for(int i = mid-1, cur = ml; i >= l; i--)\\n        {\\n            cur *= v[i];\\n            ml = max(ml,cur);\\n        }\\n        for(int i = mid+1, cur = mr; i <= r; i++)\\n        {\\n            cur *= v[i];\\n            mr = max(mr,cur);\\n        }\\n        return max({ml*v[mid]*mr,left,right});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        return divideRule(0,nums.size()-1,nums);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you\\'ve chosen, which is a divide and conquer approach, is generally sound for solving problems similar to this one. However, it falls short when dealing with the Maximum Product Subarray problem, primarily due to the presence of negative numbers and zeros in the array.\\n\\nThe main issue with your approach lies in how you calculate `left` and `right`. In your current implementation, you calculate the product of the left and right subarrays separately and then find the maximum. However, this doesn\\'t account for situations where the maximum product could span across both the left and right subarrays.\\n\\nFor example, let\\'s take the array [-2, -3, -4]. The maximum product subarray is the entire array itself, with a product of -2*-3*-4 = 24. But in your code, you divide the array into left and right subarrays, then calculate the maximum product of each, and take the maximum of these two. As a result, you miss out on the possibility that the maximum product subarray could span across both the left and right subarrays.\\n\\nFurther, your code doesn\\'t account for zeros or an even number of negative numbers correctly. For example, if you have an array like [-2, -3, 0, -4], your current code would not return the correct answer, as the maximum product is actually 24, obtained by the subarray [-2, -3, -4].\\n\\nFor these reasons, the Maximum Product Subarray problem is usually solved using a dynamic programming approach, which takes into account both the maximum and minimum product at each step. This allows the algorithm to correctly handle cases with negative numbers and zeros. It might be worth revisiting your approach to this problem and considering a dynamic programming solution instead."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/152_max_product_subarray.cpp"
                    },
                    {
                        "username": "jaronkelly0",
                        "content": "I passed all 188/188 test and yet I get a time limit exceeded? I think I figured out why the acceptance rate is so low. The problem isn\\'t difficult but with this bug I\\'m surprised anyone passed this problem. "
                    },
                    {
                        "username": "jackbb147",
                        "content": "it\\'s intentional, to prevent brute force approaches "
                    },
                    {
                        "username": "sergiycheck",
                        "content": "why the expected output for nums = [-3,-1,-1] is 3 and not -1 ? I am so confused. "
                    },
                    {
                        "username": "Aquil",
                        "content": "(-3)*(-1)=3"
                    }
                ]
            },
            {
                "id": 1758783,
                "content": [
                    {
                        "username": "jiaheaaa",
                        "content": "I understood the question (and solved it) but I still feel weird about we can't output an empty subarray and claim the product is 1... It will make things much easier."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lower bound for the array size is given to be 1 in the constraints. If the problem statement specifies that the array size has a lower bound of 1, it means that the array must contain at least one element. Therefore, we don\\'t need to consider the case of an empty array (or empty subarray), because such a situation falls outside of the problem\\'s constraints.\\n\\nIn this particular problem, the term \"subarray\" refers to a contiguous subset of elements within the array. A subarray with one element is considered valid and within the problem constraints, but an empty subarray wouldn\\'t be considered because it falls outside of the specified constraints. This is why the empty subarray (product 1) doesn\\'t come into play in this problem.\\n\\nRemember, the specifications and constraints in a problem statement are very important as they guide your solution. They often simplify the problem by eliminating the need to consider certain edge cases or more complex scenarios.\\n"
                    },
                    {
                        "username": "mars_999",
                        "content": "How I approached this problem:\\n\\nAs soon as I saw maximum product subarray with +ve and -ve integers , max sum subarray problem i. e Kadane\\'s algorithm came to my mind. But I couldn\\'t come up with anything to deal with negative numbers as that  can change the result entirely.\\n\\nSo Leetcode Official Solution helped me a lot.  Its just an extension to Kadane\\'s algo, we need to keep track of min product sub array which will help to get the max product subarray."
                    },
                    {
                        "username": "Sadiya-Irin",
                        "content": "Why this solution gives the verdict WA? Could anyone please point me out about the mistake?\\nclass Solution {\\npublic:\\nint maxProduct(vector<int> &nums){\\n    int i,n = nums.size();\\n    int prod=1, mx=LLONG_MIN;\\n    for(i=0; i<n; i++){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod==0) prod=1;\\n    }\\n//    cout<<endl;\\n    prod=1;\\n    for(i=n-1; i>=0; i--){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod == 0)   prod=1;\\n    }\\n//    cout<endl;\\n    return mx;\\n}\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code tries to solve the problem by checking the maximum product from left to right and then from right to left. However, this approach will not work for certain cases where negative numbers are involved.\\n\\nFor example, let\\'s consider the array: `[-1, -2, -3]`. The expected output is `6` because the maximum product can be achieved by multiplying all the elements. But, if you check your code, you will get `-1` as the answer. This is because your code resets `prod` to `1` whenever `prod` is `0`, but it doesn\\'t consider the case when `prod` is negative. A negative `prod` means that we have encountered an odd number of negative numbers so far, and there might be a chance that we can get a positive product by multiplying with some negative numbers in the future.\\n\\nSo, the code fails to handle the case where there are an even number of negative numbers in the array. A correct approach would be to maintain two variables, `maxProduct` and `minProduct` at each point in the array. `maxProduct` will store the maximum product that can be obtained up to the current position and `minProduct` will store the minimum (most negative) product that can be obtained up to the current position. Then at each point, you update `maxProduct` and `minProduct` using the current number, and the product of the current number with the previous `maxProduct` and `minProduct`.\\n\\nHere\\'s how you could update your function to implement this:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxProduct = nums[0], minProduct = nums[0], maxSoFar = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] < 0) swap(maxProduct, minProduct);\\n            maxProduct = max(nums[i], maxProduct * nums[i]);\\n            minProduct = min(nums[i], minProduct * nums[i]);\\n            maxSoFar = max(maxSoFar, maxProduct);\\n        }\\n\\n        return maxSoFar;\\n    }\\n};\\n```\\n\\nThis approach ensures that we correctly consider the effects of negative numbers in the array.\\n"
                    },
                    {
                        "username": "abdulhamid28",
                        "content": "testcase no 189 \\ninput nums=(no value at all)\\nhelp me"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ay96052003",
                        "content": "I cannot understand this problem, \\nfor the 1st test case : nums = [2, 3, -2, 4]\\nwhy the max product is 6 and not 12?? "
                    },
                    {
                        "username": "PhNTOm_12",
                        "content": "because [2,3] is a subarray which has a product of 6 whereas [3,4] (max product = 12)is not a a subarray, taking [3,4] means you are considering it as a subsequence. \\nA subarray or substring will always be contiguous, but a subsequence need not be contiguous.....:))"
                    },
                    {
                        "username": "ashuthe1",
                        "content": "I  am trying to use divide & conquer approach but I am getting WA in 140th test case.\\ncan anyone help me in this.\\n\\nint divideRule(int l, int r, vector<int>&v)\\n    {\\n        if(l > r) return 0;\\n        if(l == r) return v[l];\\n        int mid = (l+r)/2;\\n\\n        int left = divideRule(l,mid-1,v);\\n        int right = divideRule(mid+1,r,v);\\n\\n        int ml = 1, mr = 1;\\n        for(int i = mid-1, cur = ml; i >= l; i--)\\n        {\\n            cur *= v[i];\\n            ml = max(ml,cur);\\n        }\\n        for(int i = mid+1, cur = mr; i <= r; i++)\\n        {\\n            cur *= v[i];\\n            mr = max(mr,cur);\\n        }\\n        return max({ml*v[mid]*mr,left,right});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        return divideRule(0,nums.size()-1,nums);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you\\'ve chosen, which is a divide and conquer approach, is generally sound for solving problems similar to this one. However, it falls short when dealing with the Maximum Product Subarray problem, primarily due to the presence of negative numbers and zeros in the array.\\n\\nThe main issue with your approach lies in how you calculate `left` and `right`. In your current implementation, you calculate the product of the left and right subarrays separately and then find the maximum. However, this doesn\\'t account for situations where the maximum product could span across both the left and right subarrays.\\n\\nFor example, let\\'s take the array [-2, -3, -4]. The maximum product subarray is the entire array itself, with a product of -2*-3*-4 = 24. But in your code, you divide the array into left and right subarrays, then calculate the maximum product of each, and take the maximum of these two. As a result, you miss out on the possibility that the maximum product subarray could span across both the left and right subarrays.\\n\\nFurther, your code doesn\\'t account for zeros or an even number of negative numbers correctly. For example, if you have an array like [-2, -3, 0, -4], your current code would not return the correct answer, as the maximum product is actually 24, obtained by the subarray [-2, -3, -4].\\n\\nFor these reasons, the Maximum Product Subarray problem is usually solved using a dynamic programming approach, which takes into account both the maximum and minimum product at each step. This allows the algorithm to correctly handle cases with negative numbers and zeros. It might be worth revisiting your approach to this problem and considering a dynamic programming solution instead."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/152_max_product_subarray.cpp"
                    },
                    {
                        "username": "jaronkelly0",
                        "content": "I passed all 188/188 test and yet I get a time limit exceeded? I think I figured out why the acceptance rate is so low. The problem isn\\'t difficult but with this bug I\\'m surprised anyone passed this problem. "
                    },
                    {
                        "username": "jackbb147",
                        "content": "it\\'s intentional, to prevent brute force approaches "
                    },
                    {
                        "username": "sergiycheck",
                        "content": "why the expected output for nums = [-3,-1,-1] is 3 and not -1 ? I am so confused. "
                    },
                    {
                        "username": "Aquil",
                        "content": "(-3)*(-1)=3"
                    }
                ]
            },
            {
                "id": 1756369,
                "content": [
                    {
                        "username": "jiaheaaa",
                        "content": "I understood the question (and solved it) but I still feel weird about we can't output an empty subarray and claim the product is 1... It will make things much easier."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lower bound for the array size is given to be 1 in the constraints. If the problem statement specifies that the array size has a lower bound of 1, it means that the array must contain at least one element. Therefore, we don\\'t need to consider the case of an empty array (or empty subarray), because such a situation falls outside of the problem\\'s constraints.\\n\\nIn this particular problem, the term \"subarray\" refers to a contiguous subset of elements within the array. A subarray with one element is considered valid and within the problem constraints, but an empty subarray wouldn\\'t be considered because it falls outside of the specified constraints. This is why the empty subarray (product 1) doesn\\'t come into play in this problem.\\n\\nRemember, the specifications and constraints in a problem statement are very important as they guide your solution. They often simplify the problem by eliminating the need to consider certain edge cases or more complex scenarios.\\n"
                    },
                    {
                        "username": "mars_999",
                        "content": "How I approached this problem:\\n\\nAs soon as I saw maximum product subarray with +ve and -ve integers , max sum subarray problem i. e Kadane\\'s algorithm came to my mind. But I couldn\\'t come up with anything to deal with negative numbers as that  can change the result entirely.\\n\\nSo Leetcode Official Solution helped me a lot.  Its just an extension to Kadane\\'s algo, we need to keep track of min product sub array which will help to get the max product subarray."
                    },
                    {
                        "username": "Sadiya-Irin",
                        "content": "Why this solution gives the verdict WA? Could anyone please point me out about the mistake?\\nclass Solution {\\npublic:\\nint maxProduct(vector<int> &nums){\\n    int i,n = nums.size();\\n    int prod=1, mx=LLONG_MIN;\\n    for(i=0; i<n; i++){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod==0) prod=1;\\n    }\\n//    cout<<endl;\\n    prod=1;\\n    for(i=n-1; i>=0; i--){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod == 0)   prod=1;\\n    }\\n//    cout<endl;\\n    return mx;\\n}\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code tries to solve the problem by checking the maximum product from left to right and then from right to left. However, this approach will not work for certain cases where negative numbers are involved.\\n\\nFor example, let\\'s consider the array: `[-1, -2, -3]`. The expected output is `6` because the maximum product can be achieved by multiplying all the elements. But, if you check your code, you will get `-1` as the answer. This is because your code resets `prod` to `1` whenever `prod` is `0`, but it doesn\\'t consider the case when `prod` is negative. A negative `prod` means that we have encountered an odd number of negative numbers so far, and there might be a chance that we can get a positive product by multiplying with some negative numbers in the future.\\n\\nSo, the code fails to handle the case where there are an even number of negative numbers in the array. A correct approach would be to maintain two variables, `maxProduct` and `minProduct` at each point in the array. `maxProduct` will store the maximum product that can be obtained up to the current position and `minProduct` will store the minimum (most negative) product that can be obtained up to the current position. Then at each point, you update `maxProduct` and `minProduct` using the current number, and the product of the current number with the previous `maxProduct` and `minProduct`.\\n\\nHere\\'s how you could update your function to implement this:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxProduct = nums[0], minProduct = nums[0], maxSoFar = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] < 0) swap(maxProduct, minProduct);\\n            maxProduct = max(nums[i], maxProduct * nums[i]);\\n            minProduct = min(nums[i], minProduct * nums[i]);\\n            maxSoFar = max(maxSoFar, maxProduct);\\n        }\\n\\n        return maxSoFar;\\n    }\\n};\\n```\\n\\nThis approach ensures that we correctly consider the effects of negative numbers in the array.\\n"
                    },
                    {
                        "username": "abdulhamid28",
                        "content": "testcase no 189 \\ninput nums=(no value at all)\\nhelp me"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ay96052003",
                        "content": "I cannot understand this problem, \\nfor the 1st test case : nums = [2, 3, -2, 4]\\nwhy the max product is 6 and not 12?? "
                    },
                    {
                        "username": "PhNTOm_12",
                        "content": "because [2,3] is a subarray which has a product of 6 whereas [3,4] (max product = 12)is not a a subarray, taking [3,4] means you are considering it as a subsequence. \\nA subarray or substring will always be contiguous, but a subsequence need not be contiguous.....:))"
                    },
                    {
                        "username": "ashuthe1",
                        "content": "I  am trying to use divide & conquer approach but I am getting WA in 140th test case.\\ncan anyone help me in this.\\n\\nint divideRule(int l, int r, vector<int>&v)\\n    {\\n        if(l > r) return 0;\\n        if(l == r) return v[l];\\n        int mid = (l+r)/2;\\n\\n        int left = divideRule(l,mid-1,v);\\n        int right = divideRule(mid+1,r,v);\\n\\n        int ml = 1, mr = 1;\\n        for(int i = mid-1, cur = ml; i >= l; i--)\\n        {\\n            cur *= v[i];\\n            ml = max(ml,cur);\\n        }\\n        for(int i = mid+1, cur = mr; i <= r; i++)\\n        {\\n            cur *= v[i];\\n            mr = max(mr,cur);\\n        }\\n        return max({ml*v[mid]*mr,left,right});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        return divideRule(0,nums.size()-1,nums);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you\\'ve chosen, which is a divide and conquer approach, is generally sound for solving problems similar to this one. However, it falls short when dealing with the Maximum Product Subarray problem, primarily due to the presence of negative numbers and zeros in the array.\\n\\nThe main issue with your approach lies in how you calculate `left` and `right`. In your current implementation, you calculate the product of the left and right subarrays separately and then find the maximum. However, this doesn\\'t account for situations where the maximum product could span across both the left and right subarrays.\\n\\nFor example, let\\'s take the array [-2, -3, -4]. The maximum product subarray is the entire array itself, with a product of -2*-3*-4 = 24. But in your code, you divide the array into left and right subarrays, then calculate the maximum product of each, and take the maximum of these two. As a result, you miss out on the possibility that the maximum product subarray could span across both the left and right subarrays.\\n\\nFurther, your code doesn\\'t account for zeros or an even number of negative numbers correctly. For example, if you have an array like [-2, -3, 0, -4], your current code would not return the correct answer, as the maximum product is actually 24, obtained by the subarray [-2, -3, -4].\\n\\nFor these reasons, the Maximum Product Subarray problem is usually solved using a dynamic programming approach, which takes into account both the maximum and minimum product at each step. This allows the algorithm to correctly handle cases with negative numbers and zeros. It might be worth revisiting your approach to this problem and considering a dynamic programming solution instead."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/152_max_product_subarray.cpp"
                    },
                    {
                        "username": "jaronkelly0",
                        "content": "I passed all 188/188 test and yet I get a time limit exceeded? I think I figured out why the acceptance rate is so low. The problem isn\\'t difficult but with this bug I\\'m surprised anyone passed this problem. "
                    },
                    {
                        "username": "jackbb147",
                        "content": "it\\'s intentional, to prevent brute force approaches "
                    },
                    {
                        "username": "sergiycheck",
                        "content": "why the expected output for nums = [-3,-1,-1] is 3 and not -1 ? I am so confused. "
                    },
                    {
                        "username": "Aquil",
                        "content": "(-3)*(-1)=3"
                    }
                ]
            },
            {
                "id": 1746374,
                "content": [
                    {
                        "username": "jiaheaaa",
                        "content": "I understood the question (and solved it) but I still feel weird about we can't output an empty subarray and claim the product is 1... It will make things much easier."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lower bound for the array size is given to be 1 in the constraints. If the problem statement specifies that the array size has a lower bound of 1, it means that the array must contain at least one element. Therefore, we don\\'t need to consider the case of an empty array (or empty subarray), because such a situation falls outside of the problem\\'s constraints.\\n\\nIn this particular problem, the term \"subarray\" refers to a contiguous subset of elements within the array. A subarray with one element is considered valid and within the problem constraints, but an empty subarray wouldn\\'t be considered because it falls outside of the specified constraints. This is why the empty subarray (product 1) doesn\\'t come into play in this problem.\\n\\nRemember, the specifications and constraints in a problem statement are very important as they guide your solution. They often simplify the problem by eliminating the need to consider certain edge cases or more complex scenarios.\\n"
                    },
                    {
                        "username": "mars_999",
                        "content": "How I approached this problem:\\n\\nAs soon as I saw maximum product subarray with +ve and -ve integers , max sum subarray problem i. e Kadane\\'s algorithm came to my mind. But I couldn\\'t come up with anything to deal with negative numbers as that  can change the result entirely.\\n\\nSo Leetcode Official Solution helped me a lot.  Its just an extension to Kadane\\'s algo, we need to keep track of min product sub array which will help to get the max product subarray."
                    },
                    {
                        "username": "Sadiya-Irin",
                        "content": "Why this solution gives the verdict WA? Could anyone please point me out about the mistake?\\nclass Solution {\\npublic:\\nint maxProduct(vector<int> &nums){\\n    int i,n = nums.size();\\n    int prod=1, mx=LLONG_MIN;\\n    for(i=0; i<n; i++){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod==0) prod=1;\\n    }\\n//    cout<<endl;\\n    prod=1;\\n    for(i=n-1; i>=0; i--){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod == 0)   prod=1;\\n    }\\n//    cout<endl;\\n    return mx;\\n}\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code tries to solve the problem by checking the maximum product from left to right and then from right to left. However, this approach will not work for certain cases where negative numbers are involved.\\n\\nFor example, let\\'s consider the array: `[-1, -2, -3]`. The expected output is `6` because the maximum product can be achieved by multiplying all the elements. But, if you check your code, you will get `-1` as the answer. This is because your code resets `prod` to `1` whenever `prod` is `0`, but it doesn\\'t consider the case when `prod` is negative. A negative `prod` means that we have encountered an odd number of negative numbers so far, and there might be a chance that we can get a positive product by multiplying with some negative numbers in the future.\\n\\nSo, the code fails to handle the case where there are an even number of negative numbers in the array. A correct approach would be to maintain two variables, `maxProduct` and `minProduct` at each point in the array. `maxProduct` will store the maximum product that can be obtained up to the current position and `minProduct` will store the minimum (most negative) product that can be obtained up to the current position. Then at each point, you update `maxProduct` and `minProduct` using the current number, and the product of the current number with the previous `maxProduct` and `minProduct`.\\n\\nHere\\'s how you could update your function to implement this:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxProduct = nums[0], minProduct = nums[0], maxSoFar = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] < 0) swap(maxProduct, minProduct);\\n            maxProduct = max(nums[i], maxProduct * nums[i]);\\n            minProduct = min(nums[i], minProduct * nums[i]);\\n            maxSoFar = max(maxSoFar, maxProduct);\\n        }\\n\\n        return maxSoFar;\\n    }\\n};\\n```\\n\\nThis approach ensures that we correctly consider the effects of negative numbers in the array.\\n"
                    },
                    {
                        "username": "abdulhamid28",
                        "content": "testcase no 189 \\ninput nums=(no value at all)\\nhelp me"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ay96052003",
                        "content": "I cannot understand this problem, \\nfor the 1st test case : nums = [2, 3, -2, 4]\\nwhy the max product is 6 and not 12?? "
                    },
                    {
                        "username": "PhNTOm_12",
                        "content": "because [2,3] is a subarray which has a product of 6 whereas [3,4] (max product = 12)is not a a subarray, taking [3,4] means you are considering it as a subsequence. \\nA subarray or substring will always be contiguous, but a subsequence need not be contiguous.....:))"
                    },
                    {
                        "username": "ashuthe1",
                        "content": "I  am trying to use divide & conquer approach but I am getting WA in 140th test case.\\ncan anyone help me in this.\\n\\nint divideRule(int l, int r, vector<int>&v)\\n    {\\n        if(l > r) return 0;\\n        if(l == r) return v[l];\\n        int mid = (l+r)/2;\\n\\n        int left = divideRule(l,mid-1,v);\\n        int right = divideRule(mid+1,r,v);\\n\\n        int ml = 1, mr = 1;\\n        for(int i = mid-1, cur = ml; i >= l; i--)\\n        {\\n            cur *= v[i];\\n            ml = max(ml,cur);\\n        }\\n        for(int i = mid+1, cur = mr; i <= r; i++)\\n        {\\n            cur *= v[i];\\n            mr = max(mr,cur);\\n        }\\n        return max({ml*v[mid]*mr,left,right});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        return divideRule(0,nums.size()-1,nums);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you\\'ve chosen, which is a divide and conquer approach, is generally sound for solving problems similar to this one. However, it falls short when dealing with the Maximum Product Subarray problem, primarily due to the presence of negative numbers and zeros in the array.\\n\\nThe main issue with your approach lies in how you calculate `left` and `right`. In your current implementation, you calculate the product of the left and right subarrays separately and then find the maximum. However, this doesn\\'t account for situations where the maximum product could span across both the left and right subarrays.\\n\\nFor example, let\\'s take the array [-2, -3, -4]. The maximum product subarray is the entire array itself, with a product of -2*-3*-4 = 24. But in your code, you divide the array into left and right subarrays, then calculate the maximum product of each, and take the maximum of these two. As a result, you miss out on the possibility that the maximum product subarray could span across both the left and right subarrays.\\n\\nFurther, your code doesn\\'t account for zeros or an even number of negative numbers correctly. For example, if you have an array like [-2, -3, 0, -4], your current code would not return the correct answer, as the maximum product is actually 24, obtained by the subarray [-2, -3, -4].\\n\\nFor these reasons, the Maximum Product Subarray problem is usually solved using a dynamic programming approach, which takes into account both the maximum and minimum product at each step. This allows the algorithm to correctly handle cases with negative numbers and zeros. It might be worth revisiting your approach to this problem and considering a dynamic programming solution instead."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/152_max_product_subarray.cpp"
                    },
                    {
                        "username": "jaronkelly0",
                        "content": "I passed all 188/188 test and yet I get a time limit exceeded? I think I figured out why the acceptance rate is so low. The problem isn\\'t difficult but with this bug I\\'m surprised anyone passed this problem. "
                    },
                    {
                        "username": "jackbb147",
                        "content": "it\\'s intentional, to prevent brute force approaches "
                    },
                    {
                        "username": "sergiycheck",
                        "content": "why the expected output for nums = [-3,-1,-1] is 3 and not -1 ? I am so confused. "
                    },
                    {
                        "username": "Aquil",
                        "content": "(-3)*(-1)=3"
                    }
                ]
            },
            {
                "id": 1738799,
                "content": [
                    {
                        "username": "jiaheaaa",
                        "content": "I understood the question (and solved it) but I still feel weird about we can't output an empty subarray and claim the product is 1... It will make things much easier."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lower bound for the array size is given to be 1 in the constraints. If the problem statement specifies that the array size has a lower bound of 1, it means that the array must contain at least one element. Therefore, we don\\'t need to consider the case of an empty array (or empty subarray), because such a situation falls outside of the problem\\'s constraints.\\n\\nIn this particular problem, the term \"subarray\" refers to a contiguous subset of elements within the array. A subarray with one element is considered valid and within the problem constraints, but an empty subarray wouldn\\'t be considered because it falls outside of the specified constraints. This is why the empty subarray (product 1) doesn\\'t come into play in this problem.\\n\\nRemember, the specifications and constraints in a problem statement are very important as they guide your solution. They often simplify the problem by eliminating the need to consider certain edge cases or more complex scenarios.\\n"
                    },
                    {
                        "username": "mars_999",
                        "content": "How I approached this problem:\\n\\nAs soon as I saw maximum product subarray with +ve and -ve integers , max sum subarray problem i. e Kadane\\'s algorithm came to my mind. But I couldn\\'t come up with anything to deal with negative numbers as that  can change the result entirely.\\n\\nSo Leetcode Official Solution helped me a lot.  Its just an extension to Kadane\\'s algo, we need to keep track of min product sub array which will help to get the max product subarray."
                    },
                    {
                        "username": "Sadiya-Irin",
                        "content": "Why this solution gives the verdict WA? Could anyone please point me out about the mistake?\\nclass Solution {\\npublic:\\nint maxProduct(vector<int> &nums){\\n    int i,n = nums.size();\\n    int prod=1, mx=LLONG_MIN;\\n    for(i=0; i<n; i++){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod==0) prod=1;\\n    }\\n//    cout<<endl;\\n    prod=1;\\n    for(i=n-1; i>=0; i--){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod == 0)   prod=1;\\n    }\\n//    cout<endl;\\n    return mx;\\n}\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code tries to solve the problem by checking the maximum product from left to right and then from right to left. However, this approach will not work for certain cases where negative numbers are involved.\\n\\nFor example, let\\'s consider the array: `[-1, -2, -3]`. The expected output is `6` because the maximum product can be achieved by multiplying all the elements. But, if you check your code, you will get `-1` as the answer. This is because your code resets `prod` to `1` whenever `prod` is `0`, but it doesn\\'t consider the case when `prod` is negative. A negative `prod` means that we have encountered an odd number of negative numbers so far, and there might be a chance that we can get a positive product by multiplying with some negative numbers in the future.\\n\\nSo, the code fails to handle the case where there are an even number of negative numbers in the array. A correct approach would be to maintain two variables, `maxProduct` and `minProduct` at each point in the array. `maxProduct` will store the maximum product that can be obtained up to the current position and `minProduct` will store the minimum (most negative) product that can be obtained up to the current position. Then at each point, you update `maxProduct` and `minProduct` using the current number, and the product of the current number with the previous `maxProduct` and `minProduct`.\\n\\nHere\\'s how you could update your function to implement this:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxProduct = nums[0], minProduct = nums[0], maxSoFar = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] < 0) swap(maxProduct, minProduct);\\n            maxProduct = max(nums[i], maxProduct * nums[i]);\\n            minProduct = min(nums[i], minProduct * nums[i]);\\n            maxSoFar = max(maxSoFar, maxProduct);\\n        }\\n\\n        return maxSoFar;\\n    }\\n};\\n```\\n\\nThis approach ensures that we correctly consider the effects of negative numbers in the array.\\n"
                    },
                    {
                        "username": "abdulhamid28",
                        "content": "testcase no 189 \\ninput nums=(no value at all)\\nhelp me"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ay96052003",
                        "content": "I cannot understand this problem, \\nfor the 1st test case : nums = [2, 3, -2, 4]\\nwhy the max product is 6 and not 12?? "
                    },
                    {
                        "username": "PhNTOm_12",
                        "content": "because [2,3] is a subarray which has a product of 6 whereas [3,4] (max product = 12)is not a a subarray, taking [3,4] means you are considering it as a subsequence. \\nA subarray or substring will always be contiguous, but a subsequence need not be contiguous.....:))"
                    },
                    {
                        "username": "ashuthe1",
                        "content": "I  am trying to use divide & conquer approach but I am getting WA in 140th test case.\\ncan anyone help me in this.\\n\\nint divideRule(int l, int r, vector<int>&v)\\n    {\\n        if(l > r) return 0;\\n        if(l == r) return v[l];\\n        int mid = (l+r)/2;\\n\\n        int left = divideRule(l,mid-1,v);\\n        int right = divideRule(mid+1,r,v);\\n\\n        int ml = 1, mr = 1;\\n        for(int i = mid-1, cur = ml; i >= l; i--)\\n        {\\n            cur *= v[i];\\n            ml = max(ml,cur);\\n        }\\n        for(int i = mid+1, cur = mr; i <= r; i++)\\n        {\\n            cur *= v[i];\\n            mr = max(mr,cur);\\n        }\\n        return max({ml*v[mid]*mr,left,right});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        return divideRule(0,nums.size()-1,nums);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you\\'ve chosen, which is a divide and conquer approach, is generally sound for solving problems similar to this one. However, it falls short when dealing with the Maximum Product Subarray problem, primarily due to the presence of negative numbers and zeros in the array.\\n\\nThe main issue with your approach lies in how you calculate `left` and `right`. In your current implementation, you calculate the product of the left and right subarrays separately and then find the maximum. However, this doesn\\'t account for situations where the maximum product could span across both the left and right subarrays.\\n\\nFor example, let\\'s take the array [-2, -3, -4]. The maximum product subarray is the entire array itself, with a product of -2*-3*-4 = 24. But in your code, you divide the array into left and right subarrays, then calculate the maximum product of each, and take the maximum of these two. As a result, you miss out on the possibility that the maximum product subarray could span across both the left and right subarrays.\\n\\nFurther, your code doesn\\'t account for zeros or an even number of negative numbers correctly. For example, if you have an array like [-2, -3, 0, -4], your current code would not return the correct answer, as the maximum product is actually 24, obtained by the subarray [-2, -3, -4].\\n\\nFor these reasons, the Maximum Product Subarray problem is usually solved using a dynamic programming approach, which takes into account both the maximum and minimum product at each step. This allows the algorithm to correctly handle cases with negative numbers and zeros. It might be worth revisiting your approach to this problem and considering a dynamic programming solution instead."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/152_max_product_subarray.cpp"
                    },
                    {
                        "username": "jaronkelly0",
                        "content": "I passed all 188/188 test and yet I get a time limit exceeded? I think I figured out why the acceptance rate is so low. The problem isn\\'t difficult but with this bug I\\'m surprised anyone passed this problem. "
                    },
                    {
                        "username": "jackbb147",
                        "content": "it\\'s intentional, to prevent brute force approaches "
                    },
                    {
                        "username": "sergiycheck",
                        "content": "why the expected output for nums = [-3,-1,-1] is 3 and not -1 ? I am so confused. "
                    },
                    {
                        "username": "Aquil",
                        "content": "(-3)*(-1)=3"
                    }
                ]
            },
            {
                "id": 1724233,
                "content": [
                    {
                        "username": "jiaheaaa",
                        "content": "I understood the question (and solved it) but I still feel weird about we can't output an empty subarray and claim the product is 1... It will make things much easier."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lower bound for the array size is given to be 1 in the constraints. If the problem statement specifies that the array size has a lower bound of 1, it means that the array must contain at least one element. Therefore, we don\\'t need to consider the case of an empty array (or empty subarray), because such a situation falls outside of the problem\\'s constraints.\\n\\nIn this particular problem, the term \"subarray\" refers to a contiguous subset of elements within the array. A subarray with one element is considered valid and within the problem constraints, but an empty subarray wouldn\\'t be considered because it falls outside of the specified constraints. This is why the empty subarray (product 1) doesn\\'t come into play in this problem.\\n\\nRemember, the specifications and constraints in a problem statement are very important as they guide your solution. They often simplify the problem by eliminating the need to consider certain edge cases or more complex scenarios.\\n"
                    },
                    {
                        "username": "mars_999",
                        "content": "How I approached this problem:\\n\\nAs soon as I saw maximum product subarray with +ve and -ve integers , max sum subarray problem i. e Kadane\\'s algorithm came to my mind. But I couldn\\'t come up with anything to deal with negative numbers as that  can change the result entirely.\\n\\nSo Leetcode Official Solution helped me a lot.  Its just an extension to Kadane\\'s algo, we need to keep track of min product sub array which will help to get the max product subarray."
                    },
                    {
                        "username": "Sadiya-Irin",
                        "content": "Why this solution gives the verdict WA? Could anyone please point me out about the mistake?\\nclass Solution {\\npublic:\\nint maxProduct(vector<int> &nums){\\n    int i,n = nums.size();\\n    int prod=1, mx=LLONG_MIN;\\n    for(i=0; i<n; i++){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod==0) prod=1;\\n    }\\n//    cout<<endl;\\n    prod=1;\\n    for(i=n-1; i>=0; i--){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod == 0)   prod=1;\\n    }\\n//    cout<endl;\\n    return mx;\\n}\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code tries to solve the problem by checking the maximum product from left to right and then from right to left. However, this approach will not work for certain cases where negative numbers are involved.\\n\\nFor example, let\\'s consider the array: `[-1, -2, -3]`. The expected output is `6` because the maximum product can be achieved by multiplying all the elements. But, if you check your code, you will get `-1` as the answer. This is because your code resets `prod` to `1` whenever `prod` is `0`, but it doesn\\'t consider the case when `prod` is negative. A negative `prod` means that we have encountered an odd number of negative numbers so far, and there might be a chance that we can get a positive product by multiplying with some negative numbers in the future.\\n\\nSo, the code fails to handle the case where there are an even number of negative numbers in the array. A correct approach would be to maintain two variables, `maxProduct` and `minProduct` at each point in the array. `maxProduct` will store the maximum product that can be obtained up to the current position and `minProduct` will store the minimum (most negative) product that can be obtained up to the current position. Then at each point, you update `maxProduct` and `minProduct` using the current number, and the product of the current number with the previous `maxProduct` and `minProduct`.\\n\\nHere\\'s how you could update your function to implement this:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxProduct = nums[0], minProduct = nums[0], maxSoFar = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] < 0) swap(maxProduct, minProduct);\\n            maxProduct = max(nums[i], maxProduct * nums[i]);\\n            minProduct = min(nums[i], minProduct * nums[i]);\\n            maxSoFar = max(maxSoFar, maxProduct);\\n        }\\n\\n        return maxSoFar;\\n    }\\n};\\n```\\n\\nThis approach ensures that we correctly consider the effects of negative numbers in the array.\\n"
                    },
                    {
                        "username": "abdulhamid28",
                        "content": "testcase no 189 \\ninput nums=(no value at all)\\nhelp me"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ay96052003",
                        "content": "I cannot understand this problem, \\nfor the 1st test case : nums = [2, 3, -2, 4]\\nwhy the max product is 6 and not 12?? "
                    },
                    {
                        "username": "PhNTOm_12",
                        "content": "because [2,3] is a subarray which has a product of 6 whereas [3,4] (max product = 12)is not a a subarray, taking [3,4] means you are considering it as a subsequence. \\nA subarray or substring will always be contiguous, but a subsequence need not be contiguous.....:))"
                    },
                    {
                        "username": "ashuthe1",
                        "content": "I  am trying to use divide & conquer approach but I am getting WA in 140th test case.\\ncan anyone help me in this.\\n\\nint divideRule(int l, int r, vector<int>&v)\\n    {\\n        if(l > r) return 0;\\n        if(l == r) return v[l];\\n        int mid = (l+r)/2;\\n\\n        int left = divideRule(l,mid-1,v);\\n        int right = divideRule(mid+1,r,v);\\n\\n        int ml = 1, mr = 1;\\n        for(int i = mid-1, cur = ml; i >= l; i--)\\n        {\\n            cur *= v[i];\\n            ml = max(ml,cur);\\n        }\\n        for(int i = mid+1, cur = mr; i <= r; i++)\\n        {\\n            cur *= v[i];\\n            mr = max(mr,cur);\\n        }\\n        return max({ml*v[mid]*mr,left,right});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        return divideRule(0,nums.size()-1,nums);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you\\'ve chosen, which is a divide and conquer approach, is generally sound for solving problems similar to this one. However, it falls short when dealing with the Maximum Product Subarray problem, primarily due to the presence of negative numbers and zeros in the array.\\n\\nThe main issue with your approach lies in how you calculate `left` and `right`. In your current implementation, you calculate the product of the left and right subarrays separately and then find the maximum. However, this doesn\\'t account for situations where the maximum product could span across both the left and right subarrays.\\n\\nFor example, let\\'s take the array [-2, -3, -4]. The maximum product subarray is the entire array itself, with a product of -2*-3*-4 = 24. But in your code, you divide the array into left and right subarrays, then calculate the maximum product of each, and take the maximum of these two. As a result, you miss out on the possibility that the maximum product subarray could span across both the left and right subarrays.\\n\\nFurther, your code doesn\\'t account for zeros or an even number of negative numbers correctly. For example, if you have an array like [-2, -3, 0, -4], your current code would not return the correct answer, as the maximum product is actually 24, obtained by the subarray [-2, -3, -4].\\n\\nFor these reasons, the Maximum Product Subarray problem is usually solved using a dynamic programming approach, which takes into account both the maximum and minimum product at each step. This allows the algorithm to correctly handle cases with negative numbers and zeros. It might be worth revisiting your approach to this problem and considering a dynamic programming solution instead."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/152_max_product_subarray.cpp"
                    },
                    {
                        "username": "jaronkelly0",
                        "content": "I passed all 188/188 test and yet I get a time limit exceeded? I think I figured out why the acceptance rate is so low. The problem isn\\'t difficult but with this bug I\\'m surprised anyone passed this problem. "
                    },
                    {
                        "username": "jackbb147",
                        "content": "it\\'s intentional, to prevent brute force approaches "
                    },
                    {
                        "username": "sergiycheck",
                        "content": "why the expected output for nums = [-3,-1,-1] is 3 and not -1 ? I am so confused. "
                    },
                    {
                        "username": "Aquil",
                        "content": "(-3)*(-1)=3"
                    }
                ]
            },
            {
                "id": 1720746,
                "content": [
                    {
                        "username": "jiaheaaa",
                        "content": "I understood the question (and solved it) but I still feel weird about we can't output an empty subarray and claim the product is 1... It will make things much easier."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lower bound for the array size is given to be 1 in the constraints. If the problem statement specifies that the array size has a lower bound of 1, it means that the array must contain at least one element. Therefore, we don\\'t need to consider the case of an empty array (or empty subarray), because such a situation falls outside of the problem\\'s constraints.\\n\\nIn this particular problem, the term \"subarray\" refers to a contiguous subset of elements within the array. A subarray with one element is considered valid and within the problem constraints, but an empty subarray wouldn\\'t be considered because it falls outside of the specified constraints. This is why the empty subarray (product 1) doesn\\'t come into play in this problem.\\n\\nRemember, the specifications and constraints in a problem statement are very important as they guide your solution. They often simplify the problem by eliminating the need to consider certain edge cases or more complex scenarios.\\n"
                    },
                    {
                        "username": "mars_999",
                        "content": "How I approached this problem:\\n\\nAs soon as I saw maximum product subarray with +ve and -ve integers , max sum subarray problem i. e Kadane\\'s algorithm came to my mind. But I couldn\\'t come up with anything to deal with negative numbers as that  can change the result entirely.\\n\\nSo Leetcode Official Solution helped me a lot.  Its just an extension to Kadane\\'s algo, we need to keep track of min product sub array which will help to get the max product subarray."
                    },
                    {
                        "username": "Sadiya-Irin",
                        "content": "Why this solution gives the verdict WA? Could anyone please point me out about the mistake?\\nclass Solution {\\npublic:\\nint maxProduct(vector<int> &nums){\\n    int i,n = nums.size();\\n    int prod=1, mx=LLONG_MIN;\\n    for(i=0; i<n; i++){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod==0) prod=1;\\n    }\\n//    cout<<endl;\\n    prod=1;\\n    for(i=n-1; i>=0; i--){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod == 0)   prod=1;\\n    }\\n//    cout<endl;\\n    return mx;\\n}\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code tries to solve the problem by checking the maximum product from left to right and then from right to left. However, this approach will not work for certain cases where negative numbers are involved.\\n\\nFor example, let\\'s consider the array: `[-1, -2, -3]`. The expected output is `6` because the maximum product can be achieved by multiplying all the elements. But, if you check your code, you will get `-1` as the answer. This is because your code resets `prod` to `1` whenever `prod` is `0`, but it doesn\\'t consider the case when `prod` is negative. A negative `prod` means that we have encountered an odd number of negative numbers so far, and there might be a chance that we can get a positive product by multiplying with some negative numbers in the future.\\n\\nSo, the code fails to handle the case where there are an even number of negative numbers in the array. A correct approach would be to maintain two variables, `maxProduct` and `minProduct` at each point in the array. `maxProduct` will store the maximum product that can be obtained up to the current position and `minProduct` will store the minimum (most negative) product that can be obtained up to the current position. Then at each point, you update `maxProduct` and `minProduct` using the current number, and the product of the current number with the previous `maxProduct` and `minProduct`.\\n\\nHere\\'s how you could update your function to implement this:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxProduct = nums[0], minProduct = nums[0], maxSoFar = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] < 0) swap(maxProduct, minProduct);\\n            maxProduct = max(nums[i], maxProduct * nums[i]);\\n            minProduct = min(nums[i], minProduct * nums[i]);\\n            maxSoFar = max(maxSoFar, maxProduct);\\n        }\\n\\n        return maxSoFar;\\n    }\\n};\\n```\\n\\nThis approach ensures that we correctly consider the effects of negative numbers in the array.\\n"
                    },
                    {
                        "username": "abdulhamid28",
                        "content": "testcase no 189 \\ninput nums=(no value at all)\\nhelp me"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ay96052003",
                        "content": "I cannot understand this problem, \\nfor the 1st test case : nums = [2, 3, -2, 4]\\nwhy the max product is 6 and not 12?? "
                    },
                    {
                        "username": "PhNTOm_12",
                        "content": "because [2,3] is a subarray which has a product of 6 whereas [3,4] (max product = 12)is not a a subarray, taking [3,4] means you are considering it as a subsequence. \\nA subarray or substring will always be contiguous, but a subsequence need not be contiguous.....:))"
                    },
                    {
                        "username": "ashuthe1",
                        "content": "I  am trying to use divide & conquer approach but I am getting WA in 140th test case.\\ncan anyone help me in this.\\n\\nint divideRule(int l, int r, vector<int>&v)\\n    {\\n        if(l > r) return 0;\\n        if(l == r) return v[l];\\n        int mid = (l+r)/2;\\n\\n        int left = divideRule(l,mid-1,v);\\n        int right = divideRule(mid+1,r,v);\\n\\n        int ml = 1, mr = 1;\\n        for(int i = mid-1, cur = ml; i >= l; i--)\\n        {\\n            cur *= v[i];\\n            ml = max(ml,cur);\\n        }\\n        for(int i = mid+1, cur = mr; i <= r; i++)\\n        {\\n            cur *= v[i];\\n            mr = max(mr,cur);\\n        }\\n        return max({ml*v[mid]*mr,left,right});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        return divideRule(0,nums.size()-1,nums);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you\\'ve chosen, which is a divide and conquer approach, is generally sound for solving problems similar to this one. However, it falls short when dealing with the Maximum Product Subarray problem, primarily due to the presence of negative numbers and zeros in the array.\\n\\nThe main issue with your approach lies in how you calculate `left` and `right`. In your current implementation, you calculate the product of the left and right subarrays separately and then find the maximum. However, this doesn\\'t account for situations where the maximum product could span across both the left and right subarrays.\\n\\nFor example, let\\'s take the array [-2, -3, -4]. The maximum product subarray is the entire array itself, with a product of -2*-3*-4 = 24. But in your code, you divide the array into left and right subarrays, then calculate the maximum product of each, and take the maximum of these two. As a result, you miss out on the possibility that the maximum product subarray could span across both the left and right subarrays.\\n\\nFurther, your code doesn\\'t account for zeros or an even number of negative numbers correctly. For example, if you have an array like [-2, -3, 0, -4], your current code would not return the correct answer, as the maximum product is actually 24, obtained by the subarray [-2, -3, -4].\\n\\nFor these reasons, the Maximum Product Subarray problem is usually solved using a dynamic programming approach, which takes into account both the maximum and minimum product at each step. This allows the algorithm to correctly handle cases with negative numbers and zeros. It might be worth revisiting your approach to this problem and considering a dynamic programming solution instead."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/152_max_product_subarray.cpp"
                    },
                    {
                        "username": "jaronkelly0",
                        "content": "I passed all 188/188 test and yet I get a time limit exceeded? I think I figured out why the acceptance rate is so low. The problem isn\\'t difficult but with this bug I\\'m surprised anyone passed this problem. "
                    },
                    {
                        "username": "jackbb147",
                        "content": "it\\'s intentional, to prevent brute force approaches "
                    },
                    {
                        "username": "sergiycheck",
                        "content": "why the expected output for nums = [-3,-1,-1] is 3 and not -1 ? I am so confused. "
                    },
                    {
                        "username": "Aquil",
                        "content": "(-3)*(-1)=3"
                    }
                ]
            },
            {
                "id": 1718421,
                "content": [
                    {
                        "username": "jiaheaaa",
                        "content": "I understood the question (and solved it) but I still feel weird about we can't output an empty subarray and claim the product is 1... It will make things much easier."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lower bound for the array size is given to be 1 in the constraints. If the problem statement specifies that the array size has a lower bound of 1, it means that the array must contain at least one element. Therefore, we don\\'t need to consider the case of an empty array (or empty subarray), because such a situation falls outside of the problem\\'s constraints.\\n\\nIn this particular problem, the term \"subarray\" refers to a contiguous subset of elements within the array. A subarray with one element is considered valid and within the problem constraints, but an empty subarray wouldn\\'t be considered because it falls outside of the specified constraints. This is why the empty subarray (product 1) doesn\\'t come into play in this problem.\\n\\nRemember, the specifications and constraints in a problem statement are very important as they guide your solution. They often simplify the problem by eliminating the need to consider certain edge cases or more complex scenarios.\\n"
                    },
                    {
                        "username": "mars_999",
                        "content": "How I approached this problem:\\n\\nAs soon as I saw maximum product subarray with +ve and -ve integers , max sum subarray problem i. e Kadane\\'s algorithm came to my mind. But I couldn\\'t come up with anything to deal with negative numbers as that  can change the result entirely.\\n\\nSo Leetcode Official Solution helped me a lot.  Its just an extension to Kadane\\'s algo, we need to keep track of min product sub array which will help to get the max product subarray."
                    },
                    {
                        "username": "Sadiya-Irin",
                        "content": "Why this solution gives the verdict WA? Could anyone please point me out about the mistake?\\nclass Solution {\\npublic:\\nint maxProduct(vector<int> &nums){\\n    int i,n = nums.size();\\n    int prod=1, mx=LLONG_MIN;\\n    for(i=0; i<n; i++){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod==0) prod=1;\\n    }\\n//    cout<<endl;\\n    prod=1;\\n    for(i=n-1; i>=0; i--){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod == 0)   prod=1;\\n    }\\n//    cout<endl;\\n    return mx;\\n}\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code tries to solve the problem by checking the maximum product from left to right and then from right to left. However, this approach will not work for certain cases where negative numbers are involved.\\n\\nFor example, let\\'s consider the array: `[-1, -2, -3]`. The expected output is `6` because the maximum product can be achieved by multiplying all the elements. But, if you check your code, you will get `-1` as the answer. This is because your code resets `prod` to `1` whenever `prod` is `0`, but it doesn\\'t consider the case when `prod` is negative. A negative `prod` means that we have encountered an odd number of negative numbers so far, and there might be a chance that we can get a positive product by multiplying with some negative numbers in the future.\\n\\nSo, the code fails to handle the case where there are an even number of negative numbers in the array. A correct approach would be to maintain two variables, `maxProduct` and `minProduct` at each point in the array. `maxProduct` will store the maximum product that can be obtained up to the current position and `minProduct` will store the minimum (most negative) product that can be obtained up to the current position. Then at each point, you update `maxProduct` and `minProduct` using the current number, and the product of the current number with the previous `maxProduct` and `minProduct`.\\n\\nHere\\'s how you could update your function to implement this:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxProduct = nums[0], minProduct = nums[0], maxSoFar = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] < 0) swap(maxProduct, minProduct);\\n            maxProduct = max(nums[i], maxProduct * nums[i]);\\n            minProduct = min(nums[i], minProduct * nums[i]);\\n            maxSoFar = max(maxSoFar, maxProduct);\\n        }\\n\\n        return maxSoFar;\\n    }\\n};\\n```\\n\\nThis approach ensures that we correctly consider the effects of negative numbers in the array.\\n"
                    },
                    {
                        "username": "abdulhamid28",
                        "content": "testcase no 189 \\ninput nums=(no value at all)\\nhelp me"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ay96052003",
                        "content": "I cannot understand this problem, \\nfor the 1st test case : nums = [2, 3, -2, 4]\\nwhy the max product is 6 and not 12?? "
                    },
                    {
                        "username": "PhNTOm_12",
                        "content": "because [2,3] is a subarray which has a product of 6 whereas [3,4] (max product = 12)is not a a subarray, taking [3,4] means you are considering it as a subsequence. \\nA subarray or substring will always be contiguous, but a subsequence need not be contiguous.....:))"
                    },
                    {
                        "username": "ashuthe1",
                        "content": "I  am trying to use divide & conquer approach but I am getting WA in 140th test case.\\ncan anyone help me in this.\\n\\nint divideRule(int l, int r, vector<int>&v)\\n    {\\n        if(l > r) return 0;\\n        if(l == r) return v[l];\\n        int mid = (l+r)/2;\\n\\n        int left = divideRule(l,mid-1,v);\\n        int right = divideRule(mid+1,r,v);\\n\\n        int ml = 1, mr = 1;\\n        for(int i = mid-1, cur = ml; i >= l; i--)\\n        {\\n            cur *= v[i];\\n            ml = max(ml,cur);\\n        }\\n        for(int i = mid+1, cur = mr; i <= r; i++)\\n        {\\n            cur *= v[i];\\n            mr = max(mr,cur);\\n        }\\n        return max({ml*v[mid]*mr,left,right});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        return divideRule(0,nums.size()-1,nums);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you\\'ve chosen, which is a divide and conquer approach, is generally sound for solving problems similar to this one. However, it falls short when dealing with the Maximum Product Subarray problem, primarily due to the presence of negative numbers and zeros in the array.\\n\\nThe main issue with your approach lies in how you calculate `left` and `right`. In your current implementation, you calculate the product of the left and right subarrays separately and then find the maximum. However, this doesn\\'t account for situations where the maximum product could span across both the left and right subarrays.\\n\\nFor example, let\\'s take the array [-2, -3, -4]. The maximum product subarray is the entire array itself, with a product of -2*-3*-4 = 24. But in your code, you divide the array into left and right subarrays, then calculate the maximum product of each, and take the maximum of these two. As a result, you miss out on the possibility that the maximum product subarray could span across both the left and right subarrays.\\n\\nFurther, your code doesn\\'t account for zeros or an even number of negative numbers correctly. For example, if you have an array like [-2, -3, 0, -4], your current code would not return the correct answer, as the maximum product is actually 24, obtained by the subarray [-2, -3, -4].\\n\\nFor these reasons, the Maximum Product Subarray problem is usually solved using a dynamic programming approach, which takes into account both the maximum and minimum product at each step. This allows the algorithm to correctly handle cases with negative numbers and zeros. It might be worth revisiting your approach to this problem and considering a dynamic programming solution instead."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/152_max_product_subarray.cpp"
                    },
                    {
                        "username": "jaronkelly0",
                        "content": "I passed all 188/188 test and yet I get a time limit exceeded? I think I figured out why the acceptance rate is so low. The problem isn\\'t difficult but with this bug I\\'m surprised anyone passed this problem. "
                    },
                    {
                        "username": "jackbb147",
                        "content": "it\\'s intentional, to prevent brute force approaches "
                    },
                    {
                        "username": "sergiycheck",
                        "content": "why the expected output for nums = [-3,-1,-1] is 3 and not -1 ? I am so confused. "
                    },
                    {
                        "username": "Aquil",
                        "content": "(-3)*(-1)=3"
                    }
                ]
            }
        ]
    },
    {
        "title": "Meeting Rooms",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1928591,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "It would\\'ve been helpful if they mentioned whether a person could attend a meeting that starts exactly after another meeting ends. "
                    },
                    {
                        "username": "CivilCS",
                        "content": "Exactly, I was running into that issue and failing 4 test cases because of this. \\n\\nCLARIFICATION:\\nA person cannot  attend a meeting that starts at the same time another meeting ends "
                    },
                    {
                        "username": "granzort",
                        "content": "Trying to understand why empty interval needs to return true logically. For some problems, default results are more predictable than this, or it is given through the notes. If anyone have good logical explanation it would be helpful.\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is saying \"Do I have a schedule conflict?\"\n\nIf `intervals` is empty then clearly False doesn't work. If you don't have any meetings you can't have a schedule conflict. It makes perfect sense to return True since you don't have a conflict.\n\nA slightly different interpretation is \"Can I attend all my meetings?\". Then you could argue it's weird to say you can attend all meetings when you don't even _have_ any meetings. But False definitely still doesn't work.\n\nUnder this interpretation you could say that not having meetings is an error. In production code you might throw an exception or return an error code. But LeetCode doesn't allow for that in this problem definition so you don't have a choice anyway."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Sort the intervals by start time, then check whether all pairs of consecutive intervals are disjoint.\\n\\n    def can_attend_meetings(intervals)\\n      intervals.sort_by(&:start).each_cons(2).all? { |i, j| i.end <= j.start }\\n    end"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "This is a pure \"Line Sweep\" problem. Why not add \"Prefix Sum\" and \"Line Sweep\" tags for this problem? This might help someone coming up with a solution or even find this problem in the list of problems."
                    },
                    {
                        "username": "FRin323",
                        "content": "why is \\'*range\\' giving a syntax error?"
                    }
                ]
            },
            {
                "id": 1573106,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "It would\\'ve been helpful if they mentioned whether a person could attend a meeting that starts exactly after another meeting ends. "
                    },
                    {
                        "username": "CivilCS",
                        "content": "Exactly, I was running into that issue and failing 4 test cases because of this. \\n\\nCLARIFICATION:\\nA person cannot  attend a meeting that starts at the same time another meeting ends "
                    },
                    {
                        "username": "granzort",
                        "content": "Trying to understand why empty interval needs to return true logically. For some problems, default results are more predictable than this, or it is given through the notes. If anyone have good logical explanation it would be helpful.\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is saying \"Do I have a schedule conflict?\"\n\nIf `intervals` is empty then clearly False doesn't work. If you don't have any meetings you can't have a schedule conflict. It makes perfect sense to return True since you don't have a conflict.\n\nA slightly different interpretation is \"Can I attend all my meetings?\". Then you could argue it's weird to say you can attend all meetings when you don't even _have_ any meetings. But False definitely still doesn't work.\n\nUnder this interpretation you could say that not having meetings is an error. In production code you might throw an exception or return an error code. But LeetCode doesn't allow for that in this problem definition so you don't have a choice anyway."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Sort the intervals by start time, then check whether all pairs of consecutive intervals are disjoint.\\n\\n    def can_attend_meetings(intervals)\\n      intervals.sort_by(&:start).each_cons(2).all? { |i, j| i.end <= j.start }\\n    end"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "This is a pure \"Line Sweep\" problem. Why not add \"Prefix Sum\" and \"Line Sweep\" tags for this problem? This might help someone coming up with a solution or even find this problem in the list of problems."
                    },
                    {
                        "username": "FRin323",
                        "content": "why is \\'*range\\' giving a syntax error?"
                    }
                ]
            },
            {
                "id": 1571493,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "It would\\'ve been helpful if they mentioned whether a person could attend a meeting that starts exactly after another meeting ends. "
                    },
                    {
                        "username": "CivilCS",
                        "content": "Exactly, I was running into that issue and failing 4 test cases because of this. \\n\\nCLARIFICATION:\\nA person cannot  attend a meeting that starts at the same time another meeting ends "
                    },
                    {
                        "username": "granzort",
                        "content": "Trying to understand why empty interval needs to return true logically. For some problems, default results are more predictable than this, or it is given through the notes. If anyone have good logical explanation it would be helpful.\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is saying \"Do I have a schedule conflict?\"\n\nIf `intervals` is empty then clearly False doesn't work. If you don't have any meetings you can't have a schedule conflict. It makes perfect sense to return True since you don't have a conflict.\n\nA slightly different interpretation is \"Can I attend all my meetings?\". Then you could argue it's weird to say you can attend all meetings when you don't even _have_ any meetings. But False definitely still doesn't work.\n\nUnder this interpretation you could say that not having meetings is an error. In production code you might throw an exception or return an error code. But LeetCode doesn't allow for that in this problem definition so you don't have a choice anyway."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Sort the intervals by start time, then check whether all pairs of consecutive intervals are disjoint.\\n\\n    def can_attend_meetings(intervals)\\n      intervals.sort_by(&:start).each_cons(2).all? { |i, j| i.end <= j.start }\\n    end"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "This is a pure \"Line Sweep\" problem. Why not add \"Prefix Sum\" and \"Line Sweep\" tags for this problem? This might help someone coming up with a solution or even find this problem in the list of problems."
                    },
                    {
                        "username": "FRin323",
                        "content": "why is \\'*range\\' giving a syntax error?"
                    }
                ]
            },
            {
                "id": 2053905,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "It would\\'ve been helpful if they mentioned whether a person could attend a meeting that starts exactly after another meeting ends. "
                    },
                    {
                        "username": "CivilCS",
                        "content": "Exactly, I was running into that issue and failing 4 test cases because of this. \\n\\nCLARIFICATION:\\nA person cannot  attend a meeting that starts at the same time another meeting ends "
                    },
                    {
                        "username": "granzort",
                        "content": "Trying to understand why empty interval needs to return true logically. For some problems, default results are more predictable than this, or it is given through the notes. If anyone have good logical explanation it would be helpful.\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is saying \"Do I have a schedule conflict?\"\n\nIf `intervals` is empty then clearly False doesn't work. If you don't have any meetings you can't have a schedule conflict. It makes perfect sense to return True since you don't have a conflict.\n\nA slightly different interpretation is \"Can I attend all my meetings?\". Then you could argue it's weird to say you can attend all meetings when you don't even _have_ any meetings. But False definitely still doesn't work.\n\nUnder this interpretation you could say that not having meetings is an error. In production code you might throw an exception or return an error code. But LeetCode doesn't allow for that in this problem definition so you don't have a choice anyway."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Sort the intervals by start time, then check whether all pairs of consecutive intervals are disjoint.\\n\\n    def can_attend_meetings(intervals)\\n      intervals.sort_by(&:start).each_cons(2).all? { |i, j| i.end <= j.start }\\n    end"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "This is a pure \"Line Sweep\" problem. Why not add \"Prefix Sum\" and \"Line Sweep\" tags for this problem? This might help someone coming up with a solution or even find this problem in the list of problems."
                    },
                    {
                        "username": "FRin323",
                        "content": "why is \\'*range\\' giving a syntax error?"
                    }
                ]
            },
            {
                "id": 1746557,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "It would\\'ve been helpful if they mentioned whether a person could attend a meeting that starts exactly after another meeting ends. "
                    },
                    {
                        "username": "CivilCS",
                        "content": "Exactly, I was running into that issue and failing 4 test cases because of this. \\n\\nCLARIFICATION:\\nA person cannot  attend a meeting that starts at the same time another meeting ends "
                    },
                    {
                        "username": "granzort",
                        "content": "Trying to understand why empty interval needs to return true logically. For some problems, default results are more predictable than this, or it is given through the notes. If anyone have good logical explanation it would be helpful.\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is saying \"Do I have a schedule conflict?\"\n\nIf `intervals` is empty then clearly False doesn't work. If you don't have any meetings you can't have a schedule conflict. It makes perfect sense to return True since you don't have a conflict.\n\nA slightly different interpretation is \"Can I attend all my meetings?\". Then you could argue it's weird to say you can attend all meetings when you don't even _have_ any meetings. But False definitely still doesn't work.\n\nUnder this interpretation you could say that not having meetings is an error. In production code you might throw an exception or return an error code. But LeetCode doesn't allow for that in this problem definition so you don't have a choice anyway."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Sort the intervals by start time, then check whether all pairs of consecutive intervals are disjoint.\\n\\n    def can_attend_meetings(intervals)\\n      intervals.sort_by(&:start).each_cons(2).all? { |i, j| i.end <= j.start }\\n    end"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "This is a pure \"Line Sweep\" problem. Why not add \"Prefix Sum\" and \"Line Sweep\" tags for this problem? This might help someone coming up with a solution or even find this problem in the list of problems."
                    },
                    {
                        "username": "FRin323",
                        "content": "why is \\'*range\\' giving a syntax error?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Data Stream as Disjoint Intervals",
        "question_content": "<p>Given a data stream input of non-negative integers <code>a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub></code>, summarize the numbers seen so far as a list of disjoint intervals.</p>\n\n<p>Implement the <code>SummaryRanges</code> class:</p>\n\n<ul>\n\t<li><code>SummaryRanges()</code> Initializes the object with an empty stream.</li>\n\t<li><code>void addNum(int value)</code> Adds the integer <code>value</code> to the stream.</li>\n\t<li><code>int[][] getIntervals()</code> Returns a summary of the integers in the stream currently as a list of disjoint intervals <code>[start<sub>i</sub>, end<sub>i</sub>]</code>. The answer should be sorted by <code>start<sub>i</sub></code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;SummaryRanges&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]\n<strong>Output</strong>\n[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]\n\n<strong>Explanation</strong>\nSummaryRanges summaryRanges = new SummaryRanges();\nsummaryRanges.addNum(1);      // arr = [1]\nsummaryRanges.getIntervals(); // return [[1, 1]]\nsummaryRanges.addNum(3);      // arr = [1, 3]\nsummaryRanges.getIntervals(); // return [[1, 1], [3, 3]]\nsummaryRanges.addNum(7);      // arr = [1, 3, 7]\nsummaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]]\nsummaryRanges.addNum(2);      // arr = [1, 2, 3, 7]\nsummaryRanges.getIntervals(); // return [[1, 3], [7, 7]]\nsummaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]\nsummaryRanges.getIntervals(); // return [[1, 3], [6, 7]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= value &lt;= 10<sup>4</sup></code></li>\n\t<li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>addNum</code> and <code>getIntervals</code>.</li>\n\t<li>At most <code>10<sup>2</sup></code>&nbsp;calls will be made to&nbsp;<code>getIntervals</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> What if there are lots of merges and the number of disjoint intervals is small compared to the size of the data stream?</p>\n",
        "solutions": [
            {
                "id": 3107308,
                "title": "c-binary-search-ordered-set-with-full-explanation-beats-99",
                "content": "# Intuition\\nThe intuition behind this implementation is to use a data structure that allows for easy ordering and searching, as well as efficient insertion and deletion of intervals. In this case, a std::map is used to store the disjoint intervals. The key is the start value of the interval and the value is the end value.\\nBy using a data structure like map which implements a balanced binary search tree, we can easily find the correct position of new value and merge it with the existing intervals if necessary, which will help us to maintain the disjoint property of the intervals.\\n\\n# Approach\\nThe approach used in this implementation is to use a data structure, in this case a std::map, to store the disjoint intervals. Each interval is stored as a key-value pair in the map, where the key is the start value of the interval and the value is the end value.\\n\\nWhen a new value is added to the stream, the lower_bound() function is used to find the correct position of the new value in the map, and then the implementation checks if the new value can be added to an existing interval or if it needs to create a new one. It also checks if the new value can merge with the interval before or after it, and merges them if necessary.\\n\\nThe getIntervals() function iterates through the map and stores the intervals in a vector of vectors, which is returned.\\n\\nBy using the map\\'s properties of ordering and searching, the implementation can easily find the correct position of the new value in the stream and merge it with the existing intervals if necessary.\\n\\nThis approach is efficient in terms of space and time complexity because it allows for easy ordering and searching, as well as efficient insertion and deletion of intervals, which is important for maintaining the disjoint property of the intervals.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the addNum() function is **O(log n)** on average, where n is the number of disjoint intervals stored in the map. This is because the lower_bound() function used to find the position of the new value in the map has an average time complexity of O(log n) when used with a std::map. This is due to the fact that the map is implemented as a balanced binary search tree, and the time complexity of searching for an element in a balanced binary search tree is O(log n).\\nThe time complexity of the getIntervals() function is O(n) where n is the number of disjoint intervals stored in the map. This is because the function iterates through all the intervals in the map and stores them in a vector, the time complexity of iterating through the map is O(n) .\\n\\n- Space complexity:\\nThe space complexity of this implementation is **O(n)**, where n is the number of disjoint intervals stored in the map. Each interval is stored as a key-value pair in the map, and since the intervals do not overlap, the total number of intervals is equal to the total number of integers in the stream.\\n\\n# Code\\n```\\nclass SummaryRanges {\\npublic:\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int value) {\\n        auto it = _map.lower_bound(value);\\n        bool merged = false;\\n        if(it != _map.begin()) {\\n            auto prev = it;\\n            --prev;\\n            if(prev->second + 1 >= value) {\\n                merged = true;\\n                prev->second = max(prev->second, value);\\n            }\\n        }\\n\\n        if(it != _map.end()) {\\n            if(it->first - 1 <= value) {\\n                if(merged) {\\n                    auto prev = it;\\n                    --prev;\\n                    if(prev->second >= it->first - 1) {\\n                        prev->second = max(prev->second, it->second);\\n                        _map.erase(it);\\n                    }\\n                } else {\\n                    merged = true;\\n                    if(it->first != value) {\\n                        pair<int, int> p = *it;\\n                        p.first = min(p.first, value);\\n                        it = _map.insert(it, p);\\n                        ++it;\\n                        if(it != _map.end())\\n                            _map.erase(it);\\n                    }\\n                }\\n            }\\n        }\\n        if(!merged)\\n            _map.insert(it, {value, value});\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> intervals;\\n        for(auto const & p : _map)\\n            intervals.push_back({p.first, p.second});\\n        return intervals;\\n    }\\n\\n    map<int, int> _map;\\n};\\n```\\n\\n![2wlbi6.webp](https://assets.leetcode.com/users/images/78719639-3edb-4764-969b-205209d3dcd8_1674868807.9893684.webp)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass SummaryRanges {\\npublic:\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int value) {\\n        auto it = _map.lower_bound(value);\\n        bool merged = false;\\n        if(it != _map.begin()) {\\n            auto prev = it;\\n            --prev;\\n            if(prev->second + 1 >= value) {\\n                merged = true;\\n                prev->second = max(prev->second, value);\\n            }\\n        }\\n\\n        if(it != _map.end()) {\\n            if(it->first - 1 <= value) {\\n                if(merged) {\\n                    auto prev = it;\\n                    --prev;\\n                    if(prev->second >= it->first - 1) {\\n                        prev->second = max(prev->second, it->second);\\n                        _map.erase(it);\\n                    }\\n                } else {\\n                    merged = true;\\n                    if(it->first != value) {\\n                        pair<int, int> p = *it;\\n                        p.first = min(p.first, value);\\n                        it = _map.insert(it, p);\\n                        ++it;\\n                        if(it != _map.end())\\n                            _map.erase(it);\\n                    }\\n                }\\n            }\\n        }\\n        if(!merged)\\n            _map.insert(it, {value, value});\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> intervals;\\n        for(auto const & p : _map)\\n            intervals.push_back({p.first, p.second});\\n        return intervals;\\n    }\\n\\n    map<int, int> _map;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82553,
                "title": "java-solution-using-treemap-real-o-logn-per-adding",
                "content": "Use TreeMap to easily find the lower and higher keys, the key is the start of the interval. \\nMerge the lower and higher intervals when necessary. The time complexity for adding is O(logN) since lowerKey(), higherKey(), put() and remove() are all O(logN). It would be O(N) if you use an ArrayList and remove an interval from it. \\n\\n    public class SummaryRanges {\\n        TreeMap<Integer, Interval> tree;\\n    \\n        public SummaryRanges() {\\n            tree = new TreeMap<>();\\n        }\\n    \\n        public void addNum(int val) {\\n            if(tree.containsKey(val)) return;\\n            Integer l = tree.lowerKey(val);\\n            Integer h = tree.higherKey(val);\\n            if(l != null && h != null && tree.get(l).end + 1 == val && h == val + 1) {\\n                tree.get(l).end = tree.get(h).end;\\n                tree.remove(h);\\n            } else if(l != null && tree.get(l).end + 1 >= val) {\\n                tree.get(l).end = Math.max(tree.get(l).end, val);\\n            } else if(h != null && h == val + 1) {\\n                tree.put(val, new Interval(val, tree.get(h).end));\\n                tree.remove(h);\\n            } else {\\n                tree.put(val, new Interval(val, val));\\n            }\\n        }\\n    \\n        public List<Interval> getIntervals() {\\n            return new ArrayList<>(tree.values());\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Use TreeMap to easily find the lower and higher keys, the key is the start of the interval. \\nMerge the lower and higher intervals when necessary. The time complexity for adding is O(logN) since lowerKey(), higherKey(), put() and remove() are all O(logN). It would be O(N) if you use an ArrayList and remove an interval from it. \\n\\n    public class SummaryRanges {\\n        TreeMap<Integer, Interval> tree;\\n    \\n        public SummaryRanges() {\\n            tree = new TreeMap<>();\\n        }\\n    \\n        public void addNum(int val) {\\n            if(tree.containsKey(val)) return;\\n            Integer l = tree.lowerKey(val);\\n            Integer h = tree.higherKey(val);\\n            if(l != null && h != null && tree.get(l).end + 1 == val && h == val + 1) {\\n                tree.get(l).end = tree.get(h).end;\\n                tree.remove(h);\\n            } else if(l != null && tree.get(l).end + 1 >= val) {\\n                tree.get(l).end = Math.max(tree.get(l).end, val);\\n            } else if(h != null && h == val + 1) {\\n                tree.put(val, new Interval(val, tree.get(h).end));\\n                tree.remove(h);\\n            } else {\\n                tree.put(val, new Interval(val, val));\\n            }\\n        }\\n    \\n        public List<Interval> getIntervals() {\\n            return new ArrayList<>(tree.values());\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3107293,
                "title": "day-28-ordered-set-easiest-beginner-friendly-sol",
                "content": "# Intuition of this Problem:\\n**Lets understand disjoint set with example:**\\nIf we have given input array : [1, 2, 3, 5, 7, 9, 10, 11]\\nAt 4,6,8 we have disjoint so 5,7 keep in two different array\\nthen output 2d array will be: [[1,3], [5,5], [7,7], [9,11]]\\n\\nIf we have given input array : [1, 2, 3, 5, 6, 7, 9, 10, 11]\\nthen output 2d array will be: [[1,3], [5,7], [9,11]]\\n\\nThe intuition behind this problem is to maintain a set of non-negative integers as a stream of input and to summarize them as a list of disjoint intervals. The intervals are determined by finding contiguous groups of integers in the stream. The set data structure is used to maintain the integers in sorted order, which makes it easy to find contiguous groups of integers.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Initialize an empty set nums to store the integers in the data stream.\\n2. In the addNum() function, insert the given value into the set nums.\\n3. In the getIntervals() function, initialize a vector of vectors called intervals to store the disjoint intervals.\\n4. Initialize variables start and end to the first element in the set nums.\\n5. Iterate through the set nums starting from the second element. For each element, check if its value minus the current value of end is 1.\\nIf it is, update the value of end to the current element\\'s value.If not, push the current interval [start, end] into the intervals vector and update start and end to the current element\\'s value.\\n1. After the loop, push the last interval [start, end] into the intervals vector and return the intervals vector.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass SummaryRanges {\\npublic:\\n    set<int> nums;\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int value) {\\n        nums.insert(value);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> intervals;\\n        int start = *nums.begin();\\n        int end = *nums.begin();\\n        for (auto it = ++nums.begin(); it != nums.end(); it++) {\\n            int val = *it;\\n            if (val - end == 1) {\\n                end = val;\\n            } else {\\n                intervals.push_back({start, end});\\n                start = end = val;\\n            }\\n        }\\n        intervals.push_back({start, end});\\n        return intervals;\\n        \\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```\\n```C++ []\\nclass SummaryRanges {\\npublic:\\n    set<int> nums;\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int value) {\\n        nums.insert(value);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> intervals;\\n        int start = -1;\\n        int end = -1;\\n        for (auto num : nums) {\\n            if(end < 0)\\n                start = end = num;\\n            else if (num - end == 1) {\\n                end = num;\\n            } else {\\n                intervals.push_back({start, end});\\n                start = end = num;\\n            }\\n        }\\n        intervals.push_back({start, end});\\n        return intervals;\\n        \\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```\\n```Java []\\nclass SummaryRanges {\\n    TreeSet<Integer> nums;\\n    SummaryRanges() {\\n        nums = new TreeSet<>();\\n    }\\n    \\n    void addNum(int value) {\\n        nums.add(value);\\n    }\\n    \\n    int[][] getIntervals() {\\n        int[][] intervals;\\n        int start = nums.first();\\n        int end = nums.first();\\n        int i = 0;\\n        for (Integer val : nums.tailSet(nums.first()+1)) {\\n            if (val - end == 1) {\\n                end = val;\\n            } else {\\n                intervals[i][0] = start;\\n                intervals[i][1] = end;\\n                i++;\\n                start = end = val;\\n            }\\n        }\\n        intervals[i][0] = start;\\n        intervals[i][1] = end;\\n        return intervals;\\n    }\\n}\\n\\n```\\n```Python []\\nclass SummaryRanges:\\n    def __init__(self):\\n        self.nums = set()\\n        \\n    def addNum(self, value: int) -> None:\\n        self.nums.add(value)\\n        \\n    def getIntervals(self) -> List[List[int]]:\\n        intervals = []\\n        start = None\\n        end = None\\n        for val in self.nums:\\n            if start is None:\\n                start = val\\n                end = val\\n            elif val - end == 1:\\n                end = val\\n            else:\\n                intervals.append([start, end])\\n                start = end = val\\n        if start is not None:\\n            intervals.append([start, end])\\n        return intervals\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **The time complexity of the addNum() function is O(log(n)) due to the use of the set data structure, where n is the number of elements in the set. The time complexity of the getIntervals() function is O(n) where n is the number of elements in the set. This is because we are iterating through all the elements in the set once.**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **The space complexity is O(n) where n is the number of elements in the set. This is because we are using a set data structure to store all the elements in the stream**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Ordered Set"
                ],
                "code": "```C++ []\\nclass SummaryRanges {\\npublic:\\n    set<int> nums;\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int value) {\\n        nums.insert(value);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> intervals;\\n        int start = *nums.begin();\\n        int end = *nums.begin();\\n        for (auto it = ++nums.begin(); it != nums.end(); it++) {\\n            int val = *it;\\n            if (val - end == 1) {\\n                end = val;\\n            } else {\\n                intervals.push_back({start, end});\\n                start = end = val;\\n            }\\n        }\\n        intervals.push_back({start, end});\\n        return intervals;\\n        \\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```\n```C++ []\\nclass SummaryRanges {\\npublic:\\n    set<int> nums;\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int value) {\\n        nums.insert(value);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> intervals;\\n        int start = -1;\\n        int end = -1;\\n        for (auto num : nums) {\\n            if(end < 0)\\n                start = end = num;\\n            else if (num - end == 1) {\\n                end = num;\\n            } else {\\n                intervals.push_back({start, end});\\n                start = end = num;\\n            }\\n        }\\n        intervals.push_back({start, end});\\n        return intervals;\\n        \\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```\n```Java []\\nclass SummaryRanges {\\n    TreeSet<Integer> nums;\\n    SummaryRanges() {\\n        nums = new TreeSet<>();\\n    }\\n    \\n    void addNum(int value) {\\n        nums.add(value);\\n    }\\n    \\n    int[][] getIntervals() {\\n        int[][] intervals;\\n        int start = nums.first();\\n        int end = nums.first();\\n        int i = 0;\\n        for (Integer val : nums.tailSet(nums.first()+1)) {\\n            if (val - end == 1) {\\n                end = val;\\n            } else {\\n                intervals[i][0] = start;\\n                intervals[i][1] = end;\\n                i++;\\n                start = end = val;\\n            }\\n        }\\n        intervals[i][0] = start;\\n        intervals[i][1] = end;\\n        return intervals;\\n    }\\n}\\n\\n```\n```Python []\\nclass SummaryRanges:\\n    def __init__(self):\\n        self.nums = set()\\n        \\n    def addNum(self, value: int) -> None:\\n        self.nums.add(value)\\n        \\n    def getIntervals(self) -> List[List[int]]:\\n        intervals = []\\n        start = None\\n        end = None\\n        for val in self.nums:\\n            if start is None:\\n                start = val\\n                end = val\\n            elif val - end == 1:\\n                end = val\\n            else:\\n                intervals.append([start, end])\\n                start = end = val\\n        if start is not None:\\n            intervals.append([start, end])\\n        return intervals\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82557,
                "title": "very-concise-c-solution",
                "content": "In general case, vector is OK, it will take O(n) time in each add, and O(1) in get result. But if there are lots of merges and the number of disjoint intervals are small compared to the data stream's size, we'd better use another data structure \"set\", because the insert operation in vector will cost O(n) time, but it only cost O(log n) in binary search tree, but it will cost O(n) time in getInterval. So use which data structure will depends. \\n\\nfirst one is the solution use vector\\n\\n    class SummaryRanges {\\n    public:\\n        void addNum(int val) {\\n            auto Cmp = [](Interval a, Interval b) { return a.start < b.start; };\\n            auto it = lower_bound(vec.begin(), vec.end(), Interval(val, val), Cmp);\\n            int start = val, end = val;\\n            if(it != vec.begin() && (it-1)->end+1 >= val) it--;\\n            while(it != vec.end() && val+1 >= it->start && val-1 <= it->end)\\n            {\\n                start = min(start, it->start);\\n                end = max(end, it->end);\\n                it = vec.erase(it);\\n            }\\n            vec.insert(it,Interval(start, end));\\n        }\\n        \\n        vector<Interval> getIntervals() {\\n            return vec;\\n        }\\n    private:\\n        vector<Interval> vec;\\n    };\\n\\nand below is another solution use binary search tree.\\n\\n    class SummaryRanges {\\n    public:\\n        /** Initialize your data structure here. */\\n        void addNum(int val) {\\n            auto it = st.lower_bound(Interval(val, val));\\n            int start = val, end = val;\\n            if(it != st.begin() && (--it)->end+1 < val) it++;\\n            while(it != st.end() && val+1 >= it->start && val-1 <= it->end)\\n            {\\n                start = min(start, it->start);\\n                end = max(end, it->end);\\n                it = st.erase(it);\\n            }\\n            st.insert(it,Interval(start, end));\\n        }\\n        \\n        vector<Interval> getIntervals() {\\n            vector<Interval> result;\\n            for(auto val: st) result.push_back(val);\\n            return result;\\n        }\\n    private:\\n        struct Cmp{\\n            bool operator()(Interval a, Interval b){ return a.start < b.start; }\\n        };\\n        set<Interval, Cmp> st;\\n    };",
                "solutionTags": [],
                "code": "In general case, vector is OK, it will take O(n) time in each add, and O(1) in get result. But if there are lots of merges and the number of disjoint intervals are small compared to the data stream's size, we'd better use another data structure \"set\", because the insert operation in vector will cost O(n) time, but it only cost O(log n) in binary search tree, but it will cost O(n) time in getInterval. So use which data structure will depends. \\n\\nfirst one is the solution use vector\\n\\n    class SummaryRanges {\\n    public:\\n        void addNum(int val) {\\n            auto Cmp = [](Interval a, Interval b) { return a.start < b.start; };\\n            auto it = lower_bound(vec.begin(), vec.end(), Interval(val, val), Cmp);\\n            int start = val, end = val;\\n            if(it != vec.begin() && (it-1)->end+1 >= val) it--;\\n            while(it != vec.end() && val+1 >= it->start && val-1 <= it->end)\\n            {\\n                start = min(start, it->start);\\n                end = max(end, it->end);\\n                it = vec.erase(it);\\n            }\\n            vec.insert(it,Interval(start, end));\\n        }\\n        \\n        vector<Interval> getIntervals() {\\n            return vec;\\n        }\\n    private:\\n        vector<Interval> vec;\\n    };\\n\\nand below is another solution use binary search tree.\\n\\n    class SummaryRanges {\\n    public:\\n        /** Initialize your data structure here. */\\n        void addNum(int val) {\\n            auto it = st.lower_bound(Interval(val, val));\\n            int start = val, end = val;\\n            if(it != st.begin() && (--it)->end+1 < val) it++;\\n            while(it != st.end() && val+1 >= it->start && val-1 <= it->end)\\n            {\\n                start = min(start, it->start);\\n                end = max(end, it->end);\\n                it = st.erase(it);\\n            }\\n            st.insert(it,Interval(start, end));\\n        }\\n        \\n        vector<Interval> getIntervals() {\\n            vector<Interval> result;\\n            for(auto val: st) result.push_back(val);\\n            return result;\\n        }\\n    private:\\n        struct Cmp{\\n            bool operator()(Interval a, Interval b){ return a.start < b.start; }\\n        };\\n        set<Interval, Cmp> st;\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 297728,
                "title": "short-python-union-find-solution",
                "content": "Idea:\\n* on every new element (if doesn\\'t exist in union find)\\n\\t* perform union with val-1, val+1\\n\\t* on union perform interval adjustment\\n* together with union-find forest maintain intervals for the roots of the trees\\n\\nmake_set:\\n* on make set create a new interval with [x,x]\\n\\nunion:\\n* on union we need to remove one interval (the one which is not root anymore)\\n* merge the union by taking the min of the start and max of the end\\n\\ngetIntervals:\\n* return all intervals in the sorted order\\n\\nComplexity:\\n* O(1) for addNum\\n* O(nlogn) for getIntevals where n is number of unique intervals\\n\\n```\\nclass DSU:\\n    def __init__(self):\\n        self.p = {}\\n        self.intervals = {}\\n\\n    def exists(self, x): return x in self.p\\n\\n    def make_set(self, x):\\n        self.p[x] = x\\n        self.intervals[x] = [x,x]\\n        \\n    def find(self, x):\\n        if not self.exists(x): return None\\n        \\n        if self.p[x] != x:\\n            self.p[x] = self.find(self.p[x])\\n\\n        return self.p[x]\\n\\n    def union(self, x, y):\\n        xr = self.find(x)\\n        yr = self.find(y)\\n        \\n        if xr is None or yr is None: return\\n        \\n        self.p[xr] = yr\\n        \\n        ## interval adjusting logic\\n        x_interval = self.intervals[xr]\\n        del self.intervals[xr]\\n        \\n        self.intervals[yr] = [min(self.intervals[yr][0], x_interval[0]), max(self.intervals[yr][1], x_interval[1])]\\n        \\nclass SummaryRanges:    \\n    def __init__(self):\\n        self.dsu = DSU()\\n\\n    def addNum(self, val: int) -> None:\\n        if self.dsu.exists(val): return\\n            \\n        self.dsu.make_set(val)\\n        \\n        self.dsu.union(val, val-1)\\n        self.dsu.union(val, val+1)\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        return sorted(self.dsu.intervals.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass DSU:\\n    def __init__(self):\\n        self.p = {}\\n        self.intervals = {}\\n\\n    def exists(self, x): return x in self.p\\n\\n    def make_set(self, x):\\n        self.p[x] = x\\n        self.intervals[x] = [x,x]\\n        \\n    def find(self, x):\\n        if not self.exists(x): return None\\n        \\n        if self.p[x] != x:\\n            self.p[x] = self.find(self.p[x])\\n\\n        return self.p[x]\\n\\n    def union(self, x, y):\\n        xr = self.find(x)\\n        yr = self.find(y)\\n        \\n        if xr is None or yr is None: return\\n        \\n        self.p[xr] = yr\\n        \\n        ## interval adjusting logic\\n        x_interval = self.intervals[xr]\\n        del self.intervals[xr]\\n        \\n        self.intervals[yr] = [min(self.intervals[yr][0], x_interval[0]), max(self.intervals[yr][1], x_interval[1])]\\n        \\nclass SummaryRanges:    \\n    def __init__(self):\\n        self.dsu = DSU()\\n\\n    def addNum(self, val: int) -> None:\\n        if self.dsu.exists(val): return\\n            \\n        self.dsu.make_set(val)\\n        \\n        self.dsu.union(val, val-1)\\n        self.dsu.union(val, val+1)\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        return sorted(self.dsu.intervals.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82548,
                "title": "share-my-python-solution-using-heap",
                "content": "Since there is no standard TreeMap library for python, I am implementing this structure with a min heap.\\nThe idea is straight froward: \\nAppend interval to heap when addNum called\\nMerge intervals when getIntervals called\\n\\n  \\n    class SummaryRanges(object):\\n\\n      def __init__(self):\\n        self.intervals = []\\n        \\n      def addNum(self, val):\\n        heapq.heappush(self.intervals, (val, Interval(val, val)))\\n        \\n      def getIntervals(self):\\n        stack = []\\n        while self.intervals:\\n            idx, cur = heapq.heappop(self.intervals)\\n            if not stack:\\n                stack.append((idx, cur))\\n            else:\\n                _, prev = stack[-1]\\n                if prev.end + 1 >= cur.start:\\n                    prev.end = max(prev.end, cur.end)\\n                else:\\n                    stack.append((idx, cur))\\n        self.intervals = stack\\n        return list(map(lambda x: x[1], stack))",
                "solutionTags": [],
                "code": "Since there is no standard TreeMap library for python, I am implementing this structure with a min heap.\\nThe idea is straight froward: \\nAppend interval to heap when addNum called\\nMerge intervals when getIntervals called\\n\\n  \\n    class SummaryRanges(object):\\n\\n      def __init__(self):\\n        self.intervals = []\\n        \\n      def addNum(self, val):\\n        heapq.heappush(self.intervals, (val, Interval(val, val)))\\n        \\n      def getIntervals(self):\\n        stack = []\\n        while self.intervals:\\n            idx, cur = heapq.heappop(self.intervals)\\n            if not stack:\\n                stack.append((idx, cur))\\n            else:\\n                _, prev = stack[-1]\\n                if prev.end + 1 >= cur.start:\\n                    prev.end = max(prev.end, cur.end)\\n                else:\\n                    stack.append((idx, cur))\\n        self.intervals = stack\\n        return list(map(lambda x: x[1], stack))",
                "codeTag": "Java"
            },
            {
                "id": 3107565,
                "title": "c-easy-to-understand-explanation",
                "content": "For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, \\u2026, then the summary will be:\\n\\n[1, 1]\\n[1, 1], [3, 3]\\n[1, 1], [3, 3], [7, 7]\\n[1, 3], [7, 7]\\n[1, 3], [6, 7]\\n\\nA simple method is put integers to a set, then iterate data in set to construct the interval list.\\n# time complexity :-addNum is O(lgn), getIntervals is O(n).\\n# space complexity :-o(n) \\n                       ``` please upvote my solution ```\\nLets Connect On Linkedin https://www.linkedin.com/in/sonal-prasad-sahu-78973a229/\\n\\n![begging.jpg](https://assets.leetcode.com/users/images/015bcc2a-a0bd-4b75-8039-42de8f93e2f0_1674879028.7512639.jpeg)\\n\\n# Code\\n```\\nclass SummaryRanges {\\npublic:\\n \\n  SummaryRanges() {\\n        \\n  }\\n    \\n  void addNum(int val) {\\n    data_given.insert(val);\\n  }\\n    \\n  vector<vector<int>> getIntervals() {\\n      vector<vector<int>> res;\\n      int start = -1;\\n      int end = -1;\\n      for ( auto  &item: data_given) {\\n          if (start == -1) {\\n              start = item;\\n              end = item;\\n          } else if (item == end + 1) {\\n              end = item;\\n          } else {\\n              res.push_back({start, end});\\n              start = end = item;\\n          }\\n      }\\n      \\n      if (start != -1) res.push_back({start, end});\\n      \\n      return res;\\n  }\\nprivate:\\n  set<int> data_given;\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` please upvote my solution ```\n```\\nclass SummaryRanges {\\npublic:\\n \\n  SummaryRanges() {\\n        \\n  }\\n    \\n  void addNum(int val) {\\n    data_given.insert(val);\\n  }\\n    \\n  vector<vector<int>> getIntervals() {\\n      vector<vector<int>> res;\\n      int start = -1;\\n      int end = -1;\\n      for ( auto  &item: data_given) {\\n          if (start == -1) {\\n              start = item;\\n              end = item;\\n          } else if (item == end + 1) {\\n              end = item;\\n          } else {\\n              res.push_back({start, end});\\n              start = end = item;\\n          }\\n      }\\n      \\n      if (start != -1) res.push_back({start, end});\\n      \\n      return res;\\n  }\\nprivate:\\n  set<int> data_given;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107556,
                "title": "fast-java-solution",
                "content": "# Code\\n``` JAVA []\\nclass SummaryRanges {\\n  public void addNum(int val) {\\n    if (map.containsKey(val))\\n      return;\\n\\n    final Integer lo = map.lowerKey(val);  // Maximum in map < key\\n    final Integer hi = map.higherKey(val); // Minimum in map > key\\n\\n    // {lo, map.get(lo)[1]} + val + {hi, map.get(hi)[1]} = {lo, map.get(hi)[1]}\\n    if (lo != null && hi != null && map.get(lo)[1] + 1 == val && val + 1 == hi) {\\n      map.get(lo)[1] = map.get(hi)[1];\\n      map.remove(hi);\\n      // {lo, map.get(lo)[1]} + val = {lo, val}\\n      // (prevent adding duplicate entry by using \\'>=\\' instead of \\'==\\')\\n    } else if (lo != null && map.get(lo)[1] + 1 >= val) {\\n      map.get(lo)[1] = Math.max(map.get(lo)[1], val);\\n      // Val + {hi, map.get(hi)[1]} = {val, map.get(hi)[1]}\\n    } else if (hi != null && val + 1 == hi) {\\n      map.put(val, new int[] {val, map.get(hi)[1]});\\n      map.remove(hi);\\n    } else {\\n      map.put(val, new int[] {val, val});\\n    }\\n  }\\n\\n  public int[][] getIntervals() {\\n    List<int[]> intervals = new ArrayList<>(map.values());\\n    return intervals.toArray(new int[intervals.size()][]);\\n  }\\n\\n  // {start: {start, end}}\\n  private TreeMap<Integer, int[]> map = new TreeMap<>();\\n}\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/a368e607-130a-49ea-a1b8-58402aeb1cbf_1674878823.1172526.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` JAVA []\\nclass SummaryRanges {\\n  public void addNum(int val) {\\n    if (map.containsKey(val))\\n      return;\\n\\n    final Integer lo = map.lowerKey(val);  // Maximum in map < key\\n    final Integer hi = map.higherKey(val); // Minimum in map > key\\n\\n    // {lo, map.get(lo)[1]} + val + {hi, map.get(hi)[1]} = {lo, map.get(hi)[1]}\\n    if (lo != null && hi != null && map.get(lo)[1] + 1 == val && val + 1 == hi) {\\n      map.get(lo)[1] = map.get(hi)[1];\\n      map.remove(hi);\\n      // {lo, map.get(lo)[1]} + val = {lo, val}\\n      // (prevent adding duplicate entry by using \\'>=\\' instead of \\'==\\')\\n    } else if (lo != null && map.get(lo)[1] + 1 >= val) {\\n      map.get(lo)[1] = Math.max(map.get(lo)[1], val);\\n      // Val + {hi, map.get(hi)[1]} = {val, map.get(hi)[1]}\\n    } else if (hi != null && val + 1 == hi) {\\n      map.put(val, new int[] {val, map.get(hi)[1]});\\n      map.remove(hi);\\n    } else {\\n      map.put(val, new int[] {val, val});\\n    }\\n  }\\n\\n  public int[][] getIntervals() {\\n    List<int[]> intervals = new ArrayList<>(map.values());\\n    return intervals.toArray(new int[intervals.size()][]);\\n  }\\n\\n  // {start: {start, end}}\\n  private TreeMap<Integer, int[]> map = new TreeMap<>();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347973,
                "title": "concise-python-o-1-add-o-nlgn-get-no-union-find-no-heap",
                "content": "Python doesn\\'t have TreeMap. Without treemap, seems that the best we can have is O(1) add and O(nlgn) getting all intervals. There are posts using union find and heap. But all of them has O(nlgn) complexity. If O(nlgn) is acceptable, then why not simply hashing all numbers we\\'ve seen, and sort them in the \"get\" operation?\\n\\nThis method doesn\\'t run very fast, but in theory has the same time complexity as Union find way and the heapq way. And it is memory efficient.\\n\\n860ms defeats 6.5%\\n```\\nclass SummaryRanges:\\n    def __init__(self):\\n        self.seen=set()\\n\\n    def addNum(self, val: int) -> None:\\n        self.seen.add(val)\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        res=[]\\n        for v in sorted(self.seen):\\n            if not res or v>res[-1][1]+1:\\n                res.append([v,v])\\n            elif res and v==res[-1][1]+1:\\n                res[-1][1]=v\\n        return res\\n```\\n\\nTo make things faster, you can also keep two dictionaries:\\n1. start value : [start, end]\\n2. end value : [start, end]\\nFor each newly added value, look for value+1 in start dict, look for value-1 in end dictionary, when find one, update the dictionary.\\n\\nIn the \"get\" operation, you sort the dictionary to get output intervals. But beause the dictionary size is much smaller than total number of values, it is much faster sorting.\\n\\n180ms defeats 97%\\n```\\nclass SummaryRanges:\\n    def __init__(self):\\n        self.start={}\\n        self.end={}\\n        self.visited=set()\\n\\n    def addNum(self, val: int) -> None:\\n        if val in self.visited:\\n            return\\n        self.visited.add(val)\\n        start,end=val,val\\n        if val+1 in self.start:\\n            end=self.start[val+1][1]\\n            self.start.pop(val+1)\\n        if val-1 in self.end:\\n            start=self.end[val-1][0]\\n            self.end.pop(val-1)\\n        interval=[start,end]\\n        self.start[start]=interval\\n        self.end[end]=interval\\n        \\n    def getIntervals(self) -> List[List[int]]:\\n        return sorted(self.start.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass SummaryRanges:\\n    def __init__(self):\\n        self.seen=set()\\n\\n    def addNum(self, val: int) -> None:\\n        self.seen.add(val)\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        res=[]\\n        for v in sorted(self.seen):\\n            if not res or v>res[-1][1]+1:\\n                res.append([v,v])\\n            elif res and v==res[-1][1]+1:\\n                res[-1][1]=v\\n        return res\\n```\n```\\nclass SummaryRanges:\\n    def __init__(self):\\n        self.start={}\\n        self.end={}\\n        self.visited=set()\\n\\n    def addNum(self, val: int) -> None:\\n        if val in self.visited:\\n            return\\n        self.visited.add(val)\\n        start,end=val,val\\n        if val+1 in self.start:\\n            end=self.start[val+1][1]\\n            self.start.pop(val+1)\\n        if val-1 in self.end:\\n            start=self.end[val-1][0]\\n            self.end.pop(val-1)\\n        interval=[start,end]\\n        self.start[start]=interval\\n        self.end[end]=interval\\n        \\n    def getIntervals(self) -> List[List[int]]:\\n        return sorted(self.start.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82610,
                "title": "java-fast-log-n-solution-186ms-without-using-the-treemap-but-a-customized-bst",
                "content": "    public class SummaryRanges {\\n        class BSTNode {\\n            Interval interval;\\n            BSTNode left;\\n            BSTNode right;\\n            BSTNode(Interval in){\\n                interval = in;\\n            }\\n        }\\n        \\n        BSTNode findMin(BSTNode root) {\\n            if (root == null) return null;\\n            if (root.left == null ) return root;\\n            else return findMin(root.left);\\n        }\\n        \\n        BSTNode remove(Interval x, BSTNode root) {\\n            if (root == null) return null;\\n            else if ( x == null ) return root;\\n            else if (x.start > root.interval.end ) {\\n                root.right = remove(x, root.right);\\n            } else if (x.end < root.interval.start ) {\\n                root.left = remove(x, root.left);\\n            } else if ( root.left != null && root.right != null) {\\n                root.interval = findMin(root.right).interval;\\n                root.right = remove( root.interval, root.right);\\n            } else {\\n                root = ( root.left != null ) ? root.left : root.right;\\n            }\\n            return root;\\n        }\\n        \\n        BSTNode findKey(int val, BSTNode root) {\\n            if (root == null) return null;\\n            if (root.interval.start > val) {\\n                return findKey(val, root.left);\\n            } else if (root.interval.end < val) {\\n                return findKey(val, root.right);\\n            } else return root;\\n        }\\n        \\n        BSTNode addKey(int val, BSTNode root) {\\n            if (root == null) {\\n                root = new BSTNode( new Interval(val, val) ); \\n            } else if (root.interval.start > val) {\\n                root.left = addKey(val, root.left);\\n            } else if (root.interval.end < val) {\\n                root.right = addKey(val, root.right);\\n            }  \\n            return root;\\n        }\\n        void inOrder(BSTNode root) {\\n            if (root != null) {\\n                inOrder(root.left);\\n                list.add(root.interval);\\n                inOrder(root.right);\\n            }\\n        }\\n        \\n        /** Initialize your data structure here. */\\n        BSTNode root;\\n        List<Interval> list = new ArrayList();\\n        public SummaryRanges() {\\n            root = null;\\n        }\\n        \\n        public void addNum(int val) {\\n            if (root == null) {\\n                root = addKey(val, root);\\n            } else {\\n                if ( findKey(val, root) != null) return;\\n                BSTNode left = findKey(val-1, root);\\n                BSTNode right = findKey(val+1, root);\\n                if (left == null && right == null) {\\n                    root = addKey(val, root);\\n                } else if (left != null && right == null) {\\n                    left.interval.end++;\\n                } else if (left == null && right != null) {\\n                    right.interval.start--;\\n                } else {\\n                    Interval l = left.interval;\\n                    int e = right.interval.end;\\n                    root = remove(right.interval, root);\\n                    l.end = e;\\n                }\\n            }\\n        }\\n        \\n        public List<Interval> getIntervals() {\\n            list.clear();\\n            inOrder(root);\\n            return list;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "    public class SummaryRanges {\\n        class BSTNode {\\n            Interval interval;\\n            BSTNode left;\\n            BSTNode right;\\n            BSTNode(Interval in){\\n                interval = in;\\n            }\\n        }\\n        \\n        BSTNode findMin(BSTNode root) {\\n            if (root == null) return null;\\n            if (root.left == null ) return root;\\n            else return findMin(root.left);\\n        }\\n        \\n        BSTNode remove(Interval x, BSTNode root) {\\n            if (root == null) return null;\\n            else if ( x == null ) return root;\\n            else if (x.start > root.interval.end ) {\\n                root.right = remove(x, root.right);\\n            } else if (x.end < root.interval.start ) {\\n                root.left = remove(x, root.left);\\n            } else if ( root.left != null && root.right != null) {\\n                root.interval = findMin(root.right).interval;\\n                root.right = remove( root.interval, root.right);\\n            } else {\\n                root = ( root.left != null ) ? root.left : root.right;\\n            }\\n            return root;\\n        }\\n        \\n        BSTNode findKey(int val, BSTNode root) {\\n            if (root == null) return null;\\n            if (root.interval.start > val) {\\n                return findKey(val, root.left);\\n            } else if (root.interval.end < val) {\\n                return findKey(val, root.right);\\n            } else return root;\\n        }\\n        \\n        BSTNode addKey(int val, BSTNode root) {\\n            if (root == null) {\\n                root = new BSTNode( new Interval(val, val) ); \\n            } else if (root.interval.start > val) {\\n                root.left = addKey(val, root.left);\\n            } else if (root.interval.end < val) {\\n                root.right = addKey(val, root.right);\\n            }  \\n            return root;\\n        }\\n        void inOrder(BSTNode root) {\\n            if (root != null) {\\n                inOrder(root.left);\\n                list.add(root.interval);\\n                inOrder(root.right);\\n            }\\n        }\\n        \\n        /** Initialize your data structure here. */\\n        BSTNode root;\\n        List<Interval> list = new ArrayList();\\n        public SummaryRanges() {\\n            root = null;\\n        }\\n        \\n        public void addNum(int val) {\\n            if (root == null) {\\n                root = addKey(val, root);\\n            } else {\\n                if ( findKey(val, root) != null) return;\\n                BSTNode left = findKey(val-1, root);\\n                BSTNode right = findKey(val+1, root);\\n                if (left == null && right == null) {\\n                    root = addKey(val, root);\\n                } else if (left != null && right == null) {\\n                    left.interval.end++;\\n                } else if (left == null && right != null) {\\n                    right.interval.start--;\\n                } else {\\n                    Interval l = left.interval;\\n                    int e = right.interval.end;\\n                    root = remove(right.interval, root);\\n                    l.end = e;\\n                }\\n            }\\n        }\\n        \\n        public List<Interval> getIntervals() {\\n            list.clear();\\n            inOrder(root);\\n            return list;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 82546,
                "title": "simple-python-solution-with-binary-search",
                "content": "```\\nclass SummaryRanges(object):\\n    def __init__(self):\\n        self.intervals = []\\n\\n    def addNum(self, val):\\n        # find location\\n        low, high = 0, len(self.intervals) - 1\\n        while low <= high:\\n            mid = (low + high) // 2\\n            elem = self.intervals[mid]\\n            if elem.start <= val <= elem.end:\\n                return\\n            elif elem.start > val:\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n\\n        # insert the interval\\n        pos = min(low, high) + 1\\n        self.intervals[pos:pos] = [Interval(val, val)]\\n\\n        # merge with next interval\\n        if pos + 1 < len(self.intervals) and val == self.intervals[pos + 1].start - 1:\\n            self.intervals[pos].end = self.intervals[pos + 1].end\\n            self.intervals[pos + 1:pos + 2] = []\\n\\n        # merge with prev interval\\n        if pos - 1 >= 0 and val == self.intervals[pos - 1].end + 1:\\n            self.intervals[pos - 1].end = self.intervals[pos].end\\n            self.intervals[pos:pos + 1] = []\\n\\n    def getIntervals(self):\\n        return self.intervals\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass SummaryRanges(object):\\n    def __init__(self):\\n        self.intervals = []\\n\\n    def addNum(self, val):\\n        # find location\\n        low, high = 0, len(self.intervals) - 1\\n        while low <= high:\\n            mid = (low + high) // 2\\n            elem = self.intervals[mid]\\n            if elem.start <= val <= elem.end:\\n                return\\n            elif elem.start > val:\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n\\n        # insert the interval\\n        pos = min(low, high) + 1\\n        self.intervals[pos:pos] = [Interval(val, val)]\\n\\n        # merge with next interval\\n        if pos + 1 < len(self.intervals) and val == self.intervals[pos + 1].start - 1:\\n            self.intervals[pos].end = self.intervals[pos + 1].end\\n            self.intervals[pos + 1:pos + 2] = []\\n\\n        # merge with prev interval\\n        if pos - 1 >= 0 and val == self.intervals[pos - 1].end + 1:\\n            self.intervals[pos - 1].end = self.intervals[pos].end\\n            self.intervals[pos:pos + 1] = []\\n\\n    def getIntervals(self):\\n        return self.intervals\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107289,
                "title": "python-short-o-nlogn-solution-using-sortedlist-binary-search-tree",
                "content": "Keep a sorted list of ranges, for each add operations, binary search the insert position, compare val with the previous and next ranges. \\n\\nThis can be implemented with a `list of ranges` but the complexity\\'s gonna be `O(n)` for each addNum() since inserting into a list takes O(n) time. Instead, using a `SortedList of ranges` makes each addNum() `O(logn)` since SortedList is implemented with BST and BST insertion is O(logn).\\n\\n```\\nfrom sortedcontainers import SortedList\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.sl = SortedList()\\n\\n    def addNum(self, val: int) -> None:\\n        n = len(self.sl)\\n        i = self.sl.bisect_left([val, val])\\n        # val already added\\n        if i > 0 and self.sl[i-1][0] <= val <= self.sl[i-1][1] or i < n and self.sl[i][0] <= val <= self.sl[i][1]:\\n            pass\\n        # merge left & right\\n        elif 0 < i < n and self.sl[i-1][1] == val-1 and self.sl[i][0] == val+1:\\n            new = [self.sl[i-1][0], self.sl[i][1]]\\n            del self.sl[i]\\n            del self.sl[i-1]\\n            self.sl.add(new)\\n        # merge left only\\n        elif 0 < i and self.sl[i-1][1] == val-1:\\n            new = [self.sl[i-1][0], val]\\n            del self.sl[i-1]\\n            self.sl.add(new)\\n        # merge right only\\n        elif i < n and self.sl[i][0] == val+1:\\n            new = [val, self.sl[i][1]]\\n            del self.sl[i]\\n            self.sl.add(new)\\n        else:\\n            self.sl.add([val, val])\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        return self.sl\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.sl = SortedList()\\n\\n    def addNum(self, val: int) -> None:\\n        n = len(self.sl)\\n        i = self.sl.bisect_left([val, val])\\n        # val already added\\n        if i > 0 and self.sl[i-1][0] <= val <= self.sl[i-1][1] or i < n and self.sl[i][0] <= val <= self.sl[i][1]:\\n            pass\\n        # merge left & right\\n        elif 0 < i < n and self.sl[i-1][1] == val-1 and self.sl[i][0] == val+1:\\n            new = [self.sl[i-1][0], self.sl[i][1]]\\n            del self.sl[i]\\n            del self.sl[i-1]\\n            self.sl.add(new)\\n        # merge left only\\n        elif 0 < i and self.sl[i-1][1] == val-1:\\n            new = [self.sl[i-1][0], val]\\n            del self.sl[i-1]\\n            self.sl.add(new)\\n        # merge right only\\n        elif i < n and self.sl[i][0] == val+1:\\n            new = [val, self.sl[i][1]]\\n            del self.sl[i]\\n            self.sl.add(new)\\n        else:\\n            self.sl.add([val, val])\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        return self.sl\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107304,
                "title": "python-simple-approach-expand-around-each-number-to-find-the-interval",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConstruct the interval by expanding around each of the added numbers. \\n\\n# Complexity\\n- Time complexity: __O(N)__ for getIntervals, __O(1)__ for addNum\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: __O(N)__ for getIntervals, __O(1)__ for addNum\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.nums = set()\\n\\n    def addNum(self, value: int) -> None:\\n        self.nums.add(value)\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        intervals = []\\n        seen = set()\\n        for num in self.nums:\\n            if num in seen: \\n                continue\\n\\n            left = num\\n            while left - 1 in self.nums:\\n                left -= 1\\n                seen.add(left)\\n\\n            right = num\\n            while right + 1 in self.nums:\\n                right += 1\\n                seen.add(right)\\n            \\n            intervals.append([left, right])\\n        return sorted(intervals)\\n\\n# Your SummaryRanges object will be instantiated and called as such:\\n# obj = SummaryRanges()\\n# obj.addNum(value)\\n# param_2 = obj.getIntervals()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.nums = set()\\n\\n    def addNum(self, value: int) -> None:\\n        self.nums.add(value)\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        intervals = []\\n        seen = set()\\n        for num in self.nums:\\n            if num in seen: \\n                continue\\n\\n            left = num\\n            while left - 1 in self.nums:\\n                left -= 1\\n                seen.add(left)\\n\\n            right = num\\n            while right + 1 in self.nums:\\n                right += 1\\n                seen.add(right)\\n            \\n            intervals.append([left, right])\\n        return sorted(intervals)\\n\\n# Your SummaryRanges object will be instantiated and called as such:\\n# obj = SummaryRanges()\\n# obj.addNum(value)\\n# param_2 = obj.getIntervals()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531106,
                "title": "python-solution-using-bisect-to-do-binary-search-beating-99-5-in-time",
                "content": "```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.intervals = [[float(\\'-inf\\'), float(\\'-inf\\')], [float(\\'inf\\'), float(\\'inf\\')]]\\n        \\n\\n    def addNum(self, val: int) -> None:\\n        i = bisect.bisect(self.intervals, [val])\\n        ps, pe = self.intervals[i-1]\\n        ns, ne = self.intervals[i]\\n        \\n        if pe == val - 1 and ns == val + 1:\\n            self.intervals = self.intervals[:i-1] + [[ps, ne]] + self.intervals[i+1:]\\n        elif pe == val - 1:\\n            self.intervals[i-1][1] = val\\n        elif ns == val + 1:\\n            self.intervals[i][0] = val\\n        elif pe < val - 1 and ns > val + 1:\\n            self.intervals = self.intervals[:i] + [[val, val]] + self.intervals[i:]\\n        \\n\\n    def getIntervals(self) -> List[List[int]]:\\n        return self.intervals[1:-1]\\n ```\\n \\n There are only four cases:\\n 1. [[1,2], [4,5]] + 3 -> merge two intervals into [[1,5]]\\n 2. [[1,2], [5,6]] + 3 -> update [1,2] to [1,3]\\n 3. [[1,2], [5,6]] + 4 -> update [5,6] to [4,6]\\n 4. [[1,2], [6,7]] + 4 -> add another interval [4,4]\\n\\nIf it turns out not in those four cases, then we make no updates to the intervals. \\n\\nWe use `bisect` to do binary search and find the two target intervals in `O(logn)` time. The solution can beat 99.5% Python code in time and 100% in memory.",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.intervals = [[float(\\'-inf\\'), float(\\'-inf\\')], [float(\\'inf\\'), float(\\'inf\\')]]\\n        \\n\\n    def addNum(self, val: int) -> None:\\n        i = bisect.bisect(self.intervals, [val])\\n        ps, pe = self.intervals[i-1]\\n        ns, ne = self.intervals[i]\\n        \\n        if pe == val - 1 and ns == val + 1:\\n            self.intervals = self.intervals[:i-1] + [[ps, ne]] + self.intervals[i+1:]\\n        elif pe == val - 1:\\n            self.intervals[i-1][1] = val\\n        elif ns == val + 1:\\n            self.intervals[i][0] = val\\n        elif pe < val - 1 and ns > val + 1:\\n            self.intervals = self.intervals[:i] + [[val, val]] + self.intervals[i:]\\n        \\n\\n    def getIntervals(self) -> List[List[int]]:\\n        return self.intervals[1:-1]\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 82660,
                "title": "java-fast-simple-code-using-treemap-with-detailed-explanation",
                "content": "The idea is map all map all val to its left bond of containing interval for fast lookup.\\nStore intervals in TreeMap as it seems to require output intervals in ascending order.(if ascending order is not required, I would use a hashmap for maximum performance)\\n\\n5 cases\\n0: isolated val\\n\\n1: val already in existing interval\\ne.g    [1,6]    3, do nothing\\n\\n2. val is connected to interval on its left\\ne.g [1,2] 3\\n\\n3. val is connected to interval on its right\\ne.g.  [4, 7] 3\\n\\n4. val is connected on both side\\ne.g  [1,2] [4, 7]  3.\\n\\nThe algorithm actually finds the possible left or right intervals to val, (or both). remove the old intervals,\\ninsert the new interval in the TreeMap. Update valueToBond hashmap to ensure the right bound val can find its correct left bound. Note that some val in the middle of the interval won't find correct left bound. But that is OK as we will not access to the middle values in the future! The left bound, right bound values must find their correct left bound.\\n\\n\\n  \\n\\n     public class SummaryRanges {\\n            private Map<Integer, Integer> valueToBond;//map val to containing interval left bound\\n            private Map<Integer, Interval> bondToInterval; // store intervals in TreeMap <left bound, interval>\\n            \\n            public SummaryRanges() {\\n                valueToBond = new HashMap<>();\\n                bondToInterval = new TreeMap<>();\\n            }\\n            \\n            public void addNum(int val) {\\n                //contained in an existing interval\\n                if (valueToBond.containsKey(val)) {\\n                    return;\\n                }\\n                //isolated number, no connection to its left or right\\n                if (!valueToBond.containsKey(val - 1) && !valueToBond.containsKey(val + 1)) {\\n                    valueToBond.put(val, val);\\n                    bondToInterval.put(val, new Interval(val, val));\\n                    return;\\n                }\\n                //may connect to left, right or both\\n                int left = valueToBond.containsKey(val - 1) ? valueToBond.get(val - 1) : val;\\n                int right = valueToBond.containsKey(val + 1) ? bondToInterval.get(valueToBond.get(val + 1)).end : val;\\n                valueToBond.put(val, left);\\n                valueToBond.put(right, left);\\n                bondToInterval.remove(val + 1);\\n                bondToInterval.put(left, new Interval(left, right));\\n            }\\n            \\n            public List<Interval> getIntervals() {\\n                return new ArrayList<>(bondToInterval.values());\\n            }\\n        }",
                "solutionTags": [],
                "code": "The idea is map all map all val to its left bond of containing interval for fast lookup.\\nStore intervals in TreeMap as it seems to require output intervals in ascending order.(if ascending order is not required, I would use a hashmap for maximum performance)\\n\\n5 cases\\n0: isolated val\\n\\n1: val already in existing interval\\ne.g    [1,6]    3, do nothing\\n\\n2. val is connected to interval on its left\\ne.g [1,2] 3\\n\\n3. val is connected to interval on its right\\ne.g.  [4, 7] 3\\n\\n4. val is connected on both side\\ne.g  [1,2] [4, 7]  3.\\n\\nThe algorithm actually finds the possible left or right intervals to val, (or both). remove the old intervals,\\ninsert the new interval in the TreeMap. Update valueToBond hashmap to ensure the right bound val can find its correct left bound. Note that some val in the middle of the interval won't find correct left bound. But that is OK as we will not access to the middle values in the future! The left bound, right bound values must find their correct left bound.\\n\\n\\n  \\n\\n     public class SummaryRanges {\\n            private Map<Integer, Integer> valueToBond;//map val to containing interval left bound\\n            private Map<Integer, Interval> bondToInterval; // store intervals in TreeMap <left bound, interval>\\n            \\n            public SummaryRanges() {\\n                valueToBond = new HashMap<>();\\n                bondToInterval = new TreeMap<>();\\n            }\\n            \\n            public void addNum(int val) {\\n                //contained in an existing interval\\n                if (valueToBond.containsKey(val)) {\\n                    return;\\n                }\\n                //isolated number, no connection to its left or right\\n                if (!valueToBond.containsKey(val - 1) && !valueToBond.containsKey(val + 1)) {\\n                    valueToBond.put(val, val);\\n                    bondToInterval.put(val, new Interval(val, val));\\n                    return;\\n                }\\n                //may connect to left, right or both\\n                int left = valueToBond.containsKey(val - 1) ? valueToBond.get(val - 1) : val;\\n                int right = valueToBond.containsKey(val + 1) ? bondToInterval.get(valueToBond.get(val + 1)).end : val;\\n                valueToBond.put(val, left);\\n                valueToBond.put(right, left);\\n                bondToInterval.remove(val + 1);\\n                bondToInterval.put(left, new Interval(left, right));\\n            }\\n            \\n            public List<Interval> getIntervals() {\\n                return new ArrayList<>(bondToInterval.values());\\n            }\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 82616,
                "title": "c-solution-using-map-o-logn-per-adding",
                "content": "c++ solution.\\n    \\n    map<int, Interval> m;\\n    void addNum(int val) {\\n        if (m.count(val)) return;\\n        \\n        auto higher = m.lower_bound(val);\\n        auto lower = (higher == m.begin()) ? m.end() : prev(higher);\\n\\n        if (lower != m.end() && higher != m.end() && lower->second.end + 1 == val && higher->first == val + 1) {\\n            // merge two intervals. [1, 2] [4, 5] with val 3;\\n            lower->second.end = higher->second.end;\\n            m.erase(higher);\\n        } else if (lower != m.end() && lower->second.end + 1 >= val) {\\n            // [1, 5] with val 6\\n            lower->second.end = max(lower->second.end, val);\\n        } else if (higher != m.end() && higher->first == val + 1) {\\n            // [4, 5] with 3\\n            m[val] = {val, higher->second.end};\\n            m.erase(higher);\\n        } else {\\n            m[val] = {val, val};\\n        }\\n    }\\n    \\n    vector<Interval> getIntervals() {\\n        vector<Interval> result;\\n        for (const auto& p : m) {\\n            result.push_back(p.second);\\n        }\\n        return result;\\n    }\\n...",
                "solutionTags": [],
                "code": "c++ solution.\\n    \\n    map<int, Interval> m;\\n    void addNum(int val) {\\n        if (m.count(val)) return;\\n        \\n        auto higher = m.lower_bound(val);\\n        auto lower = (higher == m.begin()) ? m.end() : prev(higher);\\n\\n        if (lower != m.end() && higher != m.end() && lower->second.end + 1 == val && higher->first == val + 1) {\\n            // merge two intervals. [1, 2] [4, 5] with val 3;\\n            lower->second.end = higher->second.end;\\n            m.erase(higher);\\n        } else if (lower != m.end() && lower->second.end + 1 >= val) {\\n            // [1, 5] with val 6\\n            lower->second.end = max(lower->second.end, val);\\n        } else if (higher != m.end() && higher->first == val + 1) {\\n            // [4, 5] with 3\\n            m[val] = {val, higher->second.end};\\n            m.erase(higher);\\n        } else {\\n            m[val] = {val, val};\\n        }\\n    }\\n    \\n    vector<Interval> getIntervals() {\\n        vector<Interval> result;\\n        for (const auto& p : m) {\\n            result.push_back(p.second);\\n        }\\n        return result;\\n    }\\n...",
                "codeTag": "Unknown"
            },
            {
                "id": 3107617,
                "title": "python3-beats-99-33",
                "content": "![image.png](https://assets.leetcode.com/users/images/30069894-5e76-4db0-85e2-f24ba8ce1ebd_1674880333.2723274.png)\\n\\n# Code\\n```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        def cmp():\\n            return -1\\n        self.mp=defaultdict(cmp)\\n        self.a=[]\\n        \\n\\n    def addNum(self, value: int) -> None:\\n        if self.mp[value]!=-1:\\n            return \\n        if self.mp[value-1]!=-1:\\n            self.a.remove([self.mp[value-1],value-1])\\n            \\n            self.mp[value]=self.mp[value-1]\\n            self.mp[self.mp[value-1]]=value\\n            self.a.append([self.mp[value],value])\\n            if self.mp[value+1]!=-1:\\n                self.a.remove([self.mp[value],value])\\n                self.a.remove([value+1,self.mp[value+1]])\\n                self.a.append([self.mp[value],self.mp[value+1]])\\n                self.mp[self.mp[value]]=self.mp[value+1]\\n                self.mp[self.mp[value+1]]=self.mp[value]\\n                \\n        elif self.mp[value+1]!=-1:\\n            self.a.remove([value+1,self.mp[value+1]])\\n            \\n            self.mp[value]=self.mp[value+1]\\n            self.mp[self.mp[value+1]]=value   \\n            self.a.append([value,self.mp[value]])         \\n            \\n        if self.mp[value]==-1:\\n            self.mp[value]=value\\n            self.a.append([value,value])\\n\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        return sorted(self.a)\\n        \\n\\n\\n# Your SummaryRanges object will be instantiated and called as such:\\n# obj = SummaryRanges()\\n# obj.addNum(value)\\n# param_2 = obj.getIntervals()\\n```\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        def cmp():\\n            return -1\\n        self.mp=defaultdict(cmp)\\n        self.a=[]\\n        \\n\\n    def addNum(self, value: int) -> None:\\n        if self.mp[value]!=-1:\\n            return \\n        if self.mp[value-1]!=-1:\\n            self.a.remove([self.mp[value-1],value-1])\\n            \\n            self.mp[value]=self.mp[value-1]\\n            self.mp[self.mp[value-1]]=value\\n            self.a.append([self.mp[value],value])\\n            if self.mp[value+1]!=-1:\\n                self.a.remove([self.mp[value],value])\\n                self.a.remove([value+1,self.mp[value+1]])\\n                self.a.append([self.mp[value],self.mp[value+1]])\\n                self.mp[self.mp[value]]=self.mp[value+1]\\n                self.mp[self.mp[value+1]]=self.mp[value]\\n                \\n        elif self.mp[value+1]!=-1:\\n            self.a.remove([value+1,self.mp[value+1]])\\n            \\n            self.mp[value]=self.mp[value+1]\\n            self.mp[self.mp[value+1]]=value   \\n            self.a.append([value,self.mp[value]])         \\n            \\n        if self.mp[value]==-1:\\n            self.mp[value]=value\\n            self.a.append([value,value])\\n\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        return sorted(self.a)\\n        \\n\\n\\n# Your SummaryRanges object will be instantiated and called as such:\\n# obj = SummaryRanges()\\n# obj.addNum(value)\\n# param_2 = obj.getIntervals()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107283,
                "title": "simple-and-detailed-explanation-with-video-tree-map",
                "content": "# Understanding  the problem:\\nDisjoint Intervals: [1,2,3,4, 6,7, 9] the numbers that are continious i.e 1,2,3,4 belong to one interval i.e [1,4]. Since 5 is not there 6,7 form another interval and [9,9] itself.\\n\\n# Intuition \\n# 1. How to form intervals?? \\n[1,2,3,4, 6,7, 9] First the input has to be sorted then we check if the element  = PREVIOUS element+1, if yes it belongs to same interval, if not we create a new interval.\\nInitiate left = A[0] right = A[0]\\nIterate over the array and \\n\\tif A[i]=right+1   (//Don\\'t store duplicates) A[i] belongs to same interval. \\n\\tElse left = A[i] and right = A[i]\\nOne Easy solution that comes to mind is to use arraylist and insertion sort i.e whenever a new element is added we just insert at right position. But We have a built in data structure that does the job for us treeSet in java or ordered Set in others.\\n\\n\\n# 2. Approach 1(Less optimized):\\nStore the numbers in treeset and form intervals every time getInterval is asked.(use above mentioned approach to form intervals).\\n\\n# 3.  Optimized:\\nInstead of forming the intervals there has to be a way to store the intervals and update it every time a new number is added.\\nThe initial answer is again a 2d array[[left, right], [l2,r2]]. But we again have a built in DS i.e TreeMaps.\\n\\nThe key are left and values are right. \\nTreeMap <Integer, Integer> intervals;\\nWhen a new integer is added .\\n\\n**Case 1**. There is no entry --> left = n right = n or key = n and value =n 1\\neg{\\n\\t1:1\\n}\\n\\n**Case 2.**     There is a entry but forms a new interval. 4\\n\\t{\\n\\t1:1\\n\\t4:4\\n\\t}\\n\\t\\n**Case 3.** There is an entry that belong to or changes just one entry.\\n\\teg 2\\n\\tget key value lesser than 2 .i.e 1\\n\\tif the value i.e 1 == 2-1, then we can just update this entry\\n\\t\\n\\t{\\n\\t\\t\\t1:2\\n\\t\\t\\t4:4\\n\\t}\\n\\t\\n**Case 4:**      \\nThere is a entry but changes 2 intervals:\\neg 3 will merge both intervals\\n\\ninitiate left =3 and right = 3\\n\\nget an key lesser that 3 i.e 1 and since 3 == 2+1, \\n\\nleft = 1;\\n\\n\\nget a key greater than 3 i.e 4\\n\\nsince 3 == 4-1\\n\\nright = 4 (the value)\\n\\n\\nRemove the above 2 values and add the left as key and right as value into the tree map.\\n\\n\\n{\\n\\t1:4\\n}\\n\\n\\nhttps://youtu.be/XJpitOiAQ_Y\\n\\n![upvote.webp](https://assets.leetcode.com/users/images/e81a44ac-2a0a-4268-8033-63780c428560_1674698166.6324708.webp)\\n\\n```\\nprivate TreeMap<Integer, Integer> intervals;\\n\\n    public SummaryRanges() {\\n        intervals = new TreeMap<>(); \\n    }\\n    \\n    public void addNum(int value) {\\n        final Map.Entry<Integer, Integer> minEntry = intervals.floorEntry(value); \\n        int left = value, right = value;\\n        if (minEntry != null) {\\n            int rightEntry = minEntry.getValue();\\n            if (rightEntry >= value) {\\n                return;\\n            }\\n            if (rightEntry == value - 1) {\\n                left = minEntry.getKey();\\n            }\\n        }\\n        final Map.Entry<Integer, Integer> maxEntry = intervals.higherEntry(value); \\n        if (maxEntry != null && maxEntry.getKey() == value + 1) {\\n            right = maxEntry.getValue();\\n            intervals.remove(value + 1);\\n        }\\n        intervals.put(left, right);\\n    }\\n    \\n    public int[][] getIntervals() {\\n        final int[][] answer = new int[intervals.size()][2];\\n        int i = 0;\\n        for (Map.Entry<Integer, Integer> entry : intervals.entrySet()) {\\n            answer[i][0] = entry.getKey();\\n            answer[i][1] = entry.getValue();\\n            i++;\\n        }\\n        return answer; \\n    }\\n```\\t\\n\\n```\\n\\tclass SummaryRanges {\\n    map<int, int> intervals;\\n\\n\\tpublic:\\n\\t\\tSummaryRanges() {}\\n\\n    void addNum(int value) {\\n        int left = value, right = value;\\n        auto min_entry = intervals.upper_bound(value);\\n        if (min_entry != intervals.begin()) {\\n            auto max_entry = min_entry;\\n            --max_entry;\\n            if (max_entry->second >= value) {\\n                return;\\n            }\\n            if (max_entry->second == value - 1) {\\n                left = max_entry->first;\\n            }\\n        }\\n        if (min_entry != intervals.end() && min_entry->first == value + 1) {\\n            right = min_entry->second;\\n            intervals.erase(min_entry);\\n        }\\n        intervals[left] = right;\\n    }\\n\\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> answer;\\n        for (const auto& p : intervals) {\\n            answer.push_back({p.first, p.second});\\n        }\\n        return answer;\\n    }\\n\\t};\\n```\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Tree"
                ],
                "code": "```\\nprivate TreeMap<Integer, Integer> intervals;\\n\\n    public SummaryRanges() {\\n        intervals = new TreeMap<>(); \\n    }\\n    \\n    public void addNum(int value) {\\n        final Map.Entry<Integer, Integer> minEntry = intervals.floorEntry(value); \\n        int left = value, right = value;\\n        if (minEntry != null) {\\n            int rightEntry = minEntry.getValue();\\n            if (rightEntry >= value) {\\n                return;\\n            }\\n            if (rightEntry == value - 1) {\\n                left = minEntry.getKey();\\n            }\\n        }\\n        final Map.Entry<Integer, Integer> maxEntry = intervals.higherEntry(value); \\n        if (maxEntry != null && maxEntry.getKey() == value + 1) {\\n            right = maxEntry.getValue();\\n            intervals.remove(value + 1);\\n        }\\n        intervals.put(left, right);\\n    }\\n    \\n    public int[][] getIntervals() {\\n        final int[][] answer = new int[intervals.size()][2];\\n        int i = 0;\\n        for (Map.Entry<Integer, Integer> entry : intervals.entrySet()) {\\n            answer[i][0] = entry.getKey();\\n            answer[i][1] = entry.getValue();\\n            i++;\\n        }\\n        return answer; \\n    }\\n```\n```\\n\\tclass SummaryRanges {\\n    map<int, int> intervals;\\n\\n\\tpublic:\\n\\t\\tSummaryRanges() {}\\n\\n    void addNum(int value) {\\n        int left = value, right = value;\\n        auto min_entry = intervals.upper_bound(value);\\n        if (min_entry != intervals.begin()) {\\n            auto max_entry = min_entry;\\n            --max_entry;\\n            if (max_entry->second >= value) {\\n                return;\\n            }\\n            if (max_entry->second == value - 1) {\\n                left = max_entry->first;\\n            }\\n        }\\n        if (min_entry != intervals.end() && min_entry->first == value + 1) {\\n            right = min_entry->second;\\n            intervals.erase(min_entry);\\n        }\\n        intervals[left] = right;\\n    }\\n\\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> answer;\\n        for (const auto& p : intervals) {\\n            answer.push_back({p.first, p.second});\\n        }\\n        return answer;\\n    }\\n\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82562,
                "title": "c-solution-using-vector-and-binary-search-with-explanation",
                "content": "For a new number n, find and return the index of interval [s, t] such that s is the largest 'start' that is smaller than n. If no such interval exists, return -1. This is done using binary search.\\n\\nFor example, \\n\\n - new number 5, intervals [[1,1], [4,6], [8,8]], binary search returns 1.\\n\\n - new number 0, intervals [[1,1], [4,6], [8,8]], binary search returns -1.\\n\\nAfter we find this 'index', there are three circumstances:\\n\\n1. intervals[index] already contains val. Do nothing.\\n\\n2. val can be merged into intervals[index+1]. Modify intervals[index+1].start to val.\\n\\n3. val can be merged into intervals[index]. Modify intervals[index].end to val.\\n\\n4. val can't be merged into either interval. Insert Interval( val, val).\\n\\nFinally, after inserting val, we need to check whether intervals[index] and intervals[index+1] can be merged.\\n\\n\\n\\n    class SummaryRanges {\\n    private:\\n        vector<Interval> intervals = vector<Interval>();\\n        \\n        int binarySearch(vector<Interval> intervals, int val) {\\n            return binarySearchHelper(intervals, 0, intervals.size(), val);\\n        }\\n        \\n        int binarySearchHelper(vector<Interval> intervals, int start, int end, int val) {\\n            if (start == end) return -1;\\n            if (start+1 == end && intervals[start].start < val) return start;\\n            \\n            int mid = (start + end)/2;\\n            if (intervals[mid].start == val) {\\n                return mid;\\n            } else if (intervals[mid].start < val) {\\n                return binarySearchHelper(intervals, mid, end, val);\\n            } else { //intervals[mid] > val\\n                return binarySearchHelper(intervals, start, mid, val);\\n            }\\n        }\\n        \\n    public:\\n        /** Initialize your data structure here. */\\n        SummaryRanges() {\\n            \\n        }\\n        \\n        /** For a new number n, find the last(biggest) interval\\n         *  [s,t], such that s < n. If no such interval exists, \\n         *  return -1.\\n         */\\n        void addNum(int val) {\\n            int index = binarySearch(intervals, val);\\n            \\n            // intervals[index] contains val\\n            if (index != -1 && intervals[index].end >= val) {\\n                return;\\n            }\\n            \\n            if (index != intervals.size()-1 && val + 1 == intervals[index+1].start) {\\n                intervals[index+1].start = val;\\n            } else if (index != -1 && val - 1 == intervals[index].end) {\\n                intervals[index].end = val;\\n            } else {\\n                intervals.insert(intervals.begin() + index + 1, Interval(val, val));\\n            }\\n            \\n            //merge intervals[index] with intervals[index+1]\\n            if (index != -1 && intervals[index].end + 1 == intervals[index+1].start) {\\n                intervals[index].end = intervals[index+1].end;\\n                intervals.erase(intervals.begin()+index+1);\\n            }\\n            \\n            return;\\n        }\\n        \\n        vector<Interval> getIntervals() {\\n            return this->intervals;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "For a new number n, find and return the index of interval [s, t] such that s is the largest 'start' that is smaller than n. If no such interval exists, return -1. This is done using binary search.\\n\\nFor example, \\n\\n - new number 5, intervals [[1,1], [4,6], [8,8]], binary search returns 1.\\n\\n - new number 0, intervals [[1,1], [4,6], [8,8]], binary search returns -1.\\n\\nAfter we find this 'index', there are three circumstances:\\n\\n1. intervals[index] already contains val. Do nothing.\\n\\n2. val can be merged into intervals[index+1]. Modify intervals[index+1].start to val.\\n\\n3. val can be merged into intervals[index]. Modify intervals[index].end to val.\\n\\n4. val can't be merged into either interval. Insert Interval( val, val).\\n\\nFinally, after inserting val, we need to check whether intervals[index] and intervals[index+1] can be merged.\\n\\n\\n\\n    class SummaryRanges {\\n    private:\\n        vector<Interval> intervals = vector<Interval>();\\n        \\n        int binarySearch(vector<Interval> intervals, int val) {\\n            return binarySearchHelper(intervals, 0, intervals.size(), val);\\n        }\\n        \\n        int binarySearchHelper(vector<Interval> intervals, int start, int end, int val) {\\n            if (start == end) return -1;\\n            if (start+1 == end && intervals[start].start < val) return start;\\n            \\n            int mid = (start + end)/2;\\n            if (intervals[mid].start == val) {\\n                return mid;\\n            } else if (intervals[mid].start < val) {\\n                return binarySearchHelper(intervals, mid, end, val);\\n            } else { //intervals[mid] > val\\n                return binarySearchHelper(intervals, start, mid, val);\\n            }\\n        }\\n        \\n    public:\\n        /** Initialize your data structure here. */\\n        SummaryRanges() {\\n            \\n        }\\n        \\n        /** For a new number n, find the last(biggest) interval\\n         *  [s,t], such that s < n. If no such interval exists, \\n         *  return -1.\\n         */\\n        void addNum(int val) {\\n            int index = binarySearch(intervals, val);\\n            \\n            // intervals[index] contains val\\n            if (index != -1 && intervals[index].end >= val) {\\n                return;\\n            }\\n            \\n            if (index != intervals.size()-1 && val + 1 == intervals[index+1].start) {\\n                intervals[index+1].start = val;\\n            } else if (index != -1 && val - 1 == intervals[index].end) {\\n                intervals[index].end = val;\\n            } else {\\n                intervals.insert(intervals.begin() + index + 1, Interval(val, val));\\n            }\\n            \\n            //merge intervals[index] with intervals[index+1]\\n            if (index != -1 && intervals[index].end + 1 == intervals[index+1].start) {\\n                intervals[index].end = intervals[index+1].end;\\n                intervals.erase(intervals.begin()+index+1);\\n            }\\n            \\n            return;\\n        }\\n        \\n        vector<Interval> getIntervals() {\\n            return this->intervals;\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 3109542,
                "title": "c-very-intuitive-sol-using-binary-search",
                "content": "```\\nclass SummaryRanges {\\n    vector<int> v;\\n    unordered_map<int,bool> mp;\\npublic:\\n    void addNum(int value) {\\n\\t// when a new number is coming we add it to the vector v at the upper bound index of the value with unique elements which i am checking usinig unordered_map\\n        if(!(mp.count(value))) v.insert(upper_bound(v.begin(),v.end(),value),value) , mp[value] = true;\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> ans = {{v[0]}};  // initializing the ans vector with the 0th elemt of the vector;\\n        for(int i = 1;i<v.size();i++){\\n            if(ans.back().back() + 1 == v[i]) { // if last elemet of the last vector of ans vector == v[i] - 1 then \\n                if(ans.back().size() == 2) ans.back().back() = v[i]; // we check if the value of last vector is 2 then we simple equate the last value of the last vector = to v[i];\\n                else ans.back().push_back(v[i]); // else if last vector has size smaller then 2 then add v[i] to last vector of ans\\n            }\\n            else {\\n                if(ans.back().size() == 1) ans.back().emplace_back(ans.back()[0]); // here we are checking if the interval size is one then we make it size of two.  eg [1] = [1,1]\\n                ans.push_back({v[i]}); // and we add a new interval.\\n            }\\n        }\\n        if(ans.back().size() == 1) ans.back().emplace_back(ans.back()[0]); // checking for the last vector if its size if 1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Design"
                ],
                "code": "```\\nclass SummaryRanges {\\n    vector<int> v;\\n    unordered_map<int,bool> mp;\\npublic:\\n    void addNum(int value) {\\n\\t// when a new number is coming we add it to the vector v at the upper bound index of the value with unique elements which i am checking usinig unordered_map\\n        if(!(mp.count(value))) v.insert(upper_bound(v.begin(),v.end(),value),value) , mp[value] = true;\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> ans = {{v[0]}};  // initializing the ans vector with the 0th elemt of the vector;\\n        for(int i = 1;i<v.size();i++){\\n            if(ans.back().back() + 1 == v[i]) { // if last elemet of the last vector of ans vector == v[i] - 1 then \\n                if(ans.back().size() == 2) ans.back().back() = v[i]; // we check if the value of last vector is 2 then we simple equate the last value of the last vector = to v[i];\\n                else ans.back().push_back(v[i]); // else if last vector has size smaller then 2 then add v[i] to last vector of ans\\n            }\\n            else {\\n                if(ans.back().size() == 1) ans.back().emplace_back(ans.back()[0]); // here we are checking if the interval size is one then we make it size of two.  eg [1] = [1,1]\\n                ans.push_back({v[i]}); // and we add a new interval.\\n            }\\n        }\\n        if(ans.back().size() == 1) ans.back().emplace_back(ans.back()[0]); // checking for the last vector if its size if 1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346064,
                "title": "short-c-solution-easy-to-understand-used-map",
                "content": "```\\nclass SummaryRanges {\\npublic:\\n    /** Initialize your data structure here. */\\n    map<int, int> m;\\n    SummaryRanges() {\\n    }\\n    \\n    void addNum(int val) {\\n        if(m.count(val)) return;\\n        m[val] = val;\\n        int mn = val, mx = val;\\n        if (m.count(val - 1)) mn = m[val-1];\\n        if (m.count(val + 1)) mx = m[val + 1];\\n        m[mn] = mx;\\n        m[mx] = mn;\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int> > ans;\\n        auto it = m.begin();\\n        while(it != m.end()) {\\n            ans.push_back({it->first, it->second});\\n            it = m.upper_bound(it->second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass SummaryRanges {\\npublic:\\n    /** Initialize your data structure here. */\\n    map<int, int> m;\\n    SummaryRanges() {\\n    }\\n    \\n    void addNum(int val) {\\n        if(m.count(val)) return;\\n        m[val] = val;\\n        int mn = val, mx = val;\\n        if (m.count(val - 1)) mn = m[val-1];\\n        if (m.count(val + 1)) mx = m[val + 1];\\n        m[mn] = mx;\\n        m[mx] = mn;\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int> > ans;\\n        auto it = m.begin();\\n        while(it != m.end()) {\\n            ans.push_back({it->first, it->second});\\n            it = m.upper_bound(it->second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108647,
                "title": "c-bruteforce-felt-like-an-easy-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**After reading question carefully, I observed 2 major things**\\n- The constraints are 10<sup>4</sup> so we can come up with a n<sup>2</sup> solution. That\\'s why I tried a bruteforce solution.\\n- We have to merge the the intervals again and again which felt like a hassle so I choosed a line sweep method.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n<img src=\"https://imgur.com/tPc9DZh.png\" alt=\"\">\\nWe will check for the ranges which are true and will add these ranges to our Answer vector.\\n\\n# Complexity\\n> - Time complexity: $$O(n2)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n> - Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n# Code\\n```\\nclass SummaryRanges {\\npublic:\\n    //The numberline \\n    vector<bool> arr;\\n    int mx = -1;\\n    SummaryRanges() {\\n        arr = vector<bool>(10001, false);\\n    }\\n    \\n    void addNum(int value) {\\n        arr[value] = true;\\n        mx = max(value, mx);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> ans;\\n        // finding ranges\\n        for(int i = 0; i <= mx; i++){\\n            int j = i;\\n            while(j <= mx && arr[j]){\\n                j++;\\n            }\\n            // check if the current range is valid or not\\n            if(arr[i])\\n            ans.push_back(vector<int>{i,j-1});\\n            i = j;\\n        }\\n        return ans;\\n    }\\n    // Note: we don\\'t need to check for 10^4 everytime,\\n    // we used mx to check until maximum element.\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SummaryRanges {\\npublic:\\n    //The numberline \\n    vector<bool> arr;\\n    int mx = -1;\\n    SummaryRanges() {\\n        arr = vector<bool>(10001, false);\\n    }\\n    \\n    void addNum(int value) {\\n        arr[value] = true;\\n        mx = max(value, mx);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> ans;\\n        // finding ranges\\n        for(int i = 0; i <= mx; i++){\\n            int j = i;\\n            while(j <= mx && arr[j]){\\n                j++;\\n            }\\n            // check if the current range is valid or not\\n            if(arr[i])\\n            ans.push_back(vector<int>{i,j-1});\\n            i = j;\\n        }\\n        return ans;\\n    }\\n    // Note: we don\\'t need to check for 10^4 everytime,\\n    // we used mx to check until maximum element.\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107325,
                "title": "clean-codes-full-explanation-ordered-set-c-java",
                "content": "# Explanation to Approach :\\n- \"addNum(int val)\" : method is used to add a new integer to the range.\\n- \"getIntervals()\" : method is used to get the summary of the range of integers.\\n1. Here we are using a data structure called \"TreeMap\" which is similar to a dictionary, it stores the range of integers as key-value pairs, where the key is the start of the range and the value is an array of two integers, the start and the end of the range.\\n\\n2. The \"addNum(int val)\" method first checks if the integer has already been added to the range, if it has, it returns without doing anything. If not, it finds the range that the new integer belongs to by finding the maximum number in the map that is less than the new integer and the minimum number in the map that is greater than the new integer. \\n3. Then it proceeds to update the range, it does this by checking different conditions and updating the range accordingly, such as merging two ranges if the new integer is the missing link between them, or adding the new integer to an existing range if it is a part of it.\\n\\n4. The \"getIntervals()\" method is used to get the summary of the range of integers, it does this by getting all the values of the \"TreeMap\" data structure and storing them in a list called \"intervals\", then it returns the list as a 2D array.\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n\\n# Code [C++ | Java] : (Explained in Comments)\\n```C++ []\\nclass SummaryRanges {\\n public:\\n  void addNum(int val) {\\n    if (map.count(val))\\n      return;\\n\\n    const int lo = lowerKey(val);\\n    const int hi = higherKey(val);\\n\\n    // {lo, map[lo][1]} + val + {hi, map[hi][1]} = {lo, map[hi][1]}\\n    if (lo >= 0 && hi >= 0 && map[lo][1] + 1 == val && val + 1 == hi) {\\n      map[lo][1] = map[hi][1];\\n      map.erase(hi);\\n      // {lo, map[lo][1]} + val = {lo, val}\\n      // (prevent adding duplicate entry by using \\'>=\\' instead of \\'==\\')\\n    } else if (lo >= 0 && map[lo][1] + 1 >= val) {\\n      map[lo][1] = max(map[lo][1], val);\\n    } else if (hi >= 0 && val + 1 == hi) {\\n      // Val + {hi, map[hi][1]} = {val, map[hi][1]}\\n      map[val] = {val, map[hi][1]};\\n      map.erase(hi);\\n    } else {\\n      map[val] = {val, val};\\n    }\\n  }\\n\\n  vector<vector<int>> getIntervals() {\\n    vector<vector<int>> intervals;\\n    for (const auto& [_, interval] : map)\\n      intervals.push_back(interval);\\n    return intervals;\\n  }\\n\\n private:\\n  map<int, vector<int>> map;  // {start: {start, end}}\\n\\n  // Maximum in map < key\\n  int lowerKey(int key) {\\n    auto it = map.lower_bound(key);  // Minimum in map >= key\\n    if (it == begin(map))\\n      return -1;\\n    return (--it)->first;\\n  }\\n\\n  // Minimum in map > key\\n  int higherKey(int key) {\\n    const auto it = map.upper_bound(key);  // Minimum in map > key\\n    if (it == cend(map))\\n      return -1;\\n    return it->first;\\n  }\\n};\\n```\\n```Java []\\nclass SummaryRanges {\\n  public void addNum(int val) {\\n    if (map.containsKey(val))\\n      return;\\n\\n    final Integer lo = map.lowerKey(val);  // Maximum in map < key\\n    final Integer hi = map.higherKey(val); // Minimum in map > key\\n\\n    // {lo, map.get(lo)[1]} + val + {hi, map.get(hi)[1]} = {lo, map.get(hi)[1]}\\n    if (lo != null && hi != null && map.get(lo)[1] + 1 == val && val + 1 == hi) {\\n      map.get(lo)[1] = map.get(hi)[1];\\n      map.remove(hi);\\n      // {lo, map.get(lo)[1]} + val = {lo, val}\\n      // (prevent adding duplicate entry by using \\'>=\\' instead of \\'==\\')\\n    } else if (lo != null && map.get(lo)[1] + 1 >= val) {\\n      map.get(lo)[1] = Math.max(map.get(lo)[1], val);\\n      // Val + {hi, map.get(hi)[1]} = {val, map.get(hi)[1]}\\n    } else if (hi != null && val + 1 == hi) {\\n      map.put(val, new int[] {val, map.get(hi)[1]});\\n      map.remove(hi);\\n    } else {\\n      map.put(val, new int[] {val, val});\\n    }\\n  }\\n\\n  public int[][] getIntervals() {\\n    List<int[]> intervals = new ArrayList<>(map.values());\\n    return intervals.toArray(new int[intervals.size()][]);\\n  }\\n\\n  // {start: {start, end}}\\n  private TreeMap<Integer, int[]> map = new TreeMap<>();\\n}\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/090a4018-642c-408c-9fa6-c772958fbea9_1674869501.9143817.gif)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Binary Search",
                    "Design",
                    "Ordered Set"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```C++ []\\nclass SummaryRanges {\\n public:\\n  void addNum(int val) {\\n    if (map.count(val))\\n      return;\\n\\n    const int lo = lowerKey(val);\\n    const int hi = higherKey(val);\\n\\n    // {lo, map[lo][1]} + val + {hi, map[hi][1]} = {lo, map[hi][1]}\\n    if (lo >= 0 && hi >= 0 && map[lo][1] + 1 == val && val + 1 == hi) {\\n      map[lo][1] = map[hi][1];\\n      map.erase(hi);\\n      // {lo, map[lo][1]} + val = {lo, val}\\n      // (prevent adding duplicate entry by using \\'>=\\' instead of \\'==\\')\\n    } else if (lo >= 0 && map[lo][1] + 1 >= val) {\\n      map[lo][1] = max(map[lo][1], val);\\n    } else if (hi >= 0 && val + 1 == hi) {\\n      // Val + {hi, map[hi][1]} = {val, map[hi][1]}\\n      map[val] = {val, map[hi][1]};\\n      map.erase(hi);\\n    } else {\\n      map[val] = {val, val};\\n    }\\n  }\\n\\n  vector<vector<int>> getIntervals() {\\n    vector<vector<int>> intervals;\\n    for (const auto& [_, interval] : map)\\n      intervals.push_back(interval);\\n    return intervals;\\n  }\\n\\n private:\\n  map<int, vector<int>> map;  // {start: {start, end}}\\n\\n  // Maximum in map < key\\n  int lowerKey(int key) {\\n    auto it = map.lower_bound(key);  // Minimum in map >= key\\n    if (it == begin(map))\\n      return -1;\\n    return (--it)->first;\\n  }\\n\\n  // Minimum in map > key\\n  int higherKey(int key) {\\n    const auto it = map.upper_bound(key);  // Minimum in map > key\\n    if (it == cend(map))\\n      return -1;\\n    return it->first;\\n  }\\n};\\n```\n```Java []\\nclass SummaryRanges {\\n  public void addNum(int val) {\\n    if (map.containsKey(val))\\n      return;\\n\\n    final Integer lo = map.lowerKey(val);  // Maximum in map < key\\n    final Integer hi = map.higherKey(val); // Minimum in map > key\\n\\n    // {lo, map.get(lo)[1]} + val + {hi, map.get(hi)[1]} = {lo, map.get(hi)[1]}\\n    if (lo != null && hi != null && map.get(lo)[1] + 1 == val && val + 1 == hi) {\\n      map.get(lo)[1] = map.get(hi)[1];\\n      map.remove(hi);\\n      // {lo, map.get(lo)[1]} + val = {lo, val}\\n      // (prevent adding duplicate entry by using \\'>=\\' instead of \\'==\\')\\n    } else if (lo != null && map.get(lo)[1] + 1 >= val) {\\n      map.get(lo)[1] = Math.max(map.get(lo)[1], val);\\n      // Val + {hi, map.get(hi)[1]} = {val, map.get(hi)[1]}\\n    } else if (hi != null && val + 1 == hi) {\\n      map.put(val, new int[] {val, map.get(hi)[1]});\\n      map.remove(hi);\\n    } else {\\n      map.put(val, new int[] {val, val});\\n    }\\n  }\\n\\n  public int[][] getIntervals() {\\n    List<int[]> intervals = new ArrayList<>(map.values());\\n    return intervals.toArray(new int[intervals.size()][]);\\n  }\\n\\n  // {start: {start, end}}\\n  private TreeMap<Integer, int[]> map = new TreeMap<>();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107504,
                "title": "set-cpp-o-nlogn",
                "content": "- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    T(n) = O(nlogn)\\n\\n# Code\\n```\\nclass SummaryRanges {\\nprivate: set<int> st;\\npublic:\\n    SummaryRanges() {}\\n    void addNum(int value) {\\n        st.insert(value);\\n    }\\n    vector<vector<int>> getIntervals(){       \\n        vector<vector<int>> result; \\n        int n = size(st); \\n        auto firstIt = begin(st), secondIt = begin(st);\\n        ++secondIt;    \\n        for(int i = 0; i < n ; i++) {\\n            int start = *firstIt;          \\n            while(i < n-1 && *firstIt + 1 == *secondIt) {\\n                i++;\\n                firstIt++, secondIt++;\\n            }\\n            result.push_back({start, *firstIt});\\n            ++firstIt, ++secondIt;\\n        }   \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SummaryRanges {\\nprivate: set<int> st;\\npublic:\\n    SummaryRanges() {}\\n    void addNum(int value) {\\n        st.insert(value);\\n    }\\n    vector<vector<int>> getIntervals(){       \\n        vector<vector<int>> result; \\n        int n = size(st); \\n        auto firstIt = begin(st), secondIt = begin(st);\\n        ++secondIt;    \\n        for(int i = 0; i < n ; i++) {\\n            int start = *firstIt;          \\n            while(i < n-1 && *firstIt + 1 == *secondIt) {\\n                i++;\\n                firstIt++, secondIt++;\\n            }\\n            result.push_back({start, *firstIt});\\n            ++firstIt, ++secondIt;\\n        }   \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82619,
                "title": "java-ac-union-find-solution",
                "content": "public class SummaryRanges {\\n\\n    HashMap<Integer,Integer> map;\\n    HashMap<Integer,Integer> Intervals;\\n\\n    /** Initialize your data structure here. */\\n    public SummaryRanges() {\\n        map = new HashMap<>();\\n        Intervals = new HashMap<>();\\n    }\\n    \\n    public void addNum(int val) {\\n        if(map.containsKey(val))\\n            return;\\n        else{\\n            map.put(val,1);\\n            if(map.containsKey(val+1) && map.containsKey(val-1)){\\n                int l = map.get(val+1);\\n                int r = map.get(val-1);\\n                map.put(val+l,l+r+1);\\n                map.put(val-r,l+r+1);\\n                Intervals.remove(val+1);\\n                Intervals.put(val-r,l+r+1);\\n            }\\n            else if(map.containsKey(val+1)){\\n                int l = map.get(val+1);\\n                map.put(val+l,l+1);\\n                map.put(val,l+1);\\n                Intervals.remove(val+1);\\n                Intervals.put(val,l+1);\\n            }\\n            else if(map.containsKey(val-1)){\\n                int r = map.get(val-1);\\n                map.put(val-r,r+1);\\n                map.put(val,r+1);\\n                Intervals.put(val-r,r+1);\\n            }\\n            else\\n                Intervals.put(val,1);\\n        }\\n    }\\n    \\n    public List<Interval> getIntervals() {\\n        List<Interval> list = new ArrayList<>();\\n        for(Integer i: Intervals.keySet())\\n            list.add(new Interval(i,i+Intervals.get(i)-1));\\n        Collections.sort(list, new Comparator<Interval>(){\\n            @Override\\n            public int compare(Interval i1, Interval i2){\\n                return i1.start-i2.start;\\n            }\\n        });\\n        return list;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "public class SummaryRanges {\\n\\n    HashMap<Integer,Integer> map;\\n    HashMap<Integer,Integer> Intervals;\\n\\n    /** Initialize your data structure here. */\\n    public SummaryRanges() {\\n        map = new HashMap<>();\\n        Intervals = new HashMap<>();\\n    }\\n    \\n    public void addNum(int val) {\\n        if(map.containsKey(val))\\n            return;\\n        else{\\n            map.put(val,1);\\n            if(map.containsKey(val+1) && map.containsKey(val-1)){\\n                int l = map.get(val+1);\\n                int r = map.get(val-1);\\n                map.put(val+l,l+r+1);\\n                map.put(val-r,l+r+1);\\n                Intervals.remove(val+1);\\n                Intervals.put(val-r,l+r+1);\\n            }\\n            else if(map.containsKey(val+1)){\\n                int l = map.get(val+1);\\n                map.put(val+l,l+1);\\n                map.put(val,l+1);\\n                Intervals.remove(val+1);\\n                Intervals.put(val,l+1);\\n            }\\n            else if(map.containsKey(val-1)){\\n                int r = map.get(val-1);\\n                map.put(val-r,r+1);\\n                map.put(val,r+1);\\n                Intervals.put(val-r,r+1);\\n            }\\n            else\\n                Intervals.put(val,1);\\n        }\\n    }\\n    \\n    public List<Interval> getIntervals() {\\n        List<Interval> list = new ArrayList<>();\\n        for(Integer i: Intervals.keySet())\\n            list.add(new Interval(i,i+Intervals.get(i)-1));\\n        Collections.sort(list, new Comparator<Interval>(){\\n            @Override\\n            public int compare(Interval i1, Interval i2){\\n                return i1.start-i2.start;\\n            }\\n        });\\n        return list;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 214428,
                "title": "python-solution-with-o-1-per-adding-and-o-m-log-m-per-getinterval",
                "content": "My solution gets AC, but I am not that confident given everyone is posting O(log(N)) solutions.\\n\\nKeep in mind that getInterval needs to return m = #intervals elements, so the runtime is Omega(m), even if you directly maintain the intervals and return it. It might not be the case if the return value is passed by address, correct me if this is the case.\\n\\nThe adding runtime is obviously optimal. But there is a not too bad overhead for getInterval, and the memory might be bad. We are using O(n) for recording all seen elements.\\n\\nThe idea is to maintain a dictionary from interval left to interval right and another from interval right to interval left.\\n\\nFor each new value,\\n- if the value is added before, just ignore\\n- if the value is isolated, insert value => value to both dictionaries\\n- if value - 1 is unseen but value + 1 is seen, merge with [value + 1, left_to_right[value + 1]]\\n- if value - 1 is seen but value + 1 is unseen, merge with [right_to_left[value - 1], value - 1]\\n- otherwise, merge with [right_to_left[value - 1], value - 1] and [value + 1, left_to_right[value + 1]]\\n\\nFor each merge, delete the outdated keys from the dictionary.\\n\\nExample: [1, 3, 7, 2, 6]\\n* Initially, left_to_right = {}, right_to_left = {}\\n* Add 1, left_to_right = {1:1}, right_to_left = {1:1}\\n* Add 3, left_to_right = {1:1, 3:3}, right_to_left = {1:1, 3:3}\\n* Add 7, left_to_right = {1:1, 3:3, 7:7}, right_to_left = {1:1, 3:3, 7:7}\\n* Add 2, left_to_right = {1:3, 7:7}, right_to_left = {3:1, 7:7}\\n* Add 6, left_to_right = {1:3, 6:7}, right_to_left = {3:1, 7:6}\\n\\nFor getInterval, simply sort the left => right pairs inside left_to_right.\\n\\n```\\n# Definition for an interval.\\n# class Interval(object):\\n#     def __init__(self, s=0, e=0):\\n#         self.start = s\\n#         self.end = e\\n\\nclass SummaryRanges(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.seen = set()\\n        self.left2right = dict()\\n        self.right2left = dict()\\n\\n    def addNum(self, val):\\n        \"\"\"\\n        :type val: int\\n        :rtype: void\\n        \"\"\"\\n        if val in self.seen:\\n            return\\n        self.seen.add(val)\\n        if val - 1 not in self.right2left and val + 1 not in self.left2right:\\n            self.left2right[val] = val\\n            self.right2left[val] = val\\n        elif val - 1 not in self.right2left and val + 1 in self.left2right:\\n            self.left2right[val] = self.left2right[val + 1]\\n            self.right2left[self.left2right[val]] = val\\n            del self.left2right[val + 1]\\n        elif val - 1 in self.right2left and val + 1 not in self.left2right:\\n            self.right2left[val] = self.right2left[val - 1]\\n            self.left2right[self.right2left[val]] = val\\n            del self.right2left[val - 1]\\n        else:\\n            left = self.right2left[val - 1]\\n            right = self.left2right[val + 1]\\n            del self.left2right[val + 1]\\n            del self.right2left[val - 1]\\n            self.left2right[left] = right\\n            self.right2left[right] = left\\n\\n    def getIntervals(self):\\n        \"\"\"\\n        :rtype: List[Interval]\\n        \"\"\"\\n        rtn = [Interval(k, v) for k, v in self.left2right.items()]\\n        rtn.sort(key=lambda i: i.start)\\n        return rtn\\n\\n\\n# Your SummaryRanges object will be instantiated and called as such:\\n# obj = SummaryRanges()\\n# obj.addNum(val)\\n# param_2 = obj.getIntervals()\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for an interval.\\n# class Interval(object):\\n#     def __init__(self, s=0, e=0):\\n#         self.start = s\\n#         self.end = e\\n\\nclass SummaryRanges(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.seen = set()\\n        self.left2right = dict()\\n        self.right2left = dict()\\n\\n    def addNum(self, val):\\n        \"\"\"\\n        :type val: int\\n        :rtype: void\\n        \"\"\"\\n        if val in self.seen:\\n            return\\n        self.seen.add(val)\\n        if val - 1 not in self.right2left and val + 1 not in self.left2right:\\n            self.left2right[val] = val\\n            self.right2left[val] = val\\n        elif val - 1 not in self.right2left and val + 1 in self.left2right:\\n            self.left2right[val] = self.left2right[val + 1]\\n            self.right2left[self.left2right[val]] = val\\n            del self.left2right[val + 1]\\n        elif val - 1 in self.right2left and val + 1 not in self.left2right:\\n            self.right2left[val] = self.right2left[val - 1]\\n            self.left2right[self.right2left[val]] = val\\n            del self.right2left[val - 1]\\n        else:\\n            left = self.right2left[val - 1]\\n            right = self.left2right[val + 1]\\n            del self.left2right[val + 1]\\n            del self.right2left[val - 1]\\n            self.left2right[left] = right\\n            self.right2left[right] = left\\n\\n    def getIntervals(self):\\n        \"\"\"\\n        :rtype: List[Interval]\\n        \"\"\"\\n        rtn = [Interval(k, v) for k, v in self.left2right.items()]\\n        rtn.sort(key=lambda i: i.start)\\n        return rtn\\n\\n\\n# Your SummaryRanges object will be instantiated and called as such:\\n# obj = SummaryRanges()\\n# obj.addNum(val)\\n# param_2 = obj.getIntervals()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109060,
                "title": "python-short-and-clean-with-explanation-sortedlist-bst",
                "content": "# Approach\\nOverall algorithm:\\n\\n1. Initialize a `SortedList` of `intervals`, where an interval is of form `[a, b]`.\\n\\n2. Maintain the `non overlapping` invariant after each `addNum` operation. (Described below in `addNum` operation)\\n\\n3. In `getIntervals` operation, return the `intervals` list as is.\\n\\n\\nOperation `addNum` algorithm:\\n\\n1. Binary search for the insertion point of `value` in the `intervals`, say index `i`.\\n\\n2. Let, `lt` be the left interval of `value`. i.e, `lt = intervals[i - 1]`.\\n\\n3. Let, `rt` be the right interval of `value`. i.e, `rt = intervals[i]`.\\n\\n4. Note that, `lt[1] <= value < rt[0]`.\\n\\n5. Now there are bunch of cases to handle:\\n\\n    1. `lt[0] <= value <= lt[1]`:\\n        Existing interval `lt` already covers `value`. No need to do anything.\\n        Ex: `lt = [2, 5], value = 4`.\\n\\n    2. `lt[1] + 1 == value` and `value == rt[0] - 1`:\\n        Both `lt` and `rt` can be merged using `value` as intermediate!\\n        Remove `lt` and `rt`. Add merged interval `[lt[0], rt[1]]`.\\n        Ex: `lt = [2, 5], value = 6, rt = [7, 9]` `=>` `..[2, 9]..`\\n\\n    3. `lt[1] + 1 == value` and `value != rt[0] - 1`:\\n        The `value` can be merged with `lt`.\\n        Remove `lt`. Add merged interval `[lt[0], value]`.\\n        Ex: `lt = [2, 5], value = 6, rt = [8, 9]` `=>` `..[2, 6],[8, 9]..`\\n\\n    4. `lt[1] + 1 != value` and `value == rt[0] - 1`:\\n        The `value` can be merged with `rt`.\\n        Remove `rt`. Add merged interval `[value, rt[1]]`.\\n        Ex: `lt = [2, 4], value = 6, rt = [7, 9]` `=>` `..[2, 4],[6, 9]..`\\n\\n    5. `lt[1] + 1 != value` and `value != rt[0] - 1`:\\n        The `value` can\\'t be merged.\\n        Add standalone interval `[value, value]`.\\n        Ex: `lt = [2, 4], value = 6, rt = [8, 9]` `=>` `..[2, 4],[6, 6],[8, 9]..`\\n\\n6. Note: Below `code` compresses all the above cases into few conditions. But it\\'s essentially doing the same.\\n\\n# Complexity\\n- Time complexity:\\n    `addNum`: $$O(log(n))$$\\n    `getIntervals`: $$(1)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere, `n is min(number of intervals, number of values)`\\n\\n# Code\\n```python\\nfrom sortedcontainers import SortedList\\n\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.intervals = SortedList()\\n\\n    def addNum(self, value: int) -> None:\\n        n = len(self.intervals)\\n        i = self.intervals.bisect((value, math.inf))\\n        \\n        lt = self.intervals[i - 1] if 0 <= i - 1 < n else (-inf, -inf)\\n        rt = self.intervals[i    ] if 0 <= i     < n else ( inf,  inf)\\n        \\n        if lt[0] <= value <= lt[1]: return\\n\\n        a, b = value, value\\n        if lt[1] + 1 == value: self.intervals.remove(lt); a = lt[0]\\n        if value == rt[0] - 1: self.intervals.remove(rt); b = rt[1]\\n\\n        self.intervals.add((a, b))\\n\\n    def getIntervals(self) -> list[list[int]]:\\n        return self.intervals\\n\\n\\n# Your SummaryRanges object will be instantiated and called as such:\\n# obj = SummaryRanges()\\n# obj.addNum(value)\\n# param_2 = obj.getIntervals()\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Design",
                    "Ordered Set"
                ],
                "code": "```python\\nfrom sortedcontainers import SortedList\\n\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.intervals = SortedList()\\n\\n    def addNum(self, value: int) -> None:\\n        n = len(self.intervals)\\n        i = self.intervals.bisect((value, math.inf))\\n        \\n        lt = self.intervals[i - 1] if 0 <= i - 1 < n else (-inf, -inf)\\n        rt = self.intervals[i    ] if 0 <= i     < n else ( inf,  inf)\\n        \\n        if lt[0] <= value <= lt[1]: return\\n\\n        a, b = value, value\\n        if lt[1] + 1 == value: self.intervals.remove(lt); a = lt[0]\\n        if value == rt[0] - 1: self.intervals.remove(rt); b = rt[1]\\n\\n        self.intervals.add((a, b))\\n\\n    def getIntervals(self) -> list[list[int]]:\\n        return self.intervals\\n\\n\\n# Your SummaryRanges object will be instantiated and called as such:\\n# obj = SummaryRanges()\\n# obj.addNum(value)\\n# param_2 = obj.getIntervals()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108132,
                "title": "c-using-set-very-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nVery Simple idea we have to push the elements in a data structure and when we try to get interval from that we have to check whether the intervals should be disjoint . So to do this we have to first get all the elments pushed in the data structure as sorted then we can check if some intrvals are overlapping or not but to sort our elements again and again will give time complexity if stored in vector or array. So we should use an effiecint data structure like set or map which will keep sorted elements in $$logn$$ while they are being pushed and after that we can easly check those intervals who are overlapping and only push the disjoint intervals in our answer vector.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo use a set or a map . Push the elements in that .\\nIn getInterval function we should check if elments pushed in the set or having differnce `1` i.e they are not dis-joint we should keep track of `start` and `last` and push them when differnce is `not 1` . In this way only disjoint intervals will get inserted in ans vector.\\n# Complexity\\n- Time complexity:$$O(N)$$  -->` getIntervals()`\\n- $$O(log(N))$$ --> `addNum()`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$ for storing values in `set`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SummaryRanges {\\n \\n \\npublic:\\n    set<int>st;\\n    SummaryRanges() {}\\n    void addNum(int value) { st.insert(value); }\\n    vector<vector<int>> getIntervals() {\\n        if (st.empty()) {\\n            return {};\\n        }\\n        vector<vector<int>> ans;\\n        int start = -1, last = -1;\\n        for (int val : st) {\\n            if (start < 0) {\\n                start = last = val;\\n            } else if (val-last==1) {\\n                last = val;\\n            } else {\\n                ans.push_back({start, last});\\n                start = last = val;\\n            }\\n        }\\n        ans.push_back({start, last});\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass SummaryRanges {\\n \\n \\npublic:\\n    set<int>st;\\n    SummaryRanges() {}\\n    void addNum(int value) { st.insert(value); }\\n    vector<vector<int>> getIntervals() {\\n        if (st.empty()) {\\n            return {};\\n        }\\n        vector<vector<int>> ans;\\n        int start = -1, last = -1;\\n        for (int val : st) {\\n            if (start < 0) {\\n                start = last = val;\\n            } else if (val-last==1) {\\n                last = val;\\n            } else {\\n                ans.push_back({start, last});\\n                start = last = val;\\n            }\\n        }\\n        ans.push_back({start, last});\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107431,
                "title": "js-fast-solution-easy-array",
                "content": "# Intuition\\nConstraints:\\n0 <= value <= 10^4\\n\\nThis approach works great when all input are positive integers.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass SummaryRanges {\\n  constructor() {\\n    this.list = [];\\n  }\\n  addNum(num) {\\n    this.list[num] = true;\\n  }\\n  getIntervals() {\\n    const res = [];\\n    for (let i = 0; i < this.list.length; i++) {\\n      if (this.list[i]) {\\n        let j = i;\\n        while (this.list[j]) j++;\\n        res.push([i, j - 1]);\\n        i = j;\\n      }\\n    }\\n    return res;\\n  }\\n}\\n```\\n\\n![1.jpg](https://assets.leetcode.com/users/images/09f4de79-52be-4475-b883-97a156bf38b2_1674874667.9731266.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass SummaryRanges {\\n  constructor() {\\n    this.list = [];\\n  }\\n  addNum(num) {\\n    this.list[num] = true;\\n  }\\n  getIntervals() {\\n    const res = [];\\n    for (let i = 0; i < this.list.length; i++) {\\n      if (this.list[i]) {\\n        let j = i;\\n        while (this.list[j]) j++;\\n        res.push([i, j - 1]);\\n        i = j;\\n      }\\n    }\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107429,
                "title": "python3-binary-search-and-merge-or-insert",
                "content": "Consider ranges as a array maintained sorted. [(r1, r2), (r3,r4) .... ] => r1 < r2 < r3 < r4 ....\\nThe above should also hold good after inserting a certain value.\\n\\nThe following are the cases to consider to insert a value into the range. The value ... \\n1. is inside the current ranges ( can be eliminated during binary search of ranges )\\n2. is connection point between two ranges\\n3. extends an existing range\\'s end\\n4. extends an existing range\\'s start\\n5. Starts a new range at start, end or elsewhere.\\n\\nEx: 1 ranges = [1,4], [5,7], value = 6; => [1,4], [5,7]\\nEx: 2 ranges = [1,2], [4,5], value = 3; => [1,5]\\nEx: 3 ranges = [1,2], [6,7], value = 3; => [1,3], [6,7]\\nEx: 4 ranges = [1,2], [6,7], value = 5; => [1,2], [5,7]\\nEx: 5 ranges = [1,2], [6,7], value = 4; => [1,2], [4,4], [6,7]\\n\\n```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.ranges = []\\n\\n    def addNum(self, value: int) -> None:    \\n        start, end, idx = 0, len(self.ranges), 0 \\n        \\n        # binary search the index where the value would end up if independent range.\\n        \\n        while start < end: \\n            pivot = (start+end)//2\\n            s,e = self.ranges[pivot]\\n            if value >= s and value <= e:\\n                return \\n            elif value > e:\\n                idx = start = pivot + 1\\n            elif value < s:\\n                idx = end = pivot\\n        \\n        if idx == len(self.ranges):\\n            \\n\\t\\t\\t# The value goes at the end, either merge with end range or open new one.\\n            \\n\\t\\t\\tif len(self.ranges) and self.ranges[-1][1] + 1 == value: \\n                self.ranges[-1][1] = value\\n            else: \\n                self.ranges.append([value, value])\\n        elif idx >= 0:\\n            if self.ranges[idx][0]-1 == value:\\n                \\n                # Merge value into the range at idx and check if we need to merge the range before. \\n                # Its a connection.\\n                \\n                self.ranges[idx][0] = value\\n                if idx and self.ranges[idx-1][1] + 1 == self.ranges[idx][0]:\\n                    self.ranges[idx-1][1] = self.ranges[idx][1]\\n                    \\n                    # Delete range at idx if we merged the range with prev one.\\n                    \\n                    del self.ranges[idx]\\n            elif idx and self.ranges[idx-1][1]+1 == value: \\n                \\n\\t\\t\\t\\t# value merges with the range before.\\n                \\n                self.ranges[idx-1][1] = value  \\n            else:\\n                # open new range in middle.\\n                \\n                self.ranges.insert(idx, [value, value])\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        return self.ranges\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "Consider ranges as a array maintained sorted. [(r1, r2), (r3,r4) .... ] => r1 < r2 < r3 < r4 ....\\nThe above should also hold good after inserting a certain value.\\n\\nThe following are the cases to consider to insert a value into the range. The value ... \\n1. is inside the current ranges ( can be eliminated during binary search of ranges )\\n2. is connection point between two ranges\\n3. extends an existing range\\'s end\\n4. extends an existing range\\'s start\\n5. Starts a new range at start, end or elsewhere.\\n\\nEx: 1 ranges = [1,4], [5,7], value = 6; => [1,4], [5,7]\\nEx: 2 ranges = [1,2], [4,5], value = 3; => [1,5]\\nEx: 3 ranges = [1,2], [6,7], value = 3; => [1,3], [6,7]\\nEx: 4 ranges = [1,2], [6,7], value = 5; => [1,2], [5,7]\\nEx: 5 ranges = [1,2], [6,7], value = 4; => [1,2], [4,4], [6,7]\\n\\n```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.ranges = []\\n\\n    def addNum(self, value: int) -> None:    \\n        start, end, idx = 0, len(self.ranges), 0 \\n        \\n        # binary search the index where the value would end up if independent range.\\n        \\n        while start < end: \\n            pivot = (start+end)//2\\n            s,e = self.ranges[pivot]\\n            if value >= s and value <= e:\\n                return \\n            elif value > e:\\n                idx = start = pivot + 1\\n            elif value < s:\\n                idx = end = pivot\\n        \\n        if idx == len(self.ranges):\\n            \\n\\t\\t\\t# The value goes at the end, either merge with end range or open new one.\\n            \\n\\t\\t\\tif len(self.ranges) and self.ranges[-1][1] + 1 == value: \\n                self.ranges[-1][1] = value\\n            else: \\n                self.ranges.append([value, value])\\n        elif idx >= 0:\\n            if self.ranges[idx][0]-1 == value:\\n                \\n                # Merge value into the range at idx and check if we need to merge the range before. \\n                # Its a connection.\\n                \\n                self.ranges[idx][0] = value\\n                if idx and self.ranges[idx-1][1] + 1 == self.ranges[idx][0]:\\n                    self.ranges[idx-1][1] = self.ranges[idx][1]\\n                    \\n                    # Delete range at idx if we merged the range with prev one.\\n                    \\n                    del self.ranges[idx]\\n            elif idx and self.ranges[idx-1][1]+1 == value: \\n                \\n\\t\\t\\t\\t# value merges with the range before.\\n                \\n                self.ranges[idx-1][1] = value  \\n            else:\\n                # open new range in middle.\\n                \\n                self.ranges.insert(idx, [value, value])\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        return self.ranges\\n",
                "codeTag": "Java"
            },
            {
                "id": 3107772,
                "title": "clean-concise-solution-using-set",
                "content": "# Intuition\\ni thought of using a ordered set as in it element are in sorted form. \\n\\n# Approach\\ni first stored the first value of set in the variable initial and then i checked if the next consecutive element i.e initial+1 is present in the set or not. If it is present in the set than again check the same thing for initial+1. if the next consecutive element is not present in the set than we can push_back intial & current element in set and after that update value of initial to next element in the set.  \\n\\n# Complexity\\n- Time complexity:\\n $$O(NlogN)$$\\nas we are traversing in whole set once and log(N) is time required for count operation.N is number of elements in the set.\\n\\n- Space complexity:\\n $$O(N)$$ \\na set of size N is used where N is number of elements in the set\\n\\n# Code\\n```\\nclass SummaryRanges {\\npublic:\\n    set<int> s;\\n    SummaryRanges() {\\n    }\\n    \\n    void addNum(int value) {\\n        s.insert(value);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>>v;\\n        set<int>::iterator itr=s.begin();\\n        int initial=*itr;\\n        for (itr = s.begin();itr != s.end(); itr++){\\n            if(s.count(*itr+1)){\\n                continue;\\n            }\\n            v.push_back({initial,*itr});\\n            ++itr;\\n            initial=*itr;\\n            --itr;\\n        }\\n        return v;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass SummaryRanges {\\npublic:\\n    set<int> s;\\n    SummaryRanges() {\\n    }\\n    \\n    void addNum(int value) {\\n        s.insert(value);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>>v;\\n        set<int>::iterator itr=s.begin();\\n        int initial=*itr;\\n        for (itr = s.begin();itr != s.end(); itr++){\\n            if(s.count(*itr+1)){\\n                continue;\\n            }\\n            v.push_back({initial,*itr});\\n            ++itr;\\n            initial=*itr;\\n            --itr;\\n        }\\n        return v;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107479,
                "title": "100-javascript-fast-very-very-easy-to-understand-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/PXWk2BgpDpE\\n\\n![image.png](https://assets.leetcode.com/users/images/53d94216-2383-46ee-b6f0-942a763293be_1674876609.145929.png)\\n# Code\\n```\\nvar SummaryRanges = function() {\\n    this.arr = []\\n};\\n\\n/** \\n * @param {number} value\\n * @return {void}\\n */\\nSummaryRanges.prototype.addNum = function(val) {\\n    let valIsInside = false;\\n    for(let i =0; i<this.arr.length;i++){\\n        let [x,y] = this.arr[i];\\n        if(val >=x && val<=y){\\n            valIsInside = true;\\n            break;\\n        }\\n        else if(val === y + 1){\\n            this.arr[i][1] = val;\\n            if(val + 1 === this.arr[i+1]?.[0]){\\n                this.arr[i][1] = this.arr[i+1][1]\\n                this.arr.splice(i+1,1)\\n            }\\n            valIsInside = true;\\n            break;\\n        }\\n        else if(val < x){\\n            if(val + 1 == x){\\n                this.arr[i][0] = val;\\n            }\\n            else this.arr.splice(i,0,[val,val])\\n            valIsInside = true;\\n            break;\\n        }\\n    }\\n    if(!valIsInside) this.arr.push([val,val])\\n};\\n\\n/**\\n * @return {number[][]}\\n */\\nSummaryRanges.prototype.getIntervals = function() {\\n    return this.arr\\n};\\n\\n/** \\n * Your SummaryRanges object will be instantiated and called as such:\\n * var obj = new SummaryRanges()\\n * obj.addNum(value)\\n * var param_2 = obj.getIntervals()\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar SummaryRanges = function() {\\n    this.arr = []\\n};\\n\\n/** \\n * @param {number} value\\n * @return {void}\\n */\\nSummaryRanges.prototype.addNum = function(val) {\\n    let valIsInside = false;\\n    for(let i =0; i<this.arr.length;i++){\\n        let [x,y] = this.arr[i];\\n        if(val >=x && val<=y){\\n            valIsInside = true;\\n            break;\\n        }\\n        else if(val === y + 1){\\n            this.arr[i][1] = val;\\n            if(val + 1 === this.arr[i+1]?.[0]){\\n                this.arr[i][1] = this.arr[i+1][1]\\n                this.arr.splice(i+1,1)\\n            }\\n            valIsInside = true;\\n            break;\\n        }\\n        else if(val < x){\\n            if(val + 1 == x){\\n                this.arr[i][0] = val;\\n            }\\n            else this.arr.splice(i,0,[val,val])\\n            valIsInside = true;\\n            break;\\n        }\\n    }\\n    if(!valIsInside) this.arr.push([val,val])\\n};\\n\\n/**\\n * @return {number[][]}\\n */\\nSummaryRanges.prototype.getIntervals = function() {\\n    return this.arr\\n};\\n\\n/** \\n * Your SummaryRanges object will be instantiated and called as such:\\n * var obj = new SummaryRanges()\\n * obj.addNum(value)\\n * var param_2 = obj.getIntervals()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 314970,
                "title": "c-concise-solution",
                "content": "This can be optimised a little bit by turning the for loop into binary search, but it does not save much time. Not worth it, as it makes code harder to read.  \\n```cpp\\nclass SummaryRanges {\\npublic:\\n    SummaryRanges() {}\\n    \\n    void addNum(int val) {\\n        vector<int> merge {val, val};\\n        for (auto it = intervals.begin(); it != intervals.end(); ) {\\n            if (it->front() - 1 > merge.back() || it->back() + 1 < merge.front())\\n                it++;\\n            else {\\n                merge.front() = min(merge.front(), it->front());\\n                merge.back() = max(merge.back(), it->back());\\n                it = intervals.erase(it);\\n            }\\n        }\\n        intervals.insert(merge);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        return vector<vector<int>>(intervals.begin(), intervals.end());\\n    }\\nprivate:\\n    set<vector<int>> intervals;\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass SummaryRanges {\\npublic:\\n    SummaryRanges() {}\\n    \\n    void addNum(int val) {\\n        vector<int> merge {val, val};\\n        for (auto it = intervals.begin(); it != intervals.end(); ) {\\n            if (it->front() - 1 > merge.back() || it->back() + 1 < merge.front())\\n                it++;\\n            else {\\n                merge.front() = min(merge.front(), it->front());\\n                merge.back() = max(merge.back(), it->back());\\n                it = intervals.erase(it);\\n            }\\n        }\\n        intervals.insert(merge);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        return vector<vector<int>>(intervals.begin(), intervals.end());\\n    }\\nprivate:\\n    set<vector<int>> intervals;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279760,
                "title": "java-solution-84ms-use-treemap-extremely-simple",
                "content": "```java\\nclass SummaryRanges {\\n    \\n    Map<Integer, Interval> smap;\\n    Map<Integer, Interval> emap;\\n    Set<Integer> added;\\n\\n    public SummaryRanges() {\\n        smap = new TreeMap<>();\\n        emap = new TreeMap<>();\\n        added = new HashSet<>();\\n    }\\n    \\n    public void addNum(int val) {\\n        \\n        if(added.contains(val)) return;\\n        added.add(val);\\n        \\n        Interval s = smap.get(val+1);\\n        Interval e = emap.get(val-1);\\n        \\n        smap.remove(val+1);\\n        emap.remove(val-1);\\n \\n        Interval n = new Interval(e!=null?e.start:val, s!=null?s.end:val);\\n        smap.put(n.start, n);\\n        emap.put(n.end, n);\\n    }\\n    \\n    public List<Interval> getIntervals() {\\n        return new ArrayList<>(smap.values());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass SummaryRanges {\\n    \\n    Map<Integer, Interval> smap;\\n    Map<Integer, Interval> emap;\\n    Set<Integer> added;\\n\\n    public SummaryRanges() {\\n        smap = new TreeMap<>();\\n        emap = new TreeMap<>();\\n        added = new HashSet<>();\\n    }\\n    \\n    public void addNum(int val) {\\n        \\n        if(added.contains(val)) return;\\n        added.add(val);\\n        \\n        Interval s = smap.get(val+1);\\n        Interval e = emap.get(val-1);\\n        \\n        smap.remove(val+1);\\n        emap.remove(val-1);\\n \\n        Interval n = new Interval(e!=null?e.start:val, s!=null?s.end:val);\\n        smap.put(n.start, n);\\n        emap.put(n.end, n);\\n    }\\n    \\n    public List<Interval> getIntervals() {\\n        return new ArrayList<>(smap.values());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238369,
                "title": "python-3-4-lines-sets-zip-t-m-100-100",
                "content": "```\\nclass SummaryRanges:\\n    def __init__(self):\\n        self.stack = deque()\\n        \\n    def dfs(self, nums):\\n        return list(zip(sorted(set([n for n in nums if n-1 not in nums])),\\n                        sorted(set([n for n in nums if n+1 not in nums]))))\\n\\n    def addNum(self, val):\\n        self.stack.append(val)\\n\\n    def getIntervals(self):\\n        return self.dfs(self.stack)\\n```\\n[https://leetcode.com/problems/data-stream-as-disjoint-intervals/submissions/906232980/](http://)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SummaryRanges:\\n    def __init__(self):\\n        self.stack = deque()\\n        \\n    def dfs(self, nums):\\n        return list(zip(sorted(set([n for n in nums if n-1 not in nums])),\\n                        sorted(set([n for n in nums if n+1 not in nums]))))\\n\\n    def addNum(self, val):\\n        self.stack.append(val)\\n\\n    def getIntervals(self):\\n        return self.dfs(self.stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109566,
                "title": "java-easy-to-understand-solution",
                "content": "# Code\\n```\\nclass SummaryRanges {\\n    private Map<Integer,Integer> intervals;\\n\\n    public SummaryRanges() {\\n        /*I used tree maps because they are always sorted by key value*/\\n        intervals = new TreeMap<>();\\n    }\\n\\n    public void addNum(int value) {\\n        //If our map is empty just add that single interval\\n        if(intervals.isEmpty()){\\n            intervals.put(value,value);\\n            return;\\n        }\\n        //Call our main function\\n        validate(value);\\n    }\\n\\n    private void validate(int k){\\n        //Iterate over our map\\n        for (Map.Entry<Integer,Integer> entry : intervals.entrySet()) {\\n            Integer value = entry.getValue();\\n            Integer key = entry.getKey();\\n            /*If current value is between range of an already \\n            exisiting interval just return*/\\n            if(key<=k && k<=value){\\n                return;\\n            }\\n            /*Example: If our k is 3 and an interval is 4-6 then we add 3-6\\n            as a new interval and remove the old interval*/\\n            if(k+1 == key){\\n                intervals.put(k,value);\\n                intervals.remove(key);\\n                return;\\n            }\\n            //Example: 1-2 4-5 and k is equal to 3 the first \\n            //condition k-1==2 is true so the current map is 1-3 4-5, we then check\\n            //if the map contains k+1 which is 4, then we merge and the new map is 1-5\\n            if(k-1 == value){\\n                intervals.put(key,k);\\n                if(intervals.containsKey(k+1)){\\n                    intervals.put(key,intervals.get(k+1));\\n                    intervals.remove(k+1);\\n                }\\n                return;\\n            }\\n\\n\\n        }\\n        //If all the above conidtions fail, that means k is a new interval\\n\\n        intervals.put(k, k);\\n    }\\n\\n    public int[][] getIntervals() {\\n        if(intervals.size()==0){\\n            return new int[0][0];\\n        }\\n\\n        int[][] res = new int[intervals.size()][2];\\n        int index=0;\\n        for (Map.Entry<Integer,Integer> entry : intervals.entrySet()) {\\n            Integer value = entry.getValue();\\n            Integer key = entry.getKey();\\n            res[index][0]=key;\\n            res[index][1]=value;\\n            index++;\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SummaryRanges {\\n    private Map<Integer,Integer> intervals;\\n\\n    public SummaryRanges() {\\n        /*I used tree maps because they are always sorted by key value*/\\n        intervals = new TreeMap<>();\\n    }\\n\\n    public void addNum(int value) {\\n        //If our map is empty just add that single interval\\n        if(intervals.isEmpty()){\\n            intervals.put(value,value);\\n            return;\\n        }\\n        //Call our main function\\n        validate(value);\\n    }\\n\\n    private void validate(int k){\\n        //Iterate over our map\\n        for (Map.Entry<Integer,Integer> entry : intervals.entrySet()) {\\n            Integer value = entry.getValue();\\n            Integer key = entry.getKey();\\n            /*If current value is between range of an already \\n            exisiting interval just return*/\\n            if(key<=k && k<=value){\\n                return;\\n            }\\n            /*Example: If our k is 3 and an interval is 4-6 then we add 3-6\\n            as a new interval and remove the old interval*/\\n            if(k+1 == key){\\n                intervals.put(k,value);\\n                intervals.remove(key);\\n                return;\\n            }\\n            //Example: 1-2 4-5 and k is equal to 3 the first \\n            //condition k-1==2 is true so the current map is 1-3 4-5, we then check\\n            //if the map contains k+1 which is 4, then we merge and the new map is 1-5\\n            if(k-1 == value){\\n                intervals.put(key,k);\\n                if(intervals.containsKey(k+1)){\\n                    intervals.put(key,intervals.get(k+1));\\n                    intervals.remove(k+1);\\n                }\\n                return;\\n            }\\n\\n\\n        }\\n        //If all the above conidtions fail, that means k is a new interval\\n\\n        intervals.put(k, k);\\n    }\\n\\n    public int[][] getIntervals() {\\n        if(intervals.size()==0){\\n            return new int[0][0];\\n        }\\n\\n        int[][] res = new int[intervals.size()][2];\\n        int index=0;\\n        for (Map.Entry<Integer,Integer> entry : intervals.entrySet()) {\\n            Integer value = entry.getValue();\\n            Integer key = entry.getKey();\\n            res[index][0]=key;\\n            res[index][1]=value;\\n            index++;\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109384,
                "title": "c-std-map-always-insert",
                "content": "# Approach 1: always insert into a std::map\\nThe high level idea is the use a ```std::map``` to keep track of the intervals in sorted order. The key into the map is the left boundary of the interval and the value is the right boundary of the interval. Instead of scanning the exisiting elements in the map for the insert position the following approach always inserts the new interval and merges it with the previous or the next as needed. ```std::map::insert``` returns as an iterator and going from there to the previous and next element is cheap.\\n\\n```cpp\\nclass SummaryRanges {\\nprivate:\\n    map<int, int> m_;\\n\\npublic:\\n    SummaryRanges() = default;\\n    \\n    void addNum(int val) {\\n        auto [it, inserted]  = m_.insert({val, val});\\n        if (!inserted) return;\\n        \\n        // Merge with previous.\\n        if (it != begin(m_)) {\\n            auto p = prev(it);\\n            if (p->second + 1 >= it->first) {\\n                p->second = max(it->first, p->second);\\n                m_.erase(it);\\n                it = p;                \\n            }\\n        }\\n        \\n        // Merge with next.\\n        if (it != end(m_)) {\\n            auto n = next(it);\\n            if (it->second + 1 == n->first) {\\n                it->second = n->second;\\n                m_.erase(n);\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> getIntervals() const {\\n        vector<vector<int>> ans;\\n        ans.reserve(size(m_));\\n        for (auto [l, r] : m_) ans.push_back({l, r});\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n**Complexity Analysis**\\nLet $$n$$ be the number of calls to ```addNum``` then:\\n  * Time complexity is $$O(n \\\\log n)$$ for all the ```addNum``` calls and each call to ```getIntervals``` is $$O(n)$$ in the worst case. The\\n  * Space complexity is $$O(n)$$ as we need to keep track of up to $$n$$ distjoint intervals.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```std::map```\n```std::map::insert```\n```cpp\\nclass SummaryRanges {\\nprivate:\\n    map<int, int> m_;\\n\\npublic:\\n    SummaryRanges() = default;\\n    \\n    void addNum(int val) {\\n        auto [it, inserted]  = m_.insert({val, val});\\n        if (!inserted) return;\\n        \\n        // Merge with previous.\\n        if (it != begin(m_)) {\\n            auto p = prev(it);\\n            if (p->second + 1 >= it->first) {\\n                p->second = max(it->first, p->second);\\n                m_.erase(it);\\n                it = p;                \\n            }\\n        }\\n        \\n        // Merge with next.\\n        if (it != end(m_)) {\\n            auto n = next(it);\\n            if (it->second + 1 == n->first) {\\n                it->second = n->second;\\n                m_.erase(n);\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> getIntervals() const {\\n        vector<vector<int>> ans;\\n        ans.reserve(size(m_));\\n        for (auto [l, r] : m_) ans.push_back({l, r});\\n        return ans;\\n    }\\n};\\n```\n```addNum```\n```addNum```\n```getIntervals```",
                "codeTag": "Java"
            },
            {
                "id": 3108400,
                "title": "java-2-solutions-explained",
                "content": "---\\n# Please Upvote \\uD83D\\uDE07\\n---\\n``` java []\\nclass SummaryRanges {\\n    // We will use a treeset data structure \\n    // it will keep our numbers in sorted order\\n    private TreeSet<Integer> set;\\n    public SummaryRanges() {\\n        set = new TreeSet<>();  // initialise the treeset\\n    }\\n    \\n    public void addNum(int value) {\\n        set.add(value); // add the value to treeset\\n    }\\n    \\n    public int[][] getIntervals() {\\n        // initialise an arraylist to store the intervals\\n        List<int[]> intervals = new ArrayList<>();\\n        // initialise the start and end values with the \\n        // first element that is present in the set\\n        int start = set.first();\\n        int end = set.first();\\n\\n        // we will iterate on the set, if its at number adjacent to \\'end\\'\\n        // we will update \\'end\\' until we encounter a disjoint number\\n        for (int v : set) {\\n            // simply skip the first element because\\n            // we ned to check from second element\\n            if (v == start) {   \\n                continue;       \\n            } \\n            // if the number is +1 the \\'end\\' (adjacent), we will update \\'end\\'\\n            // say \\'end\\' is 6, we encounter 7, so 6 & 7 are consecutive/adjacent\\n            // so \\'end\\' is updated to 7\\n            else if (v == end + 1) {\\n                end = v;\\n            } \\n            // when we find a disjoint case, say \\'end\\' is 7 and we encounter 9\\n            // they are disjoint, so we push the interval obtained so far\\n            else {\\n                intervals.add(new int[] {start, end});  // pushing the interval\\n                start = end = v;    // we will start afresh from 9\\n            }\\n        }\\n\\n        // at the end we will be left with an interval,\\n        // because we finished iterating on the treeset\\n        // so we will push that interval to the list\\n        intervals.add(new int[] {start, end});\\n        // return the list as a 2D array of intervals\\n        return intervals.toArray(new int[0][]);\\n    }\\n}\\n```\\n--- \\n### Clean solution:\\n``` java []\\nclass SummaryRanges {\\n    private TreeSet<Integer> set;\\n    public SummaryRanges() {\\n        set = new TreeSet<>();  \\n    }\\n    \\n    public void addNum(int value) {\\n        set.add(value); \\n    }\\n    \\n    public int[][] getIntervals() {\\n        List<int[]> intervals = new ArrayList<>();\\n        int start = set.first();\\n        int end = set.first();\\n\\n        for (int v : set) {\\n            if (v == start) {   \\n                continue;       \\n            } else if (v == end + 1) {\\n                end = v;\\n            } else {\\n                intervals.add(new int[] {start, end});  \\n                start = end = v;    \\n            }\\n        }\\n\\n        intervals.add(new int[] {start, end});\\n        return intervals.toArray(new int[0][]);\\n    }\\n}\\n```\\n--- \\nLet $$n$$ be the total calls to `addNum()` i.e. the number of elements and $$k$$ be the number of calls to `getIntervals()`.\\n### Time complexity: $$O(n * logn) + O(k * n)$$\\n- Our treeset will sort the numbers $$n$$ times in $$O(logn)$$ complexity.\\n- We iterate over the whole treeset when `getIntervals()` is called $$k$$ times which will cost an $$O(n)$$ complexity at each call.\\n### Space complexity: $$O(n)$$ \\nOur treeset stores $$n$$ elements.\\n\\n---\\n---\\n### *Another way we can go for is by using an array instead of a treeset.*\\nWe will take a boolean array long enough to be able to accomodate all our elements passed in `addNums()`. Whenever we add an element, we will put a `true` at its index which would signify the presence of the element in our set. The sorting part will be omitted, because indices are obviously sorted.\\n``` java []\\nclass SummaryRanges {\\n    private boolean[] set;\\n    public SummaryRanges() {\\n        set = new boolean[10000 + 5];\\n    }\\n\\n    public void addNum(int value) {\\n        set[value] = true;  // mark the presence\\n    }\\n\\n    public int[][] getIntervals() {\\n        List<int[]> intervals = new ArrayList<>();\\n        for (int i = 0; i < set.length; i++) {\\n            if (!set[i]) {  // reach to the starting number\\n                continue;\\n            }\\n\\n            int start = i;  // record the starting number\\n            // keep iterating till we have conecutive elements\\n            while (i < set.length && set[i]) i++;\\n            // the loop will break when i will exceed the last consecutive number\\n            int end = i - 1;    // so end is 1 less than i\\n            intervals.add(new int[] {start, end});  // add the interval\\n        }\\n\\n        // return the list as a 2D array of intervals\\n        return intervals.toArray(new int[0][]);\\n    }\\n}\\n```\\n--- \\n### Time complexity: $$O(k * 10^4)$$\\nWe are not sorting our array. We just iterate over the array every time `getIntervals()` is called, lets say $$k$$ times. \\n### Space complexity: $$O(10^4) => O(1)$$\\nWe are using an array of fixed size.\\n\\n---\\n\\n*This approach is same as the solution to the problem **[705. Design HashSet](https://leetcode.com/problems/design-hashset/description/)***",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Design",
                    "Ordered Set"
                ],
                "code": "``` java []\\nclass SummaryRanges {\\n    // We will use a treeset data structure \\n    // it will keep our numbers in sorted order\\n    private TreeSet<Integer> set;\\n    public SummaryRanges() {\\n        set = new TreeSet<>();  // initialise the treeset\\n    }\\n    \\n    public void addNum(int value) {\\n        set.add(value); // add the value to treeset\\n    }\\n    \\n    public int[][] getIntervals() {\\n        // initialise an arraylist to store the intervals\\n        List<int[]> intervals = new ArrayList<>();\\n        // initialise the start and end values with the \\n        // first element that is present in the set\\n        int start = set.first();\\n        int end = set.first();\\n\\n        // we will iterate on the set, if its at number adjacent to \\'end\\'\\n        // we will update \\'end\\' until we encounter a disjoint number\\n        for (int v : set) {\\n            // simply skip the first element because\\n            // we ned to check from second element\\n            if (v == start) {   \\n                continue;       \\n            } \\n            // if the number is +1 the \\'end\\' (adjacent), we will update \\'end\\'\\n            // say \\'end\\' is 6, we encounter 7, so 6 & 7 are consecutive/adjacent\\n            // so \\'end\\' is updated to 7\\n            else if (v == end + 1) {\\n                end = v;\\n            } \\n            // when we find a disjoint case, say \\'end\\' is 7 and we encounter 9\\n            // they are disjoint, so we push the interval obtained so far\\n            else {\\n                intervals.add(new int[] {start, end});  // pushing the interval\\n                start = end = v;    // we will start afresh from 9\\n            }\\n        }\\n\\n        // at the end we will be left with an interval,\\n        // because we finished iterating on the treeset\\n        // so we will push that interval to the list\\n        intervals.add(new int[] {start, end});\\n        // return the list as a 2D array of intervals\\n        return intervals.toArray(new int[0][]);\\n    }\\n}\\n```\n``` java []\\nclass SummaryRanges {\\n    private TreeSet<Integer> set;\\n    public SummaryRanges() {\\n        set = new TreeSet<>();  \\n    }\\n    \\n    public void addNum(int value) {\\n        set.add(value); \\n    }\\n    \\n    public int[][] getIntervals() {\\n        List<int[]> intervals = new ArrayList<>();\\n        int start = set.first();\\n        int end = set.first();\\n\\n        for (int v : set) {\\n            if (v == start) {   \\n                continue;       \\n            } else if (v == end + 1) {\\n                end = v;\\n            } else {\\n                intervals.add(new int[] {start, end});  \\n                start = end = v;    \\n            }\\n        }\\n\\n        intervals.add(new int[] {start, end});\\n        return intervals.toArray(new int[0][]);\\n    }\\n}\\n```\n``` java []\\nclass SummaryRanges {\\n    private boolean[] set;\\n    public SummaryRanges() {\\n        set = new boolean[10000 + 5];\\n    }\\n\\n    public void addNum(int value) {\\n        set[value] = true;  // mark the presence\\n    }\\n\\n    public int[][] getIntervals() {\\n        List<int[]> intervals = new ArrayList<>();\\n        for (int i = 0; i < set.length; i++) {\\n            if (!set[i]) {  // reach to the starting number\\n                continue;\\n            }\\n\\n            int start = i;  // record the starting number\\n            // keep iterating till we have conecutive elements\\n            while (i < set.length && set[i]) i++;\\n            // the loop will break when i will exceed the last consecutive number\\n            int end = i - 1;    // so end is 1 less than i\\n            intervals.add(new int[] {start, end});  // add the interval\\n        }\\n\\n        // return the list as a 2D array of intervals\\n        return intervals.toArray(new int[0][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107550,
                "title": "80-fast-c-solution",
                "content": "# Solution Code:\\n``` C++ []\\nclass SummaryRanges {\\n public:\\n  void addNum(int val) {\\n    if (map.count(val))\\n      return;\\n\\n    const int lo = lowerKey(val);\\n    const int hi = higherKey(val);\\n\\n    // {lo, map[lo][1]} + val + {hi, map[hi][1]} = {lo, map[hi][1]}\\n    if (lo >= 0 && hi >= 0 && map[lo][1] + 1 == val && val + 1 == hi) {\\n      map[lo][1] = map[hi][1];\\n      map.erase(hi);\\n      // {lo, map[lo][1]} + val = {lo, val}\\n      // (prevent adding duplicate entry by using \\'>=\\' instead of \\'==\\')\\n    } else if (lo >= 0 && map[lo][1] + 1 >= val) {\\n      map[lo][1] = max(map[lo][1], val);\\n    } else if (hi >= 0 && val + 1 == hi) {\\n      // Val + {hi, map[hi][1]} = {val, map[hi][1]}\\n      map[val] = {val, map[hi][1]};\\n      map.erase(hi);\\n    } else {\\n      map[val] = {val, val};\\n    }\\n  }\\n\\n  vector<vector<int>> getIntervals() {\\n    vector<vector<int>> intervals;\\n    for (const auto& [_, interval] : map)\\n      intervals.push_back(interval);\\n    return intervals;\\n  }\\n\\n private:\\n  map<int, vector<int>> map;  // {start: {start, end}}\\n\\n  // Maximum in map < key\\n  int lowerKey(int key) {\\n    auto it = map.lower_bound(key);  // Minimum in map >= key\\n    if (it == begin(map))\\n      return -1;\\n    return (--it)->first;\\n  }\\n\\n  // Minimum in map > key\\n  int higherKey(int key) {\\n    const auto it = map.upper_bound(key);  // Minimum in map > key\\n    if (it == cend(map))\\n      return -1;\\n    return it->first;\\n  }\\n};\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/bf1ff7a0-c747-4ae5-b942-a3a3fba2d0f2_1674878710.7347343.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass SummaryRanges {\\n public:\\n  void addNum(int val) {\\n    if (map.count(val))\\n      return;\\n\\n    const int lo = lowerKey(val);\\n    const int hi = higherKey(val);\\n\\n    // {lo, map[lo][1]} + val + {hi, map[hi][1]} = {lo, map[hi][1]}\\n    if (lo >= 0 && hi >= 0 && map[lo][1] + 1 == val && val + 1 == hi) {\\n      map[lo][1] = map[hi][1];\\n      map.erase(hi);\\n      // {lo, map[lo][1]} + val = {lo, val}\\n      // (prevent adding duplicate entry by using \\'>=\\' instead of \\'==\\')\\n    } else if (lo >= 0 && map[lo][1] + 1 >= val) {\\n      map[lo][1] = max(map[lo][1], val);\\n    } else if (hi >= 0 && val + 1 == hi) {\\n      // Val + {hi, map[hi][1]} = {val, map[hi][1]}\\n      map[val] = {val, map[hi][1]};\\n      map.erase(hi);\\n    } else {\\n      map[val] = {val, val};\\n    }\\n  }\\n\\n  vector<vector<int>> getIntervals() {\\n    vector<vector<int>> intervals;\\n    for (const auto& [_, interval] : map)\\n      intervals.push_back(interval);\\n    return intervals;\\n  }\\n\\n private:\\n  map<int, vector<int>> map;  // {start: {start, end}}\\n\\n  // Maximum in map < key\\n  int lowerKey(int key) {\\n    auto it = map.lower_bound(key);  // Minimum in map >= key\\n    if (it == begin(map))\\n      return -1;\\n    return (--it)->first;\\n  }\\n\\n  // Minimum in map > key\\n  int higherKey(int key) {\\n    const auto it = map.upper_bound(key);  // Minimum in map > key\\n    if (it == cend(map))\\n      return -1;\\n    return it->first;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107428,
                "title": "c-java-ordered-set-tree-map-binary-search-3-solutions",
                "content": "# Intuition\\nThe SummaryRanges class is used to keep track of a set of intervals and provide methods to add new numbers to the set and retrieve the current set of intervals. The class uses a vector to store the intervals, where each interval is represented by a vector containing the start and end values of the interval.\\n\\nThe addNum() method is used to add a new number to the set of intervals. It first initializes the start and end values of the new interval to the given value. It then iterates through the existing intervals and checks if the new interval overlaps with any of them. If it does, it updates the start and end values of the new interval to include the overlapping intervals, and removes those intervals from the set. If the new interval does not overlap with any existing intervals, it is inserted into the set in the appropriate position.\\n\\nThe getIntervals() method simply returns the current set of intervals.\\n\\nOverall, the SummaryRanges class is useful for keeping track of a set of intervals and easily adding new numbers to the set while maintaining the integrity of the intervals.\\n# Approach\\n1. Initialize an empty list, intervals, to store the disjoint intervals.\\n2. Implement the addNum(int value) function:\\n    - Initialize a variable, start, to the value.\\n    - Initialize a variable, end, to the value.\\n    - Iterate through the intervals list:\\n        - If the value is within any of the intervals, return.\\n        - If the value is one less than the start of an interval, update the start of that interval to be the value.\\n        - If the value is one more than the end of an interval, update the end of that interval to be the value.\\n        - If the value is between two intervals, insert a new interval with start and end equal to the value.\\n3. Implement the getIntervals() function:\\n    - Sort the intervals list by the start of each interval.\\n    - Return the intervals list as a 2D array.\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ :\\nThe time complexity of the addNum function is O(n) because in the worst case, the function needs to iterate through all the intervals in the intervals vector to check for overlapping intervals, and the space complexity is O(n) as well, because the size of the intervals vector will grow as new intervals are added.\\n\\n- Space complexity:\\n $$O(1)$$ :\\nspace complexity of O(1) because it simply returns a reference to the intervals vector without any additional processing.\\n\\n# Code\\n```\\n// C++\\nclass SummaryRanges {\\n    vector<vector<int>> intervals;\\n\\npublic:\\n    SummaryRanges() {}\\n\\n    void addNum(int value) {\\n        int start = value, end = value;\\n        auto it = intervals.begin();\\n        while (it != intervals.end()) {\\n            if (it->at(1) + 1 < start) {\\n                ++it;\\n                continue;\\n            }\\n            if (it->at(0) - 1 > end) break;\\n            start = min(start, it->at(0));\\n            end = max(end, it->at(1));\\n            it = intervals.erase(it);\\n        }\\n        intervals.insert(it, {start, end});\\n    }\\n\\n    vector<vector<int>> getIntervals() {\\n        return intervals;\\n    }\\n};\\n\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```\\n```\\n// JAVA\\nclass SummaryRanges {\\nTreeMap<Integer, int[]> map;\\n\\n\\n/** Initialize your data structure here. */\\npublic SummaryRanges() {\\n    map = new TreeMap<>();\\n}\\n\\npublic void addNum(int value) {\\n    if(map.containsKey(value)) return;\\n    Integer low = map.lowerKey(value);\\n    Integer high = map.higherKey(value);\\n    if(low != null && high != null && map.get(low)[1] + 1 == value && high == value + 1) {\\n        map.get(low)[1] = map.get(high)[1];\\n        map.remove(high);\\n    }\\n    else if(low != null && map.get(low)[1] + 1 >= value) {\\n        map.get(low)[1] = Math.max(map.get(low)[1], value);\\n    }\\n    else if(high != null && high == value + 1) {\\n        map.put(value, new int[] {value, map.get(high)[1]});\\n        map.remove(high);\\n    }\\n    else {\\n        map.put(value, new int[] {value, value});\\n    }\\n}\\n\\npublic int[][] getIntervals() {\\n    int[][] res = new int[map.size()][2];\\n    int i = 0;\\n    for(int[] m : map.values()) {\\n        res[i++] = m;\\n    }\\n    return res;\\n}\\n}\\n\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges obj = new SummaryRanges();\\n * obj.addNum(value);\\n * int[][] param_2 = obj.getIntervals();\\n */\\n```\\n```\\n// ***************************Binary Search***************************\\n\\nclass SummaryRanges {\\n    vector<vector<int>> intervals;\\npublic:\\n    /** Initialize your data structure here. */\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int value) {\\n        int l = 0, r = intervals.size() - 1;\\n        while (l <= r) {\\n            int mid = (l + r) / 2;\\n            if (intervals[mid][0] <= value && intervals[mid][1] >= value) return;\\n            if (intervals[mid][1] < value) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        if (l == 0) {\\n            if (intervals.size() > 0 && intervals[0][0] == value + 1) {\\n                intervals[0][0] = value;\\n                return;\\n            }\\n        }\\n        else if (l == intervals.size()) {\\n            if (intervals[l - 1][1] == value - 1) {\\n                intervals[l - 1][1] = value;\\n                return;\\n            }\\n        }\\n        else {\\n            if (intervals[l - 1][1] == value - 1 && intervals[l][0] == value + 1) {\\n                intervals[l - 1][1] = intervals[l][1];\\n                intervals.erase(intervals.begin() + l);\\n                return;\\n            }\\n            if (intervals[l - 1][1] == value - 1) {\\n                intervals[l - 1][1] = value;\\n                return;\\n            }\\n            if (intervals[l][0] == value + 1) {\\n                intervals[l][0] = value;\\n                return;\\n            }\\n        }\\n        intervals.insert(intervals.begin() + l, vector<int>{value, value});\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        return intervals;\\n    }\\n};\\n\\n\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\n $$O(log n)$$ :\\nThe time complexity of the addNum function is O(log n) due to the binary search used to find the correct position to insert the new value. \\n\\n- Space complexity:\\n $$O(1)$$ :\\nspace complexity of O(1) because it simply returns a reference to the intervals vector without any additional processing.\\n\\n# Please Upvote\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Binary Search",
                    "Merge Sort",
                    "Ordered Set"
                ],
                "code": "```\\n// C++\\nclass SummaryRanges {\\n    vector<vector<int>> intervals;\\n\\npublic:\\n    SummaryRanges() {}\\n\\n    void addNum(int value) {\\n        int start = value, end = value;\\n        auto it = intervals.begin();\\n        while (it != intervals.end()) {\\n            if (it->at(1) + 1 < start) {\\n                ++it;\\n                continue;\\n            }\\n            if (it->at(0) - 1 > end) break;\\n            start = min(start, it->at(0));\\n            end = max(end, it->at(1));\\n            it = intervals.erase(it);\\n        }\\n        intervals.insert(it, {start, end});\\n    }\\n\\n    vector<vector<int>> getIntervals() {\\n        return intervals;\\n    }\\n};\\n\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```\n```\\n// JAVA\\nclass SummaryRanges {\\nTreeMap<Integer, int[]> map;\\n\\n\\n/** Initialize your data structure here. */\\npublic SummaryRanges() {\\n    map = new TreeMap<>();\\n}\\n\\npublic void addNum(int value) {\\n    if(map.containsKey(value)) return;\\n    Integer low = map.lowerKey(value);\\n    Integer high = map.higherKey(value);\\n    if(low != null && high != null && map.get(low)[1] + 1 == value && high == value + 1) {\\n        map.get(low)[1] = map.get(high)[1];\\n        map.remove(high);\\n    }\\n    else if(low != null && map.get(low)[1] + 1 >= value) {\\n        map.get(low)[1] = Math.max(map.get(low)[1], value);\\n    }\\n    else if(high != null && high == value + 1) {\\n        map.put(value, new int[] {value, map.get(high)[1]});\\n        map.remove(high);\\n    }\\n    else {\\n        map.put(value, new int[] {value, value});\\n    }\\n}\\n\\npublic int[][] getIntervals() {\\n    int[][] res = new int[map.size()][2];\\n    int i = 0;\\n    for(int[] m : map.values()) {\\n        res[i++] = m;\\n    }\\n    return res;\\n}\\n}\\n\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges obj = new SummaryRanges();\\n * obj.addNum(value);\\n * int[][] param_2 = obj.getIntervals();\\n */\\n```\n```\\n// ***************************Binary Search***************************\\n\\nclass SummaryRanges {\\n    vector<vector<int>> intervals;\\npublic:\\n    /** Initialize your data structure here. */\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int value) {\\n        int l = 0, r = intervals.size() - 1;\\n        while (l <= r) {\\n            int mid = (l + r) / 2;\\n            if (intervals[mid][0] <= value && intervals[mid][1] >= value) return;\\n            if (intervals[mid][1] < value) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        if (l == 0) {\\n            if (intervals.size() > 0 && intervals[0][0] == value + 1) {\\n                intervals[0][0] = value;\\n                return;\\n            }\\n        }\\n        else if (l == intervals.size()) {\\n            if (intervals[l - 1][1] == value - 1) {\\n                intervals[l - 1][1] = value;\\n                return;\\n            }\\n        }\\n        else {\\n            if (intervals[l - 1][1] == value - 1 && intervals[l][0] == value + 1) {\\n                intervals[l - 1][1] = intervals[l][1];\\n                intervals.erase(intervals.begin() + l);\\n                return;\\n            }\\n            if (intervals[l - 1][1] == value - 1) {\\n                intervals[l - 1][1] = value;\\n                return;\\n            }\\n            if (intervals[l][0] == value + 1) {\\n                intervals[l][0] = value;\\n                return;\\n            }\\n        }\\n        intervals.insert(intervals.begin() + l, vector<int>{value, value});\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        return intervals;\\n    }\\n};\\n\\n\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 253027,
                "title": "c-solution-with-step-by-step-explanation-100ms-beats-100",
                "content": "We can use either TreeMap/set or vector to solve this problem.\\nThe solution uses tree map or set is more efficient in insertion, but costs O(N) time to dump the item to array when query.\\nThe soluton uses vector costs O(N) time during insertion (inserting a new item leads to moving all following items), but costs only O(1) in query, and is more memory efficient.\\nThis solution uses bare vector as underlying data structure, but is optimized to take only one update operation (either insertion or erase) on the vector. \\n\\nThe key to solve this problem is to maintain the invariant: **No overlapped intervals in the vector before and after insertion**. Hence, before insertion, we can always assume this is true, and after insertion, we need verify and maintain this invariant.\\n```C++\\nstruct{\\n    bool operator()(const Interval &lhs, const Interval &rhs){\\n        return lhs.end < rhs.end;\\n    }\\n} cmp;\\n\\nclass SummaryRanges{\\npublic:\\n    SummaryRanges() {}\\n    \\n    // Two phases: \\n    // phase 1: deal with the interval whose end >= val, merge if possible\\n    // phase 2: deal with the interval whose end < val (the previous interval), see if the val or the 2 intervals can be merged.\\n    void addNum(int val) {\\n        Interval item(val, val);\\n        auto cur = lower_bound(intervals.begin(), intervals.end(), item, cmp);\\n        bool inserted = false; // in case val is not intersected with current interval.\\n        // cur is end, insert val\\n        if(cur == intervals.end()){\\n            cur = intervals.insert(cur, item); // Not using emplace_back because it doesn\\'t return the iterator to the new item.\\n            inserted = true;\\n        }else{\\n            // cur is not end: \\n            //   1) val can be added to current interval: a) merged, or b) extend start, in both way, inserted = true\\n            //   2) val doesn\\'t intersect with cur, no need take actions.\\n            if(val >= cur->start - 1){\\n                inserted = true;\\n                cur->start = val == cur->start - 1 ? val : cur->start;\\n            }\\n        }\\n        \\n        auto prev = cur;\\n        // Phase 2. process the previous interval (if cur is not the beginning):\\n        if(cur != intervals.begin()){\\n            prev--;\\n            if(inserted){\\n                // if inserted, if prev intersect with cur: extend prev, erase cur, \\n                if(cur->start == prev->end + 1) {\\n                    prev->end = cur->end;\\n                    intervals.erase(cur);\\n                }\\n            }else{\\n                // if not inserted, if prev intersects with val, extend. \\n                if(val == prev->end + 1) prev->end++;\\n                else intervals.insert(cur, item); // if prev doesn\\'t intersect with val, insert the new item.\\n            }\\n        }else{\\n            // Edge case, no previous item to process, but new item has not been inserted.\\n            if(!inserted){\\n                intervals.insert(cur, item);\\n            }\\n        }\\n    }\\n    \\n    vector<Interval> getIntervals() {\\n        return intervals;\\n    }\\nprivate:\\n    vector<Interval> intervals;\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```C++\\nstruct{\\n    bool operator()(const Interval &lhs, const Interval &rhs){\\n        return lhs.end < rhs.end;\\n    }\\n} cmp;\\n\\nclass SummaryRanges{\\npublic:\\n    SummaryRanges() {}\\n    \\n    // Two phases: \\n    // phase 1: deal with the interval whose end >= val, merge if possible\\n    // phase 2: deal with the interval whose end < val (the previous interval), see if the val or the 2 intervals can be merged.\\n    void addNum(int val) {\\n        Interval item(val, val);\\n        auto cur = lower_bound(intervals.begin(), intervals.end(), item, cmp);\\n        bool inserted = false; // in case val is not intersected with current interval.\\n        // cur is end, insert val\\n        if(cur == intervals.end()){\\n            cur = intervals.insert(cur, item); // Not using emplace_back because it doesn\\'t return the iterator to the new item.\\n            inserted = true;\\n        }else{\\n            // cur is not end: \\n            //   1) val can be added to current interval: a) merged, or b) extend start, in both way, inserted = true\\n            //   2) val doesn\\'t intersect with cur, no need take actions.\\n            if(val >= cur->start - 1){\\n                inserted = true;\\n                cur->start = val == cur->start - 1 ? val : cur->start;\\n            }\\n        }\\n        \\n        auto prev = cur;\\n        // Phase 2. process the previous interval (if cur is not the beginning):\\n        if(cur != intervals.begin()){\\n            prev--;\\n            if(inserted){\\n                // if inserted, if prev intersect with cur: extend prev, erase cur, \\n                if(cur->start == prev->end + 1) {\\n                    prev->end = cur->end;\\n                    intervals.erase(cur);\\n                }\\n            }else{\\n                // if not inserted, if prev intersects with val, extend. \\n                if(val == prev->end + 1) prev->end++;\\n                else intervals.insert(cur, item); // if prev doesn\\'t intersect with val, insert the new item.\\n            }\\n        }else{\\n            // Edge case, no previous item to process, but new item has not been inserted.\\n            if(!inserted){\\n                intervals.insert(cur, item);\\n            }\\n        }\\n    }\\n    \\n    vector<Interval> getIntervals() {\\n        return intervals;\\n    }\\nprivate:\\n    vector<Interval> intervals;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 195719,
                "title": "java-treemap-solution",
                "content": "```java\\nclass SummaryRanges {\\n\\n    TreeMap<Integer, Interval> treeMap; // key is the starting time\\n    \\n    /** Initialize your data structure here. */\\n    public SummaryRanges() {\\n        treeMap = new TreeMap<>();\\n    }\\n    \\n    public void addNum(int val) {\\n        Integer key = treeMap.floorKey(val);\\n        Interval it = null;\\n        if (key == null || treeMap.get(key).end < val - 1) {\\n            it = new Interval(val, val);\\n        } else {\\n            it = treeMap.get(key);\\n            it.end = Math.max(it.end, val);\\n        }\\n        \\n        if (treeMap.containsKey(it.end + 1)) {\\n            Interval next = treeMap.get(it.end + 1);\\n            treeMap.remove(it.end + 1);\\n            it.end = Math.max(it.end, next.end);\\n        }\\n        treeMap.put(it.start, it);\\n    }\\n    \\n    public List<Interval> getIntervals() {\\n        return new ArrayList<Interval>(treeMap.values());\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```java\\nclass SummaryRanges {\\n\\n    TreeMap<Integer, Interval> treeMap; // key is the starting time\\n    \\n    /** Initialize your data structure here. */\\n    public SummaryRanges() {\\n        treeMap = new TreeMap<>();\\n    }\\n    \\n    public void addNum(int val) {\\n        Integer key = treeMap.floorKey(val);\\n        Interval it = null;\\n        if (key == null || treeMap.get(key).end < val - 1) {\\n            it = new Interval(val, val);\\n        } else {\\n            it = treeMap.get(key);\\n            it.end = Math.max(it.end, val);\\n        }\\n        \\n        if (treeMap.containsKey(it.end + 1)) {\\n            Interval next = treeMap.get(it.end + 1);\\n            treeMap.remove(it.end + 1);\\n            it.end = Math.max(it.end, next.end);\\n        }\\n        treeMap.put(it.start, it);\\n    }\\n    \\n    public List<Interval> getIntervals() {\\n        return new ArrayList<Interval>(treeMap.values());\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180856,
                "title": "my-simple-python-binary-search-solution",
                "content": "```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.starts, self.ends, self.used = [-float(\"inf\"), float(\"inf\")], [-float(\"inf\"), float(\"inf\")], set()\\n        \\n    def addNum(self, val):\\n        if val not in self.used:\\n            self.used.add(val)\\n            i = bisect.bisect_left(self.starts, val) - 1 # binay searched index for val\\n            if self.ends[i] + 1 == val and val + 1 == self.starts[i + 1]: # if val is the gap btw 2 intervals\\n                del self.starts[i + 1]\\n                del self.ends[i]\\n            elif self.ends[i] + 1 == val: #if val is adjacent to current end\\n                self.ends[i] += 1\\n            elif self.starts[i + 1] == val + 1: # if val is adjacent to next start\\n                self.starts[i + 1] -= 1\\n            elif val > self.ends[i]: # if val is independent of those 2 intervals\\n                self.starts.insert(i + 1, val) \\n                self.ends.insert(i + 1, val)\\n            \\n    def getIntervals(self):\\n        return [[s, e] for s, e in zip(self.starts[1:-1], self.ends[1:-1])] #exclude infinity\\n```",
                "solutionTags": [],
                "code": "```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.starts, self.ends, self.used = [-float(\"inf\"), float(\"inf\")], [-float(\"inf\"), float(\"inf\")], set()\\n        \\n    def addNum(self, val):\\n        if val not in self.used:\\n            self.used.add(val)\\n            i = bisect.bisect_left(self.starts, val) - 1 # binay searched index for val\\n            if self.ends[i] + 1 == val and val + 1 == self.starts[i + 1]: # if val is the gap btw 2 intervals\\n                del self.starts[i + 1]\\n                del self.ends[i]\\n            elif self.ends[i] + 1 == val: #if val is adjacent to current end\\n                self.ends[i] += 1\\n            elif self.starts[i + 1] == val + 1: # if val is adjacent to next start\\n                self.starts[i + 1] -= 1\\n            elif val > self.ends[i]: # if val is independent of those 2 intervals\\n                self.starts.insert(i + 1, val) \\n                self.ends.insert(i + 1, val)\\n            \\n    def getIntervals(self):\\n        return [[s, e] for s, e in zip(self.starts[1:-1], self.ends[1:-1])] #exclude infinity\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82602,
                "title": "java-binary-search-upon-list",
                "content": "Use a List to store the `Interval`. After adding a new number, apply binary search on the list to find the `Interval` to which the number is mostly close. \\n\\n    public class SummaryRanges {\\n        List<Interval> rangeList;\\n\\n        /** Initialize your data structure here. */\\n        public SummaryRanges() {\\n            rangeList=new LinkedList<Interval>();\\n        }\\n        \\n        public void addNum(int val) {\\n            if(rangeList.isEmpty()) rangeList.add(new Interval(val,val));\\n            else{\\n                int len=rangeList.size();\\n                int lo=0, hi=len-1;\\n                /*Search for the closest Interval:*/\\n                while(lo<hi){\\n                    int mid=lo+(hi-lo)/2;\\n                    Interval tmp=rangeList.get(mid);\\n                    if(val>=tmp.start && val<=tmp.end) return;\\n                    if(val<tmp.start) hi=mid;\\n                    else              lo=mid+1;\\n                }\\n                Interval target=rangeList.get(lo);\\n                Interval targetLeft=(lo>=1)?rangeList.get(lo-1):null;\\n                if(val>=target.start && val<=target.end) return;\\n                \\n                if(val<target.start){\\n                    if(targetLeft==null){\\n                        if(val+1==target.start) target.start=val;\\n                        else rangeList.add(0,new Interval(val,val));\\n                    }else{\\n                        if(targetLeft.end+2==target.start) {\\n                            targetLeft.end=target.end; \\n                            rangeList.remove(lo);\\n                        }else{\\n                            if(targetLeft.end+1==val) targetLeft.end=val;\\n                            else if(target.start-1==val) target.start=val;\\n                                 else rangeList.add(lo,new Interval(val,val));\\n                        }\\n                    }\\n                }else{\\n                    if(target.end+1==val) target.end=val;\\n                    else rangeList.add(new Interval(val,val));\\n                }\\n            }\\n        }\\n        \\n        public List<Interval> getIntervals() {\\n            return rangeList;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "Use a List to store the `Interval`. After adding a new number, apply binary search on the list to find the `Interval` to which the number is mostly close. \\n\\n    public class SummaryRanges {\\n        List<Interval> rangeList;\\n\\n        /** Initialize your data structure here. */\\n        public SummaryRanges() {\\n            rangeList=new LinkedList<Interval>();\\n        }\\n        \\n        public void addNum(int val) {\\n            if(rangeList.isEmpty()) rangeList.add(new Interval(val,val));\\n            else{\\n                int len=rangeList.size();\\n                int lo=0, hi=len-1;\\n                /*Search for the closest Interval:*/\\n                while(lo<hi){\\n                    int mid=lo+(hi-lo)/2;\\n                    Interval tmp=rangeList.get(mid);\\n                    if(val>=tmp.start && val<=tmp.end) return;\\n                    if(val<tmp.start) hi=mid;\\n                    else              lo=mid+1;\\n                }\\n                Interval target=rangeList.get(lo);\\n                Interval targetLeft=(lo>=1)?rangeList.get(lo-1):null;\\n                if(val>=target.start && val<=target.end) return;\\n                \\n                if(val<target.start){\\n                    if(targetLeft==null){\\n                        if(val+1==target.start) target.start=val;\\n                        else rangeList.add(0,new Interval(val,val));\\n                    }else{\\n                        if(targetLeft.end+2==target.start) {\\n                            targetLeft.end=target.end; \\n                            rangeList.remove(lo);\\n                        }else{\\n                            if(targetLeft.end+1==val) targetLeft.end=val;\\n                            else if(target.start-1==val) target.start=val;\\n                                 else rangeList.add(lo,new Interval(val,val));\\n                        }\\n                    }\\n                }else{\\n                    if(target.end+1==val) target.end=val;\\n                    else rangeList.add(new Interval(val,val));\\n                }\\n            }\\n        }\\n        \\n        public List<Interval> getIntervals() {\\n            return rangeList;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3246389,
                "title": "352-time-99-79-and-space-99-83-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHere are some comments in the code to explain what each part is doing:\\n\\n```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.intervals = []\\n```\\n- This is the constructor for the SummaryRanges class. It initializes an empty list called intervals.\\n\\n```\\n    def _merge_intervals(self, interval):\\n        if len(self.intervals) == 0:\\n            self.intervals.append(interval)\\n            return\\n```\\n- This is a helper method that merges a new interval with existing intervals in self.intervals. If self.intervals is empty, it just appends the new interval.\\n\\n```\\n        intervals = []\\n        i = 0\\n        while i < len(self.intervals):\\n            if interval[0] <= self.intervals[i][1]+1:\\n                break\\n            intervals.append(self.intervals[i])\\n\\n            i+=1\\n```\\n- This loop iterates through the existing intervals in self.intervals until it finds an interval that overlaps with interval, or until it reaches the end of the list. It saves all non-overlapping intervals in a new list called intervals.\\n```\\n        def merge_single_intervals(interval1, interval2):\\n            return [min(interval1[0], interval2[0]), max(interval1[1], interval2[1])]\\n\\n        merged_interval = interval\\n\\n        while i<len(self.intervals):\\n            if self.intervals[i][0] <= merged_interval[1]+1:\\n                merged_interval = merge_single_intervals(self.intervals[i], merged_interval)\\n            else:\\n                break\\n\\n            i+=1\\n        intervals.append(merged_interval)\\n\\n        while i<len(self.intervals):\\n            intervals.append(self.intervals[i])\\n            i+=1\\n\\n        self.intervals = intervals\\n```\\n- This loop iterates through the remaining intervals in self.intervals and merges any overlapping intervals with interval. It then adds the merged interval to intervals and appends any remaining intervals to the list.\\n```\\n    def addNum(self, value: int) -> None:\\n        self._merge_intervals([value, value])\\n```\\n- This method calls _merge_intervals with a new interval that only contains the value.\\n```\\n    def getIntervals(self) -> List[List[int]]:\\n        return self.intervals\\n```\\n- This method returns the current state of self.intervals.\\n\\n# Complexity\\n- Time complexity:\\n99.79%\\n\\n- Space complexity:\\n99.83%\\n\\n# Code\\n```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.intervals = []\\n        \\n    def _merge_intervals(self, interval):\\n        if len(self.intervals) == 0:\\n            self.intervals.append(interval)\\n            return\\n        \\n        intervals = []\\n        i = 0\\n        while i < len(self.intervals):\\n            if interval[0] <= self.intervals[i][1]+1:\\n                break\\n            intervals.append(self.intervals[i])\\n\\n            i+=1\\n        \\n        def merge_single_intervals(interval1, interval2):\\n            return [min(interval1[0], interval2[0]), max(interval1[1], interval2[1])]\\n\\n        merged_interval = interval\\n\\n        while i<len(self.intervals):\\n            if self.intervals[i][0] <= merged_interval[1]+1:\\n                merged_interval = merge_single_intervals(self.intervals[i], merged_interval)\\n            else:\\n                break\\n\\n            i+=1\\n        intervals.append(merged_interval)\\n\\n        while i<len(self.intervals):\\n            intervals.append(self.intervals[i])\\n            i+=1\\n\\n        self.intervals = intervals\\n\\n    def addNum(self, value: int) -> None:\\n        self._merge_intervals([value, value])\\n        \\n\\n    def getIntervals(self) -> List[List[int]]:\\n        return self.intervals\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Design",
                    "Ordered Set"
                ],
                "code": "```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.intervals = []\\n```\n```\\n    def _merge_intervals(self, interval):\\n        if len(self.intervals) == 0:\\n            self.intervals.append(interval)\\n            return\\n```\n```\\n        intervals = []\\n        i = 0\\n        while i < len(self.intervals):\\n            if interval[0] <= self.intervals[i][1]+1:\\n                break\\n            intervals.append(self.intervals[i])\\n\\n            i+=1\\n```\n```\\n        def merge_single_intervals(interval1, interval2):\\n            return [min(interval1[0], interval2[0]), max(interval1[1], interval2[1])]\\n\\n        merged_interval = interval\\n\\n        while i<len(self.intervals):\\n            if self.intervals[i][0] <= merged_interval[1]+1:\\n                merged_interval = merge_single_intervals(self.intervals[i], merged_interval)\\n            else:\\n                break\\n\\n            i+=1\\n        intervals.append(merged_interval)\\n\\n        while i<len(self.intervals):\\n            intervals.append(self.intervals[i])\\n            i+=1\\n\\n        self.intervals = intervals\\n```\n```\\n    def addNum(self, value: int) -> None:\\n        self._merge_intervals([value, value])\\n```\n```\\n    def getIntervals(self) -> List[List[int]]:\\n        return self.intervals\\n```\n```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.intervals = []\\n        \\n    def _merge_intervals(self, interval):\\n        if len(self.intervals) == 0:\\n            self.intervals.append(interval)\\n            return\\n        \\n        intervals = []\\n        i = 0\\n        while i < len(self.intervals):\\n            if interval[0] <= self.intervals[i][1]+1:\\n                break\\n            intervals.append(self.intervals[i])\\n\\n            i+=1\\n        \\n        def merge_single_intervals(interval1, interval2):\\n            return [min(interval1[0], interval2[0]), max(interval1[1], interval2[1])]\\n\\n        merged_interval = interval\\n\\n        while i<len(self.intervals):\\n            if self.intervals[i][0] <= merged_interval[1]+1:\\n                merged_interval = merge_single_intervals(self.intervals[i], merged_interval)\\n            else:\\n                break\\n\\n            i+=1\\n        intervals.append(merged_interval)\\n\\n        while i<len(self.intervals):\\n            intervals.append(self.intervals[i])\\n            i+=1\\n\\n        self.intervals = intervals\\n\\n    def addNum(self, value: int) -> None:\\n        self._merge_intervals([value, value])\\n        \\n\\n    def getIntervals(self) -> List[List[int]]:\\n        return self.intervals\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110367,
                "title": "c-2-line-simple-solution-very-easy-intuitive",
                "content": "# Intuition\\nAt every `getIntervals` query we have to generate and send the interval in sorted order. So, we should keep our data in the sorted order, which data-structure can help us here?\\nYes, you are right, it\\'s `set` data-structure.\\n\\n# Approach\\nOur answer is going to to be nothing but vector of vector of 2 elements (or can say, vector of pair), i.e., `[{s1,e1}, {s2,s2}, {s3,e3}]` we don\\'t have to care about elements in between `s` and `e`.\\n\\nSo, at every `getIntervals` query we have to traverse the `set` and updated the answer.\\n\\nNow, if our `ans` is empty we have to create a new \"range\" with `s = x` and `e = x` i.e., `ans.push_back({x,x})`\\n\\nIf the `e` of the last pair of the `ans` is equals to `x - 1` then we have got one more element for our last pair. So, we just update the `e` of the last pair of the `ans`. i.e., `ans.back().back() = x`.\\nIf not so, then we again have to create a new \"range\" with `s = x` and `e = x`.\\n\\nwhere `x` is the current set element.\\n\\n![image.png](https://assets.leetcode.com/users/images/88b3a326-d8c4-4c44-badc-75fa0d285310_1674927940.6129165.png)\\n\\n\\n\\n# Code\\n```\\nclass SummaryRanges {\\npublic:\\n    set<int> st;\\n\\n    SummaryRanges() {}\\n    \\n    void addNum(int value) {\\n        st.emplace(value);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> ans;\\n        for(auto x:st){\\n            if(ans.size() && ans.back().back()+1 == x) ans.back().back() = x;\\n            else ans.push_back({x,x});\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "# Intuition\\nAt every `getIntervals` query we have to generate and send the interval in sorted order. So, we should keep our data in the sorted order, which data-structure can help us here?\\nYes, you are right, it\\'s `set` data-structure.\\n\\n# Approach\\nOur answer is going to to be nothing but vector of vector of 2 elements (or can say, vector of pair), i.e., `[{s1,e1}, {s2,s2}, {s3,e3}]` we don\\'t have to care about elements in between `s` and `e`.\\n\\nSo, at every `getIntervals` query we have to traverse the `set` and updated the answer.\\n\\nNow, if our `ans` is empty we have to create a new \"range\" with `s = x` and `e = x` i.e., `ans.push_back({x,x})`\\n\\nIf the `e` of the last pair of the `ans` is equals to `x - 1` then we have got one more element for our last pair. So, we just update the `e` of the last pair of the `ans`. i.e., `ans.back().back() = x`.\\nIf not so, then we again have to create a new \"range\" with `s = x` and `e = x`.\\n\\nwhere `x` is the current set element.\\n\\n![image.png](https://assets.leetcode.com/users/images/88b3a326-d8c4-4c44-badc-75fa0d285310_1674927940.6129165.png)\\n\\n\\n\\n# Code\\n```\\nclass SummaryRanges {\\npublic:\\n    set<int> st;\\n\\n    SummaryRanges() {}\\n    \\n    void addNum(int value) {\\n        st.emplace(value);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> ans;\\n        for(auto x:st){\\n            if(ans.size() && ans.back().back()+1 == x) ans.back().back() = x;\\n            else ans.push_back({x,x});\\n        }\\n        return ans;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 3109290,
                "title": "data-stream-linked-list-node",
                "content": "# Intuition\\nIts based linked list insertion on a order way.\\n\\n# Approach\\nAdd all the elements in linked list based on ascending order,\\nWhen retriving records from head traverse through all the nodes and see if its continuous, if yes move to next element else add to the result.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(nlogn)$$\\n\\n# Code\\n```\\nclass SummaryRanges {\\n\\n\\tclass Node{\\n\\t\\tint value;\\n\\t\\tNode next;\\n\\t\\tpublic Node(int value, Node next) {\\n\\t\\t\\tthis.value = value;\\n\\t\\t\\tthis.next = next;\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\tNode head;\\n\\tpublic SummaryRanges() {\\n        head = new Node(-1, null);\\n    }\\n    \\n    public void addNum(int value) {\\n       Node curr = head;\\n       Node previous=head;\\n       while(curr!=null && curr.value<value){\\n    \\t   previous=curr;\\n    \\t   curr = curr.next;\\n       }\\n       previous.next=new Node(value, curr);\\n    }\\n    \\n    public int[][] getIntervals() {\\n       Node curr = head.next;\\n       int prevVal = curr.value;\\n       List<List<Integer>> list = new ArrayList();\\n       List<Integer> set = new ArrayList<Integer>();\\n       set.add(prevVal);\\n       curr = curr.next;\\n       while(curr!=null){\\n    \\t   if(curr.value>prevVal+1){\\n               set.add(prevVal);\\n    \\t\\t   list.add(set);\\n    \\t\\t   set = new ArrayList<Integer>();\\n    \\t\\t   set.add(curr.value);\\n    \\t   }\\n    \\t   prevVal = curr.value;\\n           curr = curr.next;\\n       }\\n       set.add(prevVal);\\n       list.add(set);\\n       int[][] res = new int[list.size()][2];\\n       for(int i=0; i<list.size(); i++){\\n    \\t   res[i][0]=list.get(i).get(0);\\n    \\t   res[i][1]=list.get(i).get(1);\\n       }\\n       return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Linked List"
                ],
                "code": "```\\nclass SummaryRanges {\\n\\n\\tclass Node{\\n\\t\\tint value;\\n\\t\\tNode next;\\n\\t\\tpublic Node(int value, Node next) {\\n\\t\\t\\tthis.value = value;\\n\\t\\t\\tthis.next = next;\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\tNode head;\\n\\tpublic SummaryRanges() {\\n        head = new Node(-1, null);\\n    }\\n    \\n    public void addNum(int value) {\\n       Node curr = head;\\n       Node previous=head;\\n       while(curr!=null && curr.value<value){\\n    \\t   previous=curr;\\n    \\t   curr = curr.next;\\n       }\\n       previous.next=new Node(value, curr);\\n    }\\n    \\n    public int[][] getIntervals() {\\n       Node curr = head.next;\\n       int prevVal = curr.value;\\n       List<List<Integer>> list = new ArrayList();\\n       List<Integer> set = new ArrayList<Integer>();\\n       set.add(prevVal);\\n       curr = curr.next;\\n       while(curr!=null){\\n    \\t   if(curr.value>prevVal+1){\\n               set.add(prevVal);\\n    \\t\\t   list.add(set);\\n    \\t\\t   set = new ArrayList<Integer>();\\n    \\t\\t   set.add(curr.value);\\n    \\t   }\\n    \\t   prevVal = curr.value;\\n           curr = curr.next;\\n       }\\n       set.add(prevVal);\\n       list.add(set);\\n       int[][] res = new int[list.size()][2];\\n       for(int i=0; i<list.size(); i++){\\n    \\t   res[i][0]=list.get(i).get(0);\\n    \\t   res[i][1]=list.get(i).get(1);\\n       }\\n       return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108356,
                "title": "python-simple-python-solution-using-ordered-set-sorting",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 610 ms, faster than 21.07% of Python3 online submissions for Data Stream as Disjoint Intervals.\\n# Memory Usage: 19 MB, less than 43.48% of Python3 online submissions for Data Stream as Disjoint Intervals.\\n\\n\\tclass SummaryRanges:\\n\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.set = set()\\n\\n\\t\\tdef addNum(self, value: int) -> None:\\n\\t\\t\\tself.set.add(value)\\n\\n\\t\\tdef getIntervals(self) -> List[List[int]]:\\n\\n\\t\\t\\tresult = []\\n\\t\\t\\tindex = 1\\n\\t\\t\\tarray = sorted(list(self.set))\\n\\t\\t\\t\\n\\t\\t\\tstart = array[0]\\n\\t\\t\\tcurrent_element = array[0]\\n\\n\\t\\t\\tif len(array) == 1:\\n\\t\\t\\t\\tresult.append([start, start])\\n\\t\\t\\t\\treturn result\\n\\n\\t\\t\\twhile index < len(array):\\n\\n\\t\\t\\t\\tif array[index] != current_element + 1:\\n\\t\\t\\t\\t\\tresult.append([start, array[index - 1]])\\n\\t\\t\\t\\t\\tstart = array[index]\\n\\n\\t\\t\\t\\tcurrent_element = array[index]\\n\\t\\t\\t\\tindex = index + 1\\n\\n\\t\\t\\tresult.append([start,array[index - 1]])\\n\\n\\t\\t\\treturn result \\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 610 ms, faster than 21.07% of Python3 online submissions for Data Stream as Disjoint Intervals.\\n# Memory Usage: 19 MB, less than 43.48% of Python3 online submissions for Data Stream as Disjoint Intervals.\\n\\n\\tclass SummaryRanges:\\n\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.set = set()\\n\\n\\t\\tdef addNum(self, value: int) -> None:\\n\\t\\t\\tself.set.add(value)\\n\\n\\t\\tdef getIntervals(self) -> List[List[int]]:\\n\\n\\t\\t\\tresult = []\\n\\t\\t\\tindex = 1\\n\\t\\t\\tarray = sorted(list(self.set))\\n\\t\\t\\t\\n\\t\\t\\tstart = array[0]\\n\\t\\t\\tcurrent_element = array[0]\\n\\n\\t\\t\\tif len(array) == 1:\\n\\t\\t\\t\\tresult.append([start, start])\\n\\t\\t\\t\\treturn result\\n\\n\\t\\t\\twhile index < len(array):\\n\\n\\t\\t\\t\\tif array[index] != current_element + 1:\\n\\t\\t\\t\\t\\tresult.append([start, array[index - 1]])\\n\\t\\t\\t\\t\\tstart = array[index]\\n\\n\\t\\t\\t\\tcurrent_element = array[index]\\n\\t\\t\\t\\tindex = index + 1\\n\\n\\t\\t\\tresult.append([start,array[index - 1]])\\n\\n\\t\\t\\treturn result \\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 3108348,
                "title": "c-use-set-simple-approach",
                "content": "# Code\\n```\\nclass SummaryRanges \\n{\\npublic:\\n    vector<int> arr;\\n    set<int> set_check;\\n    SummaryRanges() \\n    {\\n        \\n    }\\n    \\n    void addNum(int value) \\n    {\\n        //for stopping adding duplicate value\\n        //check value doesn\\'t present in the stream \\n        if(set_check.count(value)==0) \\n        {\\n            arr.push_back(value);\\n            set_check.insert(value);\\n            sort(begin(arr), end(arr)); //sort array for getting intervals\\n        }\\n    }\\n    \\n    vector<vector<int>> getIntervals() \\n    {\\n        vector<vector<int>> res;\\n        vector<int> temp; //storing interval\\n        int i, j;\\n        for(i=0; i<arr.size(); i++)\\n        {\\n            //initially take same start and end point for the interval\\n            temp.push_back(arr[i]);\\n            temp.push_back(arr[i]);\\n            for(j=i+1; j<arr.size(); j++) //for updating end point of the interval\\n            {\\n                if(arr[j]-1 == temp.back()) //if values are consecutive, we update end point\\n                    temp[1] = arr[j];\\n                else\\n                    break;\\n            }\\n            res.push_back(temp); //add the interval in the result\\n            temp.clear(); //clear the interval\\n            i=j-1; //updating index i\\n\\n        }\\n        return res;\\n        \\n    }\\n};\\n```\\n# Please upvote if it helps :)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Design",
                    "Ordered Set"
                ],
                "code": "```\\nclass SummaryRanges \\n{\\npublic:\\n    vector<int> arr;\\n    set<int> set_check;\\n    SummaryRanges() \\n    {\\n        \\n    }\\n    \\n    void addNum(int value) \\n    {\\n        //for stopping adding duplicate value\\n        //check value doesn\\'t present in the stream \\n        if(set_check.count(value)==0) \\n        {\\n            arr.push_back(value);\\n            set_check.insert(value);\\n            sort(begin(arr), end(arr)); //sort array for getting intervals\\n        }\\n    }\\n    \\n    vector<vector<int>> getIntervals() \\n    {\\n        vector<vector<int>> res;\\n        vector<int> temp; //storing interval\\n        int i, j;\\n        for(i=0; i<arr.size(); i++)\\n        {\\n            //initially take same start and end point for the interval\\n            temp.push_back(arr[i]);\\n            temp.push_back(arr[i]);\\n            for(j=i+1; j<arr.size(); j++) //for updating end point of the interval\\n            {\\n                if(arr[j]-1 == temp.back()) //if values are consecutive, we update end point\\n                    temp[1] = arr[j];\\n                else\\n                    break;\\n            }\\n            res.push_back(temp); //add the interval in the result\\n            temp.clear(); //clear the interval\\n            i=j-1; //updating index i\\n\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349552,
                "title": "c-o-n-using-set-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass SummaryRanges {\\npublic:\\n    set<int> s;\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int val) {\\n        s.insert(val);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> v;\\n        int curr=-1;\\n        int t=-1;\\n        for(auto x:s)\\n        {\\n            if(curr==-1)\\n            {\\n                t=x;\\n                curr=x;\\n            }\\n            else if(curr+1==x)\\n                curr++;\\n            else\\n            {\\n                v.push_back({t,curr});\\n                t=x;\\n                curr=x;\\n            }\\n        }\\n        v.push_back({t,curr});\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass SummaryRanges {\\npublic:\\n    set<int> s;\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int val) {\\n        s.insert(val);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> v;\\n        int curr=-1;\\n        int t=-1;\\n        for(auto x:s)\\n        {\\n            if(curr==-1)\\n            {\\n                t=x;\\n                curr=x;\\n            }\\n            else if(curr+1==x)\\n                curr++;\\n            else\\n            {\\n                v.push_back({t,curr});\\n                t=x;\\n                curr=x;\\n            }\\n        }\\n        v.push_back({t,curr});\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074655,
                "title": "shit-code-using-sorteddict-in-python",
                "content": "I am not familiar with the TreeMap and thus translated the TreeMap method into SortedDict in Python, pls let me know if we can further optimise the shit code below.\\n\\'\\'\\'\\nfrom sortedcontainers import SortedDict\\nimport bisect\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.cand = SortedDict()\\n\\n    def addNum(self, val: int) -> None:\\n        l = self.cand.keys()\\n        if val in l: return\\n        prev = bisect.bisect(l, val) - 1\\n        nxt = bisect.bisect(l, val) + 1\\n        self.cand[val] = val\\n        n = len(self.cand)\\n\\n        if nxt != n and l[nxt] == val + 1:\\n            self.cand[val] = self.cand[l[nxt]]\\n            del self.cand[l[nxt]]\\n        if prev != -1 and self.cand[l[prev]] >= val - 1:\\n            self.cand[l[prev]] = max(self.cand[l[prev]], self.cand[val])\\n            del self.cand[val]\\n        \\n    def getIntervals(self) -> List[List[int]]:\\n        ans = []\\n        for k, v in self.cand.items():\\n            ans.append([k, v])\\n            \\n        return ans\\n        \\n\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "I am not familiar with the TreeMap and thus translated the TreeMap method into SortedDict in Python, pls let me know if we can further optimise the shit code below.\\n\\'\\'\\'\\nfrom sortedcontainers import SortedDict\\nimport bisect\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.cand = SortedDict()\\n\\n    def addNum(self, val: int) -> None:\\n        l = self.cand.keys()\\n        if val in l: return\\n        prev = bisect.bisect(l, val) - 1\\n        nxt = bisect.bisect(l, val) + 1\\n        self.cand[val] = val\\n        n = len(self.cand)\\n\\n        if nxt != n and l[nxt] == val + 1:\\n            self.cand[val] = self.cand[l[nxt]]\\n            del self.cand[l[nxt]]\\n        if prev != -1 and self.cand[l[prev]] >= val - 1:\\n            self.cand[l[prev]] = max(self.cand[l[prev]], self.cand[val])\\n            del self.cand[val]\\n        \\n    def getIntervals(self) -> List[List[int]]:\\n        ans = []\\n        for k, v in self.cand.items():\\n            ans.append([k, v])\\n            \\n        return ans\\n        \\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2022311,
                "title": "c-map",
                "content": "```\\nclass SummaryRanges {\\n    map<int,int> start,end;\\n    unordered_map<int,int> mp;\\npublic:\\n    SummaryRanges() {\\n    }\\n    \\n    void addNum(int i) {\\n        if(mp.find(i)!=mp.end()) return;\\n        int st = i,en = i;\\n        if(end.find(i-1)!=end.end()){\\n            st = end[i-1]; \\n            end.erase(i-1); start.erase(st);\\n        }\\n        if(start.find(i+1)!=start.end()){\\n            en = start[i+1]; \\n            end.erase(en); start.erase(i+1);\\n        }\\n        start[st] = en; end[en] = st; mp[i]++;\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n         vector<vector<int>> re;\\n         for(auto&[x,y]:start) re.push_back({x,y});\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass SummaryRanges {\\n    map<int,int> start,end;\\n    unordered_map<int,int> mp;\\npublic:\\n    SummaryRanges() {\\n    }\\n    \\n    void addNum(int i) {\\n        if(mp.find(i)!=mp.end()) return;\\n        int st = i,en = i;\\n        if(end.find(i-1)!=end.end()){\\n            st = end[i-1]; \\n            end.erase(i-1); start.erase(st);\\n        }\\n        if(start.find(i+1)!=start.end()){\\n            en = start[i+1]; \\n            end.erase(en); start.erase(i+1);\\n        }\\n        start[st] = en; end[en] = st; mp[i]++;\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n         vector<vector<int>> re;\\n         for(auto&[x,y]:start) re.push_back({x,y});\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1571725,
                "title": "golang-binary-search-100-solution",
                "content": "```go\\ntype SummaryRanges struct {\\n\\tranges [][]int\\n}\\n\\nfunc Constructor() SummaryRanges {\\n\\treturn SummaryRanges{\\n\\t\\tranges: make([][]int, 0),\\n\\t}\\n}\\n\\nfunc (sr *SummaryRanges) AddNum(val int)  {\\n\\tl, r := 0, len(sr.ranges)-1\\n\\tfor l <= r {\\n\\t\\tm := (l+r)>>1\\n\\t\\tif val >= sr.ranges[m][0] && val <= sr.ranges[m][1] {\\n\\t\\t\\t// in a valid range, nothing to do\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tif val == sr.ranges[m][0]-1 {\\n\\t\\t\\tif m > 0 && sr.ranges[m-1][1] + 1 == val {\\n\\t\\t\\t\\t// connect with prev range\\n\\t\\t\\t\\tsr.ranges[m-1][1] = sr.ranges[m][1]\\n\\t\\t\\t\\tcopy(sr.ranges[m:], sr.ranges[m+1:])\\n\\t\\t\\t\\tsr.ranges = sr.ranges[:len(sr.ranges)-1]\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\t\\t\\t// modify left bound\\n\\t\\t\\tsr.ranges[m][0] = val\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tif val == sr.ranges[m][1]+1 {\\n\\t\\t\\tif m + 1 < len(sr.ranges) && sr.ranges[m+1][0] - 1 == val {\\n\\t\\t\\t\\t//  connect with next range\\n\\t\\t\\t\\tsr.ranges[m+1][0] = sr.ranges[m][0]\\n\\t\\t\\t\\tcopy(sr.ranges[m:], sr.ranges[m+1:])\\n\\t\\t\\t\\tsr.ranges = sr.ranges[:len(sr.ranges)-1]\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\t\\t\\t// modify right bound\\n\\t\\t\\tsr.ranges[m][1] = val\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tif val < sr.ranges[m][0] {\\n\\t\\t\\tr = m - 1\\n\\t\\t} else {\\n\\t\\t\\tl = m + 1\\n\\t\\t}\\n\\t}\\n\\t// value @index r+1 is greater, insert index r+1\\n\\tsr.ranges = append(sr.ranges, nil)\\n\\tcopy(sr.ranges[r+2:], sr.ranges[r+1:])\\n\\tsr.ranges[r+1] = []int{val, val}\\n}\\n\\nfunc (sr *SummaryRanges) GetIntervals() [][]int {\\n\\treturn sr.ranges\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Tree"
                ],
                "code": "```go\\ntype SummaryRanges struct {\\n\\tranges [][]int\\n}\\n\\nfunc Constructor() SummaryRanges {\\n\\treturn SummaryRanges{\\n\\t\\tranges: make([][]int, 0),\\n\\t}\\n}\\n\\nfunc (sr *SummaryRanges) AddNum(val int)  {\\n\\tl, r := 0, len(sr.ranges)-1\\n\\tfor l <= r {\\n\\t\\tm := (l+r)>>1\\n\\t\\tif val >= sr.ranges[m][0] && val <= sr.ranges[m][1] {\\n\\t\\t\\t// in a valid range, nothing to do\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tif val == sr.ranges[m][0]-1 {\\n\\t\\t\\tif m > 0 && sr.ranges[m-1][1] + 1 == val {\\n\\t\\t\\t\\t// connect with prev range\\n\\t\\t\\t\\tsr.ranges[m-1][1] = sr.ranges[m][1]\\n\\t\\t\\t\\tcopy(sr.ranges[m:], sr.ranges[m+1:])\\n\\t\\t\\t\\tsr.ranges = sr.ranges[:len(sr.ranges)-1]\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\t\\t\\t// modify left bound\\n\\t\\t\\tsr.ranges[m][0] = val\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tif val == sr.ranges[m][1]+1 {\\n\\t\\t\\tif m + 1 < len(sr.ranges) && sr.ranges[m+1][0] - 1 == val {\\n\\t\\t\\t\\t//  connect with next range\\n\\t\\t\\t\\tsr.ranges[m+1][0] = sr.ranges[m][0]\\n\\t\\t\\t\\tcopy(sr.ranges[m:], sr.ranges[m+1:])\\n\\t\\t\\t\\tsr.ranges = sr.ranges[:len(sr.ranges)-1]\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\t\\t\\t// modify right bound\\n\\t\\t\\tsr.ranges[m][1] = val\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tif val < sr.ranges[m][0] {\\n\\t\\t\\tr = m - 1\\n\\t\\t} else {\\n\\t\\t\\tl = m + 1\\n\\t\\t}\\n\\t}\\n\\t// value @index r+1 is greater, insert index r+1\\n\\tsr.ranges = append(sr.ranges, nil)\\n\\tcopy(sr.ranges[r+2:], sr.ranges[r+1:])\\n\\tsr.ranges[r+1] = []int{val, val}\\n}\\n\\nfunc (sr *SummaryRanges) GetIntervals() [][]int {\\n\\treturn sr.ranges\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 793689,
                "title": "c-simple-and-97-fast-solution-using-sets",
                "content": "```\\n    set<pair<int,int>> st;\\n    SummaryRanges() { st.clear(); }\\n    \\n    void addNum(int val) {\\n        int l=val,r=val;\\n        auto it = st.upper_bound({val,INT_MAX});\\n        if(it!=st.end() && it->first==val+1) {\\n            r=it->second;\\n            it=st.erase(it); // immediate next iterator after deletion\\n        }\\n        if(it!=st.begin()) it--;\\n        if(it!=st.end() && it->first<=val & val<=it->second) return;\\n        if(it!=st.end() && it->second==val-1) {\\n            l=it->first;\\n            st.erase(it);\\n        }\\n        st.insert({l,r});\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> res;\\n        for(auto x: st) res.push_back({x.first,x.second});\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    set<pair<int,int>> st;\\n    SummaryRanges() { st.clear(); }\\n    \\n    void addNum(int val) {\\n        int l=val,r=val;\\n        auto it = st.upper_bound({val,INT_MAX});\\n        if(it!=st.end() && it->first==val+1) {\\n            r=it->second;\\n            it=st.erase(it); // immediate next iterator after deletion\\n        }\\n        if(it!=st.begin()) it--;\\n        if(it!=st.end() && it->first<=val & val<=it->second) return;\\n        if(it!=st.end() && it->second==val-1) {\\n            l=it->first;\\n            st.erase(it);\\n        }\\n        st.insert({l,r});\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> res;\\n        for(auto x: st) res.push_back({x.first,x.second});\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 707127,
                "title": "java-hashmap-add-o-1-getintervals-o-nlogn",
                "content": "Let\\'s consider Interval `[ start, end ]` with length `len`,\\nwe save two end points into map: `map.put(start, len)` and `map.put(end, len)`\\nWhen we add a new element into map, try to merge with its neighbors.\\n\\n```\\nclass SummaryRanges {\\n    \\n    Map<Integer, Integer> map = new HashMap<>();\\n    \\n    public void addNum(int val) {\\n        if (!map.containsKey(val)) {\\n            int left = map.containsKey(val - 1) ? map.get(val - 1) : 0;               // get left neighbor\\'s length\\n            int right = map.containsKey(val + 1) ? map.get(val + 1) : 0;           // get right neighbor\\'s length\\n            int sum = left + 1 + right;\\n            map.put(val, sum);\\n            if (left != 0) {\\n                map.put(val - left, sum);\\n            }\\n            if (right != 0) {\\n                map.put(val + right, sum);\\n            }\\n        }\\n    }\\n    \\n    public int[][] getIntervals() {\\n        List<int[]> list = new ArrayList<>();\\n        List<Integer> keys = new ArrayList<>(map.keySet());\\n        Collections.sort(keys);\\n        int end = -1;\\n        for (int i = 0; i < keys.size(); i++) {\\n            int key = keys.get(i);\\n            if (key > end) {                                       // find a new interval\\n                end = key + map.get(key) - 1;\\n                list.add(new int[]{key, end});\\n            }\\n        }\\n        int[][] res = new int[list.size()][2];\\n        for (int i = 0; i < res.length; i++) {\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass SummaryRanges {\\n    \\n    Map<Integer, Integer> map = new HashMap<>();\\n    \\n    public void addNum(int val) {\\n        if (!map.containsKey(val)) {\\n            int left = map.containsKey(val - 1) ? map.get(val - 1) : 0;               // get left neighbor\\'s length\\n            int right = map.containsKey(val + 1) ? map.get(val + 1) : 0;           // get right neighbor\\'s length\\n            int sum = left + 1 + right;\\n            map.put(val, sum);\\n            if (left != 0) {\\n                map.put(val - left, sum);\\n            }\\n            if (right != 0) {\\n                map.put(val + right, sum);\\n            }\\n        }\\n    }\\n    \\n    public int[][] getIntervals() {\\n        List<int[]> list = new ArrayList<>();\\n        List<Integer> keys = new ArrayList<>(map.keySet());\\n        Collections.sort(keys);\\n        int end = -1;\\n        for (int i = 0; i < keys.size(); i++) {\\n            int key = keys.get(i);\\n            if (key > end) {                                       // find a new interval\\n                end = key + map.get(key) - 1;\\n                list.add(new int[]{key, end});\\n            }\\n        }\\n        int[][] res = new int[list.size()][2];\\n        for (int i = 0; i < res.length; i++) {\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535955,
                "title": "accepted-c-solution",
                "content": "```\\n    public class SummaryRanges\\n    {\\n        private List<int[]> _data;\\n\\n        public SummaryRanges()\\n        {\\n            _data = new List<int[]>();\\n        }\\n\\n\\n        private List<int[]> Merge(IList<int[]> intervals)\\n        {\\n            List<int[]> res = new List<int[]>();\\n            int i = 0;\\n            int j = 1;\\n\\n            while (i < intervals.Count)\\n            {\\n                int from = intervals[i][0];\\n                int to = intervals[i][1];\\n\\n                while (j < intervals.Count && intervals[j][0] <= to + 1)\\n                {\\n                    to = Math.Max(to, intervals[j][1]);\\n                    j++;\\n                }\\n\\n                res.Add(new[] { from, to });\\n\\n                i = j;\\n                j = i + 1;\\n            }\\n\\n            return res;\\n        }\\n\\n\\n        private void Insert(int[] newInterval)\\n        {\\n            if (_data.Count == 0)\\n            {\\n                _data.Add(newInterval);\\n                return;\\n            }\\n\\n\\n            int l = 0;\\n            int r = _data.Count - 1;\\n            while (l < r)\\n            {\\n                if (r - l <= 1)\\n                {\\n                    break;\\n                }\\n\\n                int m = l + (r - l) / 2;\\n                if (_data[m][0] <= newInterval[0])\\n                {\\n                    l = m;\\n                }\\n                else\\n                {\\n                    r = m;\\n                }\\n            }\\n\\n            int idx = l;\\n            while (idx < _data.Count && newInterval[0] > _data[idx][0])\\n            {\\n                idx++;\\n            }\\n\\n            if (idx == _data.Count)\\n            {\\n                _data.Add(newInterval);\\n            }\\n            else\\n            {\\n                _data.Insert(idx, newInterval);\\n            }\\n        }\\n\\n        public void AddNum(int val)\\n        {\\n            Insert(new[] {val, val});\\n        }\\n\\n        public int[][] GetIntervals()\\n        {\\n            _data = Merge(_data);\\n            return _data.ToArray();\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class SummaryRanges\\n    {\\n        private List<int[]> _data;\\n\\n        public SummaryRanges()\\n        {\\n            _data = new List<int[]>();\\n        }\\n\\n\\n        private List<int[]> Merge(IList<int[]> intervals)\\n        {\\n            List<int[]> res = new List<int[]>();\\n            int i = 0;\\n            int j = 1;\\n\\n            while (i < intervals.Count)\\n            {\\n                int from = intervals[i][0];\\n                int to = intervals[i][1];\\n\\n                while (j < intervals.Count && intervals[j][0] <= to + 1)\\n                {\\n                    to = Math.Max(to, intervals[j][1]);\\n                    j++;\\n                }\\n\\n                res.Add(new[] { from, to });\\n\\n                i = j;\\n                j = i + 1;\\n            }\\n\\n            return res;\\n        }\\n\\n\\n        private void Insert(int[] newInterval)\\n        {\\n            if (_data.Count == 0)\\n            {\\n                _data.Add(newInterval);\\n                return;\\n            }\\n\\n\\n            int l = 0;\\n            int r = _data.Count - 1;\\n            while (l < r)\\n            {\\n                if (r - l <= 1)\\n                {\\n                    break;\\n                }\\n\\n                int m = l + (r - l) / 2;\\n                if (_data[m][0] <= newInterval[0])\\n                {\\n                    l = m;\\n                }\\n                else\\n                {\\n                    r = m;\\n                }\\n            }\\n\\n            int idx = l;\\n            while (idx < _data.Count && newInterval[0] > _data[idx][0])\\n            {\\n                idx++;\\n            }\\n\\n            if (idx == _data.Count)\\n            {\\n                _data.Add(newInterval);\\n            }\\n            else\\n            {\\n                _data.Insert(idx, newInterval);\\n            }\\n        }\\n\\n        public void AddNum(int val)\\n        {\\n            Insert(new[] {val, val});\\n        }\\n\\n        public int[][] GetIntervals()\\n        {\\n            _data = Merge(_data);\\n            return _data.ToArray();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 449652,
                "title": "c-solution",
                "content": "```\\npublic class SummaryRanges \\n{\\n    List<int[]> ranges;\\n    public SummaryRanges() \\n    {\\n        this.ranges = new List<int[]>();\\n    }\\n\\n    public void AddNum(int val)\\n    {\\n        int index = GetIndexToInsert(val);\\n        if (index == this.ranges.Count)\\n            this.ranges.Add(new int[] {val, val});\\n        else if (this.ranges[index][0] <= val && val <= this.ranges[index][1]) \\n            return;\\n        else\\n            this.ranges.Insert(index, new int[] {val, val});\\n        \\n        if(index + 1 < this.ranges.Count && ranges[index + 1][0] == val + 1)\\n        {\\n            this.ranges[index][1] = ranges[index + 1][1];\\n            this.ranges.RemoveAt(index + 1);\\n        }\\n        \\n        if(index - 1 >= 0 && ranges[index - 1][1] == val - 1)\\n        {\\n            this.ranges[index][0] = ranges[index - 1][0];\\n            this.ranges.RemoveAt(index - 1);\\n        }\\n    }\\n    \\n    public int[][] GetIntervals() \\n    {\\n        return this.ranges.ToArray();\\n    }\\n    \\n    private int GetIndexToInsert(int val)\\n    {\\n        var array = this.ranges.Select(x => x[1]).ToArray();\\n        var index = Array.BinarySearch(array, val);\\n        if(index < 0) index = ~index;\\n        return index;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class SummaryRanges \\n{\\n    List<int[]> ranges;\\n    public SummaryRanges() \\n    {\\n        this.ranges = new List<int[]>();\\n    }\\n\\n    public void AddNum(int val)\\n    {\\n        int index = GetIndexToInsert(val);\\n        if (index == this.ranges.Count)\\n            this.ranges.Add(new int[] {val, val});\\n        else if (this.ranges[index][0] <= val && val <= this.ranges[index][1]) \\n            return;\\n        else\\n            this.ranges.Insert(index, new int[] {val, val});\\n        \\n        if(index + 1 < this.ranges.Count && ranges[index + 1][0] == val + 1)\\n        {\\n            this.ranges[index][1] = ranges[index + 1][1];\\n            this.ranges.RemoveAt(index + 1);\\n        }\\n        \\n        if(index - 1 >= 0 && ranges[index - 1][1] == val - 1)\\n        {\\n            this.ranges[index][0] = ranges[index - 1][0];\\n            this.ranges.RemoveAt(index - 1);\\n        }\\n    }\\n    \\n    public int[][] GetIntervals() \\n    {\\n        return this.ranges.ToArray();\\n    }\\n    \\n    private int GetIndexToInsert(int val)\\n    {\\n        var array = this.ranges.Select(x => x[1]).ToArray();\\n        var index = Array.BinarySearch(array, val);\\n        if(index < 0) index = ~index;\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371756,
                "title": "java-treemap-solution",
                "content": "```\\nclass SummaryRanges {\\n\\n    /** Initialize your data structure here. */\\n    TreeMap<Integer, Integer> treemap = new TreeMap<>();\\n    public SummaryRanges() {\\n        \\n    }\\n    \\n    public void addNum(int val) {\\n        Integer pre = treemap.floorKey(val);\\n        Integer next = treemap.ceilingKey(val);\\n        \\n        if(pre!=null && treemap.get(pre)>=val){\\n            return;\\n        }\\n        \\n        if(next!=null && next == val){\\n            return;\\n        }\\n        \\n        int start = val;\\n        int end = val;\\n        if(next!=null && next-1==val){\\n            end = treemap.get(next);\\n            treemap.remove(next);\\n        }\\n        \\n        if(pre!=null && treemap.get(pre)+1==val){\\n            start = pre;\\n            treemap.remove(pre);\\n        }\\n        \\n        treemap.put(start, end);\\n        \\n        \\n    }\\n    \\n    public int[][] getIntervals() {\\n        List<int[]> res = new ArrayList<>();\\n        for(Integer start: treemap.keySet()){\\n            res.add(new int[]{start, treemap.get(start)});\\n        }\\n        \\n        int[][] ans = new int[res.size()][2];\\n        \\n        for(int i=0;i<res.size();i++){\\n            ans[i] = res.get(i);\\n        }\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges obj = new SummaryRanges();\\n * obj.addNum(val);\\n * int[][] param_2 = obj.getIntervals();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass SummaryRanges {\\n\\n    /** Initialize your data structure here. */\\n    TreeMap<Integer, Integer> treemap = new TreeMap<>();\\n    public SummaryRanges() {\\n        \\n    }\\n    \\n    public void addNum(int val) {\\n        Integer pre = treemap.floorKey(val);\\n        Integer next = treemap.ceilingKey(val);\\n        \\n        if(pre!=null && treemap.get(pre)>=val){\\n            return;\\n        }\\n        \\n        if(next!=null && next == val){\\n            return;\\n        }\\n        \\n        int start = val;\\n        int end = val;\\n        if(next!=null && next-1==val){\\n            end = treemap.get(next);\\n            treemap.remove(next);\\n        }\\n        \\n        if(pre!=null && treemap.get(pre)+1==val){\\n            start = pre;\\n            treemap.remove(pre);\\n        }\\n        \\n        treemap.put(start, end);\\n        \\n        \\n    }\\n    \\n    public int[][] getIntervals() {\\n        List<int[]> res = new ArrayList<>();\\n        for(Integer start: treemap.keySet()){\\n            res.add(new int[]{start, treemap.get(start)});\\n        }\\n        \\n        int[][] ans = new int[res.size()][2];\\n        \\n        for(int i=0;i<res.size();i++){\\n            ans[i] = res.get(i);\\n        }\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges obj = new SummaryRanges();\\n * obj.addNum(val);\\n * int[][] param_2 = obj.getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320175,
                "title": "javascript-beyond-easy",
                "content": "```\\n/**\\n * Initialize your data structure here.\\n */\\nvar SummaryRanges = function () {\\n  this.arr = []\\n};\\n\\n/** \\n * @param {number} val\\n * @return {void}\\n */\\nSummaryRanges.prototype.addNum = function (val) {\\n  this.arr[val] = true\\n};\\n\\n/**\\n * @return {number[][]}\\n */\\nSummaryRanges.prototype.getIntervals = function () {\\n  let rtn = [], start = -1\\n  for (let i = 0; i < this.arr.length; i++) {\\n    if (start == -1) {\\n      if (this.arr[i]) {\\n        start = i\\n        continue\\n      }\\n    } else {\\n      if (!this.arr[i]) {\\n        rtn.push([start, i - 1])\\n        start = -1\\n        continue\\n      }\\n    }\\n  }\\n  if (start != -1) {\\n    rtn.push([start, this.arr.length - 1])\\n  }\\n  return rtn\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Initialize your data structure here.\\n */\\nvar SummaryRanges = function () {\\n  this.arr = []\\n};\\n\\n/** \\n * @param {number} val\\n * @return {void}\\n */\\nSummaryRanges.prototype.addNum = function (val) {\\n  this.arr[val] = true\\n};\\n\\n/**\\n * @return {number[][]}\\n */\\nSummaryRanges.prototype.getIntervals = function () {\\n  let rtn = [], start = -1\\n  for (let i = 0; i < this.arr.length; i++) {\\n    if (start == -1) {\\n      if (this.arr[i]) {\\n        start = i\\n        continue\\n      }\\n    } else {\\n      if (!this.arr[i]) {\\n        rtn.push([start, i - 1])\\n        start = -1\\n        continue\\n      }\\n    }\\n  }\\n  if (start != -1) {\\n    rtn.push([start, this.arr.length - 1])\\n  }\\n  return rtn\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3116191,
                "title": "not-hart-not-medium-this-problem-is-easy",
                "content": "# Complexity\\n- Time complexity:O((no. of calls)*len(lst))\\n- Space complexity:O(len(calls))\\n# Code\\n```\\nclass SummaryRanges:\\n    def __init__(self):\\n        self.lst = []\\n\\n    def addNum(self, value: int) -> None:\\n        if value not in self.lst:\\n            self.lst.append(value)\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        self.lst.sort()\\n        res = []\\n        for ele in self.lst:\\n            if len(res) == 0 or res[-1][1] + 1 != ele:\\n                res.append([ele,ele])\\n            elif res[-1][1] + 1 == ele:\\n                res[-1][1] = ele\\n        return res\\n\\n\\nt = SummaryRanges()\\nlst = [1,2,6,6,9,10,11,12]\\nfor val in lst:\\n    t.addNum(val)\\n\\nprint(t.getIntervals())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SummaryRanges:\\n    def __init__(self):\\n        self.lst = []\\n\\n    def addNum(self, value: int) -> None:\\n        if value not in self.lst:\\n            self.lst.append(value)\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        self.lst.sort()\\n        res = []\\n        for ele in self.lst:\\n            if len(res) == 0 or res[-1][1] + 1 != ele:\\n                res.append([ele,ele])\\n            elif res[-1][1] + 1 == ele:\\n                res[-1][1] = ele\\n        return res\\n\\n\\nt = SummaryRanges()\\nlst = [1,2,6,6,9,10,11,12]\\nfor val in lst:\\n    t.addNum(val)\\n\\nprint(t.getIntervals())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111026,
                "title": "very-easy-intution-explained-c-vector",
                "content": "**Here as given in constraints :**\\n**0<=value<=10000**\\n\\n**Intution**\\n**intialise a vector of size 10001 with value 0.**\\n**add Num : when we add a number just make the vector[value]=1**\\n**getInterval : every time check using a loop about interval if we found continous interval just add into temp interval and then th first and last element into ans vector**\\n\\n\\n```\\n\\n// TC: addNum- o(1)\\n //      getInterval -O(N) each time we travel approx 10^4 times\\nclass SummaryRanges {\\npublic:\\n    vector<int>v;\\n    int maxi=0;\\n    SummaryRanges() {\\n        vector<int>temp(10002,0);\\n        v= temp;\\n    }\\n    \\n    void addNum(int value) {\\n        v[value]=1;\\n        maxi= max(maxi, value);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>>ans;\\n        vector<int>temp;\\n        \\n        for(int i=0; i<=maxi+1;i++)\\n        {\\n            if(v[i]==1)\\n            {\\n                while(v[i]==1)\\n                temp.push_back(i++);  \\n                i--;\\n            }\\n            else if(temp.size())\\n            {\\n                ans.push_back({temp.front(), temp.back()});\\n                temp={};\\n                \\n            }\\n           \\n        // return {};\\n            \\n            \\n        } return ans;\\n    }\\n    \\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\n\\n// TC: addNum- o(1)\\n //      getInterval -O(N) each time we travel approx 10^4 times\\nclass SummaryRanges {\\npublic:\\n    vector<int>v;\\n    int maxi=0;\\n    SummaryRanges() {\\n        vector<int>temp(10002,0);\\n        v= temp;\\n    }\\n    \\n    void addNum(int value) {\\n        v[value]=1;\\n        maxi= max(maxi, value);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>>ans;\\n        vector<int>temp;\\n        \\n        for(int i=0; i<=maxi+1;i++)\\n        {\\n            if(v[i]==1)\\n            {\\n                while(v[i]==1)\\n                temp.push_back(i++);  \\n                i--;\\n            }\\n            else if(temp.size())\\n            {\\n                ans.push_back({temp.front(), temp.back()});\\n                temp={};\\n                \\n            }\\n           \\n        // return {};\\n            \\n            \\n        } return ans;\\n    }\\n    \\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110238,
                "title": "java-tree-map-easy-solution",
                "content": "**We need to check 3 conditions basically which I ll explain with examples**\\n1. Existing Intervals : **[2,3] and [5,6]**. Now if comes a value as 4. We will check for lower and higher key and if their differnce is 1 . We ll combine the intervals as **[2, 6].**\\n2. Existing Interval: **[2,3]**. Now if comes a value as 4. We will check for lower and higher key and since only a lower key exists. We ll update the interval as **[2,4]**.\\n3.  Existing Interval: **[5,6]**. Now if comes a value as 4. We will check for lower and higher key and since only a higher key exists. We ll update the interval as **[4,6]**.\\n\\nAt last if none of the condition satisfies and valus is 4. Add an entry of **[4,4]** into the treemap\\n\\n```\\nclass SummaryRanges {\\n    TreeMap<Integer, Integer> tm;\\n    public SummaryRanges() {\\n        tm = new TreeMap<>();\\n    }\\n    \\n    public void addNum(int val) {\\n        if(tm.containsKey(val))\\n        {\\n            return;\\n        }\\n        \\n        Integer lower = tm.lowerKey(val);\\n        Integer higher = tm.higherKey(val);\\n        // Condition 1\\n        if(lower!=null && higher!=null && tm.get(lower) == val-1 && higher == val+1)\\n        {\\n            tm.put(lower, tm.get(higher));\\n            tm.remove(higher);\\n        }\\n\\t\\t// Condition 2\\n        else if(lower!=null && tm.get(lower)+1 >= val)\\n        {\\n            tm.put(lower, Math.max(tm.get(lower), val));\\n        }\\n\\t\\t// Condition 3\\n        else if(higher!=null  && higher == val+1)\\n        {\\n            tm.put(val, tm.get(higher));\\n            tm.remove(higher);\\n        }\\n        else\\n        {\\n            tm.put(val,val);\\n        }\\n    }\\n    \\n    public int[][] getIntervals() {\\n        List<int[]> res = new ArrayList<>();\\n        for(int a:tm.keySet()){\\n            res.add(new int[]{a,tm.get(a)});\\n        }\\n        return res.toArray(new int[tm.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass SummaryRanges {\\n    TreeMap<Integer, Integer> tm;\\n    public SummaryRanges() {\\n        tm = new TreeMap<>();\\n    }\\n    \\n    public void addNum(int val) {\\n        if(tm.containsKey(val))\\n        {\\n            return;\\n        }\\n        \\n        Integer lower = tm.lowerKey(val);\\n        Integer higher = tm.higherKey(val);\\n        // Condition 1\\n        if(lower!=null && higher!=null && tm.get(lower) == val-1 && higher == val+1)\\n        {\\n            tm.put(lower, tm.get(higher));\\n            tm.remove(higher);\\n        }\\n\\t\\t// Condition 2\\n        else if(lower!=null && tm.get(lower)+1 >= val)\\n        {\\n            tm.put(lower, Math.max(tm.get(lower), val));\\n        }\\n\\t\\t// Condition 3\\n        else if(higher!=null  && higher == val+1)\\n        {\\n            tm.put(val, tm.get(higher));\\n            tm.remove(higher);\\n        }\\n        else\\n        {\\n            tm.put(val,val);\\n        }\\n    }\\n    \\n    public int[][] getIntervals() {\\n        List<int[]> res = new ArrayList<>();\\n        for(int a:tm.keySet()){\\n            res.add(new int[]{a,tm.get(a)});\\n        }\\n        return res.toArray(new int[tm.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109909,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Ordered Set\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(log(N)) for addNum, O(N) for getIntervals.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass SummaryRanges {\\npublic:\\n    set<int> values;\\n\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int value) {\\n        values.insert(value);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        if(values.empty()) return {};\\n        vector<vector<int>> intervals;\\n        int l = -1, r = -1;\\n        for(auto x: values) {\\n            if(l < 0) l = r = x;\\n            else if(x == r + 1) r = x;\\n            else {\\n                intervals.push_back({l, r});\\n                l = r = x;\\n            }\\n        }\\n        intervals.push_back({l, r});\\n        return intervals;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SummaryRanges {\\npublic:\\n    set<int> values;\\n\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int value) {\\n        values.insert(value);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        if(values.empty()) return {};\\n        vector<vector<int>> intervals;\\n        int l = -1, r = -1;\\n        for(auto x: values) {\\n            if(l < 0) l = r = x;\\n            else if(x == r + 1) r = x;\\n            else {\\n                intervals.push_back({l, r});\\n                l = r = x;\\n            }\\n        }\\n        intervals.push_back({l, r});\\n        return intervals;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109760,
                "title": "faster-than-flash-c-binary-search",
                "content": "# Intuition\\nThe Approach is to use binary search to find the correct insert position where we can add a interval with new value.\\nIf we can merge intervals based on new value the we will do it and now this will also shrink the original array. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSuppose $$ind$$ is the correct insert position then we will do two things\\n1. search in the right for intervals which can be merged (may or may not be found)\\n2. search in the left for intervals which can be merged (may or may not be found)\\n\\nNow let from index $$i$$ to $$j$$ (merging interval\\'s indices may be changed based on the result from point **1** or **2**),  we can merge intervals with the new value into index $$i$$\\nthen $$nums[i]$$ = {$$nums[i][0], nums[j][1]$$}\\nNow we can shrink the array by moving all the intevals from index $$ k = j + 1 $$to the left till index $$i + 1$$\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SummaryRanges {\\npublic:\\n    vector<vector<int>> nums;\\n    //where new value should be added\\n    int ind;\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int value) {\\n        if(nums.empty()) {\\n            nums.push_back({value, value});\\n            return;\\n        }\\n\\n        //binary search to find the insert position\\n        int l = 0;\\n        int r = nums.size() -1;\\n        while(l <= r) {\\n            int mid = l + (r - l)/2;\\n            if(value > nums[r][1]) {\\n                ind = r + 1; break;\\n            }\\n            if(value < nums[l][0]) {\\n                ind = l; break;\\n            }\\n            // if value exists in any interval\\n            if(value >= nums[mid][0] && value <= nums[mid][1]) {\\n                ind = -1; break;\\n            }\\n            else if(value < nums[mid][0]) {\\n                r = mid - 1;\\n            }\\n            else  if(value > nums[mid][1]){\\n                l = mid + 1;\\n            }\\n        }\\n        // if the value exists in any interval then simply return.\\n        if(ind == -1) {\\n            return;\\n        }\\n        //we are looking for other intervals who can be merge into one\\n        bool flagi = false;\\n        bool flagj = false;\\n        //searching in the right of the insert position(ind to n-1)\\n        int j = -1;\\n        int lookFor = value;\\n        for(j = ind; j<nums.size() && lookFor + 1 == nums[j][0]; j++) {\\n            lookFor = nums[j][1];\\n            flagj = true;\\n        }\\n        //searching in the left of the insert position(ind-1 to 0)\\n        lookFor = value;\\n        int i = -1;\\n        for(i = ind-1; i>=0 && nums[i][1] + 1 == value; i--) {\\n            lookFor = nums[i][0];\\n            flagi = true;\\n        }\\n\\n        if(!flagi) i = -1;\\n        else {\\n            i++;\\n        }\\n        if(!flagj) j = -1;\\n        else {\\n            j--;\\n        }\\n        // k is the value from where we start shrinking our array.\\n        int k;\\n        // if we dont have any colliding intervals with new value\\n        if(i == -1 && j == -1) {\\n            nums.push_back({value, value});\\n            for(int i = nums.size() - 1; i>ind; i--) {\\n                nums[i] = nums[i-1];\\n            }\\n            nums[ind] = {value, value};\\n            ind = -1;\\n            return;\\n        }\\n        else if(i >= 0 && j == -1) {\\n            nums[i] = {nums[i][0], value};\\n            i++;\\n            k = ind;\\n\\n        }\\n        else if(i == -1 && j >= 0) {\\n            nums[j] = {value, nums[j][1]};\\n            i = ind;\\n            k = j;\\n        }\\n        else if(i >= 0 && j >= 0) {\\n            nums[i] = {nums[i][0], nums[j][1]};\\n            i++;\\n            k = j+1;\\n        }\\n        //shrinking the array after merging the intervals\\n        while(i < nums.size() && k < nums.size()) {\\n            nums[i++] = nums[k++];\\n        }\\n        int size = nums.size();\\n        while(i < size) {\\n            nums.pop_back();\\n            i++;\\n        }\\n        // assing ind = -1 for the next add Call\\n        ind = -1;\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        return nums;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass SummaryRanges {\\npublic:\\n    vector<vector<int>> nums;\\n    //where new value should be added\\n    int ind;\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int value) {\\n        if(nums.empty()) {\\n            nums.push_back({value, value});\\n            return;\\n        }\\n\\n        //binary search to find the insert position\\n        int l = 0;\\n        int r = nums.size() -1;\\n        while(l <= r) {\\n            int mid = l + (r - l)/2;\\n            if(value > nums[r][1]) {\\n                ind = r + 1; break;\\n            }\\n            if(value < nums[l][0]) {\\n                ind = l; break;\\n            }\\n            // if value exists in any interval\\n            if(value >= nums[mid][0] && value <= nums[mid][1]) {\\n                ind = -1; break;\\n            }\\n            else if(value < nums[mid][0]) {\\n                r = mid - 1;\\n            }\\n            else  if(value > nums[mid][1]){\\n                l = mid + 1;\\n            }\\n        }\\n        // if the value exists in any interval then simply return.\\n        if(ind == -1) {\\n            return;\\n        }\\n        //we are looking for other intervals who can be merge into one\\n        bool flagi = false;\\n        bool flagj = false;\\n        //searching in the right of the insert position(ind to n-1)\\n        int j = -1;\\n        int lookFor = value;\\n        for(j = ind; j<nums.size() && lookFor + 1 == nums[j][0]; j++) {\\n            lookFor = nums[j][1];\\n            flagj = true;\\n        }\\n        //searching in the left of the insert position(ind-1 to 0)\\n        lookFor = value;\\n        int i = -1;\\n        for(i = ind-1; i>=0 && nums[i][1] + 1 == value; i--) {\\n            lookFor = nums[i][0];\\n            flagi = true;\\n        }\\n\\n        if(!flagi) i = -1;\\n        else {\\n            i++;\\n        }\\n        if(!flagj) j = -1;\\n        else {\\n            j--;\\n        }\\n        // k is the value from where we start shrinking our array.\\n        int k;\\n        // if we dont have any colliding intervals with new value\\n        if(i == -1 && j == -1) {\\n            nums.push_back({value, value});\\n            for(int i = nums.size() - 1; i>ind; i--) {\\n                nums[i] = nums[i-1];\\n            }\\n            nums[ind] = {value, value};\\n            ind = -1;\\n            return;\\n        }\\n        else if(i >= 0 && j == -1) {\\n            nums[i] = {nums[i][0], value};\\n            i++;\\n            k = ind;\\n\\n        }\\n        else if(i == -1 && j >= 0) {\\n            nums[j] = {value, nums[j][1]};\\n            i = ind;\\n            k = j;\\n        }\\n        else if(i >= 0 && j >= 0) {\\n            nums[i] = {nums[i][0], nums[j][1]};\\n            i++;\\n            k = j+1;\\n        }\\n        //shrinking the array after merging the intervals\\n        while(i < nums.size() && k < nums.size()) {\\n            nums[i++] = nums[k++];\\n        }\\n        int size = nums.size();\\n        while(i < size) {\\n            nums.pop_back();\\n            i++;\\n        }\\n        // assing ind = -1 for the next add Call\\n        ind = -1;\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        return nums;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109692,
                "title": "python3-146-ms-faster-than-99-33-of-python3",
                "content": "```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.intervals = []\\n\\n    def addNum(self, value: int) -> None:\\n        left, right = 0, len(self.intervals) - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            e = self.intervals[mid]\\n            if e[0] <= value <= e[1]: return\\n            elif value < e[0]:right = mid - 1\\n            else:left = mid + 1\\n        pos = left\\n        self.intervals.insert(pos, [value, value])\\n        if pos + 1 < len(self.intervals) and value + 1 == self.intervals[pos+1][0]:\\n            self.intervals[pos][1] = self.intervals[pos+1][1]\\n            del self.intervals[pos+1]\\n        if pos - 1 >= 0 and value - 1 == self.intervals[pos-1][1]:\\n            self.intervals[pos-1][1] = self.intervals[pos][1]\\n            del self.intervals[pos]\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        return self.intervals\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Design",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.intervals = []\\n\\n    def addNum(self, value: int) -> None:\\n        left, right = 0, len(self.intervals) - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            e = self.intervals[mid]\\n            if e[0] <= value <= e[1]: return\\n            elif value < e[0]:right = mid - 1\\n            else:left = mid + 1\\n        pos = left\\n        self.intervals.insert(pos, [value, value])\\n        if pos + 1 < len(self.intervals) and value + 1 == self.intervals[pos+1][0]:\\n            self.intervals[pos][1] = self.intervals[pos+1][1]\\n            del self.intervals[pos+1]\\n        if pos - 1 >= 0 and value - 1 == self.intervals[pos-1][1]:\\n            self.intervals[pos-1][1] = self.intervals[pos][1]\\n            del self.intervals[pos]\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        return self.intervals\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109383,
                "title": "simple-java-easy-beginners-steps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SummaryRanges {\\n    TreeSet<int[]> set;\\n    public SummaryRanges() {\\n        set  = new TreeSet<int[]>((a, b) -> (a[0] == b[0]) ? a[1] - b[1] : a[0] - b[0]);\\n    }\\n    \\n    public void addNum(int value) {\\n        int[] m = new int[]{value, value};\\n        if(set.contains(m)){\\n            return;\\n        }\\n        int[] heigh = set.higher(m), low = set.lower(m);\\n        if(heigh != null && heigh[0] == value + 1 && low != null && low[1] == value - 1){\\n            // [1, 1], [3, 3]. inseted [2, 2]\\n            heigh[0] = low[0];\\n            set.remove(low);\\n        }else if(heigh != null && heigh[0] == value + 1){\\n            // [3, 3] insert [2, 2]\\n            heigh[0] = value;\\n        }else if(low != null && low[1] == value - 1){\\n            // [1, 1] insert [2, 2]\\n            low[1] = value;\\n        }else if((heigh != null && heigh[0] == value) || (low != null && low[0] <= value && low[1] >= value)){\\n            // [2, 3] insert [2, 2]\\n            // [1, 3] insert [2, 2]\\n            return;\\n        }else{\\n            set.add(m);\\n        }\\n    } \\n    \\n    public int[][] getIntervals(){\\n        List<int[]> res = new ArrayList<>();\\n        for(int[] s: set){\\n            res.add(s);\\n        }\\n        return res.toArray(new int[0][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SummaryRanges {\\n    TreeSet<int[]> set;\\n    public SummaryRanges() {\\n        set  = new TreeSet<int[]>((a, b) -> (a[0] == b[0]) ? a[1] - b[1] : a[0] - b[0]);\\n    }\\n    \\n    public void addNum(int value) {\\n        int[] m = new int[]{value, value};\\n        if(set.contains(m)){\\n            return;\\n        }\\n        int[] heigh = set.higher(m), low = set.lower(m);\\n        if(heigh != null && heigh[0] == value + 1 && low != null && low[1] == value - 1){\\n            // [1, 1], [3, 3]. inseted [2, 2]\\n            heigh[0] = low[0];\\n            set.remove(low);\\n        }else if(heigh != null && heigh[0] == value + 1){\\n            // [3, 3] insert [2, 2]\\n            heigh[0] = value;\\n        }else if(low != null && low[1] == value - 1){\\n            // [1, 1] insert [2, 2]\\n            low[1] = value;\\n        }else if((heigh != null && heigh[0] == value) || (low != null && low[0] <= value && low[1] >= value)){\\n            // [2, 3] insert [2, 2]\\n            // [1, 3] insert [2, 2]\\n            return;\\n        }else{\\n            set.add(m);\\n        }\\n    } \\n    \\n    public int[][] getIntervals(){\\n        List<int[]> res = new ArrayList<>();\\n        for(int[] s: set){\\n            res.add(s);\\n        }\\n        return res.toArray(new int[0][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109007,
                "title": "c-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\nkeep unique items in the list and then search for increasing index\\n\\n# Approach\\nstore the initial element and look for increasing indices(+1).\\n# Code\\n```\\nclass SummaryRanges {\\npublic:\\nvector<int> a;\\nvector<int>::iterator it;\\n    SummaryRanges() {}\\n    void addNum(int val) {\\n        it=find(a.begin(),a.end(),val);\\n        if(it==a.end())//store unique items\\n        a.push_back(val);\\n    }\\n    int solution(vector<int>& a,int i){\\n        int j=0;\\n        for(int k=i;k<a.size();k++){\\n            if(a[k]==a[i]+j){//increasing elements\\n                j++;\\n                continue;\\n            }\\n            else return k-1;//last increasing or same element \\n        }\\n        return a.size()-1;//if all elements are set\\n    }\\n    vector<vector<int>> getIntervals() {\\n        sort(a.begin(),a.end());\\n        vector<vector<int>> ans;\\n         vector<int> d;\\n        for(int i=0;i<a.size();i++){\\n            d={};\\n            d.push_back(a[i]);//store inital  element\\n            i=solution(a,i);//update the index\\n            d.push_back(a[i]);\\n            ans.push_back(d);\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(val);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SummaryRanges {\\npublic:\\nvector<int> a;\\nvector<int>::iterator it;\\n    SummaryRanges() {}\\n    void addNum(int val) {\\n        it=find(a.begin(),a.end(),val);\\n        if(it==a.end())//store unique items\\n        a.push_back(val);\\n    }\\n    int solution(vector<int>& a,int i){\\n        int j=0;\\n        for(int k=i;k<a.size();k++){\\n            if(a[k]==a[i]+j){//increasing elements\\n                j++;\\n                continue;\\n            }\\n            else return k-1;//last increasing or same element \\n        }\\n        return a.size()-1;//if all elements are set\\n    }\\n    vector<vector<int>> getIntervals() {\\n        sort(a.begin(),a.end());\\n        vector<vector<int>> ans;\\n         vector<int> d;\\n        for(int i=0;i<a.size();i++){\\n            d={};\\n            d.push_back(a[i]);//store inital  element\\n            i=solution(a,i);//update the index\\n            d.push_back(a[i]);\\n            ans.push_back(d);\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(val);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108838,
                "title": "leetcode-daily-challenge-easiest-solution",
                "content": "\\n\\n# Approach\\nFor example we have vector like 1,2,4,5\\nFirstly take all the values as separate interval like [1,1], [2,2], [4,4], [5,5] and then merge continous range [1,2] & [4,5] we cannot write [1,5] as 3 is not present in the vector so we have break there.\\n\\n# Complexity\\n- Time complexity:\\n  TIME COMPLEXITY: O(n + nlogn)\\n\\n- Space complexity:\\n  SPACE COMPLEXITY:O(n)\\n\\n# Code\\n```\\nclass SummaryRanges\\n{\\npublic:\\n  set<int> v;\\n  SummaryRanges()\\n  {\\n  }\\n\\n  void addNum(int value)\\n  {\\n    v.insert(value);\\n  }\\n\\n  vector<vector<int>> getIntervals()\\n  {\\n    vector<vector<int>> ans;\\n\\n    for (auto x = v.begin(); x != v.end(); x++)\\n    {\\n      int ct = *x;\\n      auto y = x;\\n      y++;\\n      for (; y != v.end(); y++) // Merging the interval i.e taking continous values\\n      {\\n        if (*y == ct + 1)\\n          ct++;\\n        else\\n          break;\\n      }\\n      ans.push_back({*x, ct});\\n      y--;\\n      x = y;\\n    }\\n    return ans;\\n  }\\n};\\n// TIME COMPLEXITY: O(nlogn)\\n// SPACE COMPLEXITY:O(n)\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SummaryRanges\\n{\\npublic:\\n  set<int> v;\\n  SummaryRanges()\\n  {\\n  }\\n\\n  void addNum(int value)\\n  {\\n    v.insert(value);\\n  }\\n\\n  vector<vector<int>> getIntervals()\\n  {\\n    vector<vector<int>> ans;\\n\\n    for (auto x = v.begin(); x != v.end(); x++)\\n    {\\n      int ct = *x;\\n      auto y = x;\\n      y++;\\n      for (; y != v.end(); y++) // Merging the interval i.e taking continous values\\n      {\\n        if (*y == ct + 1)\\n          ct++;\\n        else\\n          break;\\n      }\\n      ans.push_back({*x, ct});\\n      y--;\\n      x = y;\\n    }\\n    return ans;\\n  }\\n};\\n// TIME COMPLEXITY: O(nlogn)\\n// SPACE COMPLEXITY:O(n)\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108776,
                "title": "ruby-solution",
                "content": "# Code\\n```ruby []\\nclass SummaryRanges\\n  def initialize()\\n    @ranges = []\\n  end\\n\\n=begin\\n  :type value: Integer\\n  :rtype: Void\\n=end\\n  def add_num(value)\\n    index = @ranges.bsearch_index {|first, last| last >= value}\\n\\n    if index\\n      return if value.between?(*@ranges[index])\\n    else\\n      index = @ranges.size\\n    end\\n\\n    @ranges.insert(index, [value, value])\\n\\n    if index > 0 && necessary_merge_with_previous_one?(index)\\n      merge_interval_with_previous_one(index)\\n    else\\n      index += 1\\n    end\\n    \\n    if @ranges[index] && necessary_merge_with_previous_one?(index)\\n      merge_interval_with_previous_one(index)\\n    end\\n\\n  end\\n\\n  def necessary_merge_with_previous_one?(index)\\n    (@ranges[index].first - @ranges[index - 1].last) <= 1\\n  end\\n\\n  def merge_interval_with_previous_one(index)\\n    @ranges[index - 1][1] = @ranges.delete_at(index).last\\n  end\\n  \\n=begin\\n  :rtype: Integer[][]\\n=end\\n  def get_intervals()\\n    @ranges\\n  end\\n\\nend\\n\\n# Your SummaryRanges object will be instantiated and called as such:\\n# obj = SummaryRanges.new()\\n# obj.add_num(value)\\n# param_2 = obj.get_intervals()\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby []\\nclass SummaryRanges\\n  def initialize()\\n    @ranges = []\\n  end\\n\\n=begin\\n  :type value: Integer\\n  :rtype: Void\\n=end\\n  def add_num(value)\\n    index = @ranges.bsearch_index {|first, last| last >= value}\\n\\n    if index\\n      return if value.between?(*@ranges[index])\\n    else\\n      index = @ranges.size\\n    end\\n\\n    @ranges.insert(index, [value, value])\\n\\n    if index > 0 && necessary_merge_with_previous_one?(index)\\n      merge_interval_with_previous_one(index)\\n    else\\n      index += 1\\n    end\\n    \\n    if @ranges[index] && necessary_merge_with_previous_one?(index)\\n      merge_interval_with_previous_one(index)\\n    end\\n\\n  end\\n\\n  def necessary_merge_with_previous_one?(index)\\n    (@ranges[index].first - @ranges[index - 1].last) <= 1\\n  end\\n\\n  def merge_interval_with_previous_one(index)\\n    @ranges[index - 1][1] = @ranges.delete_at(index).last\\n  end\\n  \\n=begin\\n  :rtype: Integer[][]\\n=end\\n  def get_intervals()\\n    @ranges\\n  end\\n\\nend\\n\\n# Your SummaryRanges object will be instantiated and called as such:\\n# obj = SummaryRanges.new()\\n# obj.add_num(value)\\n# param_2 = obj.get_intervals()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108431,
                "title": "easy-c-using-priority-queue-no-binary-search-easy-to-undestand",
                "content": "* ***Approach one : Using Priority Queue***\\n*Wrong Answer*\\n\\n```\\nclass SummaryRanges {\\npublic:\\n    \\n    priority_queue<int, vector<int>, greater<int>> pq;\\n    \\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int value) {\\n        \\n        pq.push(value);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        \\n        vector<vector<int>> ans;\\n        if(pq.empty()) return ans;\\n        priority_queue<int, vector<int>, greater<int>> copy = pq; \\n        while(!copy.empty()) {\\n            vector<int> temp;\\n            int first = copy.top();\\n            copy.pop();\\n            temp.push_back(first);\\n            first++;\\n            while(!copy.empty() and copy.top() == first) {\\n                first++;\\n                copy.pop();\\n            }\\n            temp.push_back(first-1);\\n            ans.push_back(temp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n* **Found the mistake in above code**\\n* **What was it?**\\n\\t* *I was pushing elements in the queue without checking for duplicates, as we are finding the range, we don\\'t need to add the same element twice, it will be entertained in the same range.*\\n* **Solution**\\n\\t* *I keep a set for unique values. If the value is not present in the set then only I will the value.*\\n\\n* ***Priority Queue with Unordered Set***\\n\\t* **Accepted**\\n\\n```\\nclass SummaryRanges {\\npublic:\\n    \\n    priority_queue<int, vector<int>, greater<int>> pq;\\n    unordered_set<int> st;\\n    \\n    SummaryRanges() { }\\n    \\n    void addNum(int value) {\\n        \\n        if(!st.count(value)) {\\n            pq.push(value);\\n            st.insert(value);\\n        }\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        \\n        vector<vector<int>> ans;\\n        if(pq.empty()) return ans;\\n        priority_queue<int, vector<int>, greater<int>> copy = pq; \\n        while(!copy.empty()) {\\n            vector<int> temp;\\n            int first = copy.top();\\n            copy.pop();\\n            temp.push_back(first);\\n            first++;\\n            while(!copy.empty() and copy.top() == first) {\\n                first++;\\n                copy.pop();\\n            }\\n            temp.push_back(first-1);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SummaryRanges {\\npublic:\\n    \\n    priority_queue<int, vector<int>, greater<int>> pq;\\n    \\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int value) {\\n        \\n        pq.push(value);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        \\n        vector<vector<int>> ans;\\n        if(pq.empty()) return ans;\\n        priority_queue<int, vector<int>, greater<int>> copy = pq; \\n        while(!copy.empty()) {\\n            vector<int> temp;\\n            int first = copy.top();\\n            copy.pop();\\n            temp.push_back(first);\\n            first++;\\n            while(!copy.empty() and copy.top() == first) {\\n                first++;\\n                copy.pop();\\n            }\\n            temp.push_back(first-1);\\n            ans.push_back(temp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass SummaryRanges {\\npublic:\\n    \\n    priority_queue<int, vector<int>, greater<int>> pq;\\n    unordered_set<int> st;\\n    \\n    SummaryRanges() { }\\n    \\n    void addNum(int value) {\\n        \\n        if(!st.count(value)) {\\n            pq.push(value);\\n            st.insert(value);\\n        }\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        \\n        vector<vector<int>> ans;\\n        if(pq.empty()) return ans;\\n        priority_queue<int, vector<int>, greater<int>> copy = pq; \\n        while(!copy.empty()) {\\n            vector<int> temp;\\n            int first = copy.top();\\n            copy.pop();\\n            temp.push_back(first);\\n            first++;\\n            while(!copy.empty() and copy.top() == first) {\\n                first++;\\n                copy.pop();\\n            }\\n            temp.push_back(first-1);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108385,
                "title": "easy-to-understand-simple-code",
                "content": "# Intuition\\njust we will insert all the elements in the ordered_Set and we will iterate through the set and we will store the prev pair and check the last element of prev is just 1 greater than the current element\\n# Complexity\\n- Time complexity:\\nO(log(n)) for addNum() and O(n) for getIntervals()\\n\\n# Code\\n```\\nclass SummaryRanges {\\npublic:\\nset<int>s;\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int val) {\\n      s.insert(val);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>>intervals;\\n        vector<int>prev(2,-1);\\n        for(auto i:s)\\n        {\\n            if(prev[0]==-1)\\n            {\\n                prev={i,i};\\n            }\\n         else if(i==prev[1]+1)\\n          {\\n              prev[1]=i;\\n          }\\n          else\\n          {\\n              intervals.push_back({prev[0],prev[1]});\\n              prev={i,i};\\n          }\\n        }\\n        intervals.push_back(prev);\\n        return intervals;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass SummaryRanges {\\npublic:\\nset<int>s;\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int val) {\\n      s.insert(val);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>>intervals;\\n        vector<int>prev(2,-1);\\n        for(auto i:s)\\n        {\\n            if(prev[0]==-1)\\n            {\\n                prev={i,i};\\n            }\\n         else if(i==prev[1]+1)\\n          {\\n              prev[1]=i;\\n          }\\n          else\\n          {\\n              intervals.push_back({prev[0],prev[1]});\\n              prev={i,i};\\n          }\\n        }\\n        intervals.push_back(prev);\\n        return intervals;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108162,
                "title": "simple-solution-using-union-find",
                "content": "# Intuition\\nDisjoint set union\\n\\n# Approach\\nUsing disjoint set union we find ans keep record of the start and end of interval  the number is in .\\n\\n# Complexity\\n- Time complexity:\\n- log(N) for finding start and end and O(N) for finding the set.\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n int n=1e5;\\n    vector<int> kp(n);\\n    vector<int> st(n),en(n);\\nclass SummaryRanges {\\n    public:\\n    int ma=0,mi=1e9;\\n    int fi(int val,vector<int> &par)\\n    {\\n        if(val==par[val])\\n        return val;\\n        return par[val]=fi(par[val],par);\\n    }\\n   \\n\\n    SummaryRanges() {\\n       \\n        for(int i=0;i<n;i++)\\n        kp[i]=0;\\n         for(int i=0;i<n;i++)\\n        st[i]=0;\\n         for(int i=0;i<n;i++)\\n        en[i]=0;\\n    }\\n    \\n    void addNum(int val) {\\n        kp[val]=1;\\n        if(val==0||kp[val-1]==0)\\n        {\\n            st[val]=val;\\n        }\\n        else\\n        {\\n            st[val]=fi(val-1,st);\\n            en[val-1]=val;\\n\\n        }\\n        if(kp[val+1]==0)\\n        {\\n            en[val]=val;\\n        }\\n        else\\n        {\\n            en[val]=fi(val+1,en);\\n            st[val+1]=val;\\n        }\\n        // int f1=fi(val,st);\\n        //  en[f1]=f1()\\n        ma=max(val,ma);\\n        mi=min(mi,val);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> ans;\\n        if(mi==1e9)\\n        return ans;\\n        for(int i=mi;i<=ma;i++)\\n        {\\n           // cout<<i<<\" \"<<st[i]<<\" \"<<en[i]<<endl;\\n            if(st[i]==i)\\n            {\\n                ans.push_back({i,fi(i,en)});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\n int n=1e5;\\n    vector<int> kp(n);\\n    vector<int> st(n),en(n);\\nclass SummaryRanges {\\n    public:\\n    int ma=0,mi=1e9;\\n    int fi(int val,vector<int> &par)\\n    {\\n        if(val==par[val])\\n        return val;\\n        return par[val]=fi(par[val],par);\\n    }\\n   \\n\\n    SummaryRanges() {\\n       \\n        for(int i=0;i<n;i++)\\n        kp[i]=0;\\n         for(int i=0;i<n;i++)\\n        st[i]=0;\\n         for(int i=0;i<n;i++)\\n        en[i]=0;\\n    }\\n    \\n    void addNum(int val) {\\n        kp[val]=1;\\n        if(val==0||kp[val-1]==0)\\n        {\\n            st[val]=val;\\n        }\\n        else\\n        {\\n            st[val]=fi(val-1,st);\\n            en[val-1]=val;\\n\\n        }\\n        if(kp[val+1]==0)\\n        {\\n            en[val]=val;\\n        }\\n        else\\n        {\\n            en[val]=fi(val+1,en);\\n            st[val+1]=val;\\n        }\\n        // int f1=fi(val,st);\\n        //  en[f1]=f1()\\n        ma=max(val,ma);\\n        mi=min(mi,val);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> ans;\\n        if(mi==1e9)\\n        return ans;\\n        for(int i=mi;i<=ma;i++)\\n        {\\n           // cout<<i<<\" \"<<st[i]<<\" \"<<en[i]<<endl;\\n            if(st[i]==i)\\n            {\\n                ans.push_back({i,fi(i,en)});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3107991,
                "title": "hey-could-you-retrieve-element-in-constant-time",
                "content": "![memecat.jpeg](https://assets.leetcode.com/users/images/0bd22b15-c7ec-417e-8fbd-bc4a82087c1a_1674887109.218613.jpeg)\\n\\n![image.png](https://assets.leetcode.com/users/images/a1bf9850-e9f4-40b2-84e5-d5f01d895b4c_1674887570.0530128.png)\\n\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nprivate ArrayList<int[]> intervals;\\npublic SummaryRanges() {\\n    intervals = new ArrayList<>();\\n}\\n```\\n```\\npublic void addNum(int value) {\\n    if (intervals.isEmpty()) {\\n        intervals.add(new int[]{value, value});\\n        return;\\n    } int start = 0, end = intervals.size() - 1;\\n    while (start < end) {\\n        int middle = (start + end) / 2, currentInterval[] = intervals.get(middle), currentLowRange = currentInterval[0], currentHighRange = currentInterval[1];\\n        if (value < currentLowRange - 1) {\\n            end = middle - 1;\\n            continue;\\n        } if (value > currentHighRange + 1) {\\n                start = middle + 1;\\n                continue;\\n            } // value >= currentLowRange - 1 && value <= currentHighRange + 1, so it\\'s in range\\n            addValueToRange(value, middle);\\n            return;\\n        }\\n        if (start == end && value >= intervals.get(start)[0] - 1 && value <= intervals.get(start)[1] + 1) {\\n            addValueToRange(value, start);\\n            return;\\n        }int index = Math.max(start, end);\\n        while (index >= 0 && intervals.get(index)[0] > value)   index--;\\n        intervals.add(index + 1, new int[]{value, value});\\n}\\n```\\n```\\nprivate void addValueToRange(int value, int index) {\\n    int[] interval = intervals.get(index);\\n    int lowRange = interval[0], highRange = interval[1];\\n    if (index > 0 && value == lowRange - 1 && intervals.get(index - 1)[1] + 1 >= value) {// ex. 3-3 5-6 [insert 4] - merge with left one\\n        intervals.get(index - 1)[1] = highRange;\\n        intervals.remove(index);\\n        return;\\n    } else if (index + 1 < intervals.size() && value == highRange + 1 && intervals.get(index + 1)[0] - 1 <= value) { // ex. 3-3 [insert 4] 5-6 - merge with right\\n        intervals.get(index)[1] = intervals.get(index + 1)[1];\\n        intervals.remove(index + 1);\\n        return;\\n    }\\n    if (value == lowRange - 1) intervals.get(index)[0] = value;\\n    else if (value == highRange + 1) intervals.get(index)[1] = value;\\n}\\n```\\n```\\npublic int[][] getIntervals() {\\n    int[][] results = new int[intervals.size()][];\\n    for (int i = 0; i < intervals.size(); i++) {\\n        results[i] = intervals.get(i);\\n    } return results;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Design"
                ],
                "code": "```\\nprivate ArrayList<int[]> intervals;\\npublic SummaryRanges() {\\n    intervals = new ArrayList<>();\\n}\\n```\n```\\npublic void addNum(int value) {\\n    if (intervals.isEmpty()) {\\n        intervals.add(new int[]{value, value});\\n        return;\\n    } int start = 0, end = intervals.size() - 1;\\n    while (start < end) {\\n        int middle = (start + end) / 2, currentInterval[] = intervals.get(middle), currentLowRange = currentInterval[0], currentHighRange = currentInterval[1];\\n        if (value < currentLowRange - 1) {\\n            end = middle - 1;\\n            continue;\\n        } if (value > currentHighRange + 1) {\\n                start = middle + 1;\\n                continue;\\n            } // value >= currentLowRange - 1 && value <= currentHighRange + 1, so it\\'s in range\\n            addValueToRange(value, middle);\\n            return;\\n        }\\n        if (start == end && value >= intervals.get(start)[0] - 1 && value <= intervals.get(start)[1] + 1) {\\n            addValueToRange(value, start);\\n            return;\\n        }int index = Math.max(start, end);\\n        while (index >= 0 && intervals.get(index)[0] > value)   index--;\\n        intervals.add(index + 1, new int[]{value, value});\\n}\\n```\n```\\nprivate void addValueToRange(int value, int index) {\\n    int[] interval = intervals.get(index);\\n    int lowRange = interval[0], highRange = interval[1];\\n    if (index > 0 && value == lowRange - 1 && intervals.get(index - 1)[1] + 1 >= value) {// ex. 3-3 5-6 [insert 4] - merge with left one\\n        intervals.get(index - 1)[1] = highRange;\\n        intervals.remove(index);\\n        return;\\n    } else if (index + 1 < intervals.size() && value == highRange + 1 && intervals.get(index + 1)[0] - 1 <= value) { // ex. 3-3 [insert 4] 5-6 - merge with right\\n        intervals.get(index)[1] = intervals.get(index + 1)[1];\\n        intervals.remove(index + 1);\\n        return;\\n    }\\n    if (value == lowRange - 1) intervals.get(index)[0] = value;\\n    else if (value == highRange + 1) intervals.get(index)[1] = value;\\n}\\n```\n```\\npublic int[][] getIntervals() {\\n    int[][] results = new int[intervals.size()][];\\n    for (int i = 0; i < intervals.size(); i++) {\\n        results[i] = intervals.get(i);\\n    } return results;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3107866,
                "title": "java-treemap-o-log-n-insertion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse a TreeMap to store intervals, where the key is the start of an interval and the value is the end. A TreeMap will naturally sort all the keys (beginning of the intervals) in ascending order.\\n\\n# Complexity\\n- Time complexity: $$O(log(N))$$ for addNum, $$O(N)$$ for getIntervals.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SummaryRanges {\\n  TreeMap<Integer, Integer> map;\\n\\n  public SummaryRanges() {\\n    map = new TreeMap<>();\\n  }\\n  \\n  public void addNum(int value) {\\n    var f = map.floorEntry(value);\\n    var c = map.ceilingEntry(value);\\n\\n    // Case: value is part of an existing interval, do nothing.\\n    if ((f != null && value >= f.getKey() && value <= f.getValue())\\n        || (c != null && value >= c.getKey() && value <= c.getValue()))\\n      return;\\n\\n    // Case: value is not part of any existing interval, create a new interval.\\n    if ((f == null || value - f.getValue() > 1)\\n        && (c == null || c.getKey() - value > 1)) {\\n      map.put(value, value);\\n      return;\\n    }\\n    // Case: value must be merged with both the prior and subsequent intervals.\\n    if (f != null && value - f.getValue() == 1\\n        && c != null && c.getKey() - value == 1) {\\n      map.put(f.getKey(), c.getValue());\\n      map.remove(c.getKey());\\n      return;\\n    }\\n    // Case: value must be merged with only the prior interval.\\n    if (f != null && value - f.getValue() == 1) {\\n      map.put(f.getKey(), value);\\n    } else {\\n      // Case: value must be merged with only the subsequent interval.\\n      map.put(value, c.getValue());\\n      map.remove(c.getKey());\\n    }\\n  }\\n  \\n  public int[][] getIntervals() {\\n    var res = new int[map.size()][2];\\n    var i = 0;\\n\\n    for (var entry : map.entrySet()) {\\n      res[i][0] = entry.getKey();\\n      res[i++][1] = entry.getValue();\\n    }\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Map"
                ],
                "code": "```\\nclass SummaryRanges {\\n  TreeMap<Integer, Integer> map;\\n\\n  public SummaryRanges() {\\n    map = new TreeMap<>();\\n  }\\n  \\n  public void addNum(int value) {\\n    var f = map.floorEntry(value);\\n    var c = map.ceilingEntry(value);\\n\\n    // Case: value is part of an existing interval, do nothing.\\n    if ((f != null && value >= f.getKey() && value <= f.getValue())\\n        || (c != null && value >= c.getKey() && value <= c.getValue()))\\n      return;\\n\\n    // Case: value is not part of any existing interval, create a new interval.\\n    if ((f == null || value - f.getValue() > 1)\\n        && (c == null || c.getKey() - value > 1)) {\\n      map.put(value, value);\\n      return;\\n    }\\n    // Case: value must be merged with both the prior and subsequent intervals.\\n    if (f != null && value - f.getValue() == 1\\n        && c != null && c.getKey() - value == 1) {\\n      map.put(f.getKey(), c.getValue());\\n      map.remove(c.getKey());\\n      return;\\n    }\\n    // Case: value must be merged with only the prior interval.\\n    if (f != null && value - f.getValue() == 1) {\\n      map.put(f.getKey(), value);\\n    } else {\\n      // Case: value must be merged with only the subsequent interval.\\n      map.put(value, c.getValue());\\n      map.remove(c.getKey());\\n    }\\n  }\\n  \\n  public int[][] getIntervals() {\\n    var res = new int[map.size()][2];\\n    var i = 0;\\n\\n    for (var entry : map.entrySet()) {\\n      res[i][0] = entry.getKey();\\n      res[i++][1] = entry.getValue();\\n    }\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107790,
                "title": "simple-beginner-friendly-solution-using-set-without-binary-search-or-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to give the output from getIntervals() function in a sorted order so we\\'ll use set ans also to solve questions in which we require intervals the data must be in sorted form\\n\\nPlease have a dry run on the code and the solution will become crystal clear\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SummaryRanges {\\n    set<int>s;\\npublic:\\n    SummaryRanges() {\\n        s.clear();\\n    }\\n    \\n    void addNum(int value) {\\n        s.insert(value);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>>ans;\\n        vector<int>temp;\\n        // temp.push_back(*s.begin());\\n        int prev=-1;\\n        for(auto i:s)\\n        {\\n            if(temp.size()==0){\\n                temp.push_back(i);\\n                prev=i;\\n            }\\n            else if(prev+1==i){\\n                prev=i;\\n            }else{\\n                temp.push_back(prev);\\n                ans.push_back(temp);\\n                temp.clear();\\n                temp.push_back(i);\\n                prev=i;\\n            }\\n        }\\n        if(temp.size()==1)temp.push_back(prev);\\n        ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass SummaryRanges {\\n    set<int>s;\\npublic:\\n    SummaryRanges() {\\n        s.clear();\\n    }\\n    \\n    void addNum(int value) {\\n        s.insert(value);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>>ans;\\n        vector<int>temp;\\n        // temp.push_back(*s.begin());\\n        int prev=-1;\\n        for(auto i:s)\\n        {\\n            if(temp.size()==0){\\n                temp.push_back(i);\\n                prev=i;\\n            }\\n            else if(prev+1==i){\\n                prev=i;\\n            }else{\\n                temp.push_back(prev);\\n                ans.push_back(temp);\\n                temp.clear();\\n                temp.push_back(i);\\n                prev=i;\\n            }\\n        }\\n        if(temp.size()==1)temp.push_back(prev);\\n        ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107737,
                "title": "cpp-maps-solve-solving",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nusing map and starting to iterate over map and create the vector\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nconsecutive elements are reffer as the intervals [1,2,3] as [1,3]\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SummaryRanges {\\npublic:\\n    map<int,int> mapp;\\n    SummaryRanges() {   \\n    }\\n    void addNum(int value) {\\n    mapp[value]++;    \\n    }\\n    vector<vector<int>> getIntervals() {\\n      vector<vector<int>> sols;\\n      int prev;\\n      for(auto it=mapp.begin();it!=mapp.end();it++){\\n       vector<int> sss;\\n       if(it==mapp.begin()){\\n        sss.push_back(it->first);\\n        sss.push_back(it->first);\\n        prev=it->first;\\n        mapsols.push_back(sss);}\\n       else if(prev+1==it->first)\\n        {\\n        sols[sols.size()-1][1]=it->first;\\n        prev=it->first;\\n        }\\n       else\\n       {    \\n        sss.push_back(it->first);\\n        sss.push_back(it->first);\\n        prev=it->first;\\n        sols.push_back(sss);\\n       }\\n      }\\n      return sols;  \\n    }\\n};\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass SummaryRanges {\\npublic:\\n    map<int,int> mapp;\\n    SummaryRanges() {   \\n    }\\n    void addNum(int value) {\\n    mapp[value]++;    \\n    }\\n    vector<vector<int>> getIntervals() {\\n      vector<vector<int>> sols;\\n      int prev;\\n      for(auto it=mapp.begin();it!=mapp.end();it++){\\n       vector<int> sss;\\n       if(it==mapp.begin()){\\n        sss.push_back(it->first);\\n        sss.push_back(it->first);\\n        prev=it->first;\\n        mapsols.push_back(sss);}\\n       else if(prev+1==it->first)\\n        {\\n        sols[sols.size()-1][1]=it->first;\\n        prev=it->first;\\n        }\\n       else\\n       {    \\n        sss.push_back(it->first);\\n        sss.push_back(it->first);\\n        prev=it->first;\\n        sols.push_back(sss);\\n       }\\n      }\\n      return sols;  \\n    }\\n};\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107658,
                "title": "ruby-intuitive-solution",
                "content": "# Approach\\nWe need a sorted array to create the correct ranges. Therefore, to insert a new element, we use bsearch_index. Ruby has a built-in method, but it might be correct to write it yourself. In any case, the idea here is important, we need to always keep the array sorted.\\n\\nTo create periods, we use an intuitive approach, go through the **list** and accumulate values in the temporary **current_range**. Also we store **last_element**.\\nIf the next value from the **list** is more than the **last_element** by more than 1, then we put the **current_range** into the result, take the first and last value.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log n)$$ for add_num\\n$$O(n)$$ for get_intervals\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass SummaryRanges\\n    def initialize()\\n        @list = []\\n    end\\n\\n=begin\\n    :type value: Integer\\n    :rtype: Void\\n=end\\n    def add_num(value)\\n        position = find_insert_position(value)\\n        @list.insert(position, value)\\n    end\\n\\n=begin\\n    :rtype: Integer[][]\\n=end\\n    def get_intervals()    \\n        result = []\\n        last_elem = @list.first\\n        current_range = [last_elem]\\n        @list.each do |elem|\\n            if elem - last_elem <= 1\\n                current_range << elem\\n            else\\n                result << [current_range.first, current_range.last]\\n\\n                current_range = [elem]\\n            end\\n\\n            last_elem = elem\\n        end\\n\\n        result << [current_range.first, current_range.last]\\n\\n        result\\n    end\\n\\n    def find_insert_position(value)\\n        @list.bsearch_index {|x| x >= value } || @list.size\\n    end\\nend\\n\\n# Your SummaryRanges object will be instantiated and called as such:\\n# obj = SummaryRanges.new()\\n# obj.add_num(value)\\n# param_2 = obj.get_intervals()\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nclass SummaryRanges\\n    def initialize()\\n        @list = []\\n    end\\n\\n=begin\\n    :type value: Integer\\n    :rtype: Void\\n=end\\n    def add_num(value)\\n        position = find_insert_position(value)\\n        @list.insert(position, value)\\n    end\\n\\n=begin\\n    :rtype: Integer[][]\\n=end\\n    def get_intervals()    \\n        result = []\\n        last_elem = @list.first\\n        current_range = [last_elem]\\n        @list.each do |elem|\\n            if elem - last_elem <= 1\\n                current_range << elem\\n            else\\n                result << [current_range.first, current_range.last]\\n\\n                current_range = [elem]\\n            end\\n\\n            last_elem = elem\\n        end\\n\\n        result << [current_range.first, current_range.last]\\n\\n        result\\n    end\\n\\n    def find_insert_position(value)\\n        @list.bsearch_index {|x| x >= value } || @list.size\\n    end\\nend\\n\\n# Your SummaryRanges object will be instantiated and called as such:\\n# obj = SummaryRanges.new()\\n# obj.add_num(value)\\n# param_2 = obj.get_intervals()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107610,
                "title": "c-set-easy-way",
                "content": "```\\nclass SummaryRanges {\\npublic:\\n    set<int>st; //initialize set\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int value) {\\n        st.insert(value); //adding value in set\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>>ans; \\n        vector<int>t(st.begin(),st.end()); // converting set to vector for better traversing [for me :)]\\n        int i = 0;\\n        while(i<t.size())\\n        {\\n            int start = t[i]; //start of interval\\n\\t\\t\\t\\n\\t\\t\\t//while there is values whose difference is 1 just consider it.. in the range\\n            while(i+1<t.size() and t[i]+1 == t[i+1])\\n            {\\n                i++;\\n            }\\n            ans.push_back({start,t[i]});\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass SummaryRanges {\\npublic:\\n    set<int>st; //initialize set\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int value) {\\n        st.insert(value); //adding value in set\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>>ans; \\n        vector<int>t(st.begin(),st.end()); // converting set to vector for better traversing [for me :)]\\n        int i = 0;\\n        while(i<t.size())\\n        {\\n            int start = t[i]; //start of interval\\n\\t\\t\\t\\n\\t\\t\\t//while there is values whose difference is 1 just consider it.. in the range\\n            while(i+1<t.size() and t[i]+1 == t[i+1])\\n            {\\n                i++;\\n            }\\n            ans.push_back({start,t[i]});\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107334,
                "title": "c-simple",
                "content": "# Code\\n```\\npublic class SummaryRanges \\n{\\n    private SortedSet<int> values;\\n    public SummaryRanges() \\n    {\\n        values = new SortedSet<int>();\\n    }\\n    public void AddNum(int value) => values.Add(value);\\n    public int[][] GetIntervals() \\n    {\\n        if (values.Count == 0) return new int[0][];\\n        List<int[]> intervals = new List<int[]>();\\n        int left = -1, right = -1;\\n        foreach (int value in values) \\n        {\\n            if (left < 0) left = right = value;\\n            else if (value == right + 1) right = value;\\n            else\\n            {\\n                intervals.Add(new int[] {left, right});\\n                left = right = value;\\n            } \\n        }\\n        intervals.Add(new int[] {left, right});\\n        return intervals.ToArray(); \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class SummaryRanges \\n{\\n    private SortedSet<int> values;\\n    public SummaryRanges() \\n    {\\n        values = new SortedSet<int>();\\n    }\\n    public void AddNum(int value) => values.Add(value);\\n    public int[][] GetIntervals() \\n    {\\n        if (values.Count == 0) return new int[0][];\\n        List<int[]> intervals = new List<int[]>();\\n        int left = -1, right = -1;\\n        foreach (int value in values) \\n        {\\n            if (left < 0) left = right = value;\\n            else if (value == right + 1) right = value;\\n            else\\n            {\\n                intervals.Add(new int[] {left, right});\\n                left = right = value;\\n            } \\n        }\\n        intervals.Add(new int[] {left, right});\\n        return intervals.ToArray(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107244,
                "title": "easy-c-solution-faster",
                "content": "# Code\\n```\\nclass SummaryRanges {\\n public:\\n  void addNum(int val) {\\n    if (map.count(val))\\n      return;\\n\\n    const int lo = lowerKey(val);\\n    const int hi = higherKey(val);\\n\\n\\n    if (lo >= 0 && hi >= 0 && map[lo][1] + 1 == val && val + 1 == hi) {\\n      map[lo][1] = map[hi][1];\\n      map.erase(hi);\\n      \\n    } else if (lo >= 0 && map[lo][1] + 1 >= val) {\\n      map[lo][1] = max(map[lo][1], val);\\n    } else if (hi >= 0 && val + 1 == hi) {\\n      map[val] = {val, map[hi][1]};\\n      map.erase(hi);\\n    } else {\\n      map[val] = {val, val};\\n    }\\n  }\\n\\n  vector<vector<int>> getIntervals() {\\n    vector<vector<int>> intervals;\\n    for (const auto& [_, interval] : map)\\n      intervals.push_back(interval);\\n    return intervals;\\n  }\\n\\n private:\\n  map<int, vector<int>> map;\\n\\n  int lowerKey(int key) {\\n    auto it = map.lower_bound(key);  \\n    if (it == begin(map))\\n      return -1;\\n    return (--it)->first;\\n  }\\n\\n  int higherKey(int key) {\\n    const auto it = map.upper_bound(key);\\n    if (it == cend(map))\\n      return -1;\\n    return it->first;\\n  }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SummaryRanges {\\n public:\\n  void addNum(int val) {\\n    if (map.count(val))\\n      return;\\n\\n    const int lo = lowerKey(val);\\n    const int hi = higherKey(val);\\n\\n\\n    if (lo >= 0 && hi >= 0 && map[lo][1] + 1 == val && val + 1 == hi) {\\n      map[lo][1] = map[hi][1];\\n      map.erase(hi);\\n      \\n    } else if (lo >= 0 && map[lo][1] + 1 >= val) {\\n      map[lo][1] = max(map[lo][1], val);\\n    } else if (hi >= 0 && val + 1 == hi) {\\n      map[val] = {val, map[hi][1]};\\n      map.erase(hi);\\n    } else {\\n      map[val] = {val, val};\\n    }\\n  }\\n\\n  vector<vector<int>> getIntervals() {\\n    vector<vector<int>> intervals;\\n    for (const auto& [_, interval] : map)\\n      intervals.push_back(interval);\\n    return intervals;\\n  }\\n\\n private:\\n  map<int, vector<int>> map;\\n\\n  int lowerKey(int key) {\\n    auto it = map.lower_bound(key);  \\n    if (it == begin(map))\\n      return -1;\\n    return (--it)->first;\\n  }\\n\\n  int higherKey(int key) {\\n    const auto it = map.upper_bound(key);\\n    if (it == cend(map))\\n      return -1;\\n    return it->first;\\n  }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2705502,
                "title": "simple-map-and-check-array",
                "content": "```\\nint check[10001]={0};\\n    map<int,int> map;\\n    SummaryRanges() {\\n        \\n    }\\n    void addNum(int value) {\\n        check[value]=1;\\n        int start=value,end=value;\\n        while(start>0&&check[start-1]==1)\\n        {\\n            start--;\\n            map.erase(start);//have to erase if previously this start was any starting index\\n        }\\n        while(end<10000 && check[end+1]==1)\\n        {\\n            end++;\\n            map.erase(end);//have to erase if previously this end was any ending index\\n        }\\n        map[start]=end;//add new range to map\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> ans;\\n        for(auto i:map)\\n            ans.push_back({i.first,i.second});//i.first contains start ans i.second end of range\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\nint check[10001]={0};\\n    map<int,int> map;\\n    SummaryRanges() {\\n        \\n    }\\n    void addNum(int value) {\\n        check[value]=1;\\n        int start=value,end=value;\\n        while(start>0&&check[start-1]==1)\\n        {\\n            start--;\\n            map.erase(start);//have to erase if previously this start was any starting index\\n        }\\n        while(end<10000 && check[end+1]==1)\\n        {\\n            end++;\\n            map.erase(end);//have to erase if previously this end was any ending index\\n        }\\n        map[start]=end;//add new range to map\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> ans;\\n        for(auto i:map)\\n            ans.push_back({i.first,i.second});//i.first contains start ans i.second end of range\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2344279,
                "title": "c-sorteddictionary",
                "content": "Here we are stroring the intervals sorted by the interval start. Note that each interval is stored twice - at the both ends of the interval. Expanding an interval can only be done in three cases - we have an interval that starts with a val+1, or we have an interval that ends with val-1, or both.  GetIntervals() is simply ignoring duplicate values. \\nSince we only store the ends of each interval, we need to maintain a set of seen values - values that are parts of some interval, for correctness.\\nTryGetValue and Remove are log k - where k is the current number of intervals stored\\nGetting SortedDictionary values is constant time, and we are iterating through them, which is O(k) where k is the current number of intervals stored. ToArray() is proportional to k as well.\\n\\n```\\npublic class SummaryRanges {\\n    private const int START = 0;\\n    private const int END = 1;\\n    \\n    private IDictionary<int, int[]> _intervals = new SortedDictionary<int, int[]>();\\n    private HashSet<int> _seen = new HashSet<int>();\\n    \\n    public SummaryRanges() {\\n    }\\n    \\n    public void AddNum(int val) {\\n        if(!_seen.Add(val)) {\\n            return;\\n        }\\n        \\n        var interval = new int[] { val, val };\\n        \\n        if(_intervals.TryGetValue(val-1, out var lower)) {\\n            interval[START] = lower[START];\\n            _intervals.Remove(val-1);\\n        }\\n        if(_intervals.TryGetValue(val+1, out var higher)) {\\n            interval[END] = higher[END];\\n            _intervals.Remove(val+1);\\n        }\\n        \\n        _intervals[interval[START]] = interval;\\n        _intervals[interval[END]] = interval;\\n    }\\n    \\n    public int[][] GetIntervals() {\\n        var intervalsList = new List<int[]>();\\n        \\n        var nextIntervalStart = -1;\\n        \\n        foreach(var interval in _intervals.Values) {\\n            if(interval[START] < nextIntervalStart) {\\n                continue;\\n            }\\n            \\n            intervalsList.Add(new int[] { interval[START], interval[END] });\\n            nextIntervalStart = interval[END] + 1;\\n        }\\n        \\n        return intervalsList.ToArray();\\n    }\\n}\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges obj = new SummaryRanges();\\n * obj.AddNum(val);\\n * int[][] param_2 = obj.GetIntervals();\\n */",
                "solutionTags": [],
                "code": "Here we are stroring the intervals sorted by the interval start. Note that each interval is stored twice - at the both ends of the interval. Expanding an interval can only be done in three cases - we have an interval that starts with a val+1, or we have an interval that ends with val-1, or both.  GetIntervals() is simply ignoring duplicate values. \\nSince we only store the ends of each interval, we need to maintain a set of seen values - values that are parts of some interval, for correctness.\\nTryGetValue and Remove are log k - where k is the current number of intervals stored\\nGetting SortedDictionary values is constant time, and we are iterating through them, which is O(k) where k is the current number of intervals stored. ToArray() is proportional to k as well.\\n\\n```\\npublic class SummaryRanges {\\n    private const int START = 0;\\n    private const int END = 1;\\n    \\n    private IDictionary<int, int[]> _intervals = new SortedDictionary<int, int[]>();\\n    private HashSet<int> _seen = new HashSet<int>();\\n    \\n    public SummaryRanges() {\\n    }\\n    \\n    public void AddNum(int val) {\\n        if(!_seen.Add(val)) {\\n            return;\\n        }\\n        \\n        var interval = new int[] { val, val };\\n        \\n        if(_intervals.TryGetValue(val-1, out var lower)) {\\n            interval[START] = lower[START];\\n            _intervals.Remove(val-1);\\n        }\\n        if(_intervals.TryGetValue(val+1, out var higher)) {\\n            interval[END] = higher[END];\\n            _intervals.Remove(val+1);\\n        }\\n        \\n        _intervals[interval[START]] = interval;\\n        _intervals[interval[END]] = interval;\\n    }\\n    \\n    public int[][] GetIntervals() {\\n        var intervalsList = new List<int[]>();\\n        \\n        var nextIntervalStart = -1;\\n        \\n        foreach(var interval in _intervals.Values) {\\n            if(interval[START] < nextIntervalStart) {\\n                continue;\\n            }\\n            \\n            intervalsList.Add(new int[] { interval[START], interval[END] });\\n            nextIntervalStart = interval[END] + 1;\\n        }\\n        \\n        return intervalsList.ToArray();\\n    }\\n}\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges obj = new SummaryRanges();\\n * obj.AddNum(val);\\n * int[][] param_2 = obj.GetIntervals();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1959333,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n    public class SummaryRanges {\\n\\t\\n\\tclass Interval {\\n\\tint start;\\n\\tint end;\\n\\n\\tpublic Interval(int start, int end) {\\n\\t\\tthis.start = start;\\n\\t\\tthis.end = end;\\n\\t}\\n\\t}\\n\\tTreeSet<Interval> lookUp;\\n    int[][] resCache;\\n    boolean cacheDirty;\\n\\n    public SummaryRanges() {\\n\\n\\tComparator<Interval> sortInterval = new Comparator<Interval>() {\\n\\t\\t@Override\\n\\t\\tpublic int compare(Interval it1, Interval it2) {\\n\\t\\t\\treturn it1.start - it2.start;\\n\\t\\t}\\n\\t};\\n\\tlookUp = new TreeSet<Interval>(sortInterval);\\n\\n\\tresCache = new int[0][2];\\n\\tcacheDirty = true;\\n\\t}\\n\\n    // lower - Returns the greatest element in this set strictly less than the given\\n    // element, or null if there is no such element.\\n\\n    // higher - Returns the least element in this set strictly greater than the\\n    // given element, or null if there is no such element.\\n    public void addNum(int val) {\\n\\n\\tInterval itCur = new Interval(val, val);\\n\\n\\t// CASE 1: interval already exists\\n\\tif (lookUp.contains(itCur))\\n\\t\\treturn;\\n\\t\\t\\n\\t//https://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html\\n\\tInterval itLower = lookUp.lower(itCur), itHigher = lookUp.higher(itCur);\\n\\n\\t// CASE 2:\\n\\tif (itLower != null && val <= itLower.end)\\n\\t\\treturn;\\n\\n\\t// CASE 3:\\n\\tif ((itHigher != null && itHigher.start == val + 1) && (itLower != null && val == itLower.end + 1)) {\\n\\t\\titLower.end = itHigher.end; // merge both the intervals\\n\\t\\tlookUp.remove(itHigher);\\n\\t}\\n\\t\\n\\t// CASE 4:\\n\\telse if (itHigher != null && itHigher.start == val + 1) \\n\\t\\titHigher.start = val; // to be merged with higher\\n\\n\\t// CASE 5:\\n\\telse if (itLower != null && val == itLower.end + 1) \\n\\t\\titLower.end = val; // to be merged with lower\\n\\t\\n\\t// CASE 6:\\n\\telse \\n\\t\\tlookUp.add(new Interval(val, val));\\n\\t\\n\\t// in all the above 4 cases - lookUp is modified\\n\\tcacheDirty = true;\\n\\t}\\n\\n    public int[][] getIntervals() {\\n\\n\\tif (!cacheDirty)\\n\\t\\treturn resCache;\\n\\n\\tint len = lookUp.size();\\n\\tresCache = new int[len][2];\\n\\n\\tint i = 0;\\n\\tfor (Interval curr : lookUp) {\\n\\t\\tresCache[i][0] = curr.start;\\n\\t\\tresCache[i][1] = curr.end;\\n\\t\\ti++;\\n\\t}\\n\\tcacheDirty = false;\\n\\treturn resCache;\\n\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public class SummaryRanges {\\n\\t\\n\\tclass Interval {\\n\\tint start;\\n\\tint end;\\n\\n\\tpublic Interval(int start, int end) {\\n\\t\\tthis.start = start;\\n\\t\\tthis.end = end;\\n\\t}\\n\\t}\\n\\tTreeSet<Interval> lookUp;\\n    int[][] resCache;\\n    boolean cacheDirty;\\n\\n    public SummaryRanges() {\\n\\n\\tComparator<Interval> sortInterval = new Comparator<Interval>() {\\n\\t\\t@Override\\n\\t\\tpublic int compare(Interval it1, Interval it2) {\\n\\t\\t\\treturn it1.start - it2.start;\\n\\t\\t}\\n\\t};\\n\\tlookUp = new TreeSet<Interval>(sortInterval);\\n\\n\\tresCache = new int[0][2];\\n\\tcacheDirty = true;\\n\\t}\\n\\n    // lower - Returns the greatest element in this set strictly less than the given\\n    // element, or null if there is no such element.\\n\\n    // higher - Returns the least element in this set strictly greater than the\\n    // given element, or null if there is no such element.\\n    public void addNum(int val) {\\n\\n\\tInterval itCur = new Interval(val, val);\\n\\n\\t// CASE 1: interval already exists\\n\\tif (lookUp.contains(itCur))\\n\\t\\treturn;\\n\\t\\t\\n\\t//https://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html\\n\\tInterval itLower = lookUp.lower(itCur), itHigher = lookUp.higher(itCur);\\n\\n\\t// CASE 2:\\n\\tif (itLower != null && val <= itLower.end)\\n\\t\\treturn;\\n\\n\\t// CASE 3:\\n\\tif ((itHigher != null && itHigher.start == val + 1) && (itLower != null && val == itLower.end + 1)) {\\n\\t\\titLower.end = itHigher.end; // merge both the intervals\\n\\t\\tlookUp.remove(itHigher);\\n\\t}\\n\\t\\n\\t// CASE 4:\\n\\telse if (itHigher != null && itHigher.start == val + 1) \\n\\t\\titHigher.start = val; // to be merged with higher\\n\\n\\t// CASE 5:\\n\\telse if (itLower != null && val == itLower.end + 1) \\n\\t\\titLower.end = val; // to be merged with lower\\n\\t\\n\\t// CASE 6:\\n\\telse \\n\\t\\tlookUp.add(new Interval(val, val));\\n\\t\\n\\t// in all the above 4 cases - lookUp is modified\\n\\tcacheDirty = true;\\n\\t}\\n\\n    public int[][] getIntervals() {\\n\\n\\tif (!cacheDirty)\\n\\t\\treturn resCache;\\n\\n\\tint len = lookUp.size();\\n\\tresCache = new int[len][2];\\n\\n\\tint i = 0;\\n\\tfor (Interval curr : lookUp) {\\n\\t\\tresCache[i][0] = curr.start;\\n\\t\\tresCache[i][1] = curr.end;\\n\\t\\ti++;\\n\\t}\\n\\tcacheDirty = false;\\n\\treturn resCache;\\n\\t}\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1661544,
                "title": "treemap-olog-n-straightforward",
                "content": "```\\nclass SummaryRanges {\\n\\n    TreeMap<Integer, Integer> tm = new TreeMap<>();\\n    public SummaryRanges() {\\n    }\\n    \\n    public void addNum(int val) {        \\n        Integer prev = tm.lowerKey(val);\\n        Integer next = tm.higherKey(val);\\n        \\n        tm.put(val, val);\\n        \\n        if (next != null && next == val + 1) {\\n            tm.put(val, tm.get(next));\\n            tm.remove(next);\\n        }\\n        if (prev != null && tm.get(prev) >= val - 1) {\\n            tm.put(prev, Math.max(tm.get(prev), tm.get(val)));\\n            tm.remove(val);\\n        } \\n    }\\n    \\n    public int[][] getIntervals() {\\n        int[][] ans = new int[tm.size()][2];\\n        int idx = 0;\\n        for (Map.Entry<Integer, Integer> e : tm.entrySet()) {\\n            ans[idx++] = new int[]{e.getKey(), e.getValue()};\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass SummaryRanges {\\n\\n    TreeMap<Integer, Integer> tm = new TreeMap<>();\\n    public SummaryRanges() {\\n    }\\n    \\n    public void addNum(int val) {        \\n        Integer prev = tm.lowerKey(val);\\n        Integer next = tm.higherKey(val);\\n        \\n        tm.put(val, val);\\n        \\n        if (next != null && next == val + 1) {\\n            tm.put(val, tm.get(next));\\n            tm.remove(next);\\n        }\\n        if (prev != null && tm.get(prev) >= val - 1) {\\n            tm.put(prev, Math.max(tm.get(prev), tm.get(val)));\\n            tm.remove(val);\\n        } \\n    }\\n    \\n    public int[][] getIntervals() {\\n        int[][] ans = new int[tm.size()][2];\\n        int idx = 0;\\n        for (Map.Entry<Integer, Integer> e : tm.entrySet()) {\\n            ans[idx++] = new int[]{e.getKey(), e.getValue()};\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585796,
                "title": "python-3-binary-search",
                "content": "```\\n# faster than 99.34%\\nclass SummaryRanges:\\n    def __init__(self):\\n        self.inte=[]\\n        self.d=set()\\n    def bs (self,t):\\n        l=0;h=len(self.inte)-1\\n        while l <=h:\\n            m=(l+h)//2\\n            if self.inte[m][0]>t:h=m-1\\n            elif self.inte[m][0]<t:l=m+1\\n        return l\\n    def addNum(self, val: int) -> None:\\n        #here we are going to mentain it in sorted order \\n        #here we use set () in order to find that is that in or not \\n        if val not in self.d:\\n            self.d.add(val)\\n            z=self.bs(val)#it will give us the index  where it need to be inserted \\n            a,b=val-1 in self.d,val+1 in self.d\\n            if a and b:\\n                self.inte[z-1][1]=self.inte[z][1]\\n                self.inte[z:z+1]=[]#use to delete at given pos very fast \\n            elif a:self.inte[z-1][1]=val\\n            elif b:self.inte[z][0]=val \\n            else:self.inte[z:z]=[[val,val]]#use to insert at given pos very fast \\n    def getIntervals(self) -> List[List[int]]:\\n        return self.inte\\n\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n# faster than 99.34%\\nclass SummaryRanges:\\n    def __init__(self):\\n        self.inte=[]\\n        self.d=set()\\n    def bs (self,t):\\n        l=0;h=len(self.inte)-1\\n        while l <=h:\\n            m=(l+h)//2\\n            if self.inte[m][0]>t:h=m-1\\n            elif self.inte[m][0]<t:l=m+1\\n        return l\\n    def addNum(self, val: int) -> None:\\n        #here we are going to mentain it in sorted order \\n        #here we use set () in order to find that is that in or not \\n        if val not in self.d:\\n            self.d.add(val)\\n            z=self.bs(val)#it will give us the index  where it need to be inserted \\n            a,b=val-1 in self.d,val+1 in self.d\\n            if a and b:\\n                self.inte[z-1][1]=self.inte[z][1]\\n                self.inte[z:z+1]=[]#use to delete at given pos very fast \\n            elif a:self.inte[z-1][1]=val\\n            elif b:self.inte[z][0]=val \\n            else:self.inte[z:z]=[[val,val]]#use to insert at given pos very fast \\n    def getIntervals(self) -> List[List[int]]:\\n        return self.inte\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380781,
                "title": "java-treeset-o-log-intervals-for-addnum-and-o-intervals-log-intervals-for-getintervals",
                "content": "```\\nclass Range implements Comparable<Range>{\\n    public int start, end;\\n    \\n    public Range(int x, int y){\\n        this.start = x;\\n        this.end = y;\\n    }\\n    \\n    @Override\\n    public int compareTo(Range other){\\n        return this.start - other.start;\\n    }\\n}\\n\\nclass SummaryRanges {\\n    private TreeSet<Range> set;\\n    \\n    /** Initialize your data structure here. */\\n    public SummaryRanges() {\\n        this.set = new TreeSet<Range>();\\n    }\\n    \\n    public void addNum(int val) {\\n        Range current = new Range(val, val);\\n        \\n        Range before = this.set.floor(current);\\n        Range after = this.set.ceiling(current);\\n        \\n        if(before != null && before.end + 1 >= val){\\n            current.start = before.start;\\n            current.end = Math.max(val, before.end);\\n            this.set.remove(before);\\n        }\\n        \\n        if(after != null && after.start == val + 1){\\n            current.end = after.end;\\n            this.set.remove(after);\\n        }\\n        \\n        this.set.add(current);\\n    }\\n    \\n    public int[][] getIntervals() {\\n        int N = this.set.size();\\n        int[][] result = new int[N][2];\\n        int i = 0;\\n        \\n        for(Range range : this.set){\\n            result[i][0] = range.start;\\n            result[i][1] = range.end;\\n            ++i;\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges obj = new SummaryRanges();\\n * obj.addNum(val);\\n * int[][] param_2 = obj.getIntervals();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Range implements Comparable<Range>{\\n    public int start, end;\\n    \\n    public Range(int x, int y){\\n        this.start = x;\\n        this.end = y;\\n    }\\n    \\n    @Override\\n    public int compareTo(Range other){\\n        return this.start - other.start;\\n    }\\n}\\n\\nclass SummaryRanges {\\n    private TreeSet<Range> set;\\n    \\n    /** Initialize your data structure here. */\\n    public SummaryRanges() {\\n        this.set = new TreeSet<Range>();\\n    }\\n    \\n    public void addNum(int val) {\\n        Range current = new Range(val, val);\\n        \\n        Range before = this.set.floor(current);\\n        Range after = this.set.ceiling(current);\\n        \\n        if(before != null && before.end + 1 >= val){\\n            current.start = before.start;\\n            current.end = Math.max(val, before.end);\\n            this.set.remove(before);\\n        }\\n        \\n        if(after != null && after.start == val + 1){\\n            current.end = after.end;\\n            this.set.remove(after);\\n        }\\n        \\n        this.set.add(current);\\n    }\\n    \\n    public int[][] getIntervals() {\\n        int N = this.set.size();\\n        int[][] result = new int[N][2];\\n        int i = 0;\\n        \\n        for(Range range : this.set){\\n            result[i][0] = range.start;\\n            result[i][1] = range.end;\\n            ++i;\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges obj = new SummaryRanges();\\n * obj.addNum(val);\\n * int[][] param_2 = obj.getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269980,
                "title": "python-o-n",
                "content": "class SummaryRanges:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.data = []\\n\\n    def addNum(self, val: int) -> None:\\n        if(not self.data):\\n            self.data.append([val, val])\\n            return\\n        \\n        if(val == self.data[0][0]-1):\\n            self.data[0][0] = val\\n            return\\n        if(val < self.data[0][0]):\\n            self.data.insert(0, [val, val])\\n            return\\n            \\n        i = 0\\n        L = len(self.data)\\n        while(i<L and self.data[i][0] <= val):\\n            i += 1\\n        if(i == L):\\n            if(self.data[i-1][1] >= val):\\n                pass\\n            elif(self.data[i-1][1]+1 == val):\\n                self.data[i-1][1] =val\\n            else:\\n                self.data.append([val, val])\\n        else:\\n            if(self.data[i-1][1] + 1 == val):\\n                self.data[i-1][1] = val\\n                if(self.data[i-1][1]+1 == self.data[i][0]):\\n                    self.data[i-1][1] = self.data[i][1]\\n                    self.data.pop(i)\\n            elif(self.data[i-1][1] >= val):\\n                pass\\n            elif(self.data[i][0]-1 == val):\\n                self.data[i][0] = val\\n            else:\\n                self.data = self.data[:i] + [[val, val]] + self.data[i:]\\n            \\n    def getIntervals(self) -> List[List[int]]:\\n        return self.data",
                "solutionTags": [],
                "code": "class SummaryRanges:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.data = []\\n\\n    def addNum(self, val: int) -> None:\\n        if(not self.data):\\n            self.data.append([val, val])\\n            return\\n        \\n        if(val == self.data[0][0]-1):\\n            self.data[0][0] = val\\n            return\\n        if(val < self.data[0][0]):\\n            self.data.insert(0, [val, val])\\n            return\\n            \\n        i = 0\\n        L = len(self.data)\\n        while(i<L and self.data[i][0] <= val):\\n            i += 1\\n        if(i == L):\\n            if(self.data[i-1][1] >= val):\\n                pass\\n            elif(self.data[i-1][1]+1 == val):\\n                self.data[i-1][1] =val\\n            else:\\n                self.data.append([val, val])\\n        else:\\n            if(self.data[i-1][1] + 1 == val):\\n                self.data[i-1][1] = val\\n                if(self.data[i-1][1]+1 == self.data[i][0]):\\n                    self.data[i-1][1] = self.data[i][1]\\n                    self.data.pop(i)\\n            elif(self.data[i-1][1] >= val):\\n                pass\\n            elif(self.data[i][0]-1 == val):\\n                self.data[i][0] = val\\n            else:\\n                self.data = self.data[:i] + [[val, val]] + self.data[i:]\\n            \\n    def getIntervals(self) -> List[List[int]]:\\n        return self.data",
                "codeTag": "Java"
            },
            {
                "id": 1258672,
                "title": "python-solution-using-heap",
                "content": "```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.intervals=[]\\n        \\n\\n    def addNum(self, val: int) -> None:\\n         heapq.heappush(self.intervals, [val, val])\\n        \\n\\n    def getIntervals(self) -> List[List[int]]:\\n        tmp = []\\n\\n        while self.intervals:\\n            cur = heapq.heappop(self.intervals)\\n            if tmp and cur[0] <= tmp[-1][1] + 1:\\n                tmp[-1][1] = max(tmp[-1][1], cur[1])\\n            else:\\n                tmp.append(cur)\\n\\n        self.intervals = tmp\\n        return self.intervals\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.intervals=[]\\n        \\n\\n    def addNum(self, val: int) -> None:\\n         heapq.heappush(self.intervals, [val, val])\\n        \\n\\n    def getIntervals(self) -> List[List[int]]:\\n        tmp = []\\n\\n        while self.intervals:\\n            cur = heapq.heappop(self.intervals)\\n            if tmp and cur[0] <= tmp[-1][1] + 1:\\n                tmp[-1][1] = max(tmp[-1][1], cur[1])\\n            else:\\n                tmp.append(cur)\\n\\n        self.intervals = tmp\\n        return self.intervals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859666,
                "title": "c-using-priority-queue-and-hashset",
                "content": "\\n```\\nclass SummaryRanges {\\npublic:\\n    /** Initialize your data structure here. */\\n    priority_queue<int,vector<int>, greater<int>> pq ;\\n    unordered_set<int> SET; \\n    \\n    void addNum(int val) {\\n        if(SET.find(val) == SET.end())pq.push(val), SET.insert(val); \\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> out ; \\n        priority_queue<int,vector<int>, greater<int>> pqcopy = pq;  \\n        vector<int> temp ; \\n        while(!pqcopy.empty()){\\n            int start = pqcopy.top(); \\n            pqcopy.pop(); \\n            temp.push_back(start); \\n            int end = start ;\\n            while(pqcopy.size() && start+1 == pqcopy.top()){\\n                end++; \\n                start++; \\n                pqcopy.pop();\\n            }\\n            temp.push_back(end); \\n            out.push_back(temp); \\n            temp.clear(); \\n        }\\n        return out ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass SummaryRanges {\\npublic:\\n    /** Initialize your data structure here. */\\n    priority_queue<int,vector<int>, greater<int>> pq ;\\n    unordered_set<int> SET; \\n    \\n    void addNum(int val) {\\n        if(SET.find(val) == SET.end())pq.push(val), SET.insert(val); \\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> out ; \\n        priority_queue<int,vector<int>, greater<int>> pqcopy = pq;  \\n        vector<int> temp ; \\n        while(!pqcopy.empty()){\\n            int start = pqcopy.top(); \\n            pqcopy.pop(); \\n            temp.push_back(start); \\n            int end = start ;\\n            while(pqcopy.size() && start+1 == pqcopy.top()){\\n                end++; \\n                start++; \\n                pqcopy.pop();\\n            }\\n            temp.push_back(end); \\n            out.push_back(temp); \\n            temp.clear(); \\n        }\\n        return out ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825196,
                "title": "java-clean-code",
                "content": "I did not like this problem, being it full of nasty `if-else`. The hard part is to comprehend how the range is formed.\\n\\n```java\\nclass SummaryRanges {\\n\\n    private TreeMap<Integer, Integer> map;\\n    \\n    /** Initialize your data structure here. */\\n    public SummaryRanges() {\\n        map = new TreeMap<>();\\n    }\\n    \\n    public void addNum(int val) {\\n        \\n        if (map.containsKey(val)) return;\\n        \\n        Integer lowerKey = map.lowerKey(val);\\n        Integer higherKey = map.higherKey(val);\\n        \\n        if (lowerKey != null && higherKey != null && map.get(lowerKey) + 1 == val && higherKey - 1 == val) {\\n            map.put(lowerKey, map.get(higherKey));\\n            map.remove(higherKey);\\n        } \\n        else if (higherKey != null && higherKey - 1 == val) {\\n                map.put(val, map.get(higherKey));\\n                map.remove(higherKey);\\n        } \\n        else if (lowerKey != null && map.get(lowerKey) + 1 >= val)    \\n            map.put(lowerKey, Math.max(val, map.get(lowerKey)));\\n        else\\n            map.put(val, val);\\n    }\\n    \\n    public int[][] getIntervals() {\\n        int count = map.size();\\n        int[][] result = new int[count][2];\\n        \\n        int i = 0;\\n        for (int key : map.keySet()) result[i++] = new int[] {key, map.get(key)};\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "I did not like this problem, being it full of nasty `if-else`. The hard part is to comprehend how the range is formed.\\n\\n```java\\nclass SummaryRanges {\\n\\n    private TreeMap<Integer, Integer> map;\\n    \\n    /** Initialize your data structure here. */\\n    public SummaryRanges() {\\n        map = new TreeMap<>();\\n    }\\n    \\n    public void addNum(int val) {\\n        \\n        if (map.containsKey(val)) return;\\n        \\n        Integer lowerKey = map.lowerKey(val);\\n        Integer higherKey = map.higherKey(val);\\n        \\n        if (lowerKey != null && higherKey != null && map.get(lowerKey) + 1 == val && higherKey - 1 == val) {\\n            map.put(lowerKey, map.get(higherKey));\\n            map.remove(higherKey);\\n        } \\n        else if (higherKey != null && higherKey - 1 == val) {\\n                map.put(val, map.get(higherKey));\\n                map.remove(higherKey);\\n        } \\n        else if (lowerKey != null && map.get(lowerKey) + 1 >= val)    \\n            map.put(lowerKey, Math.max(val, map.get(lowerKey)));\\n        else\\n            map.put(val, val);\\n    }\\n    \\n    public int[][] getIntervals() {\\n        int count = map.size();\\n        int[][] result = new int[count][2];\\n        \\n        int i = 0;\\n        for (int key : map.keySet()) result[i++] = new int[] {key, map.get(key)};\\n        return result;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 790270,
                "title": "java",
                "content": "```\\nclass SummaryRanges {\\n    TreeMap<Integer, Pair<Integer, Integer>> map = null;\\n    /** Initialize your data structure here. */\\n    public SummaryRanges() {\\n        map = new TreeMap<Integer, Pair<Integer, Integer>>();\\n    }\\n    \\n    public void addNum(int val) {\\n        Integer lowKey = map.floorKey(val);\\n        Integer highKey = map.ceilingKey(val);\\n        Pair<Integer, Integer> l = lowKey!=null ? map.get(lowKey) : null;\\n        Pair<Integer, Integer> h = highKey!=null ? map.get(highKey) : null;\\n        int merged = 0;\\n        if(lowKey != null){\\n            l = map.get(lowKey);\\n            if(val>=l.getKey() && val<=l.getValue())\\n                return;\\n            else if(l.getValue()+1 == val){\\n                map.put(lowKey, new Pair<Integer, Integer>(l.getKey(), l.getValue()+1));\\n                merged++;\\n            }\\n        }\\n        if(highKey != null){\\n            h = map.get(highKey);\\n            if(val>=h.getKey() && val<=h.getValue())\\n                return;\\n            else if(h.getKey()-1 == val){\\n                map.put(highKey, new Pair<Integer, Integer>(h.getKey()-1, h.getValue()));\\n                merged++;\\n            }\\n        }\\n        if(merged == 0)\\n            map.put(val, new Pair<Integer, Integer>(val, val));\\n        else if(merged == 2){\\n            map.put(lowKey, new Pair<Integer, Integer>(l.getKey(), h.getValue()));\\n            map.remove(highKey);\\n        }\\n    }\\n    \\n    public int[][] getIntervals() {\\n        int[][] res = new int[map.size()][2];\\n        int idx = 0;\\n        for(Pair<Integer, Integer> p : map.values()){\\n            res[idx][0] = p.getKey();\\n            res[idx++][1] = p.getValue();\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges obj = new SummaryRanges();\\n * obj.addNum(val);\\n * int[][] param_2 = obj.getIntervals();\\n */",
                "solutionTags": [],
                "code": "```\\nclass SummaryRanges {\\n    TreeMap<Integer, Pair<Integer, Integer>> map = null;\\n    /** Initialize your data structure here. */\\n    public SummaryRanges() {\\n        map = new TreeMap<Integer, Pair<Integer, Integer>>();\\n    }\\n    \\n    public void addNum(int val) {\\n        Integer lowKey = map.floorKey(val);\\n        Integer highKey = map.ceilingKey(val);\\n        Pair<Integer, Integer> l = lowKey!=null ? map.get(lowKey) : null;\\n        Pair<Integer, Integer> h = highKey!=null ? map.get(highKey) : null;\\n        int merged = 0;\\n        if(lowKey != null){\\n            l = map.get(lowKey);\\n            if(val>=l.getKey() && val<=l.getValue())\\n                return;\\n            else if(l.getValue()+1 == val){\\n                map.put(lowKey, new Pair<Integer, Integer>(l.getKey(), l.getValue()+1));\\n                merged++;\\n            }\\n        }\\n        if(highKey != null){\\n            h = map.get(highKey);\\n            if(val>=h.getKey() && val<=h.getValue())\\n                return;\\n            else if(h.getKey()-1 == val){\\n                map.put(highKey, new Pair<Integer, Integer>(h.getKey()-1, h.getValue()));\\n                merged++;\\n            }\\n        }\\n        if(merged == 0)\\n            map.put(val, new Pair<Integer, Integer>(val, val));\\n        else if(merged == 2){\\n            map.put(lowKey, new Pair<Integer, Integer>(l.getKey(), h.getValue()));\\n            map.remove(highKey);\\n        }\\n    }\\n    \\n    public int[][] getIntervals() {\\n        int[][] res = new int[map.size()][2];\\n        int idx = 0;\\n        for(Pair<Integer, Integer> p : map.values()){\\n            res[idx][0] = p.getKey();\\n            res[idx++][1] = p.getValue();\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges obj = new SummaryRanges();\\n * obj.addNum(val);\\n * int[][] param_2 = obj.getIntervals();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 753762,
                "title": "java-treeset-serving-as-binary-search-tree",
                "content": "```\\n// When do we merge the number to an existing interval?\\n// 1. If it\\'s within 1 interval(No merge operation needed in this case)\\n// 2. If it\\'s 1 less than left bound or 1 larger than right bound of 1 interval\\n\\n// How do we check this?\\n// Java TreeSet + Overridden Comparator\\n// O(log n) where n is the number of intervals\\n\\nclass SummaryRanges {\\n    TreeSet<Range> tree;\\n\\n    /** Initialize your data structure here. */\\n    public SummaryRanges() {\\n        tree = new TreeSet<>(new Comparator<Range>() {\\n            @Override\\n            public int compare(Range o1, Range o2) {\\n                if(o1.start > o2.end) {\\n                    return 1;\\n                } else if(o1.end < o2.start) {\\n                    return -1;\\n                } else {\\n                    return 0; // overlap\\n                }\\n            }\\n        });\\n\\n    }\\n\\n    public void addNum(int val) {\\n        Range newRange = new Range(val, val);\\n        if(!tree.contains(newRange)) {\\n            tree.add(newRange);\\n            Range lower = tree.lower(newRange);\\n            Range higher = tree.higher(newRange);\\n            if(lower != null && lower.end == newRange.start - 1) {\\n                tree.remove(lower);\\n                newRange.start = lower.start;\\n            }\\n            if(higher != null && higher.start == newRange.end + 1) {\\n                tree.remove(higher);\\n                newRange.end = higher.end;\\n            }\\n        }\\n    }\\n\\n    public int[][] getIntervals() {\\n        int size = tree.size();\\n        int[][] intervals = new int[size][];\\n        if(tree.isEmpty()) {\\n            return intervals;\\n        }\\n        Range cur = tree.first();\\n        for(int i = 0 ; i < size; i++) {\\n            intervals[i] = new int[2];\\n            intervals[i][0] = cur.start;\\n            intervals[i][1] = cur.end;\\n            cur = tree.higher(cur);\\n        }\\n        return intervals;\\n    }\\n\\n\\n    private class Range {\\n        int start;\\n        int end;\\n\\n        Range(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// When do we merge the number to an existing interval?\\n// 1. If it\\'s within 1 interval(No merge operation needed in this case)\\n// 2. If it\\'s 1 less than left bound or 1 larger than right bound of 1 interval\\n\\n// How do we check this?\\n// Java TreeSet + Overridden Comparator\\n// O(log n) where n is the number of intervals\\n\\nclass SummaryRanges {\\n    TreeSet<Range> tree;\\n\\n    /** Initialize your data structure here. */\\n    public SummaryRanges() {\\n        tree = new TreeSet<>(new Comparator<Range>() {\\n            @Override\\n            public int compare(Range o1, Range o2) {\\n                if(o1.start > o2.end) {\\n                    return 1;\\n                } else if(o1.end < o2.start) {\\n                    return -1;\\n                } else {\\n                    return 0; // overlap\\n                }\\n            }\\n        });\\n\\n    }\\n\\n    public void addNum(int val) {\\n        Range newRange = new Range(val, val);\\n        if(!tree.contains(newRange)) {\\n            tree.add(newRange);\\n            Range lower = tree.lower(newRange);\\n            Range higher = tree.higher(newRange);\\n            if(lower != null && lower.end == newRange.start - 1) {\\n                tree.remove(lower);\\n                newRange.start = lower.start;\\n            }\\n            if(higher != null && higher.start == newRange.end + 1) {\\n                tree.remove(higher);\\n                newRange.end = higher.end;\\n            }\\n        }\\n    }\\n\\n    public int[][] getIntervals() {\\n        int size = tree.size();\\n        int[][] intervals = new int[size][];\\n        if(tree.isEmpty()) {\\n            return intervals;\\n        }\\n        Range cur = tree.first();\\n        for(int i = 0 ; i < size; i++) {\\n            intervals[i] = new int[2];\\n            intervals[i][0] = cur.start;\\n            intervals[i][1] = cur.end;\\n            cur = tree.higher(cur);\\n        }\\n        return intervals;\\n    }\\n\\n\\n    private class Range {\\n        int start;\\n        int end;\\n\\n        Range(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749009,
                "title": "c-ordered-map-binary-search-solution",
                "content": "```\\nclass SummaryRanges {\\npublic:\\n    /** Initialize your data structure here. */\\n    map<int, int> mp;\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int val) {\\n        map<int, int> :: iterator it = mp.lower_bound(val);\\n        if (it == mp.begin()) {\\n            if (it->first == val + 1) {\\n                int last = it->second;\\n                mp.erase(it);\\n                mp[val] = last;\\n            } else if (it->first != val){\\n                mp[val] = val;\\n            }\\n        } else if (it == mp.end()) {\\n            if (mp.empty()) mp[val] = val;\\n            else {\\n                if (mp.rbegin()->second == val - 1) mp.rbegin()->second = val;\\n                else if (mp.rbegin()->second < val) mp[val] = val;\\n            }\\n        } else {\\n            if (val + 1 == it->first && val - 1 == (prev(it))->second) {\\n                prev(it)->second = it->second;\\n                mp.erase(it);\\n            } else if (val + 1 == it->first) {\\n                mp[val] = it->second;\\n                mp.erase(it);\\n            } else if (val - 1 == (prev(it))->second) {\\n                prev(it)->second = val;\\n            } else if (it->first != val && prev(it)->second < val){\\n                mp[val] = val;\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> vec;\\n        for (map<int, int> :: iterator it = mp.begin(); it != mp.end(); it++) {\\n            vec.push_back({it->first, it->second});\\n        }\\n        return vec;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(val);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass SummaryRanges {\\npublic:\\n    /** Initialize your data structure here. */\\n    map<int, int> mp;\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int val) {\\n        map<int, int> :: iterator it = mp.lower_bound(val);\\n        if (it == mp.begin()) {\\n            if (it->first == val + 1) {\\n                int last = it->second;\\n                mp.erase(it);\\n                mp[val] = last;\\n            } else if (it->first != val){\\n                mp[val] = val;\\n            }\\n        } else if (it == mp.end()) {\\n            if (mp.empty()) mp[val] = val;\\n            else {\\n                if (mp.rbegin()->second == val - 1) mp.rbegin()->second = val;\\n                else if (mp.rbegin()->second < val) mp[val] = val;\\n            }\\n        } else {\\n            if (val + 1 == it->first && val - 1 == (prev(it))->second) {\\n                prev(it)->second = it->second;\\n                mp.erase(it);\\n            } else if (val + 1 == it->first) {\\n                mp[val] = it->second;\\n                mp.erase(it);\\n            } else if (val - 1 == (prev(it))->second) {\\n                prev(it)->second = val;\\n            } else if (it->first != val && prev(it)->second < val){\\n                mp[val] = val;\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> vec;\\n        for (map<int, int> :: iterator it = mp.begin(); it != mp.end(); it++) {\\n            vec.push_back({it->first, it->second});\\n        }\\n        return vec;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(val);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733905,
                "title": "c-union-find",
                "content": "```\\n \\n    struct Node{\\n        int val;\\n        int rank;\\n        Node* parent;\\n    };\\n    \\n    unordered_map<int, Node*> m;\\n    unordered_map<Node*, int> minMap;\\n    unordered_map<Node*, int> maxMap;\\n    \\n    void makeSet(int val){\\n        Node* n = new Node();\\n        n->val = val;\\n        n->rank = 0;\\n        n->parent = n;\\n        m[val] = n;\\n        minMap[n] = val;\\n        maxMap[n] = val;\\n    }\\n    \\n    Node* findSet(Node * node){\\n        if(node->parent == node)\\n            return node;\\n        node->parent = findSet(node->parent);\\n        return node->parent;\\n    }\\n    \\n    void unionSet(int val1, int val2){\\n        Node* n1 = m[val1];\\n        Node* n2 = m[val2];\\n        \\n        Node* p1 = findSet(n1);\\n        Node* p2 = findSet(n2);\\n        \\n        if(p1 == p2)\\n            ;\\n        else{\\n            if(p1->rank >= p2->rank){\\n                p1->rank = p1->rank == p2->rank?1+p1->rank:p1->rank;\\n                p2->parent = p1;\\n                if(minMap[p1] > minMap[p2])\\n                    minMap[p1] = minMap[p2];\\n                if(maxMap[p1] < maxMap[p2])\\n                    maxMap[p1] = maxMap[p2];\\n            }\\n            else{\\n                p1->parent = p2;\\n                if(minMap[p2] > minMap[p1])\\n                    minMap[p2] = minMap[p1];\\n                if(maxMap[p2] < maxMap[p1])\\n                    maxMap[p2] = maxMap[p1];\\n            }\\n        }\\n    }\\n    \\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int val) {\\n        if(m.find(val) == m.end()){\\n            makeSet(val);\\n            if(m.find(val-1)!=m.end())\\n                unionSet(val-1, val);\\n            if(m.find(val+1)!=m.end())\\n                unionSet(val+1, val);\\n        }\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> res;\\n        set<int> st;\\n        for(auto it = m.begin();it!=m.end();it++){\\n            if(st.find(findSet(it->second)->val) == st.end())\\n                st.insert(findSet(it->second)->val);\\n        }\\n        for(auto it = st.begin(); it!=st.end(); it++){\\n            vector<int> v1;\\n            v1.push_back(minMap.find(m.find(*it)->second)->second);\\n            v1.push_back(maxMap.find(m.find(*it)->second)->second);\\n            res.push_back(v1);\\n        }\\n        //reverse(res.begin(), res.end());\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n \\n    struct Node{\\n        int val;\\n        int rank;\\n        Node* parent;\\n    };\\n    \\n    unordered_map<int, Node*> m;\\n    unordered_map<Node*, int> minMap;\\n    unordered_map<Node*, int> maxMap;\\n    \\n    void makeSet(int val){\\n        Node* n = new Node();\\n        n->val = val;\\n        n->rank = 0;\\n        n->parent = n;\\n        m[val] = n;\\n        minMap[n] = val;\\n        maxMap[n] = val;\\n    }\\n    \\n    Node* findSet(Node * node){\\n        if(node->parent == node)\\n            return node;\\n        node->parent = findSet(node->parent);\\n        return node->parent;\\n    }\\n    \\n    void unionSet(int val1, int val2){\\n        Node* n1 = m[val1];\\n        Node* n2 = m[val2];\\n        \\n        Node* p1 = findSet(n1);\\n        Node* p2 = findSet(n2);\\n        \\n        if(p1 == p2)\\n            ;\\n        else{\\n            if(p1->rank >= p2->rank){\\n                p1->rank = p1->rank == p2->rank?1+p1->rank:p1->rank;\\n                p2->parent = p1;\\n                if(minMap[p1] > minMap[p2])\\n                    minMap[p1] = minMap[p2];\\n                if(maxMap[p1] < maxMap[p2])\\n                    maxMap[p1] = maxMap[p2];\\n            }\\n            else{\\n                p1->parent = p2;\\n                if(minMap[p2] > minMap[p1])\\n                    minMap[p2] = minMap[p1];\\n                if(maxMap[p2] < maxMap[p1])\\n                    maxMap[p2] = maxMap[p1];\\n            }\\n        }\\n    }\\n    \\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int val) {\\n        if(m.find(val) == m.end()){\\n            makeSet(val);\\n            if(m.find(val-1)!=m.end())\\n                unionSet(val-1, val);\\n            if(m.find(val+1)!=m.end())\\n                unionSet(val+1, val);\\n        }\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> res;\\n        set<int> st;\\n        for(auto it = m.begin();it!=m.end();it++){\\n            if(st.find(findSet(it->second)->val) == st.end())\\n                st.insert(findSet(it->second)->val);\\n        }\\n        for(auto it = st.begin(); it!=st.end(); it++){\\n            vector<int> v1;\\n            v1.push_back(minMap.find(m.find(*it)->second)->second);\\n            v1.push_back(maxMap.find(m.find(*it)->second)->second);\\n            res.push_back(v1);\\n        }\\n        //reverse(res.begin(), res.end());\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 684315,
                "title": "c-using-set-easy-to-understand",
                "content": "```\\nclass SummaryRanges {\\nprotected:\\n    set<int> order;\\npublic:\\n    /** Initialize your data structure here. */\\n    SummaryRanges() {\\n        \\n    }\\n    // O(log(N)) to add\\n    void addNum(int val) {\\n        order.insert(val);\\n    }\\n    // O(N) ot get interval\\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> ret;\\n        if(order.empty()) return ret;\\n        auto it = (order.begin());\\n        int start = *it;\\n        int expect = start+1;\\n        it++;\\n        while(it!=order.end()){\\n            if(*it!=expect){\\n                ret.push_back({start,expect-1});\\n                start = *it;\\n                expect = start+1;\\n            }\\n            else expect++;\\n            it++;\\n        }\\n\\t\\t// dont forget to push the last one\\n        ret.push_back({start,expect-1});\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass SummaryRanges {\\nprotected:\\n    set<int> order;\\npublic:\\n    /** Initialize your data structure here. */\\n    SummaryRanges() {\\n        \\n    }\\n    // O(log(N)) to add\\n    void addNum(int val) {\\n        order.insert(val);\\n    }\\n    // O(N) ot get interval\\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> ret;\\n        if(order.empty()) return ret;\\n        auto it = (order.begin());\\n        int start = *it;\\n        int expect = start+1;\\n        it++;\\n        while(it!=order.end()){\\n            if(*it!=expect){\\n                ret.push_back({start,expect-1});\\n                start = *it;\\n                expect = start+1;\\n            }\\n            else expect++;\\n            it++;\\n        }\\n\\t\\t// dont forget to push the last one\\n        ret.push_back({start,expect-1});\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 647497,
                "title": "python-bisect-heapq-solutions-172ms-180ms",
                "content": "Bisect (172ms):\\n\\n```\\nfrom bisect import insort\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.h = []\\n\\n    def addNum(self, val: int) -> None:\\n        insort(self.h, [val,val])\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        r = []\\n        for i in self.h:\\n            if r and i[0] - r[-1][1] < 2: r[-1][1] = max(r[-1][1],i[1])\\n            else: r.append(i)\\n        self.h = r\\n        return r\\n```\\n\\nHeapq(180ms):\\n\\n```\\nfrom heapq import heappush, heappop\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.h = []\\n\\n    def addNum(self, val: int) -> None:\\n        heappush(self.h, [val,val])\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        r = []\\n        while self.h:\\n            i = heappop(self.h)\\n            if r and i[0] - r[-1][1] < 2: r[-1][1] = max(r[-1][1],i[1])\\n            else: r.append(i)\\n        self.h = r\\n        return r\\n```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import insort\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.h = []\\n\\n    def addNum(self, val: int) -> None:\\n        insort(self.h, [val,val])\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        r = []\\n        for i in self.h:\\n            if r and i[0] - r[-1][1] < 2: r[-1][1] = max(r[-1][1],i[1])\\n            else: r.append(i)\\n        self.h = r\\n        return r\\n```\n```\\nfrom heapq import heappush, heappop\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.h = []\\n\\n    def addNum(self, val: int) -> None:\\n        heappush(self.h, [val,val])\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        r = []\\n        while self.h:\\n            i = heappop(self.h)\\n            if r and i[0] - r[-1][1] < 2: r[-1][1] = max(r[-1][1],i[1])\\n            else: r.append(i)\\n        self.h = r\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 249636,
                "title": "java-82-ms-beats-100",
                "content": "Basic idea: construct BST of nodes with Interval as attribute.\\n\\nThe complex part is addNum method.\\n\\nFour cases in total (assume n is current root node to add val):\\n\\n1. val < n.intv.start - 1: add to left subtree\\n2. val == n.intv.start - 1: \\n    2.1. merge n with the right most node in left subtree;\\n    2.2.merge n with val\\n3. val == n.intv.end + 1:\\n    3.1. merge n with the left most node in right subtree;\\n    3.2.merge n with val\\n4. val > n.intv.end + 1: add to right subtree\\n\\n```\\nclass SummaryRanges {\\n\\tprivate class TreeNode {\\n\\t\\tInterval intv;\\n\\t\\tTreeNode left, right;\\n\\t\\tpublic TreeNode(Interval i) {\\n\\t\\t\\tintv = i;\\n\\t\\t}\\n\\t}\\n\\n\\tTreeNode root;\\n\\n    /** Initialize your data structure here. */\\n    public SummaryRanges() {\\n        root = null;\\n    }\\n    \\n    public void addNum(int val) {\\n    \\troot = addNum(root, val);\\n    }\\n\\n    private TreeNode addNum(TreeNode n, int val) {\\n    \\tif (n == null) {\\n    \\t\\tn = new TreeNode(new Interval(val, val));\\n    \\t\\treturn n;\\n    \\t}\\n    \\tif (val < n.intv.start - 1) {\\n    \\t\\tn.left = addNum(n.left, val);\\n    \\t}\\n    \\telse if (val == n.intv.start - 1) {\\n    \\t\\tTreeNode rightMost = n.left, rightMostPrev = n;\\n    \\t\\twhile (rightMost != null && rightMost.right != null) {\\n    \\t\\t\\trightMostPrev = rightMost;\\n    \\t\\t\\trightMost = rightMost.right;\\n    \\t\\t}\\n    \\t\\tif (rightMost != null && rightMost.intv.end + 1 == val) {\\n    \\t\\t\\tn.intv.start = rightMost.intv.start;\\n    \\t\\t\\tif (rightMostPrev != n) {\\n    \\t\\t\\t\\trightMostPrev.right = rightMost.left;\\n    \\t\\t\\t}\\n    \\t\\t\\telse rightMostPrev.left = rightMost.left;\\n    \\t\\t}\\n    \\t\\telse n.intv.start = val;\\n    \\t}\\n    \\telse if (val == n.intv.end + 1) {\\n    \\t\\tTreeNode leftMost = n.right, leftMostPrev = n;\\n    \\t\\twhile (leftMost != null && leftMost.left != null) {\\n    \\t\\t\\tleftMostPrev = leftMost;\\n    \\t\\t\\tleftMost = leftMost.left;\\n    \\t\\t}\\n    \\t\\tif (leftMost != null && leftMost.intv.start - 1 == val) {\\n    \\t\\t\\tn.intv.end = leftMost.intv.end;\\n    \\t\\t\\tif (leftMostPrev != n) {\\n    \\t\\t\\t\\tleftMostPrev.left = leftMost.right;\\n    \\t\\t\\t}\\n    \\t\\t\\telse leftMostPrev.right = leftMost.right;\\n    \\t\\t}\\n    \\t\\telse n.intv.end = val;\\n    \\t}\\n    \\telse if (val > n.intv.end + 1) {\\n    \\t\\tn.right = addNum(n.right, val);\\n    \\t}\\n    \\treturn n;\\n    }\\n    \\n    public List<Interval> getIntervals() {\\n    \\treturn getIntervals(root);\\n    }\\n\\n    private List<Interval> getIntervals(TreeNode n) {\\n        List<Interval> list = new LinkedList();\\n        if (n == null) return list;\\n        list.addAll(getIntervals(n.left));\\n        list.add(n.intv);\\n        list.addAll(getIntervals(n.right));\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass SummaryRanges {\\n\\tprivate class TreeNode {\\n\\t\\tInterval intv;\\n\\t\\tTreeNode left, right;\\n\\t\\tpublic TreeNode(Interval i) {\\n\\t\\t\\tintv = i;\\n\\t\\t}\\n\\t}\\n\\n\\tTreeNode root;\\n\\n    /** Initialize your data structure here. */\\n    public SummaryRanges() {\\n        root = null;\\n    }\\n    \\n    public void addNum(int val) {\\n    \\troot = addNum(root, val);\\n    }\\n\\n    private TreeNode addNum(TreeNode n, int val) {\\n    \\tif (n == null) {\\n    \\t\\tn = new TreeNode(new Interval(val, val));\\n    \\t\\treturn n;\\n    \\t}\\n    \\tif (val < n.intv.start - 1) {\\n    \\t\\tn.left = addNum(n.left, val);\\n    \\t}\\n    \\telse if (val == n.intv.start - 1) {\\n    \\t\\tTreeNode rightMost = n.left, rightMostPrev = n;\\n    \\t\\twhile (rightMost != null && rightMost.right != null) {\\n    \\t\\t\\trightMostPrev = rightMost;\\n    \\t\\t\\trightMost = rightMost.right;\\n    \\t\\t}\\n    \\t\\tif (rightMost != null && rightMost.intv.end + 1 == val) {\\n    \\t\\t\\tn.intv.start = rightMost.intv.start;\\n    \\t\\t\\tif (rightMostPrev != n) {\\n    \\t\\t\\t\\trightMostPrev.right = rightMost.left;\\n    \\t\\t\\t}\\n    \\t\\t\\telse rightMostPrev.left = rightMost.left;\\n    \\t\\t}\\n    \\t\\telse n.intv.start = val;\\n    \\t}\\n    \\telse if (val == n.intv.end + 1) {\\n    \\t\\tTreeNode leftMost = n.right, leftMostPrev = n;\\n    \\t\\twhile (leftMost != null && leftMost.left != null) {\\n    \\t\\t\\tleftMostPrev = leftMost;\\n    \\t\\t\\tleftMost = leftMost.left;\\n    \\t\\t}\\n    \\t\\tif (leftMost != null && leftMost.intv.start - 1 == val) {\\n    \\t\\t\\tn.intv.end = leftMost.intv.end;\\n    \\t\\t\\tif (leftMostPrev != n) {\\n    \\t\\t\\t\\tleftMostPrev.left = leftMost.right;\\n    \\t\\t\\t}\\n    \\t\\t\\telse leftMostPrev.right = leftMost.right;\\n    \\t\\t}\\n    \\t\\telse n.intv.end = val;\\n    \\t}\\n    \\telse if (val > n.intv.end + 1) {\\n    \\t\\tn.right = addNum(n.right, val);\\n    \\t}\\n    \\treturn n;\\n    }\\n    \\n    public List<Interval> getIntervals() {\\n    \\treturn getIntervals(root);\\n    }\\n\\n    private List<Interval> getIntervals(TreeNode n) {\\n        List<Interval> list = new LinkedList();\\n        if (n == null) return list;\\n        list.addAll(getIntervals(n.left));\\n        list.add(n.intv);\\n        list.addAll(getIntervals(n.right));\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82565,
                "title": "golang-o-n-logn-solution-with-a-customized-bst-no-treemap-or-similar-things",
                "content": "The difficult part is how to merge the Nodes(ranges) if the adding value can connect two ranges.\\n\\n```\\ntype Node struct{\\n    begin, end int\\n    left, right *Node\\n}\\n\\ntype SummaryRanges struct {\\n    root *Node\\n}\\n\\n\\n/** Initialize your data structure here. */\\nfunc Constructor() SummaryRanges {\\n    return SummaryRanges{nil}\\n}\\n\\nfunc mergeRightmost(toMerge , n *Node) *Node{\\n    if n==nil{\\n        toMerge.begin -= 1\\n        return nil\\n    }\\n    if n.end + 2 == toMerge.begin{\\n        toMerge.begin = n.begin\\n        return n.left//remove n\\n    }\\n    n.right = mergeRightmost(toMerge, n.right)\\n    return n\\n}\\n\\nfunc mergeLeftmost(toMerge , n *Node) *Node{\\n    if n==nil{\\n        toMerge.end += 1\\n        return nil\\n    }\\n    //fmt.Println(\"tomerge [\", toMerge.begin, toMerge.end, \"], @\", n.begin)\\n    if n.begin-2 == toMerge.end{\\n        toMerge.end = n.end\\n        return n.right//remove n\\n    }\\n    n.left = mergeLeftmost(toMerge, n.left)\\n    return n\\n}\\n\\nfunc add(n *Node, val int) *Node{\\n    if n == nil{\\n        return &Node{val,val, nil, nil}\\n    }\\n    //included\\n    if  n.begin <= val && val <= n.end{\\n        return n\\n    }\\n    \\n    //to insert left\\n    if  val < n.begin{\\n        if val +1 == n.begin{\\n            n.left = mergeRightmost(n , n.left)\\n        }else{\\n            n.left = add(n.left, val)\\n        }\\n    }else{//val > n.end\\n        if val - 1 == n.end{\\n            n.right = mergeLeftmost(n , n.right)\\n        }else{\\n            n.right = add(n.right, val)\\n        }\\n    }\\n    return n\\n}\\n\\nfunc (this *SummaryRanges) Addnum(val int)  {\\n    this.root = add(this.root, val)\\n}\\n\\n\\nfunc  genInterval(n *Node, it []Interval ) []Interval {\\n    if n == nil{\\n        return it\\n    }\\n    it = genInterval(n.left, it)\\n    it = append(it, Interval{n.begin, n.end} )\\n    it = genInterval(n.right, it)\\n    return it\\n}\\n\\nfunc (this *SummaryRanges) Getintervals() []Interval {\\n    return genInterval(this.root, make([]Interval,0))\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\ntype Node struct{\\n    begin, end int\\n    left, right *Node\\n}\\n\\ntype SummaryRanges struct {\\n    root *Node\\n}\\n\\n\\n/** Initialize your data structure here. */\\nfunc Constructor() SummaryRanges {\\n    return SummaryRanges{nil}\\n}\\n\\nfunc mergeRightmost(toMerge , n *Node) *Node{\\n    if n==nil{\\n        toMerge.begin -= 1\\n        return nil\\n    }\\n    if n.end + 2 == toMerge.begin{\\n        toMerge.begin = n.begin\\n        return n.left//remove n\\n    }\\n    n.right = mergeRightmost(toMerge, n.right)\\n    return n\\n}\\n\\nfunc mergeLeftmost(toMerge , n *Node) *Node{\\n    if n==nil{\\n        toMerge.end += 1\\n        return nil\\n    }\\n    //fmt.Println(\"tomerge [\", toMerge.begin, toMerge.end, \"], @\", n.begin)\\n    if n.begin-2 == toMerge.end{\\n        toMerge.end = n.end\\n        return n.right//remove n\\n    }\\n    n.left = mergeLeftmost(toMerge, n.left)\\n    return n\\n}\\n\\nfunc add(n *Node, val int) *Node{\\n    if n == nil{\\n        return &Node{val,val, nil, nil}\\n    }\\n    //included\\n    if  n.begin <= val && val <= n.end{\\n        return n\\n    }\\n    \\n    //to insert left\\n    if  val < n.begin{\\n        if val +1 == n.begin{\\n            n.left = mergeRightmost(n , n.left)\\n        }else{\\n            n.left = add(n.left, val)\\n        }\\n    }else{//val > n.end\\n        if val - 1 == n.end{\\n            n.right = mergeLeftmost(n , n.right)\\n        }else{\\n            n.right = add(n.right, val)\\n        }\\n    }\\n    return n\\n}\\n\\nfunc (this *SummaryRanges) Addnum(val int)  {\\n    this.root = add(this.root, val)\\n}\\n\\n\\nfunc  genInterval(n *Node, it []Interval ) []Interval {\\n    if n == nil{\\n        return it\\n    }\\n    it = genInterval(n.left, it)\\n    it = append(it, Interval{n.begin, n.end} )\\n    it = genInterval(n.right, it)\\n    return it\\n}\\n\\nfunc (this *SummaryRanges) Getintervals() []Interval {\\n    return genInterval(this.root, make([]Interval,0))\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 82571,
                "title": "c-102ms-concise-code-union-find-path-compression",
                "content": "Brief idea is whenever adding new val, union it with val-1 and val + 1. And always join the parent from bigger value to lower value. \\n\\nKeep another map for the end point of each union. In union operation, update end point of survived parent and deleted the obsolete parent. So this way this map is always ready to query all the intervals.\\n\\n\\n```\\n/**\\n * Definition for an interval.\\n * struct Interval {\\n *     int start;\\n *     int end;\\n *     Interval() : start(0), end(0) {}\\n *     Interval(int s, int e) : start(s), end(e) {}\\n * };\\n */\\nclass SummaryRanges {\\npublic:\\n    /** Initialize your data structure here. */\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int val) {\\n        if (parent.count(val)) return;\\n        parent[val] = val;\\n        range_end[val] = val;\\n        if (parent.count(val-1)) join(val - 1, val);\\n        if (parent.count(val+1)) join(val, val + 1);\\n    }\\n    \\n    vector<Interval> getIntervals() {\\n        vector<Interval> r;\\n        for (auto& e: range_end) {\\n            r.push_back(Interval(e.first, e.second));\\n        }\\n        return r;\\n    }\\n    \\n    int find_p(int i) {\\n        if (parent[i] != i) {\\n          parent[i] = find_p(parent[i]);\\n        }\\n        return parent[i];\\n    }\\n    \\n    void join(int i, int j) {\\n        int pi = find_p(i);\\n        int pj = find_p(j);\\n        parent[pj] = pi;\\n        range_end[pi] = range_end[pj];\\n        range_end.erase(pj);\\n    }\\n    \\n    unordered_map<int, int> parent;\\n    map<int, int> range_end;\\n    \\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for an interval.\\n * struct Interval {\\n *     int start;\\n *     int end;\\n *     Interval() : start(0), end(0) {}\\n *     Interval(int s, int e) : start(s), end(e) {}\\n * };\\n */\\nclass SummaryRanges {\\npublic:\\n    /** Initialize your data structure here. */\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int val) {\\n        if (parent.count(val)) return;\\n        parent[val] = val;\\n        range_end[val] = val;\\n        if (parent.count(val-1)) join(val - 1, val);\\n        if (parent.count(val+1)) join(val, val + 1);\\n    }\\n    \\n    vector<Interval> getIntervals() {\\n        vector<Interval> r;\\n        for (auto& e: range_end) {\\n            r.push_back(Interval(e.first, e.second));\\n        }\\n        return r;\\n    }\\n    \\n    int find_p(int i) {\\n        if (parent[i] != i) {\\n          parent[i] = find_p(parent[i]);\\n        }\\n        return parent[i];\\n    }\\n    \\n    void join(int i, int j) {\\n        int pi = find_p(i);\\n        int pj = find_p(j);\\n        parent[pj] = pi;\\n        range_end[pi] = range_end[pj];\\n        range_end.erase(pj);\\n    }\\n    \\n    unordered_map<int, int> parent;\\n    map<int, int> range_end;\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 82614,
                "title": "share-152ms-c-solution-using-segment-tree",
                "content": "The key point is how to merge intervals.\\n\\n    \\n \\n\\n    struct MMTreeNode\\n     {\\n         Interval range;\\n         MMTreeNode *left;\\n         MMTreeNode *right;\\n         MMTreeNode(int s, int e):range(s, e), left(NULL), right(NULL){}\\n     };\\n    class SummaryRanges {\\n    private:\\n        MMTreeNode *rt;\\n    public:\\n        /** Initialize your data structure here. */\\n        SummaryRanges() {\\n            rt = NULL;\\n        }\\n        \\n        void addNum(int val) {\\n            addNumHelper(val, rt);\\n        }\\n        \\n        void addNumHelper(int val, MMTreeNode *&root)\\n        {\\n            if(root == NULL)\\n            {\\n                root = new MMTreeNode(val, val);\\n                return;\\n            }\\n            if(root->range.start <= val && root->range.end >= val) return;\\n            if(root->range.start == val + 1)\\n            {\\n                root->range.start = val;\\n                //find the rightest node on the left subtree\\n                if(root->left)\\n                {\\n                    MMTreeNode *node = root->left;\\n                    if(node->right == NULL)\\n                    {\\n                        //node's right subtree doesn't exist\\n                        if(node->range.end == val - 1)\\n                        {\\n                            root->range.start = node->range.start;\\n                            root->left = node->left;\\n                            delete node;\\n                        }\\n                        return;\\n                    }\\n                    //if right subtree exists, then find the rightest node\\n                    MMTreeNode *parent;\\n                    while(node->right)\\n                    {\\n                        parent = node;\\n                        node = node->right;\\n                    }\\n                    if(node->range.end == val - 1)\\n                    {\\n                        parent->right = node->left;\\n                        root->range.start = node->range.start;\\n                        delete node;\\n                    }\\n                }\\n                return;\\n            }else if(root->range.end == val - 1)\\n            {\\n                root->range.end = val;\\n                //find the leftest node on the right subtree\\n                if(root->right)\\n                {\\n                    MMTreeNode *node = root->right;\\n                    if(node->left == NULL)\\n                    {\\n                        //node's left subtree doesn't exist\\n                        if(node->range.start == val + 1)\\n                        {\\n                            root->range.end = node->range.end;\\n                            root->right = node->right;\\n                            delete node;\\n                        }\\n                        return;\\n                    }\\n                    //if left subtree exists, then find the leftest node\\n                    MMTreeNode *parent = root;\\n                    while(node->left)\\n                    {\\n                        parent = node;\\n                        node = node->left;\\n                    }\\n                    if(node->range.start == val + 1)\\n                    {\\n                        parent->left = node->right;\\n                        root->range.end = node->range.end;\\n                        delete node;\\n                    }\\n                }\\n                return;\\n            }else if(root->range.start > val)\\n            {\\n                addNumHelper(val, root->left);\\n            }else\\n            {\\n                addNumHelper(val, root->right);\\n            }\\n        }\\n        \\n        vector<Interval> getIntervals() {\\n            vector<Interval> result;\\n            getIntervalsHelper(rt, result);\\n            return result;\\n        }\\n        //middle order traversal\\n        void getIntervalsHelper(MMTreeNode *root, vector<Interval> &result)\\n        {\\n            if(root == NULL) return;\\n            getIntervalsHelper(root->left, result);\\n            result.push_back(root->range);\\n            getIntervalsHelper(root->right, result);\\n        }\\n    };",
                "solutionTags": [],
                "code": "The key point is how to merge intervals.\\n\\n    \\n \\n\\n    struct MMTreeNode\\n     {\\n         Interval range;\\n         MMTreeNode *left;\\n         MMTreeNode *right;\\n         MMTreeNode(int s, int e):range(s, e), left(NULL), right(NULL){}\\n     };\\n    class SummaryRanges {\\n    private:\\n        MMTreeNode *rt;\\n    public:\\n        /** Initialize your data structure here. */\\n        SummaryRanges() {\\n            rt = NULL;\\n        }\\n        \\n        void addNum(int val) {\\n            addNumHelper(val, rt);\\n        }\\n        \\n        void addNumHelper(int val, MMTreeNode *&root)\\n        {\\n            if(root == NULL)\\n            {\\n                root = new MMTreeNode(val, val);\\n                return;\\n            }\\n            if(root->range.start <= val && root->range.end >= val) return;\\n            if(root->range.start == val + 1)\\n            {\\n                root->range.start = val;\\n                //find the rightest node on the left subtree\\n                if(root->left)\\n                {\\n                    MMTreeNode *node = root->left;\\n                    if(node->right == NULL)\\n                    {\\n                        //node's right subtree doesn't exist\\n                        if(node->range.end == val - 1)\\n                        {\\n                            root->range.start = node->range.start;\\n                            root->left = node->left;\\n                            delete node;\\n                        }\\n                        return;\\n                    }\\n                    //if right subtree exists, then find the rightest node\\n                    MMTreeNode *parent;\\n                    while(node->right)\\n                    {\\n                        parent = node;\\n                        node = node->right;\\n                    }\\n                    if(node->range.end == val - 1)\\n                    {\\n                        parent->right = node->left;\\n                        root->range.start = node->range.start;\\n                        delete node;\\n                    }\\n                }\\n                return;\\n            }else if(root->range.end == val - 1)\\n            {\\n                root->range.end = val;\\n                //find the leftest node on the right subtree\\n                if(root->right)\\n                {\\n                    MMTreeNode *node = root->right;\\n                    if(node->left == NULL)\\n                    {\\n                        //node's left subtree doesn't exist\\n                        if(node->range.start == val + 1)\\n                        {\\n                            root->range.end = node->range.end;\\n                            root->right = node->right;\\n                            delete node;\\n                        }\\n                        return;\\n                    }\\n                    //if left subtree exists, then find the leftest node\\n                    MMTreeNode *parent = root;\\n                    while(node->left)\\n                    {\\n                        parent = node;\\n                        node = node->left;\\n                    }\\n                    if(node->range.start == val + 1)\\n                    {\\n                        parent->left = node->right;\\n                        root->range.end = node->range.end;\\n                        delete node;\\n                    }\\n                }\\n                return;\\n            }else if(root->range.start > val)\\n            {\\n                addNumHelper(val, root->left);\\n            }else\\n            {\\n                addNumHelper(val, root->right);\\n            }\\n        }\\n        \\n        vector<Interval> getIntervals() {\\n            vector<Interval> result;\\n            getIntervalsHelper(rt, result);\\n            return result;\\n        }\\n        //middle order traversal\\n        void getIntervalsHelper(MMTreeNode *root, vector<Interval> &result)\\n        {\\n            if(root == NULL) return;\\n            getIntervalsHelper(root->left, result);\\n            result.push_back(root->range);\\n            getIntervalsHelper(root->right, result);\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 82637,
                "title": "solution-based-on-c-set-memory-limit-exceeded",
                "content": "My solution uses a C++ set, as shown below. To do so, I use a custom `SRInterval` class. Two `SRIntervals` compare equal if they overlap. This makes it easy to find existing intervals that need to be merged.\\n\\nThis solution received a \"memory limit exceeded\" verdict, and I cannot understand why. Any hints?\\n\\n    struct SRInterval {\\n        const int begin;\\n        const int end;\\n        SRInterval(int begin, int end) : begin(begin), end(end) {}\\n        bool operator<(const SRInterval &other) const {\\n            return end <= other.begin;\\n        }\\n    };\\n\\n    class SummaryRanges {\\n        set<SRInterval> intervals;\\n\\n    public:\\n        void addNum(int val) {\\n            int b = val;\\n            int e = val + 1;\\n\\n            auto left = intervals.find(SRInterval(val - 1, val));\\n            if (left != intervals.end()) {\\n                b = left->begin;\\n                intervals.erase(*left);\\n            }\\n            auto right = intervals.find(SRInterval(val, val + 2));\\n            if (right != intervals.end()) {\\n                e = right->end;\\n                intervals.erase(*right);\\n            }\\n\\n            SRInterval sri(b, e);\\n            assert(intervals.count(sri) == 0 && \"sri already in intervals?\");\\n            intervals.insert(sri);\\n        }\\n        \\n        vector<Interval> getIntervals() {\\n            vector<Interval> result;\\n            result.reserve(intervals.size());\\n            for (auto &sri : intervals) {\\n                result.emplace_back(sri.begin, sri.end - 1);\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "My solution uses a C++ set, as shown below. To do so, I use a custom `SRInterval` class. Two `SRIntervals` compare equal if they overlap. This makes it easy to find existing intervals that need to be merged.\\n\\nThis solution received a \"memory limit exceeded\" verdict, and I cannot understand why. Any hints?\\n\\n    struct SRInterval {\\n        const int begin;\\n        const int end;\\n        SRInterval(int begin, int end) : begin(begin), end(end) {}\\n        bool operator<(const SRInterval &other) const {\\n            return end <= other.begin;\\n        }\\n    };\\n\\n    class SummaryRanges {\\n        set<SRInterval> intervals;\\n\\n    public:\\n        void addNum(int val) {\\n            int b = val;\\n            int e = val + 1;\\n\\n            auto left = intervals.find(SRInterval(val - 1, val));\\n            if (left != intervals.end()) {\\n                b = left->begin;\\n                intervals.erase(*left);\\n            }\\n            auto right = intervals.find(SRInterval(val, val + 2));\\n            if (right != intervals.end()) {\\n                e = right->end;\\n                intervals.erase(*right);\\n            }\\n\\n            SRInterval sri(b, e);\\n            assert(intervals.count(sri) == 0 && \"sri already in intervals?\");\\n            intervals.insert(sri);\\n        }\\n        \\n        vector<Interval> getIntervals() {\\n            vector<Interval> result;\\n            result.reserve(intervals.size());\\n            for (auto &sri : intervals) {\\n                result.emplace_back(sri.begin, sri.end - 1);\\n            }\\n            return result;\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 82584,
                "title": "short-but-bad-python",
                "content": "    def __init__(self):\\n        vals = set()\\n        self.addNum = vals.add\\n        self.getIntervals = lambda: [[g[0][1], g[-1][1]] for g in\\n                                     (list(g) for _, g in itertools.groupby(\\n                                      enumerate(sorted(vals)), lambda (i, val): val - i))]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def __init__(self):\\n        vals = set()\\n        self.addNum = vals.add\\n        self.getIntervals = lambda: [[g[0][1], g[-1][1]] for g in\\n                                     (list(g) for _, g in itertools.groupby(\\n                                      enumerate(sorted(vals)), lambda (i, val): val - i))]",
                "codeTag": "Python3"
            },
            {
                "id": 82621,
                "title": "c-solution-using-std-set",
                "content": "Using `std::set` (implemented with red-black tree generally), for every update (insertion), the time cost is O(lgn).\\n\\n    bool operator < (const Interval &i1, const Interval &i2) {\\n        return i1.start < i2.start;\\n    }\\n    \\n    void update_end(const Interval &i, int end) {\\n        const_cast<Interval &>(i).end = end;\\n    }\\n    \\n    class SummaryRanges {\\n        set<Interval> data;\\n    \\n    public:\\n        SummaryRanges() {}\\n    \\n        void addNum(int val) {\\n            Interval i(val, val);\\n    \\n            auto &&next = upper_bound(data.begin(), data.end(), i);\\n    \\n            if (next != data.begin() && next != data.end()) {\\n                auto prev = next; --prev;\\n    \\n                if (prev->end >= val) {\\n                    return;\\n                }\\n            }\\n    \\n            if (next == data.end() && !data.empty()) {\\n                if (data.rbegin()->end >= val) {\\n                    return;\\n                }\\n            }\\n    \\n            auto &&curr = data.insert(next, i);\\n            auto prev = data.end();\\n    \\n            bool erase_curr = false, erase_next = false;\\n    \\n            if (curr != data.begin()) {\\n                prev = curr; --prev;\\n    \\n                if (prev->end == curr->start - 1) {\\n                    update_end(*prev, curr->start);\\n                    erase_curr = true;\\n                }\\n            }\\n    \\n            if (next != data.end()) {\\n                if (next->start == curr->start + 1) {\\n                    if (erase_curr) {\\n                        update_end(*prev, next->end);\\n                    } else {\\n                        update_end(*curr, next->end);\\n                    }\\n    \\n                    erase_next = true;\\n                }\\n            }\\n    \\n            if (erase_curr) {\\n                data.erase(curr);\\n            }\\n    \\n            if (erase_next) {\\n                data.erase(next);\\n            }\\n        }\\n    \\n        vector<Interval> getIntervals() {\\n            return vector<Interval>(data.begin(), data.end());\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "Using `std::set` (implemented with red-black tree generally), for every update (insertion), the time cost is O(lgn).\\n\\n    bool operator < (const Interval &i1, const Interval &i2) {\\n        return i1.start < i2.start;\\n    }\\n    \\n    void update_end(const Interval &i, int end) {\\n        const_cast<Interval &>(i).end = end;\\n    }\\n    \\n    class SummaryRanges {\\n        set<Interval> data;\\n    \\n    public:\\n        SummaryRanges() {}\\n    \\n        void addNum(int val) {\\n            Interval i(val, val);\\n    \\n            auto &&next = upper_bound(data.begin(), data.end(), i);\\n    \\n            if (next != data.begin() && next != data.end()) {\\n                auto prev = next; --prev;\\n    \\n                if (prev->end >= val) {\\n                    return;\\n                }\\n            }\\n    \\n            if (next == data.end() && !data.empty()) {\\n                if (data.rbegin()->end >= val) {\\n                    return;\\n                }\\n            }\\n    \\n            auto &&curr = data.insert(next, i);\\n            auto prev = data.end();\\n    \\n            bool erase_curr = false, erase_next = false;\\n    \\n            if (curr != data.begin()) {\\n                prev = curr; --prev;\\n    \\n                if (prev->end == curr->start - 1) {\\n                    update_end(*prev, curr->start);\\n                    erase_curr = true;\\n                }\\n            }\\n    \\n            if (next != data.end()) {\\n                if (next->start == curr->start + 1) {\\n                    if (erase_curr) {\\n                        update_end(*prev, next->end);\\n                    } else {\\n                        update_end(*curr, next->end);\\n                    }\\n    \\n                    erase_next = true;\\n                }\\n            }\\n    \\n            if (erase_curr) {\\n                data.erase(curr);\\n            }\\n    \\n            if (erase_next) {\\n                data.erase(next);\\n            }\\n        }\\n    \\n        vector<Interval> getIntervals() {\\n            return vector<Interval>(data.begin(), data.end());\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 82643,
                "title": "java-194-ms-using-custom-tree-with-merging-nodes-o-intervals-for-space",
                "content": "There are other solutions on the board that use TreeMap and binary search but I decided to try it by building my own binary search tree and merging nodes as I went to keep the tree as small as possible.  \\n\\n    public class SummaryRanges {\\n    private class IntervalNode\\n    {\\n        Interval i;\\n        IntervalNode left;\\n        IntervalNode right;\\n        \\n        public IntervalNode(int begin, int end)\\n        {\\n            i = new Interval(begin, end);\\n        }\\n        \\n        public boolean canMerge(int val)\\n        {\\n            return val >= i.start - 1 && val <= i.end + 1;\\n        }\\n        \\n        public void merge(int val)\\n        {\\n            if (val > i.end) i.end = val;\\n            if (val < i.start) i.start = val;\\n        }\\n        \\n        public boolean canMerge(IntervalNode other)\\n        {\\n            if (other.i.start >= i.start - 1 && other.i.start <= i.end + 1 ||\\n                i.start >= other.i.start - 1 && i.start <= other.i.end + 1) return true;\\n                \\n                return false;\\n        }\\n        \\n        public void mergeNodes(IntervalNode other)\\n        {\\n            if (other.i.start < i.start) i.start = other.i.start;\\n            if (other.i.end > i.end) i.end = other.i.end;\\n        }\\n    }\\n    \\n    private IntervalNode overallRoot;\\n    \\n    // pretty dumb rebalancing but whateva\\n    private void rebalance(IntervalNode root, IntervalNode subTree)\\n    {\\n        if (root.left == null)\\n        {\\n            root.left = subTree;\\n        }\\n        else\\n        {\\n            rebalance(root.left, subTree);\\n        }\\n    }\\n    \\n    private IntervalNode updateTree(IntervalNode root, IntervalNode prevInterval, int val)\\n    {\\n        if (root == null && prevInterval == null)\\n        {\\n            return new IntervalNode(val, val);\\n        }\\n        else if (root == null)\\n        {\\n            return root;\\n        }\\n        \\n        if (root.canMerge(val) && prevInterval == null)\\n        {\\n            root.merge(val);\\n            prevInterval = root;\\n        }\\n        else if (prevInterval != null && root.canMerge(prevInterval))\\n        {\\n            prevInterval.mergeNodes(root);\\n            if (root.right != null)\\n            {\\n                rebalance(root.right, root.left);\\n                return root.right;\\n            }\\n            else\\n            {\\n                return root.left;\\n            }\\n        }\\n        \\n        if (val > root.i.start)\\n        {\\n            root.right = updateTree(root.right, prevInterval, val);\\n        }\\n        else\\n        {\\n            root.left = updateTree(root.left, prevInterval, val);\\n        }\\n        \\n        return root;\\n    }\\n    \\n    public void addNum(int val) {\\n        if (overallRoot == null)\\n        {\\n            overallRoot = new IntervalNode(val, val);\\n        }\\n        else\\n        {\\n            overallRoot = updateTree(overallRoot, null, val);            \\n        }\\n    }\\n    \\n    private void inorder(IntervalNode root, List<Interval> results)\\n    {\\n        if (root != null)\\n        {\\n            inorder(root.left, results);\\n            results.add(root.i);\\n            inorder(root.right, results);\\n        }\\n    }\\n    \\n    public List<Interval> getIntervals() {\\n        List<Interval> results = new ArrayList<Interval>();\\n        inorder(overallRoot, results);\\n        return results;\\n    }\\n}",
                "solutionTags": [],
                "code": "There are other solutions on the board that use TreeMap and binary search but I decided to try it by building my own binary search tree and merging nodes as I went to keep the tree as small as possible.  \\n\\n    public class SummaryRanges {\\n    private class IntervalNode\\n    {\\n        Interval i;\\n        IntervalNode left;\\n        IntervalNode right;\\n        \\n        public IntervalNode(int begin, int end)\\n        {\\n            i = new Interval(begin, end);\\n        }\\n        \\n        public boolean canMerge(int val)\\n        {\\n            return val >= i.start - 1 && val <= i.end + 1;\\n        }\\n        \\n        public void merge(int val)\\n        {\\n            if (val > i.end) i.end = val;\\n            if (val < i.start) i.start = val;\\n        }\\n        \\n        public boolean canMerge(IntervalNode other)\\n        {\\n            if (other.i.start >= i.start - 1 && other.i.start <= i.end + 1 ||\\n                i.start >= other.i.start - 1 && i.start <= other.i.end + 1) return true;\\n                \\n                return false;\\n        }\\n        \\n        public void mergeNodes(IntervalNode other)\\n        {\\n            if (other.i.start < i.start) i.start = other.i.start;\\n            if (other.i.end > i.end) i.end = other.i.end;\\n        }\\n    }\\n    \\n    private IntervalNode overallRoot;\\n    \\n    // pretty dumb rebalancing but whateva\\n    private void rebalance(IntervalNode root, IntervalNode subTree)\\n    {\\n        if (root.left == null)\\n        {\\n            root.left = subTree;\\n        }\\n        else\\n        {\\n            rebalance(root.left, subTree);\\n        }\\n    }\\n    \\n    private IntervalNode updateTree(IntervalNode root, IntervalNode prevInterval, int val)\\n    {\\n        if (root == null && prevInterval == null)\\n        {\\n            return new IntervalNode(val, val);\\n        }\\n        else if (root == null)\\n        {\\n            return root;\\n        }\\n        \\n        if (root.canMerge(val) && prevInterval == null)\\n        {\\n            root.merge(val);\\n            prevInterval = root;\\n        }\\n        else if (prevInterval != null && root.canMerge(prevInterval))\\n        {\\n            prevInterval.mergeNodes(root);\\n            if (root.right != null)\\n            {\\n                rebalance(root.right, root.left);\\n                return root.right;\\n            }\\n            else\\n            {\\n                return root.left;\\n            }\\n        }\\n        \\n        if (val > root.i.start)\\n        {\\n            root.right = updateTree(root.right, prevInterval, val);\\n        }\\n        else\\n        {\\n            root.left = updateTree(root.left, prevInterval, val);\\n        }\\n        \\n        return root;\\n    }\\n    \\n    public void addNum(int val) {\\n        if (overallRoot == null)\\n        {\\n            overallRoot = new IntervalNode(val, val);\\n        }\\n        else\\n        {\\n            overallRoot = updateTree(overallRoot, null, val);            \\n        }\\n    }\\n    \\n    private void inorder(IntervalNode root, List<Interval> results)\\n    {\\n        if (root != null)\\n        {\\n            inorder(root.left, results);\\n            results.add(root.i);\\n            inorder(root.right, results);\\n        }\\n    }\\n    \\n    public List<Interval> getIntervals() {\\n        List<Interval> results = new ArrayList<Interval>();\\n        inorder(overallRoot, results);\\n        return results;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 82658,
                "title": "not-very-concise-but-easy-to-read-java-solution-o-logn-per-input",
                "content": "Java is not my primary languages. However, this question is not easy to implement in C++. I tried the pb_ds/tree, it solves the problem, but for sure not as convenient as Java TreeMap.\\n\\n    public class SummaryRanges {\\n    \\n        /** Initialize your data structure here. */\\n        private TreeMap<Integer, Integer> tree;\\n        \\n        public SummaryRanges() {\\n            tree = new TreeMap<>();\\n        }\\n        \\n        public void addNum(int val) {\\n            // Value existed as key\\n            if (tree.get(val) != null)\\n                return;\\n    \\n            // Value existed inside intervals\\n            Map.Entry<Integer, Integer> low = tree.lowerEntry(val);\\n            if (low != null && low.getValue() >= val)\\n                return;\\n    \\n            // Value can merge to end\\n            if (low != null && low.getValue() + 1 == val) {\\n                if (tree.get(val + 1) != null) {\\n                    int start = low.getKey();\\n                    int end = tree.get(val + 1);\\n                    tree.remove(val + 1);\\n                    tree.remove(low.getKey());\\n                    tree.put(start, end);\\n                }\\n                else\\n                    tree.put(low.getKey(), val);\\n                return;\\n            }\\n    \\n            // Value can merge to start\\n            Map.Entry<Integer, Integer> high = tree.higherEntry(val);\\n            if (high != null && high.getKey() == val + 1) {\\n                int end = high.getValue();\\n                tree.remove(high.getKey());\\n                tree.put(val, end);\\n                return;\\n            }\\n    \\n            // Isolated new value\\n            tree.put(val, val);\\n        }        \\n        \\n        public List<Interval> getIntervals() {\\n            List<Interval> l = new LinkedList<>();\\n    \\n            for (Map.Entry<Integer, Integer> entry : tree.entrySet())\\n                l.add(new Interval(entry.getKey(), entry.getValue()));\\n    \\n            return l;        \\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Tree"
                ],
                "code": "Java is not my primary languages. However, this question is not easy to implement in C++. I tried the pb_ds/tree, it solves the problem, but for sure not as convenient as Java TreeMap.\\n\\n    public class SummaryRanges {\\n    \\n        /** Initialize your data structure here. */\\n        private TreeMap<Integer, Integer> tree;\\n        \\n        public SummaryRanges() {\\n            tree = new TreeMap<>();\\n        }\\n        \\n        public void addNum(int val) {\\n            // Value existed as key\\n            if (tree.get(val) != null)\\n                return;\\n    \\n            // Value existed inside intervals\\n            Map.Entry<Integer, Integer> low = tree.lowerEntry(val);\\n            if (low != null && low.getValue() >= val)\\n                return;\\n    \\n            // Value can merge to end\\n            if (low != null && low.getValue() + 1 == val) {\\n                if (tree.get(val + 1) != null) {\\n                    int start = low.getKey();\\n                    int end = tree.get(val + 1);\\n                    tree.remove(val + 1);\\n                    tree.remove(low.getKey());\\n                    tree.put(start, end);\\n                }\\n                else\\n                    tree.put(low.getKey(), val);\\n                return;\\n            }\\n    \\n            // Value can merge to start\\n            Map.Entry<Integer, Integer> high = tree.higherEntry(val);\\n            if (high != null && high.getKey() == val + 1) {\\n                int end = high.getValue();\\n                tree.remove(high.getKey());\\n                tree.put(val, end);\\n                return;\\n            }\\n    \\n            // Isolated new value\\n            tree.put(val, val);\\n        }        \\n        \\n        public List<Interval> getIntervals() {\\n            List<Interval> l = new LinkedList<>();\\n    \\n            for (Map.Entry<Integer, Integer> entry : tree.entrySet())\\n                l.add(new Interval(entry.getKey(), entry.getValue()));\\n    \\n            return l;        \\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3837520,
                "title": "decompose-into-logical-braches-relatively-easy",
                "content": "Looking at the examples we can see its split into three general cases when adding a new number\\n1. create new interval\\n2. merge two intervals\\n3. add number to existing interval\\n\\nLooking at the three cases, when does each happen?\\n\\n1. when 2 and 3 are **both** not met\\n2. when the number is within one of the end **and** start of two **consecutive** intervals\\n3. when the number is within one of a start **or** end of only **one** existing interval\\n\\nThe only issue is now dealing with edge cases of when found interval is begin or end.\\n\\nUse a ordered tree structure to make modification and lookup `O(lg(sz(M_n))) \\u2208 O(lg(calls to addNum))` aswell as `upper_bound \\u2208 O(lg(sz(M_n)))`, or in general terms `addNum \\u2208 O(nlg(n))` for a series of`n` calls. Of course `getIntervals \\u2208 O(n * m)` for a series of `n` and `m` calls to `getIntervals` and `addNum` respectively .\\n```\\nclass SummaryRanges\\n{\\n    \\n  public:\\n    \\n    map<int,int> M_p;\\n    \\n    void addNum(int v)\\n    {\\n        auto iter = M_p.upper_bound(v);\\n        \\n        const auto r_diff = iter == end(M_p)\\n            ? 2\\n            : iter->first - v;\\n        const auto l_diff = iter == begin(M_p)\\n            ? 2\\n            : v - prev(iter)->second;\\n        \\n        if (r_diff > 1 && l_diff > 1)\\n        {\\n            // insert new\\n            M_p[v] = v;\\n        }\\n        else if (r_diff == 1 && l_diff == 1)\\n        {\\n            // delete right and make that end left end\\n            prev(iter)->second = iter->second;\\n            M_p.erase(iter);\\n        }\\n        else if (r_diff == 1)\\n        {\\n            // update beginning of right\\n            M_p[v] = iter->second;\\n            M_p.erase(iter);\\n        }\\n        else if (l_diff == 1)\\n        {\\n            // update beginning of left\\n            prev(iter)->second = v;\\n        }\\n    }\\n    \\n    vector<vector<int>> getIntervals()\\n    {\\n        vector<vector<int>> v;\\n\\n        for (const auto& [a,b] : M_p)\\n        {\\n            v.push_back({a,b});\\n        }\\n        \\n        return v;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass SummaryRanges\\n{\\n    \\n  public:\\n    \\n    map<int,int> M_p;\\n    \\n    void addNum(int v)\\n    {\\n        auto iter = M_p.upper_bound(v);\\n        \\n        const auto r_diff = iter == end(M_p)\\n            ? 2\\n            : iter->first - v;\\n        const auto l_diff = iter == begin(M_p)\\n            ? 2\\n            : v - prev(iter)->second;\\n        \\n        if (r_diff > 1 && l_diff > 1)\\n        {\\n            // insert new\\n            M_p[v] = v;\\n        }\\n        else if (r_diff == 1 && l_diff == 1)\\n        {\\n            // delete right and make that end left end\\n            prev(iter)->second = iter->second;\\n            M_p.erase(iter);\\n        }\\n        else if (r_diff == 1)\\n        {\\n            // update beginning of right\\n            M_p[v] = iter->second;\\n            M_p.erase(iter);\\n        }\\n        else if (l_diff == 1)\\n        {\\n            // update beginning of left\\n            prev(iter)->second = v;\\n        }\\n    }\\n    \\n    vector<vector<int>> getIntervals()\\n    {\\n        vector<vector<int>> v;\\n\\n        for (const auto& [a,b] : M_p)\\n        {\\n            v.push_back({a,b});\\n        }\\n        \\n        return v;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693357,
                "title": "c-using-union-find",
                "content": "\\n# Code\\n```\\nclass SummaryRanges {\\npublic:\\n    \\n    vector<int> parent;\\n    vector<int> size;\\n    int mx = 0;\\n    SummaryRanges() {\\n      parent.resize(10001, -1);\\n      size.resize(10001, 1);\\n       mx = 0;\\n    }\\n    \\n    void make(int val)\\n    {\\n        if(parent[val]==-1)\\n        parent[val] = val;\\n    }\\n\\n    int findpar(int a)\\n    {\\n        if(parent[a]==a)\\n        return a;\\n        return parent[a] = findpar(parent[a]);\\n    }\\n\\n    void Union(int a, int b)\\n    {\\n        a = findpar(a);\\n        b = findpar(b);\\n        parent[b] = a;\\n        size[a] += size[b];\\n    }\\n\\n    void addNum(int value) {\\n         mx = max(value, mx);\\n         make(value);\\n         if(value-1>=0 && parent[value-1]!=-1)\\n         {\\n             if(findpar(value)!=findpar(value-1))\\n             Union(value-1, value);\\n         }\\n         if(value+1<=10000 && parent[value+1]!=-1)\\n         {\\n             if(findpar(value)!=findpar(value+1))\\n             Union(value, value+1);\\n         }\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n           vector<vector<int>> ans;\\n           for(int i = 0; i<=mx; i++)\\n           {\\n               if(parent[i]==i)\\n               {\\n                  vector<int> v = {i, i+size[i]-1};\\n                  ans.push_back(v);\\n               }\\n           }\\n           return ans;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass SummaryRanges {\\npublic:\\n    \\n    vector<int> parent;\\n    vector<int> size;\\n    int mx = 0;\\n    SummaryRanges() {\\n      parent.resize(10001, -1);\\n      size.resize(10001, 1);\\n       mx = 0;\\n    }\\n    \\n    void make(int val)\\n    {\\n        if(parent[val]==-1)\\n        parent[val] = val;\\n    }\\n\\n    int findpar(int a)\\n    {\\n        if(parent[a]==a)\\n        return a;\\n        return parent[a] = findpar(parent[a]);\\n    }\\n\\n    void Union(int a, int b)\\n    {\\n        a = findpar(a);\\n        b = findpar(b);\\n        parent[b] = a;\\n        size[a] += size[b];\\n    }\\n\\n    void addNum(int value) {\\n         mx = max(value, mx);\\n         make(value);\\n         if(value-1>=0 && parent[value-1]!=-1)\\n         {\\n             if(findpar(value)!=findpar(value-1))\\n             Union(value-1, value);\\n         }\\n         if(value+1<=10000 && parent[value+1]!=-1)\\n         {\\n             if(findpar(value)!=findpar(value+1))\\n             Union(value, value+1);\\n         }\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n           vector<vector<int>> ans;\\n           for(int i = 0; i<=mx; i++)\\n           {\\n               if(parent[i]==i)\\n               {\\n                  vector<int> v = {i, i+size[i]-1};\\n                  ans.push_back(v);\\n               }\\n           }\\n           return ans;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650379,
                "title": "buum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.hashmap=set()\\n    def addNum(self, value: int) -> None:\\n        self.hashmap.add(value)\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        if len(self.hashmap)==0:return []\\n        arr=sorted(self.hashmap)\\n        res=[[arr[0],arr[0]]]\\n        for i in range(1,len(arr)):\\n            if arr[i]==res[-1][-1]+1:res[-1][-1]=arr[i]\\n            else:res.append([arr[i],arr[i]])\\n        return res\\n# Your SummaryRanges object will be instantiated and called as such:\\n# obj = SummaryRanges()\\n# obj.addNum(value)\\n# param_2 = obj.getIntervals()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.hashmap=set()\\n    def addNum(self, value: int) -> None:\\n        self.hashmap.add(value)\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        if len(self.hashmap)==0:return []\\n        arr=sorted(self.hashmap)\\n        res=[[arr[0],arr[0]]]\\n        for i in range(1,len(arr)):\\n            if arr[i]==res[-1][-1]+1:res[-1][-1]=arr[i]\\n            else:res.append([arr[i],arr[i]])\\n        return res\\n# Your SummaryRanges object will be instantiated and called as such:\\n# obj = SummaryRanges()\\n# obj.addNum(value)\\n# param_2 = obj.getIntervals()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451934,
                "title": "c-concise-union-find-solution",
                "content": "The idea is very simple: apply union-find on each inserted number, and if it can be unioned with adjacent intervals, then union.\\n\\nKeep invariant: for a given interval `[left, right]`, guarantee that `p[left] = left`, `p[right] = left`.\\n\\n# Code\\n```\\nstruct Interval {\\n  int left;\\n  int right;\\n};\\n\\nclass SummaryRanges {\\n public:\\n  void add_num(int value) {\\n    if (p.contains(value)) return;\\n    p[value] = value;\\n    roots.insert(value);\\n    m[value] = {value, value};\\n\\n    if (p.contains(value-1)) merge(p[value-1], p[value]);\\n    if (p.contains(value+1)) merge(p[value], p[value+1]);\\n  }\\n\\n  vector<Interval> get_intervals() {\\n    vector<Interval> result;\\n    for (int root : roots) result.push_back(m[root]);\\n    return result;\\n  }\\n\\n private:\\n  void merge(int ra, int rb) {\\n    m[ra].right = m[rb].right;\\n    m.erase(rb);\\n    roots.erase(rb);\\n    p[m[ra].left] = ra;\\n    p[m[ra].right] = ra;\\n  }\\n\\n  unordered_map<int, int> p;  // p[x] = y: x\\'s parent is y\\n  set<int> roots;  // disjoint roots\\n  unordered_map<int, Interval> m;  // m[root] = [left, right]\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Interval {\\n  int left;\\n  int right;\\n};\\n\\nclass SummaryRanges {\\n public:\\n  void add_num(int value) {\\n    if (p.contains(value)) return;\\n    p[value] = value;\\n    roots.insert(value);\\n    m[value] = {value, value};\\n\\n    if (p.contains(value-1)) merge(p[value-1], p[value]);\\n    if (p.contains(value+1)) merge(p[value], p[value+1]);\\n  }\\n\\n  vector<Interval> get_intervals() {\\n    vector<Interval> result;\\n    for (int root : roots) result.push_back(m[root]);\\n    return result;\\n  }\\n\\n private:\\n  void merge(int ra, int rb) {\\n    m[ra].right = m[rb].right;\\n    m.erase(rb);\\n    roots.erase(rb);\\n    p[m[ra].left] = ra;\\n    p[m[ra].right] = ra;\\n  }\\n\\n  unordered_map<int, int> p;  // p[x] = y: x\\'s parent is y\\n  set<int> roots;  // disjoint roots\\n  unordered_map<int, Interval> m;  // m[root] = [left, right]\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418841,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SummaryRanges {\\n    private Map<Integer,Integer> intervals;\\n    public SummaryRanges() {\\n        intervals = new TreeMap<>();\\n    }\\n    public void addNum(int value) {\\n        if(intervals.isEmpty()){\\n            intervals.put(value,value);\\n            return;\\n        }\\n        validate(value);\\n    }\\n    private void validate(int k){\\n        for (Map.Entry<Integer,Integer> entry : intervals.entrySet()) {\\n            Integer value = entry.getValue();\\n            Integer key = entry.getKey();\\n            if(key<=k && k<=value){\\n                return;\\n            }\\n            if(k+1 == key){\\n                intervals.put(k,value);\\n                intervals.remove(key);\\n                return;\\n            }\\n            if(k-1 == value){\\n                intervals.put(key,k);\\n                if(intervals.containsKey(k+1)){\\n                    intervals.put(key,intervals.get(k+1));\\n                    intervals.remove(k+1);\\n                }\\n                return;\\n            }\\n        }\\n        intervals.put(k, k);\\n    }\\n\\n    public int[][] getIntervals() {\\n        if(intervals.size()==0){\\n            return new int[0][0];\\n        }\\n\\n        int[][] res = new int[intervals.size()][2];\\n        int index=0;\\n        for (Map.Entry<Integer,Integer> entry : intervals.entrySet()) {\\n            Integer value = entry.getValue();\\n            Integer key = entry.getKey();\\n            res[index][0]=key;\\n            res[index][1]=value;\\n            index++;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SummaryRanges {\\n    private Map<Integer,Integer> intervals;\\n    public SummaryRanges() {\\n        intervals = new TreeMap<>();\\n    }\\n    public void addNum(int value) {\\n        if(intervals.isEmpty()){\\n            intervals.put(value,value);\\n            return;\\n        }\\n        validate(value);\\n    }\\n    private void validate(int k){\\n        for (Map.Entry<Integer,Integer> entry : intervals.entrySet()) {\\n            Integer value = entry.getValue();\\n            Integer key = entry.getKey();\\n            if(key<=k && k<=value){\\n                return;\\n            }\\n            if(k+1 == key){\\n                intervals.put(k,value);\\n                intervals.remove(key);\\n                return;\\n            }\\n            if(k-1 == value){\\n                intervals.put(key,k);\\n                if(intervals.containsKey(k+1)){\\n                    intervals.put(key,intervals.get(k+1));\\n                    intervals.remove(k+1);\\n                }\\n                return;\\n            }\\n        }\\n        intervals.put(k, k);\\n    }\\n\\n    public int[][] getIntervals() {\\n        if(intervals.size()==0){\\n            return new int[0][0];\\n        }\\n\\n        int[][] res = new int[intervals.size()][2];\\n        int index=0;\\n        for (Map.Entry<Integer,Integer> entry : intervals.entrySet()) {\\n            Integer value = entry.getValue();\\n            Integer key = entry.getKey();\\n            res[index][0]=key;\\n            res[index][1]=value;\\n            index++;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412385,
                "title": "java-clean-unionfind-solution",
                "content": "\\n```java\\nclass SummaryRanges {\\n    UnionFind uf;\\n\\n    public SummaryRanges() {\\n        uf = new UnionFind();\\n    }\\n\\n    public void addNum(int value) {\\n        uf.add(value);\\n        if (uf.contains(value - 1)) uf.union(value, value - 1);\\n        if (uf.contains(value + 1)) uf.union(value, value + 1);\\n    }\\n\\n    public int[][] getIntervals() {\\n        List<int[]> res = uf.getIntervals();\\n        return res\\n                .stream()\\n                .sorted(Comparator.comparingInt(a -> a[0]))\\n                .toArray(int[][]::new);\\n    }\\n}\\n\\nclass UnionFind {\\n    HashMap<Integer, Integer> boss;\\n    HashMap<Integer, int[]> interval;\\n    HashMap<Integer, Integer> size;\\n\\n    UnionFind() {\\n        boss = new HashMap<>();\\n        size = new HashMap<>();\\n        interval = new HashMap<>();\\n    }\\n\\n    int find(int i) {\\n        if (i != boss.get(i)) {\\n            boss.put(i, find(boss.get(i)));\\n        }\\n        return boss.get(i);\\n    }\\n\\n    void add(int i) {\\n        if (contains(i)) return;\\n        boss.put(i, i);\\n        interval.put(i, new int[]{i, i});\\n        size.put(i, 1);\\n    }\\n\\n    void union(int i, int j) {\\n        int f1 = find(i);\\n        int f2 = find(j);\\n        if (f1 == f2) return;\\n        int left = Math.min(interval.get(f1)[0], interval.get(f2)[0]);\\n        int right = Math.max(interval.get(f1)[1], interval.get(f2)[1]);\\n        if (size.get(f1) > size.get(f2)) {\\n            boss.put(f2, f1);\\n            size.put(f1, size.get(f1) + size.get(f2));\\n            interval.put(f1, new int[]{left, right});\\n        } else {\\n            boss.put(f1, f2);\\n            size.put(f2, size.get(f1) + size.get(f2));\\n            interval.put(f2, new int[]{left, right});\\n        }\\n    }\\n\\n    boolean contains(int i) {\\n        return boss.containsKey(i);\\n    }\\n\\n    List<int[]> getIntervals() {\\n        return boss.keySet().stream().filter(a -> boss.get(a) == a).map(interval::get).toList();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass SummaryRanges {\\n    UnionFind uf;\\n\\n    public SummaryRanges() {\\n        uf = new UnionFind();\\n    }\\n\\n    public void addNum(int value) {\\n        uf.add(value);\\n        if (uf.contains(value - 1)) uf.union(value, value - 1);\\n        if (uf.contains(value + 1)) uf.union(value, value + 1);\\n    }\\n\\n    public int[][] getIntervals() {\\n        List<int[]> res = uf.getIntervals();\\n        return res\\n                .stream()\\n                .sorted(Comparator.comparingInt(a -> a[0]))\\n                .toArray(int[][]::new);\\n    }\\n}\\n\\nclass UnionFind {\\n    HashMap<Integer, Integer> boss;\\n    HashMap<Integer, int[]> interval;\\n    HashMap<Integer, Integer> size;\\n\\n    UnionFind() {\\n        boss = new HashMap<>();\\n        size = new HashMap<>();\\n        interval = new HashMap<>();\\n    }\\n\\n    int find(int i) {\\n        if (i != boss.get(i)) {\\n            boss.put(i, find(boss.get(i)));\\n        }\\n        return boss.get(i);\\n    }\\n\\n    void add(int i) {\\n        if (contains(i)) return;\\n        boss.put(i, i);\\n        interval.put(i, new int[]{i, i});\\n        size.put(i, 1);\\n    }\\n\\n    void union(int i, int j) {\\n        int f1 = find(i);\\n        int f2 = find(j);\\n        if (f1 == f2) return;\\n        int left = Math.min(interval.get(f1)[0], interval.get(f2)[0]);\\n        int right = Math.max(interval.get(f1)[1], interval.get(f2)[1]);\\n        if (size.get(f1) > size.get(f2)) {\\n            boss.put(f2, f1);\\n            size.put(f1, size.get(f1) + size.get(f2));\\n            interval.put(f1, new int[]{left, right});\\n        } else {\\n            boss.put(f1, f2);\\n            size.put(f2, size.get(f1) + size.get(f2));\\n            interval.put(f2, new int[]{left, right});\\n        }\\n    }\\n\\n    boolean contains(int i) {\\n        return boss.containsKey(i);\\n    }\\n\\n    List<int[]> getIntervals() {\\n        return boss.keySet().stream().filter(a -> boss.get(a) == a).map(interval::get).toList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111832,
                "title": "simple-typescript-javascript-solution-with-binary-search-o-log-n",
                "content": "# Code\\n```typescript\\nclass SummaryRanges {\\n  private intervals: number[][] = [];\\n\\n  // O(log(n))\\n  public addNum(num: number, start = 0, end = this.intervals.length): void {\\n    const { intervals } = this;\\n    if (start === end) {\\n      intervals.splice(start, 0, [num, num]);\\n      return;\\n    }\\n    const middleIndex = start + Math.floor((end - start) / 2);\\n    const [min, max] = intervals[middleIndex];\\n    if (num < min - 1) this.addNum(num, start, middleIndex);\\n    if (num > max + 1) this.addNum(num, middleIndex + 1, end);\\n    const middleInterval = intervals[middleIndex];\\n    if (num === max + 1) {\\n      middleInterval[1] =\\n        intervals[middleIndex + 1]?.[0] === num + 1\\n          ? intervals.splice(middleIndex + 1, 1)[0][1]\\n          : num;\\n    }\\n    if (num === min - 1) {\\n      middleInterval[0] =\\n        intervals[middleIndex - 1]?.[1] === num - 1\\n          ? intervals.splice(middleIndex - 1, 1)[0][0]\\n          : num;\\n    }\\n  }\\n\\n  // O(1)\\n  public getIntervals(): number[][] {\\n    return this.intervals;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Binary Search"
                ],
                "code": "```typescript\\nclass SummaryRanges {\\n  private intervals: number[][] = [];\\n\\n  // O(log(n))\\n  public addNum(num: number, start = 0, end = this.intervals.length): void {\\n    const { intervals } = this;\\n    if (start === end) {\\n      intervals.splice(start, 0, [num, num]);\\n      return;\\n    }\\n    const middleIndex = start + Math.floor((end - start) / 2);\\n    const [min, max] = intervals[middleIndex];\\n    if (num < min - 1) this.addNum(num, start, middleIndex);\\n    if (num > max + 1) this.addNum(num, middleIndex + 1, end);\\n    const middleInterval = intervals[middleIndex];\\n    if (num === max + 1) {\\n      middleInterval[1] =\\n        intervals[middleIndex + 1]?.[0] === num + 1\\n          ? intervals.splice(middleIndex + 1, 1)[0][1]\\n          : num;\\n    }\\n    if (num === min - 1) {\\n      middleInterval[0] =\\n        intervals[middleIndex - 1]?.[1] === num - 1\\n          ? intervals.splice(middleIndex - 1, 1)[0][0]\\n          : num;\\n    }\\n  }\\n\\n  // O(1)\\n  public getIntervals(): number[][] {\\n    return this.intervals;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111074,
                "title": "python3-o-n-time-o-n-space",
                "content": "\\n# Code\\n```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.arr = []    \\n\\n    def addNum(self, value: int) -> None:\\n        \\n        ind = self.bi_search(value)\\n        remove_left = False\\n        remove_right = False\\n        if ind == -1 or ind == len(self.arr) or (self.arr[ind] != value and (ind % 2 == 1)):\\n            remove_right = ind + 1 < len(self.arr) and self.arr[ind + 1] == value + 1\\n            remove_left = ind >= 0 and self.arr[ind] == value - 1\\n            if remove_right and remove_left:\\n                del self.arr[ind]\\n                del self.arr[ind]\\n            elif remove_right:\\n                del self.arr[ind + 1]\\n                self.arr.insert(ind + 1, value)\\n            elif remove_left:\\n                del self.arr[ind]\\n                self.arr.insert(ind, value)\\n            else:\\n                self.arr.insert(ind + 1, value)\\n                self.arr.insert(ind + 1, value)\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        return [[self.arr[i], self.arr[i + 1]] for i in range(0, len(self.arr), 2)]\\n\\n    def bi_search(self, x):\\n        \\n        low = 0\\n        high = len(self.arr) - 1\\n        mid = 0\\n    \\n        while low <= high:\\n    \\n            mid = (high + low) // 2\\n    \\n            if self.arr[mid] < x:\\n                low = mid + 1\\n    \\n            elif self.arr[mid] > x:\\n                high = mid - 1\\n            else:\\n               return mid\\n    \\n        return high\\n\\n\\n\\n# Your SummaryRanges object will be instantiated and called as such:\\n# obj = SummaryRanges()\\n# obj.addNum(value)\\n# param_2 = obj.getIntervals()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.arr = []    \\n\\n    def addNum(self, value: int) -> None:\\n        \\n        ind = self.bi_search(value)\\n        remove_left = False\\n        remove_right = False\\n        if ind == -1 or ind == len(self.arr) or (self.arr[ind] != value and (ind % 2 == 1)):\\n            remove_right = ind + 1 < len(self.arr) and self.arr[ind + 1] == value + 1\\n            remove_left = ind >= 0 and self.arr[ind] == value - 1\\n            if remove_right and remove_left:\\n                del self.arr[ind]\\n                del self.arr[ind]\\n            elif remove_right:\\n                del self.arr[ind + 1]\\n                self.arr.insert(ind + 1, value)\\n            elif remove_left:\\n                del self.arr[ind]\\n                self.arr.insert(ind, value)\\n            else:\\n                self.arr.insert(ind + 1, value)\\n                self.arr.insert(ind + 1, value)\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        return [[self.arr[i], self.arr[i + 1]] for i in range(0, len(self.arr), 2)]\\n\\n    def bi_search(self, x):\\n        \\n        low = 0\\n        high = len(self.arr) - 1\\n        mid = 0\\n    \\n        while low <= high:\\n    \\n            mid = (high + low) // 2\\n    \\n            if self.arr[mid] < x:\\n                low = mid + 1\\n    \\n            elif self.arr[mid] > x:\\n                high = mid - 1\\n            else:\\n               return mid\\n    \\n        return high\\n\\n\\n\\n# Your SummaryRanges object will be instantiated and called as such:\\n# obj = SummaryRanges()\\n# obj.addNum(value)\\n# param_2 = obj.getIntervals()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110875,
                "title": "java-solution-beats-94-96-in-time-complexity-and-97-48-in-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SummaryRanges {\\n    int head[];\\n    int max;\\n    public SummaryRanges() {\\n        head = new int[10002];\\n        Arrays.fill(head, -1);\\n        max = 0;\\n    }\\n    \\n    public void addNum(int val) {\\n        max = Math.max(max, val);\\n        if(val == 0)\\n        head[0] = 0;\\n        else {\\n            int prev = findHead(val-1);\\n            if(prev != -1) {\\n                head[val] = prev;\\n            }\\n            else {\\n                head[val] = val;\\n            }\\n        }\\n        \\n        if(head[val+1] != -1) {\\n            head[val+1] = head[val];\\n        }\\n    }\\n    \\n    public int[][] getIntervals() {\\n        int n = countSets();\\n        int res[][] = new int[n][2];\\n        findSets(res, n);\\n        return res;\\n    }\\n\\n    private int findHead(int x) {\\n        if(head[x] == -1) {\\n            return -1;\\n        }\\n        if(head[x] == x) {\\n            return x;\\n        }\\n        return findHead(head[x]);\\n    }\\n\\n    private int countSets() {\\n        int i = max;\\n        int count = 0;\\n        while(i >= 0) {\\n            int x = findHead(i);\\n            if(x == -1) {\\n                i--;\\n            }\\n            else if(x == i) {\\n                count++;\\n                i--;\\n            }\\n            else {\\n                count++;\\n                i = x-1;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    private void findSets(int res[][], int n) {\\n        int i = max;\\n        int index = n-1;\\n\\n        while(i >= 0) {\\n            int x = findHead(i);\\n            if(x == -1) {\\n                i--;\\n            }\\n            else if(x == i) {\\n                res[index--] = new int[]{x, x};\\n                i--;\\n            }\\n            else {\\n                res[index--] = new int[]{x, i};\\n                i = x-1;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges obj = new SummaryRanges();\\n * obj.addNum(value);\\n * int[][] param_2 = obj.getIntervals();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SummaryRanges {\\n    int head[];\\n    int max;\\n    public SummaryRanges() {\\n        head = new int[10002];\\n        Arrays.fill(head, -1);\\n        max = 0;\\n    }\\n    \\n    public void addNum(int val) {\\n        max = Math.max(max, val);\\n        if(val == 0)\\n        head[0] = 0;\\n        else {\\n            int prev = findHead(val-1);\\n            if(prev != -1) {\\n                head[val] = prev;\\n            }\\n            else {\\n                head[val] = val;\\n            }\\n        }\\n        \\n        if(head[val+1] != -1) {\\n            head[val+1] = head[val];\\n        }\\n    }\\n    \\n    public int[][] getIntervals() {\\n        int n = countSets();\\n        int res[][] = new int[n][2];\\n        findSets(res, n);\\n        return res;\\n    }\\n\\n    private int findHead(int x) {\\n        if(head[x] == -1) {\\n            return -1;\\n        }\\n        if(head[x] == x) {\\n            return x;\\n        }\\n        return findHead(head[x]);\\n    }\\n\\n    private int countSets() {\\n        int i = max;\\n        int count = 0;\\n        while(i >= 0) {\\n            int x = findHead(i);\\n            if(x == -1) {\\n                i--;\\n            }\\n            else if(x == i) {\\n                count++;\\n                i--;\\n            }\\n            else {\\n                count++;\\n                i = x-1;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    private void findSets(int res[][], int n) {\\n        int i = max;\\n        int index = n-1;\\n\\n        while(i >= 0) {\\n            int x = findHead(i);\\n            if(x == -1) {\\n                i--;\\n            }\\n            else if(x == i) {\\n                res[index--] = new int[]{x, x};\\n                i--;\\n            }\\n            else {\\n                res[index--] = new int[]{x, i};\\n                i = x-1;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges obj = new SummaryRanges();\\n * obj.addNum(value);\\n * int[][] param_2 = obj.getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110595,
                "title": "if-you-look-at-my-solution-then-you-will-wonder-if-its-really-hard-faster-than-95-solutions",
                "content": "```\\nclass SummaryRanges {\\n    boolean[] arr;\\n    int size=10001;\\n    int minValue=Integer.MAX_VALUE;\\n    int maxValue=Integer.MIN_VALUE;\\n    public SummaryRanges() {\\n        arr=new boolean[size];\\n    }\\n    \\n    public void addNum(int value) {\\n        arr[value]=true;\\n        minValue=Math.min(minValue,value);\\n        maxValue=Math.max(maxValue,value);\\n    }\\n    \\n    public int[][] getIntervals() {\\n        List<int[]>ls=new ArrayList<>();\\n        for(int i=minValue;i<=maxValue;i++){\\n            if(arr[i]){\\n                int j=i;\\n                while(j++<size && arr[j]);\\n                ls.add(new int[]{i,j-1});\\n                i=j-1;\\n            }\\n        }\\n        int[][] ans=new int[ls.size()][2];\\n        for(int i=0;i<ans.length;i++){\\n            ans[i][0]=ls.get(i)[0];\\n            ans[i][1]=ls.get(i)[1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SummaryRanges {\\n    boolean[] arr;\\n    int size=10001;\\n    int minValue=Integer.MAX_VALUE;\\n    int maxValue=Integer.MIN_VALUE;\\n    public SummaryRanges() {\\n        arr=new boolean[size];\\n    }\\n    \\n    public void addNum(int value) {\\n        arr[value]=true;\\n        minValue=Math.min(minValue,value);\\n        maxValue=Math.max(maxValue,value);\\n    }\\n    \\n    public int[][] getIntervals() {\\n        List<int[]>ls=new ArrayList<>();\\n        for(int i=minValue;i<=maxValue;i++){\\n            if(arr[i]){\\n                int j=i;\\n                while(j++<size && arr[j]);\\n                ls.add(new int[]{i,j-1});\\n                i=j-1;\\n            }\\n        }\\n        int[][] ans=new int[ls.size()][2];\\n        for(int i=0;i<ans.length;i++){\\n            ans[i][0]=ls.get(i)[0];\\n            ans[i][1]=ls.get(i)[1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110478,
                "title": "java-treeset",
                "content": "\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SummaryRanges {\\n\\nTreeSet<Integer> tree;\\n    public SummaryRanges() {\\n      \\n        tree=new TreeSet();\\n    }\\n    \\n    public void addNum(int value) {\\n       \\n       tree.add(value);\\n      \\n    }\\n   \\n    \\n    public int[][] getIntervals() {\\n    List<int[]> list=new ArrayList<>();\\n        int start = tree.first();\\n        int end = tree.first();\\n        int i = 0;\\n        for (Integer val : tree.tailSet(tree.first()+1,true)) {\\n            if (val - end == 1) {\\n                end = val;\\n            } else {\\n               int arr[]=new int[2];\\n               arr[0]=start;\\n               arr[1]=end;\\n               list.add(arr);\\n           \\n                start = end = val;\\n            }\\n        }\\n        int arr[]=new int[2];\\n               arr[0]=start;\\n               arr[1]=end;\\n               list.add(arr);\\n               int intervals[][]=new int[list.size()][2];\\n               for(int[] a: list){\\n                   intervals[i][0]=a[0];\\n                   intervals[i][1]=a[1];\\n                   i++;\\n               }\\n\\n        return intervals;\\n    \\n    }\\n}\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges obj = new SummaryRanges();\\n * obj.addNum(value);\\n * int[][] param_2 = obj.getIntervals();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SummaryRanges {\\n\\nTreeSet<Integer> tree;\\n    public SummaryRanges() {\\n      \\n        tree=new TreeSet();\\n    }\\n    \\n    public void addNum(int value) {\\n       \\n       tree.add(value);\\n      \\n    }\\n   \\n    \\n    public int[][] getIntervals() {\\n    List<int[]> list=new ArrayList<>();\\n        int start = tree.first();\\n        int end = tree.first();\\n        int i = 0;\\n        for (Integer val : tree.tailSet(tree.first()+1,true)) {\\n            if (val - end == 1) {\\n                end = val;\\n            } else {\\n               int arr[]=new int[2];\\n               arr[0]=start;\\n               arr[1]=end;\\n               list.add(arr);\\n           \\n                start = end = val;\\n            }\\n        }\\n        int arr[]=new int[2];\\n               arr[0]=start;\\n               arr[1]=end;\\n               list.add(arr);\\n               int intervals[][]=new int[list.size()][2];\\n               for(int[] a: list){\\n                   intervals[i][0]=a[0];\\n                   intervals[i][1]=a[1];\\n                   i++;\\n               }\\n\\n        return intervals;\\n    \\n    }\\n}\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges obj = new SummaryRanges();\\n * obj.addNum(value);\\n * int[][] param_2 = obj.getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109922,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SummaryRanges {\\npublic:\\n    set<int> st;\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int value) {\\n        st.insert(value);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> ans;\\n        int start = -1;\\n        int end = -1;\\n        for(auto it : st){\\n            if(start == -1 && end == -1) start = end = it;\\n            else if(it == end+1) end++;\\n            else {\\n                ans.push_back({start , end});\\n                start = end = it;\\n            }\\n        }\\n        ans.push_back({start , end});\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SummaryRanges {\\npublic:\\n    set<int> st;\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int value) {\\n        st.insert(value);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> ans;\\n        int start = -1;\\n        int end = -1;\\n        for(auto it : st){\\n            if(start == -1 && end == -1) start = end = it;\\n            else if(it == end+1) end++;\\n            else {\\n                ans.push_back({start , end});\\n                start = end = it;\\n            }\\n        }\\n        ans.push_back({start , end});\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109884,
                "title": "union-find-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse Union Find Algorithm to form sets of continuous ranges.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nForm an array parent and a map intervals to store ranges.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(logN)$$ for addNum.\\n$$O(NlogN)$$ for getIntervals.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$ for parent array and interval.\\n\\n# Code\\n```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.parent = [-1] * 10001\\n        self.intervals = {}\\n\\n    def addNum(self, value: int) -> None:\\n        if self.parent[value] >= 0:\\n            return\\n\\n        leftMerge = value - 1 >= 0 and self.parent[value - 1] >= 0\\n        rightMerge = value + 1 < 10001 and self.parent[value + 1] >= 0\\n\\n        if leftMerge and rightMerge:\\n            self._merge_intervals(value)\\n        elif leftMerge:\\n            leftParent = self._find_parent(value - 1)\\n            self.intervals[leftParent] = (self.intervals[leftParent][0], value)\\n            self.parent[value] = leftParent\\n        elif rightMerge:\\n            rightParent = self._find_parent(value + 1)\\n            self.intervals[rightParent] = (value, self.intervals[rightParent][1])\\n            self.parent[value] = rightParent\\n        else:\\n            self.parent[value] = value\\n            self.intervals[value] = (value, value)\\n\\n    \\n    def _merge_intervals(self, value):\\n        leftParent = self._find_parent(value - 1)\\n        rightParent = self._find_parent(value + 1)\\n        \\n        leftRange = self.intervals[leftParent]\\n        rightRange = self.intervals[rightParent]\\n\\n        self.intervals[leftParent] = (leftRange[0], rightRange[1])\\n        del self.intervals[rightParent]\\n        self.parent[rightParent] = leftParent\\n        self.parent[value] = leftParent\\n\\n    \\n    def _find_parent(self, value):\\n        while self.parent[value] != value:\\n            value = self.parent[value]\\n        return value\\n\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        return sorted(self.intervals.values(), key = lambda k: k[0])\\n        \\n\\n\\n# Your SummaryRanges object will be instantiated and called as such:\\n# obj = SummaryRanges()\\n# obj.addNum(value)\\n# param_2 = obj.getIntervals()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.parent = [-1] * 10001\\n        self.intervals = {}\\n\\n    def addNum(self, value: int) -> None:\\n        if self.parent[value] >= 0:\\n            return\\n\\n        leftMerge = value - 1 >= 0 and self.parent[value - 1] >= 0\\n        rightMerge = value + 1 < 10001 and self.parent[value + 1] >= 0\\n\\n        if leftMerge and rightMerge:\\n            self._merge_intervals(value)\\n        elif leftMerge:\\n            leftParent = self._find_parent(value - 1)\\n            self.intervals[leftParent] = (self.intervals[leftParent][0], value)\\n            self.parent[value] = leftParent\\n        elif rightMerge:\\n            rightParent = self._find_parent(value + 1)\\n            self.intervals[rightParent] = (value, self.intervals[rightParent][1])\\n            self.parent[value] = rightParent\\n        else:\\n            self.parent[value] = value\\n            self.intervals[value] = (value, value)\\n\\n    \\n    def _merge_intervals(self, value):\\n        leftParent = self._find_parent(value - 1)\\n        rightParent = self._find_parent(value + 1)\\n        \\n        leftRange = self.intervals[leftParent]\\n        rightRange = self.intervals[rightParent]\\n\\n        self.intervals[leftParent] = (leftRange[0], rightRange[1])\\n        del self.intervals[rightParent]\\n        self.parent[rightParent] = leftParent\\n        self.parent[value] = leftParent\\n\\n    \\n    def _find_parent(self, value):\\n        while self.parent[value] != value:\\n            value = self.parent[value]\\n        return value\\n\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        return sorted(self.intervals.values(), key = lambda k: k[0])\\n        \\n\\n\\n# Your SummaryRanges object will be instantiated and called as such:\\n# obj = SummaryRanges()\\n# obj.addNum(value)\\n# param_2 = obj.getIntervals()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109657,
                "title": "java-easy-to-understand-treeset-with-intervals",
                "content": "# Github\\nhttps://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/hard/orderedset/SummaryRanges.java\\n\\n# Code\\n```\\nimport java.awt.*;\\nimport java.util.Arrays;\\nimport java.util.TreeSet;\\n\\npublic class SummaryRanges {\\n    private static class Interval extends Point implements Comparable<Interval> {\\n        Interval(int x, int y) {\\n            super(x, y);\\n        }\\n\\n        @Override\\n        public boolean equals(Object other) {\\n            return this.x <= ((Interval) other).x && this.y >= ((Interval) other).y;//full overlap\\n        }\\n\\n        @Override\\n        public int compareTo(Interval other) {\\n            if (other.equals(this)) return 0;\\n            if (this.x == other.x) return this.y - other.y;\\n            return this.x - other.x;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"Interval{\" + \"x=\" + x + \", y=\" + y + \\'}\\';\\n        }\\n    }\\n\\n    private final TreeSet<Interval> _intervals = new TreeSet<>();\\n\\n    public SummaryRanges() {\\n    }\\n\\n    public void addNum(int num) {\\n        insert(new Interval(num, num));\\n    }\\n\\n    public int[][] getIntervals() {\\n        int[][] intervals = new int[_intervals.size()][2];\\n        int i = 0;\\n        for (Interval interval : _intervals) {\\n            intervals[i][0] = interval.x;\\n            intervals[i][1] = interval.y;\\n            i++;\\n        }\\n        return intervals;\\n    }\\n\\n    private void insert(Interval interval) {\\n        var left = _intervals.floor(interval);\\n        var right = _intervals.ceiling(interval);\\n\\n        if (left == null && right == null) {\\n            _intervals.add(interval);\\n        } else if (left == null) {\\n            if (interval.y + 1 == right.x) {\\n                mergeToRight(interval, right);\\n            } else {\\n                _intervals.add(interval);\\n            }\\n        } else if (right == null) {\\n            if (left.y == interval.x - 1) {\\n                mergeToLeft(interval, left);\\n            } else {\\n                _intervals.add(interval);\\n            }\\n        } else {\\n            if (left.y == interval.x - 1 && right.x == interval.y + 1) {\\n                mergeLeftToRight(left, right);\\n            } else if (left.y == interval.x - 1) {\\n                mergeToLeft(interval, left);\\n            } else if (interval.y + 1 == right.x) {\\n                mergeToRight(interval, right);\\n            } else {\\n                _intervals.add(interval);\\n            }\\n        }\\n    }\\n\\n    private void mergeLeftToRight(Interval left, Interval right) {\\n        _intervals.remove(left);\\n        _intervals.remove(right);\\n        _intervals.add(new Interval(left.x, right.y));\\n    }\\n\\n    private void mergeToLeft(Interval interval, Interval left) {\\n        _intervals.remove(left);\\n        _intervals.add(new Interval(left.x, interval.y));\\n    }\\n\\n    private void mergeToRight(Interval interval, Interval right) {\\n        _intervals.remove(right);\\n        _intervals.add(new Interval(interval.x, right.y));\\n    }\\n}\\n\\n```\\n\\n![upvote_meme.jpeg](https://assets.leetcode.com/users/images/5eeacc87-9976-4e22-bd82-63f8435f03d9_1674919182.880324.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.awt.*;\\nimport java.util.Arrays;\\nimport java.util.TreeSet;\\n\\npublic class SummaryRanges {\\n    private static class Interval extends Point implements Comparable<Interval> {\\n        Interval(int x, int y) {\\n            super(x, y);\\n        }\\n\\n        @Override\\n        public boolean equals(Object other) {\\n            return this.x <= ((Interval) other).x && this.y >= ((Interval) other).y;//full overlap\\n        }\\n\\n        @Override\\n        public int compareTo(Interval other) {\\n            if (other.equals(this)) return 0;\\n            if (this.x == other.x) return this.y - other.y;\\n            return this.x - other.x;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"Interval{\" + \"x=\" + x + \", y=\" + y + \\'}\\';\\n        }\\n    }\\n\\n    private final TreeSet<Interval> _intervals = new TreeSet<>();\\n\\n    public SummaryRanges() {\\n    }\\n\\n    public void addNum(int num) {\\n        insert(new Interval(num, num));\\n    }\\n\\n    public int[][] getIntervals() {\\n        int[][] intervals = new int[_intervals.size()][2];\\n        int i = 0;\\n        for (Interval interval : _intervals) {\\n            intervals[i][0] = interval.x;\\n            intervals[i][1] = interval.y;\\n            i++;\\n        }\\n        return intervals;\\n    }\\n\\n    private void insert(Interval interval) {\\n        var left = _intervals.floor(interval);\\n        var right = _intervals.ceiling(interval);\\n\\n        if (left == null && right == null) {\\n            _intervals.add(interval);\\n        } else if (left == null) {\\n            if (interval.y + 1 == right.x) {\\n                mergeToRight(interval, right);\\n            } else {\\n                _intervals.add(interval);\\n            }\\n        } else if (right == null) {\\n            if (left.y == interval.x - 1) {\\n                mergeToLeft(interval, left);\\n            } else {\\n                _intervals.add(interval);\\n            }\\n        } else {\\n            if (left.y == interval.x - 1 && right.x == interval.y + 1) {\\n                mergeLeftToRight(left, right);\\n            } else if (left.y == interval.x - 1) {\\n                mergeToLeft(interval, left);\\n            } else if (interval.y + 1 == right.x) {\\n                mergeToRight(interval, right);\\n            } else {\\n                _intervals.add(interval);\\n            }\\n        }\\n    }\\n\\n    private void mergeLeftToRight(Interval left, Interval right) {\\n        _intervals.remove(left);\\n        _intervals.remove(right);\\n        _intervals.add(new Interval(left.x, right.y));\\n    }\\n\\n    private void mergeToLeft(Interval interval, Interval left) {\\n        _intervals.remove(left);\\n        _intervals.add(new Interval(left.x, interval.y));\\n    }\\n\\n    private void mergeToRight(Interval interval, Interval right) {\\n        _intervals.remove(right);\\n        _intervals.add(new Interval(interval.x, right.y));\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109568,
                "title": "detailed-video-explanation-c-hashmap-beginner-friendly",
                "content": "# Intuition and Approach\\n  https://youtu.be/BUrO96SUYBk\\n\\n# Complexity\\n- Time complexity: \\n  addNum()   - O(logn)\\n  getIntervals() - O(n)\\n  where n is the length of intervals\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    O(n)\\n  where n is the length of interval\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SummaryRanges {\\npublic:\\n    map<int,int> mp;\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int value) {\\n        auto t=mp.upper_bound(value);\\n        auto k=t;\\n        if(t!=mp.begin())\\n         k--;\\n        int a=value,b=value;\\n        if(t!=mp.begin() && (value<=k->second+1))\\n        {\\n            a=k->first;\\n            b=max(k->second,value);\\n            mp.erase(k);\\n        }\\n        if(t!=mp.end() && value+1==t->first)\\n        {\\n            b=t->second;\\n            mp.erase(t);\\n        }\\n        mp.insert({a,b});\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> res;\\n        for(auto m:mp)\\n         res.push_back({m.first,m.second});\\n        return res;\\n    }\\n};           \\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search",
                    "Ordered Map"
                ],
                "code": "```\\nclass SummaryRanges {\\npublic:\\n    map<int,int> mp;\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int value) {\\n        auto t=mp.upper_bound(value);\\n        auto k=t;\\n        if(t!=mp.begin())\\n         k--;\\n        int a=value,b=value;\\n        if(t!=mp.begin() && (value<=k->second+1))\\n        {\\n            a=k->first;\\n            b=max(k->second,value);\\n            mp.erase(k);\\n        }\\n        if(t!=mp.end() && value+1==t->first)\\n        {\\n            b=t->second;\\n            mp.erase(t);\\n        }\\n        mp.insert({a,b});\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> res;\\n        for(auto m:mp)\\n         res.push_back({m.first,m.second});\\n        return res;\\n    }\\n};           \\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109544,
                "title": "c-using-set-and-left-right-values-concept",
                "content": "# Intuition\\nRight and Left values of the numbers will be recorded and if we encounter adjacent values, we will deal with the right left values accordingly. \\n\\n# Approach\\nWe just maintain a set of the left and right values of all possible ranges and delete the middle elements so as to save the complexity.\\nAlso the for the first and last values of ranges, both times the range will be pushed into vector, so we avoid it by using ordered set and in that way we also sort it.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass SummaryRanges {\\npublic:\\n    SummaryRanges() {\\n        \\n    }\\n    unordered_map<int,int>righttovalue,lefttovalue;\\n    unordered_map<int,bool>valueexists;\\n    unordered_map<int,bool>inserted;\\n    unordered_set<int>toconsider;\\n\\n    void addNum(int value) {\\n        valueexists[value]=true;\\n        if(inserted[value])\\n        {\\n            return;\\n        }\\n        if(valueexists[value+1] && valueexists[value-1])\\n        {\\n            lefttovalue[righttovalue[value+1]]=lefttovalue[value-1];\\n            righttovalue[lefttovalue[value-1]]=righttovalue[value+1];\\n            if(lefttovalue[value-1]!=(value-1))\\n            {\\n                toconsider.erase(value-1);\\n            }\\n            if(righttovalue[value+1]!=(value+1))\\n            {\\n                toconsider.erase(value+1);\\n            }\\n        }\\n        else if(valueexists[value+1] && !valueexists[value-1])\\n        {\\n            lefttovalue[righttovalue[value+1]]=value;\\n            righttovalue[value]=righttovalue[value+1];\\n            lefttovalue[value]=value;\\n            if(righttovalue[value+1]!=(value+1))\\n            {\\n                toconsider.erase(value+1);\\n            }\\n            toconsider.insert(value);\\n        }\\n        else if(!valueexists[value+1] && valueexists[value-1])\\n        {\\n            righttovalue[lefttovalue[value-1]]=value;\\n            lefttovalue[value]=lefttovalue[value-1];\\n            righttovalue[value]=value;\\n            if(lefttovalue[value-1]!=(value-1))\\n            {\\n                toconsider.erase(value-1);\\n            }\\n            toconsider.insert(value);\\n        }\\n        else\\n        {\\n            righttovalue[value]=value;\\n            lefttovalue[value]=value;\\n            toconsider.insert(value);\\n        }\\n        inserted[value]=true;\\n        return;\\n    }\\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>>ans;\\n        set<vector<int>>ANS;\\n        for(auto j:toconsider)\\n        {\\n            ANS.insert({lefttovalue[j],righttovalue[j]});\\n        }\\n        set<vector<int>>::iterator itr;\\n        for(itr=ANS.begin();itr!=ANS.end();itr++)\\n        {\\n            ans.push_back(*itr);\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass SummaryRanges {\\npublic:\\n    SummaryRanges() {\\n        \\n    }\\n    unordered_map<int,int>righttovalue,lefttovalue;\\n    unordered_map<int,bool>valueexists;\\n    unordered_map<int,bool>inserted;\\n    unordered_set<int>toconsider;\\n\\n    void addNum(int value) {\\n        valueexists[value]=true;\\n        if(inserted[value])\\n        {\\n            return;\\n        }\\n        if(valueexists[value+1] && valueexists[value-1])\\n        {\\n            lefttovalue[righttovalue[value+1]]=lefttovalue[value-1];\\n            righttovalue[lefttovalue[value-1]]=righttovalue[value+1];\\n            if(lefttovalue[value-1]!=(value-1))\\n            {\\n                toconsider.erase(value-1);\\n            }\\n            if(righttovalue[value+1]!=(value+1))\\n            {\\n                toconsider.erase(value+1);\\n            }\\n        }\\n        else if(valueexists[value+1] && !valueexists[value-1])\\n        {\\n            lefttovalue[righttovalue[value+1]]=value;\\n            righttovalue[value]=righttovalue[value+1];\\n            lefttovalue[value]=value;\\n            if(righttovalue[value+1]!=(value+1))\\n            {\\n                toconsider.erase(value+1);\\n            }\\n            toconsider.insert(value);\\n        }\\n        else if(!valueexists[value+1] && valueexists[value-1])\\n        {\\n            righttovalue[lefttovalue[value-1]]=value;\\n            lefttovalue[value]=lefttovalue[value-1];\\n            righttovalue[value]=value;\\n            if(lefttovalue[value-1]!=(value-1))\\n            {\\n                toconsider.erase(value-1);\\n            }\\n            toconsider.insert(value);\\n        }\\n        else\\n        {\\n            righttovalue[value]=value;\\n            lefttovalue[value]=value;\\n            toconsider.insert(value);\\n        }\\n        inserted[value]=true;\\n        return;\\n    }\\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>>ans;\\n        set<vector<int>>ANS;\\n        for(auto j:toconsider)\\n        {\\n            ANS.insert({lefttovalue[j],righttovalue[j]});\\n        }\\n        set<vector<int>>::iterator itr;\\n        for(itr=ANS.begin();itr!=ANS.end();itr++)\\n        {\\n            ans.push_back(*itr);\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109514,
                "title": "simple-go-solution-binary-search-with-merge-intervals",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn AddNum operation, we update Intervals. The filed Intervals always has the increasing order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAddNum(Value):\\n1. Find the $$index$$ of interval which start num less than Value\\n2. Insert a new interval with *{Value, Value}*\\n3. Merge three intervals ***Intervals[index]***, *{Value, Value}*, \\n***Intervals[index+1]***\\n\\nGetIntervals\\njust return filed $$Intervals$$\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype SummaryRanges struct {\\n    Intervals [][]int\\n}\\n\\n\\nfunc Constructor() SummaryRanges {\\n    return SummaryRanges{\\n    }\\n}\\n\\n\\nfunc (this *SummaryRanges) AddNum(value int)  {\\n    innerVal := this.Intervals\\n    len := len(innerVal)\\n    firstSmaller := func(target, left, right int) int {\\n        for ; left < right; {\\n            mid := left + (right-left) >> 1\\n            cur := innerVal[mid][0]\\n            if cur < target {\\n                left = mid+1\\n            } else {\\n                right = mid\\n            }\\n        }\\n        left--\\n        return left\\n    }\\n\\n    index := firstSmaller(value, 0, len)\\n    if index + 1 < len && innerVal[index+1][0] == value {\\n        return\\n    }\\n    var change [][]int\\n    var newInterval [][]int\\n    if index >= 0 {\\n        change = append(change, innerVal[index])\\n        newInterval = append(newInterval, innerVal[:index]...)\\n    }\\n\\n    change = append(change, []int{value, value})\\n    if index+1 < len {\\n        change = append(change, innerVal[index+1])\\n    }\\n    change = mergeIntervals(change)\\n\\n    newInterval = append(newInterval,change...)\\n    if index + 2 < len {\\n        newInterval = append(newInterval,innerVal[index+2:]...) \\n    }\\n    this.Intervals = newInterval\\n}\\n\\nfunc mergeIntervals(input [][]int) [][]int {\\n    if len(input) == 0 {\\n        return input\\n    }\\n    var result [][]int\\n    lastInterval := input[0]\\n    for i:=1; i < len(input); i++ {\\n        if input[i][0] - lastInterval[1] > 1 {\\n            result = append(result, lastInterval)\\n            lastInterval = input[i]\\n        } else {\\n            end := lastInterval[1]\\n            if end < input[i][1] {\\n                end = input[i][1]\\n            }\\n            lastInterval = []int{lastInterval[0], end}\\n        }\\n    }\\n    result = append(result, lastInterval)\\n    return result\\n}\\n\\nfunc (this *SummaryRanges) GetIntervals() [][]int {\\n    return this.Intervals\\n}\\n\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.AddNum(value);\\n * param_2 := obj.GetIntervals();\\n */\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search"
                ],
                "code": "```\\ntype SummaryRanges struct {\\n    Intervals [][]int\\n}\\n\\n\\nfunc Constructor() SummaryRanges {\\n    return SummaryRanges{\\n    }\\n}\\n\\n\\nfunc (this *SummaryRanges) AddNum(value int)  {\\n    innerVal := this.Intervals\\n    len := len(innerVal)\\n    firstSmaller := func(target, left, right int) int {\\n        for ; left < right; {\\n            mid := left + (right-left) >> 1\\n            cur := innerVal[mid][0]\\n            if cur < target {\\n                left = mid+1\\n            } else {\\n                right = mid\\n            }\\n        }\\n        left--\\n        return left\\n    }\\n\\n    index := firstSmaller(value, 0, len)\\n    if index + 1 < len && innerVal[index+1][0] == value {\\n        return\\n    }\\n    var change [][]int\\n    var newInterval [][]int\\n    if index >= 0 {\\n        change = append(change, innerVal[index])\\n        newInterval = append(newInterval, innerVal[:index]...)\\n    }\\n\\n    change = append(change, []int{value, value})\\n    if index+1 < len {\\n        change = append(change, innerVal[index+1])\\n    }\\n    change = mergeIntervals(change)\\n\\n    newInterval = append(newInterval,change...)\\n    if index + 2 < len {\\n        newInterval = append(newInterval,innerVal[index+2:]...) \\n    }\\n    this.Intervals = newInterval\\n}\\n\\nfunc mergeIntervals(input [][]int) [][]int {\\n    if len(input) == 0 {\\n        return input\\n    }\\n    var result [][]int\\n    lastInterval := input[0]\\n    for i:=1; i < len(input); i++ {\\n        if input[i][0] - lastInterval[1] > 1 {\\n            result = append(result, lastInterval)\\n            lastInterval = input[i]\\n        } else {\\n            end := lastInterval[1]\\n            if end < input[i][1] {\\n                end = input[i][1]\\n            }\\n            lastInterval = []int{lastInterval[0], end}\\n        }\\n    }\\n    result = append(result, lastInterval)\\n    return result\\n}\\n\\nfunc (this *SummaryRanges) GetIntervals() [][]int {\\n    return this.Intervals\\n}\\n\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.AddNum(value);\\n * param_2 := obj.GetIntervals();\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3109260,
                "title": "clean-python-high-speed-o-n-time-o-1-space-beats-98-9",
                "content": "# Code\\n```\\nclass SummaryRanges:\\n    def __init__(self):\\n        self.intervals = []\\n    def addNum(self, val: int) -> None:\\n        left, right = 0, len(self.intervals) - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            e = self.intervals[mid]\\n            if e[0] <= val <= e[1]: return\\n            elif val < e[0]:right = mid - 1\\n            else:left = mid + 1\\n        pos = left\\n        self.intervals.insert(pos, [val, val])\\n        if pos + 1 < len(self.intervals) and val + 1 == self.intervals[pos+1][0]:\\n            self.intervals[pos][1] = self.intervals[pos+1][1]\\n            del self.intervals[pos+1]\\n        if pos - 1 >= 0 and val - 1 == self.intervals[pos-1][1]:\\n            self.intervals[pos-1][1] = self.intervals[pos][1]\\n            del self.intervals[pos]\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        return self.intervals\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SummaryRanges:\\n    def __init__(self):\\n        self.intervals = []\\n    def addNum(self, val: int) -> None:\\n        left, right = 0, len(self.intervals) - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            e = self.intervals[mid]\\n            if e[0] <= val <= e[1]: return\\n            elif val < e[0]:right = mid - 1\\n            else:left = mid + 1\\n        pos = left\\n        self.intervals.insert(pos, [val, val])\\n        if pos + 1 < len(self.intervals) and val + 1 == self.intervals[pos+1][0]:\\n            self.intervals[pos][1] = self.intervals[pos+1][1]\\n            del self.intervals[pos+1]\\n        if pos - 1 >= 0 and val - 1 == self.intervals[pos-1][1]:\\n            self.intervals[pos-1][1] = self.intervals[pos][1]\\n            del self.intervals[pos]\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        return self.intervals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109171,
                "title": "java-from-672ms-to-113ms-2-solutions",
                "content": "# Solution 1 | 672 ms | 5% Time | 6% Memory\\nUsing 2 PriorityQueues and Set to check if the list of values is unique.\\n```\\nclass SummaryRanges {\\n\\n        PriorityQueue<Integer> pq;\\n        PriorityQueue<Integer> pq2;\\n        Set<Integer> set;\\n        public SummaryRanges() {\\n            pq = new PriorityQueue<>();\\n            pq2 = new PriorityQueue<>();\\n            set = new HashSet<>();\\n        }\\n\\n        public void addNum(int value) {\\n            if (!set.contains(value)) {\\n                pq.add(value);\\n                set.add(value);\\n            }\\n        }\\n\\n        public int[][] getIntervals() {\\n            List<int[]> list = new ArrayList<>();\\n            int temp = pq.poll();\\n            pq2.offer(temp);\\n            int[] arr = new int[2];\\n            arr[0] = temp;\\n            arr[1] = temp;\\n            list.add(arr);\\n            while (!pq.isEmpty()) {\\n                int n = pq.poll();\\n                if (n - temp == 1) {\\n                    arr[1] = n;\\n                    temp = n;\\n                } else {\\n                    arr = new int[2];\\n                    arr[0] = n;\\n                    arr[1] = n;\\n                    list.add(arr);\\n                    temp = n;\\n                }\\n                pq2.offer(n);\\n            }\\n            pq = pq2;\\n            pq2 = new PriorityQueue<>();\\n            int[][] res = new int[list.size()][2];\\n            for (int i = 0; i < list.size(); i++) {\\n                res[i] = list.get(i);\\n            }\\n            return res;\\n        }\\n}\\n```\\n\\n# Solution 2 | 113 ms | 38% Time | 50% Memory\\nUsing TreeSet for all necessary operations above\\n```\\nclass SummaryRanges {\\n\\n    TreeSet<Integer> set;\\n        public SummaryRanges() {\\n            set = new TreeSet<>();\\n        }\\n\\n        public void addNum(int value) {\\n            set.add(value);\\n        }\\n\\n        public int[][] getIntervals() {\\n            List<int[]> list = new ArrayList<>();\\n            int temp = set.first();\\n            int[] arr = new int[2];\\n            arr[0] = temp;\\n            arr[1] = temp;\\n            list.add(arr);\\n            for (Integer n : set) {\\n                if (n == temp) continue;\\n                if (n - temp == 1) {\\n                    arr[1] = n;\\n                    temp = n;\\n                } else {\\n                    arr = new int[2];\\n                    arr[0] = n;\\n                    arr[1] = n;\\n                    list.add(arr);\\n                    temp = n;\\n                }\\n            }\\n\\n            int[][] res = new int[list.size()][2];\\n            for (int i = 0; i < list.size(); i++) {\\n                res[i] = list.get(i);\\n            }\\n            return res;\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SummaryRanges {\\n\\n        PriorityQueue<Integer> pq;\\n        PriorityQueue<Integer> pq2;\\n        Set<Integer> set;\\n        public SummaryRanges() {\\n            pq = new PriorityQueue<>();\\n            pq2 = new PriorityQueue<>();\\n            set = new HashSet<>();\\n        }\\n\\n        public void addNum(int value) {\\n            if (!set.contains(value)) {\\n                pq.add(value);\\n                set.add(value);\\n            }\\n        }\\n\\n        public int[][] getIntervals() {\\n            List<int[]> list = new ArrayList<>();\\n            int temp = pq.poll();\\n            pq2.offer(temp);\\n            int[] arr = new int[2];\\n            arr[0] = temp;\\n            arr[1] = temp;\\n            list.add(arr);\\n            while (!pq.isEmpty()) {\\n                int n = pq.poll();\\n                if (n - temp == 1) {\\n                    arr[1] = n;\\n                    temp = n;\\n                } else {\\n                    arr = new int[2];\\n                    arr[0] = n;\\n                    arr[1] = n;\\n                    list.add(arr);\\n                    temp = n;\\n                }\\n                pq2.offer(n);\\n            }\\n            pq = pq2;\\n            pq2 = new PriorityQueue<>();\\n            int[][] res = new int[list.size()][2];\\n            for (int i = 0; i < list.size(); i++) {\\n                res[i] = list.get(i);\\n            }\\n            return res;\\n        }\\n}\\n```\n```\\nclass SummaryRanges {\\n\\n    TreeSet<Integer> set;\\n        public SummaryRanges() {\\n            set = new TreeSet<>();\\n        }\\n\\n        public void addNum(int value) {\\n            set.add(value);\\n        }\\n\\n        public int[][] getIntervals() {\\n            List<int[]> list = new ArrayList<>();\\n            int temp = set.first();\\n            int[] arr = new int[2];\\n            arr[0] = temp;\\n            arr[1] = temp;\\n            list.add(arr);\\n            for (Integer n : set) {\\n                if (n == temp) continue;\\n                if (n - temp == 1) {\\n                    arr[1] = n;\\n                    temp = n;\\n                } else {\\n                    arr = new int[2];\\n                    arr[0] = n;\\n                    arr[1] = n;\\n                    list.add(arr);\\n                    temp = n;\\n                }\\n            }\\n\\n            int[][] res = new int[list.size()][2];\\n            for (int i = 0; i < list.size(); i++) {\\n                res[i] = list.get(i);\\n            }\\n            return res;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109144,
                "title": "go-binary-search-solution",
                "content": "# Code\\n```\\ntype SummaryRanges struct {\\n\\tval [][]int\\n}\\n\\nfunc Constructor() SummaryRanges {\\n\\treturn SummaryRanges{\\n\\t\\tval: [][]int{},\\n\\t}\\n}\\n\\nfunc (this *SummaryRanges) AddNum(value int) {\\n\\tlow, high := 0, len(this.val)-1\\n\\tif high == -1 {\\n\\t\\tthis.val = [][]int{{value, value}}\\n\\t\\treturn\\n\\t}\\n\\n\\tfor low <= high {\\n\\t\\tmedian := (low + high) / 2\\n\\n\\t\\tif this.val[median][0] <= value && value <= this.val[median][1] {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tif this.val[median][1] == value-1 {\\n\\t\\t\\tthis.val[median][1] = value\\n\\t\\t\\tif median != len(this.val)-1 {\\n\\t\\t\\t\\tif this.val[median][1]+1 == this.val[median+1][0] {\\n\\t\\t\\t\\t\\tthis.val[median+1][0] = this.val[median][0]\\n\\t\\t\\t\\t\\tthis.val = append(this.val[:median], this.val[median+1:]...)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tif this.val[median][0] == value+1 {\\n\\t\\t\\tthis.val[median][0] = value\\n\\t\\t\\tif median != 0 {\\n\\t\\t\\t\\tif this.val[median][0]-1 == this.val[median-1][1] {\\n\\t\\t\\t\\t\\tthis.val[median-1][1] = this.val[median][1]\\n\\t\\t\\t\\t\\tthis.val = append(this.val[:median], this.val[median+1:]...)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tif this.val[median][1] < value {\\n\\t\\t\\tlow = median + 1\\n\\t\\t} else {\\n\\t\\t\\thigh = median - 1\\n\\t\\t}\\n\\t}\\n\\n\\tthis.val = append(this.val[:low], append([][]int{{value, value}}, this.val[low:]...)...)\\n}\\n\\nfunc (this *SummaryRanges) GetIntervals() [][]int {\\n\\treturn this.val\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype SummaryRanges struct {\\n\\tval [][]int\\n}\\n\\nfunc Constructor() SummaryRanges {\\n\\treturn SummaryRanges{\\n\\t\\tval: [][]int{},\\n\\t}\\n}\\n\\nfunc (this *SummaryRanges) AddNum(value int) {\\n\\tlow, high := 0, len(this.val)-1\\n\\tif high == -1 {\\n\\t\\tthis.val = [][]int{{value, value}}\\n\\t\\treturn\\n\\t}\\n\\n\\tfor low <= high {\\n\\t\\tmedian := (low + high) / 2\\n\\n\\t\\tif this.val[median][0] <= value && value <= this.val[median][1] {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tif this.val[median][1] == value-1 {\\n\\t\\t\\tthis.val[median][1] = value\\n\\t\\t\\tif median != len(this.val)-1 {\\n\\t\\t\\t\\tif this.val[median][1]+1 == this.val[median+1][0] {\\n\\t\\t\\t\\t\\tthis.val[median+1][0] = this.val[median][0]\\n\\t\\t\\t\\t\\tthis.val = append(this.val[:median], this.val[median+1:]...)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tif this.val[median][0] == value+1 {\\n\\t\\t\\tthis.val[median][0] = value\\n\\t\\t\\tif median != 0 {\\n\\t\\t\\t\\tif this.val[median][0]-1 == this.val[median-1][1] {\\n\\t\\t\\t\\t\\tthis.val[median-1][1] = this.val[median][1]\\n\\t\\t\\t\\t\\tthis.val = append(this.val[:median], this.val[median+1:]...)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tif this.val[median][1] < value {\\n\\t\\t\\tlow = median + 1\\n\\t\\t} else {\\n\\t\\t\\thigh = median - 1\\n\\t\\t}\\n\\t}\\n\\n\\tthis.val = append(this.val[:low], append([][]int{{value, value}}, this.val[low:]...)...)\\n}\\n\\nfunc (this *SummaryRanges) GetIntervals() [][]int {\\n\\treturn this.val\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3109139,
                "title": "stupid-desciption-just-expand-the-intervals",
                "content": "# Intuition\\n1. Sort all the incoming elements in the tree set.\\n2. while implementing getIntervals() check for consecutives if elements are consecutive skip those elements\\n3. else create a new interval\\n\\n# Approach\\nI inserted elements into array at correct positions (by the help of lower_bound function)\\nThen, created ranges[] list using simple O(N) traversal (skipping consequent equal values)\\n\\n# Complexity\\nTc -> O(n.logn), SC -> O(n)\\n\\n# Code\\n```\\nclass SummaryRanges:\\n    def __init__(self):\\n        self.nums = set()\\n\\n    def addNum(self, value: int) -> None:\\n        self.nums.add(value)\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        intervals = []\\n        seen = set()\\n        for num in self.nums:\\n            if num in seen: \\n                continue\\n\\n            left = num\\n            while left - 1 in self.nums:\\n                left -= 1\\n                seen.add(left)\\n\\n            right = num\\n            while right + 1 in self.nums:\\n                right += 1\\n                seen.add(right)\\n            \\n            intervals.append([left, right])\\n        return sorted(intervals)\\n\\n\\n\\n\\n# Your SummaryRanges object will be instantiated and called as such:\\n# obj = SummaryRanges()\\n# obj.addNum(value)\\n# param_2 = obj.getIntervals()\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Design",
                    "Ordered Set"
                ],
                "code": "```\\nclass SummaryRanges:\\n    def __init__(self):\\n        self.nums = set()\\n\\n    def addNum(self, value: int) -> None:\\n        self.nums.add(value)\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        intervals = []\\n        seen = set()\\n        for num in self.nums:\\n            if num in seen: \\n                continue\\n\\n            left = num\\n            while left - 1 in self.nums:\\n                left -= 1\\n                seen.add(left)\\n\\n            right = num\\n            while right + 1 in self.nums:\\n                right += 1\\n                seen.add(right)\\n            \\n            intervals.append([left, right])\\n        return sorted(intervals)\\n\\n\\n\\n\\n# Your SummaryRanges object will be instantiated and called as such:\\n# obj = SummaryRanges()\\n# obj.addNum(value)\\n# param_2 = obj.getIntervals()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109137,
                "title": "fast-c-solution-with-custom-comparer",
                "content": "# Code\\n```\\npublic class SummaryRanges {\\n    private readonly SortedSet<(int start, int end)> _list = new(new Comparer());\\n\\n    public void AddNum(int value)\\n    {\\n        if (_list.TryGetValue((value, value), out _))\\n            return;\\n        bool hasPrefix = _list.TryGetValue((value - 1, value - 1), out var prefix);\\n        bool hasSufix = _list.TryGetValue((value + 1, value + 1), out var sufix);\\n\\n        if (hasPrefix)\\n            _list.Remove(prefix);\\n        if (hasSufix)\\n            _list.Remove(sufix);\\n        _list.Add((hasPrefix ? prefix.start : value, hasSufix ? sufix.end : value));\\n    }\\n\\n    public int[][] GetIntervals() =>\\n        _list\\n        .Select(x => new int[] {x.start, x.end})\\n        .ToArray();\\n\\n    private class Comparer : IComparer<(int start, int end)>\\n    {\\n        public int Compare((int start, int end) x, (int start, int end) y)\\n        {\\n            if (x.start == x.end)\\n                return x.start >= y.start && x.end <= y.end ? 0 : x.start > y.start ? 1 : -1;\\n            if (y.start == y.end)\\n                return y.start >= x.start && y.end <= x.end ? 0 : x.start > y.start ? 1 : -1;\\n\\n            return x.start - y.start;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class SummaryRanges {\\n    private readonly SortedSet<(int start, int end)> _list = new(new Comparer());\\n\\n    public void AddNum(int value)\\n    {\\n        if (_list.TryGetValue((value, value), out _))\\n            return;\\n        bool hasPrefix = _list.TryGetValue((value - 1, value - 1), out var prefix);\\n        bool hasSufix = _list.TryGetValue((value + 1, value + 1), out var sufix);\\n\\n        if (hasPrefix)\\n            _list.Remove(prefix);\\n        if (hasSufix)\\n            _list.Remove(sufix);\\n        _list.Add((hasPrefix ? prefix.start : value, hasSufix ? sufix.end : value));\\n    }\\n\\n    public int[][] GetIntervals() =>\\n        _list\\n        .Select(x => new int[] {x.start, x.end})\\n        .ToArray();\\n\\n    private class Comparer : IComparer<(int start, int end)>\\n    {\\n        public int Compare((int start, int end) x, (int start, int end) y)\\n        {\\n            if (x.start == x.end)\\n                return x.start >= y.start && x.end <= y.end ? 0 : x.start > y.start ? 1 : -1;\\n            if (y.start == y.end)\\n                return y.start >= x.start && y.end <= x.end ? 0 : x.start > y.start ? 1 : -1;\\n\\n            return x.start - y.start;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109135,
                "title": "using-sortedlist-and-binary-search",
                "content": "# Intuition\\nUsing Sorted Containers to maintain and update intervals for each new number and Binary Search to find where to insert the new number in out intervals list.\\n\\n# Approach\\nFor each new number, find the index `idx` of where to insert the number.\\nNow previous interval is `prev` which is `intervals[idx - 1]`  \\nAnd next interval is `nxt` which is `intervals[idx]`\\n\\nIf our number is already within `prev` or `nxt`, then no need to do anything.  \\nFor example if our `intervals = [[1, 4], [6,8]]` and our number is `3`, then no need to do anything as 3 is already part of `[1,4]`\\n\\nIf our number is one more than end of `prev` **AND** one less than start of `nxt`, then we can combine these two intervals  \\nFor example if our `intervals = [[1, 4], [6,8]]` and number is `5`, then we can write `intervals = [[1,8]]`\\n\\nIf our number is one more than end of `prev` **OR** one less than start of `nxt`, then we can merge it with `prev` or `nxt`\\n\\n# Complexity\\n- Time complexity:\\n    For each addNum: Approximately $$O(logN)$$ (as we are using SortedList)\\n    For each getIntervals: $$O(1)$$\\n\\n- Space complexity: $$O(N)$$\\n\\n# Code\\n```python\\nfrom sortedcontainers import SortedList\\n\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.intervals = SortedList()\\n\\n    def addNum(self, value: int) -> None:\\n        INF = float(\\'inf\\')\\n        N = len(self.intervals)\\n        idx = self.intervals.bisect_left([value, value])\\n\\n        pre_start, pre_end = self.intervals[idx - 1] if idx > 0 else [-INF, -INF]\\n        nxt_start, nxt_end = self.intervals[idx] if idx < N else [INF, INF]\\n\\n        if pre_start <= value <= pre_end or nxt_start <= value <= nxt_end:\\n            # Eat 5 Star, Do nothing\\n            pass\\n        elif pre_end == value - 1 and nxt_start == value + 1:\\n            # Merge them\\n            self.intervals[idx - 1][1] = self.intervals[idx][1]\\n            self.intervals.pop(idx)\\n        elif pre_end == value - 1:\\n            # Merge with previous\\n            self.intervals[idx - 1][1] = value\\n        elif value + 1 == nxt_start:\\n            # Merge with next\\n            self.intervals[idx][0] = value\\n        else:\\n            # New interval entry\\n            self.intervals.add([value, value])\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        return self.intervals\\n        \\n\\n\\n# Your SummaryRanges object will be instantiated and called as such:\\n# obj = SummaryRanges()\\n# obj.addNum(value)\\n# param_2 = obj.getIntervals()\\n```\\n\\nHope it helps :)",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```python\\nfrom sortedcontainers import SortedList\\n\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n        self.intervals = SortedList()\\n\\n    def addNum(self, value: int) -> None:\\n        INF = float(\\'inf\\')\\n        N = len(self.intervals)\\n        idx = self.intervals.bisect_left([value, value])\\n\\n        pre_start, pre_end = self.intervals[idx - 1] if idx > 0 else [-INF, -INF]\\n        nxt_start, nxt_end = self.intervals[idx] if idx < N else [INF, INF]\\n\\n        if pre_start <= value <= pre_end or nxt_start <= value <= nxt_end:\\n            # Eat 5 Star, Do nothing\\n            pass\\n        elif pre_end == value - 1 and nxt_start == value + 1:\\n            # Merge them\\n            self.intervals[idx - 1][1] = self.intervals[idx][1]\\n            self.intervals.pop(idx)\\n        elif pre_end == value - 1:\\n            # Merge with previous\\n            self.intervals[idx - 1][1] = value\\n        elif value + 1 == nxt_start:\\n            # Merge with next\\n            self.intervals[idx][0] = value\\n        else:\\n            # New interval entry\\n            self.intervals.add([value, value])\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        return self.intervals\\n        \\n\\n\\n# Your SummaryRanges object will be instantiated and called as such:\\n# obj = SummaryRanges()\\n# obj.addNum(value)\\n# param_2 = obj.getIntervals()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109125,
                "title": "set-c-two-pointer-approach-basic",
                "content": "\\tclass SummaryRanges {\\n\\tpublic:\\n\\t\\tset<int> s;\\n\\t\\tSummaryRanges() {\\n\\n\\t\\t}\\n\\t\\tvoid addNum(int v) {\\n\\t\\t\\ts.insert(v);    \\n\\t\\t}\\n\\n\\t\\tvector<vector<int>> getIntervals() {\\n\\t\\t\\tint start=*s.begin();\\n\\t\\t\\tint end =*s.begin();\\n\\t\\t\\tvector<vector<int>> v;\\n\\t\\t\\tfor(auto it =++s.begin();it!=s.end();it++){\\n\\t\\t\\t\\tif(abs(end-*it)==1){\\n\\t\\t\\t\\t\\tend=*it;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tv.push_back({start,end});\\n\\t\\t\\t\\t\\tstart=*it;\\n\\t\\t\\t\\t\\tend=*it;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tv.push_back({start,end});\\n\\t\\t\\treturn v;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Two Pointers",
                    "Ordered Set"
                ],
                "code": "\\tclass SummaryRanges {\\n\\tpublic:\\n\\t\\tset<int> s;\\n\\t\\tSummaryRanges() {\\n\\n\\t\\t}\\n\\t\\tvoid addNum(int v) {\\n\\t\\t\\ts.insert(v);    \\n\\t\\t}\\n\\n\\t\\tvector<vector<int>> getIntervals() {\\n\\t\\t\\tint start=*s.begin();\\n\\t\\t\\tint end =*s.begin();\\n\\t\\t\\tvector<vector<int>> v;\\n\\t\\t\\tfor(auto it =++s.begin();it!=s.end();it++){\\n\\t\\t\\t\\tif(abs(end-*it)==1){\\n\\t\\t\\t\\t\\tend=*it;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tv.push_back({start,end});\\n\\t\\t\\t\\t\\tstart=*it;\\n\\t\\t\\t\\t\\tend=*it;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tv.push_back({start,end});\\n\\t\\t\\treturn v;\\n\\t\\t}\\n\\t};",
                "codeTag": "Java"
            },
            {
                "id": 3109102,
                "title": "i-can-t-believe-i-solved-hard-problem-by-myself-so-i-m-proud-of-my-code",
                "content": "\\nclass SummaryRanges {\\npublic:\\n\\n    vector<vector<int>> sry ;\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    vector<vector<int>> adjust(vector<vector<int>>a, int x){\\n        // if(x>=a.size()-1||x=<0)return a ;\\n        if(x!=0&&a[x][0]-1==a[x-1][1]){\\n            a[x-1][1]=a[x][1];\\n            //remove a[x]\\n            a.erase(a.begin() + x);\\n            return a ; \\n        }\\n        if(x!=a.size()-1&&a[x][1]+1==a[x+1][0]){\\n            a[x][1]=a[x+1][1];\\n            //remove a[x+1] \\n            a.erase(a.begin() +(x+1));\\n            return a ;\\n        }\\n        return a ;\\n    }\\n\\n    void addNum(int v) {\\n        if(sry.empty()){ sry.push_back({v, v});\\n        return ; }\\n        int newRange = 1 ;\\n        for(int i = 0 ; i < sry.size() ; i++){\\n            int s = sry[i][0], e = sry[i][1] ;\\n            if(s <= v && v <=e) return ; //within range\\n            if(s-1==v){\\n                newRange =0 ;\\n                sry[i][0] = v ;\\n                sry = adjust(sry,i);\\n                break;\\n            }\\n            if(e+1==v){\\n               newRange =0 ;\\n                sry[i][1] = v ;\\n                sry = adjust(sry,i);\\n                break; \\n            }\\n        }\\n        if(newRange){ sry.push_back({v, v});\\n        return ; }\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        sort(sry.begin(), sry.end());\\n        return sry ;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\nclass SummaryRanges {\\npublic:\\n\\n    vector<vector<int>> sry ;\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    vector<vector<int>> adjust(vector<vector<int>>a, int x){\\n        // if(x>=a.size()-1||x=<0)return a ;\\n        if(x!=0&&a[x][0]-1==a[x-1][1]){\\n            a[x-1][1]=a[x][1];\\n            //remove a[x]\\n            a.erase(a.begin() + x);\\n            return a ; \\n        }\\n        if(x!=a.size()-1&&a[x][1]+1==a[x+1][0]){\\n            a[x][1]=a[x+1][1];\\n            //remove a[x+1] \\n            a.erase(a.begin() +(x+1));\\n            return a ;\\n        }\\n        return a ;\\n    }\\n\\n    void addNum(int v) {\\n        if(sry.empty()){ sry.push_back({v, v});\\n        return ; }\\n        int newRange = 1 ;\\n        for(int i = 0 ; i < sry.size() ; i++){\\n            int s = sry[i][0], e = sry[i][1] ;\\n            if(s <= v && v <=e) return ; //within range\\n            if(s-1==v){\\n                newRange =0 ;\\n                sry[i][0] = v ;\\n                sry = adjust(sry,i);\\n                break;\\n            }\\n            if(e+1==v){\\n               newRange =0 ;\\n                sry[i][1] = v ;\\n                sry = adjust(sry,i);\\n                break; \\n            }\\n        }\\n        if(newRange){ sry.push_back({v, v});\\n        return ; }\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        sort(sry.begin(), sry.end());\\n        return sry ;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109054,
                "title": "easy-c-solution-dictionary-sortedset-faster-than-100",
                "content": "# Code C#\\n```\\npublic class SummaryRanges\\n{\\n    private class IntervalComparer : IComparer<int[]>\\n    {\\n        public int Compare(int[]? x, int[]? y)\\n        {\\n            return x[0].CompareTo(y[0]);\\n        }\\n    }\\n\\n    private Dictionary<int, int[]> _numbers;\\n    private SortedSet<int[]> _intervals;\\n\\n    public SummaryRanges()\\n    {\\n        _numbers = new Dictionary<int, int[]>();\\n        _intervals = new SortedSet<int[]>(new IntervalComparer());\\n    }\\n\\n    public void AddNum(int value)\\n    {\\n        if (_numbers.ContainsKey(value)) return;\\n\\n        int[] range;\\n        if(_numbers.ContainsKey(value - 1))\\n        {\\n            if (_numbers.ContainsKey(value + 1))\\n            {\\n                range = new int[] { _numbers[value - 1][0], _numbers[value + 1][1] };\\n\\n                for (int i = _numbers[value - 1][0]; i < _numbers[value - 1][1]; i++)\\n                    _numbers[i] = range;\\n                for (int i = _numbers[value + 1][0] + 1; i <= _numbers[value + 1][1]; i++)\\n                    _numbers[i] = range;\\n\\n                _intervals.Remove(_numbers[value - 1]);\\n                _intervals.Remove(_numbers[value + 1]);\\n                _intervals.Add(range);\\n\\n                _numbers[value - 1] = range;\\n                _numbers[value + 1] = range;\\n            }\\n            else\\n            {\\n                _numbers[value - 1][1] = value;\\n                range = _numbers[value - 1];\\n            }\\n        }\\n        else if(_numbers.ContainsKey(value + 1))\\n        {\\n            _numbers[value + 1][0] = value;\\n            range = _numbers[value + 1];\\n        }\\n        else\\n        {\\n            range = new[] { value, value };\\n            _intervals.Add(range);\\n        }\\n\\n        _numbers.Add(value, range);\\n    }\\n\\n    public int[][] GetIntervals()\\n    {\\n        return _intervals.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class SummaryRanges\\n{\\n    private class IntervalComparer : IComparer<int[]>\\n    {\\n        public int Compare(int[]? x, int[]? y)\\n        {\\n            return x[0].CompareTo(y[0]);\\n        }\\n    }\\n\\n    private Dictionary<int, int[]> _numbers;\\n    private SortedSet<int[]> _intervals;\\n\\n    public SummaryRanges()\\n    {\\n        _numbers = new Dictionary<int, int[]>();\\n        _intervals = new SortedSet<int[]>(new IntervalComparer());\\n    }\\n\\n    public void AddNum(int value)\\n    {\\n        if (_numbers.ContainsKey(value)) return;\\n\\n        int[] range;\\n        if(_numbers.ContainsKey(value - 1))\\n        {\\n            if (_numbers.ContainsKey(value + 1))\\n            {\\n                range = new int[] { _numbers[value - 1][0], _numbers[value + 1][1] };\\n\\n                for (int i = _numbers[value - 1][0]; i < _numbers[value - 1][1]; i++)\\n                    _numbers[i] = range;\\n                for (int i = _numbers[value + 1][0] + 1; i <= _numbers[value + 1][1]; i++)\\n                    _numbers[i] = range;\\n\\n                _intervals.Remove(_numbers[value - 1]);\\n                _intervals.Remove(_numbers[value + 1]);\\n                _intervals.Add(range);\\n\\n                _numbers[value - 1] = range;\\n                _numbers[value + 1] = range;\\n            }\\n            else\\n            {\\n                _numbers[value - 1][1] = value;\\n                range = _numbers[value - 1];\\n            }\\n        }\\n        else if(_numbers.ContainsKey(value + 1))\\n        {\\n            _numbers[value + 1][0] = value;\\n            range = _numbers[value + 1];\\n        }\\n        else\\n        {\\n            range = new[] { value, value };\\n            _intervals.Add(range);\\n        }\\n\\n        _numbers.Add(value, range);\\n    }\\n\\n    public int[][] GetIntervals()\\n    {\\n        return _intervals.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108992,
                "title": "fast-and-easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInspired the merge intervals problem .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhat you have to worry about is :\\n- Create a new interval from val -> val if the value dosent exist.\\n- else if it exist merge the prior intervals by selecting the starting point and ending point of your current state of intervals,\\n- after merging proceed to next steps.\\n\\n>important to note that we are finding the index for our new interval to be placed using binary search which is an effective way \\n\\n# Complexity\\n- Time complexity: `O(logn)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/f736fdaf-fe7c-4980-92ac-98f041fc9a62_1674904766.980209.png)\\n\\n\\n# Code\\n```\\nclass SummaryRanges\\n{\\n    vector<vector<int>> intervals;\\n\\npublic:\\n    SummaryRanges()\\n    {\\n        intervals.clear();\\n    }\\n\\n    void addNum(int value)\\n    {\\n        if (intervals.empty())\\n        {\\n            intervals.push_back({value, value});\\n            return;\\n        }\\n\\n        int l = 0, r = intervals.size() - 1;\\n        while (l <= r)\\n        {\\n            int mid = (l + r) / 2;\\n            if (intervals[mid][0] <= value && intervals[mid][1] >= value)\\n                return;\\n            else if (intervals[mid][0] > value)\\n                r = mid - 1;\\n            else\\n                l = mid + 1;\\n        }\\n\\n        if (l == 0)\\n        {\\n            if (intervals[l][0] == value + 1)\\n                intervals[l][0] = value;\\n            else\\n                intervals.insert(intervals.begin(), {value, value});\\n        }\\n        else if (l == intervals.size())\\n        {\\n            if (intervals[l - 1][1] == value - 1)\\n                intervals[l - 1][1] = value;\\n            else\\n                intervals.push_back({value, value});\\n        }\\n        else\\n        {\\n            if (intervals[l - 1][1] == value - 1 && intervals[l][0] == value + 1)\\n            {\\n                intervals[l - 1][1] = intervals[l][1];\\n                intervals.erase(intervals.begin() + l);\\n            }\\n            else if (intervals[l - 1][1] == value - 1)\\n                intervals[l - 1][1] = value;\\n            else if (intervals[l][0] == value + 1)\\n                intervals[l][0] = value;\\n            else\\n                intervals.insert(intervals.begin() + l, {value, value});\\n        }\\n    }\\n\\n    vector<vector<int>> getIntervals()\\n    {\\n        return intervals;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Design"
                ],
                "code": "```\\nclass SummaryRanges\\n{\\n    vector<vector<int>> intervals;\\n\\npublic:\\n    SummaryRanges()\\n    {\\n        intervals.clear();\\n    }\\n\\n    void addNum(int value)\\n    {\\n        if (intervals.empty())\\n        {\\n            intervals.push_back({value, value});\\n            return;\\n        }\\n\\n        int l = 0, r = intervals.size() - 1;\\n        while (l <= r)\\n        {\\n            int mid = (l + r) / 2;\\n            if (intervals[mid][0] <= value && intervals[mid][1] >= value)\\n                return;\\n            else if (intervals[mid][0] > value)\\n                r = mid - 1;\\n            else\\n                l = mid + 1;\\n        }\\n\\n        if (l == 0)\\n        {\\n            if (intervals[l][0] == value + 1)\\n                intervals[l][0] = value;\\n            else\\n                intervals.insert(intervals.begin(), {value, value});\\n        }\\n        else if (l == intervals.size())\\n        {\\n            if (intervals[l - 1][1] == value - 1)\\n                intervals[l - 1][1] = value;\\n            else\\n                intervals.push_back({value, value});\\n        }\\n        else\\n        {\\n            if (intervals[l - 1][1] == value - 1 && intervals[l][0] == value + 1)\\n            {\\n                intervals[l - 1][1] = intervals[l][1];\\n                intervals.erase(intervals.begin() + l);\\n            }\\n            else if (intervals[l - 1][1] == value - 1)\\n                intervals[l - 1][1] = value;\\n            else if (intervals[l][0] == value + 1)\\n                intervals[l][0] = value;\\n            else\\n                intervals.insert(intervals.begin() + l, {value, value});\\n        }\\n    }\\n\\n    vector<vector<int>> getIntervals()\\n    {\\n        return intervals;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108941,
                "title": "easy-to-understand-using-set-solution",
                "content": "```\\nclass SummaryRanges {\\n    private:\\n    \\npublic:\\n    set<vector<int>> ans;\\n    unordered_set<int> s;\\n    SummaryRanges() {\\n    };\\n    \\n    void addNum(int value) {\\n        int x = value-1,y = value+1;\\n        while(s.count(x)){\\n            x--;\\n        }\\n        while(s.count(y)){\\n            y++;\\n        }\\n        s.insert(value);\\n        x++;y--;\\n        // cout<<x<<\" \"<<value-1<<\" \"<<value+1<<\" \"<<y<<endl;\\n        ans.erase({x,value-1});\\n        ans.erase({value+1,y});\\n        ans.insert({x,y});\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> v;\\n        for(auto &i: ans){\\n            v.push_back(i);\\n        }\\n        return v;\\n    }\\n};\\n\\n ```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass SummaryRanges {\\n    private:\\n    \\npublic:\\n    set<vector<int>> ans;\\n    unordered_set<int> s;\\n    SummaryRanges() {\\n    };\\n    \\n    void addNum(int value) {\\n        int x = value-1,y = value+1;\\n        while(s.count(x)){\\n            x--;\\n        }\\n        while(s.count(y)){\\n            y++;\\n        }\\n        s.insert(value);\\n        x++;y--;\\n        // cout<<x<<\" \"<<value-1<<\" \"<<value+1<<\" \"<<y<<endl;\\n        ans.erase({x,value-1});\\n        ans.erase({value+1,y});\\n        ans.insert({x,y});\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> v;\\n        for(auto &i: ans){\\n            v.push_back(i);\\n        }\\n        return v;\\n    }\\n};\\n\\n ```",
                "codeTag": "C++"
            },
            {
                "id": 3108876,
                "title": "python-solution-native-approach-easy-to-understand",
                "content": "```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n\\t\\t# list to store values\\n        self.rtr = []\\n\\n    def addNum(self, value: int) -> None:\\n        if not self.rtr:\\n\\t\\t\\t# if list is empty add the value\\n            self.rtr.append(value)\\n        else:\\n\\t\\t\\t# if value is already present just return\\n            if value in self.rtr:\\n                return\\n            f=False\\n\\t\\t\\t# traverse the list to find insert position for current elm -> you can use bisect module to do the same in logn time complexity.\\n            for index,elm in enumerate(self.rtr):\\n                if elm > value:\\n                    f=True\\n                    break\\n            if f:\\n\\t\\t\\t\\t# inserting the element to its position so that the list is sorted\\n                self.rtr.insert(index,value)\\n            else:\\n                self.rtr.insert(index+1,value)\\n\\n    def getIntervals(self) -> List[List[int]]:\\n\\t\\t# default interval we\\'ll update it inside loop of O(n) time complexity\\n        interval = [-2,-2]\\n\\t\\t# parent will store all intervals\\n        parent = []\\n\\t\\t# traversing the sorted elements list\\n        for num in self.rtr:\\n\\t\\t\\t# if no interval is available -> change the default interval to create one\\n            if interval[0]==-2:\\n                interval[0] = num\\n                interval[1] = num\\n            else:\\n\\t\\t\\t\\t# otherwise check if the gap b/w them is 1 if it is update the intervals end with current number\\n                if interval[-1] + 1 == num:\\n                    interval[-1] = num\\n\\t\\t\\t\\t# otherwise append the current interval and create a new interval\\n                else:\\n                    parent.append(list(interval))\\n                    interval[0] = num\\n                    interval[1] = num\\n\\t\\t# if last interval is not been added to final list add the last one\\n        if interval[0]!=-2:\\n            parent.append(interval)\\n        # print(self.rtr,parent)\\n        return parent\\n\\n\\'\\'\\'\\n\\tThanks For reading please upvote\\n\\tif you like :-)\\n\\'\\'\\'\\n\\n# Your SummaryRanges object will be instantiated and called as such:\\n# obj = SummaryRanges()\\n# obj.addNum(value)\\n# param_2 = obj.getIntervals()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Design",
                    "Ordered Set"
                ],
                "code": "```\\nclass SummaryRanges:\\n\\n    def __init__(self):\\n\\t\\t# list to store values\\n        self.rtr = []\\n\\n    def addNum(self, value: int) -> None:\\n        if not self.rtr:\\n\\t\\t\\t# if list is empty add the value\\n            self.rtr.append(value)\\n        else:\\n\\t\\t\\t# if value is already present just return\\n            if value in self.rtr:\\n                return\\n            f=False\\n\\t\\t\\t# traverse the list to find insert position for current elm -> you can use bisect module to do the same in logn time complexity.\\n            for index,elm in enumerate(self.rtr):\\n                if elm > value:\\n                    f=True\\n                    break\\n            if f:\\n\\t\\t\\t\\t# inserting the element to its position so that the list is sorted\\n                self.rtr.insert(index,value)\\n            else:\\n                self.rtr.insert(index+1,value)\\n\\n    def getIntervals(self) -> List[List[int]]:\\n\\t\\t# default interval we\\'ll update it inside loop of O(n) time complexity\\n        interval = [-2,-2]\\n\\t\\t# parent will store all intervals\\n        parent = []\\n\\t\\t# traversing the sorted elements list\\n        for num in self.rtr:\\n\\t\\t\\t# if no interval is available -> change the default interval to create one\\n            if interval[0]==-2:\\n                interval[0] = num\\n                interval[1] = num\\n            else:\\n\\t\\t\\t\\t# otherwise check if the gap b/w them is 1 if it is update the intervals end with current number\\n                if interval[-1] + 1 == num:\\n                    interval[-1] = num\\n\\t\\t\\t\\t# otherwise append the current interval and create a new interval\\n                else:\\n                    parent.append(list(interval))\\n                    interval[0] = num\\n                    interval[1] = num\\n\\t\\t# if last interval is not been added to final list add the last one\\n        if interval[0]!=-2:\\n            parent.append(interval)\\n        # print(self.rtr,parent)\\n        return parent\\n\\n\\'\\'\\'\\n\\tThanks For reading please upvote\\n\\tif you like :-)\\n\\'\\'\\'\\n\\n# Your SummaryRanges object will be instantiated and called as such:\\n# obj = SummaryRanges()\\n# obj.addNum(value)\\n# param_2 = obj.getIntervals()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108799,
                "title": "c-solution-using-set",
                "content": "```\\nclass SummaryRanges {\\npublic:\\n    set<int> set;\\n    \\n    SummaryRanges() {\\n    }\\n    \\n    void addNum(int value) {\\n        set.insert(value);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        \\n        for(auto x:set){\\n            if(temp.size()==0) temp= {x,x};\\n            else{\\n                if(x== temp[1]+1) temp[1]= x;\\n                else{\\n                    ans.push_back(temp);\\n                    temp= {x,x};\\n                }\\n            }\\n        }\\n        \\n        ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass SummaryRanges {\\npublic:\\n    set<int> set;\\n    \\n    SummaryRanges() {\\n    }\\n    \\n    void addNum(int value) {\\n        set.insert(value);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        \\n        for(auto x:set){\\n            if(temp.size()==0) temp= {x,x};\\n            else{\\n                if(x== temp[1]+1) temp[1]= x;\\n                else{\\n                    ans.push_back(temp);\\n                    temp= {x,x};\\n                }\\n            }\\n        }\\n        \\n        ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108754,
                "title": "easy-set",
                "content": "# Approach\\nMaintain all number in a set, generating interval use this set.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SummaryRanges {\\n    set<int> iInt;\\npublic:\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int value) {\\n        iInt.insert(value);\\n        \\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> res;\\n        if (iInt.size() == 0) return res;\\n\\n        int start=-1, end=-1;\\n        for (auto val:iInt){\\n            if (start == -1) start = end = val;\\n            else if(end+1 == val) end = val;\\n            else {\\n                res.push_back({start,end});\\n                start = end = val;\\n            }\\n        }\\n        res.push_back({start,end});\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SummaryRanges {\\n    set<int> iInt;\\npublic:\\n    SummaryRanges() {\\n        \\n    }\\n    \\n    void addNum(int value) {\\n        iInt.insert(value);\\n        \\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> res;\\n        if (iInt.size() == 0) return res;\\n\\n        int start=-1, end=-1;\\n        for (auto val:iInt){\\n            if (start == -1) start = end = val;\\n            else if(end+1 == val) end = val;\\n            else {\\n                res.push_back({start,end});\\n                start = end = val;\\n            }\\n        }\\n        res.push_back({start,end});\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108748,
                "title": "simple-c-solution-easy-sorting-and-merging",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple sorting approch.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsorting and merging\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nfor sorting:- O(nlogn)\\nfor merging:- O(n)\\ntotal:- O(n^2 logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nspace complexity:- O(N)\\n\\n# Code\\n```\\nclass SummaryRanges {\\npublic:\\n    vector<vector<int>>ans;\\n    int ismerged;\\n    vector<int>ispresent;\\n    SummaryRanges() {\\n        ismerged=true;\\n        ispresent.resize(10005,0);\\n    }\\n    \\n    void addNum(int value) {\\n        if(ispresent[value]==0){\\n            ans.push_back({value,value});\\n            ismerged=false;\\n            ispresent[value]=1;\\n        }\\n    }\\n    void merge(){\\n        sort(ans.begin(),ans.end());\\n        vector<vector<int>>temp;\\n        temp.push_back(ans[0]);\\n        int i=0,j=1;\\n        while(j<ans.size()){\\n            if((temp[i][1]+1)==ans[j][0]){\\n                temp[i][1]=ans[j][1];\\n                j++;\\n            }\\n            else{\\n                temp.push_back(ans[j]);\\n                j++;i++;\\n            }\\n        }\\n        ans=temp;\\n    }\\n    vector<vector<int>> getIntervals() {\\n        if(ismerged==false){\\n            merge();\\n            ismerged=true;\\n            return ans;\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass SummaryRanges {\\npublic:\\n    vector<vector<int>>ans;\\n    int ismerged;\\n    vector<int>ispresent;\\n    SummaryRanges() {\\n        ismerged=true;\\n        ispresent.resize(10005,0);\\n    }\\n    \\n    void addNum(int value) {\\n        if(ispresent[value]==0){\\n            ans.push_back({value,value});\\n            ismerged=false;\\n            ispresent[value]=1;\\n        }\\n    }\\n    void merge(){\\n        sort(ans.begin(),ans.end());\\n        vector<vector<int>>temp;\\n        temp.push_back(ans[0]);\\n        int i=0,j=1;\\n        while(j<ans.size()){\\n            if((temp[i][1]+1)==ans[j][0]){\\n                temp[i][1]=ans[j][1];\\n                j++;\\n            }\\n            else{\\n                temp.push_back(ans[j]);\\n                j++;i++;\\n            }\\n        }\\n        ans=temp;\\n    }\\n    vector<vector<int>> getIntervals() {\\n        if(ismerged==false){\\n            merge();\\n            ismerged=true;\\n            return ans;\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108710,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SummaryRanges {\\n    private TreeSet<Integer> set;\\n    public SummaryRanges() {\\n        set=new TreeSet<>();\\n    }\\n    \\n    public void addNum(int value) {\\n        set.add(value);\\n    }\\n    \\n    public int[][] getIntervals() {\\n        ArrayList<int []>list=new ArrayList<>();\\n        int []a=new int[2];\\n        int flag=0,left=0,right=0;\\n        for(int values:set){\\n            \\n            if(!set.contains(values+1)){\\n                //don\\'t change the value of left if you have already stored the value of left\\n                if(flag==0)left=values;\\n                right=values;\\n                list.add(new int[]{left,right});\\n                flag=0;\\n            }\\n            else if(set.contains(values+1)){\\n                //changes only when if you haven\\'t selected the left\\n                //left remains same for other values if it contains \\n                if(flag==0){\\n                    left=values;\\n                    flag=1;\\n                }\\n            }\\n                \\n        }\\n        return list.toArray(new int[0][]);\\n    }\\n}\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges obj = new SummaryRanges();\\n * obj.addNum(value);\\n * int[][] param_2 = obj.getIntervals();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SummaryRanges {\\n    private TreeSet<Integer> set;\\n    public SummaryRanges() {\\n        set=new TreeSet<>();\\n    }\\n    \\n    public void addNum(int value) {\\n        set.add(value);\\n    }\\n    \\n    public int[][] getIntervals() {\\n        ArrayList<int []>list=new ArrayList<>();\\n        int []a=new int[2];\\n        int flag=0,left=0,right=0;\\n        for(int values:set){\\n            \\n            if(!set.contains(values+1)){\\n                //don\\'t change the value of left if you have already stored the value of left\\n                if(flag==0)left=values;\\n                right=values;\\n                list.add(new int[]{left,right});\\n                flag=0;\\n            }\\n            else if(set.contains(values+1)){\\n                //changes only when if you haven\\'t selected the left\\n                //left remains same for other values if it contains \\n                if(flag==0){\\n                    left=values;\\n                    flag=1;\\n                }\\n            }\\n                \\n        }\\n        return list.toArray(new int[0][]);\\n    }\\n}\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges obj = new SummaryRanges();\\n * obj.addNum(value);\\n * int[][] param_2 = obj.getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108663,
                "title": "c-simple-idea-just-using-vector-and-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SummaryRanges {\\npublic:\\n    SummaryRanges() { //constructor\\n        \\n    }\\n    \\n    void addNum(int value) {\\n        m[value]++;\\n    }\\n\\n    vector<vector<int>> getIntervals() {\\n        int low = -1;\\n        vector<vector<int>> res;\\n        vector<int> interval(2);\\n        for(auto &num : m) {\\n            if(low == -1) {\\n                interval[0] = num.first;\\n                interval[1] = num.first;\\n            }\\n            else if(num.first - low > 1) {\\n                res.push_back(interval);\\n                interval[0] = num.first;\\n                interval[1] = num.first;\\t\\n            }\\n            else if(num.first - low == 1)\\n                interval[1] = num.first;\\n            low = num.first;\\n        }\\n        res.push_back(interval);\\n        return res;\\n    }\\n    map<int, int> m;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SummaryRanges {\\npublic:\\n    SummaryRanges() { //constructor\\n        \\n    }\\n    \\n    void addNum(int value) {\\n        m[value]++;\\n    }\\n\\n    vector<vector<int>> getIntervals() {\\n        int low = -1;\\n        vector<vector<int>> res;\\n        vector<int> interval(2);\\n        for(auto &num : m) {\\n            if(low == -1) {\\n                interval[0] = num.first;\\n                interval[1] = num.first;\\n            }\\n            else if(num.first - low > 1) {\\n                res.push_back(interval);\\n                interval[0] = num.first;\\n                interval[1] = num.first;\\t\\n            }\\n            else if(num.first - low == 1)\\n                interval[1] = num.first;\\n            low = num.first;\\n        }\\n        res.push_back(interval);\\n        return res;\\n    }\\n    map<int, int> m;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108542,
                "title": "352-data-stream-as-disjoint-intervals-python-set",
                "content": "# Code\\n```\\nclass SummaryRanges:\\n    def __init__(self):\\n        self.intervals = set()\\n\\n    def addNum(self, value: int) -> None:\\n        self.intervals.add(value)\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        ans = []\\n        arr = sorted(self.intervals)\\n        start, end = arr[0], arr[0]\\n        for curr in arr[1:]:\\n            if end+1 == curr:\\n                end = curr\\n            else:\\n                ans.append([start, end])\\n                start, end = curr, curr\\n        ans.append([start, end])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SummaryRanges:\\n    def __init__(self):\\n        self.intervals = set()\\n\\n    def addNum(self, value: int) -> None:\\n        self.intervals.add(value)\\n\\n    def getIntervals(self) -> List[List[int]]:\\n        ans = []\\n        arr = sorted(self.intervals)\\n        start, end = arr[0], arr[0]\\n        for curr in arr[1:]:\\n            if end+1 == curr:\\n                end = curr\\n            else:\\n                ans.append([start, end])\\n                start, end = curr, curr\\n        ans.append([start, end])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108458,
                "title": "kotlin-treemap-add-o-log-n-time-complexity",
                "content": "# Intuition\\n`TreeMap` stores the current interval, `TreeMap.key` represents the start and `TreeMap.value` represents the end of the interval(both inclusive).\\nFor every input `value`, check whether `value + 1` and `value - 1` exists in the `TreeMap(TM)`. \\nIf `value + 1` exists, that means new interval will be `value` to `TM.get(value + 1)`. Same can be done for `value - 1`.\\n\\nNOTE - \\n1. Do not process the duplicate inputs. \\n2. TreeMap is required due to the sorted order requirement while returning the intervals.\\n\\n# Complexity\\n- Time complexity: Add - $$O(log(n))$$, GetIntervals - $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass SummaryRanges() {\\n\\n    private val map = TreeMap<Int, Int>()\\n    private val invertMap = HashMap<Int, Int>()\\n    private val input = HashSet<Int>()\\n\\n    fun addNum(value: Int) {\\n        var s = value\\n        var e = value\\n        \\n        if (!input.contains(value)) {\\n            if (map.containsKey(value + 1)) {\\n                e = map[value + 1]!!\\n                map.remove(value + 1)\\n            }\\n            if (invertMap.containsKey(value - 1)) {\\n                s = invertMap[value - 1]!!\\n                invertMap.remove(value - 1)\\n            }\\n            map[s] = e\\n            invertMap[e] = s\\n        }\\n\\n        input.add(value)\\n    }\\n\\n    fun getIntervals(): Array<IntArray> {\\n        val arr = Array<IntArray>(map.size) { IntArray(2) }\\n        var i = 0\\n        for (e in map) {\\n            arr[i][0] = e.key\\n            arr[i][1] = e.value\\n            i++\\n        }\\n        return arr\\n    }\\n\\n}\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * var obj = SummaryRanges()\\n * obj.addNum(value)\\n * var param_2 = obj.getIntervals()\\n */\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass SummaryRanges() {\\n\\n    private val map = TreeMap<Int, Int>()\\n    private val invertMap = HashMap<Int, Int>()\\n    private val input = HashSet<Int>()\\n\\n    fun addNum(value: Int) {\\n        var s = value\\n        var e = value\\n        \\n        if (!input.contains(value)) {\\n            if (map.containsKey(value + 1)) {\\n                e = map[value + 1]!!\\n                map.remove(value + 1)\\n            }\\n            if (invertMap.containsKey(value - 1)) {\\n                s = invertMap[value - 1]!!\\n                invertMap.remove(value - 1)\\n            }\\n            map[s] = e\\n            invertMap[e] = s\\n        }\\n\\n        input.add(value)\\n    }\\n\\n    fun getIntervals(): Array<IntArray> {\\n        val arr = Array<IntArray>(map.size) { IntArray(2) }\\n        var i = 0\\n        for (e in map) {\\n            arr[i][0] = e.key\\n            arr[i][1] = e.value\\n            i++\\n        }\\n        return arr\\n    }\\n\\n}\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * var obj = SummaryRanges()\\n * obj.addNum(value)\\n * var param_2 = obj.getIntervals()\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108314,
                "title": "c-simple-use-of-map-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SummaryRanges {\\n    map<int,int> H, B;\\n    vector<int> A;\\npublic:\\n    SummaryRanges() {\\n        H.clear();B.clear();A.clear();\\n        A.resize(10001, 0);\\n    }\\n    \\n    void addNum(int value) {\\n        if (A[value] == 1) return;\\n        A[value] = 1;\\n        if ((value-1 >= 0 && A[value-1]) && (value+1 < 10001 && A[value+1])) {\\n            H[B[value-1]] = H[value+1];\\n            B[H[value+1]] = B[value-1];\\n            H.erase(value+1); B.erase(value-1);\\n        } else if (value-1 >= 0 && A[value-1]) {\\n            H[B[value-1]] = value;\\n            B[value] = B[value-1];\\n            B.erase(value-1);\\n        } else if (value+1 < 10001 && A[value+1]) {\\n            B[H[value+1]] = value;\\n            H[value] = H[value+1];\\n            H.erase(value+1);\\n        } else {\\n            B[value] = value;\\n            H[value] = value;\\n        }\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> ans;\\n        for (auto &it : H) {\\n            ans.push_back(vector<int>{it.first,it.second});\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SummaryRanges {\\n    map<int,int> H, B;\\n    vector<int> A;\\npublic:\\n    SummaryRanges() {\\n        H.clear();B.clear();A.clear();\\n        A.resize(10001, 0);\\n    }\\n    \\n    void addNum(int value) {\\n        if (A[value] == 1) return;\\n        A[value] = 1;\\n        if ((value-1 >= 0 && A[value-1]) && (value+1 < 10001 && A[value+1])) {\\n            H[B[value-1]] = H[value+1];\\n            B[H[value+1]] = B[value-1];\\n            H.erase(value+1); B.erase(value-1);\\n        } else if (value-1 >= 0 && A[value-1]) {\\n            H[B[value-1]] = value;\\n            B[value] = B[value-1];\\n            B.erase(value-1);\\n        } else if (value+1 < 10001 && A[value+1]) {\\n            B[H[value+1]] = value;\\n            H[value] = H[value+1];\\n            H.erase(value+1);\\n        } else {\\n            B[value] = value;\\n            H[value] = value;\\n        }\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> ans;\\n        for (auto &it : H) {\\n            ans.push_back(vector<int>{it.first,it.second});\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108303,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass SummaryRanges {\\n    private TreeMap<Integer, Integer> intervals;\\n\\n    public SummaryRanges() {\\n        intervals = new TreeMap<>(); \\n    }\\n    \\n    public void addNum(int value) {\\n        final Map.Entry<Integer, Integer> smallEntry = intervals.floorEntry(value); \\n        int left = value, right = value;\\n        if (smallEntry != null) {\\n            final int previous = smallEntry.getValue();\\n            if (previous >= value) {\\n                return;\\n            }\\n            if (previous == value - 1) {\\n                left = smallEntry.getKey();\\n            }\\n        }\\n        final Map.Entry<Integer, Integer> maxEntry = intervals.higherEntry(value); \\n        if (maxEntry != null && maxEntry.getKey() == value + 1) {\\n            right = maxEntry.getValue();\\n            intervals.remove(value + 1);\\n        }\\n        intervals.put(left, right);\\n    }\\n    \\n    public int[][] getIntervals() {\\n        final int[][] answer = new int[intervals.size()][2];\\n        int ind = 0;\\n        for (Map.Entry<Integer, Integer> entry : intervals.entrySet()) {\\n            answer[ind][0] = entry.getKey();\\n            answer[ind++][1] = entry.getValue();\\n        }\\n        return answer; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Design",
                    "Ordered Set"
                ],
                "code": "```\\nclass SummaryRanges {\\n    private TreeMap<Integer, Integer> intervals;\\n\\n    public SummaryRanges() {\\n        intervals = new TreeMap<>(); \\n    }\\n    \\n    public void addNum(int value) {\\n        final Map.Entry<Integer, Integer> smallEntry = intervals.floorEntry(value); \\n        int left = value, right = value;\\n        if (smallEntry != null) {\\n            final int previous = smallEntry.getValue();\\n            if (previous >= value) {\\n                return;\\n            }\\n            if (previous == value - 1) {\\n                left = smallEntry.getKey();\\n            }\\n        }\\n        final Map.Entry<Integer, Integer> maxEntry = intervals.higherEntry(value); \\n        if (maxEntry != null && maxEntry.getKey() == value + 1) {\\n            right = maxEntry.getValue();\\n            intervals.remove(value + 1);\\n        }\\n        intervals.put(left, right);\\n    }\\n    \\n    public int[][] getIntervals() {\\n        final int[][] answer = new int[intervals.size()][2];\\n        int ind = 0;\\n        for (Map.Entry<Integer, Integer> entry : intervals.entrySet()) {\\n            answer[ind][0] = entry.getKey();\\n            answer[ind++][1] = entry.getValue();\\n        }\\n        return answer; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108135,
                "title": "intervaltree-segmenttree-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince it\\'s an interval-related problem, my intuition is to solve it with an IntervalTree (or called SegmentTree). \\n\\nIf you guys have already known what IntervalTree is, this problem is almost solved. BTW, we are not going to introduce this data structure here. There are a lot of awesome tutorials online.\\n\\nWe can treat \"addNum\" as an ***insert*** function to the IntervalTree. \\n- #### Due to the consideration of generization, the input param of my insert function is an inserted interval rather than a number. But you can write your own version :D\\n\\nAlso, we can treat \"getIntervals\" as an ***inorder traverse*** to the IntervalTree\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, build an IntervalTree and then delegate \"addNum\" to the insert function and delegate \"getIntervals\" to the inorder function.\\n\\n# Complexity\\nLet $d$ represents $max(value) - min(value)$ and $k$ represents number of calls will be made;\\n- Time complexity:\\n    - insert: $O(log(d))$\\n    - inorder: $O(d)$\\n    - total: $O(k^2log(d))$, since there are at most klog(d) nodes be visited for each inorder traverse.\\n\\n- Space complexity:\\n    - $O(2^{log(d)}) = O(d)$  \\n\\n\\n# Code\\n```\\nstruct IntervalNode{\\n    IntervalNode(int left, int right, bool is_interval=true, IntervalNode* left_child=nullptr, IntervalNode* right_child=nullptr)\\n    : left(left), right(right), is_interval(is_interval), left_child(left_child), right_child(right_child){}\\n    int left  = -1;\\n    int right = -1;\\n    bool is_interval;\\n    IntervalNode* left_child;\\n    IntervalNode* right_child;\\n};\\n\\nclass IntervalTree{\\npublic:\\n    IntervalTree(int node_left, int node_right): root_(new IntervalNode(node_left, node_right)){}\\n    void insert(int insert_left, int insert_right){ \\n        insert(insert_left, insert_right, root_->left, root_->right, root_);\\n    }\\n    vector<vector<int>> inorder(){\\n        results.clear();\\n        inorder(root_);\\n        return results;\\n    }\\nprivate:\\n    IntervalNode* insert(int insert_left, int insert_right, int node_left, int node_right, IntervalNode* curr_node){\\n\\n        // cout << insert_left << \", \" << insert_right << \", \" << node_left << \", \" << node_right << \", curr_node\" << endl;\\n        if(!curr_node){ curr_node = new IntervalNode(node_left, node_right); }\\n        if(((insert_left == node_left) && (insert_right == node_right)) || (node_left == node_right)){\\n            return curr_node;\\n        }\\n\\n        int node_mid = (node_left + node_right) / 2;\\n        if(insert_left <= node_mid){ \\n            curr_node->left_child = insert(insert_left, min(insert_right, node_mid), node_left, node_mid, curr_node->left_child);\\n        }\\n        if(insert_right > node_mid){\\n            curr_node->right_child = insert(max(insert_left, node_mid+1), insert_right, node_mid+1, node_right, curr_node->right_child);\\n        }\\n        curr_node->is_interval = (curr_node->left_child) && (curr_node->right_child) && (curr_node->left_child->is_interval) && (curr_node->right_child->is_interval);\\n        return curr_node;\\n    }\\n\\n    void inorder(IntervalNode* curr_node){\\n        if(!curr_node){ return; }\\n        if(curr_node->is_interval){ \\n            if(results.empty()){ results.push_back({curr_node->left, curr_node->right}); }\\n            else{\\n                if(results.back()[1] == (curr_node->left - 1)){ results.back()[1] = curr_node->right; }\\n                else{ results.push_back({curr_node->left, curr_node->right}); }\\n            } \\n            return;\\n        }\\n        inorder(curr_node->left_child);\\n        inorder(curr_node->right_child);\\n    }\\nprivate:\\n    IntervalNode* root_;\\n    vector<vector<int>> results;\\n};\\nclass SummaryRanges {\\npublic:\\n    SummaryRanges() : interval_tree(new IntervalTree(0, 1e4)){}\\n    \\n    void addNum(int value) {\\n        interval_tree->insert(value, value);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        return interval_tree->inorder();\\n    }\\nprivate:\\n    vector<int> memo;\\n    IntervalTree* interval_tree;\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nstruct IntervalNode{\\n    IntervalNode(int left, int right, bool is_interval=true, IntervalNode* left_child=nullptr, IntervalNode* right_child=nullptr)\\n    : left(left), right(right), is_interval(is_interval), left_child(left_child), right_child(right_child){}\\n    int left  = -1;\\n    int right = -1;\\n    bool is_interval;\\n    IntervalNode* left_child;\\n    IntervalNode* right_child;\\n};\\n\\nclass IntervalTree{\\npublic:\\n    IntervalTree(int node_left, int node_right): root_(new IntervalNode(node_left, node_right)){}\\n    void insert(int insert_left, int insert_right){ \\n        insert(insert_left, insert_right, root_->left, root_->right, root_);\\n    }\\n    vector<vector<int>> inorder(){\\n        results.clear();\\n        inorder(root_);\\n        return results;\\n    }\\nprivate:\\n    IntervalNode* insert(int insert_left, int insert_right, int node_left, int node_right, IntervalNode* curr_node){\\n\\n        // cout << insert_left << \", \" << insert_right << \", \" << node_left << \", \" << node_right << \", curr_node\" << endl;\\n        if(!curr_node){ curr_node = new IntervalNode(node_left, node_right); }\\n        if(((insert_left == node_left) && (insert_right == node_right)) || (node_left == node_right)){\\n            return curr_node;\\n        }\\n\\n        int node_mid = (node_left + node_right) / 2;\\n        if(insert_left <= node_mid){ \\n            curr_node->left_child = insert(insert_left, min(insert_right, node_mid), node_left, node_mid, curr_node->left_child);\\n        }\\n        if(insert_right > node_mid){\\n            curr_node->right_child = insert(max(insert_left, node_mid+1), insert_right, node_mid+1, node_right, curr_node->right_child);\\n        }\\n        curr_node->is_interval = (curr_node->left_child) && (curr_node->right_child) && (curr_node->left_child->is_interval) && (curr_node->right_child->is_interval);\\n        return curr_node;\\n    }\\n\\n    void inorder(IntervalNode* curr_node){\\n        if(!curr_node){ return; }\\n        if(curr_node->is_interval){ \\n            if(results.empty()){ results.push_back({curr_node->left, curr_node->right}); }\\n            else{\\n                if(results.back()[1] == (curr_node->left - 1)){ results.back()[1] = curr_node->right; }\\n                else{ results.push_back({curr_node->left, curr_node->right}); }\\n            } \\n            return;\\n        }\\n        inorder(curr_node->left_child);\\n        inorder(curr_node->right_child);\\n    }\\nprivate:\\n    IntervalNode* root_;\\n    vector<vector<int>> results;\\n};\\nclass SummaryRanges {\\npublic:\\n    SummaryRanges() : interval_tree(new IntervalTree(0, 1e4)){}\\n    \\n    void addNum(int value) {\\n        interval_tree->insert(value, value);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        return interval_tree->inorder();\\n    }\\nprivate:\\n    vector<int> memo;\\n    IntervalTree* interval_tree;\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3108130,
                "title": "c-66ms-o-log-n-insert-and-o-n-getintervals-full-explanation-commented-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem as a whole seems to admit two approaches. The space that numbers can appear in is pretty small -- only from 0 to 10000 -- which means it might be viable to store the numbers each individually. However, this would mean we need to recreate the ranges every time from the raw numbers, and with the `getIntervals` function being called up to 30000 times, this becomes cost prohibitive.\\n\\nTherefore, we want to store the complete intervals of numbers that we\\'ve seen so far, and just return the intervals when we\\'re asked to do so. This will require us to do a bit more work in our merge, however. In particular, if we add a number $x$ to the set that has not been added yet, then we might need to merge it into an interval that previously had an upper bound of $n - 1$ or an interval that previously had a lower bound of $n + 1$. We\\'ll want to be able to check if any such intervals exist efficiently.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo make it easy to check whether we\\'re adding a duplicate value, we store one hash set of all the numbers that have already been added. This gives us a quick way to check if a number is a duplicate and we can skip it if it is one. If not, then we store the set of all currently-existing intervals -- twice! One map maps the lower bounds of each interval to their corresponding upper bounds, while the other maps the upper bounds to their lower bounds. This makes it easy to check if there\\'s an interval directly above and below a new value. All intervals are stored as inclusive ranges.\\n\\nIf there is an interval directly below the value, we remove it from both sets and use its lower bound as the lower bound of the new interval. Otherwise, there are no values directly below the new value and this new value is then the lower bound of its interval since `value - 1` does not exist in the collection yet. We then do the same procedure again, checking for an interval with lower bound at `value + 1` to check if an interval above will get merged with the new value.\\n\\nThen, based on the bounds calculated in the above step, we insert the new interval into both maps. The key data structure invariant that we need to maintain in this step is that both of the maps storing intervals represent the same set of intervals at all times. Therefore, we need to be careful to remove from both and add to both.\\n\\nYou might also be wondering about the choice of an ordered `std::map` for the lower-bound map while using an unordered hashing-based structure for everything else. This actually improves our performance from over 80ms to the final 66ms time, because the ordered map can be traversed quickly when `getIntervals` is called without requiring us to sort the intervals every time. If we used a hash map for the `lo` map as well, then we would need to sort the intervals after extracting them from the map, which actually makes our asymptotic complexity worse here! As it turns out, sacrificing a bit of speed on insertions to get a better getIntervals is worth it in the end. :)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`addNum` has complexity $O(\\\\log n)$ where $n$ is the size of the data structure so far. It has to do operations on the ordered map `lo` such as lookup and potentially deletion, which take logarithmic time. The hash-map operations are all constant time.\\n\\n`getIntervals` has complexity $O(n)$ where $n$ is the number of intervals (which can be as large as the number of values inserted so far). We have to iterate through an ordered map, which takes $O(n)$ time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIf we insert $n$ numbers, we need $O(n)$ space for each of the maps/sets that we use since $n$ numbers form up to $n$ distinct intervals.\\n\\n# Code\\n```\\nclass SummaryRanges {\\npublic:\\n    // maps lower bounds of ranges to the upper bounds\\n    map<int, int> lo;\\n    // maps upper bounds of ranges to the lower bounds\\n    unordered_map<int, int> hi;\\n    // set for storing the numbers to deduplicate\\n    unordered_set<int> s;\\n\\n    SummaryRanges() {\\n        // nothing\\n    }\\n    \\n    void addNum(int value) {\\n        // if we already have this value don\\'t add it again\\n        if(s.count(value) > 0) return;\\n        // insert value into the set\\n        s.insert(value);\\n        // lower bound and upper bound for this range\\n        int lb, ub;\\n        // found a range that ends right below new val\\n        if(hi.count(value - 1) > 0) {\\n            // find the new lower bound\\n            lb = hi[value - 1];\\n            // remove copies of this range as it gets merged\\n            hi.erase(value - 1);\\n            lo.erase(lb);\\n        }\\n        else {\\n            // this will be the lowest value in its range\\n            lb = value;\\n        }\\n        // same code, but for the upper bound (symmetric)\\n        if(lo.count(value + 1) > 0) {\\n            ub = lo[value + 1];\\n            lo.erase(value + 1);\\n            hi.erase(ub);\\n        }\\n        else {\\n            ub = value;\\n        }\\n        // add the newly-formed/merged range\\n        lo[lb] = ub;\\n        hi[ub] = lb;\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> v;\\n        // traversing ordered set, which is in order of starting value already\\n        for(pair<int, int> p : lo) {\\n            v.push_back({p.first, p.second});\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nIf this helped you, please upvote!",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass SummaryRanges {\\npublic:\\n    // maps lower bounds of ranges to the upper bounds\\n    map<int, int> lo;\\n    // maps upper bounds of ranges to the lower bounds\\n    unordered_map<int, int> hi;\\n    // set for storing the numbers to deduplicate\\n    unordered_set<int> s;\\n\\n    SummaryRanges() {\\n        // nothing\\n    }\\n    \\n    void addNum(int value) {\\n        // if we already have this value don\\'t add it again\\n        if(s.count(value) > 0) return;\\n        // insert value into the set\\n        s.insert(value);\\n        // lower bound and upper bound for this range\\n        int lb, ub;\\n        // found a range that ends right below new val\\n        if(hi.count(value - 1) > 0) {\\n            // find the new lower bound\\n            lb = hi[value - 1];\\n            // remove copies of this range as it gets merged\\n            hi.erase(value - 1);\\n            lo.erase(lb);\\n        }\\n        else {\\n            // this will be the lowest value in its range\\n            lb = value;\\n        }\\n        // same code, but for the upper bound (symmetric)\\n        if(lo.count(value + 1) > 0) {\\n            ub = lo[value + 1];\\n            lo.erase(value + 1);\\n            hi.erase(ub);\\n        }\\n        else {\\n            ub = value;\\n        }\\n        // add the newly-formed/merged range\\n        lo[lb] = ub;\\n        hi[ub] = lb;\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> v;\\n        // traversing ordered set, which is in order of starting value already\\n        for(pair<int, int> p : lo) {\\n            v.push_back({p.first, p.second});\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108080,
                "title": "easiest-solution",
                "content": "Algorithm:\\n1 . Put data into a set\\n2 . Iterate over set to generate required intervals\\n# Code\\n```\\nclass SummaryRanges {\\npublic:\\n\\n    set<int> dataSet;\\n    void addNum(int value) {\\n        dataSet.insert(value);\\n    }\\n\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> intervals;\\n        \\n        int starti=-1 , endi=-1;\\n        for(auto n : dataSet) {\\n            if(starti==-1) {\\n                starti=n , endi=n;\\n            }\\n            else if(n==endi+1){\\n                endi=n;\\n            }else {\\n                intervals.push_back({starti , endi});\\n                starti=n , endi=n;\\n            }\\n        }\\n        intervals.push_back({starti , endi});\\n        return intervals;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SummaryRanges {\\npublic:\\n\\n    set<int> dataSet;\\n    void addNum(int value) {\\n        dataSet.insert(value);\\n    }\\n\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> intervals;\\n        \\n        int starti=-1 , endi=-1;\\n        for(auto n : dataSet) {\\n            if(starti==-1) {\\n                starti=n , endi=n;\\n            }\\n            else if(n==endi+1){\\n                endi=n;\\n            }else {\\n                intervals.push_back({starti , endi});\\n                starti=n , endi=n;\\n            }\\n        }\\n        intervals.push_back({starti , endi});\\n        return intervals;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107856,
                "title": "easy-binary-search-solution-c",
                "content": "```\\nclass SummaryRanges {\\npublic:\\n    vector<int> v;\\n    SummaryRanges() {\\n    }\\n    \\n    void addNum(int value) {\\n        if(v.size()==0) v.push_back(value);\\n        else{\\n            auto it=lower_bound(v.begin(),v.end(),value)-v.begin();\\n            v.insert(v.begin()+it,value);\\n        }\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> res;\\n        int i=0,j=0;\\n        while(j<v.size()){\\n            while(j+1<v.size() && v[j+1]-v[j]<=1) j++;\\n            res.push_back({v[i],v[j]});\\n            j++;\\n            i=j;\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass SummaryRanges {\\npublic:\\n    vector<int> v;\\n    SummaryRanges() {\\n    }\\n    \\n    void addNum(int value) {\\n        if(v.size()==0) v.push_back(value);\\n        else{\\n            auto it=lower_bound(v.begin(),v.end(),value)-v.begin();\\n            v.insert(v.begin()+it,value);\\n        }\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> res;\\n        int i=0,j=0;\\n        while(j<v.size()){\\n            while(j+1<v.size() && v[j+1]-v[j]<=1) j++;\\n            res.push_back({v[i],v[j]});\\n            j++;\\n            i=j;\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3107828,
                "title": "let-s-learn-kotlin-binary-search-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe ranges are continuously being updated and must be built and maintained in sorted order. That means insorting and insorting means **binary search**!\\nFurthermore, because the integers are added one at a time as a data stream, we can hash them in a set and use this to detect range collisions in constant time.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs mentioned, our class will have two properties: `nums` and `ranges`. `addNum()` will be doing all the work to keep update `ranges` and `getIntervals()` will simply return it.\\nFor any value added, we\\'ll use binary search to find the prospective insertion index for `[value, value]`. Then, check for adjacent values in `nums` and update `ranges` appropriately.\\nExpanding on `addNum()` piece by piece:\\n1. If we\\'ve seen a number before, this function has already previously assured it\\'s accounted for in `ranges`. \\n2. Get the insertion index using binary search. Because of the previous block, it is guaranteed that `value` is not contained within a current range. This simplifies the helper function, allowing it to search only on start values with strict inequality.\\n> By checking `nums` for `value - 1` and `value + 1`, we ascertain whether or not there are adjacent ranges that will absorb `value`.\\n3. I check the singleton case first because it\\'s the double negative case and using negated conditionals enhances readability by keeping all `if` blocks at the top level.\\n4. There\\'s **only** an interval below `value` that is adjacent: increment its end value\\n5. There\\'s **only** an interval above `value` that is adjacent: decrement its start value\\n6. In the double positive case, `value` forms a bridge between two intervals, merging them.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$ for `addNum`, $$O(1)$$ for `getIntervals`\\n\\nNote that binary search is $$O(log(N))$$, but insertion takes linear time.\\nSo given $$N$$ calls, the problem in its entirety is $$O(N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SummaryRanges() {\\n    var ranges = mutableListOf<IntArray>()\\n    var nums = hashSetOf<Int>()\\n\\n    fun addNum(value: Int) {\\n        // already in a range\\n        if (value in nums) return\\n\\n        nums.add(value)\\n        val insertIdx = binarySearch(value)\\n        // add singleton range\\n        if (!nums.contains(value - 1) && !nums.contains(value + 1)) {\\n            ranges.add(insertIdx, IntArray(2) {value})\\n        // append left\\n        } else if (!nums.contains(value + 1)) {\\n            ranges[insertIdx - 1][1] = value\\n        // prepend right\\n        } else if (!nums.contains(value - 1)) {\\n            ranges[insertIdx][0] = value\\n        // merge left and right\\n        } else {\\n            ranges[insertIdx - 1][1] = ranges[insertIdx][1]\\n            ranges.removeAt(insertIdx)\\n        }\\n        return\\n    }\\n\\n    fun getIntervals(): Array<IntArray> {\\n        return ranges.toTypedArray()\\n    }\\n\\n    fun binarySearch(x: Int): Int {\\n        var l = 0\\n        var r = ranges.size\\n        while (l < r) {\\n            val m = (l + r) / 2\\n            if (ranges[m][0] < x) {\\n                l = m + 1\\n            } else {\\n                r = m\\n            }\\n        }\\n        return l\\n    }\\n\\n}\\n```\\n![Screenshot 2023-01-28 at 12.11.53 AM.png](https://assets.leetcode.com/users/images/feb00aab-3375-4adb-ac24-efc7c1341875_1674884643.2472794.png)\\n",
                "solutionTags": [
                    "Kotlin",
                    "Binary Search"
                ],
                "code": "```\\nclass SummaryRanges() {\\n    var ranges = mutableListOf<IntArray>()\\n    var nums = hashSetOf<Int>()\\n\\n    fun addNum(value: Int) {\\n        // already in a range\\n        if (value in nums) return\\n\\n        nums.add(value)\\n        val insertIdx = binarySearch(value)\\n        // add singleton range\\n        if (!nums.contains(value - 1) && !nums.contains(value + 1)) {\\n            ranges.add(insertIdx, IntArray(2) {value})\\n        // append left\\n        } else if (!nums.contains(value + 1)) {\\n            ranges[insertIdx - 1][1] = value\\n        // prepend right\\n        } else if (!nums.contains(value - 1)) {\\n            ranges[insertIdx][0] = value\\n        // merge left and right\\n        } else {\\n            ranges[insertIdx - 1][1] = ranges[insertIdx][1]\\n            ranges.removeAt(insertIdx)\\n        }\\n        return\\n    }\\n\\n    fun getIntervals(): Array<IntArray> {\\n        return ranges.toTypedArray()\\n    }\\n\\n    fun binarySearch(x: Int): Int {\\n        var l = 0\\n        var r = ranges.size\\n        while (l < r) {\\n            val m = (l + r) / 2\\n            if (ranges[m][0] < x) {\\n                l = m + 1\\n            } else {\\n                r = m\\n            }\\n        }\\n        return l\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107810,
                "title": "easy-soluition-with-map-and-findparent-function",
                "content": "# Intuition\\nThe question asks to combine consecutive values into intervals, namely, if we have values of 1, 2, 3, and 4, we can make an interval that starts from 1 and ends at 4. If the data is sorted, we can easily iterate over it to find the intervals. A data structure is needed that allows us to insert elements while maintaining sorted order, otherwise we would need to sort the data every time we call getIntervals, which is expensive.\\n# Approach\\n- in this solution we use `par` array and `findParent()` function to store the start of each segment when acess it from the middle we will update the par in the same steps.\\n- we will store the segments in map array and we will remove segments and add it\\'s concatenation during the addNum.\\n# Complexity\\n- Time complexity:\\n  - O(zlog(n)) for `getIntervals()` function\\n  - O(long(n)) for `addNum()` function\\n\\n- Space complexity:\\n  - O(n)\\n\\n# Code\\n```\\nclass SummaryRanges {\\nprivate:\\n    vector<int>par;\\n    map<int,int>mp;\\n    int findParent(int i){\\n        if(par[i]==i){\\n            return i;\\n        }else{\\n            return par[i]=findParent(par[i]);\\n        }\\n    }\\npublic:\\n    SummaryRanges() {\\n        par=vector<int>((int)1e5,-1);\\n        mp.clear();\\n    }\\n    \\n    void addNum(int value) {\\n        if(par[value]!=-1)return;\\n        int start=0,end=0;\\n        if(value!=0){\\n            if(par[value-1]!=-1){\\n                par[value]=findParent(value-1);\\n            }else{\\n                par[value]=value;\\n            }\\n        }else{\\n            par[value]=value;\\n        }\\n        start=par[value];\\n        if(par[value+1]!=-1){\\n            end=mp[findParent(value+1)];\\n            par[value+1]=findParent(value);\\n            mp.erase(value+1);\\n        }else{\\n            end=value;\\n        }\\n        mp[start]=end;\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>>res;\\n        vector<int>temp(2);\\n        for(auto x:mp){\\n            temp[0]=x.first;\\n            temp[1]=x.second;\\n            res.push_back(temp);\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass SummaryRanges {\\nprivate:\\n    vector<int>par;\\n    map<int,int>mp;\\n    int findParent(int i){\\n        if(par[i]==i){\\n            return i;\\n        }else{\\n            return par[i]=findParent(par[i]);\\n        }\\n    }\\npublic:\\n    SummaryRanges() {\\n        par=vector<int>((int)1e5,-1);\\n        mp.clear();\\n    }\\n    \\n    void addNum(int value) {\\n        if(par[value]!=-1)return;\\n        int start=0,end=0;\\n        if(value!=0){\\n            if(par[value-1]!=-1){\\n                par[value]=findParent(value-1);\\n            }else{\\n                par[value]=value;\\n            }\\n        }else{\\n            par[value]=value;\\n        }\\n        start=par[value];\\n        if(par[value+1]!=-1){\\n            end=mp[findParent(value+1)];\\n            par[value+1]=findParent(value);\\n            mp.erase(value+1);\\n        }else{\\n            end=value;\\n        }\\n        mp[start]=end;\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>>res;\\n        vector<int>temp(2);\\n        for(auto x:mp){\\n            temp[0]=x.first;\\n            temp[1]=x.second;\\n            res.push_back(temp);\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107791,
                "title": "c-simple-set-based-solution",
                "content": "\\tclass SummaryRanges {\\n\\tpublic:\\n\\n\\t\\tset<int> st;\\n\\n\\t\\tSummaryRanges() {\\n\\n\\t\\t}\\n\\n\\t\\tvoid addNum(int value) \\n\\t\\t{\\n\\t\\t\\tst.insert(value);\\n\\t\\t}\\n\\n\\t\\tvector<vector<int>> getIntervals() \\n\\t\\t{\\n\\t\\t\\tvector<vector<int>> res;\\n\\t\\t\\tauto it = st.begin();\\n\\t\\t\\tint start = *it;\\n\\t\\t\\tint end = *it;\\n\\t\\t\\tit++;\\n\\t\\t\\tfor(; it != st.end(); it++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(end + 1 == *it)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tend = *it;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvector<int> temp;\\n\\t\\t\\t\\t\\ttemp.push_back(start);\\n\\t\\t\\t\\t\\ttemp.push_back(end);\\n\\t\\t\\t\\t\\tstart = *it;\\n\\t\\t\\t\\t\\tend = *it;\\n\\t\\t\\t\\t\\tres.push_back(temp);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<int> temp;\\n\\t\\t\\ttemp.push_back(start);\\n\\t\\t\\ttemp.push_back(end);\\n\\t\\t\\tres.push_back(temp);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "\\tclass SummaryRanges {\\n\\tpublic:\\n\\n\\t\\tset<int> st;\\n\\n\\t\\tSummaryRanges() {\\n\\n\\t\\t}\\n\\n\\t\\tvoid addNum(int value) \\n\\t\\t{\\n\\t\\t\\tst.insert(value);\\n\\t\\t}\\n\\n\\t\\tvector<vector<int>> getIntervals() \\n\\t\\t{\\n\\t\\t\\tvector<vector<int>> res;\\n\\t\\t\\tauto it = st.begin();\\n\\t\\t\\tint start = *it;\\n\\t\\t\\tint end = *it;\\n\\t\\t\\tit++;\\n\\t\\t\\tfor(; it != st.end(); it++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(end + 1 == *it)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tend = *it;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvector<int> temp;\\n\\t\\t\\t\\t\\ttemp.push_back(start);\\n\\t\\t\\t\\t\\ttemp.push_back(end);\\n\\t\\t\\t\\t\\tstart = *it;\\n\\t\\t\\t\\t\\tend = *it;\\n\\t\\t\\t\\t\\tres.push_back(temp);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<int> temp;\\n\\t\\t\\ttemp.push_back(start);\\n\\t\\t\\ttemp.push_back(end);\\n\\t\\t\\tres.push_back(temp);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564664,
                "content": [
                    {
                        "username": "lirongbin",
                        "content": "I can not understand the question description, can any one explain it?"
                    },
                    {
                        "username": "santanusen",
                        "content": "The word \"intervals\" is the source of confusion. They meant, summarize \"contiguous numbers\" as intervals. Thus, numbers ```{1, 2, 3, 4, 6, 8, 9}``` will be summarized as ```{[1,4], [6,6], [8,9]}```"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@Maverick767](/Maverick767) mean 1,2,3,4,5 not have any missing number but 1,2,4,6 have 3 and 5 ???"
                    },
                    {
                        "username": "Maverick767",
                        "content": "For anyone doing the daily today and confused by the description, you are basically tasked with merging all consecutive sequences of numbers into a single range. For example, [1,2,3,4,5] would be merged into [1,5]. The range [1,2,4,6] would not be merged entirely as it is not consecutive. In the second case, you would end up with [[1, 2], [4, 4], [6, 6]]"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I want to meet the problem setter who takes joy in withholding such an important piece of information that interval here means a consecutive sequence of numbers, and summary means just the beginning and ending of  that sequence.\\nHow much difficult it is to mention:\\n**A sequence of consecutive numbers `a1, a2, a3 .... an` represents an interval with summary `[a1, an]`**"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Right bro :)"
                    },
                    {
                        "username": "abrahem",
                        "content": "dude ty go paraphrase All leetcode problems "
                    },
                    {
                        "username": "clipper21",
                        "content": "This should be a medium or easy. Explanation is bad too."
                    },
                    {
                        "username": "Det2048",
                        "content": "It\\'s hard because the explanation made it hard."
                    },
                    {
                        "username": "farhaankhanfiroz",
                        "content": "Correct"
                    },
                    {
                        "username": "vin36",
                        "content": "I think an interval in this question is a sequence of consecutive numbers.\nSo in the example where the numbers are: [1, 2, 3, 6, 7]\nThe sequence of consecutive numbers (intervals) are [1,2,3] and [6,7], but we only want the \"summary\": [start, end]. Therefore the intervals are [1,3] and [6,7].\nHope this helps!"
                    },
                    {
                        "username": "0x69ED75",
                        "content": "Man. These questions really need to explain this."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vincent](/MrVinnyLuu) Thanks a lot, I was never going to figure this"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Brute Force solution is accepted."
                    },
                    {
                        "username": "rbarcelos",
                        "content": "I have a C# solution and would like to make sure that it is correct.. could you add a C# code defintion"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "Looking at these hard problems everyday / 2-3 in a week , and graph/heap tree questions makes me want to stop doing this , can\\'t solve most of them , always have to look at solution. \\nI understand that you need to solve hard , but for someone who is forming a practice , its tough. "
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Problem-solving, if not done in a proper order, can demotivate anyone.\nThe daily challenges are not meant for people to learn DSA at all. It is merely there to form a habit of consistency, which is another very important trait for any problem solver.\nThe best way to learn DSA is through Leetcode's Explore cards on all individual Datatype, and if you really are serious about problem-solving then after finishing Leetcode's Explore cards try the A2OJ ladder and try Codeforces."
                    },
                    {
                        "username": "THE_REAL_KBL",
                        "content": "The brute force algorithm works in my case. So you can solve this without using any fance data structure. Just maintain a sorted list containing all added numbers."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, it\\'s a kind of stressful and not quite effective way of practice and learning.\\nAt the beginning, It\\'s better to go to \"Explore\" section and study/practice main basic topics, \"build up you muscles\" in every topic, and then pursue max streaks...\\nAt least this is how I did for myself.\\nGoodluck!"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "its same in my case too i can think of a intuition for a ezy and med level question but if you want to maintain streaks and push your limits then please do it. use you tube use solutions make comments on your own and code it.\\n"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "daily challenges are getting harder and harder ; )"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You basically just need to use a form of binary search to find the relevant range in your list of ranges, then merge with the left or right range if applicable."
                    },
                    {
                        "username": "netheril96",
                        "content": "I'm doing *352. Data Stream as Disjoint Intervals* and get *Output Limit Exceeded* error. But running the test case that throws out this error gives the exact solution as the expected answer. I thought that unlike time limit exceeded or memory limit exceeded, *Output Limit Exceeded* happens only on individual test cases, not cumulatively. Then why would I get this error when the test case passes?"
                    },
                    {
                        "username": "Jai_0710",
                        "content": "i think you have a print statement in your code .... do remove it "
                    },
                    {
                        "username": "powerup7",
                        "content": "Output limit exceeded happens when your output to log overflows."
                    }
                ]
            },
            {
                "id": 1777164,
                "content": [
                    {
                        "username": "lirongbin",
                        "content": "I can not understand the question description, can any one explain it?"
                    },
                    {
                        "username": "santanusen",
                        "content": "The word \"intervals\" is the source of confusion. They meant, summarize \"contiguous numbers\" as intervals. Thus, numbers ```{1, 2, 3, 4, 6, 8, 9}``` will be summarized as ```{[1,4], [6,6], [8,9]}```"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@Maverick767](/Maverick767) mean 1,2,3,4,5 not have any missing number but 1,2,4,6 have 3 and 5 ???"
                    },
                    {
                        "username": "Maverick767",
                        "content": "For anyone doing the daily today and confused by the description, you are basically tasked with merging all consecutive sequences of numbers into a single range. For example, [1,2,3,4,5] would be merged into [1,5]. The range [1,2,4,6] would not be merged entirely as it is not consecutive. In the second case, you would end up with [[1, 2], [4, 4], [6, 6]]"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I want to meet the problem setter who takes joy in withholding such an important piece of information that interval here means a consecutive sequence of numbers, and summary means just the beginning and ending of  that sequence.\\nHow much difficult it is to mention:\\n**A sequence of consecutive numbers `a1, a2, a3 .... an` represents an interval with summary `[a1, an]`**"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Right bro :)"
                    },
                    {
                        "username": "abrahem",
                        "content": "dude ty go paraphrase All leetcode problems "
                    },
                    {
                        "username": "clipper21",
                        "content": "This should be a medium or easy. Explanation is bad too."
                    },
                    {
                        "username": "Det2048",
                        "content": "It\\'s hard because the explanation made it hard."
                    },
                    {
                        "username": "farhaankhanfiroz",
                        "content": "Correct"
                    },
                    {
                        "username": "vin36",
                        "content": "I think an interval in this question is a sequence of consecutive numbers.\nSo in the example where the numbers are: [1, 2, 3, 6, 7]\nThe sequence of consecutive numbers (intervals) are [1,2,3] and [6,7], but we only want the \"summary\": [start, end]. Therefore the intervals are [1,3] and [6,7].\nHope this helps!"
                    },
                    {
                        "username": "0x69ED75",
                        "content": "Man. These questions really need to explain this."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vincent](/MrVinnyLuu) Thanks a lot, I was never going to figure this"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Brute Force solution is accepted."
                    },
                    {
                        "username": "rbarcelos",
                        "content": "I have a C# solution and would like to make sure that it is correct.. could you add a C# code defintion"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "Looking at these hard problems everyday / 2-3 in a week , and graph/heap tree questions makes me want to stop doing this , can\\'t solve most of them , always have to look at solution. \\nI understand that you need to solve hard , but for someone who is forming a practice , its tough. "
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Problem-solving, if not done in a proper order, can demotivate anyone.\nThe daily challenges are not meant for people to learn DSA at all. It is merely there to form a habit of consistency, which is another very important trait for any problem solver.\nThe best way to learn DSA is through Leetcode's Explore cards on all individual Datatype, and if you really are serious about problem-solving then after finishing Leetcode's Explore cards try the A2OJ ladder and try Codeforces."
                    },
                    {
                        "username": "THE_REAL_KBL",
                        "content": "The brute force algorithm works in my case. So you can solve this without using any fance data structure. Just maintain a sorted list containing all added numbers."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, it\\'s a kind of stressful and not quite effective way of practice and learning.\\nAt the beginning, It\\'s better to go to \"Explore\" section and study/practice main basic topics, \"build up you muscles\" in every topic, and then pursue max streaks...\\nAt least this is how I did for myself.\\nGoodluck!"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "its same in my case too i can think of a intuition for a ezy and med level question but if you want to maintain streaks and push your limits then please do it. use you tube use solutions make comments on your own and code it.\\n"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "daily challenges are getting harder and harder ; )"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You basically just need to use a form of binary search to find the relevant range in your list of ranges, then merge with the left or right range if applicable."
                    },
                    {
                        "username": "netheril96",
                        "content": "I'm doing *352. Data Stream as Disjoint Intervals* and get *Output Limit Exceeded* error. But running the test case that throws out this error gives the exact solution as the expected answer. I thought that unlike time limit exceeded or memory limit exceeded, *Output Limit Exceeded* happens only on individual test cases, not cumulatively. Then why would I get this error when the test case passes?"
                    },
                    {
                        "username": "Jai_0710",
                        "content": "i think you have a print statement in your code .... do remove it "
                    },
                    {
                        "username": "powerup7",
                        "content": "Output limit exceeded happens when your output to log overflows."
                    }
                ]
            },
            {
                "id": 1777437,
                "content": [
                    {
                        "username": "lirongbin",
                        "content": "I can not understand the question description, can any one explain it?"
                    },
                    {
                        "username": "santanusen",
                        "content": "The word \"intervals\" is the source of confusion. They meant, summarize \"contiguous numbers\" as intervals. Thus, numbers ```{1, 2, 3, 4, 6, 8, 9}``` will be summarized as ```{[1,4], [6,6], [8,9]}```"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@Maverick767](/Maverick767) mean 1,2,3,4,5 not have any missing number but 1,2,4,6 have 3 and 5 ???"
                    },
                    {
                        "username": "Maverick767",
                        "content": "For anyone doing the daily today and confused by the description, you are basically tasked with merging all consecutive sequences of numbers into a single range. For example, [1,2,3,4,5] would be merged into [1,5]. The range [1,2,4,6] would not be merged entirely as it is not consecutive. In the second case, you would end up with [[1, 2], [4, 4], [6, 6]]"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I want to meet the problem setter who takes joy in withholding such an important piece of information that interval here means a consecutive sequence of numbers, and summary means just the beginning and ending of  that sequence.\\nHow much difficult it is to mention:\\n**A sequence of consecutive numbers `a1, a2, a3 .... an` represents an interval with summary `[a1, an]`**"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Right bro :)"
                    },
                    {
                        "username": "abrahem",
                        "content": "dude ty go paraphrase All leetcode problems "
                    },
                    {
                        "username": "clipper21",
                        "content": "This should be a medium or easy. Explanation is bad too."
                    },
                    {
                        "username": "Det2048",
                        "content": "It\\'s hard because the explanation made it hard."
                    },
                    {
                        "username": "farhaankhanfiroz",
                        "content": "Correct"
                    },
                    {
                        "username": "vin36",
                        "content": "I think an interval in this question is a sequence of consecutive numbers.\nSo in the example where the numbers are: [1, 2, 3, 6, 7]\nThe sequence of consecutive numbers (intervals) are [1,2,3] and [6,7], but we only want the \"summary\": [start, end]. Therefore the intervals are [1,3] and [6,7].\nHope this helps!"
                    },
                    {
                        "username": "0x69ED75",
                        "content": "Man. These questions really need to explain this."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vincent](/MrVinnyLuu) Thanks a lot, I was never going to figure this"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Brute Force solution is accepted."
                    },
                    {
                        "username": "rbarcelos",
                        "content": "I have a C# solution and would like to make sure that it is correct.. could you add a C# code defintion"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "Looking at these hard problems everyday / 2-3 in a week , and graph/heap tree questions makes me want to stop doing this , can\\'t solve most of them , always have to look at solution. \\nI understand that you need to solve hard , but for someone who is forming a practice , its tough. "
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Problem-solving, if not done in a proper order, can demotivate anyone.\nThe daily challenges are not meant for people to learn DSA at all. It is merely there to form a habit of consistency, which is another very important trait for any problem solver.\nThe best way to learn DSA is through Leetcode's Explore cards on all individual Datatype, and if you really are serious about problem-solving then after finishing Leetcode's Explore cards try the A2OJ ladder and try Codeforces."
                    },
                    {
                        "username": "THE_REAL_KBL",
                        "content": "The brute force algorithm works in my case. So you can solve this without using any fance data structure. Just maintain a sorted list containing all added numbers."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, it\\'s a kind of stressful and not quite effective way of practice and learning.\\nAt the beginning, It\\'s better to go to \"Explore\" section and study/practice main basic topics, \"build up you muscles\" in every topic, and then pursue max streaks...\\nAt least this is how I did for myself.\\nGoodluck!"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "its same in my case too i can think of a intuition for a ezy and med level question but if you want to maintain streaks and push your limits then please do it. use you tube use solutions make comments on your own and code it.\\n"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "daily challenges are getting harder and harder ; )"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You basically just need to use a form of binary search to find the relevant range in your list of ranges, then merge with the left or right range if applicable."
                    },
                    {
                        "username": "netheril96",
                        "content": "I'm doing *352. Data Stream as Disjoint Intervals* and get *Output Limit Exceeded* error. But running the test case that throws out this error gives the exact solution as the expected answer. I thought that unlike time limit exceeded or memory limit exceeded, *Output Limit Exceeded* happens only on individual test cases, not cumulatively. Then why would I get this error when the test case passes?"
                    },
                    {
                        "username": "Jai_0710",
                        "content": "i think you have a print statement in your code .... do remove it "
                    },
                    {
                        "username": "powerup7",
                        "content": "Output limit exceeded happens when your output to log overflows."
                    }
                ]
            },
            {
                "id": 1777152,
                "content": [
                    {
                        "username": "lirongbin",
                        "content": "I can not understand the question description, can any one explain it?"
                    },
                    {
                        "username": "santanusen",
                        "content": "The word \"intervals\" is the source of confusion. They meant, summarize \"contiguous numbers\" as intervals. Thus, numbers ```{1, 2, 3, 4, 6, 8, 9}``` will be summarized as ```{[1,4], [6,6], [8,9]}```"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@Maverick767](/Maverick767) mean 1,2,3,4,5 not have any missing number but 1,2,4,6 have 3 and 5 ???"
                    },
                    {
                        "username": "Maverick767",
                        "content": "For anyone doing the daily today and confused by the description, you are basically tasked with merging all consecutive sequences of numbers into a single range. For example, [1,2,3,4,5] would be merged into [1,5]. The range [1,2,4,6] would not be merged entirely as it is not consecutive. In the second case, you would end up with [[1, 2], [4, 4], [6, 6]]"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I want to meet the problem setter who takes joy in withholding such an important piece of information that interval here means a consecutive sequence of numbers, and summary means just the beginning and ending of  that sequence.\\nHow much difficult it is to mention:\\n**A sequence of consecutive numbers `a1, a2, a3 .... an` represents an interval with summary `[a1, an]`**"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Right bro :)"
                    },
                    {
                        "username": "abrahem",
                        "content": "dude ty go paraphrase All leetcode problems "
                    },
                    {
                        "username": "clipper21",
                        "content": "This should be a medium or easy. Explanation is bad too."
                    },
                    {
                        "username": "Det2048",
                        "content": "It\\'s hard because the explanation made it hard."
                    },
                    {
                        "username": "farhaankhanfiroz",
                        "content": "Correct"
                    },
                    {
                        "username": "vin36",
                        "content": "I think an interval in this question is a sequence of consecutive numbers.\nSo in the example where the numbers are: [1, 2, 3, 6, 7]\nThe sequence of consecutive numbers (intervals) are [1,2,3] and [6,7], but we only want the \"summary\": [start, end]. Therefore the intervals are [1,3] and [6,7].\nHope this helps!"
                    },
                    {
                        "username": "0x69ED75",
                        "content": "Man. These questions really need to explain this."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vincent](/MrVinnyLuu) Thanks a lot, I was never going to figure this"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Brute Force solution is accepted."
                    },
                    {
                        "username": "rbarcelos",
                        "content": "I have a C# solution and would like to make sure that it is correct.. could you add a C# code defintion"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "Looking at these hard problems everyday / 2-3 in a week , and graph/heap tree questions makes me want to stop doing this , can\\'t solve most of them , always have to look at solution. \\nI understand that you need to solve hard , but for someone who is forming a practice , its tough. "
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Problem-solving, if not done in a proper order, can demotivate anyone.\nThe daily challenges are not meant for people to learn DSA at all. It is merely there to form a habit of consistency, which is another very important trait for any problem solver.\nThe best way to learn DSA is through Leetcode's Explore cards on all individual Datatype, and if you really are serious about problem-solving then after finishing Leetcode's Explore cards try the A2OJ ladder and try Codeforces."
                    },
                    {
                        "username": "THE_REAL_KBL",
                        "content": "The brute force algorithm works in my case. So you can solve this without using any fance data structure. Just maintain a sorted list containing all added numbers."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, it\\'s a kind of stressful and not quite effective way of practice and learning.\\nAt the beginning, It\\'s better to go to \"Explore\" section and study/practice main basic topics, \"build up you muscles\" in every topic, and then pursue max streaks...\\nAt least this is how I did for myself.\\nGoodluck!"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "its same in my case too i can think of a intuition for a ezy and med level question but if you want to maintain streaks and push your limits then please do it. use you tube use solutions make comments on your own and code it.\\n"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "daily challenges are getting harder and harder ; )"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You basically just need to use a form of binary search to find the relevant range in your list of ranges, then merge with the left or right range if applicable."
                    },
                    {
                        "username": "netheril96",
                        "content": "I'm doing *352. Data Stream as Disjoint Intervals* and get *Output Limit Exceeded* error. But running the test case that throws out this error gives the exact solution as the expected answer. I thought that unlike time limit exceeded or memory limit exceeded, *Output Limit Exceeded* happens only on individual test cases, not cumulatively. Then why would I get this error when the test case passes?"
                    },
                    {
                        "username": "Jai_0710",
                        "content": "i think you have a print statement in your code .... do remove it "
                    },
                    {
                        "username": "powerup7",
                        "content": "Output limit exceeded happens when your output to log overflows."
                    }
                ]
            },
            {
                "id": 1777498,
                "content": [
                    {
                        "username": "lirongbin",
                        "content": "I can not understand the question description, can any one explain it?"
                    },
                    {
                        "username": "santanusen",
                        "content": "The word \"intervals\" is the source of confusion. They meant, summarize \"contiguous numbers\" as intervals. Thus, numbers ```{1, 2, 3, 4, 6, 8, 9}``` will be summarized as ```{[1,4], [6,6], [8,9]}```"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@Maverick767](/Maverick767) mean 1,2,3,4,5 not have any missing number but 1,2,4,6 have 3 and 5 ???"
                    },
                    {
                        "username": "Maverick767",
                        "content": "For anyone doing the daily today and confused by the description, you are basically tasked with merging all consecutive sequences of numbers into a single range. For example, [1,2,3,4,5] would be merged into [1,5]. The range [1,2,4,6] would not be merged entirely as it is not consecutive. In the second case, you would end up with [[1, 2], [4, 4], [6, 6]]"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I want to meet the problem setter who takes joy in withholding such an important piece of information that interval here means a consecutive sequence of numbers, and summary means just the beginning and ending of  that sequence.\\nHow much difficult it is to mention:\\n**A sequence of consecutive numbers `a1, a2, a3 .... an` represents an interval with summary `[a1, an]`**"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Right bro :)"
                    },
                    {
                        "username": "abrahem",
                        "content": "dude ty go paraphrase All leetcode problems "
                    },
                    {
                        "username": "clipper21",
                        "content": "This should be a medium or easy. Explanation is bad too."
                    },
                    {
                        "username": "Det2048",
                        "content": "It\\'s hard because the explanation made it hard."
                    },
                    {
                        "username": "farhaankhanfiroz",
                        "content": "Correct"
                    },
                    {
                        "username": "vin36",
                        "content": "I think an interval in this question is a sequence of consecutive numbers.\nSo in the example where the numbers are: [1, 2, 3, 6, 7]\nThe sequence of consecutive numbers (intervals) are [1,2,3] and [6,7], but we only want the \"summary\": [start, end]. Therefore the intervals are [1,3] and [6,7].\nHope this helps!"
                    },
                    {
                        "username": "0x69ED75",
                        "content": "Man. These questions really need to explain this."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vincent](/MrVinnyLuu) Thanks a lot, I was never going to figure this"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Brute Force solution is accepted."
                    },
                    {
                        "username": "rbarcelos",
                        "content": "I have a C# solution and would like to make sure that it is correct.. could you add a C# code defintion"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "Looking at these hard problems everyday / 2-3 in a week , and graph/heap tree questions makes me want to stop doing this , can\\'t solve most of them , always have to look at solution. \\nI understand that you need to solve hard , but for someone who is forming a practice , its tough. "
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Problem-solving, if not done in a proper order, can demotivate anyone.\nThe daily challenges are not meant for people to learn DSA at all. It is merely there to form a habit of consistency, which is another very important trait for any problem solver.\nThe best way to learn DSA is through Leetcode's Explore cards on all individual Datatype, and if you really are serious about problem-solving then after finishing Leetcode's Explore cards try the A2OJ ladder and try Codeforces."
                    },
                    {
                        "username": "THE_REAL_KBL",
                        "content": "The brute force algorithm works in my case. So you can solve this without using any fance data structure. Just maintain a sorted list containing all added numbers."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, it\\'s a kind of stressful and not quite effective way of practice and learning.\\nAt the beginning, It\\'s better to go to \"Explore\" section and study/practice main basic topics, \"build up you muscles\" in every topic, and then pursue max streaks...\\nAt least this is how I did for myself.\\nGoodluck!"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "its same in my case too i can think of a intuition for a ezy and med level question but if you want to maintain streaks and push your limits then please do it. use you tube use solutions make comments on your own and code it.\\n"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "daily challenges are getting harder and harder ; )"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You basically just need to use a form of binary search to find the relevant range in your list of ranges, then merge with the left or right range if applicable."
                    },
                    {
                        "username": "netheril96",
                        "content": "I'm doing *352. Data Stream as Disjoint Intervals* and get *Output Limit Exceeded* error. But running the test case that throws out this error gives the exact solution as the expected answer. I thought that unlike time limit exceeded or memory limit exceeded, *Output Limit Exceeded* happens only on individual test cases, not cumulatively. Then why would I get this error when the test case passes?"
                    },
                    {
                        "username": "Jai_0710",
                        "content": "i think you have a print statement in your code .... do remove it "
                    },
                    {
                        "username": "powerup7",
                        "content": "Output limit exceeded happens when your output to log overflows."
                    }
                ]
            },
            {
                "id": 1565949,
                "content": [
                    {
                        "username": "lirongbin",
                        "content": "I can not understand the question description, can any one explain it?"
                    },
                    {
                        "username": "santanusen",
                        "content": "The word \"intervals\" is the source of confusion. They meant, summarize \"contiguous numbers\" as intervals. Thus, numbers ```{1, 2, 3, 4, 6, 8, 9}``` will be summarized as ```{[1,4], [6,6], [8,9]}```"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@Maverick767](/Maverick767) mean 1,2,3,4,5 not have any missing number but 1,2,4,6 have 3 and 5 ???"
                    },
                    {
                        "username": "Maverick767",
                        "content": "For anyone doing the daily today and confused by the description, you are basically tasked with merging all consecutive sequences of numbers into a single range. For example, [1,2,3,4,5] would be merged into [1,5]. The range [1,2,4,6] would not be merged entirely as it is not consecutive. In the second case, you would end up with [[1, 2], [4, 4], [6, 6]]"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I want to meet the problem setter who takes joy in withholding such an important piece of information that interval here means a consecutive sequence of numbers, and summary means just the beginning and ending of  that sequence.\\nHow much difficult it is to mention:\\n**A sequence of consecutive numbers `a1, a2, a3 .... an` represents an interval with summary `[a1, an]`**"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Right bro :)"
                    },
                    {
                        "username": "abrahem",
                        "content": "dude ty go paraphrase All leetcode problems "
                    },
                    {
                        "username": "clipper21",
                        "content": "This should be a medium or easy. Explanation is bad too."
                    },
                    {
                        "username": "Det2048",
                        "content": "It\\'s hard because the explanation made it hard."
                    },
                    {
                        "username": "farhaankhanfiroz",
                        "content": "Correct"
                    },
                    {
                        "username": "vin36",
                        "content": "I think an interval in this question is a sequence of consecutive numbers.\nSo in the example where the numbers are: [1, 2, 3, 6, 7]\nThe sequence of consecutive numbers (intervals) are [1,2,3] and [6,7], but we only want the \"summary\": [start, end]. Therefore the intervals are [1,3] and [6,7].\nHope this helps!"
                    },
                    {
                        "username": "0x69ED75",
                        "content": "Man. These questions really need to explain this."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vincent](/MrVinnyLuu) Thanks a lot, I was never going to figure this"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Brute Force solution is accepted."
                    },
                    {
                        "username": "rbarcelos",
                        "content": "I have a C# solution and would like to make sure that it is correct.. could you add a C# code defintion"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "Looking at these hard problems everyday / 2-3 in a week , and graph/heap tree questions makes me want to stop doing this , can\\'t solve most of them , always have to look at solution. \\nI understand that you need to solve hard , but for someone who is forming a practice , its tough. "
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Problem-solving, if not done in a proper order, can demotivate anyone.\nThe daily challenges are not meant for people to learn DSA at all. It is merely there to form a habit of consistency, which is another very important trait for any problem solver.\nThe best way to learn DSA is through Leetcode's Explore cards on all individual Datatype, and if you really are serious about problem-solving then after finishing Leetcode's Explore cards try the A2OJ ladder and try Codeforces."
                    },
                    {
                        "username": "THE_REAL_KBL",
                        "content": "The brute force algorithm works in my case. So you can solve this without using any fance data structure. Just maintain a sorted list containing all added numbers."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, it\\'s a kind of stressful and not quite effective way of practice and learning.\\nAt the beginning, It\\'s better to go to \"Explore\" section and study/practice main basic topics, \"build up you muscles\" in every topic, and then pursue max streaks...\\nAt least this is how I did for myself.\\nGoodluck!"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "its same in my case too i can think of a intuition for a ezy and med level question but if you want to maintain streaks and push your limits then please do it. use you tube use solutions make comments on your own and code it.\\n"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "daily challenges are getting harder and harder ; )"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You basically just need to use a form of binary search to find the relevant range in your list of ranges, then merge with the left or right range if applicable."
                    },
                    {
                        "username": "netheril96",
                        "content": "I'm doing *352. Data Stream as Disjoint Intervals* and get *Output Limit Exceeded* error. But running the test case that throws out this error gives the exact solution as the expected answer. I thought that unlike time limit exceeded or memory limit exceeded, *Output Limit Exceeded* happens only on individual test cases, not cumulatively. Then why would I get this error when the test case passes?"
                    },
                    {
                        "username": "Jai_0710",
                        "content": "i think you have a print statement in your code .... do remove it "
                    },
                    {
                        "username": "powerup7",
                        "content": "Output limit exceeded happens when your output to log overflows."
                    }
                ]
            },
            {
                "id": 1777457,
                "content": [
                    {
                        "username": "lirongbin",
                        "content": "I can not understand the question description, can any one explain it?"
                    },
                    {
                        "username": "santanusen",
                        "content": "The word \"intervals\" is the source of confusion. They meant, summarize \"contiguous numbers\" as intervals. Thus, numbers ```{1, 2, 3, 4, 6, 8, 9}``` will be summarized as ```{[1,4], [6,6], [8,9]}```"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@Maverick767](/Maverick767) mean 1,2,3,4,5 not have any missing number but 1,2,4,6 have 3 and 5 ???"
                    },
                    {
                        "username": "Maverick767",
                        "content": "For anyone doing the daily today and confused by the description, you are basically tasked with merging all consecutive sequences of numbers into a single range. For example, [1,2,3,4,5] would be merged into [1,5]. The range [1,2,4,6] would not be merged entirely as it is not consecutive. In the second case, you would end up with [[1, 2], [4, 4], [6, 6]]"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I want to meet the problem setter who takes joy in withholding such an important piece of information that interval here means a consecutive sequence of numbers, and summary means just the beginning and ending of  that sequence.\\nHow much difficult it is to mention:\\n**A sequence of consecutive numbers `a1, a2, a3 .... an` represents an interval with summary `[a1, an]`**"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Right bro :)"
                    },
                    {
                        "username": "abrahem",
                        "content": "dude ty go paraphrase All leetcode problems "
                    },
                    {
                        "username": "clipper21",
                        "content": "This should be a medium or easy. Explanation is bad too."
                    },
                    {
                        "username": "Det2048",
                        "content": "It\\'s hard because the explanation made it hard."
                    },
                    {
                        "username": "farhaankhanfiroz",
                        "content": "Correct"
                    },
                    {
                        "username": "vin36",
                        "content": "I think an interval in this question is a sequence of consecutive numbers.\nSo in the example where the numbers are: [1, 2, 3, 6, 7]\nThe sequence of consecutive numbers (intervals) are [1,2,3] and [6,7], but we only want the \"summary\": [start, end]. Therefore the intervals are [1,3] and [6,7].\nHope this helps!"
                    },
                    {
                        "username": "0x69ED75",
                        "content": "Man. These questions really need to explain this."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vincent](/MrVinnyLuu) Thanks a lot, I was never going to figure this"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Brute Force solution is accepted."
                    },
                    {
                        "username": "rbarcelos",
                        "content": "I have a C# solution and would like to make sure that it is correct.. could you add a C# code defintion"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "Looking at these hard problems everyday / 2-3 in a week , and graph/heap tree questions makes me want to stop doing this , can\\'t solve most of them , always have to look at solution. \\nI understand that you need to solve hard , but for someone who is forming a practice , its tough. "
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Problem-solving, if not done in a proper order, can demotivate anyone.\nThe daily challenges are not meant for people to learn DSA at all. It is merely there to form a habit of consistency, which is another very important trait for any problem solver.\nThe best way to learn DSA is through Leetcode's Explore cards on all individual Datatype, and if you really are serious about problem-solving then after finishing Leetcode's Explore cards try the A2OJ ladder and try Codeforces."
                    },
                    {
                        "username": "THE_REAL_KBL",
                        "content": "The brute force algorithm works in my case. So you can solve this without using any fance data structure. Just maintain a sorted list containing all added numbers."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, it\\'s a kind of stressful and not quite effective way of practice and learning.\\nAt the beginning, It\\'s better to go to \"Explore\" section and study/practice main basic topics, \"build up you muscles\" in every topic, and then pursue max streaks...\\nAt least this is how I did for myself.\\nGoodluck!"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "its same in my case too i can think of a intuition for a ezy and med level question but if you want to maintain streaks and push your limits then please do it. use you tube use solutions make comments on your own and code it.\\n"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "daily challenges are getting harder and harder ; )"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You basically just need to use a form of binary search to find the relevant range in your list of ranges, then merge with the left or right range if applicable."
                    },
                    {
                        "username": "netheril96",
                        "content": "I'm doing *352. Data Stream as Disjoint Intervals* and get *Output Limit Exceeded* error. But running the test case that throws out this error gives the exact solution as the expected answer. I thought that unlike time limit exceeded or memory limit exceeded, *Output Limit Exceeded* happens only on individual test cases, not cumulatively. Then why would I get this error when the test case passes?"
                    },
                    {
                        "username": "Jai_0710",
                        "content": "i think you have a print statement in your code .... do remove it "
                    },
                    {
                        "username": "powerup7",
                        "content": "Output limit exceeded happens when your output to log overflows."
                    }
                ]
            },
            {
                "id": 1777492,
                "content": [
                    {
                        "username": "lirongbin",
                        "content": "I can not understand the question description, can any one explain it?"
                    },
                    {
                        "username": "santanusen",
                        "content": "The word \"intervals\" is the source of confusion. They meant, summarize \"contiguous numbers\" as intervals. Thus, numbers ```{1, 2, 3, 4, 6, 8, 9}``` will be summarized as ```{[1,4], [6,6], [8,9]}```"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@Maverick767](/Maverick767) mean 1,2,3,4,5 not have any missing number but 1,2,4,6 have 3 and 5 ???"
                    },
                    {
                        "username": "Maverick767",
                        "content": "For anyone doing the daily today and confused by the description, you are basically tasked with merging all consecutive sequences of numbers into a single range. For example, [1,2,3,4,5] would be merged into [1,5]. The range [1,2,4,6] would not be merged entirely as it is not consecutive. In the second case, you would end up with [[1, 2], [4, 4], [6, 6]]"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I want to meet the problem setter who takes joy in withholding such an important piece of information that interval here means a consecutive sequence of numbers, and summary means just the beginning and ending of  that sequence.\\nHow much difficult it is to mention:\\n**A sequence of consecutive numbers `a1, a2, a3 .... an` represents an interval with summary `[a1, an]`**"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Right bro :)"
                    },
                    {
                        "username": "abrahem",
                        "content": "dude ty go paraphrase All leetcode problems "
                    },
                    {
                        "username": "clipper21",
                        "content": "This should be a medium or easy. Explanation is bad too."
                    },
                    {
                        "username": "Det2048",
                        "content": "It\\'s hard because the explanation made it hard."
                    },
                    {
                        "username": "farhaankhanfiroz",
                        "content": "Correct"
                    },
                    {
                        "username": "vin36",
                        "content": "I think an interval in this question is a sequence of consecutive numbers.\nSo in the example where the numbers are: [1, 2, 3, 6, 7]\nThe sequence of consecutive numbers (intervals) are [1,2,3] and [6,7], but we only want the \"summary\": [start, end]. Therefore the intervals are [1,3] and [6,7].\nHope this helps!"
                    },
                    {
                        "username": "0x69ED75",
                        "content": "Man. These questions really need to explain this."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vincent](/MrVinnyLuu) Thanks a lot, I was never going to figure this"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Brute Force solution is accepted."
                    },
                    {
                        "username": "rbarcelos",
                        "content": "I have a C# solution and would like to make sure that it is correct.. could you add a C# code defintion"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "Looking at these hard problems everyday / 2-3 in a week , and graph/heap tree questions makes me want to stop doing this , can\\'t solve most of them , always have to look at solution. \\nI understand that you need to solve hard , but for someone who is forming a practice , its tough. "
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Problem-solving, if not done in a proper order, can demotivate anyone.\nThe daily challenges are not meant for people to learn DSA at all. It is merely there to form a habit of consistency, which is another very important trait for any problem solver.\nThe best way to learn DSA is through Leetcode's Explore cards on all individual Datatype, and if you really are serious about problem-solving then after finishing Leetcode's Explore cards try the A2OJ ladder and try Codeforces."
                    },
                    {
                        "username": "THE_REAL_KBL",
                        "content": "The brute force algorithm works in my case. So you can solve this without using any fance data structure. Just maintain a sorted list containing all added numbers."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, it\\'s a kind of stressful and not quite effective way of practice and learning.\\nAt the beginning, It\\'s better to go to \"Explore\" section and study/practice main basic topics, \"build up you muscles\" in every topic, and then pursue max streaks...\\nAt least this is how I did for myself.\\nGoodluck!"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "its same in my case too i can think of a intuition for a ezy and med level question but if you want to maintain streaks and push your limits then please do it. use you tube use solutions make comments on your own and code it.\\n"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "daily challenges are getting harder and harder ; )"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You basically just need to use a form of binary search to find the relevant range in your list of ranges, then merge with the left or right range if applicable."
                    },
                    {
                        "username": "netheril96",
                        "content": "I'm doing *352. Data Stream as Disjoint Intervals* and get *Output Limit Exceeded* error. But running the test case that throws out this error gives the exact solution as the expected answer. I thought that unlike time limit exceeded or memory limit exceeded, *Output Limit Exceeded* happens only on individual test cases, not cumulatively. Then why would I get this error when the test case passes?"
                    },
                    {
                        "username": "Jai_0710",
                        "content": "i think you have a print statement in your code .... do remove it "
                    },
                    {
                        "username": "powerup7",
                        "content": "Output limit exceeded happens when your output to log overflows."
                    }
                ]
            },
            {
                "id": 1777186,
                "content": [
                    {
                        "username": "lirongbin",
                        "content": "I can not understand the question description, can any one explain it?"
                    },
                    {
                        "username": "santanusen",
                        "content": "The word \"intervals\" is the source of confusion. They meant, summarize \"contiguous numbers\" as intervals. Thus, numbers ```{1, 2, 3, 4, 6, 8, 9}``` will be summarized as ```{[1,4], [6,6], [8,9]}```"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@Maverick767](/Maverick767) mean 1,2,3,4,5 not have any missing number but 1,2,4,6 have 3 and 5 ???"
                    },
                    {
                        "username": "Maverick767",
                        "content": "For anyone doing the daily today and confused by the description, you are basically tasked with merging all consecutive sequences of numbers into a single range. For example, [1,2,3,4,5] would be merged into [1,5]. The range [1,2,4,6] would not be merged entirely as it is not consecutive. In the second case, you would end up with [[1, 2], [4, 4], [6, 6]]"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I want to meet the problem setter who takes joy in withholding such an important piece of information that interval here means a consecutive sequence of numbers, and summary means just the beginning and ending of  that sequence.\\nHow much difficult it is to mention:\\n**A sequence of consecutive numbers `a1, a2, a3 .... an` represents an interval with summary `[a1, an]`**"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Right bro :)"
                    },
                    {
                        "username": "abrahem",
                        "content": "dude ty go paraphrase All leetcode problems "
                    },
                    {
                        "username": "clipper21",
                        "content": "This should be a medium or easy. Explanation is bad too."
                    },
                    {
                        "username": "Det2048",
                        "content": "It\\'s hard because the explanation made it hard."
                    },
                    {
                        "username": "farhaankhanfiroz",
                        "content": "Correct"
                    },
                    {
                        "username": "vin36",
                        "content": "I think an interval in this question is a sequence of consecutive numbers.\nSo in the example where the numbers are: [1, 2, 3, 6, 7]\nThe sequence of consecutive numbers (intervals) are [1,2,3] and [6,7], but we only want the \"summary\": [start, end]. Therefore the intervals are [1,3] and [6,7].\nHope this helps!"
                    },
                    {
                        "username": "0x69ED75",
                        "content": "Man. These questions really need to explain this."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vincent](/MrVinnyLuu) Thanks a lot, I was never going to figure this"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Brute Force solution is accepted."
                    },
                    {
                        "username": "rbarcelos",
                        "content": "I have a C# solution and would like to make sure that it is correct.. could you add a C# code defintion"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "Looking at these hard problems everyday / 2-3 in a week , and graph/heap tree questions makes me want to stop doing this , can\\'t solve most of them , always have to look at solution. \\nI understand that you need to solve hard , but for someone who is forming a practice , its tough. "
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Problem-solving, if not done in a proper order, can demotivate anyone.\nThe daily challenges are not meant for people to learn DSA at all. It is merely there to form a habit of consistency, which is another very important trait for any problem solver.\nThe best way to learn DSA is through Leetcode's Explore cards on all individual Datatype, and if you really are serious about problem-solving then after finishing Leetcode's Explore cards try the A2OJ ladder and try Codeforces."
                    },
                    {
                        "username": "THE_REAL_KBL",
                        "content": "The brute force algorithm works in my case. So you can solve this without using any fance data structure. Just maintain a sorted list containing all added numbers."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, it\\'s a kind of stressful and not quite effective way of practice and learning.\\nAt the beginning, It\\'s better to go to \"Explore\" section and study/practice main basic topics, \"build up you muscles\" in every topic, and then pursue max streaks...\\nAt least this is how I did for myself.\\nGoodluck!"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "its same in my case too i can think of a intuition for a ezy and med level question but if you want to maintain streaks and push your limits then please do it. use you tube use solutions make comments on your own and code it.\\n"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "daily challenges are getting harder and harder ; )"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You basically just need to use a form of binary search to find the relevant range in your list of ranges, then merge with the left or right range if applicable."
                    },
                    {
                        "username": "netheril96",
                        "content": "I'm doing *352. Data Stream as Disjoint Intervals* and get *Output Limit Exceeded* error. But running the test case that throws out this error gives the exact solution as the expected answer. I thought that unlike time limit exceeded or memory limit exceeded, *Output Limit Exceeded* happens only on individual test cases, not cumulatively. Then why would I get this error when the test case passes?"
                    },
                    {
                        "username": "Jai_0710",
                        "content": "i think you have a print statement in your code .... do remove it "
                    },
                    {
                        "username": "powerup7",
                        "content": "Output limit exceeded happens when your output to log overflows."
                    }
                ]
            },
            {
                "id": 1569094,
                "content": [
                    {
                        "username": "lirongbin",
                        "content": "I can not understand the question description, can any one explain it?"
                    },
                    {
                        "username": "santanusen",
                        "content": "The word \"intervals\" is the source of confusion. They meant, summarize \"contiguous numbers\" as intervals. Thus, numbers ```{1, 2, 3, 4, 6, 8, 9}``` will be summarized as ```{[1,4], [6,6], [8,9]}```"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@Maverick767](/Maverick767) mean 1,2,3,4,5 not have any missing number but 1,2,4,6 have 3 and 5 ???"
                    },
                    {
                        "username": "Maverick767",
                        "content": "For anyone doing the daily today and confused by the description, you are basically tasked with merging all consecutive sequences of numbers into a single range. For example, [1,2,3,4,5] would be merged into [1,5]. The range [1,2,4,6] would not be merged entirely as it is not consecutive. In the second case, you would end up with [[1, 2], [4, 4], [6, 6]]"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I want to meet the problem setter who takes joy in withholding such an important piece of information that interval here means a consecutive sequence of numbers, and summary means just the beginning and ending of  that sequence.\\nHow much difficult it is to mention:\\n**A sequence of consecutive numbers `a1, a2, a3 .... an` represents an interval with summary `[a1, an]`**"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Right bro :)"
                    },
                    {
                        "username": "abrahem",
                        "content": "dude ty go paraphrase All leetcode problems "
                    },
                    {
                        "username": "clipper21",
                        "content": "This should be a medium or easy. Explanation is bad too."
                    },
                    {
                        "username": "Det2048",
                        "content": "It\\'s hard because the explanation made it hard."
                    },
                    {
                        "username": "farhaankhanfiroz",
                        "content": "Correct"
                    },
                    {
                        "username": "vin36",
                        "content": "I think an interval in this question is a sequence of consecutive numbers.\nSo in the example where the numbers are: [1, 2, 3, 6, 7]\nThe sequence of consecutive numbers (intervals) are [1,2,3] and [6,7], but we only want the \"summary\": [start, end]. Therefore the intervals are [1,3] and [6,7].\nHope this helps!"
                    },
                    {
                        "username": "0x69ED75",
                        "content": "Man. These questions really need to explain this."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vincent](/MrVinnyLuu) Thanks a lot, I was never going to figure this"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Brute Force solution is accepted."
                    },
                    {
                        "username": "rbarcelos",
                        "content": "I have a C# solution and would like to make sure that it is correct.. could you add a C# code defintion"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "Looking at these hard problems everyday / 2-3 in a week , and graph/heap tree questions makes me want to stop doing this , can\\'t solve most of them , always have to look at solution. \\nI understand that you need to solve hard , but for someone who is forming a practice , its tough. "
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Problem-solving, if not done in a proper order, can demotivate anyone.\nThe daily challenges are not meant for people to learn DSA at all. It is merely there to form a habit of consistency, which is another very important trait for any problem solver.\nThe best way to learn DSA is through Leetcode's Explore cards on all individual Datatype, and if you really are serious about problem-solving then after finishing Leetcode's Explore cards try the A2OJ ladder and try Codeforces."
                    },
                    {
                        "username": "THE_REAL_KBL",
                        "content": "The brute force algorithm works in my case. So you can solve this without using any fance data structure. Just maintain a sorted list containing all added numbers."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, it\\'s a kind of stressful and not quite effective way of practice and learning.\\nAt the beginning, It\\'s better to go to \"Explore\" section and study/practice main basic topics, \"build up you muscles\" in every topic, and then pursue max streaks...\\nAt least this is how I did for myself.\\nGoodluck!"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "its same in my case too i can think of a intuition for a ezy and med level question but if you want to maintain streaks and push your limits then please do it. use you tube use solutions make comments on your own and code it.\\n"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "daily challenges are getting harder and harder ; )"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You basically just need to use a form of binary search to find the relevant range in your list of ranges, then merge with the left or right range if applicable."
                    },
                    {
                        "username": "netheril96",
                        "content": "I'm doing *352. Data Stream as Disjoint Intervals* and get *Output Limit Exceeded* error. But running the test case that throws out this error gives the exact solution as the expected answer. I thought that unlike time limit exceeded or memory limit exceeded, *Output Limit Exceeded* happens only on individual test cases, not cumulatively. Then why would I get this error when the test case passes?"
                    },
                    {
                        "username": "Jai_0710",
                        "content": "i think you have a print statement in your code .... do remove it "
                    },
                    {
                        "username": "powerup7",
                        "content": "Output limit exceeded happens when your output to log overflows."
                    }
                ]
            },
            {
                "id": 1564664,
                "content": [
                    {
                        "username": "lirongbin",
                        "content": "I can not understand the question description, can any one explain it?"
                    },
                    {
                        "username": "santanusen",
                        "content": "The word \"intervals\" is the source of confusion. They meant, summarize \"contiguous numbers\" as intervals. Thus, numbers ```{1, 2, 3, 4, 6, 8, 9}``` will be summarized as ```{[1,4], [6,6], [8,9]}```"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@Maverick767](/Maverick767) mean 1,2,3,4,5 not have any missing number but 1,2,4,6 have 3 and 5 ???"
                    },
                    {
                        "username": "Maverick767",
                        "content": "For anyone doing the daily today and confused by the description, you are basically tasked with merging all consecutive sequences of numbers into a single range. For example, [1,2,3,4,5] would be merged into [1,5]. The range [1,2,4,6] would not be merged entirely as it is not consecutive. In the second case, you would end up with [[1, 2], [4, 4], [6, 6]]"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I want to meet the problem setter who takes joy in withholding such an important piece of information that interval here means a consecutive sequence of numbers, and summary means just the beginning and ending of  that sequence.\\nHow much difficult it is to mention:\\n**A sequence of consecutive numbers `a1, a2, a3 .... an` represents an interval with summary `[a1, an]`**"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Right bro :)"
                    },
                    {
                        "username": "abrahem",
                        "content": "dude ty go paraphrase All leetcode problems "
                    },
                    {
                        "username": "clipper21",
                        "content": "This should be a medium or easy. Explanation is bad too."
                    },
                    {
                        "username": "Det2048",
                        "content": "It\\'s hard because the explanation made it hard."
                    },
                    {
                        "username": "farhaankhanfiroz",
                        "content": "Correct"
                    },
                    {
                        "username": "vin36",
                        "content": "I think an interval in this question is a sequence of consecutive numbers.\nSo in the example where the numbers are: [1, 2, 3, 6, 7]\nThe sequence of consecutive numbers (intervals) are [1,2,3] and [6,7], but we only want the \"summary\": [start, end]. Therefore the intervals are [1,3] and [6,7].\nHope this helps!"
                    },
                    {
                        "username": "0x69ED75",
                        "content": "Man. These questions really need to explain this."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vincent](/MrVinnyLuu) Thanks a lot, I was never going to figure this"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Brute Force solution is accepted."
                    },
                    {
                        "username": "rbarcelos",
                        "content": "I have a C# solution and would like to make sure that it is correct.. could you add a C# code defintion"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "Looking at these hard problems everyday / 2-3 in a week , and graph/heap tree questions makes me want to stop doing this , can\\'t solve most of them , always have to look at solution. \\nI understand that you need to solve hard , but for someone who is forming a practice , its tough. "
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Problem-solving, if not done in a proper order, can demotivate anyone.\nThe daily challenges are not meant for people to learn DSA at all. It is merely there to form a habit of consistency, which is another very important trait for any problem solver.\nThe best way to learn DSA is through Leetcode's Explore cards on all individual Datatype, and if you really are serious about problem-solving then after finishing Leetcode's Explore cards try the A2OJ ladder and try Codeforces."
                    },
                    {
                        "username": "THE_REAL_KBL",
                        "content": "The brute force algorithm works in my case. So you can solve this without using any fance data structure. Just maintain a sorted list containing all added numbers."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, it\\'s a kind of stressful and not quite effective way of practice and learning.\\nAt the beginning, It\\'s better to go to \"Explore\" section and study/practice main basic topics, \"build up you muscles\" in every topic, and then pursue max streaks...\\nAt least this is how I did for myself.\\nGoodluck!"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "its same in my case too i can think of a intuition for a ezy and med level question but if you want to maintain streaks and push your limits then please do it. use you tube use solutions make comments on your own and code it.\\n"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "daily challenges are getting harder and harder ; )"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You basically just need to use a form of binary search to find the relevant range in your list of ranges, then merge with the left or right range if applicable."
                    },
                    {
                        "username": "netheril96",
                        "content": "I'm doing *352. Data Stream as Disjoint Intervals* and get *Output Limit Exceeded* error. But running the test case that throws out this error gives the exact solution as the expected answer. I thought that unlike time limit exceeded or memory limit exceeded, *Output Limit Exceeded* happens only on individual test cases, not cumulatively. Then why would I get this error when the test case passes?"
                    },
                    {
                        "username": "Jai_0710",
                        "content": "i think you have a print statement in your code .... do remove it "
                    },
                    {
                        "username": "powerup7",
                        "content": "Output limit exceeded happens when your output to log overflows."
                    }
                ]
            },
            {
                "id": 1777164,
                "content": [
                    {
                        "username": "lirongbin",
                        "content": "I can not understand the question description, can any one explain it?"
                    },
                    {
                        "username": "santanusen",
                        "content": "The word \"intervals\" is the source of confusion. They meant, summarize \"contiguous numbers\" as intervals. Thus, numbers ```{1, 2, 3, 4, 6, 8, 9}``` will be summarized as ```{[1,4], [6,6], [8,9]}```"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@Maverick767](/Maverick767) mean 1,2,3,4,5 not have any missing number but 1,2,4,6 have 3 and 5 ???"
                    },
                    {
                        "username": "Maverick767",
                        "content": "For anyone doing the daily today and confused by the description, you are basically tasked with merging all consecutive sequences of numbers into a single range. For example, [1,2,3,4,5] would be merged into [1,5]. The range [1,2,4,6] would not be merged entirely as it is not consecutive. In the second case, you would end up with [[1, 2], [4, 4], [6, 6]]"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I want to meet the problem setter who takes joy in withholding such an important piece of information that interval here means a consecutive sequence of numbers, and summary means just the beginning and ending of  that sequence.\\nHow much difficult it is to mention:\\n**A sequence of consecutive numbers `a1, a2, a3 .... an` represents an interval with summary `[a1, an]`**"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Right bro :)"
                    },
                    {
                        "username": "abrahem",
                        "content": "dude ty go paraphrase All leetcode problems "
                    },
                    {
                        "username": "clipper21",
                        "content": "This should be a medium or easy. Explanation is bad too."
                    },
                    {
                        "username": "Det2048",
                        "content": "It\\'s hard because the explanation made it hard."
                    },
                    {
                        "username": "farhaankhanfiroz",
                        "content": "Correct"
                    },
                    {
                        "username": "vin36",
                        "content": "I think an interval in this question is a sequence of consecutive numbers.\nSo in the example where the numbers are: [1, 2, 3, 6, 7]\nThe sequence of consecutive numbers (intervals) are [1,2,3] and [6,7], but we only want the \"summary\": [start, end]. Therefore the intervals are [1,3] and [6,7].\nHope this helps!"
                    },
                    {
                        "username": "0x69ED75",
                        "content": "Man. These questions really need to explain this."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vincent](/MrVinnyLuu) Thanks a lot, I was never going to figure this"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Brute Force solution is accepted."
                    },
                    {
                        "username": "rbarcelos",
                        "content": "I have a C# solution and would like to make sure that it is correct.. could you add a C# code defintion"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "Looking at these hard problems everyday / 2-3 in a week , and graph/heap tree questions makes me want to stop doing this , can\\'t solve most of them , always have to look at solution. \\nI understand that you need to solve hard , but for someone who is forming a practice , its tough. "
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Problem-solving, if not done in a proper order, can demotivate anyone.\nThe daily challenges are not meant for people to learn DSA at all. It is merely there to form a habit of consistency, which is another very important trait for any problem solver.\nThe best way to learn DSA is through Leetcode's Explore cards on all individual Datatype, and if you really are serious about problem-solving then after finishing Leetcode's Explore cards try the A2OJ ladder and try Codeforces."
                    },
                    {
                        "username": "THE_REAL_KBL",
                        "content": "The brute force algorithm works in my case. So you can solve this without using any fance data structure. Just maintain a sorted list containing all added numbers."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, it\\'s a kind of stressful and not quite effective way of practice and learning.\\nAt the beginning, It\\'s better to go to \"Explore\" section and study/practice main basic topics, \"build up you muscles\" in every topic, and then pursue max streaks...\\nAt least this is how I did for myself.\\nGoodluck!"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "its same in my case too i can think of a intuition for a ezy and med level question but if you want to maintain streaks and push your limits then please do it. use you tube use solutions make comments on your own and code it.\\n"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "daily challenges are getting harder and harder ; )"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You basically just need to use a form of binary search to find the relevant range in your list of ranges, then merge with the left or right range if applicable."
                    },
                    {
                        "username": "netheril96",
                        "content": "I'm doing *352. Data Stream as Disjoint Intervals* and get *Output Limit Exceeded* error. But running the test case that throws out this error gives the exact solution as the expected answer. I thought that unlike time limit exceeded or memory limit exceeded, *Output Limit Exceeded* happens only on individual test cases, not cumulatively. Then why would I get this error when the test case passes?"
                    },
                    {
                        "username": "Jai_0710",
                        "content": "i think you have a print statement in your code .... do remove it "
                    },
                    {
                        "username": "powerup7",
                        "content": "Output limit exceeded happens when your output to log overflows."
                    }
                ]
            },
            {
                "id": 1777437,
                "content": [
                    {
                        "username": "lirongbin",
                        "content": "I can not understand the question description, can any one explain it?"
                    },
                    {
                        "username": "santanusen",
                        "content": "The word \"intervals\" is the source of confusion. They meant, summarize \"contiguous numbers\" as intervals. Thus, numbers ```{1, 2, 3, 4, 6, 8, 9}``` will be summarized as ```{[1,4], [6,6], [8,9]}```"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@Maverick767](/Maverick767) mean 1,2,3,4,5 not have any missing number but 1,2,4,6 have 3 and 5 ???"
                    },
                    {
                        "username": "Maverick767",
                        "content": "For anyone doing the daily today and confused by the description, you are basically tasked with merging all consecutive sequences of numbers into a single range. For example, [1,2,3,4,5] would be merged into [1,5]. The range [1,2,4,6] would not be merged entirely as it is not consecutive. In the second case, you would end up with [[1, 2], [4, 4], [6, 6]]"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I want to meet the problem setter who takes joy in withholding such an important piece of information that interval here means a consecutive sequence of numbers, and summary means just the beginning and ending of  that sequence.\\nHow much difficult it is to mention:\\n**A sequence of consecutive numbers `a1, a2, a3 .... an` represents an interval with summary `[a1, an]`**"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Right bro :)"
                    },
                    {
                        "username": "abrahem",
                        "content": "dude ty go paraphrase All leetcode problems "
                    },
                    {
                        "username": "clipper21",
                        "content": "This should be a medium or easy. Explanation is bad too."
                    },
                    {
                        "username": "Det2048",
                        "content": "It\\'s hard because the explanation made it hard."
                    },
                    {
                        "username": "farhaankhanfiroz",
                        "content": "Correct"
                    },
                    {
                        "username": "vin36",
                        "content": "I think an interval in this question is a sequence of consecutive numbers.\nSo in the example where the numbers are: [1, 2, 3, 6, 7]\nThe sequence of consecutive numbers (intervals) are [1,2,3] and [6,7], but we only want the \"summary\": [start, end]. Therefore the intervals are [1,3] and [6,7].\nHope this helps!"
                    },
                    {
                        "username": "0x69ED75",
                        "content": "Man. These questions really need to explain this."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vincent](/MrVinnyLuu) Thanks a lot, I was never going to figure this"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Brute Force solution is accepted."
                    },
                    {
                        "username": "rbarcelos",
                        "content": "I have a C# solution and would like to make sure that it is correct.. could you add a C# code defintion"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "Looking at these hard problems everyday / 2-3 in a week , and graph/heap tree questions makes me want to stop doing this , can\\'t solve most of them , always have to look at solution. \\nI understand that you need to solve hard , but for someone who is forming a practice , its tough. "
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Problem-solving, if not done in a proper order, can demotivate anyone.\nThe daily challenges are not meant for people to learn DSA at all. It is merely there to form a habit of consistency, which is another very important trait for any problem solver.\nThe best way to learn DSA is through Leetcode's Explore cards on all individual Datatype, and if you really are serious about problem-solving then after finishing Leetcode's Explore cards try the A2OJ ladder and try Codeforces."
                    },
                    {
                        "username": "THE_REAL_KBL",
                        "content": "The brute force algorithm works in my case. So you can solve this without using any fance data structure. Just maintain a sorted list containing all added numbers."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, it\\'s a kind of stressful and not quite effective way of practice and learning.\\nAt the beginning, It\\'s better to go to \"Explore\" section and study/practice main basic topics, \"build up you muscles\" in every topic, and then pursue max streaks...\\nAt least this is how I did for myself.\\nGoodluck!"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "its same in my case too i can think of a intuition for a ezy and med level question but if you want to maintain streaks and push your limits then please do it. use you tube use solutions make comments on your own and code it.\\n"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "daily challenges are getting harder and harder ; )"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You basically just need to use a form of binary search to find the relevant range in your list of ranges, then merge with the left or right range if applicable."
                    },
                    {
                        "username": "netheril96",
                        "content": "I'm doing *352. Data Stream as Disjoint Intervals* and get *Output Limit Exceeded* error. But running the test case that throws out this error gives the exact solution as the expected answer. I thought that unlike time limit exceeded or memory limit exceeded, *Output Limit Exceeded* happens only on individual test cases, not cumulatively. Then why would I get this error when the test case passes?"
                    },
                    {
                        "username": "Jai_0710",
                        "content": "i think you have a print statement in your code .... do remove it "
                    },
                    {
                        "username": "powerup7",
                        "content": "Output limit exceeded happens when your output to log overflows."
                    }
                ]
            },
            {
                "id": 1777152,
                "content": [
                    {
                        "username": "lirongbin",
                        "content": "I can not understand the question description, can any one explain it?"
                    },
                    {
                        "username": "santanusen",
                        "content": "The word \"intervals\" is the source of confusion. They meant, summarize \"contiguous numbers\" as intervals. Thus, numbers ```{1, 2, 3, 4, 6, 8, 9}``` will be summarized as ```{[1,4], [6,6], [8,9]}```"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@Maverick767](/Maverick767) mean 1,2,3,4,5 not have any missing number but 1,2,4,6 have 3 and 5 ???"
                    },
                    {
                        "username": "Maverick767",
                        "content": "For anyone doing the daily today and confused by the description, you are basically tasked with merging all consecutive sequences of numbers into a single range. For example, [1,2,3,4,5] would be merged into [1,5]. The range [1,2,4,6] would not be merged entirely as it is not consecutive. In the second case, you would end up with [[1, 2], [4, 4], [6, 6]]"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I want to meet the problem setter who takes joy in withholding such an important piece of information that interval here means a consecutive sequence of numbers, and summary means just the beginning and ending of  that sequence.\\nHow much difficult it is to mention:\\n**A sequence of consecutive numbers `a1, a2, a3 .... an` represents an interval with summary `[a1, an]`**"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Right bro :)"
                    },
                    {
                        "username": "abrahem",
                        "content": "dude ty go paraphrase All leetcode problems "
                    },
                    {
                        "username": "clipper21",
                        "content": "This should be a medium or easy. Explanation is bad too."
                    },
                    {
                        "username": "Det2048",
                        "content": "It\\'s hard because the explanation made it hard."
                    },
                    {
                        "username": "farhaankhanfiroz",
                        "content": "Correct"
                    },
                    {
                        "username": "vin36",
                        "content": "I think an interval in this question is a sequence of consecutive numbers.\nSo in the example where the numbers are: [1, 2, 3, 6, 7]\nThe sequence of consecutive numbers (intervals) are [1,2,3] and [6,7], but we only want the \"summary\": [start, end]. Therefore the intervals are [1,3] and [6,7].\nHope this helps!"
                    },
                    {
                        "username": "0x69ED75",
                        "content": "Man. These questions really need to explain this."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vincent](/MrVinnyLuu) Thanks a lot, I was never going to figure this"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Brute Force solution is accepted."
                    },
                    {
                        "username": "rbarcelos",
                        "content": "I have a C# solution and would like to make sure that it is correct.. could you add a C# code defintion"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "Looking at these hard problems everyday / 2-3 in a week , and graph/heap tree questions makes me want to stop doing this , can\\'t solve most of them , always have to look at solution. \\nI understand that you need to solve hard , but for someone who is forming a practice , its tough. "
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Problem-solving, if not done in a proper order, can demotivate anyone.\nThe daily challenges are not meant for people to learn DSA at all. It is merely there to form a habit of consistency, which is another very important trait for any problem solver.\nThe best way to learn DSA is through Leetcode's Explore cards on all individual Datatype, and if you really are serious about problem-solving then after finishing Leetcode's Explore cards try the A2OJ ladder and try Codeforces."
                    },
                    {
                        "username": "THE_REAL_KBL",
                        "content": "The brute force algorithm works in my case. So you can solve this without using any fance data structure. Just maintain a sorted list containing all added numbers."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, it\\'s a kind of stressful and not quite effective way of practice and learning.\\nAt the beginning, It\\'s better to go to \"Explore\" section and study/practice main basic topics, \"build up you muscles\" in every topic, and then pursue max streaks...\\nAt least this is how I did for myself.\\nGoodluck!"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "its same in my case too i can think of a intuition for a ezy and med level question but if you want to maintain streaks and push your limits then please do it. use you tube use solutions make comments on your own and code it.\\n"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "daily challenges are getting harder and harder ; )"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You basically just need to use a form of binary search to find the relevant range in your list of ranges, then merge with the left or right range if applicable."
                    },
                    {
                        "username": "netheril96",
                        "content": "I'm doing *352. Data Stream as Disjoint Intervals* and get *Output Limit Exceeded* error. But running the test case that throws out this error gives the exact solution as the expected answer. I thought that unlike time limit exceeded or memory limit exceeded, *Output Limit Exceeded* happens only on individual test cases, not cumulatively. Then why would I get this error when the test case passes?"
                    },
                    {
                        "username": "Jai_0710",
                        "content": "i think you have a print statement in your code .... do remove it "
                    },
                    {
                        "username": "powerup7",
                        "content": "Output limit exceeded happens when your output to log overflows."
                    }
                ]
            },
            {
                "id": 1777498,
                "content": [
                    {
                        "username": "lirongbin",
                        "content": "I can not understand the question description, can any one explain it?"
                    },
                    {
                        "username": "santanusen",
                        "content": "The word \"intervals\" is the source of confusion. They meant, summarize \"contiguous numbers\" as intervals. Thus, numbers ```{1, 2, 3, 4, 6, 8, 9}``` will be summarized as ```{[1,4], [6,6], [8,9]}```"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@Maverick767](/Maverick767) mean 1,2,3,4,5 not have any missing number but 1,2,4,6 have 3 and 5 ???"
                    },
                    {
                        "username": "Maverick767",
                        "content": "For anyone doing the daily today and confused by the description, you are basically tasked with merging all consecutive sequences of numbers into a single range. For example, [1,2,3,4,5] would be merged into [1,5]. The range [1,2,4,6] would not be merged entirely as it is not consecutive. In the second case, you would end up with [[1, 2], [4, 4], [6, 6]]"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I want to meet the problem setter who takes joy in withholding such an important piece of information that interval here means a consecutive sequence of numbers, and summary means just the beginning and ending of  that sequence.\\nHow much difficult it is to mention:\\n**A sequence of consecutive numbers `a1, a2, a3 .... an` represents an interval with summary `[a1, an]`**"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Right bro :)"
                    },
                    {
                        "username": "abrahem",
                        "content": "dude ty go paraphrase All leetcode problems "
                    },
                    {
                        "username": "clipper21",
                        "content": "This should be a medium or easy. Explanation is bad too."
                    },
                    {
                        "username": "Det2048",
                        "content": "It\\'s hard because the explanation made it hard."
                    },
                    {
                        "username": "farhaankhanfiroz",
                        "content": "Correct"
                    },
                    {
                        "username": "vin36",
                        "content": "I think an interval in this question is a sequence of consecutive numbers.\nSo in the example where the numbers are: [1, 2, 3, 6, 7]\nThe sequence of consecutive numbers (intervals) are [1,2,3] and [6,7], but we only want the \"summary\": [start, end]. Therefore the intervals are [1,3] and [6,7].\nHope this helps!"
                    },
                    {
                        "username": "0x69ED75",
                        "content": "Man. These questions really need to explain this."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vincent](/MrVinnyLuu) Thanks a lot, I was never going to figure this"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Brute Force solution is accepted."
                    },
                    {
                        "username": "rbarcelos",
                        "content": "I have a C# solution and would like to make sure that it is correct.. could you add a C# code defintion"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "Looking at these hard problems everyday / 2-3 in a week , and graph/heap tree questions makes me want to stop doing this , can\\'t solve most of them , always have to look at solution. \\nI understand that you need to solve hard , but for someone who is forming a practice , its tough. "
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Problem-solving, if not done in a proper order, can demotivate anyone.\nThe daily challenges are not meant for people to learn DSA at all. It is merely there to form a habit of consistency, which is another very important trait for any problem solver.\nThe best way to learn DSA is through Leetcode's Explore cards on all individual Datatype, and if you really are serious about problem-solving then after finishing Leetcode's Explore cards try the A2OJ ladder and try Codeforces."
                    },
                    {
                        "username": "THE_REAL_KBL",
                        "content": "The brute force algorithm works in my case. So you can solve this without using any fance data structure. Just maintain a sorted list containing all added numbers."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, it\\'s a kind of stressful and not quite effective way of practice and learning.\\nAt the beginning, It\\'s better to go to \"Explore\" section and study/practice main basic topics, \"build up you muscles\" in every topic, and then pursue max streaks...\\nAt least this is how I did for myself.\\nGoodluck!"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "its same in my case too i can think of a intuition for a ezy and med level question but if you want to maintain streaks and push your limits then please do it. use you tube use solutions make comments on your own and code it.\\n"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "daily challenges are getting harder and harder ; )"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You basically just need to use a form of binary search to find the relevant range in your list of ranges, then merge with the left or right range if applicable."
                    },
                    {
                        "username": "netheril96",
                        "content": "I'm doing *352. Data Stream as Disjoint Intervals* and get *Output Limit Exceeded* error. But running the test case that throws out this error gives the exact solution as the expected answer. I thought that unlike time limit exceeded or memory limit exceeded, *Output Limit Exceeded* happens only on individual test cases, not cumulatively. Then why would I get this error when the test case passes?"
                    },
                    {
                        "username": "Jai_0710",
                        "content": "i think you have a print statement in your code .... do remove it "
                    },
                    {
                        "username": "powerup7",
                        "content": "Output limit exceeded happens when your output to log overflows."
                    }
                ]
            },
            {
                "id": 1565949,
                "content": [
                    {
                        "username": "lirongbin",
                        "content": "I can not understand the question description, can any one explain it?"
                    },
                    {
                        "username": "santanusen",
                        "content": "The word \"intervals\" is the source of confusion. They meant, summarize \"contiguous numbers\" as intervals. Thus, numbers ```{1, 2, 3, 4, 6, 8, 9}``` will be summarized as ```{[1,4], [6,6], [8,9]}```"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@Maverick767](/Maverick767) mean 1,2,3,4,5 not have any missing number but 1,2,4,6 have 3 and 5 ???"
                    },
                    {
                        "username": "Maverick767",
                        "content": "For anyone doing the daily today and confused by the description, you are basically tasked with merging all consecutive sequences of numbers into a single range. For example, [1,2,3,4,5] would be merged into [1,5]. The range [1,2,4,6] would not be merged entirely as it is not consecutive. In the second case, you would end up with [[1, 2], [4, 4], [6, 6]]"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I want to meet the problem setter who takes joy in withholding such an important piece of information that interval here means a consecutive sequence of numbers, and summary means just the beginning and ending of  that sequence.\\nHow much difficult it is to mention:\\n**A sequence of consecutive numbers `a1, a2, a3 .... an` represents an interval with summary `[a1, an]`**"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Right bro :)"
                    },
                    {
                        "username": "abrahem",
                        "content": "dude ty go paraphrase All leetcode problems "
                    },
                    {
                        "username": "clipper21",
                        "content": "This should be a medium or easy. Explanation is bad too."
                    },
                    {
                        "username": "Det2048",
                        "content": "It\\'s hard because the explanation made it hard."
                    },
                    {
                        "username": "farhaankhanfiroz",
                        "content": "Correct"
                    },
                    {
                        "username": "vin36",
                        "content": "I think an interval in this question is a sequence of consecutive numbers.\nSo in the example where the numbers are: [1, 2, 3, 6, 7]\nThe sequence of consecutive numbers (intervals) are [1,2,3] and [6,7], but we only want the \"summary\": [start, end]. Therefore the intervals are [1,3] and [6,7].\nHope this helps!"
                    },
                    {
                        "username": "0x69ED75",
                        "content": "Man. These questions really need to explain this."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vincent](/MrVinnyLuu) Thanks a lot, I was never going to figure this"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Brute Force solution is accepted."
                    },
                    {
                        "username": "rbarcelos",
                        "content": "I have a C# solution and would like to make sure that it is correct.. could you add a C# code defintion"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "Looking at these hard problems everyday / 2-3 in a week , and graph/heap tree questions makes me want to stop doing this , can\\'t solve most of them , always have to look at solution. \\nI understand that you need to solve hard , but for someone who is forming a practice , its tough. "
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Problem-solving, if not done in a proper order, can demotivate anyone.\nThe daily challenges are not meant for people to learn DSA at all. It is merely there to form a habit of consistency, which is another very important trait for any problem solver.\nThe best way to learn DSA is through Leetcode's Explore cards on all individual Datatype, and if you really are serious about problem-solving then after finishing Leetcode's Explore cards try the A2OJ ladder and try Codeforces."
                    },
                    {
                        "username": "THE_REAL_KBL",
                        "content": "The brute force algorithm works in my case. So you can solve this without using any fance data structure. Just maintain a sorted list containing all added numbers."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, it\\'s a kind of stressful and not quite effective way of practice and learning.\\nAt the beginning, It\\'s better to go to \"Explore\" section and study/practice main basic topics, \"build up you muscles\" in every topic, and then pursue max streaks...\\nAt least this is how I did for myself.\\nGoodluck!"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "its same in my case too i can think of a intuition for a ezy and med level question but if you want to maintain streaks and push your limits then please do it. use you tube use solutions make comments on your own and code it.\\n"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "daily challenges are getting harder and harder ; )"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You basically just need to use a form of binary search to find the relevant range in your list of ranges, then merge with the left or right range if applicable."
                    },
                    {
                        "username": "netheril96",
                        "content": "I'm doing *352. Data Stream as Disjoint Intervals* and get *Output Limit Exceeded* error. But running the test case that throws out this error gives the exact solution as the expected answer. I thought that unlike time limit exceeded or memory limit exceeded, *Output Limit Exceeded* happens only on individual test cases, not cumulatively. Then why would I get this error when the test case passes?"
                    },
                    {
                        "username": "Jai_0710",
                        "content": "i think you have a print statement in your code .... do remove it "
                    },
                    {
                        "username": "powerup7",
                        "content": "Output limit exceeded happens when your output to log overflows."
                    }
                ]
            },
            {
                "id": 1777457,
                "content": [
                    {
                        "username": "lirongbin",
                        "content": "I can not understand the question description, can any one explain it?"
                    },
                    {
                        "username": "santanusen",
                        "content": "The word \"intervals\" is the source of confusion. They meant, summarize \"contiguous numbers\" as intervals. Thus, numbers ```{1, 2, 3, 4, 6, 8, 9}``` will be summarized as ```{[1,4], [6,6], [8,9]}```"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@Maverick767](/Maverick767) mean 1,2,3,4,5 not have any missing number but 1,2,4,6 have 3 and 5 ???"
                    },
                    {
                        "username": "Maverick767",
                        "content": "For anyone doing the daily today and confused by the description, you are basically tasked with merging all consecutive sequences of numbers into a single range. For example, [1,2,3,4,5] would be merged into [1,5]. The range [1,2,4,6] would not be merged entirely as it is not consecutive. In the second case, you would end up with [[1, 2], [4, 4], [6, 6]]"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I want to meet the problem setter who takes joy in withholding such an important piece of information that interval here means a consecutive sequence of numbers, and summary means just the beginning and ending of  that sequence.\\nHow much difficult it is to mention:\\n**A sequence of consecutive numbers `a1, a2, a3 .... an` represents an interval with summary `[a1, an]`**"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Right bro :)"
                    },
                    {
                        "username": "abrahem",
                        "content": "dude ty go paraphrase All leetcode problems "
                    },
                    {
                        "username": "clipper21",
                        "content": "This should be a medium or easy. Explanation is bad too."
                    },
                    {
                        "username": "Det2048",
                        "content": "It\\'s hard because the explanation made it hard."
                    },
                    {
                        "username": "farhaankhanfiroz",
                        "content": "Correct"
                    },
                    {
                        "username": "vin36",
                        "content": "I think an interval in this question is a sequence of consecutive numbers.\nSo in the example where the numbers are: [1, 2, 3, 6, 7]\nThe sequence of consecutive numbers (intervals) are [1,2,3] and [6,7], but we only want the \"summary\": [start, end]. Therefore the intervals are [1,3] and [6,7].\nHope this helps!"
                    },
                    {
                        "username": "0x69ED75",
                        "content": "Man. These questions really need to explain this."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vincent](/MrVinnyLuu) Thanks a lot, I was never going to figure this"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Brute Force solution is accepted."
                    },
                    {
                        "username": "rbarcelos",
                        "content": "I have a C# solution and would like to make sure that it is correct.. could you add a C# code defintion"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "Looking at these hard problems everyday / 2-3 in a week , and graph/heap tree questions makes me want to stop doing this , can\\'t solve most of them , always have to look at solution. \\nI understand that you need to solve hard , but for someone who is forming a practice , its tough. "
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Problem-solving, if not done in a proper order, can demotivate anyone.\nThe daily challenges are not meant for people to learn DSA at all. It is merely there to form a habit of consistency, which is another very important trait for any problem solver.\nThe best way to learn DSA is through Leetcode's Explore cards on all individual Datatype, and if you really are serious about problem-solving then after finishing Leetcode's Explore cards try the A2OJ ladder and try Codeforces."
                    },
                    {
                        "username": "THE_REAL_KBL",
                        "content": "The brute force algorithm works in my case. So you can solve this without using any fance data structure. Just maintain a sorted list containing all added numbers."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, it\\'s a kind of stressful and not quite effective way of practice and learning.\\nAt the beginning, It\\'s better to go to \"Explore\" section and study/practice main basic topics, \"build up you muscles\" in every topic, and then pursue max streaks...\\nAt least this is how I did for myself.\\nGoodluck!"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "its same in my case too i can think of a intuition for a ezy and med level question but if you want to maintain streaks and push your limits then please do it. use you tube use solutions make comments on your own and code it.\\n"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "daily challenges are getting harder and harder ; )"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You basically just need to use a form of binary search to find the relevant range in your list of ranges, then merge with the left or right range if applicable."
                    },
                    {
                        "username": "netheril96",
                        "content": "I'm doing *352. Data Stream as Disjoint Intervals* and get *Output Limit Exceeded* error. But running the test case that throws out this error gives the exact solution as the expected answer. I thought that unlike time limit exceeded or memory limit exceeded, *Output Limit Exceeded* happens only on individual test cases, not cumulatively. Then why would I get this error when the test case passes?"
                    },
                    {
                        "username": "Jai_0710",
                        "content": "i think you have a print statement in your code .... do remove it "
                    },
                    {
                        "username": "powerup7",
                        "content": "Output limit exceeded happens when your output to log overflows."
                    }
                ]
            },
            {
                "id": 1777492,
                "content": [
                    {
                        "username": "lirongbin",
                        "content": "I can not understand the question description, can any one explain it?"
                    },
                    {
                        "username": "santanusen",
                        "content": "The word \"intervals\" is the source of confusion. They meant, summarize \"contiguous numbers\" as intervals. Thus, numbers ```{1, 2, 3, 4, 6, 8, 9}``` will be summarized as ```{[1,4], [6,6], [8,9]}```"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@Maverick767](/Maverick767) mean 1,2,3,4,5 not have any missing number but 1,2,4,6 have 3 and 5 ???"
                    },
                    {
                        "username": "Maverick767",
                        "content": "For anyone doing the daily today and confused by the description, you are basically tasked with merging all consecutive sequences of numbers into a single range. For example, [1,2,3,4,5] would be merged into [1,5]. The range [1,2,4,6] would not be merged entirely as it is not consecutive. In the second case, you would end up with [[1, 2], [4, 4], [6, 6]]"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I want to meet the problem setter who takes joy in withholding such an important piece of information that interval here means a consecutive sequence of numbers, and summary means just the beginning and ending of  that sequence.\\nHow much difficult it is to mention:\\n**A sequence of consecutive numbers `a1, a2, a3 .... an` represents an interval with summary `[a1, an]`**"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Right bro :)"
                    },
                    {
                        "username": "abrahem",
                        "content": "dude ty go paraphrase All leetcode problems "
                    },
                    {
                        "username": "clipper21",
                        "content": "This should be a medium or easy. Explanation is bad too."
                    },
                    {
                        "username": "Det2048",
                        "content": "It\\'s hard because the explanation made it hard."
                    },
                    {
                        "username": "farhaankhanfiroz",
                        "content": "Correct"
                    },
                    {
                        "username": "vin36",
                        "content": "I think an interval in this question is a sequence of consecutive numbers.\nSo in the example where the numbers are: [1, 2, 3, 6, 7]\nThe sequence of consecutive numbers (intervals) are [1,2,3] and [6,7], but we only want the \"summary\": [start, end]. Therefore the intervals are [1,3] and [6,7].\nHope this helps!"
                    },
                    {
                        "username": "0x69ED75",
                        "content": "Man. These questions really need to explain this."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vincent](/MrVinnyLuu) Thanks a lot, I was never going to figure this"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Brute Force solution is accepted."
                    },
                    {
                        "username": "rbarcelos",
                        "content": "I have a C# solution and would like to make sure that it is correct.. could you add a C# code defintion"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "Looking at these hard problems everyday / 2-3 in a week , and graph/heap tree questions makes me want to stop doing this , can\\'t solve most of them , always have to look at solution. \\nI understand that you need to solve hard , but for someone who is forming a practice , its tough. "
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Problem-solving, if not done in a proper order, can demotivate anyone.\nThe daily challenges are not meant for people to learn DSA at all. It is merely there to form a habit of consistency, which is another very important trait for any problem solver.\nThe best way to learn DSA is through Leetcode's Explore cards on all individual Datatype, and if you really are serious about problem-solving then after finishing Leetcode's Explore cards try the A2OJ ladder and try Codeforces."
                    },
                    {
                        "username": "THE_REAL_KBL",
                        "content": "The brute force algorithm works in my case. So you can solve this without using any fance data structure. Just maintain a sorted list containing all added numbers."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, it\\'s a kind of stressful and not quite effective way of practice and learning.\\nAt the beginning, It\\'s better to go to \"Explore\" section and study/practice main basic topics, \"build up you muscles\" in every topic, and then pursue max streaks...\\nAt least this is how I did for myself.\\nGoodluck!"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "its same in my case too i can think of a intuition for a ezy and med level question but if you want to maintain streaks and push your limits then please do it. use you tube use solutions make comments on your own and code it.\\n"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "daily challenges are getting harder and harder ; )"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You basically just need to use a form of binary search to find the relevant range in your list of ranges, then merge with the left or right range if applicable."
                    },
                    {
                        "username": "netheril96",
                        "content": "I'm doing *352. Data Stream as Disjoint Intervals* and get *Output Limit Exceeded* error. But running the test case that throws out this error gives the exact solution as the expected answer. I thought that unlike time limit exceeded or memory limit exceeded, *Output Limit Exceeded* happens only on individual test cases, not cumulatively. Then why would I get this error when the test case passes?"
                    },
                    {
                        "username": "Jai_0710",
                        "content": "i think you have a print statement in your code .... do remove it "
                    },
                    {
                        "username": "powerup7",
                        "content": "Output limit exceeded happens when your output to log overflows."
                    }
                ]
            },
            {
                "id": 1777186,
                "content": [
                    {
                        "username": "lirongbin",
                        "content": "I can not understand the question description, can any one explain it?"
                    },
                    {
                        "username": "santanusen",
                        "content": "The word \"intervals\" is the source of confusion. They meant, summarize \"contiguous numbers\" as intervals. Thus, numbers ```{1, 2, 3, 4, 6, 8, 9}``` will be summarized as ```{[1,4], [6,6], [8,9]}```"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@Maverick767](/Maverick767) mean 1,2,3,4,5 not have any missing number but 1,2,4,6 have 3 and 5 ???"
                    },
                    {
                        "username": "Maverick767",
                        "content": "For anyone doing the daily today and confused by the description, you are basically tasked with merging all consecutive sequences of numbers into a single range. For example, [1,2,3,4,5] would be merged into [1,5]. The range [1,2,4,6] would not be merged entirely as it is not consecutive. In the second case, you would end up with [[1, 2], [4, 4], [6, 6]]"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I want to meet the problem setter who takes joy in withholding such an important piece of information that interval here means a consecutive sequence of numbers, and summary means just the beginning and ending of  that sequence.\\nHow much difficult it is to mention:\\n**A sequence of consecutive numbers `a1, a2, a3 .... an` represents an interval with summary `[a1, an]`**"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Right bro :)"
                    },
                    {
                        "username": "abrahem",
                        "content": "dude ty go paraphrase All leetcode problems "
                    },
                    {
                        "username": "clipper21",
                        "content": "This should be a medium or easy. Explanation is bad too."
                    },
                    {
                        "username": "Det2048",
                        "content": "It\\'s hard because the explanation made it hard."
                    },
                    {
                        "username": "farhaankhanfiroz",
                        "content": "Correct"
                    },
                    {
                        "username": "vin36",
                        "content": "I think an interval in this question is a sequence of consecutive numbers.\nSo in the example where the numbers are: [1, 2, 3, 6, 7]\nThe sequence of consecutive numbers (intervals) are [1,2,3] and [6,7], but we only want the \"summary\": [start, end]. Therefore the intervals are [1,3] and [6,7].\nHope this helps!"
                    },
                    {
                        "username": "0x69ED75",
                        "content": "Man. These questions really need to explain this."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vincent](/MrVinnyLuu) Thanks a lot, I was never going to figure this"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Brute Force solution is accepted."
                    },
                    {
                        "username": "rbarcelos",
                        "content": "I have a C# solution and would like to make sure that it is correct.. could you add a C# code defintion"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "Looking at these hard problems everyday / 2-3 in a week , and graph/heap tree questions makes me want to stop doing this , can\\'t solve most of them , always have to look at solution. \\nI understand that you need to solve hard , but for someone who is forming a practice , its tough. "
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Problem-solving, if not done in a proper order, can demotivate anyone.\nThe daily challenges are not meant for people to learn DSA at all. It is merely there to form a habit of consistency, which is another very important trait for any problem solver.\nThe best way to learn DSA is through Leetcode's Explore cards on all individual Datatype, and if you really are serious about problem-solving then after finishing Leetcode's Explore cards try the A2OJ ladder and try Codeforces."
                    },
                    {
                        "username": "THE_REAL_KBL",
                        "content": "The brute force algorithm works in my case. So you can solve this without using any fance data structure. Just maintain a sorted list containing all added numbers."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, it\\'s a kind of stressful and not quite effective way of practice and learning.\\nAt the beginning, It\\'s better to go to \"Explore\" section and study/practice main basic topics, \"build up you muscles\" in every topic, and then pursue max streaks...\\nAt least this is how I did for myself.\\nGoodluck!"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "its same in my case too i can think of a intuition for a ezy and med level question but if you want to maintain streaks and push your limits then please do it. use you tube use solutions make comments on your own and code it.\\n"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "daily challenges are getting harder and harder ; )"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You basically just need to use a form of binary search to find the relevant range in your list of ranges, then merge with the left or right range if applicable."
                    },
                    {
                        "username": "netheril96",
                        "content": "I'm doing *352. Data Stream as Disjoint Intervals* and get *Output Limit Exceeded* error. But running the test case that throws out this error gives the exact solution as the expected answer. I thought that unlike time limit exceeded or memory limit exceeded, *Output Limit Exceeded* happens only on individual test cases, not cumulatively. Then why would I get this error when the test case passes?"
                    },
                    {
                        "username": "Jai_0710",
                        "content": "i think you have a print statement in your code .... do remove it "
                    },
                    {
                        "username": "powerup7",
                        "content": "Output limit exceeded happens when your output to log overflows."
                    }
                ]
            },
            {
                "id": 1569094,
                "content": [
                    {
                        "username": "lirongbin",
                        "content": "I can not understand the question description, can any one explain it?"
                    },
                    {
                        "username": "santanusen",
                        "content": "The word \"intervals\" is the source of confusion. They meant, summarize \"contiguous numbers\" as intervals. Thus, numbers ```{1, 2, 3, 4, 6, 8, 9}``` will be summarized as ```{[1,4], [6,6], [8,9]}```"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@Maverick767](/Maverick767) mean 1,2,3,4,5 not have any missing number but 1,2,4,6 have 3 and 5 ???"
                    },
                    {
                        "username": "Maverick767",
                        "content": "For anyone doing the daily today and confused by the description, you are basically tasked with merging all consecutive sequences of numbers into a single range. For example, [1,2,3,4,5] would be merged into [1,5]. The range [1,2,4,6] would not be merged entirely as it is not consecutive. In the second case, you would end up with [[1, 2], [4, 4], [6, 6]]"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I want to meet the problem setter who takes joy in withholding such an important piece of information that interval here means a consecutive sequence of numbers, and summary means just the beginning and ending of  that sequence.\\nHow much difficult it is to mention:\\n**A sequence of consecutive numbers `a1, a2, a3 .... an` represents an interval with summary `[a1, an]`**"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Right bro :)"
                    },
                    {
                        "username": "abrahem",
                        "content": "dude ty go paraphrase All leetcode problems "
                    },
                    {
                        "username": "clipper21",
                        "content": "This should be a medium or easy. Explanation is bad too."
                    },
                    {
                        "username": "Det2048",
                        "content": "It\\'s hard because the explanation made it hard."
                    },
                    {
                        "username": "farhaankhanfiroz",
                        "content": "Correct"
                    },
                    {
                        "username": "vin36",
                        "content": "I think an interval in this question is a sequence of consecutive numbers.\nSo in the example where the numbers are: [1, 2, 3, 6, 7]\nThe sequence of consecutive numbers (intervals) are [1,2,3] and [6,7], but we only want the \"summary\": [start, end]. Therefore the intervals are [1,3] and [6,7].\nHope this helps!"
                    },
                    {
                        "username": "0x69ED75",
                        "content": "Man. These questions really need to explain this."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vincent](/MrVinnyLuu) Thanks a lot, I was never going to figure this"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Brute Force solution is accepted."
                    },
                    {
                        "username": "rbarcelos",
                        "content": "I have a C# solution and would like to make sure that it is correct.. could you add a C# code defintion"
                    },
                    {
                        "username": "HereForLearning_JS",
                        "content": "Looking at these hard problems everyday / 2-3 in a week , and graph/heap tree questions makes me want to stop doing this , can\\'t solve most of them , always have to look at solution. \\nI understand that you need to solve hard , but for someone who is forming a practice , its tough. "
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Problem-solving, if not done in a proper order, can demotivate anyone.\nThe daily challenges are not meant for people to learn DSA at all. It is merely there to form a habit of consistency, which is another very important trait for any problem solver.\nThe best way to learn DSA is through Leetcode's Explore cards on all individual Datatype, and if you really are serious about problem-solving then after finishing Leetcode's Explore cards try the A2OJ ladder and try Codeforces."
                    },
                    {
                        "username": "THE_REAL_KBL",
                        "content": "The brute force algorithm works in my case. So you can solve this without using any fance data structure. Just maintain a sorted list containing all added numbers."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, it\\'s a kind of stressful and not quite effective way of practice and learning.\\nAt the beginning, It\\'s better to go to \"Explore\" section and study/practice main basic topics, \"build up you muscles\" in every topic, and then pursue max streaks...\\nAt least this is how I did for myself.\\nGoodluck!"
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "its same in my case too i can think of a intuition for a ezy and med level question but if you want to maintain streaks and push your limits then please do it. use you tube use solutions make comments on your own and code it.\\n"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "daily challenges are getting harder and harder ; )"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You basically just need to use a form of binary search to find the relevant range in your list of ranges, then merge with the left or right range if applicable."
                    },
                    {
                        "username": "netheril96",
                        "content": "I'm doing *352. Data Stream as Disjoint Intervals* and get *Output Limit Exceeded* error. But running the test case that throws out this error gives the exact solution as the expected answer. I thought that unlike time limit exceeded or memory limit exceeded, *Output Limit Exceeded* happens only on individual test cases, not cumulatively. Then why would I get this error when the test case passes?"
                    },
                    {
                        "username": "Jai_0710",
                        "content": "i think you have a print statement in your code .... do remove it "
                    },
                    {
                        "username": "powerup7",
                        "content": "Output limit exceeded happens when your output to log overflows."
                    }
                ]
            },
            {
                "id": 1777638,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "what a worst description."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Wow! This should be marked as Easy."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "Can anyone drop a explaination video (YouTube) link of this problem, using C++.\\nThanks in advance."
                    },
                    {
                        "username": "arghyadas",
                        "content": "What is the use of the string array?"
                    },
                    {
                        "username": "MitchellHe",
                        "content": "Does anybody have any idea about the follow up?"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Value range is [0,10000] should be helpful.\\nBut checkout reasoning here though..\\n\\nhttps://leetcode.com/problems/data-stream-as-disjoint-intervals/discussion/comments/1777390"
                    },
                    {
                        "username": "tgli",
                        "content": "what's the class definition of Interval ????"
                    },
                    {
                        "username": "c410n",
                        "content": "Hi Team,\\nCould someone please explain me the task?"
                    },
                    {
                        "username": "colins",
                        "content": "Can someone give me an example why is my solution wrong: @\\n```class SummaryRanges {\\n    private TreeMap<Integer, Integer> intervals;\\n\\n    public SummaryRanges() {\\n        intervals = new TreeMap<>(); \\n    }\\n    \\n    public void addNum(int value) {\\n        Map.Entry<Integer, Integer> lowerEntry = intervals.lowerEntry(value); \\n        int left = value, right = value;\\n        if(lowerEntry==null){\\n            if(intervals.get(value)!=null&& intervals.get(value)>=value)return;\\n        }\\n        else {\\n            int previous = lowerEntry.getValue();\\n            if (previous >= value) {\\n                return;\\n            }\\n            if (previous == value - 1) {\\n                left = lowerEntry.getKey();\\n            }\\n        }\\n        Map.Entry<Integer, Integer> maxEntry = intervals.higherEntry(value); \\n        if (maxEntry != null && maxEntry.getKey() == value + 1) {\\n            right = maxEntry.getValue();\\n            intervals.remove(value + 1);\\n        }\\n        intervals.put(left, right);\\n    }\\n    \\n    public int[][] getIntervals() {\\n        final int[][] answer = new int[intervals.size()][2];\\n        int ind = 0;\\n        for (Map.Entry<Integer, Integer> entry : intervals.entrySet()) {\\n            answer[ind][0] = entry.getKey();\\n            answer[ind++][1] = entry.getValue();\\n        }\\n        return answer; \\n    }\\n}```"
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "I am not able to figure out where I am makig a mistake. Any help is appreciated !!\\n```\\nclass SummaryRanges {\\n    function<bool(vector<int>, vector<int>)> comp = [&](const vector<int> &a, const vector<int> &b) {\\n        return a[0] < b[0];\\n    };\\n    set<vector<int>, decltype(comp)> intervals;\\npublic:\\n    SummaryRanges() {\\n        intervals = set<vector<int>, decltype(comp)>(comp);\\n    }\\n    \\n    void addNum(int value) {\\n        vector<int> interval = {value, value};\\n        set<vector<int>>::iterator first = intervals.lower_bound({value + 1, value + 1});\\n        set<vector<int>>::iterator second = intervals.lower_bound({value - 1, value - 1});\\n        bool same = first == second;\\n        \\n        if(first != intervals.end() && (*first)[0] < value && (*first)[1] > value) return;\\n        if(second != intervals.end() && (*second)[0] < value && (*second)[1] > value) return;\\n\\n        if(first != intervals.end() && (*first)[0] == value+1) {\\n            interval[1] = (*first)[1];   \\n            intervals.erase(first);\\n        }\\n        if(!same && second != intervals.end() && (*second)[1] == value-1) {\\n            interval[0] = (*second)[0];\\n            intervals.erase(second);\\n        }\\n        intervals.insert(interval);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> res;\\n        for(vector<int> it: intervals) {\\n            res.push_back(it);\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Why every time I solve the hard problem by myself, people write that it is actually not a hard problem? :D"
                    }
                ]
            },
            {
                "id": 1777537,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "what a worst description."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Wow! This should be marked as Easy."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "Can anyone drop a explaination video (YouTube) link of this problem, using C++.\\nThanks in advance."
                    },
                    {
                        "username": "arghyadas",
                        "content": "What is the use of the string array?"
                    },
                    {
                        "username": "MitchellHe",
                        "content": "Does anybody have any idea about the follow up?"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Value range is [0,10000] should be helpful.\\nBut checkout reasoning here though..\\n\\nhttps://leetcode.com/problems/data-stream-as-disjoint-intervals/discussion/comments/1777390"
                    },
                    {
                        "username": "tgli",
                        "content": "what's the class definition of Interval ????"
                    },
                    {
                        "username": "c410n",
                        "content": "Hi Team,\\nCould someone please explain me the task?"
                    },
                    {
                        "username": "colins",
                        "content": "Can someone give me an example why is my solution wrong: @\\n```class SummaryRanges {\\n    private TreeMap<Integer, Integer> intervals;\\n\\n    public SummaryRanges() {\\n        intervals = new TreeMap<>(); \\n    }\\n    \\n    public void addNum(int value) {\\n        Map.Entry<Integer, Integer> lowerEntry = intervals.lowerEntry(value); \\n        int left = value, right = value;\\n        if(lowerEntry==null){\\n            if(intervals.get(value)!=null&& intervals.get(value)>=value)return;\\n        }\\n        else {\\n            int previous = lowerEntry.getValue();\\n            if (previous >= value) {\\n                return;\\n            }\\n            if (previous == value - 1) {\\n                left = lowerEntry.getKey();\\n            }\\n        }\\n        Map.Entry<Integer, Integer> maxEntry = intervals.higherEntry(value); \\n        if (maxEntry != null && maxEntry.getKey() == value + 1) {\\n            right = maxEntry.getValue();\\n            intervals.remove(value + 1);\\n        }\\n        intervals.put(left, right);\\n    }\\n    \\n    public int[][] getIntervals() {\\n        final int[][] answer = new int[intervals.size()][2];\\n        int ind = 0;\\n        for (Map.Entry<Integer, Integer> entry : intervals.entrySet()) {\\n            answer[ind][0] = entry.getKey();\\n            answer[ind++][1] = entry.getValue();\\n        }\\n        return answer; \\n    }\\n}```"
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "I am not able to figure out where I am makig a mistake. Any help is appreciated !!\\n```\\nclass SummaryRanges {\\n    function<bool(vector<int>, vector<int>)> comp = [&](const vector<int> &a, const vector<int> &b) {\\n        return a[0] < b[0];\\n    };\\n    set<vector<int>, decltype(comp)> intervals;\\npublic:\\n    SummaryRanges() {\\n        intervals = set<vector<int>, decltype(comp)>(comp);\\n    }\\n    \\n    void addNum(int value) {\\n        vector<int> interval = {value, value};\\n        set<vector<int>>::iterator first = intervals.lower_bound({value + 1, value + 1});\\n        set<vector<int>>::iterator second = intervals.lower_bound({value - 1, value - 1});\\n        bool same = first == second;\\n        \\n        if(first != intervals.end() && (*first)[0] < value && (*first)[1] > value) return;\\n        if(second != intervals.end() && (*second)[0] < value && (*second)[1] > value) return;\\n\\n        if(first != intervals.end() && (*first)[0] == value+1) {\\n            interval[1] = (*first)[1];   \\n            intervals.erase(first);\\n        }\\n        if(!same && second != intervals.end() && (*second)[1] == value-1) {\\n            interval[0] = (*second)[0];\\n            intervals.erase(second);\\n        }\\n        intervals.insert(interval);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> res;\\n        for(vector<int> it: intervals) {\\n            res.push_back(it);\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Why every time I solve the hard problem by myself, people write that it is actually not a hard problem? :D"
                    }
                ]
            },
            {
                "id": 1777300,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "what a worst description."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Wow! This should be marked as Easy."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "Can anyone drop a explaination video (YouTube) link of this problem, using C++.\\nThanks in advance."
                    },
                    {
                        "username": "arghyadas",
                        "content": "What is the use of the string array?"
                    },
                    {
                        "username": "MitchellHe",
                        "content": "Does anybody have any idea about the follow up?"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Value range is [0,10000] should be helpful.\\nBut checkout reasoning here though..\\n\\nhttps://leetcode.com/problems/data-stream-as-disjoint-intervals/discussion/comments/1777390"
                    },
                    {
                        "username": "tgli",
                        "content": "what's the class definition of Interval ????"
                    },
                    {
                        "username": "c410n",
                        "content": "Hi Team,\\nCould someone please explain me the task?"
                    },
                    {
                        "username": "colins",
                        "content": "Can someone give me an example why is my solution wrong: @\\n```class SummaryRanges {\\n    private TreeMap<Integer, Integer> intervals;\\n\\n    public SummaryRanges() {\\n        intervals = new TreeMap<>(); \\n    }\\n    \\n    public void addNum(int value) {\\n        Map.Entry<Integer, Integer> lowerEntry = intervals.lowerEntry(value); \\n        int left = value, right = value;\\n        if(lowerEntry==null){\\n            if(intervals.get(value)!=null&& intervals.get(value)>=value)return;\\n        }\\n        else {\\n            int previous = lowerEntry.getValue();\\n            if (previous >= value) {\\n                return;\\n            }\\n            if (previous == value - 1) {\\n                left = lowerEntry.getKey();\\n            }\\n        }\\n        Map.Entry<Integer, Integer> maxEntry = intervals.higherEntry(value); \\n        if (maxEntry != null && maxEntry.getKey() == value + 1) {\\n            right = maxEntry.getValue();\\n            intervals.remove(value + 1);\\n        }\\n        intervals.put(left, right);\\n    }\\n    \\n    public int[][] getIntervals() {\\n        final int[][] answer = new int[intervals.size()][2];\\n        int ind = 0;\\n        for (Map.Entry<Integer, Integer> entry : intervals.entrySet()) {\\n            answer[ind][0] = entry.getKey();\\n            answer[ind++][1] = entry.getValue();\\n        }\\n        return answer; \\n    }\\n}```"
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "I am not able to figure out where I am makig a mistake. Any help is appreciated !!\\n```\\nclass SummaryRanges {\\n    function<bool(vector<int>, vector<int>)> comp = [&](const vector<int> &a, const vector<int> &b) {\\n        return a[0] < b[0];\\n    };\\n    set<vector<int>, decltype(comp)> intervals;\\npublic:\\n    SummaryRanges() {\\n        intervals = set<vector<int>, decltype(comp)>(comp);\\n    }\\n    \\n    void addNum(int value) {\\n        vector<int> interval = {value, value};\\n        set<vector<int>>::iterator first = intervals.lower_bound({value + 1, value + 1});\\n        set<vector<int>>::iterator second = intervals.lower_bound({value - 1, value - 1});\\n        bool same = first == second;\\n        \\n        if(first != intervals.end() && (*first)[0] < value && (*first)[1] > value) return;\\n        if(second != intervals.end() && (*second)[0] < value && (*second)[1] > value) return;\\n\\n        if(first != intervals.end() && (*first)[0] == value+1) {\\n            interval[1] = (*first)[1];   \\n            intervals.erase(first);\\n        }\\n        if(!same && second != intervals.end() && (*second)[1] == value-1) {\\n            interval[0] = (*second)[0];\\n            intervals.erase(second);\\n        }\\n        intervals.insert(interval);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> res;\\n        for(vector<int> it: intervals) {\\n            res.push_back(it);\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Why every time I solve the hard problem by myself, people write that it is actually not a hard problem? :D"
                    }
                ]
            },
            {
                "id": 1777282,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "what a worst description."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Wow! This should be marked as Easy."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "Can anyone drop a explaination video (YouTube) link of this problem, using C++.\\nThanks in advance."
                    },
                    {
                        "username": "arghyadas",
                        "content": "What is the use of the string array?"
                    },
                    {
                        "username": "MitchellHe",
                        "content": "Does anybody have any idea about the follow up?"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Value range is [0,10000] should be helpful.\\nBut checkout reasoning here though..\\n\\nhttps://leetcode.com/problems/data-stream-as-disjoint-intervals/discussion/comments/1777390"
                    },
                    {
                        "username": "tgli",
                        "content": "what's the class definition of Interval ????"
                    },
                    {
                        "username": "c410n",
                        "content": "Hi Team,\\nCould someone please explain me the task?"
                    },
                    {
                        "username": "colins",
                        "content": "Can someone give me an example why is my solution wrong: @\\n```class SummaryRanges {\\n    private TreeMap<Integer, Integer> intervals;\\n\\n    public SummaryRanges() {\\n        intervals = new TreeMap<>(); \\n    }\\n    \\n    public void addNum(int value) {\\n        Map.Entry<Integer, Integer> lowerEntry = intervals.lowerEntry(value); \\n        int left = value, right = value;\\n        if(lowerEntry==null){\\n            if(intervals.get(value)!=null&& intervals.get(value)>=value)return;\\n        }\\n        else {\\n            int previous = lowerEntry.getValue();\\n            if (previous >= value) {\\n                return;\\n            }\\n            if (previous == value - 1) {\\n                left = lowerEntry.getKey();\\n            }\\n        }\\n        Map.Entry<Integer, Integer> maxEntry = intervals.higherEntry(value); \\n        if (maxEntry != null && maxEntry.getKey() == value + 1) {\\n            right = maxEntry.getValue();\\n            intervals.remove(value + 1);\\n        }\\n        intervals.put(left, right);\\n    }\\n    \\n    public int[][] getIntervals() {\\n        final int[][] answer = new int[intervals.size()][2];\\n        int ind = 0;\\n        for (Map.Entry<Integer, Integer> entry : intervals.entrySet()) {\\n            answer[ind][0] = entry.getKey();\\n            answer[ind++][1] = entry.getValue();\\n        }\\n        return answer; \\n    }\\n}```"
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "I am not able to figure out where I am makig a mistake. Any help is appreciated !!\\n```\\nclass SummaryRanges {\\n    function<bool(vector<int>, vector<int>)> comp = [&](const vector<int> &a, const vector<int> &b) {\\n        return a[0] < b[0];\\n    };\\n    set<vector<int>, decltype(comp)> intervals;\\npublic:\\n    SummaryRanges() {\\n        intervals = set<vector<int>, decltype(comp)>(comp);\\n    }\\n    \\n    void addNum(int value) {\\n        vector<int> interval = {value, value};\\n        set<vector<int>>::iterator first = intervals.lower_bound({value + 1, value + 1});\\n        set<vector<int>>::iterator second = intervals.lower_bound({value - 1, value - 1});\\n        bool same = first == second;\\n        \\n        if(first != intervals.end() && (*first)[0] < value && (*first)[1] > value) return;\\n        if(second != intervals.end() && (*second)[0] < value && (*second)[1] > value) return;\\n\\n        if(first != intervals.end() && (*first)[0] == value+1) {\\n            interval[1] = (*first)[1];   \\n            intervals.erase(first);\\n        }\\n        if(!same && second != intervals.end() && (*second)[1] == value-1) {\\n            interval[0] = (*second)[0];\\n            intervals.erase(second);\\n        }\\n        intervals.insert(interval);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> res;\\n        for(vector<int> it: intervals) {\\n            res.push_back(it);\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Why every time I solve the hard problem by myself, people write that it is actually not a hard problem? :D"
                    }
                ]
            },
            {
                "id": 1571627,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "what a worst description."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Wow! This should be marked as Easy."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "Can anyone drop a explaination video (YouTube) link of this problem, using C++.\\nThanks in advance."
                    },
                    {
                        "username": "arghyadas",
                        "content": "What is the use of the string array?"
                    },
                    {
                        "username": "MitchellHe",
                        "content": "Does anybody have any idea about the follow up?"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Value range is [0,10000] should be helpful.\\nBut checkout reasoning here though..\\n\\nhttps://leetcode.com/problems/data-stream-as-disjoint-intervals/discussion/comments/1777390"
                    },
                    {
                        "username": "tgli",
                        "content": "what's the class definition of Interval ????"
                    },
                    {
                        "username": "c410n",
                        "content": "Hi Team,\\nCould someone please explain me the task?"
                    },
                    {
                        "username": "colins",
                        "content": "Can someone give me an example why is my solution wrong: @\\n```class SummaryRanges {\\n    private TreeMap<Integer, Integer> intervals;\\n\\n    public SummaryRanges() {\\n        intervals = new TreeMap<>(); \\n    }\\n    \\n    public void addNum(int value) {\\n        Map.Entry<Integer, Integer> lowerEntry = intervals.lowerEntry(value); \\n        int left = value, right = value;\\n        if(lowerEntry==null){\\n            if(intervals.get(value)!=null&& intervals.get(value)>=value)return;\\n        }\\n        else {\\n            int previous = lowerEntry.getValue();\\n            if (previous >= value) {\\n                return;\\n            }\\n            if (previous == value - 1) {\\n                left = lowerEntry.getKey();\\n            }\\n        }\\n        Map.Entry<Integer, Integer> maxEntry = intervals.higherEntry(value); \\n        if (maxEntry != null && maxEntry.getKey() == value + 1) {\\n            right = maxEntry.getValue();\\n            intervals.remove(value + 1);\\n        }\\n        intervals.put(left, right);\\n    }\\n    \\n    public int[][] getIntervals() {\\n        final int[][] answer = new int[intervals.size()][2];\\n        int ind = 0;\\n        for (Map.Entry<Integer, Integer> entry : intervals.entrySet()) {\\n            answer[ind][0] = entry.getKey();\\n            answer[ind++][1] = entry.getValue();\\n        }\\n        return answer; \\n    }\\n}```"
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "I am not able to figure out where I am makig a mistake. Any help is appreciated !!\\n```\\nclass SummaryRanges {\\n    function<bool(vector<int>, vector<int>)> comp = [&](const vector<int> &a, const vector<int> &b) {\\n        return a[0] < b[0];\\n    };\\n    set<vector<int>, decltype(comp)> intervals;\\npublic:\\n    SummaryRanges() {\\n        intervals = set<vector<int>, decltype(comp)>(comp);\\n    }\\n    \\n    void addNum(int value) {\\n        vector<int> interval = {value, value};\\n        set<vector<int>>::iterator first = intervals.lower_bound({value + 1, value + 1});\\n        set<vector<int>>::iterator second = intervals.lower_bound({value - 1, value - 1});\\n        bool same = first == second;\\n        \\n        if(first != intervals.end() && (*first)[0] < value && (*first)[1] > value) return;\\n        if(second != intervals.end() && (*second)[0] < value && (*second)[1] > value) return;\\n\\n        if(first != intervals.end() && (*first)[0] == value+1) {\\n            interval[1] = (*first)[1];   \\n            intervals.erase(first);\\n        }\\n        if(!same && second != intervals.end() && (*second)[1] == value-1) {\\n            interval[0] = (*second)[0];\\n            intervals.erase(second);\\n        }\\n        intervals.insert(interval);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> res;\\n        for(vector<int> it: intervals) {\\n            res.push_back(it);\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Why every time I solve the hard problem by myself, people write that it is actually not a hard problem? :D"
                    }
                ]
            },
            {
                "id": 1571628,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "what a worst description."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Wow! This should be marked as Easy."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "Can anyone drop a explaination video (YouTube) link of this problem, using C++.\\nThanks in advance."
                    },
                    {
                        "username": "arghyadas",
                        "content": "What is the use of the string array?"
                    },
                    {
                        "username": "MitchellHe",
                        "content": "Does anybody have any idea about the follow up?"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Value range is [0,10000] should be helpful.\\nBut checkout reasoning here though..\\n\\nhttps://leetcode.com/problems/data-stream-as-disjoint-intervals/discussion/comments/1777390"
                    },
                    {
                        "username": "tgli",
                        "content": "what's the class definition of Interval ????"
                    },
                    {
                        "username": "c410n",
                        "content": "Hi Team,\\nCould someone please explain me the task?"
                    },
                    {
                        "username": "colins",
                        "content": "Can someone give me an example why is my solution wrong: @\\n```class SummaryRanges {\\n    private TreeMap<Integer, Integer> intervals;\\n\\n    public SummaryRanges() {\\n        intervals = new TreeMap<>(); \\n    }\\n    \\n    public void addNum(int value) {\\n        Map.Entry<Integer, Integer> lowerEntry = intervals.lowerEntry(value); \\n        int left = value, right = value;\\n        if(lowerEntry==null){\\n            if(intervals.get(value)!=null&& intervals.get(value)>=value)return;\\n        }\\n        else {\\n            int previous = lowerEntry.getValue();\\n            if (previous >= value) {\\n                return;\\n            }\\n            if (previous == value - 1) {\\n                left = lowerEntry.getKey();\\n            }\\n        }\\n        Map.Entry<Integer, Integer> maxEntry = intervals.higherEntry(value); \\n        if (maxEntry != null && maxEntry.getKey() == value + 1) {\\n            right = maxEntry.getValue();\\n            intervals.remove(value + 1);\\n        }\\n        intervals.put(left, right);\\n    }\\n    \\n    public int[][] getIntervals() {\\n        final int[][] answer = new int[intervals.size()][2];\\n        int ind = 0;\\n        for (Map.Entry<Integer, Integer> entry : intervals.entrySet()) {\\n            answer[ind][0] = entry.getKey();\\n            answer[ind++][1] = entry.getValue();\\n        }\\n        return answer; \\n    }\\n}```"
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "I am not able to figure out where I am makig a mistake. Any help is appreciated !!\\n```\\nclass SummaryRanges {\\n    function<bool(vector<int>, vector<int>)> comp = [&](const vector<int> &a, const vector<int> &b) {\\n        return a[0] < b[0];\\n    };\\n    set<vector<int>, decltype(comp)> intervals;\\npublic:\\n    SummaryRanges() {\\n        intervals = set<vector<int>, decltype(comp)>(comp);\\n    }\\n    \\n    void addNum(int value) {\\n        vector<int> interval = {value, value};\\n        set<vector<int>>::iterator first = intervals.lower_bound({value + 1, value + 1});\\n        set<vector<int>>::iterator second = intervals.lower_bound({value - 1, value - 1});\\n        bool same = first == second;\\n        \\n        if(first != intervals.end() && (*first)[0] < value && (*first)[1] > value) return;\\n        if(second != intervals.end() && (*second)[0] < value && (*second)[1] > value) return;\\n\\n        if(first != intervals.end() && (*first)[0] == value+1) {\\n            interval[1] = (*first)[1];   \\n            intervals.erase(first);\\n        }\\n        if(!same && second != intervals.end() && (*second)[1] == value-1) {\\n            interval[0] = (*second)[0];\\n            intervals.erase(second);\\n        }\\n        intervals.insert(interval);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> res;\\n        for(vector<int> it: intervals) {\\n            res.push_back(it);\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Why every time I solve the hard problem by myself, people write that it is actually not a hard problem? :D"
                    }
                ]
            },
            {
                "id": 1574864,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "what a worst description."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Wow! This should be marked as Easy."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "Can anyone drop a explaination video (YouTube) link of this problem, using C++.\\nThanks in advance."
                    },
                    {
                        "username": "arghyadas",
                        "content": "What is the use of the string array?"
                    },
                    {
                        "username": "MitchellHe",
                        "content": "Does anybody have any idea about the follow up?"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Value range is [0,10000] should be helpful.\\nBut checkout reasoning here though..\\n\\nhttps://leetcode.com/problems/data-stream-as-disjoint-intervals/discussion/comments/1777390"
                    },
                    {
                        "username": "tgli",
                        "content": "what's the class definition of Interval ????"
                    },
                    {
                        "username": "c410n",
                        "content": "Hi Team,\\nCould someone please explain me the task?"
                    },
                    {
                        "username": "colins",
                        "content": "Can someone give me an example why is my solution wrong: @\\n```class SummaryRanges {\\n    private TreeMap<Integer, Integer> intervals;\\n\\n    public SummaryRanges() {\\n        intervals = new TreeMap<>(); \\n    }\\n    \\n    public void addNum(int value) {\\n        Map.Entry<Integer, Integer> lowerEntry = intervals.lowerEntry(value); \\n        int left = value, right = value;\\n        if(lowerEntry==null){\\n            if(intervals.get(value)!=null&& intervals.get(value)>=value)return;\\n        }\\n        else {\\n            int previous = lowerEntry.getValue();\\n            if (previous >= value) {\\n                return;\\n            }\\n            if (previous == value - 1) {\\n                left = lowerEntry.getKey();\\n            }\\n        }\\n        Map.Entry<Integer, Integer> maxEntry = intervals.higherEntry(value); \\n        if (maxEntry != null && maxEntry.getKey() == value + 1) {\\n            right = maxEntry.getValue();\\n            intervals.remove(value + 1);\\n        }\\n        intervals.put(left, right);\\n    }\\n    \\n    public int[][] getIntervals() {\\n        final int[][] answer = new int[intervals.size()][2];\\n        int ind = 0;\\n        for (Map.Entry<Integer, Integer> entry : intervals.entrySet()) {\\n            answer[ind][0] = entry.getKey();\\n            answer[ind++][1] = entry.getValue();\\n        }\\n        return answer; \\n    }\\n}```"
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "I am not able to figure out where I am makig a mistake. Any help is appreciated !!\\n```\\nclass SummaryRanges {\\n    function<bool(vector<int>, vector<int>)> comp = [&](const vector<int> &a, const vector<int> &b) {\\n        return a[0] < b[0];\\n    };\\n    set<vector<int>, decltype(comp)> intervals;\\npublic:\\n    SummaryRanges() {\\n        intervals = set<vector<int>, decltype(comp)>(comp);\\n    }\\n    \\n    void addNum(int value) {\\n        vector<int> interval = {value, value};\\n        set<vector<int>>::iterator first = intervals.lower_bound({value + 1, value + 1});\\n        set<vector<int>>::iterator second = intervals.lower_bound({value - 1, value - 1});\\n        bool same = first == second;\\n        \\n        if(first != intervals.end() && (*first)[0] < value && (*first)[1] > value) return;\\n        if(second != intervals.end() && (*second)[0] < value && (*second)[1] > value) return;\\n\\n        if(first != intervals.end() && (*first)[0] == value+1) {\\n            interval[1] = (*first)[1];   \\n            intervals.erase(first);\\n        }\\n        if(!same && second != intervals.end() && (*second)[1] == value-1) {\\n            interval[0] = (*second)[0];\\n            intervals.erase(second);\\n        }\\n        intervals.insert(interval);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> res;\\n        for(vector<int> it: intervals) {\\n            res.push_back(it);\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Why every time I solve the hard problem by myself, people write that it is actually not a hard problem? :D"
                    }
                ]
            },
            {
                "id": 1826604,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "what a worst description."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Wow! This should be marked as Easy."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "Can anyone drop a explaination video (YouTube) link of this problem, using C++.\\nThanks in advance."
                    },
                    {
                        "username": "arghyadas",
                        "content": "What is the use of the string array?"
                    },
                    {
                        "username": "MitchellHe",
                        "content": "Does anybody have any idea about the follow up?"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Value range is [0,10000] should be helpful.\\nBut checkout reasoning here though..\\n\\nhttps://leetcode.com/problems/data-stream-as-disjoint-intervals/discussion/comments/1777390"
                    },
                    {
                        "username": "tgli",
                        "content": "what's the class definition of Interval ????"
                    },
                    {
                        "username": "c410n",
                        "content": "Hi Team,\\nCould someone please explain me the task?"
                    },
                    {
                        "username": "colins",
                        "content": "Can someone give me an example why is my solution wrong: @\\n```class SummaryRanges {\\n    private TreeMap<Integer, Integer> intervals;\\n\\n    public SummaryRanges() {\\n        intervals = new TreeMap<>(); \\n    }\\n    \\n    public void addNum(int value) {\\n        Map.Entry<Integer, Integer> lowerEntry = intervals.lowerEntry(value); \\n        int left = value, right = value;\\n        if(lowerEntry==null){\\n            if(intervals.get(value)!=null&& intervals.get(value)>=value)return;\\n        }\\n        else {\\n            int previous = lowerEntry.getValue();\\n            if (previous >= value) {\\n                return;\\n            }\\n            if (previous == value - 1) {\\n                left = lowerEntry.getKey();\\n            }\\n        }\\n        Map.Entry<Integer, Integer> maxEntry = intervals.higherEntry(value); \\n        if (maxEntry != null && maxEntry.getKey() == value + 1) {\\n            right = maxEntry.getValue();\\n            intervals.remove(value + 1);\\n        }\\n        intervals.put(left, right);\\n    }\\n    \\n    public int[][] getIntervals() {\\n        final int[][] answer = new int[intervals.size()][2];\\n        int ind = 0;\\n        for (Map.Entry<Integer, Integer> entry : intervals.entrySet()) {\\n            answer[ind][0] = entry.getKey();\\n            answer[ind++][1] = entry.getValue();\\n        }\\n        return answer; \\n    }\\n}```"
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "I am not able to figure out where I am makig a mistake. Any help is appreciated !!\\n```\\nclass SummaryRanges {\\n    function<bool(vector<int>, vector<int>)> comp = [&](const vector<int> &a, const vector<int> &b) {\\n        return a[0] < b[0];\\n    };\\n    set<vector<int>, decltype(comp)> intervals;\\npublic:\\n    SummaryRanges() {\\n        intervals = set<vector<int>, decltype(comp)>(comp);\\n    }\\n    \\n    void addNum(int value) {\\n        vector<int> interval = {value, value};\\n        set<vector<int>>::iterator first = intervals.lower_bound({value + 1, value + 1});\\n        set<vector<int>>::iterator second = intervals.lower_bound({value - 1, value - 1});\\n        bool same = first == second;\\n        \\n        if(first != intervals.end() && (*first)[0] < value && (*first)[1] > value) return;\\n        if(second != intervals.end() && (*second)[0] < value && (*second)[1] > value) return;\\n\\n        if(first != intervals.end() && (*first)[0] == value+1) {\\n            interval[1] = (*first)[1];   \\n            intervals.erase(first);\\n        }\\n        if(!same && second != intervals.end() && (*second)[1] == value-1) {\\n            interval[0] = (*second)[0];\\n            intervals.erase(second);\\n        }\\n        intervals.insert(interval);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> res;\\n        for(vector<int> it: intervals) {\\n            res.push_back(it);\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Why every time I solve the hard problem by myself, people write that it is actually not a hard problem? :D"
                    }
                ]
            },
            {
                "id": 1781642,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "what a worst description."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Wow! This should be marked as Easy."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "Can anyone drop a explaination video (YouTube) link of this problem, using C++.\\nThanks in advance."
                    },
                    {
                        "username": "arghyadas",
                        "content": "What is the use of the string array?"
                    },
                    {
                        "username": "MitchellHe",
                        "content": "Does anybody have any idea about the follow up?"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Value range is [0,10000] should be helpful.\\nBut checkout reasoning here though..\\n\\nhttps://leetcode.com/problems/data-stream-as-disjoint-intervals/discussion/comments/1777390"
                    },
                    {
                        "username": "tgli",
                        "content": "what's the class definition of Interval ????"
                    },
                    {
                        "username": "c410n",
                        "content": "Hi Team,\\nCould someone please explain me the task?"
                    },
                    {
                        "username": "colins",
                        "content": "Can someone give me an example why is my solution wrong: @\\n```class SummaryRanges {\\n    private TreeMap<Integer, Integer> intervals;\\n\\n    public SummaryRanges() {\\n        intervals = new TreeMap<>(); \\n    }\\n    \\n    public void addNum(int value) {\\n        Map.Entry<Integer, Integer> lowerEntry = intervals.lowerEntry(value); \\n        int left = value, right = value;\\n        if(lowerEntry==null){\\n            if(intervals.get(value)!=null&& intervals.get(value)>=value)return;\\n        }\\n        else {\\n            int previous = lowerEntry.getValue();\\n            if (previous >= value) {\\n                return;\\n            }\\n            if (previous == value - 1) {\\n                left = lowerEntry.getKey();\\n            }\\n        }\\n        Map.Entry<Integer, Integer> maxEntry = intervals.higherEntry(value); \\n        if (maxEntry != null && maxEntry.getKey() == value + 1) {\\n            right = maxEntry.getValue();\\n            intervals.remove(value + 1);\\n        }\\n        intervals.put(left, right);\\n    }\\n    \\n    public int[][] getIntervals() {\\n        final int[][] answer = new int[intervals.size()][2];\\n        int ind = 0;\\n        for (Map.Entry<Integer, Integer> entry : intervals.entrySet()) {\\n            answer[ind][0] = entry.getKey();\\n            answer[ind++][1] = entry.getValue();\\n        }\\n        return answer; \\n    }\\n}```"
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "I am not able to figure out where I am makig a mistake. Any help is appreciated !!\\n```\\nclass SummaryRanges {\\n    function<bool(vector<int>, vector<int>)> comp = [&](const vector<int> &a, const vector<int> &b) {\\n        return a[0] < b[0];\\n    };\\n    set<vector<int>, decltype(comp)> intervals;\\npublic:\\n    SummaryRanges() {\\n        intervals = set<vector<int>, decltype(comp)>(comp);\\n    }\\n    \\n    void addNum(int value) {\\n        vector<int> interval = {value, value};\\n        set<vector<int>>::iterator first = intervals.lower_bound({value + 1, value + 1});\\n        set<vector<int>>::iterator second = intervals.lower_bound({value - 1, value - 1});\\n        bool same = first == second;\\n        \\n        if(first != intervals.end() && (*first)[0] < value && (*first)[1] > value) return;\\n        if(second != intervals.end() && (*second)[0] < value && (*second)[1] > value) return;\\n\\n        if(first != intervals.end() && (*first)[0] == value+1) {\\n            interval[1] = (*first)[1];   \\n            intervals.erase(first);\\n        }\\n        if(!same && second != intervals.end() && (*second)[1] == value-1) {\\n            interval[0] = (*second)[0];\\n            intervals.erase(second);\\n        }\\n        intervals.insert(interval);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> res;\\n        for(vector<int> it: intervals) {\\n            res.push_back(it);\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Why every time I solve the hard problem by myself, people write that it is actually not a hard problem? :D"
                    }
                ]
            },
            {
                "id": 1778120,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "what a worst description."
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Wow! This should be marked as Easy."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "Can anyone drop a explaination video (YouTube) link of this problem, using C++.\\nThanks in advance."
                    },
                    {
                        "username": "arghyadas",
                        "content": "What is the use of the string array?"
                    },
                    {
                        "username": "MitchellHe",
                        "content": "Does anybody have any idea about the follow up?"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Value range is [0,10000] should be helpful.\\nBut checkout reasoning here though..\\n\\nhttps://leetcode.com/problems/data-stream-as-disjoint-intervals/discussion/comments/1777390"
                    },
                    {
                        "username": "tgli",
                        "content": "what's the class definition of Interval ????"
                    },
                    {
                        "username": "c410n",
                        "content": "Hi Team,\\nCould someone please explain me the task?"
                    },
                    {
                        "username": "colins",
                        "content": "Can someone give me an example why is my solution wrong: @\\n```class SummaryRanges {\\n    private TreeMap<Integer, Integer> intervals;\\n\\n    public SummaryRanges() {\\n        intervals = new TreeMap<>(); \\n    }\\n    \\n    public void addNum(int value) {\\n        Map.Entry<Integer, Integer> lowerEntry = intervals.lowerEntry(value); \\n        int left = value, right = value;\\n        if(lowerEntry==null){\\n            if(intervals.get(value)!=null&& intervals.get(value)>=value)return;\\n        }\\n        else {\\n            int previous = lowerEntry.getValue();\\n            if (previous >= value) {\\n                return;\\n            }\\n            if (previous == value - 1) {\\n                left = lowerEntry.getKey();\\n            }\\n        }\\n        Map.Entry<Integer, Integer> maxEntry = intervals.higherEntry(value); \\n        if (maxEntry != null && maxEntry.getKey() == value + 1) {\\n            right = maxEntry.getValue();\\n            intervals.remove(value + 1);\\n        }\\n        intervals.put(left, right);\\n    }\\n    \\n    public int[][] getIntervals() {\\n        final int[][] answer = new int[intervals.size()][2];\\n        int ind = 0;\\n        for (Map.Entry<Integer, Integer> entry : intervals.entrySet()) {\\n            answer[ind][0] = entry.getKey();\\n            answer[ind++][1] = entry.getValue();\\n        }\\n        return answer; \\n    }\\n}```"
                    },
                    {
                        "username": "strawhatdragon",
                        "content": "I am not able to figure out where I am makig a mistake. Any help is appreciated !!\\n```\\nclass SummaryRanges {\\n    function<bool(vector<int>, vector<int>)> comp = [&](const vector<int> &a, const vector<int> &b) {\\n        return a[0] < b[0];\\n    };\\n    set<vector<int>, decltype(comp)> intervals;\\npublic:\\n    SummaryRanges() {\\n        intervals = set<vector<int>, decltype(comp)>(comp);\\n    }\\n    \\n    void addNum(int value) {\\n        vector<int> interval = {value, value};\\n        set<vector<int>>::iterator first = intervals.lower_bound({value + 1, value + 1});\\n        set<vector<int>>::iterator second = intervals.lower_bound({value - 1, value - 1});\\n        bool same = first == second;\\n        \\n        if(first != intervals.end() && (*first)[0] < value && (*first)[1] > value) return;\\n        if(second != intervals.end() && (*second)[0] < value && (*second)[1] > value) return;\\n\\n        if(first != intervals.end() && (*first)[0] == value+1) {\\n            interval[1] = (*first)[1];   \\n            intervals.erase(first);\\n        }\\n        if(!same && second != intervals.end() && (*second)[1] == value-1) {\\n            interval[0] = (*second)[0];\\n            intervals.erase(second);\\n        }\\n        intervals.insert(interval);\\n    }\\n    \\n    vector<vector<int>> getIntervals() {\\n        vector<vector<int>> res;\\n        for(vector<int> it: intervals) {\\n            res.push_back(it);\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your SummaryRanges object will be instantiated and called as such:\\n * SummaryRanges* obj = new SummaryRanges();\\n * obj->addNum(value);\\n * vector<vector<int>> param_2 = obj->getIntervals();\\n */\\n```"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Why every time I solve the hard problem by myself, people write that it is actually not a hard problem? :D"
                    }
                ]
            },
            {
                "id": 1778118,
                "content": [
                    {
                        "username": "denkochev",
                        "content": "I like this problem. "
                    },
                    {
                        "username": "lixx2874",
                        "content": "Not a hard one but involves too much labor work : ( "
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think this problem is difficult because there is a confusing description, which can be interpreted as follows:\\n```\\n1. Define an init.array=[]\\n2. Add positive integers to this array:\\nwrite code for addNum() function\\neg: 1,3,5 -> init.array=[1,3,5]\\n3. Return the values contained in init.array when calling the getIntervals() function:\\ninit.array=[1,3,5] -> return [1,1] [3,3] [5,5]\\nIf there are continuous sequences of numbers, return the upper-lower bound, otherwise return its own interval.\\n\\neg: 1,2,3,4,7 -> init.array= =[1,2,3,4,7] -> return [1,4] [7,7]\\n```\\n\\n1. Brute force approach:\\nWrite code in the getIntervals() function, return the upper and lower bounds of a continuous series of numbers\\n\\n2. DP:\\nWrite code in the addNum() function, edit the sequence of numbers and save only the intervals"
                    },
                    {
                        "username": "native_element",
                        "content": "i have done only for streak....feeling low"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "am I the only one who solved this using Union Find and had a pretty bad time complexity ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "Why UF, it s just a class and function problem. \\n\\nNeed to treat the self.array data before return it in getInterval()"
                    },
                    {
                        "username": "Klemo1997",
                        "content": "For those who have trouble understanding the assignment, try to solve this problem: [228. Summary Ranges\\n](https://leetcode.com/problems/summary-ranges/) and it will become pretty trivial afterwards."
                    },
                    {
                        "username": "thakurfurqaan",
                        "content": "This should be Easy or Medium, not Difficult. Because even brute force solution is accepted where I am sorting the list every time I add a new number."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I agree, there is a confusing description, the rest is like a medium array problem. "
                    },
                    {
                        "username": "reflexion",
                        "content": "The quality of description of questions has degraded noticeably."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest C++ code with video explanation and dry run with line by line code, Just try and you won\\'t regret https://youtu.be/T9161z-gMgs"
                    },
                    {
                        "username": "Fadi_hamwi",
                        "content": "Frankly, I don\\'t know why the problem description says that the problem is hard, just check for duplicates and maintain the order of the stream and you will be okay."
                    }
                ]
            },
            {
                "id": 1778042,
                "content": [
                    {
                        "username": "denkochev",
                        "content": "I like this problem. "
                    },
                    {
                        "username": "lixx2874",
                        "content": "Not a hard one but involves too much labor work : ( "
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think this problem is difficult because there is a confusing description, which can be interpreted as follows:\\n```\\n1. Define an init.array=[]\\n2. Add positive integers to this array:\\nwrite code for addNum() function\\neg: 1,3,5 -> init.array=[1,3,5]\\n3. Return the values contained in init.array when calling the getIntervals() function:\\ninit.array=[1,3,5] -> return [1,1] [3,3] [5,5]\\nIf there are continuous sequences of numbers, return the upper-lower bound, otherwise return its own interval.\\n\\neg: 1,2,3,4,7 -> init.array= =[1,2,3,4,7] -> return [1,4] [7,7]\\n```\\n\\n1. Brute force approach:\\nWrite code in the getIntervals() function, return the upper and lower bounds of a continuous series of numbers\\n\\n2. DP:\\nWrite code in the addNum() function, edit the sequence of numbers and save only the intervals"
                    },
                    {
                        "username": "native_element",
                        "content": "i have done only for streak....feeling low"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "am I the only one who solved this using Union Find and had a pretty bad time complexity ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "Why UF, it s just a class and function problem. \\n\\nNeed to treat the self.array data before return it in getInterval()"
                    },
                    {
                        "username": "Klemo1997",
                        "content": "For those who have trouble understanding the assignment, try to solve this problem: [228. Summary Ranges\\n](https://leetcode.com/problems/summary-ranges/) and it will become pretty trivial afterwards."
                    },
                    {
                        "username": "thakurfurqaan",
                        "content": "This should be Easy or Medium, not Difficult. Because even brute force solution is accepted where I am sorting the list every time I add a new number."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I agree, there is a confusing description, the rest is like a medium array problem. "
                    },
                    {
                        "username": "reflexion",
                        "content": "The quality of description of questions has degraded noticeably."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest C++ code with video explanation and dry run with line by line code, Just try and you won\\'t regret https://youtu.be/T9161z-gMgs"
                    },
                    {
                        "username": "Fadi_hamwi",
                        "content": "Frankly, I don\\'t know why the problem description says that the problem is hard, just check for duplicates and maintain the order of the stream and you will be okay."
                    }
                ]
            },
            {
                "id": 1778039,
                "content": [
                    {
                        "username": "denkochev",
                        "content": "I like this problem. "
                    },
                    {
                        "username": "lixx2874",
                        "content": "Not a hard one but involves too much labor work : ( "
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think this problem is difficult because there is a confusing description, which can be interpreted as follows:\\n```\\n1. Define an init.array=[]\\n2. Add positive integers to this array:\\nwrite code for addNum() function\\neg: 1,3,5 -> init.array=[1,3,5]\\n3. Return the values contained in init.array when calling the getIntervals() function:\\ninit.array=[1,3,5] -> return [1,1] [3,3] [5,5]\\nIf there are continuous sequences of numbers, return the upper-lower bound, otherwise return its own interval.\\n\\neg: 1,2,3,4,7 -> init.array= =[1,2,3,4,7] -> return [1,4] [7,7]\\n```\\n\\n1. Brute force approach:\\nWrite code in the getIntervals() function, return the upper and lower bounds of a continuous series of numbers\\n\\n2. DP:\\nWrite code in the addNum() function, edit the sequence of numbers and save only the intervals"
                    },
                    {
                        "username": "native_element",
                        "content": "i have done only for streak....feeling low"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "am I the only one who solved this using Union Find and had a pretty bad time complexity ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "Why UF, it s just a class and function problem. \\n\\nNeed to treat the self.array data before return it in getInterval()"
                    },
                    {
                        "username": "Klemo1997",
                        "content": "For those who have trouble understanding the assignment, try to solve this problem: [228. Summary Ranges\\n](https://leetcode.com/problems/summary-ranges/) and it will become pretty trivial afterwards."
                    },
                    {
                        "username": "thakurfurqaan",
                        "content": "This should be Easy or Medium, not Difficult. Because even brute force solution is accepted where I am sorting the list every time I add a new number."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I agree, there is a confusing description, the rest is like a medium array problem. "
                    },
                    {
                        "username": "reflexion",
                        "content": "The quality of description of questions has degraded noticeably."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest C++ code with video explanation and dry run with line by line code, Just try and you won\\'t regret https://youtu.be/T9161z-gMgs"
                    },
                    {
                        "username": "Fadi_hamwi",
                        "content": "Frankly, I don\\'t know why the problem description says that the problem is hard, just check for duplicates and maintain the order of the stream and you will be okay."
                    }
                ]
            },
            {
                "id": 1777984,
                "content": [
                    {
                        "username": "denkochev",
                        "content": "I like this problem. "
                    },
                    {
                        "username": "lixx2874",
                        "content": "Not a hard one but involves too much labor work : ( "
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think this problem is difficult because there is a confusing description, which can be interpreted as follows:\\n```\\n1. Define an init.array=[]\\n2. Add positive integers to this array:\\nwrite code for addNum() function\\neg: 1,3,5 -> init.array=[1,3,5]\\n3. Return the values contained in init.array when calling the getIntervals() function:\\ninit.array=[1,3,5] -> return [1,1] [3,3] [5,5]\\nIf there are continuous sequences of numbers, return the upper-lower bound, otherwise return its own interval.\\n\\neg: 1,2,3,4,7 -> init.array= =[1,2,3,4,7] -> return [1,4] [7,7]\\n```\\n\\n1. Brute force approach:\\nWrite code in the getIntervals() function, return the upper and lower bounds of a continuous series of numbers\\n\\n2. DP:\\nWrite code in the addNum() function, edit the sequence of numbers and save only the intervals"
                    },
                    {
                        "username": "native_element",
                        "content": "i have done only for streak....feeling low"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "am I the only one who solved this using Union Find and had a pretty bad time complexity ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "Why UF, it s just a class and function problem. \\n\\nNeed to treat the self.array data before return it in getInterval()"
                    },
                    {
                        "username": "Klemo1997",
                        "content": "For those who have trouble understanding the assignment, try to solve this problem: [228. Summary Ranges\\n](https://leetcode.com/problems/summary-ranges/) and it will become pretty trivial afterwards."
                    },
                    {
                        "username": "thakurfurqaan",
                        "content": "This should be Easy or Medium, not Difficult. Because even brute force solution is accepted where I am sorting the list every time I add a new number."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I agree, there is a confusing description, the rest is like a medium array problem. "
                    },
                    {
                        "username": "reflexion",
                        "content": "The quality of description of questions has degraded noticeably."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest C++ code with video explanation and dry run with line by line code, Just try and you won\\'t regret https://youtu.be/T9161z-gMgs"
                    },
                    {
                        "username": "Fadi_hamwi",
                        "content": "Frankly, I don\\'t know why the problem description says that the problem is hard, just check for duplicates and maintain the order of the stream and you will be okay."
                    }
                ]
            },
            {
                "id": 1777955,
                "content": [
                    {
                        "username": "denkochev",
                        "content": "I like this problem. "
                    },
                    {
                        "username": "lixx2874",
                        "content": "Not a hard one but involves too much labor work : ( "
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think this problem is difficult because there is a confusing description, which can be interpreted as follows:\\n```\\n1. Define an init.array=[]\\n2. Add positive integers to this array:\\nwrite code for addNum() function\\neg: 1,3,5 -> init.array=[1,3,5]\\n3. Return the values contained in init.array when calling the getIntervals() function:\\ninit.array=[1,3,5] -> return [1,1] [3,3] [5,5]\\nIf there are continuous sequences of numbers, return the upper-lower bound, otherwise return its own interval.\\n\\neg: 1,2,3,4,7 -> init.array= =[1,2,3,4,7] -> return [1,4] [7,7]\\n```\\n\\n1. Brute force approach:\\nWrite code in the getIntervals() function, return the upper and lower bounds of a continuous series of numbers\\n\\n2. DP:\\nWrite code in the addNum() function, edit the sequence of numbers and save only the intervals"
                    },
                    {
                        "username": "native_element",
                        "content": "i have done only for streak....feeling low"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "am I the only one who solved this using Union Find and had a pretty bad time complexity ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "Why UF, it s just a class and function problem. \\n\\nNeed to treat the self.array data before return it in getInterval()"
                    },
                    {
                        "username": "Klemo1997",
                        "content": "For those who have trouble understanding the assignment, try to solve this problem: [228. Summary Ranges\\n](https://leetcode.com/problems/summary-ranges/) and it will become pretty trivial afterwards."
                    },
                    {
                        "username": "thakurfurqaan",
                        "content": "This should be Easy or Medium, not Difficult. Because even brute force solution is accepted where I am sorting the list every time I add a new number."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I agree, there is a confusing description, the rest is like a medium array problem. "
                    },
                    {
                        "username": "reflexion",
                        "content": "The quality of description of questions has degraded noticeably."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest C++ code with video explanation and dry run with line by line code, Just try and you won\\'t regret https://youtu.be/T9161z-gMgs"
                    },
                    {
                        "username": "Fadi_hamwi",
                        "content": "Frankly, I don\\'t know why the problem description says that the problem is hard, just check for duplicates and maintain the order of the stream and you will be okay."
                    }
                ]
            },
            {
                "id": 1777932,
                "content": [
                    {
                        "username": "denkochev",
                        "content": "I like this problem. "
                    },
                    {
                        "username": "lixx2874",
                        "content": "Not a hard one but involves too much labor work : ( "
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think this problem is difficult because there is a confusing description, which can be interpreted as follows:\\n```\\n1. Define an init.array=[]\\n2. Add positive integers to this array:\\nwrite code for addNum() function\\neg: 1,3,5 -> init.array=[1,3,5]\\n3. Return the values contained in init.array when calling the getIntervals() function:\\ninit.array=[1,3,5] -> return [1,1] [3,3] [5,5]\\nIf there are continuous sequences of numbers, return the upper-lower bound, otherwise return its own interval.\\n\\neg: 1,2,3,4,7 -> init.array= =[1,2,3,4,7] -> return [1,4] [7,7]\\n```\\n\\n1. Brute force approach:\\nWrite code in the getIntervals() function, return the upper and lower bounds of a continuous series of numbers\\n\\n2. DP:\\nWrite code in the addNum() function, edit the sequence of numbers and save only the intervals"
                    },
                    {
                        "username": "native_element",
                        "content": "i have done only for streak....feeling low"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "am I the only one who solved this using Union Find and had a pretty bad time complexity ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "Why UF, it s just a class and function problem. \\n\\nNeed to treat the self.array data before return it in getInterval()"
                    },
                    {
                        "username": "Klemo1997",
                        "content": "For those who have trouble understanding the assignment, try to solve this problem: [228. Summary Ranges\\n](https://leetcode.com/problems/summary-ranges/) and it will become pretty trivial afterwards."
                    },
                    {
                        "username": "thakurfurqaan",
                        "content": "This should be Easy or Medium, not Difficult. Because even brute force solution is accepted where I am sorting the list every time I add a new number."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I agree, there is a confusing description, the rest is like a medium array problem. "
                    },
                    {
                        "username": "reflexion",
                        "content": "The quality of description of questions has degraded noticeably."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest C++ code with video explanation and dry run with line by line code, Just try and you won\\'t regret https://youtu.be/T9161z-gMgs"
                    },
                    {
                        "username": "Fadi_hamwi",
                        "content": "Frankly, I don\\'t know why the problem description says that the problem is hard, just check for duplicates and maintain the order of the stream and you will be okay."
                    }
                ]
            },
            {
                "id": 1777928,
                "content": [
                    {
                        "username": "denkochev",
                        "content": "I like this problem. "
                    },
                    {
                        "username": "lixx2874",
                        "content": "Not a hard one but involves too much labor work : ( "
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think this problem is difficult because there is a confusing description, which can be interpreted as follows:\\n```\\n1. Define an init.array=[]\\n2. Add positive integers to this array:\\nwrite code for addNum() function\\neg: 1,3,5 -> init.array=[1,3,5]\\n3. Return the values contained in init.array when calling the getIntervals() function:\\ninit.array=[1,3,5] -> return [1,1] [3,3] [5,5]\\nIf there are continuous sequences of numbers, return the upper-lower bound, otherwise return its own interval.\\n\\neg: 1,2,3,4,7 -> init.array= =[1,2,3,4,7] -> return [1,4] [7,7]\\n```\\n\\n1. Brute force approach:\\nWrite code in the getIntervals() function, return the upper and lower bounds of a continuous series of numbers\\n\\n2. DP:\\nWrite code in the addNum() function, edit the sequence of numbers and save only the intervals"
                    },
                    {
                        "username": "native_element",
                        "content": "i have done only for streak....feeling low"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "am I the only one who solved this using Union Find and had a pretty bad time complexity ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "Why UF, it s just a class and function problem. \\n\\nNeed to treat the self.array data before return it in getInterval()"
                    },
                    {
                        "username": "Klemo1997",
                        "content": "For those who have trouble understanding the assignment, try to solve this problem: [228. Summary Ranges\\n](https://leetcode.com/problems/summary-ranges/) and it will become pretty trivial afterwards."
                    },
                    {
                        "username": "thakurfurqaan",
                        "content": "This should be Easy or Medium, not Difficult. Because even brute force solution is accepted where I am sorting the list every time I add a new number."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I agree, there is a confusing description, the rest is like a medium array problem. "
                    },
                    {
                        "username": "reflexion",
                        "content": "The quality of description of questions has degraded noticeably."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest C++ code with video explanation and dry run with line by line code, Just try and you won\\'t regret https://youtu.be/T9161z-gMgs"
                    },
                    {
                        "username": "Fadi_hamwi",
                        "content": "Frankly, I don\\'t know why the problem description says that the problem is hard, just check for duplicates and maintain the order of the stream and you will be okay."
                    }
                ]
            },
            {
                "id": 1777924,
                "content": [
                    {
                        "username": "denkochev",
                        "content": "I like this problem. "
                    },
                    {
                        "username": "lixx2874",
                        "content": "Not a hard one but involves too much labor work : ( "
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think this problem is difficult because there is a confusing description, which can be interpreted as follows:\\n```\\n1. Define an init.array=[]\\n2. Add positive integers to this array:\\nwrite code for addNum() function\\neg: 1,3,5 -> init.array=[1,3,5]\\n3. Return the values contained in init.array when calling the getIntervals() function:\\ninit.array=[1,3,5] -> return [1,1] [3,3] [5,5]\\nIf there are continuous sequences of numbers, return the upper-lower bound, otherwise return its own interval.\\n\\neg: 1,2,3,4,7 -> init.array= =[1,2,3,4,7] -> return [1,4] [7,7]\\n```\\n\\n1. Brute force approach:\\nWrite code in the getIntervals() function, return the upper and lower bounds of a continuous series of numbers\\n\\n2. DP:\\nWrite code in the addNum() function, edit the sequence of numbers and save only the intervals"
                    },
                    {
                        "username": "native_element",
                        "content": "i have done only for streak....feeling low"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "am I the only one who solved this using Union Find and had a pretty bad time complexity ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "Why UF, it s just a class and function problem. \\n\\nNeed to treat the self.array data before return it in getInterval()"
                    },
                    {
                        "username": "Klemo1997",
                        "content": "For those who have trouble understanding the assignment, try to solve this problem: [228. Summary Ranges\\n](https://leetcode.com/problems/summary-ranges/) and it will become pretty trivial afterwards."
                    },
                    {
                        "username": "thakurfurqaan",
                        "content": "This should be Easy or Medium, not Difficult. Because even brute force solution is accepted where I am sorting the list every time I add a new number."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I agree, there is a confusing description, the rest is like a medium array problem. "
                    },
                    {
                        "username": "reflexion",
                        "content": "The quality of description of questions has degraded noticeably."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest C++ code with video explanation and dry run with line by line code, Just try and you won\\'t regret https://youtu.be/T9161z-gMgs"
                    },
                    {
                        "username": "Fadi_hamwi",
                        "content": "Frankly, I don\\'t know why the problem description says that the problem is hard, just check for duplicates and maintain the order of the stream and you will be okay."
                    }
                ]
            },
            {
                "id": 1777917,
                "content": [
                    {
                        "username": "denkochev",
                        "content": "I like this problem. "
                    },
                    {
                        "username": "lixx2874",
                        "content": "Not a hard one but involves too much labor work : ( "
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think this problem is difficult because there is a confusing description, which can be interpreted as follows:\\n```\\n1. Define an init.array=[]\\n2. Add positive integers to this array:\\nwrite code for addNum() function\\neg: 1,3,5 -> init.array=[1,3,5]\\n3. Return the values contained in init.array when calling the getIntervals() function:\\ninit.array=[1,3,5] -> return [1,1] [3,3] [5,5]\\nIf there are continuous sequences of numbers, return the upper-lower bound, otherwise return its own interval.\\n\\neg: 1,2,3,4,7 -> init.array= =[1,2,3,4,7] -> return [1,4] [7,7]\\n```\\n\\n1. Brute force approach:\\nWrite code in the getIntervals() function, return the upper and lower bounds of a continuous series of numbers\\n\\n2. DP:\\nWrite code in the addNum() function, edit the sequence of numbers and save only the intervals"
                    },
                    {
                        "username": "native_element",
                        "content": "i have done only for streak....feeling low"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "am I the only one who solved this using Union Find and had a pretty bad time complexity ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "Why UF, it s just a class and function problem. \\n\\nNeed to treat the self.array data before return it in getInterval()"
                    },
                    {
                        "username": "Klemo1997",
                        "content": "For those who have trouble understanding the assignment, try to solve this problem: [228. Summary Ranges\\n](https://leetcode.com/problems/summary-ranges/) and it will become pretty trivial afterwards."
                    },
                    {
                        "username": "thakurfurqaan",
                        "content": "This should be Easy or Medium, not Difficult. Because even brute force solution is accepted where I am sorting the list every time I add a new number."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I agree, there is a confusing description, the rest is like a medium array problem. "
                    },
                    {
                        "username": "reflexion",
                        "content": "The quality of description of questions has degraded noticeably."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest C++ code with video explanation and dry run with line by line code, Just try and you won\\'t regret https://youtu.be/T9161z-gMgs"
                    },
                    {
                        "username": "Fadi_hamwi",
                        "content": "Frankly, I don\\'t know why the problem description says that the problem is hard, just check for duplicates and maintain the order of the stream and you will be okay."
                    }
                ]
            },
            {
                "id": 1777911,
                "content": [
                    {
                        "username": "denkochev",
                        "content": "I like this problem. "
                    },
                    {
                        "username": "lixx2874",
                        "content": "Not a hard one but involves too much labor work : ( "
                    },
                    {
                        "username": "Yongbi",
                        "content": "I think this problem is difficult because there is a confusing description, which can be interpreted as follows:\\n```\\n1. Define an init.array=[]\\n2. Add positive integers to this array:\\nwrite code for addNum() function\\neg: 1,3,5 -> init.array=[1,3,5]\\n3. Return the values contained in init.array when calling the getIntervals() function:\\ninit.array=[1,3,5] -> return [1,1] [3,3] [5,5]\\nIf there are continuous sequences of numbers, return the upper-lower bound, otherwise return its own interval.\\n\\neg: 1,2,3,4,7 -> init.array= =[1,2,3,4,7] -> return [1,4] [7,7]\\n```\\n\\n1. Brute force approach:\\nWrite code in the getIntervals() function, return the upper and lower bounds of a continuous series of numbers\\n\\n2. DP:\\nWrite code in the addNum() function, edit the sequence of numbers and save only the intervals"
                    },
                    {
                        "username": "native_element",
                        "content": "i have done only for streak....feeling low"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "am I the only one who solved this using Union Find and had a pretty bad time complexity ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "Why UF, it s just a class and function problem. \\n\\nNeed to treat the self.array data before return it in getInterval()"
                    },
                    {
                        "username": "Klemo1997",
                        "content": "For those who have trouble understanding the assignment, try to solve this problem: [228. Summary Ranges\\n](https://leetcode.com/problems/summary-ranges/) and it will become pretty trivial afterwards."
                    },
                    {
                        "username": "thakurfurqaan",
                        "content": "This should be Easy or Medium, not Difficult. Because even brute force solution is accepted where I am sorting the list every time I add a new number."
                    },
                    {
                        "username": "Yongbi",
                        "content": "I agree, there is a confusing description, the rest is like a medium array problem. "
                    },
                    {
                        "username": "reflexion",
                        "content": "The quality of description of questions has degraded noticeably."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest C++ code with video explanation and dry run with line by line code, Just try and you won\\'t regret https://youtu.be/T9161z-gMgs"
                    },
                    {
                        "username": "Fadi_hamwi",
                        "content": "Frankly, I don\\'t know why the problem description says that the problem is hard, just check for duplicates and maintain the order of the stream and you will be okay."
                    }
                ]
            },
            {
                "id": 1777740,
                "content": [
                    {
                        "username": "stefancomanita",
                        "content": "I solved this in the brute force manner, kept an ordered set and cycled it and created the result. Got only to beat 20% of submission but it was very easy and intuitive to code :)"
                    },
                    {
                        "username": "s1ttu",
                        "content": "3 days to go, to get the jan Batch!!"
                    },
                    {
                        "username": "wild_knight",
                        "content": "how was this hard ?"
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "This should not be under the hard category . Just sort the list and make the consecutive intervals , test cases are pretty weak ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Keep intervals sorted by start\\n2. Insert `[value, value]` interval using binary search\\n3. Try to join with nearby intervals"
                    },
                    {
                        "username": "neer3",
                        "content": "Test cases are pretty weak.\nEven any logic considering the constraint will pass."
                    },
                    {
                        "username": "rohit__27",
                        "content": "This is a easy-medium if you can get it..."
                    },
                    {
                        "username": "cookielau677",
                        "content": "Hi guys, I\\'m a bit curious about the calculation of time complexity here: [https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3107979/is-it-o-1-complexity-theoretically-why-is-this-hard/](https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3107979/is-it-o-1-complexity-theoretically-why-is-this-hard/)"
                    },
                    {
                        "username": "anoyash",
                        "content": "🔥\nI used total intuitive way, After going through the question , one thing is clear that, whenever a new data stream is coming in the \narray it should be in sorted order , So, SET  data structure will help here, because it stores the element in sorted order.\nNow, for getting interval , we can iterate over SET data structure and can create intervals using two pointers technique, start , end.\n1. every time end is greater than prev . number by 1 , end ++;\n2. if not , then push the {start , end } and re - initialise our start = end = current value; \nAlthough, its not fastest solution, but it really improves the implementation of logic.\n📈📈📈 <a href=\"https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3108117/total-intuitive-solution-but-not-the-fastest-solution/\">Click For Solution</a>"
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Intuition\\n* Sort all the incoming elements in the tree set.\\n* while implementing getIntervals() check for consecutives if elements are consecutive skip those elements\\n* else create a new interval\\n\\nDon\\'t Jump to solution directly : [solution](https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3108097/easy-java-solution-using-treeset/)"
                    }
                ]
            },
            {
                "id": 1777687,
                "content": [
                    {
                        "username": "stefancomanita",
                        "content": "I solved this in the brute force manner, kept an ordered set and cycled it and created the result. Got only to beat 20% of submission but it was very easy and intuitive to code :)"
                    },
                    {
                        "username": "s1ttu",
                        "content": "3 days to go, to get the jan Batch!!"
                    },
                    {
                        "username": "wild_knight",
                        "content": "how was this hard ?"
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "This should not be under the hard category . Just sort the list and make the consecutive intervals , test cases are pretty weak ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Keep intervals sorted by start\\n2. Insert `[value, value]` interval using binary search\\n3. Try to join with nearby intervals"
                    },
                    {
                        "username": "neer3",
                        "content": "Test cases are pretty weak.\nEven any logic considering the constraint will pass."
                    },
                    {
                        "username": "rohit__27",
                        "content": "This is a easy-medium if you can get it..."
                    },
                    {
                        "username": "cookielau677",
                        "content": "Hi guys, I\\'m a bit curious about the calculation of time complexity here: [https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3107979/is-it-o-1-complexity-theoretically-why-is-this-hard/](https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3107979/is-it-o-1-complexity-theoretically-why-is-this-hard/)"
                    },
                    {
                        "username": "anoyash",
                        "content": "🔥\nI used total intuitive way, After going through the question , one thing is clear that, whenever a new data stream is coming in the \narray it should be in sorted order , So, SET  data structure will help here, because it stores the element in sorted order.\nNow, for getting interval , we can iterate over SET data structure and can create intervals using two pointers technique, start , end.\n1. every time end is greater than prev . number by 1 , end ++;\n2. if not , then push the {start , end } and re - initialise our start = end = current value; \nAlthough, its not fastest solution, but it really improves the implementation of logic.\n📈📈📈 <a href=\"https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3108117/total-intuitive-solution-but-not-the-fastest-solution/\">Click For Solution</a>"
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Intuition\\n* Sort all the incoming elements in the tree set.\\n* while implementing getIntervals() check for consecutives if elements are consecutive skip those elements\\n* else create a new interval\\n\\nDon\\'t Jump to solution directly : [solution](https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3108097/easy-java-solution-using-treeset/)"
                    }
                ]
            },
            {
                "id": 1777625,
                "content": [
                    {
                        "username": "stefancomanita",
                        "content": "I solved this in the brute force manner, kept an ordered set and cycled it and created the result. Got only to beat 20% of submission but it was very easy and intuitive to code :)"
                    },
                    {
                        "username": "s1ttu",
                        "content": "3 days to go, to get the jan Batch!!"
                    },
                    {
                        "username": "wild_knight",
                        "content": "how was this hard ?"
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "This should not be under the hard category . Just sort the list and make the consecutive intervals , test cases are pretty weak ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Keep intervals sorted by start\\n2. Insert `[value, value]` interval using binary search\\n3. Try to join with nearby intervals"
                    },
                    {
                        "username": "neer3",
                        "content": "Test cases are pretty weak.\nEven any logic considering the constraint will pass."
                    },
                    {
                        "username": "rohit__27",
                        "content": "This is a easy-medium if you can get it..."
                    },
                    {
                        "username": "cookielau677",
                        "content": "Hi guys, I\\'m a bit curious about the calculation of time complexity here: [https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3107979/is-it-o-1-complexity-theoretically-why-is-this-hard/](https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3107979/is-it-o-1-complexity-theoretically-why-is-this-hard/)"
                    },
                    {
                        "username": "anoyash",
                        "content": "🔥\nI used total intuitive way, After going through the question , one thing is clear that, whenever a new data stream is coming in the \narray it should be in sorted order , So, SET  data structure will help here, because it stores the element in sorted order.\nNow, for getting interval , we can iterate over SET data structure and can create intervals using two pointers technique, start , end.\n1. every time end is greater than prev . number by 1 , end ++;\n2. if not , then push the {start , end } and re - initialise our start = end = current value; \nAlthough, its not fastest solution, but it really improves the implementation of logic.\n📈📈📈 <a href=\"https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3108117/total-intuitive-solution-but-not-the-fastest-solution/\">Click For Solution</a>"
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Intuition\\n* Sort all the incoming elements in the tree set.\\n* while implementing getIntervals() check for consecutives if elements are consecutive skip those elements\\n* else create a new interval\\n\\nDon\\'t Jump to solution directly : [solution](https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3108097/easy-java-solution-using-treeset/)"
                    }
                ]
            },
            {
                "id": 1777536,
                "content": [
                    {
                        "username": "stefancomanita",
                        "content": "I solved this in the brute force manner, kept an ordered set and cycled it and created the result. Got only to beat 20% of submission but it was very easy and intuitive to code :)"
                    },
                    {
                        "username": "s1ttu",
                        "content": "3 days to go, to get the jan Batch!!"
                    },
                    {
                        "username": "wild_knight",
                        "content": "how was this hard ?"
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "This should not be under the hard category . Just sort the list and make the consecutive intervals , test cases are pretty weak ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Keep intervals sorted by start\\n2. Insert `[value, value]` interval using binary search\\n3. Try to join with nearby intervals"
                    },
                    {
                        "username": "neer3",
                        "content": "Test cases are pretty weak.\nEven any logic considering the constraint will pass."
                    },
                    {
                        "username": "rohit__27",
                        "content": "This is a easy-medium if you can get it..."
                    },
                    {
                        "username": "cookielau677",
                        "content": "Hi guys, I\\'m a bit curious about the calculation of time complexity here: [https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3107979/is-it-o-1-complexity-theoretically-why-is-this-hard/](https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3107979/is-it-o-1-complexity-theoretically-why-is-this-hard/)"
                    },
                    {
                        "username": "anoyash",
                        "content": "🔥\nI used total intuitive way, After going through the question , one thing is clear that, whenever a new data stream is coming in the \narray it should be in sorted order , So, SET  data structure will help here, because it stores the element in sorted order.\nNow, for getting interval , we can iterate over SET data structure and can create intervals using two pointers technique, start , end.\n1. every time end is greater than prev . number by 1 , end ++;\n2. if not , then push the {start , end } and re - initialise our start = end = current value; \nAlthough, its not fastest solution, but it really improves the implementation of logic.\n📈📈📈 <a href=\"https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3108117/total-intuitive-solution-but-not-the-fastest-solution/\">Click For Solution</a>"
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Intuition\\n* Sort all the incoming elements in the tree set.\\n* while implementing getIntervals() check for consecutives if elements are consecutive skip those elements\\n* else create a new interval\\n\\nDon\\'t Jump to solution directly : [solution](https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3108097/easy-java-solution-using-treeset/)"
                    }
                ]
            },
            {
                "id": 1777529,
                "content": [
                    {
                        "username": "stefancomanita",
                        "content": "I solved this in the brute force manner, kept an ordered set and cycled it and created the result. Got only to beat 20% of submission but it was very easy and intuitive to code :)"
                    },
                    {
                        "username": "s1ttu",
                        "content": "3 days to go, to get the jan Batch!!"
                    },
                    {
                        "username": "wild_knight",
                        "content": "how was this hard ?"
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "This should not be under the hard category . Just sort the list and make the consecutive intervals , test cases are pretty weak ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Keep intervals sorted by start\\n2. Insert `[value, value]` interval using binary search\\n3. Try to join with nearby intervals"
                    },
                    {
                        "username": "neer3",
                        "content": "Test cases are pretty weak.\nEven any logic considering the constraint will pass."
                    },
                    {
                        "username": "rohit__27",
                        "content": "This is a easy-medium if you can get it..."
                    },
                    {
                        "username": "cookielau677",
                        "content": "Hi guys, I\\'m a bit curious about the calculation of time complexity here: [https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3107979/is-it-o-1-complexity-theoretically-why-is-this-hard/](https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3107979/is-it-o-1-complexity-theoretically-why-is-this-hard/)"
                    },
                    {
                        "username": "anoyash",
                        "content": "🔥\nI used total intuitive way, After going through the question , one thing is clear that, whenever a new data stream is coming in the \narray it should be in sorted order , So, SET  data structure will help here, because it stores the element in sorted order.\nNow, for getting interval , we can iterate over SET data structure and can create intervals using two pointers technique, start , end.\n1. every time end is greater than prev . number by 1 , end ++;\n2. if not , then push the {start , end } and re - initialise our start = end = current value; \nAlthough, its not fastest solution, but it really improves the implementation of logic.\n📈📈📈 <a href=\"https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3108117/total-intuitive-solution-but-not-the-fastest-solution/\">Click For Solution</a>"
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Intuition\\n* Sort all the incoming elements in the tree set.\\n* while implementing getIntervals() check for consecutives if elements are consecutive skip those elements\\n* else create a new interval\\n\\nDon\\'t Jump to solution directly : [solution](https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3108097/easy-java-solution-using-treeset/)"
                    }
                ]
            },
            {
                "id": 1777506,
                "content": [
                    {
                        "username": "stefancomanita",
                        "content": "I solved this in the brute force manner, kept an ordered set and cycled it and created the result. Got only to beat 20% of submission but it was very easy and intuitive to code :)"
                    },
                    {
                        "username": "s1ttu",
                        "content": "3 days to go, to get the jan Batch!!"
                    },
                    {
                        "username": "wild_knight",
                        "content": "how was this hard ?"
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "This should not be under the hard category . Just sort the list and make the consecutive intervals , test cases are pretty weak ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Keep intervals sorted by start\\n2. Insert `[value, value]` interval using binary search\\n3. Try to join with nearby intervals"
                    },
                    {
                        "username": "neer3",
                        "content": "Test cases are pretty weak.\nEven any logic considering the constraint will pass."
                    },
                    {
                        "username": "rohit__27",
                        "content": "This is a easy-medium if you can get it..."
                    },
                    {
                        "username": "cookielau677",
                        "content": "Hi guys, I\\'m a bit curious about the calculation of time complexity here: [https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3107979/is-it-o-1-complexity-theoretically-why-is-this-hard/](https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3107979/is-it-o-1-complexity-theoretically-why-is-this-hard/)"
                    },
                    {
                        "username": "anoyash",
                        "content": "🔥\nI used total intuitive way, After going through the question , one thing is clear that, whenever a new data stream is coming in the \narray it should be in sorted order , So, SET  data structure will help here, because it stores the element in sorted order.\nNow, for getting interval , we can iterate over SET data structure and can create intervals using two pointers technique, start , end.\n1. every time end is greater than prev . number by 1 , end ++;\n2. if not , then push the {start , end } and re - initialise our start = end = current value; \nAlthough, its not fastest solution, but it really improves the implementation of logic.\n📈📈📈 <a href=\"https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3108117/total-intuitive-solution-but-not-the-fastest-solution/\">Click For Solution</a>"
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Intuition\\n* Sort all the incoming elements in the tree set.\\n* while implementing getIntervals() check for consecutives if elements are consecutive skip those elements\\n* else create a new interval\\n\\nDon\\'t Jump to solution directly : [solution](https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3108097/easy-java-solution-using-treeset/)"
                    }
                ]
            },
            {
                "id": 1777489,
                "content": [
                    {
                        "username": "stefancomanita",
                        "content": "I solved this in the brute force manner, kept an ordered set and cycled it and created the result. Got only to beat 20% of submission but it was very easy and intuitive to code :)"
                    },
                    {
                        "username": "s1ttu",
                        "content": "3 days to go, to get the jan Batch!!"
                    },
                    {
                        "username": "wild_knight",
                        "content": "how was this hard ?"
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "This should not be under the hard category . Just sort the list and make the consecutive intervals , test cases are pretty weak ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Keep intervals sorted by start\\n2. Insert `[value, value]` interval using binary search\\n3. Try to join with nearby intervals"
                    },
                    {
                        "username": "neer3",
                        "content": "Test cases are pretty weak.\nEven any logic considering the constraint will pass."
                    },
                    {
                        "username": "rohit__27",
                        "content": "This is a easy-medium if you can get it..."
                    },
                    {
                        "username": "cookielau677",
                        "content": "Hi guys, I\\'m a bit curious about the calculation of time complexity here: [https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3107979/is-it-o-1-complexity-theoretically-why-is-this-hard/](https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3107979/is-it-o-1-complexity-theoretically-why-is-this-hard/)"
                    },
                    {
                        "username": "anoyash",
                        "content": "🔥\nI used total intuitive way, After going through the question , one thing is clear that, whenever a new data stream is coming in the \narray it should be in sorted order , So, SET  data structure will help here, because it stores the element in sorted order.\nNow, for getting interval , we can iterate over SET data structure and can create intervals using two pointers technique, start , end.\n1. every time end is greater than prev . number by 1 , end ++;\n2. if not , then push the {start , end } and re - initialise our start = end = current value; \nAlthough, its not fastest solution, but it really improves the implementation of logic.\n📈📈📈 <a href=\"https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3108117/total-intuitive-solution-but-not-the-fastest-solution/\">Click For Solution</a>"
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Intuition\\n* Sort all the incoming elements in the tree set.\\n* while implementing getIntervals() check for consecutives if elements are consecutive skip those elements\\n* else create a new interval\\n\\nDon\\'t Jump to solution directly : [solution](https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3108097/easy-java-solution-using-treeset/)"
                    }
                ]
            },
            {
                "id": 1777462,
                "content": [
                    {
                        "username": "stefancomanita",
                        "content": "I solved this in the brute force manner, kept an ordered set and cycled it and created the result. Got only to beat 20% of submission but it was very easy and intuitive to code :)"
                    },
                    {
                        "username": "s1ttu",
                        "content": "3 days to go, to get the jan Batch!!"
                    },
                    {
                        "username": "wild_knight",
                        "content": "how was this hard ?"
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "This should not be under the hard category . Just sort the list and make the consecutive intervals , test cases are pretty weak ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Keep intervals sorted by start\\n2. Insert `[value, value]` interval using binary search\\n3. Try to join with nearby intervals"
                    },
                    {
                        "username": "neer3",
                        "content": "Test cases are pretty weak.\nEven any logic considering the constraint will pass."
                    },
                    {
                        "username": "rohit__27",
                        "content": "This is a easy-medium if you can get it..."
                    },
                    {
                        "username": "cookielau677",
                        "content": "Hi guys, I\\'m a bit curious about the calculation of time complexity here: [https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3107979/is-it-o-1-complexity-theoretically-why-is-this-hard/](https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3107979/is-it-o-1-complexity-theoretically-why-is-this-hard/)"
                    },
                    {
                        "username": "anoyash",
                        "content": "🔥\nI used total intuitive way, After going through the question , one thing is clear that, whenever a new data stream is coming in the \narray it should be in sorted order , So, SET  data structure will help here, because it stores the element in sorted order.\nNow, for getting interval , we can iterate over SET data structure and can create intervals using two pointers technique, start , end.\n1. every time end is greater than prev . number by 1 , end ++;\n2. if not , then push the {start , end } and re - initialise our start = end = current value; \nAlthough, its not fastest solution, but it really improves the implementation of logic.\n📈📈📈 <a href=\"https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3108117/total-intuitive-solution-but-not-the-fastest-solution/\">Click For Solution</a>"
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Intuition\\n* Sort all the incoming elements in the tree set.\\n* while implementing getIntervals() check for consecutives if elements are consecutive skip those elements\\n* else create a new interval\\n\\nDon\\'t Jump to solution directly : [solution](https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3108097/easy-java-solution-using-treeset/)"
                    }
                ]
            },
            {
                "id": 1777434,
                "content": [
                    {
                        "username": "stefancomanita",
                        "content": "I solved this in the brute force manner, kept an ordered set and cycled it and created the result. Got only to beat 20% of submission but it was very easy and intuitive to code :)"
                    },
                    {
                        "username": "s1ttu",
                        "content": "3 days to go, to get the jan Batch!!"
                    },
                    {
                        "username": "wild_knight",
                        "content": "how was this hard ?"
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "This should not be under the hard category . Just sort the list and make the consecutive intervals , test cases are pretty weak ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Keep intervals sorted by start\\n2. Insert `[value, value]` interval using binary search\\n3. Try to join with nearby intervals"
                    },
                    {
                        "username": "neer3",
                        "content": "Test cases are pretty weak.\nEven any logic considering the constraint will pass."
                    },
                    {
                        "username": "rohit__27",
                        "content": "This is a easy-medium if you can get it..."
                    },
                    {
                        "username": "cookielau677",
                        "content": "Hi guys, I\\'m a bit curious about the calculation of time complexity here: [https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3107979/is-it-o-1-complexity-theoretically-why-is-this-hard/](https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3107979/is-it-o-1-complexity-theoretically-why-is-this-hard/)"
                    },
                    {
                        "username": "anoyash",
                        "content": "🔥\nI used total intuitive way, After going through the question , one thing is clear that, whenever a new data stream is coming in the \narray it should be in sorted order , So, SET  data structure will help here, because it stores the element in sorted order.\nNow, for getting interval , we can iterate over SET data structure and can create intervals using two pointers technique, start , end.\n1. every time end is greater than prev . number by 1 , end ++;\n2. if not , then push the {start , end } and re - initialise our start = end = current value; \nAlthough, its not fastest solution, but it really improves the implementation of logic.\n📈📈📈 <a href=\"https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3108117/total-intuitive-solution-but-not-the-fastest-solution/\">Click For Solution</a>"
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Intuition\\n* Sort all the incoming elements in the tree set.\\n* while implementing getIntervals() check for consecutives if elements are consecutive skip those elements\\n* else create a new interval\\n\\nDon\\'t Jump to solution directly : [solution](https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3108097/easy-java-solution-using-treeset/)"
                    }
                ]
            },
            {
                "id": 1777431,
                "content": [
                    {
                        "username": "stefancomanita",
                        "content": "I solved this in the brute force manner, kept an ordered set and cycled it and created the result. Got only to beat 20% of submission but it was very easy and intuitive to code :)"
                    },
                    {
                        "username": "s1ttu",
                        "content": "3 days to go, to get the jan Batch!!"
                    },
                    {
                        "username": "wild_knight",
                        "content": "how was this hard ?"
                    },
                    {
                        "username": "sharmashubham9810",
                        "content": "This should not be under the hard category . Just sort the list and make the consecutive intervals , test cases are pretty weak ."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "1. Keep intervals sorted by start\\n2. Insert `[value, value]` interval using binary search\\n3. Try to join with nearby intervals"
                    },
                    {
                        "username": "neer3",
                        "content": "Test cases are pretty weak.\nEven any logic considering the constraint will pass."
                    },
                    {
                        "username": "rohit__27",
                        "content": "This is a easy-medium if you can get it..."
                    },
                    {
                        "username": "cookielau677",
                        "content": "Hi guys, I\\'m a bit curious about the calculation of time complexity here: [https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3107979/is-it-o-1-complexity-theoretically-why-is-this-hard/](https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3107979/is-it-o-1-complexity-theoretically-why-is-this-hard/)"
                    },
                    {
                        "username": "anoyash",
                        "content": "🔥\nI used total intuitive way, After going through the question , one thing is clear that, whenever a new data stream is coming in the \narray it should be in sorted order , So, SET  data structure will help here, because it stores the element in sorted order.\nNow, for getting interval , we can iterate over SET data structure and can create intervals using two pointers technique, start , end.\n1. every time end is greater than prev . number by 1 , end ++;\n2. if not , then push the {start , end } and re - initialise our start = end = current value; \nAlthough, its not fastest solution, but it really improves the implementation of logic.\n📈📈📈 <a href=\"https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3108117/total-intuitive-solution-but-not-the-fastest-solution/\">Click For Solution</a>"
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Intuition\\n* Sort all the incoming elements in the tree set.\\n* while implementing getIntervals() check for consecutives if elements are consecutive skip those elements\\n* else create a new interval\\n\\nDon\\'t Jump to solution directly : [solution](https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3108097/easy-java-solution-using-treeset/)"
                    }
                ]
            },
            {
                "id": 1777390,
                "content": [
                    {
                        "username": "KautsIITD",
                        "content": "Value Range is [0,10000] only.. Hence maximum size of getIntervals is 5000.. Do you think a solution as simple as storing occurance in Bool array should pass? Given that there will be 30000 queries, It should not.. If there are 25000 getIntervals() queries..\\nI think Test cases are weak..??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@user3954sk](/user3954sk) For getIntervals() only a few languages support returning the list of list by reference, to allow time complexity faster than O(n)."
                    },
                    {
                        "username": "user3954sk",
                        "content": "O(n) for getIntervals still means O(n**2) overall. I think that if we just maintain a list (or set) of added numbers in addNum, and then sort and merge with the result it is faster if the number of ranges (r) is small.  Each getInterval call is log delta n (number of addNums since last getInterval) + (r + delta n).  That works out as O(r * n) I think."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Rather than the test cases being weak, we can just say this problem being easy.\nThe getIntervals() function will just normally take O(n) time even when using other approaches."
                    },
                    {
                        "username": "DosU",
                        "content": "If return type of GetIntervals is LinkedList then this problem going to be more interesting, cause it would be possible to write with O(logN). So they could make total count of calls to be 10^6, to make sure that Linear time solution be Timeout"
                    },
                    {
                        "username": "DosU",
                        "content": "Now I understand why most ICPC competitors use c++. Cause in c++ you can change the size of array in constant time. Am I correct?"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "For anyone struggling with daily challenge, try solving: [228. Summary Ranges](https://leetcode.com/problems/summary-ranges/) it will help you understand the question and practice a easy question. This might help build confidence to solve a \"H-A-R-D\" problem!"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "\\nwhy [1,1] [3,3] not like [1,3]\\nand also [1,1] [3,3] [7,7]  not [1,7] or [1,3] [7,7]\\n\\nwhy [1,2,3,6,7] is [1,3] [6,7]"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "They want range of continuous nums. Like 1,2, 3 = 1,3, and 1,2,4,5 = [1,2], [4,5]."
                    },
                    {
                        "username": "Jai_0710",
                        "content": "consecutive sequence only"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I used a highly intuitive lame solution and it got Accepted \\u2705\\nDescription:\\nI inserted elements into array at correct positions (by the help of lower_bound function)\\nThen, created ranges[] list using simple O(N) traversal (skipping consequent equal values)\\nThat\\'s it.\\nHappy coding \\uD83D\\uDE07\\uD83D\\uDCAA\\uD83C\\uDFFC"
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Why leetcode is uploading questions which do not have official python solution"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The only hard aspect of this one is understanding the confusing problem statement. By interval they actually mean *range of consecutive integers* (e.g. *5, 6, 7, 8*). So the task is actually to keep track of all the ranges of consecutive numbers within the set of given numbers. For each *getIntervals()* query you have to return *the endpoints* of all the ranges of consecutive numbers in the set of numbers seen up to that point."
                    },
                    {
                        "username": "li87o",
                        "content": "Boring problem. Simple algorithm and many corner cases."
                    },
                    {
                        "username": "Igor0",
                        "content": "You are quite right."
                    },
                    {
                        "username": "user8228j",
                        "content": "A good idea is to break down merging an interval into a list of intervals into its own function. (That in it self is a common leetcode medium question Merging Intervals). The Big difference you have to account for however is knowing that an \"overlap\" between two intervals occur ALSO if the difference between their distances is == 1."
                    }
                ]
            },
            {
                "id": 1777363,
                "content": [
                    {
                        "username": "KautsIITD",
                        "content": "Value Range is [0,10000] only.. Hence maximum size of getIntervals is 5000.. Do you think a solution as simple as storing occurance in Bool array should pass? Given that there will be 30000 queries, It should not.. If there are 25000 getIntervals() queries..\\nI think Test cases are weak..??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@user3954sk](/user3954sk) For getIntervals() only a few languages support returning the list of list by reference, to allow time complexity faster than O(n)."
                    },
                    {
                        "username": "user3954sk",
                        "content": "O(n) for getIntervals still means O(n**2) overall. I think that if we just maintain a list (or set) of added numbers in addNum, and then sort and merge with the result it is faster if the number of ranges (r) is small.  Each getInterval call is log delta n (number of addNums since last getInterval) + (r + delta n).  That works out as O(r * n) I think."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Rather than the test cases being weak, we can just say this problem being easy.\nThe getIntervals() function will just normally take O(n) time even when using other approaches."
                    },
                    {
                        "username": "DosU",
                        "content": "If return type of GetIntervals is LinkedList then this problem going to be more interesting, cause it would be possible to write with O(logN). So they could make total count of calls to be 10^6, to make sure that Linear time solution be Timeout"
                    },
                    {
                        "username": "DosU",
                        "content": "Now I understand why most ICPC competitors use c++. Cause in c++ you can change the size of array in constant time. Am I correct?"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "For anyone struggling with daily challenge, try solving: [228. Summary Ranges](https://leetcode.com/problems/summary-ranges/) it will help you understand the question and practice a easy question. This might help build confidence to solve a \"H-A-R-D\" problem!"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "\\nwhy [1,1] [3,3] not like [1,3]\\nand also [1,1] [3,3] [7,7]  not [1,7] or [1,3] [7,7]\\n\\nwhy [1,2,3,6,7] is [1,3] [6,7]"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "They want range of continuous nums. Like 1,2, 3 = 1,3, and 1,2,4,5 = [1,2], [4,5]."
                    },
                    {
                        "username": "Jai_0710",
                        "content": "consecutive sequence only"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I used a highly intuitive lame solution and it got Accepted \\u2705\\nDescription:\\nI inserted elements into array at correct positions (by the help of lower_bound function)\\nThen, created ranges[] list using simple O(N) traversal (skipping consequent equal values)\\nThat\\'s it.\\nHappy coding \\uD83D\\uDE07\\uD83D\\uDCAA\\uD83C\\uDFFC"
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Why leetcode is uploading questions which do not have official python solution"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The only hard aspect of this one is understanding the confusing problem statement. By interval they actually mean *range of consecutive integers* (e.g. *5, 6, 7, 8*). So the task is actually to keep track of all the ranges of consecutive numbers within the set of given numbers. For each *getIntervals()* query you have to return *the endpoints* of all the ranges of consecutive numbers in the set of numbers seen up to that point."
                    },
                    {
                        "username": "li87o",
                        "content": "Boring problem. Simple algorithm and many corner cases."
                    },
                    {
                        "username": "Igor0",
                        "content": "You are quite right."
                    },
                    {
                        "username": "user8228j",
                        "content": "A good idea is to break down merging an interval into a list of intervals into its own function. (That in it self is a common leetcode medium question Merging Intervals). The Big difference you have to account for however is knowing that an \"overlap\" between two intervals occur ALSO if the difference between their distances is == 1."
                    }
                ]
            },
            {
                "id": 1777338,
                "content": [
                    {
                        "username": "KautsIITD",
                        "content": "Value Range is [0,10000] only.. Hence maximum size of getIntervals is 5000.. Do you think a solution as simple as storing occurance in Bool array should pass? Given that there will be 30000 queries, It should not.. If there are 25000 getIntervals() queries..\\nI think Test cases are weak..??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@user3954sk](/user3954sk) For getIntervals() only a few languages support returning the list of list by reference, to allow time complexity faster than O(n)."
                    },
                    {
                        "username": "user3954sk",
                        "content": "O(n) for getIntervals still means O(n**2) overall. I think that if we just maintain a list (or set) of added numbers in addNum, and then sort and merge with the result it is faster if the number of ranges (r) is small.  Each getInterval call is log delta n (number of addNums since last getInterval) + (r + delta n).  That works out as O(r * n) I think."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Rather than the test cases being weak, we can just say this problem being easy.\nThe getIntervals() function will just normally take O(n) time even when using other approaches."
                    },
                    {
                        "username": "DosU",
                        "content": "If return type of GetIntervals is LinkedList then this problem going to be more interesting, cause it would be possible to write with O(logN). So they could make total count of calls to be 10^6, to make sure that Linear time solution be Timeout"
                    },
                    {
                        "username": "DosU",
                        "content": "Now I understand why most ICPC competitors use c++. Cause in c++ you can change the size of array in constant time. Am I correct?"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "For anyone struggling with daily challenge, try solving: [228. Summary Ranges](https://leetcode.com/problems/summary-ranges/) it will help you understand the question and practice a easy question. This might help build confidence to solve a \"H-A-R-D\" problem!"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "\\nwhy [1,1] [3,3] not like [1,3]\\nand also [1,1] [3,3] [7,7]  not [1,7] or [1,3] [7,7]\\n\\nwhy [1,2,3,6,7] is [1,3] [6,7]"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "They want range of continuous nums. Like 1,2, 3 = 1,3, and 1,2,4,5 = [1,2], [4,5]."
                    },
                    {
                        "username": "Jai_0710",
                        "content": "consecutive sequence only"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I used a highly intuitive lame solution and it got Accepted \\u2705\\nDescription:\\nI inserted elements into array at correct positions (by the help of lower_bound function)\\nThen, created ranges[] list using simple O(N) traversal (skipping consequent equal values)\\nThat\\'s it.\\nHappy coding \\uD83D\\uDE07\\uD83D\\uDCAA\\uD83C\\uDFFC"
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Why leetcode is uploading questions which do not have official python solution"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The only hard aspect of this one is understanding the confusing problem statement. By interval they actually mean *range of consecutive integers* (e.g. *5, 6, 7, 8*). So the task is actually to keep track of all the ranges of consecutive numbers within the set of given numbers. For each *getIntervals()* query you have to return *the endpoints* of all the ranges of consecutive numbers in the set of numbers seen up to that point."
                    },
                    {
                        "username": "li87o",
                        "content": "Boring problem. Simple algorithm and many corner cases."
                    },
                    {
                        "username": "Igor0",
                        "content": "You are quite right."
                    },
                    {
                        "username": "user8228j",
                        "content": "A good idea is to break down merging an interval into a list of intervals into its own function. (That in it self is a common leetcode medium question Merging Intervals). The Big difference you have to account for however is knowing that an \"overlap\" between two intervals occur ALSO if the difference between their distances is == 1."
                    }
                ]
            },
            {
                "id": 1777325,
                "content": [
                    {
                        "username": "KautsIITD",
                        "content": "Value Range is [0,10000] only.. Hence maximum size of getIntervals is 5000.. Do you think a solution as simple as storing occurance in Bool array should pass? Given that there will be 30000 queries, It should not.. If there are 25000 getIntervals() queries..\\nI think Test cases are weak..??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@user3954sk](/user3954sk) For getIntervals() only a few languages support returning the list of list by reference, to allow time complexity faster than O(n)."
                    },
                    {
                        "username": "user3954sk",
                        "content": "O(n) for getIntervals still means O(n**2) overall. I think that if we just maintain a list (or set) of added numbers in addNum, and then sort and merge with the result it is faster if the number of ranges (r) is small.  Each getInterval call is log delta n (number of addNums since last getInterval) + (r + delta n).  That works out as O(r * n) I think."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Rather than the test cases being weak, we can just say this problem being easy.\nThe getIntervals() function will just normally take O(n) time even when using other approaches."
                    },
                    {
                        "username": "DosU",
                        "content": "If return type of GetIntervals is LinkedList then this problem going to be more interesting, cause it would be possible to write with O(logN). So they could make total count of calls to be 10^6, to make sure that Linear time solution be Timeout"
                    },
                    {
                        "username": "DosU",
                        "content": "Now I understand why most ICPC competitors use c++. Cause in c++ you can change the size of array in constant time. Am I correct?"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "For anyone struggling with daily challenge, try solving: [228. Summary Ranges](https://leetcode.com/problems/summary-ranges/) it will help you understand the question and practice a easy question. This might help build confidence to solve a \"H-A-R-D\" problem!"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "\\nwhy [1,1] [3,3] not like [1,3]\\nand also [1,1] [3,3] [7,7]  not [1,7] or [1,3] [7,7]\\n\\nwhy [1,2,3,6,7] is [1,3] [6,7]"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "They want range of continuous nums. Like 1,2, 3 = 1,3, and 1,2,4,5 = [1,2], [4,5]."
                    },
                    {
                        "username": "Jai_0710",
                        "content": "consecutive sequence only"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I used a highly intuitive lame solution and it got Accepted \\u2705\\nDescription:\\nI inserted elements into array at correct positions (by the help of lower_bound function)\\nThen, created ranges[] list using simple O(N) traversal (skipping consequent equal values)\\nThat\\'s it.\\nHappy coding \\uD83D\\uDE07\\uD83D\\uDCAA\\uD83C\\uDFFC"
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Why leetcode is uploading questions which do not have official python solution"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The only hard aspect of this one is understanding the confusing problem statement. By interval they actually mean *range of consecutive integers* (e.g. *5, 6, 7, 8*). So the task is actually to keep track of all the ranges of consecutive numbers within the set of given numbers. For each *getIntervals()* query you have to return *the endpoints* of all the ranges of consecutive numbers in the set of numbers seen up to that point."
                    },
                    {
                        "username": "li87o",
                        "content": "Boring problem. Simple algorithm and many corner cases."
                    },
                    {
                        "username": "Igor0",
                        "content": "You are quite right."
                    },
                    {
                        "username": "user8228j",
                        "content": "A good idea is to break down merging an interval into a list of intervals into its own function. (That in it self is a common leetcode medium question Merging Intervals). The Big difference you have to account for however is knowing that an \"overlap\" between two intervals occur ALSO if the difference between their distances is == 1."
                    }
                ]
            },
            {
                "id": 1777314,
                "content": [
                    {
                        "username": "KautsIITD",
                        "content": "Value Range is [0,10000] only.. Hence maximum size of getIntervals is 5000.. Do you think a solution as simple as storing occurance in Bool array should pass? Given that there will be 30000 queries, It should not.. If there are 25000 getIntervals() queries..\\nI think Test cases are weak..??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@user3954sk](/user3954sk) For getIntervals() only a few languages support returning the list of list by reference, to allow time complexity faster than O(n)."
                    },
                    {
                        "username": "user3954sk",
                        "content": "O(n) for getIntervals still means O(n**2) overall. I think that if we just maintain a list (or set) of added numbers in addNum, and then sort and merge with the result it is faster if the number of ranges (r) is small.  Each getInterval call is log delta n (number of addNums since last getInterval) + (r + delta n).  That works out as O(r * n) I think."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Rather than the test cases being weak, we can just say this problem being easy.\nThe getIntervals() function will just normally take O(n) time even when using other approaches."
                    },
                    {
                        "username": "DosU",
                        "content": "If return type of GetIntervals is LinkedList then this problem going to be more interesting, cause it would be possible to write with O(logN). So they could make total count of calls to be 10^6, to make sure that Linear time solution be Timeout"
                    },
                    {
                        "username": "DosU",
                        "content": "Now I understand why most ICPC competitors use c++. Cause in c++ you can change the size of array in constant time. Am I correct?"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "For anyone struggling with daily challenge, try solving: [228. Summary Ranges](https://leetcode.com/problems/summary-ranges/) it will help you understand the question and practice a easy question. This might help build confidence to solve a \"H-A-R-D\" problem!"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "\\nwhy [1,1] [3,3] not like [1,3]\\nand also [1,1] [3,3] [7,7]  not [1,7] or [1,3] [7,7]\\n\\nwhy [1,2,3,6,7] is [1,3] [6,7]"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "They want range of continuous nums. Like 1,2, 3 = 1,3, and 1,2,4,5 = [1,2], [4,5]."
                    },
                    {
                        "username": "Jai_0710",
                        "content": "consecutive sequence only"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I used a highly intuitive lame solution and it got Accepted \\u2705\\nDescription:\\nI inserted elements into array at correct positions (by the help of lower_bound function)\\nThen, created ranges[] list using simple O(N) traversal (skipping consequent equal values)\\nThat\\'s it.\\nHappy coding \\uD83D\\uDE07\\uD83D\\uDCAA\\uD83C\\uDFFC"
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Why leetcode is uploading questions which do not have official python solution"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The only hard aspect of this one is understanding the confusing problem statement. By interval they actually mean *range of consecutive integers* (e.g. *5, 6, 7, 8*). So the task is actually to keep track of all the ranges of consecutive numbers within the set of given numbers. For each *getIntervals()* query you have to return *the endpoints* of all the ranges of consecutive numbers in the set of numbers seen up to that point."
                    },
                    {
                        "username": "li87o",
                        "content": "Boring problem. Simple algorithm and many corner cases."
                    },
                    {
                        "username": "Igor0",
                        "content": "You are quite right."
                    },
                    {
                        "username": "user8228j",
                        "content": "A good idea is to break down merging an interval into a list of intervals into its own function. (That in it self is a common leetcode medium question Merging Intervals). The Big difference you have to account for however is knowing that an \"overlap\" between two intervals occur ALSO if the difference between their distances is == 1."
                    }
                ]
            },
            {
                "id": 1777265,
                "content": [
                    {
                        "username": "KautsIITD",
                        "content": "Value Range is [0,10000] only.. Hence maximum size of getIntervals is 5000.. Do you think a solution as simple as storing occurance in Bool array should pass? Given that there will be 30000 queries, It should not.. If there are 25000 getIntervals() queries..\\nI think Test cases are weak..??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@user3954sk](/user3954sk) For getIntervals() only a few languages support returning the list of list by reference, to allow time complexity faster than O(n)."
                    },
                    {
                        "username": "user3954sk",
                        "content": "O(n) for getIntervals still means O(n**2) overall. I think that if we just maintain a list (or set) of added numbers in addNum, and then sort and merge with the result it is faster if the number of ranges (r) is small.  Each getInterval call is log delta n (number of addNums since last getInterval) + (r + delta n).  That works out as O(r * n) I think."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Rather than the test cases being weak, we can just say this problem being easy.\nThe getIntervals() function will just normally take O(n) time even when using other approaches."
                    },
                    {
                        "username": "DosU",
                        "content": "If return type of GetIntervals is LinkedList then this problem going to be more interesting, cause it would be possible to write with O(logN). So they could make total count of calls to be 10^6, to make sure that Linear time solution be Timeout"
                    },
                    {
                        "username": "DosU",
                        "content": "Now I understand why most ICPC competitors use c++. Cause in c++ you can change the size of array in constant time. Am I correct?"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "For anyone struggling with daily challenge, try solving: [228. Summary Ranges](https://leetcode.com/problems/summary-ranges/) it will help you understand the question and practice a easy question. This might help build confidence to solve a \"H-A-R-D\" problem!"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "\\nwhy [1,1] [3,3] not like [1,3]\\nand also [1,1] [3,3] [7,7]  not [1,7] or [1,3] [7,7]\\n\\nwhy [1,2,3,6,7] is [1,3] [6,7]"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "They want range of continuous nums. Like 1,2, 3 = 1,3, and 1,2,4,5 = [1,2], [4,5]."
                    },
                    {
                        "username": "Jai_0710",
                        "content": "consecutive sequence only"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I used a highly intuitive lame solution and it got Accepted \\u2705\\nDescription:\\nI inserted elements into array at correct positions (by the help of lower_bound function)\\nThen, created ranges[] list using simple O(N) traversal (skipping consequent equal values)\\nThat\\'s it.\\nHappy coding \\uD83D\\uDE07\\uD83D\\uDCAA\\uD83C\\uDFFC"
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Why leetcode is uploading questions which do not have official python solution"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The only hard aspect of this one is understanding the confusing problem statement. By interval they actually mean *range of consecutive integers* (e.g. *5, 6, 7, 8*). So the task is actually to keep track of all the ranges of consecutive numbers within the set of given numbers. For each *getIntervals()* query you have to return *the endpoints* of all the ranges of consecutive numbers in the set of numbers seen up to that point."
                    },
                    {
                        "username": "li87o",
                        "content": "Boring problem. Simple algorithm and many corner cases."
                    },
                    {
                        "username": "Igor0",
                        "content": "You are quite right."
                    },
                    {
                        "username": "user8228j",
                        "content": "A good idea is to break down merging an interval into a list of intervals into its own function. (That in it self is a common leetcode medium question Merging Intervals). The Big difference you have to account for however is knowing that an \"overlap\" between two intervals occur ALSO if the difference between their distances is == 1."
                    }
                ]
            },
            {
                "id": 1777210,
                "content": [
                    {
                        "username": "KautsIITD",
                        "content": "Value Range is [0,10000] only.. Hence maximum size of getIntervals is 5000.. Do you think a solution as simple as storing occurance in Bool array should pass? Given that there will be 30000 queries, It should not.. If there are 25000 getIntervals() queries..\\nI think Test cases are weak..??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@user3954sk](/user3954sk) For getIntervals() only a few languages support returning the list of list by reference, to allow time complexity faster than O(n)."
                    },
                    {
                        "username": "user3954sk",
                        "content": "O(n) for getIntervals still means O(n**2) overall. I think that if we just maintain a list (or set) of added numbers in addNum, and then sort and merge with the result it is faster if the number of ranges (r) is small.  Each getInterval call is log delta n (number of addNums since last getInterval) + (r + delta n).  That works out as O(r * n) I think."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Rather than the test cases being weak, we can just say this problem being easy.\nThe getIntervals() function will just normally take O(n) time even when using other approaches."
                    },
                    {
                        "username": "DosU",
                        "content": "If return type of GetIntervals is LinkedList then this problem going to be more interesting, cause it would be possible to write with O(logN). So they could make total count of calls to be 10^6, to make sure that Linear time solution be Timeout"
                    },
                    {
                        "username": "DosU",
                        "content": "Now I understand why most ICPC competitors use c++. Cause in c++ you can change the size of array in constant time. Am I correct?"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "For anyone struggling with daily challenge, try solving: [228. Summary Ranges](https://leetcode.com/problems/summary-ranges/) it will help you understand the question and practice a easy question. This might help build confidence to solve a \"H-A-R-D\" problem!"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "\\nwhy [1,1] [3,3] not like [1,3]\\nand also [1,1] [3,3] [7,7]  not [1,7] or [1,3] [7,7]\\n\\nwhy [1,2,3,6,7] is [1,3] [6,7]"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "They want range of continuous nums. Like 1,2, 3 = 1,3, and 1,2,4,5 = [1,2], [4,5]."
                    },
                    {
                        "username": "Jai_0710",
                        "content": "consecutive sequence only"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I used a highly intuitive lame solution and it got Accepted \\u2705\\nDescription:\\nI inserted elements into array at correct positions (by the help of lower_bound function)\\nThen, created ranges[] list using simple O(N) traversal (skipping consequent equal values)\\nThat\\'s it.\\nHappy coding \\uD83D\\uDE07\\uD83D\\uDCAA\\uD83C\\uDFFC"
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Why leetcode is uploading questions which do not have official python solution"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The only hard aspect of this one is understanding the confusing problem statement. By interval they actually mean *range of consecutive integers* (e.g. *5, 6, 7, 8*). So the task is actually to keep track of all the ranges of consecutive numbers within the set of given numbers. For each *getIntervals()* query you have to return *the endpoints* of all the ranges of consecutive numbers in the set of numbers seen up to that point."
                    },
                    {
                        "username": "li87o",
                        "content": "Boring problem. Simple algorithm and many corner cases."
                    },
                    {
                        "username": "Igor0",
                        "content": "You are quite right."
                    },
                    {
                        "username": "user8228j",
                        "content": "A good idea is to break down merging an interval into a list of intervals into its own function. (That in it self is a common leetcode medium question Merging Intervals). The Big difference you have to account for however is knowing that an \"overlap\" between two intervals occur ALSO if the difference between their distances is == 1."
                    }
                ]
            },
            {
                "id": 1777199,
                "content": [
                    {
                        "username": "KautsIITD",
                        "content": "Value Range is [0,10000] only.. Hence maximum size of getIntervals is 5000.. Do you think a solution as simple as storing occurance in Bool array should pass? Given that there will be 30000 queries, It should not.. If there are 25000 getIntervals() queries..\\nI think Test cases are weak..??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@user3954sk](/user3954sk) For getIntervals() only a few languages support returning the list of list by reference, to allow time complexity faster than O(n)."
                    },
                    {
                        "username": "user3954sk",
                        "content": "O(n) for getIntervals still means O(n**2) overall. I think that if we just maintain a list (or set) of added numbers in addNum, and then sort and merge with the result it is faster if the number of ranges (r) is small.  Each getInterval call is log delta n (number of addNums since last getInterval) + (r + delta n).  That works out as O(r * n) I think."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Rather than the test cases being weak, we can just say this problem being easy.\nThe getIntervals() function will just normally take O(n) time even when using other approaches."
                    },
                    {
                        "username": "DosU",
                        "content": "If return type of GetIntervals is LinkedList then this problem going to be more interesting, cause it would be possible to write with O(logN). So they could make total count of calls to be 10^6, to make sure that Linear time solution be Timeout"
                    },
                    {
                        "username": "DosU",
                        "content": "Now I understand why most ICPC competitors use c++. Cause in c++ you can change the size of array in constant time. Am I correct?"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "For anyone struggling with daily challenge, try solving: [228. Summary Ranges](https://leetcode.com/problems/summary-ranges/) it will help you understand the question and practice a easy question. This might help build confidence to solve a \"H-A-R-D\" problem!"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "\\nwhy [1,1] [3,3] not like [1,3]\\nand also [1,1] [3,3] [7,7]  not [1,7] or [1,3] [7,7]\\n\\nwhy [1,2,3,6,7] is [1,3] [6,7]"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "They want range of continuous nums. Like 1,2, 3 = 1,3, and 1,2,4,5 = [1,2], [4,5]."
                    },
                    {
                        "username": "Jai_0710",
                        "content": "consecutive sequence only"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I used a highly intuitive lame solution and it got Accepted \\u2705\\nDescription:\\nI inserted elements into array at correct positions (by the help of lower_bound function)\\nThen, created ranges[] list using simple O(N) traversal (skipping consequent equal values)\\nThat\\'s it.\\nHappy coding \\uD83D\\uDE07\\uD83D\\uDCAA\\uD83C\\uDFFC"
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Why leetcode is uploading questions which do not have official python solution"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The only hard aspect of this one is understanding the confusing problem statement. By interval they actually mean *range of consecutive integers* (e.g. *5, 6, 7, 8*). So the task is actually to keep track of all the ranges of consecutive numbers within the set of given numbers. For each *getIntervals()* query you have to return *the endpoints* of all the ranges of consecutive numbers in the set of numbers seen up to that point."
                    },
                    {
                        "username": "li87o",
                        "content": "Boring problem. Simple algorithm and many corner cases."
                    },
                    {
                        "username": "Igor0",
                        "content": "You are quite right."
                    },
                    {
                        "username": "user8228j",
                        "content": "A good idea is to break down merging an interval into a list of intervals into its own function. (That in it self is a common leetcode medium question Merging Intervals). The Big difference you have to account for however is knowing that an \"overlap\" between two intervals occur ALSO if the difference between their distances is == 1."
                    }
                ]
            },
            {
                "id": 1777194,
                "content": [
                    {
                        "username": "KautsIITD",
                        "content": "Value Range is [0,10000] only.. Hence maximum size of getIntervals is 5000.. Do you think a solution as simple as storing occurance in Bool array should pass? Given that there will be 30000 queries, It should not.. If there are 25000 getIntervals() queries..\\nI think Test cases are weak..??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@user3954sk](/user3954sk) For getIntervals() only a few languages support returning the list of list by reference, to allow time complexity faster than O(n)."
                    },
                    {
                        "username": "user3954sk",
                        "content": "O(n) for getIntervals still means O(n**2) overall. I think that if we just maintain a list (or set) of added numbers in addNum, and then sort and merge with the result it is faster if the number of ranges (r) is small.  Each getInterval call is log delta n (number of addNums since last getInterval) + (r + delta n).  That works out as O(r * n) I think."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Rather than the test cases being weak, we can just say this problem being easy.\nThe getIntervals() function will just normally take O(n) time even when using other approaches."
                    },
                    {
                        "username": "DosU",
                        "content": "If return type of GetIntervals is LinkedList then this problem going to be more interesting, cause it would be possible to write with O(logN). So they could make total count of calls to be 10^6, to make sure that Linear time solution be Timeout"
                    },
                    {
                        "username": "DosU",
                        "content": "Now I understand why most ICPC competitors use c++. Cause in c++ you can change the size of array in constant time. Am I correct?"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "For anyone struggling with daily challenge, try solving: [228. Summary Ranges](https://leetcode.com/problems/summary-ranges/) it will help you understand the question and practice a easy question. This might help build confidence to solve a \"H-A-R-D\" problem!"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "\\nwhy [1,1] [3,3] not like [1,3]\\nand also [1,1] [3,3] [7,7]  not [1,7] or [1,3] [7,7]\\n\\nwhy [1,2,3,6,7] is [1,3] [6,7]"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "They want range of continuous nums. Like 1,2, 3 = 1,3, and 1,2,4,5 = [1,2], [4,5]."
                    },
                    {
                        "username": "Jai_0710",
                        "content": "consecutive sequence only"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I used a highly intuitive lame solution and it got Accepted \\u2705\\nDescription:\\nI inserted elements into array at correct positions (by the help of lower_bound function)\\nThen, created ranges[] list using simple O(N) traversal (skipping consequent equal values)\\nThat\\'s it.\\nHappy coding \\uD83D\\uDE07\\uD83D\\uDCAA\\uD83C\\uDFFC"
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Why leetcode is uploading questions which do not have official python solution"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The only hard aspect of this one is understanding the confusing problem statement. By interval they actually mean *range of consecutive integers* (e.g. *5, 6, 7, 8*). So the task is actually to keep track of all the ranges of consecutive numbers within the set of given numbers. For each *getIntervals()* query you have to return *the endpoints* of all the ranges of consecutive numbers in the set of numbers seen up to that point."
                    },
                    {
                        "username": "li87o",
                        "content": "Boring problem. Simple algorithm and many corner cases."
                    },
                    {
                        "username": "Igor0",
                        "content": "You are quite right."
                    },
                    {
                        "username": "user8228j",
                        "content": "A good idea is to break down merging an interval into a list of intervals into its own function. (That in it self is a common leetcode medium question Merging Intervals). The Big difference you have to account for however is knowing that an \"overlap\" between two intervals occur ALSO if the difference between their distances is == 1."
                    }
                ]
            },
            {
                "id": 1777182,
                "content": [
                    {
                        "username": "KautsIITD",
                        "content": "Value Range is [0,10000] only.. Hence maximum size of getIntervals is 5000.. Do you think a solution as simple as storing occurance in Bool array should pass? Given that there will be 30000 queries, It should not.. If there are 25000 getIntervals() queries..\\nI think Test cases are weak..??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@user3954sk](/user3954sk) For getIntervals() only a few languages support returning the list of list by reference, to allow time complexity faster than O(n)."
                    },
                    {
                        "username": "user3954sk",
                        "content": "O(n) for getIntervals still means O(n**2) overall. I think that if we just maintain a list (or set) of added numbers in addNum, and then sort and merge with the result it is faster if the number of ranges (r) is small.  Each getInterval call is log delta n (number of addNums since last getInterval) + (r + delta n).  That works out as O(r * n) I think."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Rather than the test cases being weak, we can just say this problem being easy.\nThe getIntervals() function will just normally take O(n) time even when using other approaches."
                    },
                    {
                        "username": "DosU",
                        "content": "If return type of GetIntervals is LinkedList then this problem going to be more interesting, cause it would be possible to write with O(logN). So they could make total count of calls to be 10^6, to make sure that Linear time solution be Timeout"
                    },
                    {
                        "username": "DosU",
                        "content": "Now I understand why most ICPC competitors use c++. Cause in c++ you can change the size of array in constant time. Am I correct?"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "For anyone struggling with daily challenge, try solving: [228. Summary Ranges](https://leetcode.com/problems/summary-ranges/) it will help you understand the question and practice a easy question. This might help build confidence to solve a \"H-A-R-D\" problem!"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "\\nwhy [1,1] [3,3] not like [1,3]\\nand also [1,1] [3,3] [7,7]  not [1,7] or [1,3] [7,7]\\n\\nwhy [1,2,3,6,7] is [1,3] [6,7]"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "They want range of continuous nums. Like 1,2, 3 = 1,3, and 1,2,4,5 = [1,2], [4,5]."
                    },
                    {
                        "username": "Jai_0710",
                        "content": "consecutive sequence only"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I used a highly intuitive lame solution and it got Accepted \\u2705\\nDescription:\\nI inserted elements into array at correct positions (by the help of lower_bound function)\\nThen, created ranges[] list using simple O(N) traversal (skipping consequent equal values)\\nThat\\'s it.\\nHappy coding \\uD83D\\uDE07\\uD83D\\uDCAA\\uD83C\\uDFFC"
                    },
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Why leetcode is uploading questions which do not have official python solution"
                    },
                    {
                        "username": "Electron1997",
                        "content": "The only hard aspect of this one is understanding the confusing problem statement. By interval they actually mean *range of consecutive integers* (e.g. *5, 6, 7, 8*). So the task is actually to keep track of all the ranges of consecutive numbers within the set of given numbers. For each *getIntervals()* query you have to return *the endpoints* of all the ranges of consecutive numbers in the set of numbers seen up to that point."
                    },
                    {
                        "username": "li87o",
                        "content": "Boring problem. Simple algorithm and many corner cases."
                    },
                    {
                        "username": "Igor0",
                        "content": "You are quite right."
                    },
                    {
                        "username": "user8228j",
                        "content": "A good idea is to break down merging an interval into a list of intervals into its own function. (That in it self is a common leetcode medium question Merging Intervals). The Big difference you have to account for however is knowing that an \"overlap\" between two intervals occur ALSO if the difference between their distances is == 1."
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Number of Arrows to Burst Balloons",
        "question_content": "<p>There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array <code>points</code> where <code>points[i] = [x<sub>start</sub>, x<sub>end</sub>]</code> denotes a balloon whose <strong>horizontal diameter</strong> stretches between <code>x<sub>start</sub></code> and <code>x<sub>end</sub></code>. You do not know the exact y-coordinates of the balloons.</p>\n\n<p>Arrows can be shot up <strong>directly vertically</strong> (in the positive y-direction) from different points along the x-axis. A balloon with <code>x<sub>start</sub></code> and <code>x<sub>end</sub></code> is <strong>burst</strong> by an arrow shot at <code>x</code> if <code>x<sub>start</sub> &lt;= x &lt;= x<sub>end</sub></code>. There is <strong>no limit</strong> to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.</p>\n\n<p>Given the array <code>points</code>, return <em>the <strong>minimum</strong> number of arrows that must be shot to burst all balloons</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> points = [[10,16],[2,8],[1,6],[7,12]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].\n- Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> points = [[1,2],[3,4],[5,6],[7,8]]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> One arrow needs to be shot for each balloon for a total of 4 arrows.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> points = [[1,2],[2,3],[3,4],[4,5]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].\n- Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= points.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= x<sub>start</sub> &lt; x<sub>end</sub> &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 93703,
                "title": "share-my-explained-greedy-solution",
                "content": "No offense but the currently highest voted java solution is not ideal, the sorting can be adjusted so that there\\'s no need to check again in the for loop.\\n\\n**Idea:**\\nWe know that eventually we have to shoot down every balloon, so for each ballon there must be an arrow whose position is between **balloon[0]** and **balloon[1]** inclusively. Given that, we can sort the array of balloons by their **ending position**. Then we make sure that **while we take care of each balloon in order, we can shoot as many following balloons as possible.**\\n\\nSo what position should we pick each time? We should shoot as to the right as possible, because since balloons are sorted, this gives you the best chance to take down more balloons. Therefore the position should always be **balloon[i][1]** for the *i*th balloon.\\n\\nThis is exactly what I do in the for loop: check how many balloons I can shoot down with one shot aiming at the **ending position of the current balloon**. Then I skip all these balloons and start again from the next one (or the leftmost remaining one) that needs another arrow.\\n\\n\\n**Example:**\\n```\\nballoons = [[7,10], [1,5], [3,6], [2,4], [1,4]]\\n```\\nAfter sorting, it becomes:\\n```\\nballoons = [[2,4], [1,4], [1,5], [3,6], [7,10]]\\n```\\nSo first of all, we shoot at position **4**, we go through the array and see that all first 4 balloons can be taken care of by this single shot. Then we need another shot for one last balloon. So the result should be 2.\\n<br>\\n\\n\\n**Code:**\\n```\\npublic int findMinArrowShots(int[][] points) {\\n        if (points.length == 0) {\\n            return 0;\\n        }\\n        Arrays.sort(points, (a, b) -> a[1] - b[1]);\\n        int arrowPos = points[0][1];\\n        int arrowCnt = 1;\\n        for (int i = 1; i < points.length; i++) {\\n            if (arrowPos >= points[i][0]) {\\n                continue;\\n            }\\n            arrowCnt++;\\n            arrowPos = points[i][1];\\n        }\\n        return arrowCnt;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nballoons = [[7,10], [1,5], [3,6], [2,4], [1,4]]\\n```\n```\\nballoons = [[2,4], [1,4], [1,5], [3,6], [7,10]]\\n```\n```\\npublic int findMinArrowShots(int[][] points) {\\n        if (points.length == 0) {\\n            return 0;\\n        }\\n        Arrays.sort(points, (a, b) -> a[1] - b[1]);\\n        int arrowPos = points[0][1];\\n        int arrowCnt = 1;\\n        for (int i = 1; i < points.length; i++) {\\n            if (arrowPos >= points[i][0]) {\\n                continue;\\n            }\\n            arrowCnt++;\\n            arrowPos = points[i][1];\\n        }\\n        return arrowCnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 93735,
                "title": "a-concise-template-for-overlapping-interval-problem",
                "content": "Here I provide a concise template that I summarize for the so-called \"Overlapping Interval Problem\", e.g. Minimum Number of Arrows to Burst Balloons, and Non-overlapping Intervals etc. I found these problems share some similarities on their solutions.\\n* Sort intervals/pairs in increasing order of the start position.\\n* Scan the sorted intervals, and maintain an \"active set\" for overlapping intervals. At most times, we do not need to use an explicit set to store them. Instead, we just need to maintain several key parameters, e.g. the number of overlapping intervals (count), the minimum ending point among all overlapping intervals (minEnd). \\n* If the interval that we are currently checking overlaps with the active set, which can be characterized by cur.start > minEnd, we need to renew those key parameters or change some states.\\n* If the current interval does not overlap with the active set, we just drop current active set, record some parameters, and create a new active set that contains the current interval.\\n```\\nint count = 0; // Global parameters that are useful for results.\\nint minEnd = INT_MAX; // Key parameters characterizing the \"active set\" for overlapping intervals, e.g. the minimum ending point among all overlapping intervals.\\nsort(points.begin(), points.end()); // Sorting the intervals/pairs in ascending order of its starting point\\nfor each interval {\\n      if(interval.start > minEnd) { // If the \\n\\t // changing some states, record some information, and start a new active set. \\n\\tcount++;\\n\\tminEnd = p.second;\\n      }\\n     else {\\n\\t// renew key parameters of the active set\\n\\tminEnd = min(minEnd, p.second);\\n      } \\n }\\nreturn the result recorded in or calculated from the global information;\\n```\\n\\nFor example, for the problem Minimum \"**Number of Arrows to Burst Balloons**\", we have\\n* Sort balloons in increasing order of the start position.\\n* Scan the sorted pairs, and maintain a pointer for the minimum end position for current \"active balloons\", whose diameters are overlapping. \\n* When the next balloon starts after all active balloons, shoot an arrow to burst all active balloons, and start to record next active balloons.\\n\\n```\\nint findMinArrowShots(vector<pair<int, int>>& points) {\\n        int count = 0, minEnd = INT_MAX;\\n        sort(points.begin(), points.end());\\n        for(auto& p: points) {\\n            if(p.first > minEnd) {count++; minEnd = p.second;}\\n            else minEnd = min(minEnd, p.second);\\n        }\\n        return count + !points.empty();\\n    }\\n```\\n\\nFor the problem \"**Non-overlapping Intervals**\", we have\\n```\\nint eraseOverlapIntervals(vector<Interval>& intervals) {\\n        int total = 0, minEnd = INT_MIN, overNb = 1;\\n        sort(intervals.begin(), intervals.end(), [&](Interval& inter1, Interval& inter2) {return inter1.start < inter2.start;});\\n        for(auto& p: intervals) {\\n            if(p.start >= minEnd) {\\n                total += overNb-1;\\n                overNb = 1;\\n                minEnd = p.end;\\n            }\\n            else {\\n                overNb++;\\n                minEnd = min(minEnd, p.end);\\n            }\\n        }\\n        return total + overNb-1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint count = 0; // Global parameters that are useful for results.\\nint minEnd = INT_MAX; // Key parameters characterizing the \"active set\" for overlapping intervals, e.g. the minimum ending point among all overlapping intervals.\\nsort(points.begin(), points.end()); // Sorting the intervals/pairs in ascending order of its starting point\\nfor each interval {\\n      if(interval.start > minEnd) { // If the \\n\\t // changing some states, record some information, and start a new active set. \\n\\tcount++;\\n\\tminEnd = p.second;\\n      }\\n     else {\\n\\t// renew key parameters of the active set\\n\\tminEnd = min(minEnd, p.second);\\n      } \\n }\\nreturn the result recorded in or calculated from the global information;\\n```\n```\\nint findMinArrowShots(vector<pair<int, int>>& points) {\\n        int count = 0, minEnd = INT_MAX;\\n        sort(points.begin(), points.end());\\n        for(auto& p: points) {\\n            if(p.first > minEnd) {count++; minEnd = p.second;}\\n            else minEnd = min(minEnd, p.second);\\n        }\\n        return count + !points.empty();\\n    }\\n```\n```\\nint eraseOverlapIntervals(vector<Interval>& intervals) {\\n        int total = 0, minEnd = INT_MIN, overNb = 1;\\n        sort(intervals.begin(), intervals.end(), [&](Interval& inter1, Interval& inter2) {return inter1.start < inter2.start;});\\n        for(auto& p: intervals) {\\n            if(p.start >= minEnd) {\\n                total += overNb-1;\\n                overNb = 1;\\n                minEnd = p.end;\\n            }\\n            else {\\n                overNb++;\\n                minEnd = min(minEnd, p.end);\\n            }\\n        }\\n        return total + overNb-1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1686627,
                "title": "c-java-python-6-lines-sort-and-greedy-image-explanation",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n\\n* Problem Understanding\\n\\t* There is some **misleading** in the description of the problem, **`points` are not points but line segments, so I just modify `points` to `segments`.**\\n\\t* There are several `segments` on the one-dimensional coordinate axis, find out the minimum number of `arrows` which are orthogonal to the coordinate axis so that each `segment` can be shot through by at least one `arrow`.\\n* Approch\\n\\t* Sort the `segments` by the end\\n\\t* put an arrow at the end of the 1-st `segment`\\n\\t* from the 2-nd `segment`, we check whether the current arrow pass through the current `segment`, if not add an arrow, put it at the end of the current `segment`\\n\\n![image](https://assets.leetcode.com/users/images/5b64eeb3-60c1-4ebb-afcc-7ddc489307c4_1642045015.6650152.png)\\n\\n\\n\\n**Python**\\n```py\\nclass Solution(object):\\n    def findMinArrowShots(self, segments):\\n        segments.sort(key=lambda p: p[1])\\n        ans, arrow = 0, 0\\n        for [start, end] in segments:\\n            if ans == 0 or start > arrow:\\n                ans, arrow = ans + 1, end\\n        return ans\\n```\\n\\n**C++**\\n```\\nbool cmp(vector<int>& a, vector<int>& b) {return a[1] < b[1];}\\nclass Solution {\\npublic:  \\n    int findMinArrowShots(vector<vector<int>>& segments) {\\n        sort(segments.begin(), segments.end(), cmp);\\n        int ans = 0, arrow = 0;\\n        for (int i = 0; i < segments.size(); i ++) {\\n            if (ans == 0 || segments[i][0] > arrow) {\\n                ans ++;\\n                arrow = segments[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] segments) {\\n        Arrays.sort(segments, (a, b) -> Integer.compare(a[1], b[1]));\\n        int ans = 0, arrow = 0;\\n        for (int i = 0; i < segments.length; i ++) {\\n            if (ans == 0 || segments[i][0] > arrow) {\\n                ans ++;\\n                arrow = segments[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```py\\nclass Solution(object):\\n    def findMinArrowShots(self, segments):\\n        segments.sort(key=lambda p: p[1])\\n        ans, arrow = 0, 0\\n        for [start, end] in segments:\\n            if ans == 0 or start > arrow:\\n                ans, arrow = ans + 1, end\\n        return ans\\n```\n```\\nbool cmp(vector<int>& a, vector<int>& b) {return a[1] < b[1];}\\nclass Solution {\\npublic:  \\n    int findMinArrowShots(vector<vector<int>>& segments) {\\n        sort(segments.begin(), segments.end(), cmp);\\n        int ans = 0, arrow = 0;\\n        for (int i = 0; i < segments.size(); i ++) {\\n            if (ans == 0 || segments[i][0] > arrow) {\\n                ans ++;\\n                arrow = segments[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] segments) {\\n        Arrays.sort(segments, (a, b) -> Integer.compare(a[1], b[1]));\\n        int ans = 0, arrow = 0;\\n        for (int i = 0; i < segments.length; i ++) {\\n            if (ans == 0 || segments[i][0] > arrow) {\\n                ans ++;\\n                arrow = segments[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000353,
                "title": "c-short-and-easy-code-explained",
                "content": "\\n\\n# Approach\\n**Greedy algorithm**\\n1.An arrow shoots through multiple intervals, all of which are coincident. We try to stack the overlapping intervals together and give a jump.\\n2.To facilitate identifying coincidence in a single traversal, we sort in ascending order on the right\\n\\n# Complexity\\n- Time complexity:O(NlogN)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& p) {\\n        sort(p.begin(), p.end());\\n        int lastpoint = p[0][1];\\n        int ans = 1;\\n        for(auto point : p) {\\n            if(point[0] > lastpoint) {\\n                ans++;\\n                lastpoint = point[1];\\n            }\\n            lastpoint = min(point[1],lastpoint);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***IF YOU LIKE THE SOLUTION PLEASE UPVOTE.***\\nlet\\'s connnect [Linkdin](https://www.linkedin.com/in/mahesh-vishnoi-a4a47a193/) AND [Telegram](https://t.me/mahesh_vishnoi29)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& p) {\\n        sort(p.begin(), p.end());\\n        int lastpoint = p[0][1];\\n        int ans = 1;\\n        for(auto point : p) {\\n            if(point[0] > lastpoint) {\\n                ans++;\\n                lastpoint = point[1];\\n            }\\n            lastpoint = min(point[1],lastpoint);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000906,
                "title": "java-solution-with-explanation",
                "content": "# Approach\\n1. The approach used here is to sort the intervals by their end point (the second element of each interval), and then iterate through the sorted list. At each iteration, we compare the start point of the current interval with the end point of the previous interval. If the start point of the current interval is after the end point of the previous interval, it means that the current interval does not overlap with the previous one, and therefore we need an additional arrow to burst the current interval. If the start point of the current interval is before or at the same point as the end point of the previous interval, it means that the current interval overlaps with the previous one, and we can burst both intervals with only one arrow.\\n\\n2.  This solution works because if we sort the intervals by their end point, it will always be optimal to use the minimum number of arrows to burst the intervals that end first. This is because, if we have two intervals A and B such that A ends before B and we use one arrow to burst A, it means that we cannot use that same arrow to burst B, and therefore we must use an additional arrow for B. Therefore, it is always optimal to use the minimum number of arrows to burst the intervals that end first.\\n\\n# Code\\n```\\nclass Solution {\\n   // Finds the minimum number of arrows needed to burst all balloons\\n   public int findMinArrowShots(int[][] points) {\\n        // Sort the balloons by the end position of the arrow\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1],b[1]));\\n        \\n        // Initialize the number of arrows needed to 1\\n        int result = 1;\\n        // Set the index of the previously burst balloon to 0\\n        int previous = 0;\\n        \\n        // Iterate through all balloons\\n        for(int current = 1; current < points.length; current++){\\n            // If the start position of the current balloon is after the end position of the arrow that burst the previous balloon,\\n            // then a new arrow is needed to burst the current balloon\\n            if(points[current][0] > points[previous][1]){\\n                result++;\\n                // Update the index of the previously burst balloon\\n                previous = current;\\n            }\\n        }\\n        return result;            \\n    }\\n}\\n\\n```\\n# Approach\\n\\n**The algorithm works as follows:**\\n\\n1. A PriorityQueue is used to sort the balloon ranges in ascending order of their end points.\\n2. The balloon ranges are processed one by one, starting with the one that ends first.\\n3. For each balloon range, we check if any of the subsequent ranges start before or at the same time as the end of the current range. If a subsequent range does, we remove it from the PriorityQueue because it will also be burst when the current range is burst.\\n4. We increment the result counter by 1 for each balloon range processed, since each range requires one arrow to burst it.\\n5. After all the ranges have been processed, the result counter holds the minimum number of arrows needed to burst all the balloons.\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        // result will store the minimum number of arrows needed to burst all the balloons\\n        int result = 0;\\n\\n        // PriorityQueue to sort the balloon ranges in ascending order of their end points\\n        PriorityQueue<int[]> priorityQueue = new PriorityQueue<>((a,b) -> a[1]-b[1]);\\n\\n        // add all the balloon ranges to the PriorityQueue\\n        for (int []point : points) priorityQueue.add(point);\\n\\n        // if there are no balloons, return 0\\n        if (priorityQueue.isEmpty()) return 0;\\n\\n        // while there are balloons in the PriorityQueue, process each balloon range\\n        while (!priorityQueue.isEmpty()) {\\n            // get the current balloon range\\n            int [] prev = priorityQueue.poll();\\n\\n            // check if any subsequent balloon ranges start before or at the same time as the end of the current range\\n            // if a subsequent range does, remove it from the PriorityQueue because it will also be burst when the current range is burst\\n            while (!priorityQueue.isEmpty() && prev[1]>=priorityQueue.peek()[0] && prev[1]<=priorityQueue.peek()[1]) {\\n                priorityQueue.poll();\\n            }\\n\\n            // increment the result counter by 1 for each balloon range processed, since each range requires one arrow to burst it\\n            result++;\\n        }\\n\\n        // return the minimum number of arrows needed to burst all the balloons\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   // Finds the minimum number of arrows needed to burst all balloons\\n   public int findMinArrowShots(int[][] points) {\\n        // Sort the balloons by the end position of the arrow\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1],b[1]));\\n        \\n        // Initialize the number of arrows needed to 1\\n        int result = 1;\\n        // Set the index of the previously burst balloon to 0\\n        int previous = 0;\\n        \\n        // Iterate through all balloons\\n        for(int current = 1; current < points.length; current++){\\n            // If the start position of the current balloon is after the end position of the arrow that burst the previous balloon,\\n            // then a new arrow is needed to burst the current balloon\\n            if(points[current][0] > points[previous][1]){\\n                result++;\\n                // Update the index of the previously burst balloon\\n                previous = current;\\n            }\\n        }\\n        return result;            \\n    }\\n}\\n\\n```\n```\\n\\n\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        // result will store the minimum number of arrows needed to burst all the balloons\\n        int result = 0;\\n\\n        // PriorityQueue to sort the balloon ranges in ascending order of their end points\\n        PriorityQueue<int[]> priorityQueue = new PriorityQueue<>((a,b) -> a[1]-b[1]);\\n\\n        // add all the balloon ranges to the PriorityQueue\\n        for (int []point : points) priorityQueue.add(point);\\n\\n        // if there are no balloons, return 0\\n        if (priorityQueue.isEmpty()) return 0;\\n\\n        // while there are balloons in the PriorityQueue, process each balloon range\\n        while (!priorityQueue.isEmpty()) {\\n            // get the current balloon range\\n            int [] prev = priorityQueue.poll();\\n\\n            // check if any subsequent balloon ranges start before or at the same time as the end of the current range\\n            // if a subsequent range does, remove it from the PriorityQueue because it will also be burst when the current range is burst\\n            while (!priorityQueue.isEmpty() && prev[1]>=priorityQueue.peek()[0] && prev[1]<=priorityQueue.peek()[1]) {\\n                priorityQueue.poll();\\n            }\\n\\n            // increment the result counter by 1 for each balloon range processed, since each range requires one arrow to burst it\\n            result++;\\n        }\\n\\n        // return the minimum number of arrows needed to burst all the balloons\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000334,
                "title": "python3-greedy-approach-explained",
                "content": "**Intuition:**\\n - When looking at a ranges/intervals-related problem, it is always good to sort the array first.\\n - One thing I learned from Leetcode is to think about a problem backward somehow, in this case, either going from the right of the ```array``` to the left or, say, sorting the ```intervals``` based on the end value of each interval. (Obsessively don\\'t forget to think about it in a normal way (forward))\\n - Let\\'s sort the ```points``` using the end of each point; when we try to shoot the first balloon (cover the first interval), we want to shoot as many other balloons as possible (cover as many different intervals as possible). \\n - The best thing to do would be to shoot at the balloon\\'s end (right side) so that it can cover as many overlapped balloons as possible since they are sorted.\\n\\n **Algorithm:**\\n  - Sort the ```points``` based on the end of each point.\\n  - Initialize the ```curEnd``` as the end value of the first point. (Shotting the first balloon)\\n  - For each point:\\n  \\t- if its start point is larger than the ```curEnd```, add one more arrow, and update the ```curEnd``` to the new endpoint.\\n\\n**Solution 1:** Moving from left to right, sort the points based on end point.\\n```python\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key=lambda x:x[1])\\n        res, curEnd = 1, points[0][1]\\n        for start,end in points:\\n            if start>curEnd:\\n                curEnd = end\\n                res += 1\\n        return res\\n```\\n\\n**Solution 2:** Moving from right to left, sort the points based on start point.\\n```python\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort()\\n        res, curStart = 1, points[-1][0]\\n        for start,end in reversed(points):\\n            if end<curStart:\\n                curStart = start\\n                res += 1\\n        return res\\n```\\n\\nThe two solutions are based on the same idea, just want to show different ways of think about a problem backward.\\n\\n**Also check out [Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/), which can be solved with almost the same process.** \\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```array```\n```intervals```\n```points```\n```points```\n```curEnd```\n```curEnd```\n```curEnd```\n```python\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key=lambda x:x[1])\\n        res, curEnd = 1, points[0][1]\\n        for start,end in points:\\n            if start>curEnd:\\n                curEnd = end\\n                res += 1\\n        return res\\n```\n```python\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort()\\n        res, curStart = 1, points[-1][0]\\n        for start,end in reversed(points):\\n            if end<curStart:\\n                curStart = start\\n                res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93719,
                "title": "greedy-python-132-ms",
                "content": "1. Sort intervals by ending value;\\n2. Only count valid intervals we need, and skip overlapping intervals\\nreturn the count\\n\\n```\\nclass Solution(object):\\n    def findMinArrowShots(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        points = sorted(points, key = lambda x: x[1])\\n        res, end = 0, -float('inf')\\n        for interval in points:\\n            if interval[0] > end:\\n                res += 1\\n                end = interval[1]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findMinArrowShots(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        points = sorted(points, key = lambda x: x[1])\\n        res, end = 0, -float('inf')\\n        for interval in points:\\n            if interval[0] > end:\\n                res += 1\\n                end = interval[1]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000565,
                "title": "easiest-c-solution-with-detailed-explanation",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Intuition:** question asks for minimum, so either DP or Greedy can be applied. We will solve using Greedy algorithm.\\n\\n**Approach:**\\n* We can sort the array based on starting or ending points, lets go with ending points.\\n* Lets observe the given test case\\n* ![image](https://assets.leetcode.com/users/images/b8bac39d-c948-49d8-bb1d-379887562cc0_1672884846.4353683.png)\\n* Here we can see that [1,6] and [2,8] overlap because starting of [2,8] is less than ending of [1,6]. In such cases 1 arrow will burst them both.\\n* But if we check [1,6] and [7,12], they do not overlap because starting of [7,12] is not less than ending of [1,6]. In such cases, another arrow will be needed to burst it.\\n* We will just apply this logic in our solution.\\n\\n```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> &a, vector<int> &b)\\n    {\\n        return a[1]<b[1];\\n    }\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        if(points.size()==0)\\n            return 0;\\n        \\n        sort(points.begin(), points.end(), comp);\\n        \\n        int arrows = 1;\\n        int last = points[0][1];\\n        \\n        for(int i=1; i<points.size(); i++)\\n        {\\n            if(points[i][0]>last)\\n            {\\n                arrows++;\\n                last = points[i][1];\\n            }\\n        }\\n        return arrows;\\n    }\\n};\\n```\\n**Time Complexity** => `O(NlogN)`\\n**Space Complexity** => `O(1)`\\n\\n![image](https://assets.leetcode.com/users/images/e0f8ed44-7bcb-4055-b448-0f0cedfb529d_1672885159.8676805.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> &a, vector<int> &b)\\n    {\\n        return a[1]<b[1];\\n    }\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        if(points.size()==0)\\n            return 0;\\n        \\n        sort(points.begin(), points.end(), comp);\\n        \\n        int arrows = 1;\\n        int last = points[0][1];\\n        \\n        for(int i=1; i<points.size(); i++)\\n        {\\n            if(points[i][0]>last)\\n            {\\n                arrows++;\\n                last = points[i][1];\\n            }\\n        }\\n        return arrows;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887607,
                "title": "minimum-number-of-arrows-to-burst-balloons-o-nlogn-java-c",
                "content": "My first implementation is sort based on the start of the ballon.  But actually sort based on the end of the ballon is easier to understand.  It is a standard greedy algorithm.  \\n\\n1. Put the first arrow as far right as possible ( points[0][1] ). The is the greedy part of the alrorighm. \\n2.  Let\\'s check how many balloons can be attacked by this arrow.\\n3.  When a ballon **A** (the fourth balloon) can\\'t be reached by the previous arrow, we need one more arrow.  Now put the next arrow as far right as possible(the end of this balloon) and repeat. \\n4.  We need one more arrow to attack the last group. That is why the initial value of res is 1.  \\n\\nNote:  In step 3, it is possible that a balloon after **A** can be attacked by the previous arrow, such as the fifth and the seventh balloons.  But this will not affect the result. \\n\\nIf you like it, please upvote it. Thanks.\\n\\n![image](https://assets.leetcode.com/users/images/a40f2c8f-458d-41b4-956e-3407e387fe88_1602317342.9116127.png)\\n\\njava\\n\\nsort based on the end of the ballon\\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        if (points == null || points.length == 0) return 0;\\n        Arrays.sort(points, (int[] p1, int[] p2)->{\\n\\t\\t    // Don\\'t use p1[1 ] - p2[1]. It may overflow \\n            return p1[1] < p2[1] ? -1 : 1; \\n        });\\n        int end = points[0][1];\\n\\t\\t\\n\\t\\t// the reason res = 1 is that we need an arrow to destroy the last group. \\n        int res = 1;\\n        for (int[] point: points)\\n        {\\n            if (point[0] <= end) continue;\\n            res++;\\n            end = point[1];\\n        }\\n        return res;\\n    }\\n}\\n```\\nsort based on the the start of ballon\\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        if (points == null || points.length == 0) return 0;\\n        Arrays.sort(points, (int[] p1, int[] p2)->{\\n\\t\\t    // Don\\'t use p1[1 ] - p2[1]. It may overflow \\n            return p1[0] < p2[0] ? -1 : 1;\\n        });\\n        int start = points[0][0], end = points[0][1];\\n\\t\\t\\n\\t\\t// the reason res = 1 is that we need an arrow to destroy the last group. \\n        int res = 1;\\n        for (int[] point: points)\\n        {\\n            if (point[0]<= end)\\n            {\\n                start= Math.max(start, point[0]);\\n                end = Math.min(end, point[1]);\\n            }\\n            else\\n            {\\n                res++;\\n                start = point[0];\\n                end = point[1];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```\\n\\nc++\\nsort based on the end of the ballon\\n\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        if (points.empty()) return 0;\\n        sort(points.begin(), points.end(), [] (auto &p1, auto&p2) {\\n            return p1[1] < p2[1];\\n        });\\n        int end = points[0][1];\\n\\t\\t\\n\\t\\t// the reason res = 1 is that we need an arrow to destroy the last group. \\n        int res = 1;\\n        for (auto point: points)\\n        {\\n            if (point[0] <= end) continue;\\n            res++;\\n            end = point[1];\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nsort based on the the start of ballon\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        if (points.empty()) return 0;\\n        sort(points.begin(), points.end());\\n        int start = points[0][0], end = points[0][1];\\n\\t\\t\\n\\t\\t// the reason res = 1 is that we need an arrow to destroy the last group. \\n        int res = 1;\\n        for (auto point: points)\\n        {\\n            if (point[0] <= end)\\n            {\\n                start = max(start, point[0]);\\n                end = min(end, point[1]);\\n            }\\n            else\\n            {\\n                res++;\\n                start = point[0];\\n                end = point[1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        if (points == null || points.length == 0) return 0;\\n        Arrays.sort(points, (int[] p1, int[] p2)->{\\n\\t\\t    // Don\\'t use p1[1 ] - p2[1]. It may overflow \\n            return p1[1] < p2[1] ? -1 : 1; \\n        });\\n        int end = points[0][1];\\n\\t\\t\\n\\t\\t// the reason res = 1 is that we need an arrow to destroy the last group. \\n        int res = 1;\\n        for (int[] point: points)\\n        {\\n            if (point[0] <= end) continue;\\n            res++;\\n            end = point[1];\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        if (points == null || points.length == 0) return 0;\\n        Arrays.sort(points, (int[] p1, int[] p2)->{\\n\\t\\t    // Don\\'t use p1[1 ] - p2[1]. It may overflow \\n            return p1[0] < p2[0] ? -1 : 1;\\n        });\\n        int start = points[0][0], end = points[0][1];\\n\\t\\t\\n\\t\\t// the reason res = 1 is that we need an arrow to destroy the last group. \\n        int res = 1;\\n        for (int[] point: points)\\n        {\\n            if (point[0]<= end)\\n            {\\n                start= Math.max(start, point[0]);\\n                end = Math.min(end, point[1]);\\n            }\\n            else\\n            {\\n                res++;\\n                start = point[0];\\n                end = point[1];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        if (points.empty()) return 0;\\n        sort(points.begin(), points.end(), [] (auto &p1, auto&p2) {\\n            return p1[1] < p2[1];\\n        });\\n        int end = points[0][1];\\n\\t\\t\\n\\t\\t// the reason res = 1 is that we need an arrow to destroy the last group. \\n        int res = 1;\\n        for (auto point: points)\\n        {\\n            if (point[0] <= end) continue;\\n            res++;\\n            end = point[1];\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        if (points.empty()) return 0;\\n        sort(points.begin(), points.end());\\n        int start = points[0][0], end = points[0][1];\\n\\t\\t\\n\\t\\t// the reason res = 1 is that we need an arrow to destroy the last group. \\n        int res = 1;\\n        for (auto point: points)\\n        {\\n            if (point[0] <= end)\\n            {\\n                start = max(start, point[0]);\\n                end = min(end, point[1]);\\n            }\\n            else\\n            {\\n                res++;\\n                start = point[0];\\n                end = point[1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1686412,
                "title": "well-explanation-c-java-very-easy-to-understand-clean-code",
                "content": "#### Approach\\n\\n***Greedy Algorithm :***\\n* An arrow shoots through multiple intervals, all of which are coincident. We try to stack the overlapping intervals together and give a jump.\\n* To facilitate identifying coincidence in a single traversal, we sort in ascending order on the right.\\n\\n**C++ Code :**\\n```\\n// comparator function for sorting 2D vector\\nbool comp(vector<int> &a, vector<int> &b){\\n    return a[1] < b[1];\\n}\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        if(points.size() == 0) return 0; \\n\\t\\t\\n        sort(points.begin(), points.end(), comp);\\n        int arrows = 1;\\n        int last = points[0][1];\\n        \\n        for(int i = 1; i < points.size(); i++){\\n            if(points[i][0] > last){\\n                arrows++;\\n                last = points[i][1];\\n            }\\n        }\\n        return arrows;\\n    }\\n};\\n```\\n\\n**JAVA Code :**\\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        if(points.length == 0) return 0; \\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\\n        int arrows = 1;\\n        int end = points[0][1];\\n        \\n        for(int i = 1; i < points.length; i++){\\n            if(points[i][0] > end){\\n                arrows++;\\n                end = points[i][1];\\n            }\\n        }\\n        return arrows;\\n    }\\n}\\n```\\n\\n* **Time Complexity :-** BigO(NlogN)\\n* **Space Complexity :-** BigO(1)\\n\\nIf you understood than don\\'t forget to upvote \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\n// comparator function for sorting 2D vector\\nbool comp(vector<int> &a, vector<int> &b){\\n    return a[1] < b[1];\\n}\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        if(points.size() == 0) return 0; \\n\\t\\t\\n        sort(points.begin(), points.end(), comp);\\n        int arrows = 1;\\n        int last = points[0][1];\\n        \\n        for(int i = 1; i < points.size(); i++){\\n            if(points[i][0] > last){\\n                arrows++;\\n                last = points[i][1];\\n            }\\n        }\\n        return arrows;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        if(points.length == 0) return 0; \\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\\n        int arrows = 1;\\n        int end = points[0][1];\\n        \\n        for(int i = 1; i < points.length; i++){\\n            if(points[i][0] > end){\\n                arrows++;\\n                end = points[i][1];\\n            }\\n        }\\n        return arrows;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1686598,
                "title": "well-detailed-explaination-java-c-python-easy-for-mind-to-accept-it",
                "content": "Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F\\n\\n**So Ladies n Gentlemen without any further due let\\'s start,**\\n` What Question is saying, given the array points, return the minimum number of arrows that must be shot to burst all balloons`.\\n\\n\\n**Approach Explained:**\\n\\n**Summary :**\\n* Sort intervals/pairs in increasing order of the end position\\n* Finding the common area of current interval with start and end,if they intersect....(for example { [1,6] , [2,8] } these intervals intersect common area is [2,6])\\n* Else if no common area update start and end to current interval and increment arrow count\\n\\n**Explained:**\\n`Greedy algorithm:`\\n\\n* An arrow shoots through multiple intervals, all of which are coincident. We try to stack the overlapping intervals together and give a jump.\\n* To facilitate identifying coincidence in a single traversal, we sort in ascending order on the right\\n\\nTo, solve this problem first of all what we do is **sort the Array points**. Let\\'s say we have these point\\'s array **[[10,16],[2,8],[1,6],[7,12]]**. And we will solve this array based on the end index. So, by doing that what will happen with our Array is **[1,6]** will come first then **[2,8]** will come, third one is **[7,12]** & last is from **[10,16]**.\\nSo, these are the **4 values x-coordinates** are given like this. Let me show you in diagram :\\n\\n![image](https://assets.leetcode.com/users/images/6a666e3d-d0b1-4410-88aa-4b36fb09c3ad_1642043072.2629914.png)\\n\\n\\nNow, for **bursting these Ballons** 1st one we need one shot anywhere **1 to 6 including these edges**. So, what we will do is we will **greedly sort** over here at the end of **[6]**. So, if we shot it, the baloon burst and along with another one **[2,8]** will burst as well with only **1 arrow.**\\nAs, we have **burst 2 ballons** and 2 more left. So, again if we shot it over **[12]** then it will burst **[10,16] as well**.\\n\\n![image](https://assets.leetcode.com/users/images/a4cea92e-f1f7-4f5d-9444-0076308f9367_1642043545.1509588.png)\\n\\n\\nWe can see that in above example we **need 2 arrows** to burst all these 4 ballons\\n\\nHope the point is clear:\\n\\n**Let\\'s code it up :**\\n*code each line explained*. `Similar for C++, Java, Python` **{Only Syntax Difference}** approach same\\n\\n* Step 1 :\\n```\\n{\\n        // Base Condition, if there is no balloons then our answer will be zero\\n        if(points.length == 0) return 0; \\n        \\n        // Sorting our array, passing the 2 points a, b. And then i will sort \\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\\n        int arrows = 1; // starting arrow with 1\\n        int end = points[0][1]; // end of 1st ballon\\n```\\n\\n* Step 2 :\\n```\\n// iterating over all the ballons\\n        for(int i = 1; i < points.length; i++){\\n            if(points[i][0] > end){ // if point of start is greater then current end\\n                arrows++; // take another arrow and update our arrow\\n                end = points[i][1]; // update our end with the current point we are processing\\n            }\\n        }\\n        return arrows; // after trying all the values, return arrows as our answer\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        if(points.length == 0) return 0; \\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\\n        int arrows = 1;\\n        int end = points[0][1];\\n        \\n        for(int i = 1; i < points.length; i++){\\n            if(points[i][0] > end){\\n                arrows++;\\n                end = points[i][1];\\n            }\\n        }\\n        return arrows;\\n    }\\n}\\n```\\n**C++**\\n```\\n// comparator function for sorting 2D vector\\nbool comp(vector<int> &x, vector<int> &y){\\n    return x[1] < y[1];\\n}\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        if(points.size() == 0) return 0; \\n        sort(points.begin(), points.end(), comp);\\n        int arrows = 1;\\n        int end = points[0][1];\\n        \\n        for(int i = 1; i < points.size(); i++){\\n            if(points[i][0] > end){\\n                arrows++;\\n                end = points[i][1];\\n            }\\n        }\\n        return arrows;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points = sorted(points, key = lambda x: x[1])\\n        arrows, end = 0, -float(\\'inf\\')\\n        for i in points:\\n            if i[0] > end:\\n                arrows += 1\\n                end = i[1]\\n        return arrows\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(NlogN)\\n* **Space Complexity :-** BigO(1)\\n\\nIf you have some \\uD83E\\uDD14 doubts feel free to bug me anytime or If you understood than don\\'t forget to upvote \\uD83D\\uDC4D",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n{\\n        // Base Condition, if there is no balloons then our answer will be zero\\n        if(points.length == 0) return 0; \\n        \\n        // Sorting our array, passing the 2 points a, b. And then i will sort \\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\\n        int arrows = 1; // starting arrow with 1\\n        int end = points[0][1]; // end of 1st ballon\\n```\n```\\n// iterating over all the ballons\\n        for(int i = 1; i < points.length; i++){\\n            if(points[i][0] > end){ // if point of start is greater then current end\\n                arrows++; // take another arrow and update our arrow\\n                end = points[i][1]; // update our end with the current point we are processing\\n            }\\n        }\\n        return arrows; // after trying all the values, return arrows as our answer\\n```\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        if(points.length == 0) return 0; \\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\\n        int arrows = 1;\\n        int end = points[0][1];\\n        \\n        for(int i = 1; i < points.length; i++){\\n            if(points[i][0] > end){\\n                arrows++;\\n                end = points[i][1];\\n            }\\n        }\\n        return arrows;\\n    }\\n}\\n```\n```\\n// comparator function for sorting 2D vector\\nbool comp(vector<int> &x, vector<int> &y){\\n    return x[1] < y[1];\\n}\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        if(points.size() == 0) return 0; \\n        sort(points.begin(), points.end(), comp);\\n        int arrows = 1;\\n        int end = points[0][1];\\n        \\n        for(int i = 1; i < points.size(); i++){\\n            if(points[i][0] > end){\\n                arrows++;\\n                end = points[i][1];\\n            }\\n        }\\n        return arrows;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points = sorted(points, key = lambda x: x[1])\\n        arrows, end = 0, -float(\\'inf\\')\\n        for i in points:\\n            if i[0] > end:\\n                arrows += 1\\n                end = i[1]\\n        return arrows\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887690,
                "title": "python-o-n-log-n-solution-explained",
                "content": "This problem is almost identical to problem **435 Non-overlapping Intervals**, but here we need to find not how many interals we need to remove, but how many non-overlapping intervals we have. Also one small difference is that here intervals `[1,2]` and `[2,3]` overlapping, because they have common end.\\n\\nFor more explanations, please look at my solution of problem **435**:\\nhttps://leetcode.com/problems/non-overlapping-intervals/discuss/793070/Python-O(n-log-n)-sort-ends-with-proof-explained\\n\\n**Complexity**: it is the same as problem 435: time is `O(n log n)` and space is `O(n)`.\\n\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points):\\n        points.sort(key = lambda x: x[1])\\n        n, count = len(points), 1\\n        if n == 0: return 0\\n        curr = points[0]\\n        \\n        for i in range(n):\\n            if curr[1] < points[i][0]:\\n                count += 1\\n                curr = points[i]\\n                \\n        return count  \\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMinArrowShots(self, points):\\n        points.sort(key = lambda x: x[1])\\n        n, count = len(points), 1\\n        if n == 0: return 0\\n        curr = points[0]\\n        \\n        for i in range(n):\\n            if curr[1] < points[i][0]:\\n                count += 1\\n                curr = points[i]\\n                \\n        return count  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 93711,
                "title": "java-greedy-soution",
                "content": "```\\npublic int findMinArrowShots(int[][] points) {\\n\\tif(points==null || points.length==0 || points[0].length==0) return 0;\\n\\tArrays.sort(points, new Comparator<int[]>() {\\n\\t\\tpublic int compare(int[] a, int[] b) {\\n\\t\\t\\tif(a[0]==b[0]) return a[1]-b[1];\\n\\t\\t\\telse return a[0]-b[0];\\n\\t\\t}\\n\\t});\\n\\t\\n\\tint minArrows = 1;\\n\\tint arrowLimit = points[0][1];\\n\\tfor(int i=1;i<points.length;i++) {\\n\\t\\tint[] baloon = points[i];\\n\\t\\tif(baloon[0]<=arrowLimit) {\\n\\t\\t\\tarrowLimit=Math.min(arrowLimit, baloon[1]);\\n\\t\\t} else {\\n\\t\\t\\tminArrows++;\\n\\t\\t\\tarrowLimit=baloon[1];\\n\\t\\t}\\n\\t}\\n\\treturn minArrows;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findMinArrowShots(int[][] points) {\\n\\tif(points==null || points.length==0 || points[0].length==0) return 0;\\n\\tArrays.sort(points, new Comparator<int[]>() {\\n\\t\\tpublic int compare(int[] a, int[] b) {\\n\\t\\t\\tif(a[0]==b[0]) return a[1]-b[1];\\n\\t\\t\\telse return a[0]-b[0];\\n\\t\\t}\\n\\t});\\n\\t\\n\\tint minArrows = 1;\\n\\tint arrowLimit = points[0][1];\\n\\tfor(int i=1;i<points.length;i++) {\\n\\t\\tint[] baloon = points[i];\\n\\t\\tif(baloon[0]<=arrowLimit) {\\n\\t\\t\\tarrowLimit=Math.min(arrowLimit, baloon[1]);\\n\\t\\t} else {\\n\\t\\t\\tminArrows++;\\n\\t\\t\\tarrowLimit=baloon[1];\\n\\t\\t}\\n\\t}\\n\\treturn minArrows;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1466547,
                "title": "explanation-for-all-intervals-problems",
                "content": "\\nLeetcode questions based on \"intervals\": C++ Solutions and explanations\\n## **[56. Merge Intervals](https://leetcode.com/problems/merge-intervals/)**\\nSimple sorting and merging. We keep updating p until there is an overlap and then push it to the final array.\\n```\\n    \\nvector<vector<int>> merge(vector<vector<int>>& v) {\\n\\t\\tint n = v.size();\\n\\t\\tsort(v.begin(),v.end());\\n\\t\\tvector<vector<int>> ans;\\n\\t\\tvector<int> p = v[0];\\n\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tif(p[1] >= v[i][0])\\n\\t\\t\\t\\tp = {min(p[0],v[i][0]), max(p[1],v[i][1])};\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tans.push_back(p);\\n\\t\\t\\t\\tp = v[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans.push_back(p);\\n\\t\\treturn ans;\\n}\\n```\\n\\n\\n## **[435. Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/)**\\n\\nwe have to sort the intervals on the basis of thier end points,\\nthen use a greeady approach to find the answer.\\n\\nIf p is ending after the start of current element, we eliminate the current element but not the element contained in p because the elements are sorted according to their end points and p will have a lesser end point than the current element. So we eliminate current element to reduce the probability of overlapping with next element.\\n\\n```\\nbool comp(vector<int> a, vector<int> b)\\n{\\n    if(a[1] == b[1]) return a[0]<b[0];\\n    return a[1]<b[1];\\n}\\n\\nint eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(),comp);\\n        int n = intervals.size();\\n        int ans = 0;\\n        vector<int> p = intervals[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(p[1] > intervals[i][0])\\n                ans++;\\n            else\\n                p = intervals[i];\\n        }\\n        return ans;\\n    }\\n```\\n\\nWhy do we sort on the basis of end points, not on start points.\\n\\n- suppose you have cases like :  (1,8), (2,3), (3,4), (5,9)\\n- if you sort in the basis of start points you will end up considering (1,8) and deleting rest which collide with (1,8).\\n- For a greedy approach you will want the point with lower end point to be considered.\\n- But, We can sort on the basis of start point also, just a little tweak in the algorithm will work out that way. In case of overlap, remove the interval having the farther end point.\\n\\n```\\nint eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        int n = intervals.size();\\n        int ans = 0;\\n        int p= intervals[0][1];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(p > intervals[i][0])\\n            {\\n                ans++;\\n                p = min(p, intervals[i][1]);\\n            }\\n            else\\n                p = intervals[i][1];\\n        }\\n        return ans;\\n    }\\n```\\n\\n## **[452. Minimum Number of Arrows to Burst Balloons](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/)**\\n\\nVery similar to **435. Non-overlapping Intervals** but we have to return the number of remaining intervals.(n-ans).\\n\\n```\\nint findMinArrowShots(vector<vector<int>>& points) {\\n\\t\\tint n = points.size();\\n\\t\\tsort(points.begin(),points.end());\\n\\t\\tint p = points[0][1];\\n\\t\\tint ans = 0;   \\n\\t\\t for(int i=1;i<n;i++)\\n\\t\\t    {\\n\\t\\t        if(p >= points[i][0])\\n\\t\\t        {\\n\\t\\t            ans++;\\n\\t\\t            p = min(p, points[i][1]);\\n\\t\\t        }\\n\\t\\t        else\\n\\t\\t            p = points[i][1];\\n\\t\\t    }\\n\\t\\t\\n    return n-ans;\\n}\\n```\\n\\n## **[Meeting rooms II](https://leetcode.com/problems/meeting-rooms-ii)**\\nHere we are using a priority queue so that we can keep track of the earliest ending meeting. If the start of current meeting isn\\'t greater or equal to the end value of top element in the priority queue, we need an extra room to accommodate the meeting and hence we push the element into the priority queue. Otherwise, we pop the top element and push the current element(i.e., we re-use the room). Eventually, the size of priority queue turns out to be our answer.\\n```jsx\\nstruct comp {\\n    bool operator()(vector<int> p1, vector<int> p2)\\n    {\\n        return p1[1] > p2[1];\\n    }\\n};\\n\\nint Solution::solve(vector<vector<int> > &v) {\\n   \\n        int n = v.size();\\n        if(n==0) return 0;\\n        sort(v.begin(),v.end());\\n        priority_queue<vector<int>, vector<vector<int>>, comp> pq;\\n        pq.push(v[0]);\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            vector<int> temp = pq.top();\\n            int x = temp[1];\\n            if(v[i][0] < x)\\n            {\\n                pq.push(v[i]);\\n            }\\n            else\\n            {\\n                pq.pop();\\n                pq.push(v[i]);\\n            }\\n        }\\n        return pq.size();\\n    \\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n    \\nvector<vector<int>> merge(vector<vector<int>>& v) {\\n\\t\\tint n = v.size();\\n\\t\\tsort(v.begin(),v.end());\\n\\t\\tvector<vector<int>> ans;\\n\\t\\tvector<int> p = v[0];\\n\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tif(p[1] >= v[i][0])\\n\\t\\t\\t\\tp = {min(p[0],v[i][0]), max(p[1],v[i][1])};\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tans.push_back(p);\\n\\t\\t\\t\\tp = v[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans.push_back(p);\\n\\t\\treturn ans;\\n}\\n```\n```\\nbool comp(vector<int> a, vector<int> b)\\n{\\n    if(a[1] == b[1]) return a[0]<b[0];\\n    return a[1]<b[1];\\n}\\n\\nint eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(),comp);\\n        int n = intervals.size();\\n        int ans = 0;\\n        vector<int> p = intervals[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(p[1] > intervals[i][0])\\n                ans++;\\n            else\\n                p = intervals[i];\\n        }\\n        return ans;\\n    }\\n```\n```\\nint eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        int n = intervals.size();\\n        int ans = 0;\\n        int p= intervals[0][1];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(p > intervals[i][0])\\n            {\\n                ans++;\\n                p = min(p, intervals[i][1]);\\n            }\\n            else\\n                p = intervals[i][1];\\n        }\\n        return ans;\\n    }\\n```\n```\\nint findMinArrowShots(vector<vector<int>>& points) {\\n\\t\\tint n = points.size();\\n\\t\\tsort(points.begin(),points.end());\\n\\t\\tint p = points[0][1];\\n\\t\\tint ans = 0;   \\n\\t\\t for(int i=1;i<n;i++)\\n\\t\\t    {\\n\\t\\t        if(p >= points[i][0])\\n\\t\\t        {\\n\\t\\t            ans++;\\n\\t\\t            p = min(p, points[i][1]);\\n\\t\\t        }\\n\\t\\t        else\\n\\t\\t            p = points[i][1];\\n\\t\\t    }\\n\\t\\t\\n    return n-ans;\\n}\\n```\n```jsx\\nstruct comp {\\n    bool operator()(vector<int> p1, vector<int> p2)\\n    {\\n        return p1[1] > p2[1];\\n    }\\n};\\n\\nint Solution::solve(vector<vector<int> > &v) {\\n   \\n        int n = v.size();\\n        if(n==0) return 0;\\n        sort(v.begin(),v.end());\\n        priority_queue<vector<int>, vector<vector<int>>, comp> pq;\\n        pq.push(v[0]);\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            vector<int> temp = pq.top();\\n            int x = temp[1];\\n            if(v[i][0] < x)\\n            {\\n                pq.push(v[i]);\\n            }\\n            else\\n            {\\n                pq.pop();\\n                pq.push(v[i]);\\n            }\\n        }\\n        return pq.size();\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 93695,
                "title": "c-easy-understood-solution-sort",
                "content": "First, we sort balloons by increasing points.end (if ends are the same, then by increasing of points.start). Every time arrow shot points.end, say, points[i].second. If next balloon.start <= points[i].second, it is also shot, thus we continue.\\n```\\n    int findMinArrowShots(vector<pair<int, int>>& points) {\\n        int count = 0, arrow = INT_MIN;\\n        sort(points.begin(), points.end(), mysort);\\n        for(int i = 0; i<points.size(); i++){\\n            if(arrow!=INT_MIN && points[i].first<=arrow){continue;} //former arrow shot points[i] \\n            arrow = points[i].second; // new arrow shot the end of points[i]\\n            count++;\\n        }\\n        return count;\\n    }\\n    static bool mysort(pair<int, int>& a, pair<int, int>& b){\\n        return a.second==b.second?a.first<b.first:a.second<b.second;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int findMinArrowShots(vector<pair<int, int>>& points) {\\n        int count = 0, arrow = INT_MIN;\\n        sort(points.begin(), points.end(), mysort);\\n        for(int i = 0; i<points.size(); i++){\\n            if(arrow!=INT_MIN && points[i].first<=arrow){continue;} //former arrow shot points[i] \\n            arrow = points[i].second; // new arrow shot the end of points[i]\\n            count++;\\n        }\\n        return count;\\n    }\\n    static bool mysort(pair<int, int>& a, pair<int, int>& b){\\n        return a.second==b.second?a.first<b.first:a.second<b.second;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3001611,
                "title": "c-java-detailed-explanation-w-dry-run-commented-code-with-examples",
                "content": "**Intuition and solution:**\\n```\\n1) We will sort on the basis of starting time of the array.\\n   Because after doing this we can surely say that the intervals that start first will appear first.\\n2) Our main motive here is to carry out an active set,\\n   to check with only one arrow how many balloons we are able to burst.\\n3) Now, what is an active set, active set is nothing but the common area between two comparing sets.\\n4) See the dry run also for further clarity.\\n```\\n_________\\n**Variables will be used and their name:**\\n```\\n1) arrow: to count how many arrows we will be required.\\n2) start: to store the starting point of an active set.\\n3) end: to store the ending point of an active set.\\n```\\n__________\\n**Dry run on first test case:**\\n```\\n1) Suppose array given to us as: arr = [[10,16],[2,8],[1,6],[7,12]]\\n2) After sorting, it looks like:\\n     [[1,6]\\n     [2,8],\\n     [7,12],\\n     [10,16]]\\n\\t \\n3) Initially if the size of the array is greater or equal to one,\\nthen we can say that at least we are required a single arrow, so initially arrow count will be 1, i.e arrow = 1;\\n\\n4) Also, initially we provide start to the starting point of zero index of array, i.e start = arr[0][0] = 1\\nand end as ending point of zero index i.e end = arr[0][1] = 6\\n\\n5) Now, we run a loop from 1 to n (n being the size of array)\\n   and then update our active set on the basis of conditions.\\n\\n6) So we start the loop from i = 1, \\n         [[1,6]\\n    --> [2,8],   Now, we will see the active set b/w [1,6] and [2,8] is [2,6]\\n        [7,12],\\n        [10,16]]\\n\\nOur old active set i.e [start, end] is [1,6] \\nNow, it overlaps with current interval i.e i = 1, arr[1] = [2,8]\\nso we will recreate our new active set and that will be [2,6]\\n\\nSo, how we achieve this active set,\\nstart = max(start, arr[i][0]); --> max(1, 2) --> 2\\nand end = min(end, arr[i][1]); --> min(6, 8) --> 6\\n\\n7) now, arrow = 1, start = 2 and end = 6 \\nnow moving ahead for i = 2\\n       [[1,6],\\n        [2,8],   \\n  --> [7,12],  Now, we will see the active set b/w [2,6] and [7,12] is [] i.e nothing\\n        [10,16]]\\n\\nOur old active set i.e [start, end] is [2,6] \\nNow it does not overlap with current interval i.e i = 2, arr[2] = [7, 12]\\n\\nSo, we will require another arrow to burst this  active set and \\n    hence increment arrow i.e arrow++, now arrow will become 2.\\n\\t\\nAlso we have to recreate our whole active set again, therefore:\\n start = arr[i][0] = arr[2][0] = 7\\n end = arr[i][1] = arr[2][1] = 12\\n \\n8) now, arrow = 2, start= 7 and end = 12\\nnow moving head for i = 3\\n      [[1,6],\\n      [2,8],   \\n      [7,12], \\n--> [10,16]] Now, we will see the active set b/w [7,12] and [10,16] is [10,12]\\n\\nSo, they overlap and does not require any another arrow\\nNow, loop will be over and arrow required will be 2 in this case.\\n\\n```\\n__________\\n**Time and Space Complexity:**\\n```\\nTime complexity: O(n log n) as we will use sorting here and n being the size of the array.\\nSpace Complexity: O(1) as we are not using other data structures from our side.\\n```\\n______\\n**CODES:**\\n**1) C++**\\n```\\nint findMinArrowShots(vector<vector<int>>& arr) {\\n        int n = arr.size(); // extract size\\n        \\n        // intially arrow will be 1 (see constraint 1 <= points.length <= 10^5)\\n        // atleast 1 ballon will be required so, arrow = 1\\n        \\n        int arrow = 1; // we will require atleast 1 arrow to burst the ballons\\n        \\n         // as we said, sort it on the basis of starting point        \\n        sort(arr.begin(), arr.end());\\n        \\n        //intially start and end position will be of zero index\\n        int start = arr[0][0];\\n        int end = arr[0][1];\\n        \\n        // Run the loop i.e from (1 to n)\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(arr[i][0] > end) // active set and ith index interval does not overlap\\n            {\\n                // so we have to create new active set\\n                start = arr[i][0];\\n                end = arr[i][1];\\n                arrow++; // and also now we need one more arrow\\n            }\\n            else // if  active set and ith index interval does overlap\\n            {\\n                // we just rearranging our active set\\n                start = max(start, arr[i][0]);\\n                end = min(end, arr[i][1]);\\n            }\\n        }\\n        return arrow; // finally, loop ends return count of arrow\\n    }\\n};\\n```\\n____\\n\\n**JAVA**\\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] arr) {\\n        int n = arr.length; // extract size\\n        \\n        // intially arrow will be 1 (see constraint 1 <= points.length <= 10^5)\\n        // atleast 1 ballon will be required so, arrow = 1\\n        \\n        int arrow = 1; // we will require atleast 1 arrow to burst the ballons\\n        \\n         // as we said, sort it on the basis of starting point\\n        Arrays.sort(arr, (a, b) -> Integer.compare(a[0],b[0]));\\n        \\n        //intially start and end position will be of zero index\\n        int start = arr[0][0];\\n        int end = arr[0][1];\\n        \\n         // Run the loop i.e from (1 to n)\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(arr[i][0] > end) // active set and ith index interval does not overlap\\n            {\\n                // so we have to create new active set\\n                start = arr[i][0];\\n                end = arr[i][1];\\n                \\n                arrow++; // and also now we need one more arrow\\n            }\\n            else // if  active set and ith index interval does overlap\\n            {\\n                // we just rearranging our active set\\n                start = Math.max(start, arr[i][0]);\\n                end = Math.min(end, arr[i][1]);\\n            }\\n        }\\n        \\n        return arrow; // finally, loop ends return count of arrow\\n    }\\n}\\n```\\n_____\\n* Reference article help me: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/discuss/93735/A-Concise-Template-for-%22Overlapping-Interval-Problem%22\\n\\n***`If u find this useful , please consider to give an upvote!!`***",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n1) We will sort on the basis of starting time of the array.\\n   Because after doing this we can surely say that the intervals that start first will appear first.\\n2) Our main motive here is to carry out an active set,\\n   to check with only one arrow how many balloons we are able to burst.\\n3) Now, what is an active set, active set is nothing but the common area between two comparing sets.\\n4) See the dry run also for further clarity.\\n```\n```\\n1) arrow: to count how many arrows we will be required.\\n2) start: to store the starting point of an active set.\\n3) end: to store the ending point of an active set.\\n```\n```\\n1) Suppose array given to us as: arr = [[10,16],[2,8],[1,6],[7,12]]\\n2) After sorting, it looks like:\\n     [[1,6]\\n     [2,8],\\n     [7,12],\\n     [10,16]]\\n\\t \\n3) Initially if the size of the array is greater or equal to one,\\nthen we can say that at least we are required a single arrow, so initially arrow count will be 1, i.e arrow = 1;\\n\\n4) Also, initially we provide start to the starting point of zero index of array, i.e start = arr[0][0] = 1\\nand end as ending point of zero index i.e end = arr[0][1] = 6\\n\\n5) Now, we run a loop from 1 to n (n being the size of array)\\n   and then update our active set on the basis of conditions.\\n\\n6) So we start the loop from i = 1, \\n         [[1,6]\\n    --> [2,8],   Now, we will see the active set b/w [1,6] and [2,8] is [2,6]\\n        [7,12],\\n        [10,16]]\\n\\nOur old active set i.e [start, end] is [1,6] \\nNow, it overlaps with current interval i.e i = 1, arr[1] = [2,8]\\nso we will recreate our new active set and that will be [2,6]\\n\\nSo, how we achieve this active set,\\nstart = max(start, arr[i][0]); --> max(1, 2) --> 2\\nand end = min(end, arr[i][1]); --> min(6, 8) --> 6\\n\\n7) now, arrow = 1, start = 2 and end = 6 \\nnow moving ahead for i = 2\\n       [[1,6],\\n        [2,8],   \\n  --> [7,12],  Now, we will see the active set b/w [2,6] and [7,12] is [] i.e nothing\\n        [10,16]]\\n\\nOur old active set i.e [start, end] is [2,6] \\nNow it does not overlap with current interval i.e i = 2, arr[2] = [7, 12]\\n\\nSo, we will require another arrow to burst this  active set and \\n    hence increment arrow i.e arrow++, now arrow will become 2.\\n\\t\\nAlso we have to recreate our whole active set again, therefore:\\n start = arr[i][0] = arr[2][0] = 7\\n end = arr[i][1] = arr[2][1] = 12\\n \\n8) now, arrow = 2, start= 7 and end = 12\\nnow moving head for i = 3\\n      [[1,6],\\n      [2,8],   \\n      [7,12], \\n--> [10,16]] Now, we will see the active set b/w [7,12] and [10,16] is [10,12]\\n\\nSo, they overlap and does not require any another arrow\\nNow, loop will be over and arrow required will be 2 in this case.\\n\\n```\n```\\nTime complexity: O(n log n) as we will use sorting here and n being the size of the array.\\nSpace Complexity: O(1) as we are not using other data structures from our side.\\n```\n```\\nint findMinArrowShots(vector<vector<int>>& arr) {\\n        int n = arr.size(); // extract size\\n        \\n        // intially arrow will be 1 (see constraint 1 <= points.length <= 10^5)\\n        // atleast 1 ballon will be required so, arrow = 1\\n        \\n        int arrow = 1; // we will require atleast 1 arrow to burst the ballons\\n        \\n         // as we said, sort it on the basis of starting point        \\n        sort(arr.begin(), arr.end());\\n        \\n        //intially start and end position will be of zero index\\n        int start = arr[0][0];\\n        int end = arr[0][1];\\n        \\n        // Run the loop i.e from (1 to n)\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(arr[i][0] > end) // active set and ith index interval does not overlap\\n            {\\n                // so we have to create new active set\\n                start = arr[i][0];\\n                end = arr[i][1];\\n                arrow++; // and also now we need one more arrow\\n            }\\n            else // if  active set and ith index interval does overlap\\n            {\\n                // we just rearranging our active set\\n                start = max(start, arr[i][0]);\\n                end = min(end, arr[i][1]);\\n            }\\n        }\\n        return arrow; // finally, loop ends return count of arrow\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] arr) {\\n        int n = arr.length; // extract size\\n        \\n        // intially arrow will be 1 (see constraint 1 <= points.length <= 10^5)\\n        // atleast 1 ballon will be required so, arrow = 1\\n        \\n        int arrow = 1; // we will require atleast 1 arrow to burst the ballons\\n        \\n         // as we said, sort it on the basis of starting point\\n        Arrays.sort(arr, (a, b) -> Integer.compare(a[0],b[0]));\\n        \\n        //intially start and end position will be of zero index\\n        int start = arr[0][0];\\n        int end = arr[0][1];\\n        \\n         // Run the loop i.e from (1 to n)\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(arr[i][0] > end) // active set and ith index interval does not overlap\\n            {\\n                // so we have to create new active set\\n                start = arr[i][0];\\n                end = arr[i][1];\\n                \\n                arrow++; // and also now we need one more arrow\\n            }\\n            else // if  active set and ith index interval does overlap\\n            {\\n                // we just rearranging our active set\\n                start = Math.max(start, arr[i][0]);\\n                end = Math.min(end, arr[i][1]);\\n            }\\n        }\\n        \\n        return arrow; // finally, loop ends return count of arrow\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000422,
                "title": "python-3-7-lines-w-explanation-and-example-t-m-98-92",
                "content": "Here\\'s the intuition:\\n\\nWe start on the the left and move right, with the strategy of only shooting an arrow when necessary.\\n\\nWe must shoot before moving right of the balloon with the leftmost `end`, otherwise that balloon will remain unpopped. There\\'s no advantage to shoot before that`end`, so our first arrow is shot there. Any balloon with a`start`at or left of this position is also popped. \\n\\nNow we move right to the next`end`of the remaining end of the unpopped ballons and fires again. The process repeats until all balloons are popped. We return the`tally`of arrows shot.\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: list[list[int]]) -> int:\\n\\n        points.sort(key = lambda x: x[1])      # Example:  points = [[2,4],[1,6],[1,3],[7,8]]\\n                                               #      points.sort = [[1,3],[2,4],[1,6],[7,8]]\\n        tally, bow = 1, points[0][1]\\n                                               #                     \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013 [7,9]\\n        for start, end in points:              #   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013          [1,6] \\n            if bow < start:                    #      \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013                [2,4]\\n                bow = end                      #   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013                   [1,3]\\n                tally += 1                     #   1  2  3  4  5  6  7  8  9\\n                                               #         |                 |     \\n        return tally                           #     tally = 1         tally = 2\\n```\\n[https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/submissions/619226370/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*NlogN*)  and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinArrowShots(self, points: list[list[int]]) -> int:\\n\\n        points.sort(key = lambda x: x[1])      # Example:  points = [[2,4],[1,6],[1,3],[7,8]]\\n                                               #      points.sort = [[1,3],[2,4],[1,6],[7,8]]\\n        tally, bow = 1, points[0][1]\\n                                               #                     \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013 [7,9]\\n        for start, end in points:              #   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013          [1,6] \\n            if bow < start:                    #      \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013                [2,4]\\n                bow = end                      #   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013                   [1,3]\\n                tally += 1                     #   1  2  3  4  5  6  7  8  9\\n                                               #         |                 |     \\n        return tally                           #     tally = 1         tally = 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93786,
                "title": "this-is-actually-activity-selection-problem",
                "content": "https://en.wikipedia.org/wiki/Activity_selection_problem\\n\\n```\\npublic class Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, new C());\\n        long last = Long.MIN_VALUE;\\n        int count = 0;\\n        for (int i = 0; i < points.length; i++) {\\n            if (last < points[i][0]) {\\n                last = points[i][1];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    class C implements Comparator<int[]> {\\n        public int compare(int[] a1, int[] a2) {\\n            return Integer.compare(a1[1], a2[1]);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, new C());\\n        long last = Long.MIN_VALUE;\\n        int count = 0;\\n        for (int i = 0; i < points.length; i++) {\\n            if (last < points[i][0]) {\\n                last = points[i][1];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    class C implements Comparator<int[]> {\\n        public int compare(int[] a1, int[] a2) {\\n            return Integer.compare(a1[1], a2[1]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001279,
                "title": "well-explained-w-images-sorting-stack",
                "content": "# Intuition or Hint\\nWe use a stack to store our ballons and if there are two overlapping balloons we replace them with both with one one ballon that has the dimensions of the overlap.\\n\\n``` \\nExample : [[1, 6], [2, 9]]\\n```\\nA balloon [1, 6] and a balloon [2, 9] can be replaced with one balloon [2, 6] because any arrow it this can burst both the balloons. Also we can check further balloons with this overlap as one balloon because \\n- if it overlaps with this we can burst all 3 with 1 arrow so, we can store the overlap of all 3 as one balloon.\\n-  if it doesn\\'t we were going to need 2 arrows for all three anyway so we can store that one ballon seperately.\\n\\n# Example Images\\n```\\n[[1,7], [6, 10]]\\n```\\nThe two balloons overlap at [6, 7] and hence can be shown as one arrow.\\n\\n![topleetballoon.jpg](https://assets.leetcode.com/users/images/e3a5ad68-69dd-4ffa-8908-669b6583b213_1672897282.51885.jpeg)\\n\\n```\\nExample : [[9, 20], [10, 13], [5, 30]]\\n```\\nSame with these 3 ballons. They overlap.\\n\\n![bottomleetballoon.jpg](https://assets.leetcode.com/users/images/ee972f7a-4805-432a-93bb-5515f3141a0a_1672897293.6568146.jpeg)\\n\\n\\nWe need to sort the ballons by starting points because we want all possibly overlapping balloons to bunch together in the array so that when we process them on eby one they can b ecollectively replaced by one balloon insted.\\n\\nAfter processing we just return the number of overlap balloons we have in our stack. Becuase that is how many arrows we need.\\n\\n\\n- Excuse my bad explanation.\\n\\n- Time complexity : O(nlog(n) + O(n)) => O(nlog(n)) effectively\\n- Space : O(n) for stack\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key = lambda x : x[0])\\n        stack = [  ]\\n        for sp, ep in points:\\n            if len(stack)>0 and stack[-1][1] >= sp:\\n                last_sp, last_ep = stack.pop()\\n                stack.append( [max(sp, last_sp), min(ep, last_ep)] )\\n            else:\\n                stack.append([sp, ep])\\n        return len(stack)\\n        \\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "JavaScript"
                ],
                "code": "``` \\nExample : [[1, 6], [2, 9]]\\n```\n```\\n[[1,7], [6, 10]]\\n```\n```\\nExample : [[9, 20], [10, 13], [5, 30]]\\n```\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key = lambda x : x[0])\\n        stack = [  ]\\n        for sp, ep in points:\\n            if len(stack)>0 and stack[-1][1] >= sp:\\n                last_sp, last_ep = stack.pop()\\n                stack.append( [max(sp, last_sp), min(ep, last_ep)] )\\n            else:\\n                stack.append([sp, ep])\\n        return len(stack)\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000483,
                "title": "easy-c-solution-with-detailed-explanations-time-complexity-analysis",
                "content": "## Explanation:\\n\\n### Solution 01\\n\\n- Here we\\u2019ve to sort the 2d array.\\n- Now, on each iteration check the value of ***small*** because small is the number which is the common middle point for a set of balloons whose\\xA0`start point <= small\\xA0and\\xA0small <= end point.`\\n- Update the small value when you will find the CurrNode whose start index is greater than the small. Now increment the count and `change small = CurrNode[1]`.\\n- When the\\xA0`CurrNode[0]<small` but the ******`CurrNode[1] < small`\\xA0Just simply change the value of `small = CurrNode[1]`, because the given rule of `X start <= small <= X end` will always get obeyed!\\n- Let\\u2019s understand with the following example :\\n\\n```\\n[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n\\nhere the sorted order will be :\\n1 10\\n3 9\\n4 11\\n6 7\\n6 9\\n8 12\\n9 12\\n\\nhere on the second iteration, \\n\\tsmall = 10 but the CurrNode = { 3 , 9 } \\n\\tSo, CurrNode[1] >= small  BUT  here CurrNode[1] < small, hence to obey the rule:  we will change small from 10 to 9 and \\n\\t1 <= 9 <= 10\\n\\tand\\n\\t3 <= 9 <= 9\\n```\\n\\n- **Time complexity:** O(nlogn).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        sort(points.begin(),points.end());\\n        \\n        int small = INT_MIN ;\\n        int count = 0 ;\\n        \\n        for(auto k:points)\\n        {\\n            if( small == INT_MIN )\\n            {\\n                small = k[1];\\n                continue ;\\n            }\\n            if( k[0] <= small && small > k[1] )\\n            {\\n                small = k[1];\\n                continue ;\\n            }\\n            if( k[0] <= small )\\n                continue;\\n            else\\n            {\\n                count++ ;\\n                small = k[1] ;\\n            }\\n        }\\n        \\n        return count+1 ;\\n    }\\n    \\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\n[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n\\nhere the sorted order will be :\\n1 10\\n3 9\\n4 11\\n6 7\\n6 9\\n8 12\\n9 12\\n\\nhere on the second iteration, \\n\\tsmall = 10 but the CurrNode = { 3 , 9 } \\n\\tSo, CurrNode[1] >= small  BUT  here CurrNode[1] < small, hence to obey the rule:  we will change small from 10 to 9 and \\n\\t1 <= 9 <= 10\\n\\tand\\n\\t3 <= 9 <= 9\\n```\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        sort(points.begin(),points.end());\\n        \\n        int small = INT_MIN ;\\n        int count = 0 ;\\n        \\n        for(auto k:points)\\n        {\\n            if( small == INT_MIN )\\n            {\\n                small = k[1];\\n                continue ;\\n            }\\n            if( k[0] <= small && small > k[1] )\\n            {\\n                small = k[1];\\n                continue ;\\n            }\\n            if( k[0] <= small )\\n                continue;\\n            else\\n            {\\n                count++ ;\\n                small = k[1] ;\\n            }\\n        }\\n        \\n        return count+1 ;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 396036,
                "title": "javascript-be-greedy-in-the-right-way",
                "content": "## Thoughts\\n\\n1. Deal with the balloons from the left to the right;\\n2. Be greedy in the way that, when we are shooting the left-most balloons, shoot as many balloons as possible;\\n3. That way, we need to sort the ballons according to their left position; then we accumulate as many balloons that overlap the same x-range as possible;\\n4. To accumulate balloons, we need to find their common x-range, which should be initialized with `[left[0], right[0]]` (the left and right of the current left-most balloon, inclusively), and then continue to narrow down the x-range with the next balloon until no balloon with common x-range is found.\\n\\n--------------------\\n\\n## Illustration\\n![image](https://assets.leetcode.com/users/lmiaoj/image_1570091055.png)\\n### Step1 \\nShoot the left three balloons with one arrow:\\n![image](https://assets.leetcode.com/users/lmiaoj/image_1570091107.png)\\nAnd the balloons left become:\\n![image](https://assets.leetcode.com/users/lmiaoj/image_1570091124.png)\\n\\n### Step 2\\nShoot the left two balloons with one arrow:\\n![image](https://assets.leetcode.com/users/lmiaoj/image_1570091157.png)\\nAnd the balloons left becomes:\\n![image](https://assets.leetcode.com/users/lmiaoj/image_1570091215.png)\\n\\n### Step 3\\nShoot the last three balloons with one arrow:\\n![image](https://assets.leetcode.com/users/lmiaoj/image_1570091244.png)\\n\\n## Code\\n```\\nvar findMinArrowShots = function(points) {\\n    let n = points.length;\\n    let i = 0;\\n    let res = 0;\\n    points.sort((a,b)=>a[0]-b[0]);\\n    \\n    while(i<n){\\n        let left = points[i][0], right = points[i][1];\\n        i++;\\n        while(i<n && points[i][0]<=right && points[i][1]>=left){\\n            left = Math.max(left, points[i][0]);\\n            right = Math.min(right, points[i][1]);\\n            i++;\\n        }\\n        res++;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findMinArrowShots = function(points) {\\n    let n = points.length;\\n    let i = 0;\\n    let res = 0;\\n    points.sort((a,b)=>a[0]-b[0]);\\n    \\n    while(i<n){\\n        let left = points[i][0], right = points[i][1];\\n        i++;\\n        while(i<n && points[i][0]<=right && points[i][1]>=left){\\n            left = Math.max(left, points[i][0]);\\n            right = Math.min(right, points[i][1]);\\n            i++;\\n        }\\n        res++;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1686486,
                "title": "python-visual-greedy-simple-o-nlogn-time-o-1-space",
                "content": "Please upvote if this helps and/or comment if any corrections/improvements needed \\uD83D\\uDC4D\\n\\nDescription: This problem is similar to the overlapping intervals problem. We want to maximize the number of balloons we can hit with one dart. By sorting by start and end points, we can take a look at the current balloon and the previous to check if there is overlap.\\n\\n![image](https://assets.leetcode.com/users/images/aaaaf2df-e7df-49b7-b047-49200a64e323_1642048820.7922933.gif)\\n\\n\\nIf they DO overlap then we save that overlapped area as the previous balloon and move onto the next balloon. In this way, IF the next balloon still overlaps with pervious, we can shoot them all with one dart. \\n\\nIf they DON\\'T overlap then we at least have to use one dart to shoot at the non-overlapping baloon.\\n\\n\\n\\n```python\\nclass Solution:\\n    def findMinArrowShots(self, points):\\n        n = len(points)\\n        if n<2:\\n            return n\\n\\n        #sort by start and end point\\n        START, END = 0,1\\n        points.sort(key=lambda i: (i[START],i[END]) )\\n        prev, cur = points[0], None\\n        darts = 0\\n\\n        for i in range(1, n):\\n            cur = points[i]\\n\\n            if cur[START] <= prev[END]:\\n                #overlap, wait for more overlap to throw dart\\n                prev = [cur[START], min(cur[END],prev[END])]\\n            else:\\n                #no overlap, throw dart at previous\\n                darts += 1\\n                prev = cur\\n\\t\\t\\n\\t\\t#pop the last balloon and return\\n        return darts+1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "Please upvote if this helps and/or comment if any corrections/improvements needed \\uD83D\\uDC4D\\n\\nDescription: This problem is similar to the overlapping intervals problem. We want to maximize the number of balloons we can hit with one dart. By sorting by start and end points, we can take a look at the current balloon and the previous to check if there is overlap.\\n\\n![image](https://assets.leetcode.com/users/images/aaaaf2df-e7df-49b7-b047-49200a64e323_1642048820.7922933.gif)\\n\\n\\nIf they DO overlap then we save that overlapped area as the previous balloon and move onto the next balloon. In this way, IF the next balloon still overlaps with pervious, we can shoot them all with one dart. \\n\\nIf they DON\\'T overlap then we at least have to use one dart to shoot at the non-overlapping baloon.\\n\\n\\n\\n```python\\nclass Solution:\\n    def findMinArrowShots(self, points):\\n        n = len(points)\\n        if n<2:\\n            return n\\n\\n        #sort by start and end point\\n        START, END = 0,1\\n        points.sort(key=lambda i: (i[START],i[END]) )\\n        prev, cur = points[0], None\\n        darts = 0\\n\\n        for i in range(1, n):\\n            cur = points[i]\\n\\n            if cur[START] <= prev[END]:\\n                #overlap, wait for more overlap to throw dart\\n                prev = [cur[START], min(cur[END],prev[END])]\\n            else:\\n                #no overlap, throw dart at previous\\n                darts += 1\\n                prev = cur\\n\\t\\t\\n\\t\\t#pop the last balloon and return\\n        return darts+1",
                "codeTag": "Java"
            },
            {
                "id": 3000590,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=b1JfHS844zU&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=5) if you are interested.\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        // greedy\\n        // at least 1 arrow\\n        int ans = 1;\\n        // sort by end to cover more balloons\\n        sort(points.begin(), points.end(), [](const vector<int>& x, const vector<int>& y) {\\n           return x[1] < y[1]; \\n        });\\n        // init cur_end with the first balloon\\n        int cur_end = points[0][1];\\n        for (auto p : points) {\\n            int l = p[0], r = p[1];\\n            // if cur_end < new_start\\n            if (cur_end < l) {\\n                // then we need a new arrow\\n                ans += 1;\\n                // update cur_end\\n                cur_end = r;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        // greedy\\n        // at least 1 arrow\\n        int ans = 1;\\n        // sort by end to cover more balloons\\n        sort(points.begin(), points.end(), [](const vector<int>& x, const vector<int>& y) {\\n           return x[1] < y[1]; \\n        });\\n        // init cur_end with the first balloon\\n        int cur_end = points[0][1];\\n        for (auto p : points) {\\n            int l = p[0], r = p[1];\\n            // if cur_end < new_start\\n            if (cur_end < l) {\\n                // then we need a new arrow\\n                ans += 1;\\n                // update cur_end\\n                cur_end = r;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000437,
                "title": "simple-c-code",
                "content": "\\n# **Please try to understand its discussion before viewing the code.\\nLink to the discussion: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/discussion/comments/1742148\\n\\n# Complexity\\n- Time complexity: O(n log n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        int arrow=1;\\n        int last = points[0][1];\\n\\n        sort(points.begin(),points.end());\\n\\n        for(int i=0;i<points.size();i++){\\n            if(points[i][0]>last){\\n                arrow++;\\n                last = points[i][1];\\n            }\\n            else last = min(last, points[i][1]);\\n        }\\n\\n        return arrow;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        int arrow=1;\\n        int last = points[0][1];\\n\\n        sort(points.begin(),points.end());\\n\\n        for(int i=0;i<points.size();i++){\\n            if(points[i][0]>last){\\n                arrow++;\\n                last = points[i][1];\\n            }\\n            else last = min(last, points[i][1]);\\n        }\\n\\n        return arrow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 889144,
                "title": "javascript-clean-solution",
                "content": "```javascript\\nvar findMinArrowShots = function(points) {\\n    points.sort((a, b) => a[0] - b[0]);\\n    let prev = null, count = 0;\\n    \\n    for(let [start, end] of points) {\\n        if(prev == null || prev < start) {\\n            count++;\\n            prev = end;\\n        } else prev = Math.min(prev, end);\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar findMinArrowShots = function(points) {\\n    points.sort((a, b) => a[0] - b[0]);\\n    let prev = null, count = 0;\\n    \\n    for(let [start, end] of points) {\\n        if(prev == null || prev < start) {\\n            count++;\\n            prev = end;\\n        } else prev = Math.min(prev, end);\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3001930,
                "title": "java-greedy-full-explanation-article",
                "content": "# Intuition\\nThe greedy assumption here is that if we pop the most amounts of balloons with one arrow each time (**local best**), it will lead us to the minimum number of arrows we need to use (**global best**).\\n\\nTherefore, we need to maximize the number of balloons that can be popped with each arrow.\\n\\nNote: I will refer to balloons as intervals since they represent a segment on the X-axis.\\n\\nIf we have two intervals, `[a, b]` and `[c, d]`, they could either be intersecting or not. If `a < d AND c < b` the intervals are intersecting.\\n\\nNow we can pop two intersecting intervals with one arrow by shooting it in their intersection area: `(max(a,c), min(b,d))`.\\n\\nBut to improve our odds of intersecting with the **next** interval too, we need to take the right-most intersection point. This way, we shoot the arrow as far on the right as we can, and hope to intersect with more intervals.\\n\\nTherefore we will take the `min(b, d)` point and store it in a variable called `furthestMutual`. The variable `furthestMutual` stores the right-most point of our intersection.\\n\\nNext, we check if the following interval intersects with that `furthestMutual` variable, this way, we can shoot all the previous intersections and the current one with the same arrow. If it does intersect, we update the `furthestMutual` variable. Otherwise, we start over again.\\n\\nRepeating this procedure finds the `local minimum` amount of arrows we need, resulting in the `global minimum` answer.\\n\\nNadar\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        // Note: a[0] - b[0] can produce integer overflow, and therefore wrong result.\\n        Arrays.sort(points, (a, b) -> {\\n            if(a[0] == b[0]) {\\n                return Integer.compare(b[1], a[1]);\\n            }\\n            return Integer.compare(a[0], b[0]);\\n        });\\n\\n        if(points.length == 1) return 1;\\n        int furthestMutual = points[0][1];\\n        int result = 1;\\n\\n        for(int i = 1; i < points.length; i++) {\\n            int balloonStart = points[i][0];\\n            int balloonEnd = points[i][1];\\n\\n            // Check if they have intersection\\n            if(furthestMutual >= balloonStart) {\\n                furthestMutual = Math.min(furthestMutual, balloonEnd);\\n            } else {\\n                result++;\\n                furthestMutual = balloonEnd;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        // Note: a[0] - b[0] can produce integer overflow, and therefore wrong result.\\n        Arrays.sort(points, (a, b) -> {\\n            if(a[0] == b[0]) {\\n                return Integer.compare(b[1], a[1]);\\n            }\\n            return Integer.compare(a[0], b[0]);\\n        });\\n\\n        if(points.length == 1) return 1;\\n        int furthestMutual = points[0][1];\\n        int result = 1;\\n\\n        for(int i = 1; i < points.length; i++) {\\n            int balloonStart = points[i][0];\\n            int balloonEnd = points[i][1];\\n\\n            // Check if they have intersection\\n            if(furthestMutual >= balloonStart) {\\n                furthestMutual = Math.min(furthestMutual, balloonEnd);\\n            } else {\\n                result++;\\n                furthestMutual = balloonEnd;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000478,
                "title": "c-greedy-approach-beats-83-94-solution-intersection-method",
                "content": "# Intuition\\nTo find the minimum number of arrows , we will have to hit by arrows at points where maximum number of balloons reside.\\n\\n# Approach\\nWe should sort the balloons range in ascending order and just use the one arrow to hit more and more by finding the intersection of the range of balloon until it is empty . And if for current balloon intersection is empty then increase the arrow count and reset the intersetion and repeat the same process for this current arrow.\\n\\n# Complexity\\n- Time complexity:\\nO(nlg(n))\\n\\n- Space complexity:\\nAuxiliary Space Complexity - O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        //taking first arrow\\n        int arrow = 1;\\n        sort(points.begin(),points.end());\\n\\n        //setting first range of balloon\\n        int left = points[0][0], right = points[0][1];\\n\\n        for(int i=1;i<points.size();i++){\\n            \\n            //checking if the current balloon can be hit by the current arrow\\n            if(points[i][0]<=right && points[i][1]>=left){\\n                left = max(points[i][0],left);\\n              right = min(points[i][1],right);\\n            }else{\\n                //if not then increasing the arrow number and \\n                //setting the current balloon range as new range\\n                arrow++;\\n                left = points[i][0];\\n               right = points[i][1];\\n            }\\n            \\n        }\\n        return arrow;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        //taking first arrow\\n        int arrow = 1;\\n        sort(points.begin(),points.end());\\n\\n        //setting first range of balloon\\n        int left = points[0][0], right = points[0][1];\\n\\n        for(int i=1;i<points.size();i++){\\n            \\n            //checking if the current balloon can be hit by the current arrow\\n            if(points[i][0]<=right && points[i][1]>=left){\\n                left = max(points[i][0],left);\\n              right = min(points[i][1],right);\\n            }else{\\n                //if not then increasing the arrow number and \\n                //setting the current balloon range as new range\\n                arrow++;\\n                left = points[i][0];\\n               right = points[i][1];\\n            }\\n            \\n        }\\n        return arrow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1686588,
                "title": "python3-combo-explained",
                "content": "First of all, we have to sort points by the start point so it would be easy to process intervals in the cycle. Next, we iterate over intervals and maintain a tuple `combo` containing overlapping points of previous intervals. If the current interval overlaps with the `combo`, that means we can save one arrow (the result is not incremented). Otherwise, we reset `combo` and add a new arrow to the result.\\n\\nTime: **O(NlogN)** - sorting is the heaviest operation in this algorithm\\nSpace: **O(N)** - Python\\'s sorting implementation requires N space\\n\\nRuntime: 1292 ms, faster than **71.27%** of Python3 online submissions for Minimum Number of Arrows to Burst Balloons.\\nMemory Usage: 58.9 MB, less than **90.67%** of Python3 online submissions for Minimum Number of Arrows to Burst Balloons.\\n\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        pts = sorted(points, key=lambda el: el[1])\\n        \\n        res, combo = 0, (float(\"-inf\"), float(\"-inf\"))\\n        for start, end in pts:\\n            if start <= combo[1]: # overlaps?\\n                combo = (max(combo[0], start), min(combo[1], end))\\n            else:\\n                combo = (start, end)\\n                res += 1\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        pts = sorted(points, key=lambda el: el[1])\\n        \\n        res, combo = 0, (float(\"-inf\"), float(\"-inf\"))\\n        for start, end in pts:\\n            if start <= combo[1]: # overlaps?\\n                combo = (max(combo[0], start), min(combo[1], end))\\n            else:\\n                combo = (start, end)\\n                res += 1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001556,
                "title": "2-solutions-comparator-sort",
                "content": "\\n\\n# Code 1\\n**Approach** - We are counting how many intervals share a common boundary (overlap).\\nNow, Number of arrows = Number of Intervals - Number of Overlapping Intervals\\n```\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(begin(points), end(points));\\n        int overlap = 0, i = 0, n = points.size();\\n        while(i < n) {\\n            int x = points[i][0], y = points[i][1];\\n            while(i+1 < n && points[i+1][0] <= y) {\\n                overlap++;\\n                x = max(x, points[i+1][0]);\\n                y = min(y, points[i+1][1]);\\n                i++;\\n            }\\n            i++;\\n        }\\n        return n - overlap;\\n    }\\n```\\n\\n# Code 2 using comparator \\n**Approach**- Check how many balloons I can shoot down with one shot aiming at the ending position of the current balloon. \\n\\nballoons = [[7,10], [1,5], [3,6], [2,4], [1,4]]\\nwill be sorted as...\\nballoons = [[2,4], [1,4], [1,5], [3,6], [7,10]]\\n```\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(), points.end(),\\n                        [](vector<int>& a, vector<int>& b){return a[1] < b[1];});\\n        int overlap = 0, i = 0, n = points.size();\\n        while(i < n) {\\n            int cur = points[i][1];\\n            while(i+1 < n && points[i+1][0] <= cur) {\\n                i++;\\n                overlap++;\\n            }\\n            i++;\\n        }\\n        return n - overlap;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(begin(points), end(points));\\n        int overlap = 0, i = 0, n = points.size();\\n        while(i < n) {\\n            int x = points[i][0], y = points[i][1];\\n            while(i+1 < n && points[i+1][0] <= y) {\\n                overlap++;\\n                x = max(x, points[i+1][0]);\\n                y = min(y, points[i+1][1]);\\n                i++;\\n            }\\n            i++;\\n        }\\n        return n - overlap;\\n    }\\n```\n```\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(), points.end(),\\n                        [](vector<int>& a, vector<int>& b){return a[1] < b[1];});\\n        int overlap = 0, i = 0, n = points.size();\\n        while(i < n) {\\n            int cur = points[i][1];\\n            while(i+1 < n && points[i+1][0] <= cur) {\\n                i++;\\n                overlap++;\\n            }\\n            i++;\\n        }\\n        return n - overlap;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3000515,
                "title": "simplest-java-solution-explanation",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, Comparator.comparingInt(o -> o[1])); //Sorting according to end\\n\\n        int ans = 1;\\n        int bound = points[0][1];\\n\\n        for(int i = 1; i<points.length; i++){\\n            //checking for non-overlapping range\\n            if(points[i][0] > bound){\\n                bound = points[i][1];\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n# Explanation\\n- We just need to find the overlapping diameter range. So the easy approach would be to first sort the array.\\n- Rather than sorting according `start` or `points[][0]` it\\'s better to sort it according to `end` or `points[][1]`.\\n- This is better because we now only need to check which all balloons have start value less than or equal to the current balloon\\'s end. All these balloons can be popped by the same arrow.\\n- When we encounter a balloon with start value greater than the current\\'s end we simple make that balloon our current balloon and increment the ans variable.",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, Comparator.comparingInt(o -> o[1])); //Sorting according to end\\n\\n        int ans = 1;\\n        int bound = points[0][1];\\n\\n        for(int i = 1; i<points.length; i++){\\n            //checking for non-overlapping range\\n            if(points[i][0] > bound){\\n                bound = points[i][1];\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000317,
                "title": "daily-leetcoding-challenge-january-day-5",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3001444,
                "title": "c-easy-short-code-greedy-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n        static bool comp(vector<int>&a, vector<int>&b){\\n        return a[1] < b[1];\\n    }\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        //sort on the basis of x.end\\n        sort(points.begin(),points.end(),comp);\\n        int arrows=1; //we need 1 arrow for the first balloon for sure\\n        int end=points[0][1];\\n\\n        for(int i=1;i<points.size();i++){\\n            //comparing the xi.end with xi+1.start \\n            if(points[i][0] > end){\\n                arrows++;\\n                end=points[i][1];\\n            }\\n        }\\n        return arrows;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n        static bool comp(vector<int>&a, vector<int>&b){\\n        return a[1] < b[1];\\n    }\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        //sort on the basis of x.end\\n        sort(points.begin(),points.end(),comp);\\n        int arrows=1; //we need 1 arrow for the first balloon for sure\\n        int end=points[0][1];\\n\\n        for(int i=1;i<points.size();i++){\\n            //comparing the xi.end with xi+1.start \\n            if(points[i][0] > end){\\n                arrows++;\\n                end=points[i][1];\\n            }\\n        }\\n        return arrows;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000349,
                "title": "overlapping-interval-solution",
                "content": "1. Sort the array in order of increasing **Start** / **Left** position.\\n2. Scan the **Sorted** array for common interval. ( Start position not neccessary since we have sorted the array) \\n\\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) \\n    {\\n        Arrays.sort(points, new java.util.Comparator<int[]>() \\n                    {\\n                        public int compare(int[] a, int[] b) \\n                        {\\n                            return Integer.compare(a[0], b[0]);\\n                        }\\n                    });\\n        \\n        int currRight = points[0][1];\\n        int count = 1;\\n        \\n        for(int i=1; i<points.length; i++)\\n        {\\n            if(currRight>=points[i][0])\\n            {\\n                currRight = Math.min(currRight,points[i][1]);\\n            }\\n            else\\n            {\\n                count++;\\n                currRight = points[i][1];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) \\n    {\\n        Arrays.sort(points, new java.util.Comparator<int[]>() \\n                    {\\n                        public int compare(int[] a, int[] b) \\n                        {\\n                            return Integer.compare(a[0], b[0]);\\n                        }\\n                    });\\n        \\n        int currRight = points[0][1];\\n        int count = 1;\\n        \\n        for(int i=1; i<points.length; i++)\\n        {\\n            if(currRight>=points[i][0])\\n            {\\n                currRight = Math.min(currRight,points[i][1]);\\n            }\\n            else\\n            {\\n                count++;\\n                currRight = points[i][1];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1686444,
                "title": "java-detailed-explanation-easy-sorting-o-n-log-n",
                "content": "```\\nIntuition :\\n1) Sort the array based on balloon\\'s end time.\\n2) Take min number of arrow as 1 and take 1st balloon\\'s end time as end time.\\n3) Traverse the array and compare the end time with each balloon\\'s start time because if any balloon\\'s start time is less than or equal time to previous end time that means those balloons can be shot with same arrow. (shared some common area)\\n4) If any balloon\\'s start time is bigger than previous end time that means they do not share common area and new ballon will need a new arrow to shot.\\n5) Increase the arrow count and update the end time\\n6) Return the result\\n```\\n```\\npublic int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a,b) -> Integer.compare(a[1], b[1]));\\n        int arrow = 1;\\n        int end = points[0][1];\\n        for(int i=0;i<points.length;i++){\\n            if(points[i][0] > end){\\n                arrow++;\\n                end = points[i][1];\\n            }\\n        }\\n        return arrow;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nIntuition :\\n1) Sort the array based on balloon\\'s end time.\\n2) Take min number of arrow as 1 and take 1st balloon\\'s end time as end time.\\n3) Traverse the array and compare the end time with each balloon\\'s start time because if any balloon\\'s start time is less than or equal time to previous end time that means those balloons can be shot with same arrow. (shared some common area)\\n4) If any balloon\\'s start time is bigger than previous end time that means they do not share common area and new ballon will need a new arrow to shot.\\n5) Increase the arrow count and update the end time\\n6) Return the result\\n```\n```\\npublic int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a,b) -> Integer.compare(a[1], b[1]));\\n        int arrow = 1;\\n        int end = points[0][1];\\n        for(int i=0;i<points.length;i++){\\n            if(points[i][0] > end){\\n                arrow++;\\n                end = points[i][1];\\n            }\\n        }\\n        return arrow;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3004820,
                "title": "python-greedy-2-solutions-video-solution",
                "content": "I have explained both the approaches [here](https://youtu.be/mojcGP939zY).\\n\\n# Sort by start pos\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key=lambda x:(x[0]))\\n        count = 1\\n        prev_end = points[0][1]\\n        \\n        for x,y in points[1:]:\\n            if x<=prev_end:\\n                prev_end = min(y, prev_end)\\n                continue\\n                \\n            prev_end = y\\n            count+=1\\n        return count\\n```\\n\\n# Sort by End pos\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key=lambda x:(x[1]))\\n        count = 1\\n        prev_end = points[0][1]\\n        \\n        for x,y in points[1:]:\\n            if x<=prev_end:\\n                continue\\n            \\n            prev_end = y\\n            count+=1\\n        return count\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key=lambda x:(x[0]))\\n        count = 1\\n        prev_end = points[0][1]\\n        \\n        for x,y in points[1:]:\\n            if x<=prev_end:\\n                prev_end = min(y, prev_end)\\n                continue\\n                \\n            prev_end = y\\n            count+=1\\n        return count\\n```\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key=lambda x:(x[1]))\\n        count = 1\\n        prev_end = points[0][1]\\n        \\n        for x,y in points[1:]:\\n            if x<=prev_end:\\n                continue\\n            \\n            prev_end = y\\n            count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000804,
                "title": "simple-approach-c",
                "content": "# Intuition\\nSort on the basis of end point and check how many baloons can you burst with it.\\nWhy sort on the basis of end point and not the start point ? \\nEg : [ [6,7] , [1,10] , [5,8] , [9,12] ]\\nif you sort on the basis of start point and start taking the end then you\\'ll get ans 1 but the answer is 2 because 10 wont touch the tip of the 7 and 9 together because [6,7] has the tip till 7 & 9 starts at 9 and ends at 12 so we can burst that only.\\n\\n# Approach\\nSort on the basis of end values , iterate over the values and check for how many can you actually burst , keep a cnt for it.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>& a , vector<int>& b){\\n        return a[1] < b[1];\\n    }\\n    int findMinArrowShots(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin() , nums.end() , cmp);\\n        int i = 0 , cnt = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            int v1 = nums[i][1];\\n            while(i+1 < n && v1 >= nums[i+1][0]){\\n                i++;\\n            }\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>& a , vector<int>& b){\\n        return a[1] < b[1];\\n    }\\n    int findMinArrowShots(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin() , nums.end() , cmp);\\n        int i = 0 , cnt = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            int v1 = nums[i][1];\\n            while(i+1 < n && v1 >= nums[i+1][0]){\\n                i++;\\n            }\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000649,
                "title": "short-clean-greedy-java-javascript",
                "content": "```java []\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a,b)->Integer.compare(a[1], b[1]));\\n        int arrows = 1, cur = points[0][1];\\n        for(int i=1; i<points.length; i++){\\n            if(cur >= points[i][0]) continue;\\n            arrows++;\\n            cur = points[i][1];\\n        }\\n        return arrows;\\n    }\\n}\\n```\\n```javascript []\\nvar findMinArrowShots = function(points) {\\n    points.sort((a,b) => a[1] - b[1]);\\n    let count = 1, pos = points[0][1];\\n    for(let i=1; i<points.length; i++){\\n        if(pos >= points[i][0]){\\n            continue;\\n        }\\n        count++;\\n        pos = points[i][1];\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```java []\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a,b)->Integer.compare(a[1], b[1]));\\n        int arrows = 1, cur = points[0][1];\\n        for(int i=1; i<points.length; i++){\\n            if(cur >= points[i][0]) continue;\\n            arrows++;\\n            cur = points[i][1];\\n        }\\n        return arrows;\\n    }\\n}\\n```\n```javascript []\\nvar findMinArrowShots = function(points) {\\n    points.sort((a,b) => a[1] - b[1]);\\n    let count = 1, pos = points[0][1];\\n    for(let i=1; i<points.length; i++){\\n        if(pos >= points[i][0]){\\n            continue;\\n        }\\n        count++;\\n        pos = points[i][1];\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000601,
                "title": "easy-python-solution-sorting",
                "content": "# Code\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points = sorted(points)\\n        p = points[0][0]\\n        q = points[0][1]\\n        ans = 0\\n        for i,j in points:\\n            if p <= i <= q or p <= j <= q:\\n                p = max(i,p)\\n                q = min(j,q)\\n            else:\\n                ans += 1\\n                p = i\\n                q = j\\n        return ans + 1\\n```\\n***Please Upvote if you like it.***",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points = sorted(points)\\n        p = points[0][0]\\n        q = points[0][1]\\n        ans = 0\\n        for i,j in points:\\n            if p <= i <= q or p <= j <= q:\\n                p = max(i,p)\\n                q = min(j,q)\\n            else:\\n                ans += 1\\n                p = i\\n                q = j\\n        return ans + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000388,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& a,vector<int>& b){\\n        if(a[0]==b[0]) return a[1]<b[1];\\n        return a[0]<b[0];\\n    }\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        int n=points.size();\\n        if(n<=1) return 1;\\n        sort(points.begin(),points.end(),comp);\\n        int last=points[0][1];\\n        int ans=1;\\n        for(int i=1;i<n;i++){\\n            if(points[i][0]>last){\\n                ans++;\\n                last=points[i][1];\\n            }\\n            last=min(last,points[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& a,vector<int>& b){\\n        if(a[0]==b[0]) return a[1]<b[1];\\n        return a[0]<b[0];\\n    }\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        int n=points.size();\\n        if(n<=1) return 1;\\n        sort(points.begin(),points.end(),comp);\\n        int last=points[0][1];\\n        int ans=1;\\n        for(int i=1;i<n;i++){\\n            if(points[i][0]>last){\\n                ans++;\\n                last=points[i][1];\\n            }\\n            last=min(last,points[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999650,
                "title": "easy-to-understand-concise-solution-detailed-explanation",
                "content": "# Approach\\nGreedy approach\\n# Steps:\\n1. Sort intervals/pairs in increasing order of the end position\\n2. Finding the common area of current interval with start and end,if they intersect....(for example { [1,6] , [2,8] } these intervals intersect common area is [2,6])\\n3. If no common area update start and end to current interval and increment arrow count\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& v) {\\n        sort(v.begin(),v.end()); //sort the array\\n        int l=v[0][0];\\n        int r=v[0][1],cnt=1;\\n        for(int i=1;i<v.size();i++){\\n           if(v[i][0]<=r){\\n              r=min(r,v[i][1]); //ending value of common interval\\n              l=max(l,v[i][0]); // starting value of common interval\\n           }\\n           else{\\n               cnt++; // no common interval hence increment the count\\n               l=v[i][0]; //update the start value of common interval by start value of current index.\\n               r=v[i][1];  //update the ending point of common interval by ending value of current index.\\n           }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n---\\n\\u2705Please Upvote if you like it\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& v) {\\n        sort(v.begin(),v.end()); //sort the array\\n        int l=v[0][0];\\n        int r=v[0][1],cnt=1;\\n        for(int i=1;i<v.size();i++){\\n           if(v[i][0]<=r){\\n              r=min(r,v[i][1]); //ending value of common interval\\n              l=max(l,v[i][0]); // starting value of common interval\\n           }\\n           else{\\n               cnt++; // no common interval hence increment the count\\n               l=v[i][0]; //update the start value of common interval by start value of current index.\\n               r=v[i][1];  //update the ending point of common interval by ending value of current index.\\n           }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n---\\n\\u2705Please Upvote if you like it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1686744,
                "title": "c-sort-by-r-value-easy-code",
                "content": "Since we have to minimize the number of arrows. So we will try to shoot arrow in such manner that it will burst as many as balloon it can. So let\\'s represent a point by (l,r). If we sort all points by r values and shoot the arrow on r value it will be always beneficial for us. Beacuse this shoot may burst the next few ballons and try to minimize the number of arrows.\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) \\n    {\\n        int n=points.size(),i,ans=1,cur;\\n        vector <pair<int,int>> a;\\n        for(i=0;i<n;i++)\\n        {\\n            a.push_back({points[i][1],points[i][0]});\\n        }\\n        sort(a.begin(),a.end());\\n        cur=a[0].first;\\n        for(i=1;i<n;i++)\\n        {\\n            if(a[i].second>cur)\\n            {\\n                cur=a[i].first;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) \\n    {\\n        int n=points.size(),i,ans=1,cur;\\n        vector <pair<int,int>> a;\\n        for(i=0;i<n;i++)\\n        {\\n            a.push_back({points[i][1],points[i][0]});\\n        }\\n        sort(a.begin(),a.end());\\n        cur=a[0].first;\\n        for(i=1;i<n;i++)\\n        {\\n            if(a[i].second>cur)\\n            {\\n                cur=a[i].first;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381051,
                "title": "c-easy-solution-with-explanation",
                "content": "```\\n//first sort the array\\nsort(points.begin(),points.end());\\n\\n//start is the start of first balloon\\n        int start = points[0][0];\\n\\t\\t\\n//end is the end of first balloon\\n        int end = points[0][1];\\n\\t\\t\\n// we would need atleast 1 arrow to burst the first balloon\\n        int ans = 1;\\n\\t\\t\\n//start a for loop for other balloons\\n        for(int i=1;i<points.size();i++){\\n\\t\\t\\n//if start of any balloon is before end of the balloon, it means they coincide\\n                if(points[i][0]<=end){\\n\\t\\t\\t\\t\\n// since we need to find the intersection, find the start value more to the right\\n                    start = max(start,points[i][0]);\\n\\t\\t\\t\\t\\t\\n// since we need to find the intersection, find the end value more to the left\\n                    end = min(end,points[i][1]);\\n                }else{\\n\\t\\t\\t\\t\\n//else we know that the current balloon doesnt coincide with other balloons \\n//so we set start and end to the current balloon and increase the ans by one\\n                    start = points[i][0];\\n                    end = points[i][1];\\n                    ans++;\\n                }\\n        }\\n        return ans;\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\n//first sort the array\\nsort(points.begin(),points.end());\\n\\n//start is the start of first balloon\\n        int start = points[0][0];\\n\\t\\t\\n//end is the end of first balloon\\n        int end = points[0][1];\\n\\t\\t\\n// we would need atleast 1 arrow to burst the first balloon\\n        int ans = 1;\\n\\t\\t\\n//start a for loop for other balloons\\n        for(int i=1;i<points.size();i++){\\n\\t\\t\\n//if start of any balloon is before end of the balloon, it means they coincide\\n                if(points[i][0]<=end){\\n\\t\\t\\t\\t\\n// since we need to find the intersection, find the start value more to the right\\n                    start = max(start,points[i][0]);\\n\\t\\t\\t\\t\\t\\n// since we need to find the intersection, find the end value more to the left\\n                    end = min(end,points[i][1]);\\n                }else{\\n\\t\\t\\t\\t\\n//else we know that the current balloon doesnt coincide with other balloons \\n//so we set start and end to the current balloon and increase the ans by one\\n                    start = points[i][0];\\n                    end = points[i][1];\\n                    ans++;\\n                }\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 888564,
                "title": "easy-to-understand-c-solution-sorting-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(begin(points), end(points));\\n        int count = 0, i = 0, n = points.size();\\n        while (i < n) {\\n            int maxVal = points[i][1];\\n            while (i < n && points[i][0] <= maxVal) \\n                maxVal = min(maxVal, points[i++][1]);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(begin(points), end(points));\\n        int count = 0, i = 0, n = points.size();\\n        while (i < n) {\\n            int maxVal = points[i][1];\\n            while (i < n && points[i][0] <= maxVal) \\n                maxVal = min(maxVal, points[i++][1]);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888416,
                "title": "c-solution-with-full-explanation-greedy",
                "content": "1. Sort on start time.\\n1. Keep a variable to save the last interval you saw.\\n1. Just check if the intervals overlap, if yes, then update the last interval to merged interval. This will basically mean you can burst both the balloons with just 1 arrow.\\n1. If the intervals do not overlap, save this copy of interval as the last seen interval and update the answer by 1 since now you\\'ll require at least 2 arrows for bursting the 2 sets of balloons.\\n\\n  When trying to include a interval in the last interval I saw, there can only be 3 cases:\\n\\n    Case 1. Interescting overlapping intervals:\\n        I--------I\\n              I------I     \\n    --------------------\\n    >>        I--I\\n    We update the ans.back() with intersecting area since an array here would hit them both.\\n\\n\\n    Case 2. Intersecting included intervals:\\n        I--------I\\n           I--I\\n    ------------------\\n    >>     I--I\\n    We update the ans.back() with intersecting area since an array here would hit them both.\\n\\n\\n    Case 3. Nonintersecting intervals:\\n        I--------I\\n                    I--------I\\n     ------------------------------\\n    >>  I--------I  I--------I\\n    We push another interval in ans() since there needs to be 2 arrows now to hit them both.\\n    \\n    There will never be a 4th case that the start of j is lesser than ans.back() since they are sorted.\\n\\n\\nApproach 1: When you just need to know the number of arrows:\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& p) {\\n        if (p.size() <= 1)\\n            return p.size();\\n\\t\\t\\t\\n        sort(p.begin(), p.end());\\n        int ans=0;\\n\\t\\t\\n        int lastIntervalEndTime = p[0][1];\\n\\n        for(auto currentInterval: p){\\n            // If the ballons overlap, then keep the overlapping interval\\n            if(lastIntervalEndTime >= currentInterval[0]){\\n                lastIntervalEndTime = min(lastIntervalEndTime, currentInterval[1]);\\n            }\\n            // If they do not overlap, then keep current interval as the last interval & inrease ans\\n            else {\\n                ans++;\\n                lastIntervalEndTime = currentInterval[1];\\n            }\\n        }\\n        ans++;\\n        return ans;\\n    }\\n};\\n```\\n\\nApproach 2: When you need all the intervals:\\n```\\t\\nclass Solution {\\npublic:\\n  int findMinArrowShots(vector<vector<int>>& p) {\\n    \\n    // 0 arrows for 0 balloon, 1 arrow for 1 balloon.\\n    if (p.size() <= 1)\\n      return p.size();\\n    \\n    // Sort the intervals on their starting x and then on ending x.\\n    // sort(p.begin(), p.end());\\n    // This would also do but my own comparator is faster ;)\\n    sort(p.begin(), p.end(),\\n      [](const std::vector<int>& a, const std::vector<int>& b) {\\n      if(a[0]==b[0]) \\n        return a[1] < b[1];\\n      else\\n        return a[0] < b[0];\\n    });\\n    \\n    int j=1;\\n    // This vector of intervals would store the minimum number of intervals which would be hit by an arrow\\n    vector<pair<int, int>> ans;\\n    // Start with the pushing the first interval in the vector, we will keep updating as required.\\n    ans.push_back(make_pair(p[0][0], p[0][1]));\\n  \\n    while(j<p.size()){\\n      \\n      int ans_back = ans.back().second;\\n      int j_start = p[j][0];\\n      int j_end = p[j][1];\\n      \\n      // Case 1\\n      if(j_start <= ans_back && j_end > ans_back){\\n        ans.pop_back();\\n        ans.push_back(make_pair(j_start, ans_back));\\n      }\\n      // Case 2\\n      else if (j_start <= ans_back && j_end <= ans_back){\\n        ans.pop_back();\\n        ans.push_back(make_pair(j_start, j_end));\\n      }\\n      // Case 3\\n      else {\\n        ans.push_back(make_pair(j_start, j_end));\\n      }\\n      \\n      j++;\\n    }\\n    \\n\\t// Returning ans would actually give you the intervals where the arrows must be shot.\\n    return ans.size();\\n  }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& p) {\\n        if (p.size() <= 1)\\n            return p.size();\\n\\t\\t\\t\\n        sort(p.begin(), p.end());\\n        int ans=0;\\n\\t\\t\\n        int lastIntervalEndTime = p[0][1];\\n\\n        for(auto currentInterval: p){\\n            // If the ballons overlap, then keep the overlapping interval\\n            if(lastIntervalEndTime >= currentInterval[0]){\\n                lastIntervalEndTime = min(lastIntervalEndTime, currentInterval[1]);\\n            }\\n            // If they do not overlap, then keep current interval as the last interval & inrease ans\\n            else {\\n                ans++;\\n                lastIntervalEndTime = currentInterval[1];\\n            }\\n        }\\n        ans++;\\n        return ans;\\n    }\\n};\\n```\n```\\t\\nclass Solution {\\npublic:\\n  int findMinArrowShots(vector<vector<int>>& p) {\\n    \\n    // 0 arrows for 0 balloon, 1 arrow for 1 balloon.\\n    if (p.size() <= 1)\\n      return p.size();\\n    \\n    // Sort the intervals on their starting x and then on ending x.\\n    // sort(p.begin(), p.end());\\n    // This would also do but my own comparator is faster ;)\\n    sort(p.begin(), p.end(),\\n      [](const std::vector<int>& a, const std::vector<int>& b) {\\n      if(a[0]==b[0]) \\n        return a[1] < b[1];\\n      else\\n        return a[0] < b[0];\\n    });\\n    \\n    int j=1;\\n    // This vector of intervals would store the minimum number of intervals which would be hit by an arrow\\n    vector<pair<int, int>> ans;\\n    // Start with the pushing the first interval in the vector, we will keep updating as required.\\n    ans.push_back(make_pair(p[0][0], p[0][1]));\\n  \\n    while(j<p.size()){\\n      \\n      int ans_back = ans.back().second;\\n      int j_start = p[j][0];\\n      int j_end = p[j][1];\\n      \\n      // Case 1\\n      if(j_start <= ans_back && j_end > ans_back){\\n        ans.pop_back();\\n        ans.push_back(make_pair(j_start, ans_back));\\n      }\\n      // Case 2\\n      else if (j_start <= ans_back && j_end <= ans_back){\\n        ans.pop_back();\\n        ans.push_back(make_pair(j_start, j_end));\\n      }\\n      // Case 3\\n      else {\\n        ans.push_back(make_pair(j_start, j_end));\\n      }\\n      \\n      j++;\\n    }\\n    \\n\\t// Returning ans would actually give you the intervals where the arrows must be shot.\\n    return ans.size();\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888395,
                "title": "c-super-simple-easy-solution-using-custom-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool sort_by_end(const vector<int>& a, const vector<int>& b) {\\n        return a[1] < b[1];\\n    }\\n    \\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        if (points.size() <= 1) return points.size();\\n        sort(points.begin(), points.end(), sort_by_end);\\n        int arrows = 1;\\n        vector<int> curr = points[0];\\n        for (auto balloon : points) {\\n            if (curr[1] < balloon[0]) {\\n                curr = balloon;\\n                arrows++;\\n            }\\n        }\\n        return arrows;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool sort_by_end(const vector<int>& a, const vector<int>& b) {\\n        return a[1] < b[1];\\n    }\\n    \\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        if (points.size() <= 1) return points.size();\\n        sort(points.begin(), points.end(), sort_by_end);\\n        int arrows = 1;\\n        vector<int> curr = points[0];\\n        for (auto balloon : points) {\\n            if (curr[1] < balloon[0]) {\\n                curr = balloon;\\n                arrows++;\\n            }\\n        }\\n        return arrows;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888377,
                "title": "python-super-simple-and-short-solution-o-nlogn-faster-than-92",
                "content": "```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        if len(points) == 0:\\n            return 0\\n        points.sort(key = lambda a:a[1])\\n        arrows = 1\\n        curr = points[0]\\n        for balloon in points:\\n            if curr[1] < balloon[0]:\\n                curr = balloon\\n                arrows+=1\\n        return arrows\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        if len(points) == 0:\\n            return 0\\n        points.sort(key = lambda a:a[1])\\n        arrows = 1\\n        curr = points[0]\\n        for balloon in points:\\n            if curr[1] < balloon[0]:\\n                curr = balloon\\n                arrows+=1\\n        return arrows\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888145,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution {\\n    public int FindMinArrowShots(int[][] p) {\\n        \\n        if(!p.Any()) { return 0; }\\n        \\n        var points = p.OrderBy(x => x[1]);\\n        int result = 1;\\n        int lastArrowXPosition = points.First().Last();\\n        \\n        foreach(var x in points.Skip(1))\\n        {\\n            if(x[0] > lastArrowXPosition) \\n            {\\n                result++;\\n                lastArrowXPosition = x[1];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int FindMinArrowShots(int[][] p) {\\n        \\n        if(!p.Any()) { return 0; }\\n        \\n        var points = p.OrderBy(x => x[1]);\\n        int result = 1;\\n        int lastArrowXPosition = points.First().Last();\\n        \\n        foreach(var x in points.Skip(1))\\n        {\\n            if(x[0] > lastArrowXPosition) \\n            {\\n                result++;\\n                lastArrowXPosition = x[1];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888132,
                "title": "java-intuition-explained-commented-code",
                "content": "**UPVOTE if helful!!**\\n * This question is similar to merge intervals. \\n* When you see interval questions, try to sort the array and figure out how can you achieve the required answer.\\n* We sort the array by last element of every point as we need to maximize the ballons burst.\\n\\n```\\npublic int findMinArrowShots(int[][] points) {\\n\\n        if (points.length == 0) return 0;\\n        Arrays.sort(points, Comparator.comparingInt(a -> a[1])); // sort by end element of every balloon.\\n\\n\\n        int arrowsFired = 1;//1 arrow will always be fired\\n        int arrowFiredValue = points[0][1]; //fire arrow at point\\'s end to cover max distance.\\n        for (int i = 1; i < points.length; i++) {\\n            \\n            int left = points[i][0];\\n            int right = points[i][1];\\n            \\n            //check whether the arrowFired can burst other balloons.\\n            //if not fire arrow at the next point end value\\n            if (!(arrowFiredValue >= left && arrowFiredValue <= right)) {\\n                \\n                arrowsFired++; // increase the arrowsFired by 1.\\n                arrowFiredValue = points[i][1];  // next point end value.\\n                \\n            }\\n        }\\n\\n        return arrowsFired;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int findMinArrowShots(int[][] points) {\\n\\n        if (points.length == 0) return 0;\\n        Arrays.sort(points, Comparator.comparingInt(a -> a[1])); // sort by end element of every balloon.\\n\\n\\n        int arrowsFired = 1;//1 arrow will always be fired\\n        int arrowFiredValue = points[0][1]; //fire arrow at point\\'s end to cover max distance.\\n        for (int i = 1; i < points.length; i++) {\\n            \\n            int left = points[i][0];\\n            int right = points[i][1];\\n            \\n            //check whether the arrowFired can burst other balloons.\\n            //if not fire arrow at the next point end value\\n            if (!(arrowFiredValue >= left && arrowFiredValue <= right)) {\\n                \\n                arrowsFired++; // increase the arrowsFired by 1.\\n                arrowFiredValue = points[i][1];  // next point end value.\\n                \\n            }\\n        }\\n\\n        return arrowsFired;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 887605,
                "title": "corner-case-2147483646-2147483645-2147483646-214-java",
                "content": "**Test case** \\n[[-2147483646,-2147483645],[2147483646,2147483647]] \\n\\n```Arrays.sort(intervals,(a,b)->a[1]-b[1]);```\\nIf you are using subtraction for compartor, it will cause Integer overflow & cause sort to behave in unexpected ways.\\n\\nInstead use ```Arrays.sort(points, (a, b) -> Integer.compare(a[1],b[1]));```\\n\\n\\n",
                "solutionTags": [],
                "code": "```Arrays.sort(intervals,(a,b)->a[1]-b[1]);```\n```Arrays.sort(points, (a, b) -> Integer.compare(a[1],b[1]));```",
                "codeTag": "Unknown"
            },
            {
                "id": 887557,
                "title": "python-greedy",
                "content": "An instance of problems related to greedy algorithms.\\n\\n1. Sort intervals by the end points in increasing order.\\n2. At first you consider the balloon with smallest end point. Call this point `y`. You need one arrow to burst this. While the next baloon has a start point less than `y` you can burst it with the same arrow. (This is true, as `y` will always be included in this one. Imagine we are always shooting the arrow at location `y`.)\\n3. If not, this balloon needs a new arrow, and we update `y`.\\n\\n\\nNote: Here the invariant is the balloon we are considering. At every step we pick the balloon with smallest `y` which requires a new arrow to burst.\\n\\n```\\nclass Solution:\\n    def findMinArrowShots(self, A):\\n        if not A: return 0\\n        A.sort(key=lambda x:x[1])\\n        ret = 1\\n        right = A[0][1]\\n        for x,y in A:\\n            if x<=right:\\n                continue\\n            ret += 1\\n            right = y\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMinArrowShots(self, A):\\n        if not A: return 0\\n        A.sort(key=lambda x:x[1])\\n        ret = 1\\n        right = A[0][1]\\n        for x,y in A:\\n            if x<=right:\\n                continue\\n            ret += 1\\n            right = y\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93767,
                "title": "java-easy-to-understand-solution",
                "content": "```\\npublic class Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        if (points == null || points.length == 0)   return 0;\\n\\n        Arrays.sort(points,(a, b) -> a[0] - b[0]);       //sort the balloons according to their start coordinate\\n        \\n        int minRight = Integer.MAX_VALUE, count = 0;\\n        //minRight record the leftmost end of previous balloons\\n        for (int i = 0; i < points.length; ++i) {\\n            //whenever current balloon's start is bigger than minRight\\n            //that means we need an arrow to clear all previous balloons\\n            if (points[i][0] > minRight) {                   \\n                count++;\\n                minRight = points[i][1];\\n            } else {\\n                minRight = Math.min(minRight, points[i][1]);\\n            }\\n        }\\n        return count + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        if (points == null || points.length == 0)   return 0;\\n\\n        Arrays.sort(points,(a, b) -> a[0] - b[0]);       //sort the balloons according to their start coordinate\\n        \\n        int minRight = Integer.MAX_VALUE, count = 0;\\n        //minRight record the leftmost end of previous balloons\\n        for (int i = 0; i < points.length; ++i) {\\n            //whenever current balloon's start is bigger than minRight\\n            //that means we need an arrow to clear all previous balloons\\n            if (points[i][0] > minRight) {                   \\n                count++;\\n                minRight = points[i][1];\\n            } else {\\n                minRight = Math.min(minRight, points[i][1]);\\n            }\\n        }\\n        return count + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93737,
                "title": "concise-java-solution-tracking-the-end-of-overlapping-intervals",
                "content": "```\\npublic class Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        if(points == null || points.length < 1) return 0;\\n        Arrays.sort(points, (a, b)->(a[0]-b[0]));\\n        int result = 1;\\n        int end = points[0][1];\\n        for(int i = 1; i < points.length; i ++) {\\n            if(points[i][0] > end) {\\n                result ++;\\n                end = points[i][1];\\n            } else {\\n                end = Math.min(end, points[i][1]);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        if(points == null || points.length < 1) return 0;\\n        Arrays.sort(points, (a, b)->(a[0]-b[0]));\\n        int result = 1;\\n        int end = points[0][1];\\n        for(int i = 1; i < points.length; i ++) {\\n            if(points[i][0] > end) {\\n                result ++;\\n                end = points[i][1];\\n            } else {\\n                end = Math.min(end, points[i][1]);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001122,
                "title": "java-easy-to-understand-sorting-greedy",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can sort the array on the Xend coordinate and take the right most point that is the points[i][1] as arrow\\'s Position and we skip all the intervals in which this current position lies and increment the count of arrow when arrow\\'s position is less than points[i][0] i.e. Xstart. \\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1],b[1]));\\n        int arrow = 1;\\n        int arrowPos = points[0][1];\\n\\n        for(int i=0;i<points.length;i++){\\n            if(points[i][0]<=arrowPos) continue;\\n            arrowPos = points[i][1];\\n            arrow++;\\n        }\\n        return arrow;\\n    }\\n}\\n```\\n***Upvote If You Like!!!***\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1],b[1]));\\n        int arrow = 1;\\n        int arrowPos = points[0][1];\\n\\n        for(int i=0;i<points.length;i++){\\n            if(points[i][0]<=arrowPos) continue;\\n            arrowPos = points[i][1];\\n            arrow++;\\n        }\\n        return arrow;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1686942,
                "title": "c-python-simple-and-clean-solutions",
                "content": "We sort the `points` by the end.\\nWe shot the first arrow at the end of the first point.\\nWe keep the current arrow\\'s point of shot in `curr`.\\nThen, for each balloon, we check if the previous arrow shot it already, if not - update `curr` and increment the number of arrows.\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    static bool sort_by_end(const vector<int>& a, const vector<int>& b) {\\n        return a[1] < b[1];\\n    }\\n    \\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        if (points.size() <= 1) return points.size();\\n        sort(points.begin(), points.end(), sort_by_end);\\n        int arrows = 1;\\n        vector<int> curr = points[0];\\n        for (auto balloon : points) {\\n            if (curr[1] < balloon[0]) {\\n                curr = balloon;\\n                arrows++;\\n            }\\n        }\\n        return arrows;\\n    }\\n};\\n```\\n****\\n**Python:**\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        if len(points) == 0:\\n            return 0\\n        points.sort(key = lambda a:a[1])\\n        arrows = 1\\n        curr = points[0]\\n        for balloon in points:\\n            if curr[1] < balloon[0]:\\n                curr = balloon\\n                arrows+=1\\n        return arrows\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool sort_by_end(const vector<int>& a, const vector<int>& b) {\\n        return a[1] < b[1];\\n    }\\n    \\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        if (points.size() <= 1) return points.size();\\n        sort(points.begin(), points.end(), sort_by_end);\\n        int arrows = 1;\\n        vector<int> curr = points[0];\\n        for (auto balloon : points) {\\n            if (curr[1] < balloon[0]) {\\n                curr = balloon;\\n                arrows++;\\n            }\\n        }\\n        return arrows;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        if len(points) == 0:\\n            return 0\\n        points.sort(key = lambda a:a[1])\\n        arrows = 1\\n        curr = points[0]\\n        for balloon in points:\\n            if curr[1] < balloon[0]:\\n                curr = balloon\\n                arrows+=1\\n        return arrows\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1686267,
                "title": "very-greedy-and-small-code-c",
                "content": "**Every step you need Check with previous step and store the minimum last value**\\n\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& v) {\\n        sort(v.begin(), v.end());\\n        int ln = v.size(), cnt = 1;\\n        for(int i = 1; i<ln; i++) {\\n            if(v[i][0]<=v[i-1][1]){\\n                v[i][1] = min(v[i][1], v[i-1][1]);\\n            }\\n            else cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& v) {\\n        sort(v.begin(), v.end());\\n        int ln = v.size(), cnt = 1;\\n        for(int i = 1; i<ln; i++) {\\n            if(v[i][0]<=v[i-1][1]){\\n                v[i][1] = min(v[i][1], v[i-1][1]);\\n            }\\n            else cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888390,
                "title": "c-simple-solution-96-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    static bool comp(const vector<int>& vec1, const vector<int>& vec2)\\n    {\\n\\t    return vec1[1] < vec2[1];\\n    }\\n\\t\\n\\tint findMinArrowShots(vector<vector<int>>& points) \\n    {\\n\\t\\tif (points.size() <= 1) \\n\\t\\t\\treturn points.size();\\n\\t\\t\\t\\n\\t\\tsort(points.begin(), points.end(), comp);\\n\\n\\t\\tint minNumArrow = 0;\\n\\t\\tint tmp = points[0][1];\\n\\n\\t\\tfor (int i = 1; i < points.size(); i++)\\n\\t\\t{\\n\\t\\t\\tminNumArrow += points[i][0] > tmp;\\n\\t\\t\\ttmp = points[i][0] > tmp ? points[i][1] : tmp;\\n\\t\\t}\\n\\n\\t\\treturn minNumArrow + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool comp(const vector<int>& vec1, const vector<int>& vec2)\\n    {\\n\\t    return vec1[1] < vec2[1];\\n    }\\n\\t\\n\\tint findMinArrowShots(vector<vector<int>>& points) \\n    {\\n\\t\\tif (points.size() <= 1) \\n\\t\\t\\treturn points.size();\\n\\t\\t\\t\\n\\t\\tsort(points.begin(), points.end(), comp);\\n\\n\\t\\tint minNumArrow = 0;\\n\\t\\tint tmp = points[0][1];\\n\\n\\t\\tfor (int i = 1; i < points.size(); i++)\\n\\t\\t{\\n\\t\\t\\tminNumArrow += points[i][0] > tmp;\\n\\t\\t\\ttmp = points[i][0] > tmp ? points[i][1] : tmp;\\n\\t\\t}\\n\\n\\t\\treturn minNumArrow + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716227,
                "title": "c-greedy-solution",
                "content": "sorting the values according to their end x. Then selecting the balloon greedily.\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& p) {\\n        sort(p.begin(),p.end(),[](vector<int>&a,vector<int>&b){\\n            if(a[1]==b[1])return a[0]<b[0];\\n            return a[1]<b[1];\\n        });\\n        int ans=0,n=p.size();\\n        if(n==0)return 0;\\n        ans=1;\\n        int prev=p[0][1];\\n        for(int i=1;i<n;i++){\\n            if(prev>=p[i][0])continue;\\n            ans++;\\n            prev=p[i][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& p) {\\n        sort(p.begin(),p.end(),[](vector<int>&a,vector<int>&b){\\n            if(a[1]==b[1])return a[0]<b[0];\\n            return a[1]<b[1];\\n        });\\n        int ans=0,n=p.size();\\n        if(n==0)return 0;\\n        ans=1;\\n        int prev=p[0][1];\\n        for(int i=1;i<n;i++){\\n            if(prev>=p[i][0])continue;\\n            ans++;\\n            prev=p[i][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 450910,
                "title": "python-with-clear-explanation-and-small-twist-for-better-understanding",
                "content": "```\\nclass Solution:\\n    \\'\\'\\'\\n    this question is basically finding the max number of pairs of overlaping intervals\\n    Idea:\\n        1. initially, if you have all of the intervals non-overlapping, we will need len(points) arrows to burst all of them\\n        2. if any overlapping pair of points found, we will decrement that number by one, \\n           because we will use one arrow to burst them\\n        3. now, other than a pair of overlapping points, we also want to see if any more points\\n           can be burst at the same that, that means, let\\'s say we have three points that can be \\n           burst at the same time like [[1,3], [1,8], [2,3]], we need to find out that whether the smaller\\n           intervals have overlapping. Thus, we want to keep track of the smaller intervals, by \\n           keep track of the smaller end of the overlapping pairs\\n    \\'\\'\\'\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        if not points:\\n            return 0\\n        if len(points) == 1:\\n            return 1\\n        points.sort(key=lambda x: x[0]) \\n        arrows = len(points) # initialize the number of arrows needed to be one for each point\\n        curr_end = points[0][1]\\n        for i in range(1, len(points)):\\n            if points[i][0] <= curr_end:\\n                # check if overlapping\\n                curr_end = min(curr_end, points[i][1]) # track of the smaller interval for this overlapped pairs\\n                arrows -= 1 # decrement one arrow\\n            else:\\n                curr_end = points[i][1] # replace the tracking record if the current interval are non overlapped with previous one\\n        return arrows\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\'\\'\\'\\n    this question is basically finding the max number of pairs of overlaping intervals\\n    Idea:\\n        1. initially, if you have all of the intervals non-overlapping, we will need len(points) arrows to burst all of them\\n        2. if any overlapping pair of points found, we will decrement that number by one, \\n           because we will use one arrow to burst them\\n        3. now, other than a pair of overlapping points, we also want to see if any more points\\n           can be burst at the same that, that means, let\\'s say we have three points that can be \\n           burst at the same time like [[1,3], [1,8], [2,3]], we need to find out that whether the smaller\\n           intervals have overlapping. Thus, we want to keep track of the smaller intervals, by \\n           keep track of the smaller end of the overlapping pairs\\n    \\'\\'\\'\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        if not points:\\n            return 0\\n        if len(points) == 1:\\n            return 1\\n        points.sort(key=lambda x: x[0]) \\n        arrows = len(points) # initialize the number of arrows needed to be one for each point\\n        curr_end = points[0][1]\\n        for i in range(1, len(points)):\\n            if points[i][0] <= curr_end:\\n                # check if overlapping\\n                curr_end = min(curr_end, points[i][1]) # track of the smaller interval for this overlapped pairs\\n                arrows -= 1 # decrement one arrow\\n            else:\\n                curr_end = points[i][1] # replace the tracking record if the current interval are non overlapped with previous one\\n        return arrows\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296532,
                "title": "python3-explanation-greedy-approach",
                "content": "\\nUse greedy strategy to solve this problem. A greedy solution template:\\n1. Select (elegentally) an input\\n2. Reduce the problem with the selected input\\n3. Repeat until the problem is reduced to the base case.\\n\\n\\nThe most (and only) important step is the first step: find a good strategy to select an input. In this case, we want to select a point to shot, then repeat until all ballons have been shot.\\n\\nIn order to minimize the number of shots, we want to shot as much baloons at the same time as possible. One way to do this is we can short the ballons \"vertically\" to make them arranged like the diagram bellow:\\n\\n```\\n --\\n---\\n ----\\n-----\\n   -----\\n  ------\\n -------\\n      -------\\n    ---------\\n```\\n\\nNow we can:\\n1. Shot from the right most of the top balloon\\n2. Remove all bursted ballonos\\n3. Repeat until there is no more baloon and count the number of shots\\n\\nFollowing these steps will guarantee to produce the minimum number of shots (even thought I have no idea how to prove it formally).\\n\\nIn the snippet bellow, the `Remove all the bursted baloons` is done in a better way by tracking the last shot position.\\n\\n```python\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        sorted_points = sorted(points, key = lambda x: (x[1], x[1] - x[0])) # Sort by left cordinate, then by width\\n        last_shot = -float(\\'inf\\')\\n        shot_count = 0\\n\\n        for baloon in sorted_points:\\n            if baloon[0] > last_shot:\\n                last_shot = baloon[1]\\n                shot_count += 1\\n                \\n        return shot_count\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\n --\\n---\\n ----\\n-----\\n   -----\\n  ------\\n -------\\n      -------\\n    ---------\\n```\n```python\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        sorted_points = sorted(points, key = lambda x: (x[1], x[1] - x[0])) # Sort by left cordinate, then by width\\n        last_shot = -float(\\'inf\\')\\n        shot_count = 0\\n\\n        for baloon in sorted_points:\\n            if baloon[0] > last_shot:\\n                last_shot = baloon[1]\\n                shot_count += 1\\n                \\n        return shot_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 243819,
                "title": "python-with-sort",
                "content": "```Python\\nclass Solution(object):\\n    def findMinArrowShots(self, points):\\n        if not points:\\n            return 0\\n\\n        points = sorted(points)\\n        ans = 1\\n        \\n        end = points[0][1]\\n        for s, e in points[1:]:\\n            if end >= s:\\n                end = min(end, e)\\n                continue\\n            ans += 1\\n            end = e\\n                \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution(object):\\n    def findMinArrowShots(self, points):\\n        if not points:\\n            return 0\\n\\n        points = sorted(points)\\n        ans = 1\\n        \\n        end = points[0][1]\\n        for s, e in points[1:]:\\n            if end >= s:\\n                end = min(end, e)\\n                continue\\n            ans += 1\\n            end = e\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 166071,
                "title": "python-solution",
                "content": "Greedy algorithm:\\nSort by the second number:\\n```\\nclass Solution(object):\\n    def findMinArrowShots(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not points:\\n            return 0\\n        points = sorted(points, key = lambda x: x[1])\\n        res = 1\\n        curr = points[0][1]\\n        for i in range(1, len(points)):\\n            if points[i][0] > curr:\\n                curr = points[i][1]\\n                res += 1\\n        return res\\n```\\nSort by the first number:\\n```\\nclass Solution(object):\\n    def findMinArrowShots(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not points:\\n            return 0\\n        points = sorted(points, key = lambda x: x[0])\\n        res = 1\\n        hi = points[0][1]\\n        for i in range(1, len(points)):\\n            if points[i][0] <= hi:\\n                hi = min(hi, points[i][1])\\n            else:\\n                res += 1\\n                hi = points[i][1]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findMinArrowShots(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not points:\\n            return 0\\n        points = sorted(points, key = lambda x: x[1])\\n        res = 1\\n        curr = points[0][1]\\n        for i in range(1, len(points)):\\n            if points[i][0] > curr:\\n                curr = points[i][1]\\n                res += 1\\n        return res\\n```\n```\\nclass Solution(object):\\n    def findMinArrowShots(self, points):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not points:\\n            return 0\\n        points = sorted(points, key = lambda x: x[0])\\n        res = 1\\n        hi = points[0][1]\\n        for i in range(1, len(points)):\\n            if points[i][0] <= hi:\\n                hi = min(hi, points[i][1])\\n            else:\\n                res += 1\\n                hi = points[i][1]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 112047,
                "title": "super-strict-and-detailed-proved-greedy-algorithm",
                "content": "# 452. Minimum Number of Arrows to Burst Balloons\\n\\n## Notation\\nFor convenience, we say the k<sup>th</sup> ballon as b<sub>k</sub>, first element of b<sub>k</sub> as s<sub>k</sub>, the second element of b<sub>k</sub> as e<sub>k</sub>, the total number of ballons as n.\\n\\n## Algorithm Description\\n(\\\\* If n = 0, directly return 0. The following is talking about the other case, when there are ballons. )\\n\\n1. First sort the array according to their s<sub>k</sub>\\n\\n2. Then we define S<sub>k</sub> and E<sub>k</sub> as follows (Intuitively, if the intersection of  the b<sub>k</sub> and the [S<sub>k-1</sub> , E<sub>k-1</sub>] exsits then [S<sub>k</sub>, E<sub>k</sub>] is that intersection, else [S<sub>k</sub>, E<sub>k</sub>] is b<sub>k</sub>):\\n\\n    1. S<sub>k</sub> is always same as s<sub>k</sub>\\n\\n    2. \\n        * If k = 0, E<sub>k</sub>=e<sub>k</sub>.\\n        * Else if k > 0:\\n            * If s<sub>k</sub> \\u2264 E<sub>k-1</sub> and e<sub>k</sub> > E<sub>k-1</sub> (It's c<sub>1</sub>, short for case 1):\\n                * E<sub>k</sub> = E<sub>k-1</sub>\\n            * If s<sub>k</sub> > E<sub>k-1</sub> (also means e<sub>k</sub> > E<sub>k-1</sub>) (It's c<sub>2</sub>, short for case 2):\\n                * E<sub>k</sub> = e<sub>k</sub>\\n            * If e<sub>k</sub>  \\u2264 E<sub>k-1</sub> (also means S<sub>k-1</sub> < s<sub>k</sub> < E<sub>k-1</sub>) (It's c<sub>3</sub>, short for case 3):\\n                * E<sub>k</sub> = e<sub>k</sub>\\n    \\n    Since s<sub>k</sub> is non-decreasing with k increasing, the above definition is complete (c<sub>1</sub>, c<sub>2</sub> and c<sub>3</sub> cover all possible cases) and unique. \\n\\n3. Now initially, set result r as 1, get S<sub>1</sub> and E<sub>1</sub> from b<sub>1</sub>, do the following iteration:\\n\\n    * For every k (from 2 to n):\\n        * if c<sub>1</sub> or c<sub>3</sub>:\\n            * r remain same\\n        * if c<sub>2</sub>:\\n            * r increase by 1\\n        * anyway get S<sub>k</sub> and E<sub>k</sub> according to definition\\n    * Return r\\n\\n\\n## Proof\\n\\nFor convenience, we say the result is r<sub>t</sub> after the t<sup>th</sup> iterateration. \\n\\n__(1). This algorithm will terminate in at most O(nlogn) time if n is finite.__\\n\\n\\n(1) is proved because if we use merge sort, it takes O(nlogn) time to finish the sorting part. This is followed by n iterations where each iteration takes constant time.\\n\\n\\n\\n__(2.1)For the first ballon, this algorithm result r <sub>1</sub> is correct and the r<sub>1</sub><sup>th</sup> arrow could be placed anywhere between [S<sub>1</sub>, E<sub>1</sub>]__\\n\\n\\n(2.1) is obviously correct.\\n\\n\\n__(2.2) If for the first t<sup>th</sup> ballons,  r<sub>t</sub> is correct and the r<sub>t</sub><sup>th</sup> arrow could be anywhere between [S<sub>t</sub>, E<sub>t</sub>], then for the first t+1<sup>th</sup> ballons, r<sub>t+1</sub> is correct and the r<sub>t+1</sub><sup>th</sup> arrow could be anywhere between [S<sub>t+1</sub>, E<sub>t+1</sub>]. (t = 1, 2, 3...)__\\n\\n\\nFor different cases of b<sub>t+1</sub>\\n\\n* If c1 and c3:\\n    * Since there is intersection i<sub>t+1</sub> between [s<sub>t+1</sub>, e<sub>t+1</sub>] and [S<sub>t</sub>, E<sub>t</sub>] and the r<sub>t</sub><sup>th</sup> arrow could be anywhere between [S<sub>t</sub>, E<sub>t</sub>], let the arrow in i<sub>t+1</sub>, which is both inside [S<sub>t</sub>, E<sub>t</sub>] and b<sub>t+1</sub>, then r remains same, that is r<sub>t+1</sub> = r<sub>t</sub> so __r is correct__ according to the algorithm. \\n     \\n        In this case, [S<sub>t+1</sub>, E<sub>t+1</sub>] is exactly i<sub>t + 1</sub>, so according to above paragraph, __the r<sub>t+1</sub><sup>th</sup> arrow could be anywhere between [S<sub>t+1</sub>, E<sub>t+1</sub>]__\\n\\n\\n* If c2:\\n    *  Since s<sub>t+1</sub> > E<sub>t</sub> and E<sub>t</sub> is at most e<sub>t</sub>, so there is no intersection between any of the ballons with b<sub>t+1</sub>. Thus r need to be increased by 1 to cover b<sub>t+1</sub>, that is r<sub>t+1</sub> = r<sub>t</sub> + 1, according to the algorithm __r<sub>t+1</sub> is correct__ and __the new arrow, a.k.a the r<sub>t+1</sub><sup>th</sup> arrow could obviously be anywhere in [S<sub>t+1</sub>, E<sub>t+1</sub>]__, which is also b<sub>t+1</sub>\\n\\nThus, (2.2) is proved.\\n\\nAccording to (2.1) and (2.2), this algorithm returns correct result for any finite valid input.",
                "solutionTags": [],
                "code": "# 452. Minimum Number of Arrows to Burst Balloons\\n\\n## Notation\\nFor convenience, we say the k<sup>th</sup> ballon as b<sub>k</sub>, first element of b<sub>k</sub> as s<sub>k</sub>, the second element of b<sub>k</sub> as e<sub>k</sub>, the total number of ballons as n.\\n\\n## Algorithm Description\\n(\\\\* If n = 0, directly return 0. The following is talking about the other case, when there are ballons. )\\n\\n1. First sort the array according to their s<sub>k</sub>\\n\\n2. Then we define S<sub>k</sub> and E<sub>k</sub> as follows (Intuitively, if the intersection of  the b<sub>k</sub> and the [S<sub>k-1</sub> , E<sub>k-1</sub>] exsits then [S<sub>k</sub>, E<sub>k</sub>] is that intersection, else [S<sub>k</sub>, E<sub>k</sub>] is b<sub>k</sub>):\\n\\n    1. S<sub>k</sub> is always same as s<sub>k</sub>\\n\\n    2. \\n        * If k = 0, E<sub>k</sub>=e<sub>k</sub>.\\n        * Else if k > 0:\\n            * If s<sub>k</sub> \\u2264 E<sub>k-1</sub> and e<sub>k</sub> > E<sub>k-1</sub> (It's c<sub>1</sub>, short for case 1):\\n                * E<sub>k</sub> = E<sub>k-1</sub>\\n            * If s<sub>k</sub> > E<sub>k-1</sub> (also means e<sub>k</sub> > E<sub>k-1</sub>) (It's c<sub>2</sub>, short for case 2):\\n                * E<sub>k</sub> = e<sub>k</sub>\\n            * If e<sub>k</sub>  \\u2264 E<sub>k-1</sub> (also means S<sub>k-1</sub> < s<sub>k</sub> < E<sub>k-1</sub>) (It's c<sub>3</sub>, short for case 3):\\n                * E<sub>k</sub> = e<sub>k</sub>\\n    \\n    Since s<sub>k</sub> is non-decreasing with k increasing, the above definition is complete (c<sub>1</sub>, c<sub>2</sub> and c<sub>3</sub> cover all possible cases) and unique. \\n\\n3. Now initially, set result r as 1, get S<sub>1</sub> and E<sub>1</sub> from b<sub>1</sub>, do the following iteration:\\n\\n    * For every k (from 2 to n):\\n        * if c<sub>1</sub> or c<sub>3</sub>:\\n            * r remain same\\n        * if c<sub>2</sub>:\\n            * r increase by 1\\n        * anyway get S<sub>k</sub> and E<sub>k</sub> according to definition\\n    * Return r\\n\\n\\n## Proof\\n\\nFor convenience, we say the result is r<sub>t</sub> after the t<sup>th</sup> iterateration. \\n\\n__(1). This algorithm will terminate in at most O(nlogn) time if n is finite.__\\n\\n\\n(1) is proved because if we use merge sort, it takes O(nlogn) time to finish the sorting part. This is followed by n iterations where each iteration takes constant time.\\n\\n\\n\\n__(2.1)For the first ballon, this algorithm result r <sub>1</sub> is correct and the r<sub>1</sub><sup>th</sup> arrow could be placed anywhere between [S<sub>1</sub>, E<sub>1</sub>]__\\n\\n\\n(2.1) is obviously correct.\\n\\n\\n__(2.2) If for the first t<sup>th</sup> ballons,  r<sub>t</sub> is correct and the r<sub>t</sub><sup>th</sup> arrow could be anywhere between [S<sub>t</sub>, E<sub>t</sub>], then for the first t+1<sup>th</sup> ballons, r<sub>t+1</sub> is correct and the r<sub>t+1</sub><sup>th</sup> arrow could be anywhere between [S<sub>t+1</sub>, E<sub>t+1</sub>]. (t = 1, 2, 3...)__\\n\\n\\nFor different cases of b<sub>t+1</sub>\\n\\n* If c1 and c3:\\n    * Since there is intersection i<sub>t+1</sub> between [s<sub>t+1</sub>, e<sub>t+1</sub>] and [S<sub>t</sub>, E<sub>t</sub>] and the r<sub>t</sub><sup>th</sup> arrow could be anywhere between [S<sub>t</sub>, E<sub>t</sub>], let the arrow in i<sub>t+1</sub>, which is both inside [S<sub>t</sub>, E<sub>t</sub>] and b<sub>t+1</sub>, then r remains same, that is r<sub>t+1</sub> = r<sub>t</sub> so __r is correct__ according to the algorithm. \\n     \\n        In this case, [S<sub>t+1</sub>, E<sub>t+1</sub>] is exactly i<sub>t + 1</sub>, so according to above paragraph, __the r<sub>t+1</sub><sup>th</sup> arrow could be anywhere between [S<sub>t+1</sub>, E<sub>t+1</sub>]__\\n\\n\\n* If c2:\\n    *  Since s<sub>t+1</sub> > E<sub>t</sub> and E<sub>t</sub> is at most e<sub>t</sub>, so there is no intersection between any of the ballons with b<sub>t+1</sub>. Thus r need to be increased by 1 to cover b<sub>t+1</sub>, that is r<sub>t+1</sub> = r<sub>t</sub> + 1, according to the algorithm __r<sub>t+1</sub> is correct__ and __the new arrow, a.k.a the r<sub>t+1</sub><sup>th</sup> arrow could obviously be anywhere in [S<sub>t+1</sub>, E<sub>t+1</sub>]__, which is also b<sub>t+1</sub>\\n\\nThus, (2.2) is proved.\\n\\nAccording to (2.1) and (2.2), this algorithm returns correct result for any finite valid input.",
                "codeTag": "Unknown"
            },
            {
                "id": 3003858,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n      Arrays.sort(points,(point1,point2) ->Integer.compare(point1[1],point2[1]));\\n      int arrow=1;\\n      int pos=points[0][1];\\n      for(int i=1;i<points.length;i++){\\n          if(pos>=points[i][0]){\\n              continue;\\n          }\\n          arrow++;\\n          pos=points[i][1];\\n      }\\n      return arrow;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n      Arrays.sort(points,(point1,point2) ->Integer.compare(point1[1],point2[1]));\\n      int arrow=1;\\n      int pos=points[0][1];\\n      for(int i=1;i<points.length;i++){\\n          if(pos>=points[i][0]){\\n              continue;\\n          }\\n          arrow++;\\n          pos=points[i][1];\\n      }\\n      return arrow;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003641,
                "title": "python-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key = lambda x: x[0])\\n\\n        # keep track of the end coordinate of the last balloon we burst\\n        last_end = float(\\'-inf\\')\\n        arrow_count = 0\\n\\n        for start, end in points:\\n            # if the current balloon starts before the last one ended,\\n            # we can burst it with the same arrow\\n            if start <= last_end:\\n                last_end = min(last_end, end)\\n            else:\\n                # otherwise, we need a new arrow to burst the balloon\\n                arrow_count += 1\\n                last_end = end\\n\\n        return arrow_count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key = lambda x: x[0])\\n\\n        # keep track of the end coordinate of the last balloon we burst\\n        last_end = float(\\'-inf\\')\\n        arrow_count = 0\\n\\n        for start, end in points:\\n            # if the current balloon starts before the last one ended,\\n            # we can burst it with the same arrow\\n            if start <= last_end:\\n                last_end = min(last_end, end)\\n            else:\\n                # otherwise, we need a new arrow to burst the balloon\\n                arrow_count += 1\\n                last_end = end\\n\\n        return arrow_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003308,
                "title": "with-image-illustrations-simple-explanation-java",
                "content": "# **Illustration:**\\n![Untitled-2023-01-05-1859.png](https://assets.leetcode.com/users/images/a24eb3cb-c7da-426f-8e21-0d8fddeb01df_1672927771.5162644.png)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n\\n        // get the total number of balloons given.\\n        int noOfBalloons = points.length;\\n\\n        // Sort the given array positions along the X coordinate.\\n        Arrays.sort(points, (b1, b2) -> Integer.compare(b1[1], b2[1]));\\n\\n        // first of all the arrow required to burst the first balloon is 1,\\n            // as however we need to burst first balloon.\\n        int minArrowsRequired = 1;\\n\\n        // keep the track of previously burst balloon.\\n        int prevBurstBalloonInd = 0;\\n\\n        // from the second balloon that is from the first balloon.\\n            // if the balloon exceeds the overlapping range of the previously bursted\\n        // balloon then we need another arrow to burst the next overlapping balloons.\\n        for (int currBalloonInd = 1; currBalloonInd < noOfBalloons; currBalloonInd++) {\\n\\n            int prevBalloonBurstEndPos = points[prevBurstBalloonInd][1];\\n            int currBalloonBurstStartPos =  points[currBalloonInd][0];\\n\\n            // if current balloon exceeds the range of previously burst balloon,\\n                // then new arrow is required, and update the position.\\n            if (prevBalloonBurstEndPos < currBalloonBurstStartPos) {\\n                ++minArrowsRequired;\\n                prevBurstBalloonInd = currBalloonInd;\\n            }\\n        }\\n\\n        return minArrowsRequired;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n\\n        // get the total number of balloons given.\\n        int noOfBalloons = points.length;\\n\\n        // Sort the given array positions along the X coordinate.\\n        Arrays.sort(points, (b1, b2) -> Integer.compare(b1[1], b2[1]));\\n\\n        // first of all the arrow required to burst the first balloon is 1,\\n            // as however we need to burst first balloon.\\n        int minArrowsRequired = 1;\\n\\n        // keep the track of previously burst balloon.\\n        int prevBurstBalloonInd = 0;\\n\\n        // from the second balloon that is from the first balloon.\\n            // if the balloon exceeds the overlapping range of the previously bursted\\n        // balloon then we need another arrow to burst the next overlapping balloons.\\n        for (int currBalloonInd = 1; currBalloonInd < noOfBalloons; currBalloonInd++) {\\n\\n            int prevBalloonBurstEndPos = points[prevBurstBalloonInd][1];\\n            int currBalloonBurstStartPos =  points[currBalloonInd][0];\\n\\n            // if current balloon exceeds the range of previously burst balloon,\\n                // then new arrow is required, and update the position.\\n            if (prevBalloonBurstEndPos < currBalloonBurstStartPos) {\\n                ++minArrowsRequired;\\n                prevBurstBalloonInd = currBalloonInd;\\n            }\\n        }\\n\\n        return minArrowsRequired;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001861,
                "title": "easy-to-understand-short-code",
                "content": "# Intuition\\nBasically, after looking through the given test cases and the problem statement, it was evident for me that all I have to do is to return the number of non-overlapping intervals + 1 as answer.\\n\\nBecause, new arrows will only be required to burst the balloons that aren\\'t overlapping, I hope that makes sense.\\n# Approach\\n1. I sorted the points list using the inbuilt `sort()` which sorts the list prioritising the 0th index first, and then the 1st index.\\n2. And, I have cached the end point of the 1st point which is `points[0][1]` in prevEnd, which will come in handy for the rest of the algorithm.\\n3. The problem will definitely have atleast one point where a balloon is present `1 <= points.length <= 105`, so it is conclusive that we will require an arrow for sure. So, I have initialised the arrows to 1.\\n4. And, I have started iterating through the points list starting from the 2nd position.\\n5. Here, I have taken the current point\\'s start in start\\n6. To check whether the points doesn\\'t overlap, all that we need to check is whether `start > prevEnd`\\n7. If yes, they don\\'t overlap, we need a new arrow `arrows += 1`\\n8. And then, the prevEnd has to be changed to the current end points[i][1].\\n9. If not, they overlap, and so we have to delete one interval, we have two choices for deletion now, and we have to choose the end which comes before in the x-axis, which is the minimum end value `prevEnd = min(prevEnd, points[i][1])`\\n10. Likewise, traverse to the end of the points list.\\n11. And, now we have the minimum number of arrows, return it rightaway :)\\n# Complexity\\n- Time complexity:\\no(n*log(n))\\n\\n- Space complexity:\\no(1)\\n# Code\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort()\\n\\n        prevEnd = points[0][1]\\n        arrows = 1\\n\\n        for i in range(1, len(points)):\\n            start = points[i][0]\\n\\n            if start > prevEnd:\\n                arrows += 1\\n                prevEnd = points[i][1]\\n            else:\\n                prevEnd = min(prevEnd, points[i][1])\\n\\n        return arrows\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort()\\n\\n        prevEnd = points[0][1]\\n        arrows = 1\\n\\n        for i in range(1, len(points)):\\n            start = points[i][0]\\n\\n            if start > prevEnd:\\n                arrows += 1\\n                prevEnd = points[i][1]\\n            else:\\n                prevEnd = min(prevEnd, points[i][1])\\n\\n        return arrows\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000749,
                "title": "js-solution",
                "content": "```\\nconst findMinArrowShots = function(points) {\\n    points.sort((a, b) => a[0] - b[0]);\\n    let counter = 0,\\n        end = null;\\n\\n    for(let [x, y] of points) {\\n        if(end == null || end < x){\\n            counter++\\n            end = y\\n        }else{\\n            end = Math.min(end, y);\\n        }\\n    }\\n    return counter\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst findMinArrowShots = function(points) {\\n    points.sort((a, b) => a[0] - b[0]);\\n    let counter = 0,\\n        end = null;\\n\\n    for(let [x, y] of points) {\\n        if(end == null || end < x){\\n            counter++\\n            end = y\\n        }else{\\n            end = Math.min(end, y);\\n        }\\n    }\\n    return counter\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3000639,
                "title": "c-begineer-friendly-easy-understanding-greedy-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\nhttps://www.youtube.com/watch?v=QOEWZM7uowg/\\n\\n# Complexity\\n- Time complexity:\\n  O(n)+nlog(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int findMinArrowShots(vector<vector<int>>& points) {\\n    //  ans counter and endpoint.\\n        int ans =1;\\n        int endpoint = INT_MAX;\\n        // sorting of points in increasing order of points.\\n        sort(points.begin(),points.end());\\n\\n        // now traverse and find the non overlaping interval, bascially ans.\\n        for(auto x:points){\\n            int start = x[0];\\n            int end = x[1];\\n\\n            if(endpoint < start){\\n                ans++; // new interval with no overlapping.\\n                endpoint = end;\\n            }\\n            else{\\n                endpoint = min(endpoint,end);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int findMinArrowShots(vector<vector<int>>& points) {\\n    //  ans counter and endpoint.\\n        int ans =1;\\n        int endpoint = INT_MAX;\\n        // sorting of points in increasing order of points.\\n        sort(points.begin(),points.end());\\n\\n        // now traverse and find the non overlaping interval, bascially ans.\\n        for(auto x:points){\\n            int start = x[0];\\n            int end = x[1];\\n\\n            if(endpoint < start){\\n                ans++; // new interval with no overlapping.\\n                endpoint = end;\\n            }\\n            else{\\n                endpoint = min(endpoint,end);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687876,
                "title": "python-greedy-solution",
                "content": "Approach: \\n1) Sort the points array in increasing order based on ending x index.\\n2) Initialize res=1 which means always consider first balloon\\n3) Initialize a variable shoot which indicates the current fixed point to shoot the arrow. Initialize it to ending index of first balloon.\\n4) Loop through all the indexes. If starting index of balloon is less than the shoot , then continue. This means that the current shoot index can burst this balloon. Else increase result by one and assign shoot as ending index of current balloon\\n5) Return res \\n\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        \\n        points.sort(key=lambda x: x[1])\\n        \\n        res=1\\n        shoot=points[0][1]\\n        n=len(points)\\n        for i in range(1,n):\\n            if(points[i][0]<=shoot):\\n                continue\\n                \\n            else:\\n                res=res+1\\n                shoot=points[i][1]\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        \\n        points.sort(key=lambda x: x[1])\\n        \\n        res=1\\n        shoot=points[0][1]\\n        n=len(points)\\n        for i in range(1,n):\\n            if(points[i][0]<=shoot):\\n                continue\\n                \\n            else:\\n                res=res+1\\n                shoot=points[i][1]\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1686545,
                "title": "c-easy-to-understand",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(),points.end());\\n        int r=points[0][1],ans=1;\\n        for(auto x : points){\\n            if(x[0]<=r){\\n                r=min(r,x[1]);\\n            }else{\\n                ans++;\\n                r=x[1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(),points.end());\\n        int r=points[0][1],ans=1;\\n        for(auto x : points){\\n            if(x[0]<=r){\\n                r=min(r,x[1]);\\n            }else{\\n                ans++;\\n                r=x[1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659860,
                "title": "beginner-s-solution-with-explanation",
                "content": "We can merge the intervals and see how many intervals we get after merging which is a required answer.\\nBut, there is a twist in merging\\n\\n......Think yourself......\\n\\nSo,let us understand how we can merge the intervals with an example.\\n[1,6] [2,8] [7,12]\\nOn merging we would get [1,8][7,12]->[1,12];\\nBut there is some exception in question......\\nA balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend.\\nSo, we take any one interval and insert all these intervals inside interval [points[i][0],min(points[i][1],points[i+1][1])].\\nWe are taking minimum value  because A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend according to question and taking the minimum value limits the value of X.\\nTry puting Maximum value( [points[i][0], max(points[i][1],points[i+1][1])] ) and see the result yourself to understand better.\\nLets insert all the overlapping intervals in [1,6]\\n[2,8] overlaps [1,6] so the interval becomes [1,min(6,8)] and [7,12] dont olverlap [1,6] so we have 2 intervals left after merging [1,6] and [7,12] so we need to shoot arrow at 6 and 12\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& v) {\\n        int n=v.size();\\n        int ans=0;\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<n;i++){\\n            int end = v[i][1];\\n            //Checking if interval overlaps.\\n            while(i+1<n && v[i+1][0]<=end){\\n                end=min(end,v[i+1][1]);\\n                i++;\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& v) {\\n        int n=v.size();\\n        int ans=0;\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<n;i++){\\n            int end = v[i][1];\\n            //Checking if interval overlaps.\\n            while(i+1<n && v[i+1][0]<=end){\\n                end=min(end,v[i+1][1]);\\n                i++;\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656559,
                "title": "java-greedy-o-nlogn",
                "content": "![image](https://assets.leetcode.com/users/images/f3609b72-d6ae-4251-8ff1-03066a16b88e_1640866368.5510325.jpeg)\\n![image](https://assets.leetcode.com/users/images/bbf94437-91cb-4eb7-93f8-02ee9e64e86d_1640866373.8093414.jpeg)\\n\\n\\n```\\nclass Solution {\\n    class Activity{\\n        int start;\\n        int finish;\\n        Activity(int s ,int f){\\n            this.start=s;\\n            this.finish=f;\\n        }\\n    }\\n    \\n    \\n    public int findMinArrowShots(int[][] points) {\\n   \\n        \\n        Arrays.sort(points, new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] l, int[] r) {\\n                return l[1] < r[1] ? -1 : 1;\\n            }\\n        });\\n        \\n        \\n//         we are by default including the first activity\\n        \\n        ArrayList<ArrayList<Integer>> list =new ArrayList<>();\\n        \\n        ArrayList<Integer> list2=new ArrayList<>();\\n                list2.add(points[0][0]);\\n                list2.add(points[0][1]);\\n        list.add(list2);\\n        \\n        int prev=0; \\n        \\n        for(int curr =0;curr<points.length;curr++){\\n          \\n            if(points[curr][0]>points[prev][1]){\\n                ArrayList<Integer> list1=new ArrayList<>();\\n                list1.add(points[curr][0]);\\n                list1.add(points[curr][1]);\\n                list.add(list1);\\n                prev=curr;\\n            }\\n            \\n        }\\n        \\n        \\n        System.out.println(list);\\n        \\n        return list.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    class Activity{\\n        int start;\\n        int finish;\\n        Activity(int s ,int f){\\n            this.start=s;\\n            this.finish=f;\\n        }\\n    }\\n    \\n    \\n    public int findMinArrowShots(int[][] points) {\\n   \\n        \\n        Arrays.sort(points, new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] l, int[] r) {\\n                return l[1] < r[1] ? -1 : 1;\\n            }\\n        });\\n        \\n        \\n//         we are by default including the first activity\\n        \\n        ArrayList<ArrayList<Integer>> list =new ArrayList<>();\\n        \\n        ArrayList<Integer> list2=new ArrayList<>();\\n                list2.add(points[0][0]);\\n                list2.add(points[0][1]);\\n        list.add(list2);\\n        \\n        int prev=0; \\n        \\n        for(int curr =0;curr<points.length;curr++){\\n          \\n            if(points[curr][0]>points[prev][1]){\\n                ArrayList<Integer> list1=new ArrayList<>();\\n                list1.add(points[curr][0]);\\n                list1.add(points[curr][1]);\\n                list.add(list1);\\n                prev=curr;\\n            }\\n            \\n        }\\n        \\n        \\n        System.out.println(list);\\n        \\n        return list.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211610,
                "title": "c-simple-code-with-explanation",
                "content": "Your runtime beats 97.79 % of cpp submissions.\\nYour memory usage beats 87.82 % of cpp submissions.\\n\\n**Approach:**\\nThe logic is simple. Sort the given array in ascending order. Now, we will find the intersection interval. For instance:\\ninput: [[10,16],[2,8],[1,6],[7,12]]\\nafter sorting: [[1,6],[2,8],[7,12],[10,16]]\\nIntersection points: [[2,6],[7,8],[10,12]]\\nNow, if points[i] has common point to any of this points then we need only one arrow. As, we can find one common point x which will satisfy xstart \\u2264 x \\u2264 xend. \\nUsing this logic common point will be any of the intersection points present. \\nNow we need to find minimum, so using greedy we can solve this problem. \\nWe don\\'t need to save this intersection points, instead we will need only one pointer high; because if given starting point is greater than high then, we will need one another arrow, so we will increase count of arrow. we need to check for each points present in given 2D vector.\\n\\n**Solution:**\\n\\n```\\nint findMinArrowShots(vector<vector<int>>& points) {\\n        if(points.size()==1) return 1; \\n        sort(points.begin(),points.end()); // sort the points in ascending order O(nlogn)\\n        int high = points[0][1], arrowcnt=1;\\n        for(int i=1;i<points.size();i++)\\n        {\\n            if(high>=points[i][0]) // check if shares common point\\n\\t\\t\\t\\thigh = min(high, points[i][1]);\\n            else\\n             {\\n                 arrowcnt++;\\n                 high = points[i][1];\\n             }\\n        }\\n        return arrowcnt;\\n    }\\n```\\nspace complexity: O(1)constant\\nTime complexity: O(nlogn + n-1)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint findMinArrowShots(vector<vector<int>>& points) {\\n        if(points.size()==1) return 1; \\n        sort(points.begin(),points.end()); // sort the points in ascending order O(nlogn)\\n        int high = points[0][1], arrowcnt=1;\\n        for(int i=1;i<points.size();i++)\\n        {\\n            if(high>=points[i][0]) // check if shares common point\\n\\t\\t\\t\\thigh = min(high, points[i][1]);\\n            else\\n             {\\n                 arrowcnt++;\\n                 high = points[i][1];\\n             }\\n        }\\n        return arrowcnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1042158,
                "title": "c-greedy-sorting-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/submissions/\\n    \\n    All the balloons need to bursted, so in worst case\\n    we can use N arrows and burst all. To optimize arrows\\n    we need to shoot at points with max number of intersecting\\n    balloons, but finding that makes the problem look very difficult.\\n    If we observe carefully and look at this sentence \"All the balloons need to be burst\",\\n    we can find a clue, since each balloon needs to burst anyway, we can shoot at its end point \\n    and allow any balloons which also gets covered also be bursted. If we chose a point before the \\n    end point then we might have missed a balloon intersection towards the end. \\n    One important thing is to start wrt to the end pt and not start pt, that way we will\\n    know the extent till which a particular balloon can cover.\\n    \\n    TC: O(nlogn)\\n    SC: O(n)\\n*/\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        if(points.empty()) \\n            return 0;\\n        \\n        // sort wrt the end point\\n        sort(points.begin(), points.end(),\\n            [](auto &a, auto &b) -> bool {\\n                return a[1] < b[1]; \\n            });\\n        \\n        int burst_pt = points[0][1], arrows = 1;\\n        for(auto &point: points) {\\n            if(point[0] > burst_pt)\\n                ++arrows, burst_pt = point[1];\\n        }\\n        return arrows;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/submissions/\\n    \\n    All the balloons need to bursted, so in worst case\\n    we can use N arrows and burst all. To optimize arrows\\n    we need to shoot at points with max number of intersecting\\n    balloons, but finding that makes the problem look very difficult.\\n    If we observe carefully and look at this sentence \"All the balloons need to be burst\",\\n    we can find a clue, since each balloon needs to burst anyway, we can shoot at its end point \\n    and allow any balloons which also gets covered also be bursted. If we chose a point before the \\n    end point then we might have missed a balloon intersection towards the end. \\n    One important thing is to start wrt to the end pt and not start pt, that way we will\\n    know the extent till which a particular balloon can cover.\\n    \\n    TC: O(nlogn)\\n    SC: O(n)\\n*/\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        if(points.empty()) \\n            return 0;\\n        \\n        // sort wrt the end point\\n        sort(points.begin(), points.end(),\\n            [](auto &a, auto &b) -> bool {\\n                return a[1] < b[1]; \\n            });\\n        \\n        int burst_pt = points[0][1], arrows = 1;\\n        for(auto &point: points) {\\n            if(point[0] > burst_pt)\\n                ++arrows, burst_pt = point[1];\\n        }\\n        return arrows;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683443,
                "title": "python-simple-solution-with-detailed-explanation-and-example-stack-trace",
                "content": "```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        ## RC ##\\n        ## APPROACH : GREEDY ##\\n        ## Similar to Leetcode: 435. Non Over lapping Intervals ##\\n        \"\"\"\\n        1. Decompose this problem to intervals, solution: all overlapping intervals need to considered as single interval.\\n        2. Intially I consider there are no overlaps, so I take answer as length of given array.\\n        3. After sorting, start with overlap time as intervals[0].\\n        4. As you move along the intervals, if you see any overlap (i.e start of next interval falls in our overlap_time), \\n           indicates we can hit them both with single arrow, so decrease our answer by 1 and re-calculate the overlap_time for these both and repeat for subsequent intervals.\\n        5. When you donot find any overlap, we will no longer find any overlaps with our current overlap_time in next intervals. so, change overlap time to the current interval.\\n        \\n            Example : [[1, 10], [3, 9], [4, 11], [6, 7], [6, 9], [8, 12], [9, 12]]\\n            Stack Trace : Overlap_time (initially [1,10])\\n                            [3, 9]\\n                            [4, 9]\\n                            [6, 7]\\n                            [6, 7]\\n                            [8, 12]\\n                            [9, 12]\\n        \"\"\"\\n        if not points: return 0\\n        \\n        intervals = sorted( points, key = lambda x : (x[0], x[1]) )\\n        overlap_time = intervals[0]\\n        ans = len(intervals)\\n        # print(intervals)\\n        for i, interval in enumerate(intervals[1:]):\\n            if interval[0] <= overlap_time[1]:\\n                ans -= 1\\n                overlap_time = [ max(interval[0], overlap_time[0]) , min(interval[1], overlap_time[1]) ]\\n            else:\\n                overlap_time = interval\\n            # print(overlap_time)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        ## RC ##\\n        ## APPROACH : GREEDY ##\\n        ## Similar to Leetcode: 435. Non Over lapping Intervals ##\\n        \"\"\"\\n        1. Decompose this problem to intervals, solution: all overlapping intervals need to considered as single interval.\\n        2. Intially I consider there are no overlaps, so I take answer as length of given array.\\n        3. After sorting, start with overlap time as intervals[0].\\n        4. As you move along the intervals, if you see any overlap (i.e start of next interval falls in our overlap_time), \\n           indicates we can hit them both with single arrow, so decrease our answer by 1 and re-calculate the overlap_time for these both and repeat for subsequent intervals.\\n        5. When you donot find any overlap, we will no longer find any overlaps with our current overlap_time in next intervals. so, change overlap time to the current interval.\\n        \\n            Example : [[1, 10], [3, 9], [4, 11], [6, 7], [6, 9], [8, 12], [9, 12]]\\n            Stack Trace : Overlap_time (initially [1,10])\\n                            [3, 9]\\n                            [4, 9]\\n                            [6, 7]\\n                            [6, 7]\\n                            [8, 12]\\n                            [9, 12]\\n        \"\"\"\\n        if not points: return 0\\n        \\n        intervals = sorted( points, key = lambda x : (x[0], x[1]) )\\n        overlap_time = intervals[0]\\n        ans = len(intervals)\\n        # print(intervals)\\n        for i, interval in enumerate(intervals[1:]):\\n            if interval[0] <= overlap_time[1]:\\n                ans -= 1\\n                overlap_time = [ max(interval[0], overlap_time[0]) , min(interval[1], overlap_time[1]) ]\\n            else:\\n                overlap_time = interval\\n            # print(overlap_time)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229975,
                "title": "python-4-lines-beat-100",
                "content": "```python\\nclass Solution:\\n    def findMinArrowShots(self, points):\\n        res, arrow = 0, -float(\\'inf\\')\\n        for start, end in sorted(points, key = lambda p: p[1]):\\n            if start > arrow: arrow, res = end, res + 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findMinArrowShots(self, points):\\n        res, arrow = 0, -float(\\'inf\\')\\n        for start, end in sorted(points, key = lambda p: p[1]):\\n            if start > arrow: arrow, res = end, res + 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93787,
                "title": "c-o-nlogn-solution-in-8-lines",
                "content": "\\n    int findMinArrowShots(vector<pair<int, int>>& points) {\\n        int res = 0, i = 0, temp;\\n        sort(points.begin(), points.end(), [](pair<int, int> a, pair<int, int> b){return a.second < b.second;});\\n        while (i < points.size()) {\\n            res++;\\n            temp = points[i++].second;\\n            while (i < points.size() && points[i].first <= temp) i++;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "\\n    int findMinArrowShots(vector<pair<int, int>>& points) {\\n        int res = 0, i = 0, temp;\\n        sort(points.begin(), points.end(), [](pair<int, int> a, pair<int, int> b){return a.second < b.second;});\\n        while (i < points.size()) {\\n            res++;\\n            temp = points[i++].second;\\n            while (i < points.size() && points[i].first <= temp) i++;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3274777,
                "title": "452-time-96-85-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Sort the balloons in ascending order based on their end points\\n2. Initialize two variables: arrows = 0 and last_end = -infinity\\n3. Iterate through the balloons in the sorted list:\\na. If the current balloon\\'s start point is greater than last_end, then shoot a new arrow\\ni. Increment arrows by 1\\nii. Update last_end to the current balloon\\'s end point\\nb. If the current balloon\\'s start point is less than or equal to last_end, it can be burst by the previous arrow\\n4. Return the value of arrows as the minimum number of arrows required to burst all the balloons\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        # Sort the balloons by their end points in ascending order\\n        points.sort(key=lambda x: x[1])\\n        \\n        # Initialize the number of arrows needed and the end point of the last arrow\\n        arrows = 0\\n        last_end = float(\\'-inf\\')\\n        \\n        # Iterate through the balloons\\n        for start, end in points:\\n            # If the current balloon starts after the end of the last arrow, shoot a new arrow\\n            if start > last_end:\\n                arrows += 1\\n                last_end = end\\n        \\n        return arrows\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        # Sort the balloons by their end points in ascending order\\n        points.sort(key=lambda x: x[1])\\n        \\n        # Initialize the number of arrows needed and the end point of the last arrow\\n        arrows = 0\\n        last_end = float(\\'-inf\\')\\n        \\n        # Iterate through the balloons\\n        for start, end in points:\\n            # If the current balloon starts after the end of the last arrow, shoot a new arrow\\n            if start > last_end:\\n                arrows += 1\\n                last_end = end\\n        \\n        return arrows\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117109,
                "title": "accepted-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& a, vector<int>& b)\\n    {\\n        return a[1]<b[1];\\n    }\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(), points.end(), comp);\\n        int ans=1;\\n        int c=points[0][1];\\n        for(int i=1;i<points.size();i++)\\n        {\\n            if(c>=points[i][0])\\n            continue;\\n            c=points[i][1];\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& a, vector<int>& b)\\n    {\\n        return a[1]<b[1];\\n    }\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(), points.end(), comp);\\n        int ans=1;\\n        int c=points[0][1];\\n        for(int i=1;i<points.size();i++)\\n        {\\n            if(c>=points[i][0])\\n            continue;\\n            c=points[i][1];\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004120,
                "title": "simple-java-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to find **common range** among the balloons. The problem can be solved in many ways but we have to find the **efficient** solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can start by **sorting** the array with respect to its **end position** so that it will be easy to find the range. \\n\\nFollow the code below to understand the solution.\\n\\n            **If this solution helped you, give it an up-vote to help others** \\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n\\n        //Sort the array with respect to end position i.e. points[i][1].\\n        //We will use lambda expression to customize the sorting.\\n         Arrays.sort(points, (a,b) -> Integer.compare(a[1],b[1]));\\n\\n        //Initialize arrow count from 1 because at least 1 arrow is needed.\\n        int arrowCount = 1;\\n        int previous = 0;\\n\\n        for(int current = 0; current < points.length; current++)\\n        {\\n            // If the start position of current balloon is after the end\\n            // position of previous balloon then increment arrow counter.\\n            if(points[current][0] > points[previous][1])\\n            {\\n                arrowCount++;\\n                // Update the index of the previously burst balloon\\n                previous = current;\\n            }\\n\\n        }\\n\\n        //Finally return the arrow count.\\n\\n        return arrowCount;         \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n\\n        //Sort the array with respect to end position i.e. points[i][1].\\n        //We will use lambda expression to customize the sorting.\\n         Arrays.sort(points, (a,b) -> Integer.compare(a[1],b[1]));\\n\\n        //Initialize arrow count from 1 because at least 1 arrow is needed.\\n        int arrowCount = 1;\\n        int previous = 0;\\n\\n        for(int current = 0; current < points.length; current++)\\n        {\\n            // If the start position of current balloon is after the end\\n            // position of previous balloon then increment arrow counter.\\n            if(points[current][0] > points[previous][1])\\n            {\\n                arrowCount++;\\n                // Update the index of the previously burst balloon\\n                previous = current;\\n            }\\n\\n        }\\n\\n        //Finally return the arrow count.\\n\\n        return arrowCount;         \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003963,
                "title": "c-easy-compare-sort-greedy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt first I sort the array according to end time. Then I check, how many end point befor the taking end point.Then take thats point for one arrows and continue the next arrows that on.\\n# Complexity\\n- Time complexity:nlog(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nbool cmp(vector<int>&a, vector<int>&b){\\n    if(a[1] == b[1])return a[0] <= b[0];\\n    return a[1] <= b[1];\\n}\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(), points.end(), cmp);\\n        int ans = 0;\\n        int n = points.size();\\n        int ind = 0;\\n        while(ind < n){\\n            int left = points[ind][1];\\n            ans++;\\n            ind++;\\n            while(ind < n and points[ind][0] <= left)ind++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nbool cmp(vector<int>&a, vector<int>&b){\\n    if(a[1] == b[1])return a[0] <= b[0];\\n    return a[1] <= b[1];\\n}\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(), points.end(), cmp);\\n        int ans = 0;\\n        int n = points.size();\\n        int ind = 0;\\n        while(ind < n){\\n            int left = points[ind][1];\\n            ans++;\\n            ind++;\\n            while(ind < n and points[ind][0] <= left)ind++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003361,
                "title": "java-most-possible-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a, b) -> a[1] < b[1] ? -1 : 1);\\n        int ans = 1;\\n        int x = points[0][1];\\n        for (int[] v : points) {\\n            int a = v[0], b = v[1];\\n            if (a > x) {\\n                ++ans;\\n                x = b;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a, b) -> a[1] < b[1] ? -1 : 1);\\n        int ans = 1;\\n        int x = points[0][1];\\n        for (int[] v : points) {\\n            int a = v[0], b = v[1];\\n            if (a > x) {\\n                ++ans;\\n                x = b;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003347,
                "title": "c-easiest-solution-with-detailed-explanation",
                "content": "**DO UPVOTE IF YOU FIND THIS APPROACH HELPFUL :)**\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo find the minimum number of arrows, we will have to hit by arrows at points where maximum number of balloons reside i.e. basically problem revolves around overlapping of balloons, So we will be using greedy approach to solve this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We can sort the array based on starting or ending points, i am going with starting points. You can go with ending points but for that you have to use a comparator function additionally.\\n2. Initially, we need atleast one arrow.\\n3. We will keep track of end point of balloons also.\\n4. When starting point of another balloon is greater than current endpoint, we will increment the no of arrows and update the endpoint with new endpoint.\\n5. Else, we will have the minimum of current and next balloon endpoint as we are sorting the points vector based on starting points.\\n\\n# Complexity\\n- Time complexity: `O(nlogn)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        if(points.size() == 0)\\n            return 0;\\n        sort(points.begin(), points.end());\\n        int arrows = 1;\\n        int end = points[0][1];\\n\\n        for(int i=1; i<points.size(); i++){\\n            if(points[i][0] > end){\\n                arrows++;\\n                end = points[i][1];\\n            }else{\\n                end = min(end, points[i][1]);\\n            }\\n        }\\n\\n        return arrows;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        if(points.size() == 0)\\n            return 0;\\n        sort(points.begin(), points.end());\\n        int arrows = 1;\\n        int end = points[0][1];\\n\\n        for(int i=1; i<points.size(); i++){\\n            if(points[i][0] > end){\\n                arrows++;\\n                end = points[i][1];\\n            }else{\\n                end = min(end, points[i][1]);\\n            }\\n        }\\n\\n        return arrows;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002637,
                "title": "greedy-few-lines-solution-js",
                "content": "# Explanation\\nSteps were explained as comments in the code step by step.\\n\\n# Code\\n```\\nlet findMinArrowShots = function (points) {\\n    // Sort the array based on diameter\\'s end location\\n    let sorted = points.sort((a, b) => a[1] - b[1]);\\n    let result = 0;\\n    // Init with very small since the diameter could start from\\n    // -2^31, alternative solution to init with sorted[0][1] but in\\n    // this case the result should be initialized with 1 and not 0\\n    var currEnd = -Infinity;\\n\\n    for (let [s, e] of sorted) {\\n        // In case start exceeded the current end ->\\n        if(s > currEnd) {\\n            // Update the current end and increase the result\\n            // -> because arrow hitted all possible overlapped \\n            // balloons in the current range\\n            currEnd = e;\\n            result++;\\n        }\\n    }\\n\\n    // Return result\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet findMinArrowShots = function (points) {\\n    // Sort the array based on diameter\\'s end location\\n    let sorted = points.sort((a, b) => a[1] - b[1]);\\n    let result = 0;\\n    // Init with very small since the diameter could start from\\n    // -2^31, alternative solution to init with sorted[0][1] but in\\n    // this case the result should be initialized with 1 and not 0\\n    var currEnd = -Infinity;\\n\\n    for (let [s, e] of sorted) {\\n        // In case start exceeded the current end ->\\n        if(s > currEnd) {\\n            // Update the current end and increase the result\\n            // -> because arrow hitted all possible overlapped \\n            // balloons in the current range\\n            currEnd = e;\\n            result++;\\n        }\\n    }\\n\\n    // Return result\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3002453,
                "title": "c-sort-and-iterate-that-s-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort the element on the basis of start time and calculate the number of distinct points with no overlapping intervals.\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort (points.begin (), points.end ());\\n\\n        int i = 0;\\n        int n = points.size (), res = 0;\\n\\n        while (i < n){\\n            //in each iteration we start with new point and find\\n            //corresponding overlapping points in second while loop.\\n            int start = points[i][0];\\n            int end = points[i++][1];\\n            res++;\\n\\n            while (i < n && start <= points[i][0] && points[i][0] <= end){\\n                // minimizing width of interval\\n                start = max (points[i][0],start); \\n                end = min (points[i][1], end);\\n                i++;\\n            } \\n            \\n        }\\n\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort (points.begin (), points.end ());\\n\\n        int i = 0;\\n        int n = points.size (), res = 0;\\n\\n        while (i < n){\\n            //in each iteration we start with new point and find\\n            //corresponding overlapping points in second while loop.\\n            int start = points[i][0];\\n            int end = points[i++][1];\\n            res++;\\n\\n            while (i < n && start <= points[i][0] && points[i][0] <= end){\\n                // minimizing width of interval\\n                start = max (points[i][0],start); \\n                end = min (points[i][1], end);\\n                i++;\\n            } \\n            \\n        }\\n\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002383,
                "title": "python-elegant-short-greedy",
                "content": "```\\ndef findMinArrowShots(self, points: List[List[int]]) -> int:\\n    points.sort(key=lambda x: x[1])\\n\\n    arrows = 0\\n    end = -maxsize\\n\\n    for s, e in points:\\n        if s > end:\\n            arrows += 1\\n            end = e\\n\\n    return arrows\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\ndef findMinArrowShots(self, points: List[List[int]]) -> int:\\n    points.sort(key=lambda x: x[1])\\n\\n    arrows = 0\\n    end = -maxsize\\n\\n    for s, e in points:\\n        if s > end:\\n            arrows += 1\\n            end = e\\n\\n    return arrows\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3001950,
                "title": "rust-greedy-functional-style-with-comments",
                "content": "# Intuition\\nWe need to group balloons that are all overlapping on some x coordinate.\\n\\n# Approach\\nSort the ballons based on the right coordinate in ascending order. We need one arrow to pop the first balloon. But as long as the left coordinate of a balloon with a higher index is less than the right coordinate of the first ballon, we can send an arrow at the right coordinate of the first ballon and pop all the qualifying balloons at once. If we find a balloon that does not belong in the first group, we reset to a new group and increment the result.\\n\\nThis solution uses a Rust functional style `fold` to keep track of the algorithm state, which is the number of groups found so far (`rez`) and the rightmost coordinate of the current group (`right`).\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\log n)$$ since the sorting dominates the time complexity.\\n\\n- Space complexity: $$O(1)$$. Unstable sorts to not allocate any extra space in Rust, and the algorithm state uses two variables.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn find_min_arrow_shots(mut points: Vec<Vec<i32>>) -> i32 {\\n        points.sort_unstable_by_key(|b| b[1]);\\n        points.iter().skip(1).fold((1, points[0][1]), |(rez, right), b|\\n            if right < b[0] {\\n                (rez + 1, b[1])\\n            } else {\\n                (rez, right)\\n            }\\n        ).0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_min_arrow_shots(mut points: Vec<Vec<i32>>) -> i32 {\\n        points.sort_unstable_by_key(|b| b[1]);\\n        points.iter().skip(1).fold((1, points[0][1]), |(rez, right), b|\\n            if right < b[0] {\\n                (rez + 1, b[1])\\n            } else {\\n                (rez, right)\\n            }\\n        ).0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3001870,
                "title": "c-medium-stack-sorting-only-easy-approach-like-mergeoverlappingintervals",
                "content": "\\nMergeOverlappingIntervals\\nThis problem is a must do problem or a homework before seeing this solution, if you know MergeOverlappingIntervals then you already know the solution, just spend 2 mins here, if you dont know, pls see \\nMergeOverlappingIntervals and come here. \\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHow I saw this problem actually?\\nDraw the 1d lines of coordinates on the notebook and check how many ballons have their surface area exposed with other ballons in the same lines, if they are exposed, means it can be bursted with the single arrow. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsorted the given coordinates with first values.\\nusing stack with pairs of given coordinates to check how their spherical surface area is exposed with other coordinates, \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nfor sorting: O(NlogN)\\nfor loop for array traversal O(N)\\ntotal O(NlogN)\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:\\n-O(N) for using the stack.\\n\\n\\nAt the end, if this soluion helped you, do upvote pls, I know I am not good in explaining stuff but I trust my codes before posting. \\nHappy leetcoding.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        //Variable having total given points and b for balloons.\\n        long long n=points.size(),b=0;\\n\\n        //Sorting all the coordinates.\\n        sort(points.begin(),points.end());\\n\\n        //Creating a stack with first coordinate pushed.\\n        stack<pair<long long,long long>> st;\\n        st.push({points[0][0],points[0][1]});\\n\\n        //Starting with 1st value of array as 0th we have pushed in stack\\n        for(long long i=1;i<n;i++){\\n            //Array first and second point\\n            long long afirst=points[i][0];\\n            long long asecond=points[i][1];\\n\\n            //Stack first and second point.\\n            long long sfirst=st.top().first;\\n            long long ssecond=st.top().second;\\n            \\n\\n            //if case goes like 1-4 and 6-8 means 4<6,this means simply push this coordinate in stack and move on.\\n            if(ssecond<afirst){\\n                st.push({afirst,asecond});\\n                continue;\\n            }\\n\\n            else if(ssecond>=afirst){\\n            if case goes like 1-4 and 2-x means 2<4,this means balloon area of array points overlaps with ballon in stack points.\\n\\n            // If even the array balloon fully lies in the complete area of stack balloon like 1-4 and 2-3, means 2-3 is the overlap area. so pop out last points from the stack and push this new array points, because these will be the next possible points of overlap with the upcoming array balloons\\n                if(asecond<=ssecond){\\n                    b++;\\n                    st.pop();\\n                    st.push({afirst,asecond});\\n                    continue;\\n                }\\n            //If it doesnt overlaps, like 1-4 2-6, means same like above but coordinates changes as 2-4, afirst and ssecond. \\n                else{\\n                    b++;\\n                    st.pop();\\n                    st.push({afirst,ssecond});\\n                    continue;\\n                }\\n            }\\n        }\\n        // cout<<\"B: \"<<b<<endl;\\n\\n        //At last, leftover can\\'t be bursted but those who have bursted lies in b. so n-b return at the end.\\n        return points.size()-b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        //Variable having total given points and b for balloons.\\n        long long n=points.size(),b=0;\\n\\n        //Sorting all the coordinates.\\n        sort(points.begin(),points.end());\\n\\n        //Creating a stack with first coordinate pushed.\\n        stack<pair<long long,long long>> st;\\n        st.push({points[0][0],points[0][1]});\\n\\n        //Starting with 1st value of array as 0th we have pushed in stack\\n        for(long long i=1;i<n;i++){\\n            //Array first and second point\\n            long long afirst=points[i][0];\\n            long long asecond=points[i][1];\\n\\n            //Stack first and second point.\\n            long long sfirst=st.top().first;\\n            long long ssecond=st.top().second;\\n            \\n\\n            //if case goes like 1-4 and 6-8 means 4<6,this means simply push this coordinate in stack and move on.\\n            if(ssecond<afirst){\\n                st.push({afirst,asecond});\\n                continue;\\n            }\\n\\n            else if(ssecond>=afirst){\\n            if case goes like 1-4 and 2-x means 2<4,this means balloon area of array points overlaps with ballon in stack points.\\n\\n            // If even the array balloon fully lies in the complete area of stack balloon like 1-4 and 2-3, means 2-3 is the overlap area. so pop out last points from the stack and push this new array points, because these will be the next possible points of overlap with the upcoming array balloons\\n                if(asecond<=ssecond){\\n                    b++;\\n                    st.pop();\\n                    st.push({afirst,asecond});\\n                    continue;\\n                }\\n            //If it doesnt overlaps, like 1-4 2-6, means same like above but coordinates changes as 2-4, afirst and ssecond. \\n                else{\\n                    b++;\\n                    st.pop();\\n                    st.push({afirst,ssecond});\\n                    continue;\\n                }\\n            }\\n        }\\n        // cout<<\"B: \"<<b<<endl;\\n\\n        //At last, leftover can\\'t be bursted but those who have bursted lies in b. so n-b return at the end.\\n        return points.size()-b;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3001863,
                "title": "c-easy-solution-with-detailed-explanation",
                "content": "This is the simple one so don\\'t worry about the problem . Let\\'s start\\n\\n**Steps**\\n1.*First you need to sort our entire array according to their second element.*\\n2.*Initialize our count variable equal to n (length of the array) .*\\n3.*Iterate in array from (0 to n-2)th index and if we find the first index of the current interval is equal to or greater than the zeroth index of the next element it means our current interval and next interval overlaps so we need to decreament our counter(overlap horhe hai 2 interval to 1 arrow hi dono interval ko burst krdega) and update the first index of the next interval to first index of current interval(minimum of both)*.\\n\\n```\\n bool cmp(vector<int>& a, vector<int>& b) {\\n            return a[1] < b[1];\\n }\\n\\nclass Solution {\\npublic:\\n     int findMinArrowShots(vector<vector<int>>& arr) {\\n      int n = arr.size();\\n        int count=n;\\n      sort(arr.begin(),arr.end(), cmp); //Sort the array \\n         \\n        for(int i=0;i<n-1;i++){\\n            if(arr[i][1]>=arr[i+1][0]){\\n                arr[i+1][1] = arr[i][1]; //update next interval\\n                count--;                    //decreament counter\\n            }\\n        \\n        }\\n        return count;\\n    }\\n};\\n```\\n**Upvote it . If you find helpful\\uD83D\\uDE12**\\n",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n bool cmp(vector<int>& a, vector<int>& b) {\\n            return a[1] < b[1];\\n }\\n\\nclass Solution {\\npublic:\\n     int findMinArrowShots(vector<vector<int>>& arr) {\\n      int n = arr.size();\\n        int count=n;\\n      sort(arr.begin(),arr.end(), cmp); //Sort the array \\n         \\n        for(int i=0;i<n-1;i++){\\n            if(arr[i][1]>=arr[i+1][0]){\\n                arr[i+1][1] = arr[i][1]; //update next interval\\n                count--;                    //decreament counter\\n            }\\n        \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001658,
                "title": "trying-is-what-matters",
                "content": "![image](https://assets.leetcode.com/users/images/cea5c59f-2d71-46c2-b06b-92a2f95a64e4_1672902600.889678.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/6f4faf16-f026-4b6e-9008-26fe0c7da1fa_1672902607.8940783.jpeg)\\n\\n```\\n\\nclass Solution {\\n    public int findMinArrowShots(int[][] p) {\\n    Arrays.sort(p,(a,b)->a[0]==b[0]?a[1]-b[1]:a[0]-b[0]);  //sorting array on basis of closest to origin and ending\\n        int min=p[0][0],max=p[0][1]; // updating min. Max with first line\\n        int ans=1; // if there\\u2019s any ballon minnimum 1 arrow will be required\\n        for(int i=1;i<p.length;i++){ \\n           // System.out.println(p[i][0]+\" \"+ p[i][1]);\\n            if(p[i][0]>=min&&p[i][0]<=max){ // if there\\u2019s any intersection between previous baloon and new baloon then we\\u2019ll update our min and max as intersection points \\n                min=Math.max(p[i][0],min);  \\n                max=Math.min(p[i][1],max);\\n            }\\n            else { // if there\\u2019s no intersection. Meaning we\\u2019ll new need arrow\\n                ans++;\\n                min=p[i][0]; // updating min max as new baloon\\n                max=p[i][1];\\n            }\\n        }\\n// number of arrows we\\u2019ll need\\n        return ans;\\n    }\\n}```\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int findMinArrowShots(int[][] p) {\\n    Arrays.sort(p,(a,b)->a[0]==b[0]?a[1]-b[1]:a[0]-b[0]);  //sorting array on basis of closest to origin and ending\\n        int min=p[0][0],max=p[0][1]; // updating min. Max with first line\\n        int ans=1; // if there\\u2019s any ballon minnimum 1 arrow will be required\\n        for(int i=1;i<p.length;i++){ \\n           // System.out.println(p[i][0]+\" \"+ p[i][1]);\\n            if(p[i][0]>=min&&p[i][0]<=max){ // if there\\u2019s any intersection between previous baloon and new baloon then we\\u2019ll update our min and max as intersection points \\n                min=Math.max(p[i][0],min);  \\n                max=Math.min(p[i][1],max);\\n            }\\n            else { // if there\\u2019s no intersection. Meaning we\\u2019ll new need arrow\\n                ans++;\\n                min=p[i][0]; // updating min max as new baloon\\n                max=p[i][1];\\n            }\\n        }\\n// number of arrows we\\u2019ll need\\n        return ans;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 3001572,
                "title": "simple-and-compact",
                "content": "# Approach\\nSorting the array then finding number of overlapped ranges\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(2)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1],b[1]));   \\n        int count=1,n=points[0][1];\\n        for(int i=1;i<points.length;i++){\\n            if(n<points[i][0]){\\n                n=points[i][1];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1],b[1]));   \\n        int count=1,n=points[0][1];\\n        for(int i=1;i<points.length;i++){\\n            if(n<points[i][0]){\\n                n=points[i][1];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001138,
                "title": "sorting-solving-cpp",
                "content": "# Intuition\\nsorting and applying greedy approach to get the overlapping balloons bythe loops\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n     sort(points.begin(),points.end());\\n     int sols=0,r=-1;\\n     for(int po=0;po<points.size();po++){\\n         if(po==0)\\n         sols++;\\n         else{\\nif(points[po][0]>=points[po+r][0]&&points[po][0]<=points[po+r][1]){\\n                 \\n    points[po][0]=max(points[po+r][0],points[po][0]);\\n    points[po][1]=min(points[po+r][1],points[po][l]);\\n    continue;\\n          }\\n else sols++;\\n         }\\n     }\\n     return sols;      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n     sort(points.begin(),points.end());\\n     int sols=0,r=-1;\\n     for(int po=0;po<points.size();po++){\\n         if(po==0)\\n         sols++;\\n         else{\\nif(points[po][0]>=points[po+r][0]&&points[po][0]<=points[po+r][1]){\\n                 \\n    points[po][0]=max(points[po+r][0],points[po][0]);\\n    points[po][1]=min(points[po+r][1],points[po][l]);\\n    continue;\\n          }\\n else sols++;\\n         }\\n     }\\n     return sols;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000585,
                "title": "c-easy-solution-greedy-o-nlogn",
                "content": "# Intuition\\n- To minimize number of arrows used \\n  We Have to shoot arraow in maximum intersection points \\n- but Every baloon contains  atleast one arrow \\n- Sort the cordinates by end it ensure that no bullon \\n  before the first boolon . \\n- WE have to must brust first boolon \\n- so we choose end position to arrow because  maximize the intersection baloons next to that . \\n- intersection : whose start is less than end so end is inbetween point \\n# Approach Greedy \\n<!-- Describe your approach to solving the problem. -->\\nalgo : \\n1) sort according to xend \\n2) while loop : \\n    select first unbrusted ballon\\n    ++cnt;\\n    skip all baloon whose st is less than brusted baloon end . \\n3) return cnt . \\n\\n# Plz Upvote If this post is helpful . \\n# Complexity\\n- Time complexity: O (N LogN ) sorting \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool sortcol(vector<int> &a , vector<int> &b)\\n    {\\n        return (a[1] < b[1]);\\n    }\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin() , points.end(), sortcol);\\n        int i = 0 , cnt = 0 , n = points.size();\\n        while( i < n )\\n        {\\n            ++cnt;\\n            int end = points[i][1];\\n            ++i;\\n            while( i < n && points[i][0] <=end )\\n            {\\n                ++i;\\n            }\\n        }\\n        return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool sortcol(vector<int> &a , vector<int> &b)\\n    {\\n        return (a[1] < b[1]);\\n    }\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin() , points.end(), sortcol);\\n        int i = 0 , cnt = 0 , n = points.size();\\n        while( i < n )\\n        {\\n            ++cnt;\\n            int end = points[i][1];\\n            ++i;\\n            while( i < n && points[i][0] <=end )\\n            {\\n                ++i;\\n            }\\n        }\\n        return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000545,
                "title": "python-greedy-solution-sorting",
                "content": "# Intuition\\nIf we look at problems related to intervals , first thing we do is sorting but how and by which column. \\n\\nFirstly, look at the interval we can solve the problem either reverse order strategy or acsending order. Here I solve using reverse order.\\n\\n# Approach\\n1. Sort the points according to start points.\\n2. Traverse the points from last start points and check whether my last interval is end before curr_start interval. If so then update new curr_start interval to last interval start point and count the arrows.\\n3. Repeat the step - 2 for all points in points array.\\n4. Return the count of arrow. \\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(reverse = True)\\n        ans = 1\\n        curr_pos = points[0][0]\\n        for x, y in points:\\n            if y < curr_pos:\\n                curr_pos = x\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(reverse = True)\\n        ans = 1\\n        curr_pos = points[0][0]\\n        for x, y in points:\\n            if y < curr_pos:\\n                curr_pos = x\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854579,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public int FindMinArrowShots(int[][] points) \\n    {\\n        Array.Sort(points, new Comparer());\\n        int ans = 0, x = 0;\\n        for (int i = 0; i < points.Length; ++i)\\n        {\\n            if (ans == 0 || points[i][0] > x)\\n            {\\n                ++ans;\\n                x = points[i][1];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    private class Comparer : IComparer<int[]>\\n    {\\n        public int Compare(int[] a, int[] b) => a[1].CompareTo(b[1]);\\n        \\n    }\\n}\\n```\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n\\n- Space complexity: $$O(1)$$\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int FindMinArrowShots(int[][] points) \\n    {\\n        Array.Sort(points, new Comparer());\\n        int ans = 0, x = 0;\\n        for (int i = 0; i < points.Length; ++i)\\n        {\\n            if (ans == 0 || points[i][0] > x)\\n            {\\n                ++ans;\\n                x = points[i][1];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    private class Comparer : IComparer<int[]>\\n    {\\n        public int Compare(int[] a, int[] b) => a[1].CompareTo(b[1]);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703639,
                "title": "java-sorting-greedy",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\\n        int arrows = 1;\\n        int reach = points[0][1];\\n\\n        for (int i = 1; i < points.length; i++) {\\n            if (points[i][0] > reach) {\\n                arrows++;\\n                reach = points[i][1];\\n            }\\n        }\\n\\n        return arrows;\\n    }\\n}\\n\\n// TC: O(n *  logn) + O(n) => O(n * logn)\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\\n        int arrows = 1;\\n        int reach = points[0][1];\\n\\n        for (int i = 1; i < points.length; i++) {\\n            if (points[i][0] > reach) {\\n                arrows++;\\n                reach = points[i][1];\\n            }\\n        }\\n\\n        return arrows;\\n    }\\n}\\n\\n// TC: O(n *  logn) + O(n) => O(n * logn)\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2000158,
                "title": "elixir-simple-solution",
                "content": "```elixir\\ndefmodule Solution do\\n  @spec find_min_arrow_shots(points :: [[integer]]) :: integer\\n  def find_min_arrow_shots(points) do\\n    points\\n    |> Enum.sort(fn [_, e1], [_, e2] -> e1 <= e2 end)\\n    |> Enum.reduce({-2_147_483_649, 0}, fn [s, e], {acc, ct} ->\\n      (s <= acc && {acc, ct}) || {e, ct + 1}\\n    end)\\n    |> elem(1)\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```elixir\\ndefmodule Solution do\\n  @spec find_min_arrow_shots(points :: [[integer]]) :: integer\\n  def find_min_arrow_shots(points) do\\n    points\\n    |> Enum.sort(fn [_, e1], [_, e2] -> e1 <= e2 end)\\n    |> Enum.reduce({-2_147_483_649, 0}, fn [s, e], {acc, ct} ->\\n      (s <= acc && {acc, ct}) || {e, ct + 1}\\n    end)\\n    |> elem(1)\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1697755,
                "title": "c-same-logic-as-merge-intervals-with-comments",
                "content": "```\\n/*the main diff btwn merge intervals and this problem is in merge intervals we needed to find the \\nmaximum accumulation within an interval but in this one we need to limit our interval with\\nminimum value so that to ensure in one hit we can burst all balloons within it*/\\n\\n\\n/*suppose we have (1,10) and (3,6) and (9,11) , now if i think i cant include al of them under 1 interval\\nsince in that case i will miss on either (3,6) or (9,11) to ensure it doesnt happen we include (3,6) and \\nlimit our new interval with 6 so it ensures i can at least burst (1,10) and (3,6) in 1 hit */\\n\\n//code\\n int findMinArrowShots(vector<vector<int>>& points) {\\n        int count=1;\\n        if(points.size()==0)\\n        {\\n            return 0;\\n        }\\n        sort(points.begin(),points.end());\\n        vector<int>burst=points[0];\\n        for(auto it:points)\\n        {\\n            if(burst[1]>=it[0])\\n            {\\n                burst[1]=min(burst[1],it[1]);\\n            }\\n            else{\\n                count++;\\n                burst=it;\\n            }\\n        }\\n        return count++;\\n\\t\\t\\n\\t\\t//if you understood the solution pls upvote :-)",
                "solutionTags": [],
                "code": "```\\n/*the main diff btwn merge intervals and this problem is in merge intervals we needed to find the \\nmaximum accumulation within an interval but in this one we need to limit our interval with\\nminimum value so that to ensure in one hit we can burst all balloons within it*/\\n\\n\\n/*suppose we have (1,10) and (3,6) and (9,11) , now if i think i cant include al of them under 1 interval\\nsince in that case i will miss on either (3,6) or (9,11) to ensure it doesnt happen we include (3,6) and \\nlimit our new interval with 6 so it ensures i can at least burst (1,10) and (3,6) in 1 hit */\\n\\n//code\\n int findMinArrowShots(vector<vector<int>>& points) {\\n        int count=1;\\n        if(points.size()==0)\\n        {\\n            return 0;\\n        }\\n        sort(points.begin(),points.end());\\n        vector<int>burst=points[0];\\n        for(auto it:points)\\n        {\\n            if(burst[1]>=it[0])\\n            {\\n                burst[1]=min(burst[1],it[1]);\\n            }\\n            else{\\n                count++;\\n                burst=it;\\n            }\\n        }\\n        return count++;\\n\\t\\t\\n\\t\\t//if you understood the solution pls upvote :-)",
                "codeTag": "Unknown"
            },
            {
                "id": 1687535,
                "title": "minimum-number-of-arrows-to-burst-balloons-java-100-easy",
                "content": "class Solution {\\n\\n    public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\\n        int ans = 0, arrow = 0;\\n        for (int i = 0; i < points.length; i ++) {\\n            if (ans == 0 || points[i][0] > arrow) {\\n                ans ++;\\n                arrow = points[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\\n        int ans = 0, arrow = 0;\\n        for (int i = 0; i < points.length; i ++) {\\n            if (ans == 0 || points[i][0] > arrow) {\\n                ans ++;\\n                arrow = points[i][1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1686251,
                "title": "my-c-solution-with-qsort",
                "content": "```\\nint cmp(const void *a, const void *b)\\n{\\n    const int  x = ((int **)a)[0][1];\\n    const int  y = ((int **)b)[0][1];\\n    if(x > y)\\n        return 1;\\n    else if(x < y)\\n        return -1;\\n    return 0;\\n}\\n\\nint findMinArrowShots(int** points, int pointsSize, int* pointsColSize){\\n    qsort(points, pointsSize, sizeof(int *), cmp);\\n    int result = 1, min = points[0][1];\\n    for(int i = 1; i < pointsSize; i++)\\n    {\\n        if(points[i][0] > min)\\n        {\\n            result++;\\n            min = points[i][1];\\n        }\\n        else\\n            min = min < points[i][1] ? min : points[i][1];\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint cmp(const void *a, const void *b)\\n{\\n    const int  x = ((int **)a)[0][1];\\n    const int  y = ((int **)b)[0][1];\\n    if(x > y)\\n        return 1;\\n    else if(x < y)\\n        return -1;\\n    return 0;\\n}\\n\\nint findMinArrowShots(int** points, int pointsSize, int* pointsColSize){\\n    qsort(points, pointsSize, sizeof(int *), cmp);\\n    int result = 1, min = points[0][1];\\n    for(int i = 1; i < pointsSize; i++)\\n    {\\n        if(points[i][0] > min)\\n        {\\n            result++;\\n            min = points[i][1];\\n        }\\n        else\\n            min = min < points[i][1] ? min : points[i][1];\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1377769,
                "title": "c-solution",
                "content": "- time: O(nlogn)\\n- space: O(1)\\n```\\npublic class Solution {\\n    public int FindMinArrowShots(int[][] points) {\\n        \\n        if(points == null || points.Length == 0)\\n            return 0;\\n        \\n        Array.Sort(points, (a,b) => a[1].CompareTo(b[1]));\\n        int end = points[0][1], cnt = 1;\\n        for(int i = 1; i < points.Length; i++)\\n        {\\n            if(end >= points[i][0])\\n                continue;\\n            \\n            cnt++;\\n            end = points[i][1];\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int FindMinArrowShots(int[][] points) {\\n        \\n        if(points == null || points.Length == 0)\\n            return 0;\\n        \\n        Array.Sort(points, (a,b) => a[1].CompareTo(b[1]));\\n        int end = points[0][1], cnt = 1;\\n        for(int i = 1; i < points.Length; i++)\\n        {\\n            if(end >= points[i][0])\\n                continue;\\n            \\n            cnt++;\\n            end = points[i][1];\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259944,
                "title": "java-unique-solution",
                "content": "Here is a different solution, I have sorted given array based on starting position.\\n**Upvote if you like the solution**\\n```\\nclass Solution {\\n\\n    public int findMinArrowShots(int[][] points) {\\n        \\n\\t\\t// Sorting based on starting points\\n    Arrays.sort(points, new Comparator<int[]>() {\\n    public int compare(int[] a, int[] b) {\\n        return Integer.compare(a[0], b[0]);\\n    }\\n});    \\n\\n        \\n        int count = 1;\\n        int prevStart = points[0][0];\\n        int prevEnd = points[0][1];\\n        \\n        for(int i=1 ; i< points.length ; i++)\\n        {\\n            // System.out.println(\"Start : \" + prevStart + \" End : \" + prevEnd);\\n            \\n\\t\\t\\t// If ballon\\'s end point is smaller, for example\\n\\t\\t\\t// [5,15] and [6,12] in this case we neec to update prevEnd to points[i][1]\\n            if(points[i][0] >= prevStart && points[i][1] <= prevEnd )\\n            {\\n                prevStart = points[i][0];\\n                prevEnd = points[i][1];\\n            }\\n           else if( points[i][0] > prevEnd)\\n            {\\n                count++;\\n                prevStart = points[i][0];\\n                prevEnd =  points[i][1] > prevEnd ? points[i][1] : prevEnd;\\n                \\n            }\\n            \\n        }\\n \\n        return count;\\n \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int findMinArrowShots(int[][] points) {\\n        \\n\\t\\t// Sorting based on starting points\\n    Arrays.sort(points, new Comparator<int[]>() {\\n    public int compare(int[] a, int[] b) {\\n        return Integer.compare(a[0], b[0]);\\n    }\\n});    \\n\\n        \\n        int count = 1;\\n        int prevStart = points[0][0];\\n        int prevEnd = points[0][1];\\n        \\n        for(int i=1 ; i< points.length ; i++)\\n        {\\n            // System.out.println(\"Start : \" + prevStart + \" End : \" + prevEnd);\\n            \\n\\t\\t\\t// If ballon\\'s end point is smaller, for example\\n\\t\\t\\t// [5,15] and [6,12] in this case we neec to update prevEnd to points[i][1]\\n            if(points[i][0] >= prevStart && points[i][1] <= prevEnd )\\n            {\\n                prevStart = points[i][0];\\n                prevEnd = points[i][1];\\n            }\\n           else if( points[i][0] > prevEnd)\\n            {\\n                count++;\\n                prevStart = points[i][0];\\n                prevEnd =  points[i][1] > prevEnd ? points[i][1] : prevEnd;\\n                \\n            }\\n            \\n        }\\n \\n        return count;\\n \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1216566,
                "title": "interval-scheduling-algorithm",
                "content": "The intuition here is to find max number of ballons which don\\'t overlap. As this is the biggest such possible set all other ballons can be burst by ony bursting ballons in this set individually.\\n\\nWith this the problem reduces to interval selection problem, i.e. finding largest set of non-overlapping intervals. Python code:\\n```\\nclass Solution:\\n    def findMinArrowShots(self, intervals: List[List[int]]) -> int:\\n        n = len(intervals)\\n        if n <= 1:\\n            return n\\n\\n        intervals.sort(key=lambda x: x[1])\\n        selected = [intervals[0]]\\n        for i in range(1,n):\\n            if intervals[i][0] > selected[-1][1]:\\n                selected.append(intervals[i])\\n\\n        return len(selected)\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def findMinArrowShots(self, intervals: List[List[int]]) -> int:\\n        n = len(intervals)\\n        if n <= 1:\\n            return n\\n\\n        intervals.sort(key=lambda x: x[1])\\n        selected = [intervals[0]]\\n        for i in range(1,n):\\n            if intervals[i][0] > selected[-1][1]:\\n                selected.append(intervals[i])\\n\\n        return len(selected)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888034,
                "title": "c-simple-sorting-solution-explained-98-time-10-space",
                "content": "Another problem in the family of overlapping intervals, clearly, and as such it should be solved.\\n\\nFirst of all I sorted the array by closing intervals first and opening intervals second, using the helper function `comp`; turns out just sorting by closing intervals was enough, but I did not see much of a change saving the conditional in the function.\\n\\nAlso, be sure to pass the parameters as references for your comparing function: I was about to forget it (again \\uD83E\\uDD26\\u200D\\u2642\\uFE0F ) and man if it hit the performance!\\n\\nThen I declared a few helper variables:\\n* `len` will store the lenght of the input variable;\\n* `res` will be initialised to be `= len`, since we will assume that initially you will need `len` arrows and then decrease for each overlap spotted;\\n* `lmt` stores up to where we are considering checking for overlaps - initialised with the closing value of the very first element of the (now sorted) input.\\n\\nWe will then loop through all the other elements (ie: starting from the second) and check if the opening time of the current interval is `> lmt`:\\n* if so, we update `lmt` to the closing (notice!) time of the current one;\\n* otherwise, we found an overlap and can decrease `res` by `1`.\\n\\nIf you assume this starting input:\\n\\n```cpp\\n[[10,16],[2,8],[1,6],[7,12],[3,4],[12,16],[9,12],[9,11],[3,7],[4,9],[15,16],[1,3],[6,8]]\\n// res == 13: the initial length of the input\\n```\\n\\nYou will have the array sorted something like this:\\n\\n```cpp\\n{1, 3}, {3, 4}, {1, 6}, {3, 7}, {6, 8}, {2, 8}, {4, 9}, {9, 11}, {9, 12}, {7, 12}, {15, 16}, {12, 16}, {10, 16}\\n// lmt == 3\\n// res == 13\\n```\\n\\n`lmt` is initially going to be set to `3`, shooting there you will only take down the first balloon, then you will update it to `4`, take down the balloons from the second to the fourth (so you will have to decrease `res` by `2`), update `lmt` and so on.\\n\\nNotice **we do not actully remove items from the array**, as it would be rather expensive, while iterating is enough; I just removed them for display convenience:\\n\\n```cpp\\n// hit the first, it goes down alone and we update lmt\\n{3, 4}, {1, 6}, {3, 7}, {6, 8}, {2, 8}, {4, 9}, {9, 11}, {9, 12}, {7, 12}, {15, 16}, {12, 16}, {10, 16}\\n// lmt == 4\\n// res == 13\\n\\n// hit the next 3 with one arrow, res goes down by 2 and we update lmt\\n{6, 8}, {2, 8}, {4, 9}, {9, 11}, {9, 12}, {7, 12}, {15, 16}, {12, 16}, {10, 16}\\n// lmt == 8\\n// res == 11\\n\\n// ...\\n// try to execute all the intermediate steps on your own and you should end up like this:\\n\\n// last step: one last arrow to down 3 - notice that {10, 16} might have been downed before, for example\\n// if you had sorted by starting time, but it really does not change the ultimate result\\n{15, 16}, {12, 16}, {10, 16}\\n// lmt == 16\\n// res == 6\\n\\n// final step\\n// lmt == 16\\n// res == 4\\n```\\n\\nOnce done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nstatic auto comp = [](auto &a, auto &b){return a[1] != b[1] ? a[1] < b[1] : a[0] > b[0];};\\n\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& pts) {\\n        // edge case out\\n        if (!pts.size()) return 0;\\n        // sorting by ending time first, then starting time\\n        sort(begin(pts), end(pts), comp);\\n        // support variables\\n        int len = pts.size(), res = len, lmt = pts[0][1];\\n        // finding all the overlaps\\n        for (int i = 1; i < len; i++) {\\n            // overlap not found\\n\\t\\t\\tif (lmt < pts[i][0]) lmt = pts[i][1];\\n\\t\\t\\t// overlap found\\n            else res--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n[[10,16],[2,8],[1,6],[7,12],[3,4],[12,16],[9,12],[9,11],[3,7],[4,9],[15,16],[1,3],[6,8]]\\n// res == 13: the initial length of the input\\n```\n```cpp\\n{1, 3}, {3, 4}, {1, 6}, {3, 7}, {6, 8}, {2, 8}, {4, 9}, {9, 11}, {9, 12}, {7, 12}, {15, 16}, {12, 16}, {10, 16}\\n// lmt == 3\\n// res == 13\\n```\n```cpp\\n// hit the first, it goes down alone and we update lmt\\n{3, 4}, {1, 6}, {3, 7}, {6, 8}, {2, 8}, {4, 9}, {9, 11}, {9, 12}, {7, 12}, {15, 16}, {12, 16}, {10, 16}\\n// lmt == 4\\n// res == 13\\n\\n// hit the next 3 with one arrow, res goes down by 2 and we update lmt\\n{6, 8}, {2, 8}, {4, 9}, {9, 11}, {9, 12}, {7, 12}, {15, 16}, {12, 16}, {10, 16}\\n// lmt == 8\\n// res == 11\\n\\n// ...\\n// try to execute all the intermediate steps on your own and you should end up like this:\\n\\n// last step: one last arrow to down 3 - notice that {10, 16} might have been downed before, for example\\n// if you had sorted by starting time, but it really does not change the ultimate result\\n{15, 16}, {12, 16}, {10, 16}\\n// lmt == 16\\n// res == 6\\n\\n// final step\\n// lmt == 16\\n// res == 4\\n```\n```cpp\\nstatic auto comp = [](auto &a, auto &b){return a[1] != b[1] ? a[1] < b[1] : a[0] > b[0];};\\n\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& pts) {\\n        // edge case out\\n        if (!pts.size()) return 0;\\n        // sorting by ending time first, then starting time\\n        sort(begin(pts), end(pts), comp);\\n        // support variables\\n        int len = pts.size(), res = len, lmt = pts[0][1];\\n        // finding all the overlaps\\n        for (int i = 1; i < len; i++) {\\n            // overlap not found\\n\\t\\t\\tif (lmt < pts[i][0]) lmt = pts[i][1];\\n\\t\\t\\t// overlap found\\n            else res--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888013,
                "title": "minimum-number-of-arrows-to-burst-balloons-python",
                "content": "```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points = sorted(points, key= lambda x:x[1])\\n        res,end = 0,-float(\\'inf\\')\\n        \\n        for interval in points:\\n            if interval[0] > end:\\n                res += 1\\n                end = interval[1]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points = sorted(points, key= lambda x:x[1])\\n        res,end = 0,-float(\\'inf\\')\\n        \\n        for interval in points:\\n            if interval[0] > end:\\n                res += 1\\n                end = interval[1]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 752666,
                "title": "simple-c-solution-counting-overlaps",
                "content": "* Sort the intervals\\n* Intialise the total arrows required as size of total baloons\\n* Reduce the arrows whereever overlap is happening\\n\\n```\\n int findMinArrowShots(vector<vector<int>>& points) {\\n        if(points.size() == 0)\\n            return 0;\\n        sort(points.begin(), points.end());\\n        int arrows = points.size(), end = points[0][1];\\n        for(int i =1;i<points.size();i++) {\\n\\t\\t\\t//Overlapping happening, so reduce the max range that this arrow can cover\\n            if(points[i][0] <= end) {\\n                end = min(end,points[i][1]);\\n                --arrows;\\n            } else\\n                end = points[i][1];\\n        }\\n        return arrows;\\n    }\\n```\\n",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\n int findMinArrowShots(vector<vector<int>>& points) {\\n        if(points.size() == 0)\\n            return 0;\\n        sort(points.begin(), points.end());\\n        int arrows = points.size(), end = points[0][1];\\n        for(int i =1;i<points.size();i++) {\\n\\t\\t\\t//Overlapping happening, so reduce the max range that this arrow can cover\\n            if(points[i][0] <= end) {\\n                end = min(end,points[i][1]);\\n                --arrows;\\n            } else\\n                end = points[i][1];\\n        }\\n        return arrows;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 638189,
                "title": "c-greedy-with-comment-explanation",
                "content": "```\\npublic class Solution {\\n    public int FindMinArrowShots(int[][] points) {\\n        if (points.Length <= 1) return points.Length;\\n        \\n        //Sort the ranges by start integer\\n        Array.Sort(points, new ArrayComparer());\\n        \\n        //xStart and xEnd represent the minimum overlapping range of subsequent elements\\n        //When a range doesn\\'t overlap this range, we will increment shots and create a new overlap range\\n        int xStart = points[0][0];\\n        int xEnd = points[0][1];\\n        int shots = 0;\\n        \\n        for (int i = 1; i < points.Length; i++){\\n            //The next range doesn\\'t overlap with what we have found so far so we shoot and arrow and find more overlaps\\n            if (points[i][0] > xEnd){\\n                shots++;\\n                xStart = points[i][0];\\n                xEnd = points[i][1];\\n                continue;\\n            }\\n            \\n            //Keep minimizing the current overlapping range\\n            if (points[i][0] > xStart) xStart = points[i][0];\\n            if (points[i][1] < xEnd) xEnd = points[i][1];\\n        }\\n        \\n        //There will always be some last array we need to fire\\n        shots++;\\n        \\n        return shots;\\n    }\\n    \\n    public class ArrayComparer : IComparer<int[]> {\\n        public int Compare(int[] r1, int[] r2){\\n            return r1[0].CompareTo(r2[0]);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindMinArrowShots(int[][] points) {\\n        if (points.Length <= 1) return points.Length;\\n        \\n        //Sort the ranges by start integer\\n        Array.Sort(points, new ArrayComparer());\\n        \\n        //xStart and xEnd represent the minimum overlapping range of subsequent elements\\n        //When a range doesn\\'t overlap this range, we will increment shots and create a new overlap range\\n        int xStart = points[0][0];\\n        int xEnd = points[0][1];\\n        int shots = 0;\\n        \\n        for (int i = 1; i < points.Length; i++){\\n            //The next range doesn\\'t overlap with what we have found so far so we shoot and arrow and find more overlaps\\n            if (points[i][0] > xEnd){\\n                shots++;\\n                xStart = points[i][0];\\n                xEnd = points[i][1];\\n                continue;\\n            }\\n            \\n            //Keep minimizing the current overlapping range\\n            if (points[i][0] > xStart) xStart = points[i][0];\\n            if (points[i][1] < xEnd) xEnd = points[i][1];\\n        }\\n        \\n        //There will always be some last array we need to fire\\n        shots++;\\n        \\n        return shots;\\n    }\\n    \\n    public class ArrayComparer : IComparer<int[]> {\\n        public int Compare(int[] r1, int[] r2){\\n            return r1[0].CompareTo(r2[0]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 303197,
                "title": "c-simple-greedy-solution",
                "content": "```\\n\\nint findMinArrowShots(vector<vector<int>>& points) {\\n        if(!points.size()) return 0;\\n        sort(points.begin(), points.end());\\n        int count = 1, last = points[0][1];\\n        for(int i = 1; i < points.size(); i++)\\n        {\\n            if(last > points[i][1] ) \\n                last = points[i][1];\\n            else if(last < points[i][0]) {\\n                last = points[i][1];\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nint findMinArrowShots(vector<vector<int>>& points) {\\n        if(!points.size()) return 0;\\n        sort(points.begin(), points.end());\\n        int count = 1, last = points[0][1];\\n        for(int i = 1; i < points.size(); i++)\\n        {\\n            if(last > points[i][1] ) \\n                last = points[i][1];\\n            else if(last < points[i][0]) {\\n                last = points[i][1];\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 273208,
                "title": "o-n-solution-no-sort-but-fail-in-large-number",
                "content": "The idea is similar to bucket sort. But for large range, the auxiliary array will be too big.\\n```\\nvar findMinArrowShots = function(points) {\\n  if(!points.length) return 0;\\n  const size = points.length;\\n  let min = points[0][0];\\n  let max = points[0][1];\\n  let result = 0;\\n  \\n  for(let i = 1; i < size; i++) {\\n    if(points[i][0] < min) min = points[i][0];\\n    if(points[i][1] > max) max = points[i][1];\\n  }\\n  \\n  let arr = Array(max - min + 2).fill(0);\\n  \\n  for(let i = 0; i < size; i++) {\\n    arr[points[i][0] - min]++;\\n    arr[points[i][1] - min + 1]--;\\n  }\\n  \\n  result = arr[0];\\n  for(let i = 1; i < arr.length; i++) {\\n    arr[i] += arr[i - 1];\\n    if(arr[i] > result) result = arr[i];\\n  }\\n\\n  return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findMinArrowShots = function(points) {\\n  if(!points.length) return 0;\\n  const size = points.length;\\n  let min = points[0][0];\\n  let max = points[0][1];\\n  let result = 0;\\n  \\n  for(let i = 1; i < size; i++) {\\n    if(points[i][0] < min) min = points[i][0];\\n    if(points[i][1] > max) max = points[i][1];\\n  }\\n  \\n  let arr = Array(max - min + 2).fill(0);\\n  \\n  for(let i = 0; i < size; i++) {\\n    arr[points[i][0] - min]++;\\n    arr[points[i][1] - min + 1]--;\\n  }\\n  \\n  result = arr[0];\\n  for(let i = 1; i < arr.length; i++) {\\n    arr[i] += arr[i - 1];\\n    if(arr[i] > result) result = arr[i];\\n  }\\n\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 256088,
                "title": "python-beats-100-easy-to-understand",
                "content": "```\\ndef findMinArrowShots(self, points):\\n        if len(points) == 0:\\n            return 0 \\n        points = sorted(points, key=lambda x:x[1])\\n        arrowLastHit = -float(\\'inf\\')\\n        arrow = 0\\n        for each in points:\\n            if each[0] > arrowLastHit:\\n                arrow += 1\\n                arrowLastHit = each[1]\\n        return arrow\\n",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\ndef findMinArrowShots(self, points):\\n        if len(points) == 0:\\n            return 0 \\n        points = sorted(points, key=lambda x:x[1])\\n        arrowLastHit = -float(\\'inf\\')\\n        arrow = 0\\n        for each in points:\\n            if each[0] > arrowLastHit:\\n                arrow += 1\\n                arrowLastHit = each[1]\\n        return arrow\\n",
                "codeTag": "Python3"
            },
            {
                "id": 157690,
                "title": "simple-application-of-activity-selection-greedy-approach",
                "content": "```\\nclass Solution {\\n    public int findMinArrowShots(int[][] arr) {\\n        if(arr.length==0)\\n            return 0;\\n      \\n        Arrays.sort(arr,new SortEnd());\\n      \\n       int i=1;\\n        int end=arr[0][1];\\n        int ct=1;\\n        while(i<arr.length){\\n            if(arr[i][0]<=end){\\n                //overlapping interval\\n            }else{\\n                //non overlapping interval mila\\n                ct++;\\n                end=arr[i][1];\\n            }\\n            i++;\\n        }\\n        \\n        return ct;\\n    }\\n\\n    \\n\\n}\\n    class SortEnd implements Comparator<int[]>{\\n        //ascending order me sort karne ki koshish\\n        public int compare(int a[],int b[]){\\n            return a[1]-b[1];\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findMinArrowShots(int[][] arr) {\\n        if(arr.length==0)\\n            return 0;\\n      \\n        Arrays.sort(arr,new SortEnd());\\n      \\n       int i=1;\\n        int end=arr[0][1];\\n        int ct=1;\\n        while(i<arr.length){\\n            if(arr[i][0]<=end){\\n                //overlapping interval\\n            }else{\\n                //non overlapping interval mila\\n                ct++;\\n                end=arr[i][1];\\n            }\\n            i++;\\n        }\\n        \\n        return ct;\\n    }\\n\\n    \\n\\n}\\n    class SortEnd implements Comparator<int[]>{\\n        //ascending order me sort karne ki koshish\\n        public int compare(int a[],int b[]){\\n            return a[1]-b[1];\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 93716,
                "title": "c-easy-to-understand-solution-using-sort-starting-point",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<pair<int, int>>& points) {\\n        if(points.empty())\\n            return 0;\\n        //worst case needs the same number of arrows\\n        int cnt = points.size();\\n        \\n        //sort by the starting point\\n        sort(points.begin(), points.end(), [](const pair<int, int> &a, const pair<int, int> &b){return a.first<b.first;});\\n        for(int i=1;i<points.size();i++){\\n            if(points[i].first<=points[i-1].second){\\n                //update the current point's ending by the smaller one so we can tell if the next's start will overlap or not\\n                points[i].second = min(points[i-1].second, points[i].second);\\n                cnt--;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findMinArrowShots(vector<pair<int, int>>& points) {\\n        if(points.empty())\\n            return 0;\\n        //worst case needs the same number of arrows\\n        int cnt = points.size();\\n        \\n        //sort by the starting point\\n        sort(points.begin(), points.end(), [](const pair<int, int> &a, const pair<int, int> &b){return a.first<b.first;}",
                "codeTag": "Java"
            },
            {
                "id": 4040620,
                "title": "minimum-number-of-arrows-to-burst-balloons-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nbool cmp(vector<int>& a, vector<int>& b) {return a[1] < b[1];}\\nclass Solution {\\npublic:  \\n    int findMinArrowShots(vector<vector<int>>& segments) {\\n        sort(segments.begin(), segments.end(), cmp);\\n        int ans = 0, arrow = 0;\\n        for (int i = 0; i < segments.size(); i ++) {\\n            if (ans == 0 || segments[i][0] > arrow) {\\n                ans ++;\\n                arrow = segments[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nbool cmp(vector<int>& a, vector<int>& b) {return a[1] < b[1];}\\nclass Solution {\\npublic:  \\n    int findMinArrowShots(vector<vector<int>>& segments) {\\n        sort(segments.begin(), segments.end(), cmp);\\n        int ans = 0, arrow = 0;\\n        for (int i = 0; i < segments.size(); i ++) {\\n            if (ans == 0 || segments[i][0] > arrow) {\\n                ans ++;\\n                arrow = segments[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482643,
                "title": "activity-selection-problem",
                "content": "\\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points,(a,b)->Integer.compare(a[1],b[1]));  //Sorting acc to end points\\n        int count = 0, arrow=0;\\n        for(int i=0;i<points.length;i++){\\n            if( count==0 || points[i][0] > arrow){     //Comparing with starting point\\n                count++;\\n                arrow=points[i][1]; //End point, the whole segment will become arrow\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points,(a,b)->Integer.compare(a[1],b[1]));  //Sorting acc to end points\\n        int count = 0, arrow=0;\\n        for(int i=0;i<points.length;i++){\\n            if( count==0 || points[i][0] > arrow){     //Comparing with starting point\\n                count++;\\n                arrow=points[i][1]; //End point, the whole segment will become arrow\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478423,
                "title": "python-simple-clean-solution-using-greedy-and-without",
                "content": "# Code\\n- Here range is checked if it is range or not?\\n\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key=lambda x:(x[0], x[1]))\\n        \\n        ans = 1\\n        l, r = points[0]\\n        n = len(points)\\n        \\n        for i in range(n):\\n            if l <= points[i][0] <= r or l <= points[i][1] <= r:\\n                l = max(l, points[i][0])\\n                r = min(r, points[i][1])\\n            else:\\n                ans += 1\\n                l, r = points[i][0], points[i][1]\\n        return ans\\n\\n```\\n- This one is greedy sol. here sorting points according to ending point and then we will throw arrow at ending point and it will burst ballons which are having starting point <= arrow and when this condition falls we need another arrow and change arrow Position\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key=lambda x:x[1])\\n\\n        arrowPos = points[0][1]\\n        ans = 1\\n\\n        for x in points:\\n            if arrowPos >= x[0]:\\n                continue\\n            arrowPos = x[1]\\n            ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key=lambda x:(x[0], x[1]))\\n        \\n        ans = 1\\n        l, r = points[0]\\n        n = len(points)\\n        \\n        for i in range(n):\\n            if l <= points[i][0] <= r or l <= points[i][1] <= r:\\n                l = max(l, points[i][0])\\n                r = min(r, points[i][1])\\n            else:\\n                ans += 1\\n                l, r = points[i][0], points[i][1]\\n        return ans\\n\\n```\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key=lambda x:x[1])\\n\\n        arrowPos = points[0][1]\\n        ans = 1\\n\\n        for x in points:\\n            if arrowPos >= x[0]:\\n                continue\\n            arrowPos = x[1]\\n            ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301081,
                "title": "simple-code",
                "content": "# Intuition\\nwhile comparing 2 values a and b they may be negative also. SO in that case the a-b might overflow. To gget the correct value after subtraction we can use (Integer.compare(a,b)).\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a,b)-> Integer.compare(a[1],b[1]));\\n        int ans = 1;\\n        int end=points[0][1];\\n        for(int i=1;i<points.length;i++){\\n            if(end < points[i][0]){\\n                ans++;\\n                end=points[i][1];\\n            }           \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a,b)-> Integer.compare(a[1],b[1]));\\n        int ans = 1;\\n        int end=points[0][1];\\n        for(int i=1;i<points.length;i++){\\n            if(end < points[i][0]){\\n                ans++;\\n                end=points[i][1];\\n            }           \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085287,
                "title": "c-java-solution-explained-for-dummies-visualised",
                "content": "### Intuition\\nSo this problem is simple classic `overlapping intervals` problem but intervals come in balloons and overlapping come in shooting area where you have to shoot at to hit your targets which are the balloons. \\n\\nEnough talking lets visualize the problem with my high art skills:\\nWe will take our first testcase where points = [ [10,16] , [2,8] , [1,6] , [7,12] ]\\nThen We will sort them to get [ [1,6] , [2,8] , [7,12] , [10,16] ]\\n![photo_\\u0662\\u0660\\u0662\\u0663-\\u0660\\u0661-\\u0662\\u0662_\\u0660\\u0669-\\u0661\\u0666-\\u0663\\u0667.jpg](https://assets.leetcode.com/users/images/69b425d8-bd91-49fa-ac41-ca4f0b9ab858_1674372816.3341389.jpeg)\\nSo as we can painfully see our overlapping areas are 3 areas:\\n-First area is between **first & second ballon**.\\n-Second area is between **second & third ballon**.\\n-Third area is between **third & fourth ballon**.\\n\\nWe need to use **minimum number of arrows** to **burst all ballons**, so if we shot at first area we will burst first & second ballon, if in second area we will burst second & third ballon and if in third area we will burst third & fourth ballon.\\nThat\\'s it, We got all of our targets with **3 arrows**, But wait a minute We could have got all of our targets with only **2 arrows** and that\\'s by shooting at first area and third area only, so now we understand that we don\\'t use or count every **overlapping area**, but just the ones necessary to hit our targets with minimum shots.\\n\\nSo if you already bursted a ballon **ignore it** and **focus on next coming one** and here it\\'s clear that we will take a ***Greedy*** Approach where we focus only on our current step to get least shots and highest output.\\n\\n### Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will sort the ballons by `x.end` where -> `points[ i ] = [ x.start ,  x.end ]`.\\n\\nSo We will use what we can call **two pointers** in this Greedy approach, where first pointer will be pointing at our current ballon and next pointer will be moving and pointing on next ballons to find a ballon that doesn\\'t share an overlapping area with our current ballon.\\n\\nAt this point when we find that **non-overlapping ballon** we will move our current ballon\\'s pointer to point at the **non-overlapping ballon.**\\n\\nAt every time we move our current ballon\\'s pointer we will increase the **number of arrows we shot**, until we return the number of all **used arrows**.\\n*We will use a `for loop` for the process above.\\n*Initail value for number of **used arrows** is one, and it is one because we start counting after shooting first ballon.\\n\\n### C++\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(), points.end(), [](vector<int>& x, vector<int>& y) {\\n            return x[1] < y[1];\\n        });\\n\\n        int usedArrows = 1;\\n        for (int curr = 0, next = 1; next < points.size(); next++) {\\n            if (points[curr][1] < points[next][0]) {\\n                curr = next;\\n                usedArrows++;\\n            }\\n        }\\n\\n        return usedArrows;\\n    }\\n};\\n```\\n### Java\\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1],b[1]));\\n\\n        int usedArrows = 1;\\n        int curr = 0;\\n        for (int next = 1; next < points.length; next++) {\\n            if (points[curr][1] < points[next][0]) {\\n                curr = next;\\n                usedArrows++;\\n            }\\n        }\\n\\n        return usedArrows;\\n    }\\n};\\n\\n```\\n#### *If you find this solution helpful don\\'t forget to upvote.*\\n|\\n|\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(), points.end(), [](vector<int>& x, vector<int>& y) {\\n            return x[1] < y[1];\\n        });\\n\\n        int usedArrows = 1;\\n        for (int curr = 0, next = 1; next < points.size(); next++) {\\n            if (points[curr][1] < points[next][0]) {\\n                curr = next;\\n                usedArrows++;\\n            }\\n        }\\n\\n        return usedArrows;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1],b[1]));\\n\\n        int usedArrows = 1;\\n        int curr = 0;\\n        for (int next = 1; next < points.length; next++) {\\n            if (points[curr][1] < points[next][0]) {\\n                curr = next;\\n                usedArrows++;\\n            }\\n        }\\n\\n        return usedArrows;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005053,
                "title": "simple-java-solution-to-read-using-sorting-beats-95-69-time-o-nlogn-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1- Sort using the first element\\n2- trying to find the shared points, but be aware to when go to next element, store the minimum endpoint, not maximum \\n  when find end greater that start, then increase the number of arrows  \\n\\n# Complexity\\n- Time complexity:O(NLogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[0], b[0])); // O(NLogN)\\n\\n        int minimumArrows =1;\\n        int prev = points[0][1];\\n        for(int i=1; i<points.length;i++){ //O(N)\\n            System.out.println(points[i][0] +\" - \"+ points[i][1]);\\n              if(points[i][0] > prev){\\n                    minimumArrows++;\\n                    prev = points[i][1];\\n              }else\\n                    prev = Math.min(prev, points[i][1]);\\n        }\\n        return minimumArrows;\\n    }\\n}\\n\\n/**\\n[10,16],[2,8],[1,6],[7,12]\\n[1,6],[2,8],,[7,12],[10,16]\\n\\n prev =6 arrow =1\\n i=1 2<6   prev =8\\n i=2 7<8   prev = 12\\n\\n\\n\\n Y\\n |                   p1                 p1 \\n |   p2          p2\\n | p3          p3      \\n |               p4          p4  \\n |        \\n | \\n  ----------------------------------------  X\\n 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \\n\\n 1 20\\n 2 8\\n 7 12\\n 10 16\\n  \\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[0], b[0])); // O(NLogN)\\n\\n        int minimumArrows =1;\\n        int prev = points[0][1];\\n        for(int i=1; i<points.length;i++){ //O(N)\\n            System.out.println(points[i][0] +\" - \"+ points[i][1]);\\n              if(points[i][0] > prev){\\n                    minimumArrows++;\\n                    prev = points[i][1];\\n              }else\\n                    prev = Math.min(prev, points[i][1]);\\n        }\\n        return minimumArrows;\\n    }\\n}\\n\\n/**\\n[10,16],[2,8],[1,6],[7,12]\\n[1,6],[2,8],,[7,12],[10,16]\\n\\n prev =6 arrow =1\\n i=1 2<6   prev =8\\n i=2 7<8   prev = 12\\n\\n\\n\\n Y\\n |                   p1                 p1 \\n |   p2          p2\\n | p3          p3      \\n |               p4          p4  \\n |        \\n | \\n  ----------------------------------------  X\\n 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \\n\\n 1 20\\n 2 8\\n 7 12\\n 10 16\\n  \\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004484,
                "title": "java-using-sort-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   // Finds the minimum number of arrows needed to burst all balloons\\n   public int findMinArrowShots(int[][] points) {\\n        // Sort the balloons by the end position of the arrow\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1],b[1]));\\n        \\n        // Initialize the number of arrows needed to 1\\n        int result = 1;\\n        // Set the index of the previously burst balloon to 0\\n        int previous = 0;\\n        \\n        // Iterate through all balloons\\n        for(int current = 1; current < points.length; current++){\\n            // If the start position of the current balloon is after the end position of the arrow that burst the previous balloon,\\n            // then a new arrow is needed to burst the current balloon\\n            if(points[current][0] > points[previous][1]){\\n                result++;\\n                // Update the index of the previously burst balloon\\n                previous = current;\\n            }\\n        }\\n        return result;            \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   // Finds the minimum number of arrows needed to burst all balloons\\n   public int findMinArrowShots(int[][] points) {\\n        // Sort the balloons by the end position of the arrow\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1],b[1]));\\n        \\n        // Initialize the number of arrows needed to 1\\n        int result = 1;\\n        // Set the index of the previously burst balloon to 0\\n        int previous = 0;\\n        \\n        // Iterate through all balloons\\n        for(int current = 1; current < points.length; current++){\\n            // If the start position of the current balloon is after the end position of the arrow that burst the previous balloon,\\n            // then a new arrow is needed to burst the current balloon\\n            if(points[current][0] > points[previous][1]){\\n                result++;\\n                // Update the index of the previously burst balloon\\n                previous = current;\\n            }\\n        }\\n        return result;            \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003968,
                "title": "easy-c-solution-t-c-o-nlogn-s-c-o-1",
                "content": "# Intuition\\nSort according to  starting points(here,x start) and apply greedy approach\\n\\n# Approach\\nGreedy Approach\\n\\n# Complexity\\n- Time complexity:\\nO(N*logN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n   \\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        sort(points.begin(),points.end());\\n        \\n        int ans=1;\\n        int n=points.size();\\n        int curr=points[0][1];\\n      for(int i=1;i<n;i++)\\n      { \\n          if(points[i][0]>curr)\\n          {\\n              curr=points[i][1];\\n              ans++;\\n          }\\n          else\\n          curr=min(curr,points[i][1]);\\n      }\\n\\n          return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n   \\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        sort(points.begin(),points.end());\\n        \\n        int ans=1;\\n        int n=points.size();\\n        int curr=points[0][1];\\n      for(int i=1;i<n;i++)\\n      { \\n          if(points[i][0]>curr)\\n          {\\n              curr=points[i][1];\\n              ans++;\\n          }\\n          else\\n          curr=min(curr,points[i][1]);\\n      }\\n\\n          return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003247,
                "title": "python3-beats-99-5-easy-to-understand",
                "content": "# Intuition\\nsorting by x-ends, checking x-starts; \\nin case x-start > current x-end: counter += 1\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findMinArrowShots(self, s: List[List[int]]) -> int:\\n        s.sort(key = lambda i: i[1])\\n        k = 1\\n        aim = s.pop(0)[1]\\n        for i in s:\\n            if i[0] > aim:\\n                aim = i[1]\\n                k += 1\\n        return k\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def findMinArrowShots(self, s: List[List[int]]) -> int:\\n        s.sort(key = lambda i: i[1])\\n        k = 1\\n        aim = s.pop(0)[1]\\n        for i in s:\\n            if i[0] > aim:\\n                aim = i[1]\\n                k += 1\\n        return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003159,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(NlogN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(), points.end());\\n        int lastpoint = points[0][1];\\n        int ans = 1;\\n        for(auto x: points) {\\n            if(x[0] > lastpoint) {\\n                lastpoint = x[1];\\n                ans++;\\n            }\\n            lastpoint = min(x[1], lastpoint);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(), points.end());\\n        int lastpoint = points[0][1];\\n        int ans = 1;\\n        for(auto x: points) {\\n            if(x[0] > lastpoint) {\\n                lastpoint = x[1];\\n                ans++;\\n            }\\n            lastpoint = min(x[1], lastpoint);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002863,
                "title": "c-intuitive-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy seeing the problem we get the idea of finding out the balloons that share some common interval or whose intersection is not NULL , So we try to find out the balloons sharing co-ordinates in same range.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n**Step 1:** We sort the given points vector in increasing order of their starting points.\\n\\n**Step 2:** We maintain a ```maxStart``` and ```minEnd``` variable.\\nThe logic behind these variables is that whenever we find two ranges having an Intersection then our valid range in which the arrow will be able to burst the balloons decreases (i.e. we have to take the Intersection of the ranges.)\\n\\n**Step 3:** Now we check that the starting point of the current balloon lies within our desired range or not. \\n\\n* If it does we just update the range by taking the Intersection and updating the variables. \\n* If it doesn\\'t we update the number of arrows and start with new range. \\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n\\n        if(points.size()==1)\\n        return 1;\\n\\n        sort(points.begin(),points.end());\\n        int ans = 1, minEnd = points[0][1], maxStart = points[0][0];\\n\\n        for(int i=1;i<points.size();i++)\\n        {\\n            if(points[i][0]>=minStart && points[i][0]<=minEnd)\\n            {\\n                maxStart = max(maxStart,points[i][0]);\\n                minEnd = min(minEnd,points[i][1]);\\n            }\\n\\n            else\\n            {\\n                ans++;\\n                maxStart = points[i][0];\\n                minEnd = points[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**If this solution was helpful , please Upvote :)**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```maxStart```\n```minEnd```\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n\\n        if(points.size()==1)\\n        return 1;\\n\\n        sort(points.begin(),points.end());\\n        int ans = 1, minEnd = points[0][1], maxStart = points[0][0];\\n\\n        for(int i=1;i<points.size();i++)\\n        {\\n            if(points[i][0]>=minStart && points[i][0]<=minEnd)\\n            {\\n                maxStart = max(maxStart,points[i][0]);\\n                minEnd = min(minEnd,points[i][1]);\\n            }\\n\\n            else\\n            {\\n                ans++;\\n                maxStart = points[i][0];\\n                minEnd = points[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002833,
                "title": "explanation-sorting-with-respect-to-endpoint-c-o-nlogn",
                "content": "# Intuition\\nSay, there are 3 balloons A, B and C\\n\\n- A and B overlap by some degree\\n- B and C overlap by some degree\\n- A and C do not overlap\\n- middle point of every balloon do not overlap\\n\\nSo worst case here would be that you fire at the center and use 3 arrows\\n\\nBest case would be 2 arrows if u pop A and B and use 1 arrow for C\\n\\nNow,\\n\\nif number of balloons which overlaps with A is 1\\nand number of balloons which overlaps with B but not A becomes 10000\\n\\nthen also you would need 2 arrows whether you take out B with A or use 1 arrow for A and 1 for B with the overlapped balloons.\\n\\nIf you take out B with A then the remaining overlapped balloons will still continue to overlap each other and u can shoot them all using 1 arrow.\\n\\nIn any case you are going to get minimum arrows if you take out all the balloons which overlap a certain balloon with a single arrow\\n\\n# Approach\\nWe need an endpoint which will help in deciding whether the next balloon is overlapped with the current one or not.\\n\\nWe also need balloons to be sorted with respect to endpoint so that we can apply the above operation in sequence and sorting wrt endpoint will guarantee that the next balloon is overlapping the endpoint of the placeholder.\\n\\nSo after sorting, we take first balloon as our placeholder and fire an arrow at its end point, then we check whether the next balloon has its starting point <= the placeholder\\'s ending points\\n\\nif true then the arrow we fired will take it out so we go to the next balloon and check its starting point with the placeholder and so on.\\n\\nif false then we increment our answer and make the new balloon our placeholder and continue.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(), points.end(), [](vector<int>& a, vector<int>& b) -> bool {\\n            return a[1] == b[1] ? a[0] < b[0] : a[1] < b[1];\\n        });\\n\\n        int prev = points[0][1], ans = 1;\\n        for (int i = 1; i < points.size(); i++) {\\n            if (points[i][0] > prev) prev = points[i][1], ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(), points.end(), [](vector<int>& a, vector<int>& b) -> bool {\\n            return a[1] == b[1] ? a[0] < b[0] : a[1] < b[1];\\n        });\\n\\n        int prev = points[0][1], ans = 1;\\n        for (int i = 1; i < points.size(); i++) {\\n            if (points[i][0] > prev) prev = points[i][1], ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002389,
                "title": "c-4-lines-o-n-clean-code",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(), points.end(), [&](vector<int>& a, vector<int>& b) { \\n            return a[1] < b[1];\\n        });\\n        int arrow = 1, currentEnd = points[0][1];\\n        for (auto p: points) if (p[0] > currentEnd) arrow++, currentEnd = p[1];\\n        return arrow;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(), points.end(), [&](vector<int>& a, vector<int>& b) { \\n            return a[1] < b[1];\\n        });\\n        int arrow = 1, currentEnd = points[0][1];\\n        for (auto p: points) if (p[0] > currentEnd) arrow++, currentEnd = p[1];\\n        return arrow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002180,
                "title": "c",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int FindMinArrowShots(int[][] points) {\\n        Array.Sort(points, (x, y) => x[1].CompareTo(y[1]));\\n        int end = points[0][1], cnt = 1;\\n        for (var i = 1; i < points.Length; i++)\\n        {\\n            if (end >= points[i][0]) continue;\\n            cnt++;\\n            end = points[i][1];\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindMinArrowShots(int[][] points) {\\n        Array.Sort(points, (x, y) => x[1].CompareTo(y[1]));\\n        int end = points[0][1], cnt = 1;\\n        for (var i = 1; i < points.Length; i++)\\n        {\\n            if (end >= points[i][0]) continue;\\n            cnt++;\\n            end = points[i][1];\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002169,
                "title": "easy-solution-c-pair-of-vectors",
                "content": "\\n\\n# Approach\\n    first approach is to sort the balloons according to starting x cordinates of all balloons.\\n    Then traversing the sorted data structure and keeping track of the last point and thereby inreasing the numbers of arrows as our answer.\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: used a vector of pairs: O(n), can be done without storing into a vector of pair also.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        vector<pair<int,int>> vp;\\n        for(int i=0;i<points.size();i++){\\n            vp.push_back({points[i][0], points[i][1]});\\n        }\\n\\n        sort(vp.begin(),vp.end());\\n        int ans=1, lp=vp[0].second;\\n        for(auto i:vp){\\n            if(i.first>lp){\\n                ans++;\\n                lp = i.second;\\n            }\\n            lp = min(lp,i.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        vector<pair<int,int>> vp;\\n        for(int i=0;i<points.size();i++){\\n            vp.push_back({points[i][0], points[i][1]});\\n        }\\n\\n        sort(vp.begin(),vp.end());\\n        int ans=1, lp=vp[0].second;\\n        for(auto i:vp){\\n            if(i.first>lp){\\n                ans++;\\n                lp = i.second;\\n            }\\n            lp = min(lp,i.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001974,
                "title": "simple-c-greedy-solution-easy-to-understand-for-beginners",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(),points.end());\\n                 int breakpoint=points[0][1];\\n                 int ans=0;\\n         for(auto it : points){\\n              if(it[0]<=breakpoint){\\n                   breakpoint=min(it[1],breakpoint);\\n              }\\n              else{\\n                  ans++;\\n                  breakpoint=it[1];\\n              }\\n         }\\n         ans++;\\n         return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(),points.end());\\n                 int breakpoint=points[0][1];\\n                 int ans=0;\\n         for(auto it : points){\\n              if(it[0]<=breakpoint){\\n                   breakpoint=min(it[1],breakpoint);\\n              }\\n              else{\\n                  ans++;\\n                  breakpoint=it[1];\\n              }\\n         }\\n         ans++;\\n         return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001841,
                "title": "piece-of-cake-type-sorting-solution",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int findMinArrowShots(vector<vector < int>> &points)\\n        {\\n            sort(points.begin(), points.end());\\n            int start = INT_MIN;\\n            int end = INT_MAX;\\n            int ans = 1;\\n            for (int i = 0; i < points.size(); i++)\\n            {\\n                start = points[i][0];\\n                end = min(points[i][1], end);\\n                if (end < start)\\n                {\\n                    start = points[i][0];\\n                    end = points[i][1];\\n                    ans += 1;\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int findMinArrowShots(vector<vector < int>> &points)\\n        {\\n            sort(points.begin(), points.end());\\n            int start = INT_MIN;\\n            int end = INT_MAX;\\n            int ans = 1;\\n            for (int i = 0; i < points.size(); i++)\\n            {\\n                start = points[i][0];\\n                end = min(points[i][1], end);\\n                if (end < start)\\n                {\\n                    start = points[i][0];\\n                    end = points[i][1];\\n                    ans += 1;\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001773,
                "title": "python-solution-explained-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we sort the Array based on `End Point`, and initialize our `count` to 1 and our `end` to the first elements end.\\nThen we iterate over the sorted aray from the second element.\\nwe will always be shoting the arrow from the end `x = end`.\\nso we check if the element start point is within our bound if it is we dont do nothing.\\n\\nif it is out of our bound we increment our arrow count and change our ind to be the current elements end.\\nFinaly we return the `count`\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        # sort by end point   \\n        points.sort(key = lambda x: x[1])\\n        end = points[0][1]\\n        count = 1\\n        # iterate and count arrows\\n        for s,e in points[1:]:\\n            if s > end:\\n                count += 1\\n                end = e\\n        \\n        return count\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        # sort by end point   \\n        points.sort(key = lambda x: x[1])\\n        end = points[0][1]\\n        count = 1\\n        # iterate and count arrows\\n        for s,e in points[1:]:\\n            if s > end:\\n                count += 1\\n                end = e\\n        \\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001759,
                "title": "merge-intervals-solution-in-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& intervals) {\\n        // merge interval with intersection concept \\n\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> ans;\\n        int i=0;\\n        ans.push_back(intervals[0]);\\n\\n        for(int j=1;j<intervals.size();j++){\\n            vector<int> temp=intervals[j];\\n            if(temp[0]<=ans[i][1]){\\n                ans[i][0]=max(ans[i][0],temp[0]);\\n                ans[i][1]=min(ans[i][1],temp[1]);\\n            }\\n            else {\\n                ans.push_back(temp);\\n                i++;\\n            }\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& intervals) {\\n        // merge interval with intersection concept \\n\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> ans;\\n        int i=0;\\n        ans.push_back(intervals[0]);\\n\\n        for(int j=1;j<intervals.size();j++){\\n            vector<int> temp=intervals[j];\\n            if(temp[0]<=ans[i][1]){\\n                ans[i][0]=max(ans[i][0],temp[0]);\\n                ans[i][1]=min(ans[i][1],temp[1]);\\n            }\\n            else {\\n                ans.push_back(temp);\\n                i++;\\n            }\\n        }\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001573,
                "title": "daily-leetcode-python-3",
                "content": "# Intuition\\nSo, this problem is very similar to list of problems like Railway Station problem. \\nThe Intuition is to sort them on the basis of ending time and then check for overlaps.\\nIf duration overlaps then you dont need an extra arrow to burst it as it can be merged into previous duration but if it doesn\\'t then inc the count of arrow.\\n\\n\\n# Complexity\\n- Time complexity: O(n logn)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        #sort on the basis of ending time\\n        points = sorted(points, key=lambda x: x[1])\\n        currPointer = points[0][1]\\n        arrows = 1\\n\\n        for i in range(len(points)):\\n            if points[i][0] > currPointer: #if start of i > last pointer pointing at\\n                currPointer = points[i][1]\\n                arrows += 1\\n        return arrows\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        #sort on the basis of ending time\\n        points = sorted(points, key=lambda x: x[1])\\n        currPointer = points[0][1]\\n        arrows = 1\\n\\n        for i in range(len(points)):\\n            if points[i][0] > currPointer: #if start of i > last pointer pointing at\\n                currPointer = points[i][1]\\n                arrows += 1\\n        return arrows\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001483,
                "title": "o-log-n-tc-beats-100-simple-easy-with-explanation-and-intuition-for-beginners-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs it has a startinf point and ending point . \\nFirst thought is Greedy approach (mostly in such type of qs)\\nAs if we put the arrow in common position ashre the no of arrows will be min so it can be solved like Merge Interval q \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n(i) Sort the segments by the end\\n(ii) Put an arrow at the end of the 1-st segment\\n(iii)From the 2-nd segment, we check whether the current arrow pass through the current segment, if not add an arrow, put it at the end of the current segment\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nbool cmp ( vector<int> &a, vector<int>&b ){\\n        return a[1]<b[1];\\n    }\\nclass Solution {   \\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(), points.end(),cmp);\\n        int mid = points[0][1];\\n        int ans = 1;\\n        for(int i =1; i<points.size(); i++){\\n            if(mid<points[i][0]){\\n                ans++;\\n                mid = points[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nbool cmp ( vector<int> &a, vector<int>&b ){\\n        return a[1]<b[1];\\n    }\\nclass Solution {   \\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(), points.end(),cmp);\\n        int mid = points[0][1];\\n        int ans = 1;\\n        for(int i =1; i<points.size(); i++){\\n            if(mid<points[i][0]){\\n                ans++;\\n                mid = points[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001339,
                "title": "java-solution-optimized-greedy-approach-intersection-method",
                "content": "# Intuition\\nIf we observe the inputs carefully, we can see that if we arrange the points in sorted order based on the ending position, we can make sure that all the balloons having starting position lesser than the ending position can be burst in one shot. Please look into the image below.\\n![image.png](https://assets.leetcode.com/users/images/ed78dc4b-3141-42c6-822e-a1f0943c4b0a_1672897902.5367217.png)\\n\\n\\n# Approach\\n- check for edge cases always\\n- intialize the integer variables countArrows and prevIndex to keep track of the values\\n- sort the points based on the ending positions\\n- iterate over the points and check whether the starting position is exceeding the previous ending position\\n- return countArrows\\n\\n# Complexity\\n- Time complexity: O(N), where N is the length of points array\\n\\n- Space complexity: O(1) as only using the constant space\\n\\n**Please Upvote If this solution helps you to learn something. Thanks in advance.**\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        // edge cases\\n        if(points == null || points.length == 0){\\n            return 0;\\n        }\\n\\n        // intialization\\n        int countArrows = 0;\\n        int prevIndex = 0;\\n\\n        // sort the points based on the ending position\\n        Arrays.sort(points, (a, b)->(Integer.compare(a[1], b[1])));\\n\\n        // iterate over the points\\n        for(int index = 0;index < points.length;index++){\\n            // when initially countArrows is zero or\\n            // starting position of current balloon is greater\\n            // than the ending position of the previous group\\n            if(countArrows == 0 || points[index][0] > points[prevIndex][1]){\\n                countArrows++;\\n                prevIndex = index;\\n            }\\n        }\\n\\n        return countArrows;\\n    }\\n}\\n\\n\\n```\\n\\n**Please Upvote If this solution helps you to learn something. Thanks in advance.**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        // edge cases\\n        if(points == null || points.length == 0){\\n            return 0;\\n        }\\n\\n        // intialization\\n        int countArrows = 0;\\n        int prevIndex = 0;\\n\\n        // sort the points based on the ending position\\n        Arrays.sort(points, (a, b)->(Integer.compare(a[1], b[1])));\\n\\n        // iterate over the points\\n        for(int index = 0;index < points.length;index++){\\n            // when initially countArrows is zero or\\n            // starting position of current balloon is greater\\n            // than the ending position of the previous group\\n            if(countArrows == 0 || points[index][0] > points[prevIndex][1]){\\n                countArrows++;\\n                prevIndex = index;\\n            }\\n        }\\n\\n        return countArrows;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001305,
                "title": "new-approach-for-interview-purpose-using-stack-and-comparable-interface-java",
                "content": "```\\nclass Solution {\\n    class Pair implements Comparable<Pair>\\n    {\\n        Integer x;\\n        Integer y;\\n        Pair(int x,int y)\\n        {\\n            this.x=x;\\n            this.y=y;\\n        }\\n        \\n        public int compareTo(Pair obj)\\n        {\\n            return this.x.compareTo(obj.x);\\n        }\\n        \\n    }\\n    public int findMinArrowShots(int[][] points) \\n    {\\n     \\n        ArrayList<Pair> al=new ArrayList<>();\\n        for(int i=0;i<points.length;i++)\\n        {\\n          al.add(new Pair(points[i][0],points[i][1]));  \\n        }\\n        Collections.sort(al);\\n        for(int i=0;i<points.length;i++)\\n        {\\n          // System.out.println(al.get(i).x+\" \"+al.get(i).y);  \\n        }\\n        Stack<Pair> st=new Stack<>();\\n        st.push(al.get(0));\\n        // int ans=1;\\n        for(int i=1;i<al.size();i++)\\n        {\\n            if(al.get(i).x<=st.peek().y)\\n            {\\n               int x1=Math.max(st.peek().x,al.get(i).x);\\n               int y1=Math.min(st.peek().y,al.get(i).y);\\n                st.pop();\\n                st.push(new Pair(x1,y1));\\n            }\\n            else\\n            {\\n                st.push(al.get(i));\\n            }\\n        }\\n        return st.size();\\n        \\n       \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    class Pair implements Comparable<Pair>\\n    {\\n        Integer x;\\n        Integer y;\\n        Pair(int x,int y)\\n        {\\n            this.x=x;\\n            this.y=y;\\n        }\\n        \\n        public int compareTo(Pair obj)\\n        {\\n            return this.x.compareTo(obj.x);\\n        }\\n        \\n    }\\n    public int findMinArrowShots(int[][] points) \\n    {\\n     \\n        ArrayList<Pair> al=new ArrayList<>();\\n        for(int i=0;i<points.length;i++)\\n        {\\n          al.add(new Pair(points[i][0],points[i][1]));  \\n        }\\n        Collections.sort(al);\\n        for(int i=0;i<points.length;i++)\\n        {\\n          // System.out.println(al.get(i).x+\" \"+al.get(i).y);  \\n        }\\n        Stack<Pair> st=new Stack<>();\\n        st.push(al.get(0));\\n        // int ans=1;\\n        for(int i=1;i<al.size();i++)\\n        {\\n            if(al.get(i).x<=st.peek().y)\\n            {\\n               int x1=Math.max(st.peek().x,al.get(i).x);\\n               int y1=Math.min(st.peek().y,al.get(i).y);\\n                st.pop();\\n                st.push(new Pair(x1,y1));\\n            }\\n            else\\n            {\\n                st.push(al.get(i));\\n            }\\n        }\\n        return st.size();\\n        \\n       \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001168,
                "title": "simple-solution-detailed-comments",
                "content": "# Intuition\\nFirst sort, then observe each range (Element in list)\\n\\n# Approach\\nKeep restricting bursted baloon range, if new point out of range then set new range and use a new arrow, otherwise restrict the previous range.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n. Log(n))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nbool comprtr(vector<int>& a, vector<int>& b)\\n{\\n    return (a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]));\\n}\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(), points.end(), comprtr);\\n\\n        int n = points.size();\\n        int count = 1;\\n        int burstedFrom = points[0][0];\\n        int burstedUpto = points[0][1];\\n\\n        for(int i = 1; i<n; i++)\\n        {\\n            if(points[i][0] > burstedUpto) // not in range, new arrow required\\n            {\\n                count++;\\n                burstedFrom = points[i][0];\\n                burstedUpto = points[i][1];\\n            }else{          // old arrow utilized.. both ranges restricted\\n                burstedFrom = points[i][0];\\n                burstedUpto = min(points[i][1], burstedUpto); // two diff cases here, setting 6-7 in 1-10 makes burstedUpto as \\n                                                                //7 vs 8-12 in 1-10 makes burstedUpto as 10\\n            }  \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool comprtr(vector<int>& a, vector<int>& b)\\n{\\n    return (a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]));\\n}\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(), points.end(), comprtr);\\n\\n        int n = points.size();\\n        int count = 1;\\n        int burstedFrom = points[0][0];\\n        int burstedUpto = points[0][1];\\n\\n        for(int i = 1; i<n; i++)\\n        {\\n            if(points[i][0] > burstedUpto) // not in range, new arrow required\\n            {\\n                count++;\\n                burstedFrom = points[i][0];\\n                burstedUpto = points[i][1];\\n            }else{          // old arrow utilized.. both ranges restricted\\n                burstedFrom = points[i][0];\\n                burstedUpto = min(points[i][1], burstedUpto); // two diff cases here, setting 6-7 in 1-10 makes burstedUpto as \\n                                                                //7 vs 8-12 in 1-10 makes burstedUpto as 10\\n            }  \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001037,
                "title": "easy-explained-c-solution-using-stack-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsort and check intersection points.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. first of all sort the points matrix.\\n2. store all points in stack in form end of sorted ponts matrix.\\n3. make count, temp variable and make while loop and start poping pair store in staack. and update temp and increment count variables.\\n4. return count.\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n\\n        sort(points.begin(),points.end());\\n\\n        stack<pair<int,int>>s;\\n        for(int i=points.size()-1;i>=0;i--)\\n        {\\n           s.push({points[i][0],points[i][1]});\\n        }\\n      \\n        int count=1;\\n        int temp=s.top().second;\\n        s.pop();\\n        while(!s.empty())\\n        {  if( s.top().first<=temp)  \\n                {\\n                    while(!s.empty() && s.top().first<=temp)\\n                   { \\n                      temp=min(temp,s.top().second);\\n                       s.pop();\\n                   }\\n\\n                }\\n            else{\\n                temp=s.top().second;\\n                s.pop();\\n\\n                count++;\\n            }    \\n                 \\n\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n\\n        sort(points.begin(),points.end());\\n\\n        stack<pair<int,int>>s;\\n        for(int i=points.size()-1;i>=0;i--)\\n        {\\n           s.push({points[i][0],points[i][1]});\\n        }\\n      \\n        int count=1;\\n        int temp=s.top().second;\\n        s.pop();\\n        while(!s.empty())\\n        {  if( s.top().first<=temp)  \\n                {\\n                    while(!s.empty() && s.top().first<=temp)\\n                   { \\n                      temp=min(temp,s.top().second);\\n                       s.pop();\\n                   }\\n\\n                }\\n            else{\\n                temp=s.top().second;\\n                s.pop();\\n\\n                count++;\\n            }    \\n                 \\n\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001026,
                "title": "c-easy-solution",
                "content": "# Intuition\\nIntution behind this question is just find intersecting pair so we can brust a balloon by one arrow.\\n\\n# Approach\\nApproch of this Question is iterate over all pair and check next pair is intersecting to previous pair or not if that pair is intersect to previous pair so include that pair and after go for next pair and continue this process untill you find non intersecting pair and when you find non intersecting pair just increment count of arrows and begin a new process for that pair.\\n\\n# Complexity\\n- Time complexity:\\nO(NLogN) N is size of array\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstatic bool comparator(vector<int> &a,vector<int> &b)\\n{\\n    if(a[0]<b[0])return 1;\\n    else if(a[0]==b[0])\\n    {\\n        return a[1]<b[1];\\n       \\n    }\\n    return 0;\\n} \\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        int n=points.size();\\n        int m=points[0].size();\\n        sort(points.begin(),points.end(),comparator);\\n        int i=0;\\n        int count=0;\\n        int start=-1;\\n        int end=-1;\\n        while(i<n)\\n        {\\n//new Process is start\\n            if(start==-1&&end==-1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart=points[i][0];\\n\\t\\t\\t\\tend=points[i][1];\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n//when you find intersecting pair just include that and go for next pair\\n\\t\\t\\telse if(end>=points[i][0])\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart=points[i][0];\\n\\t\\t\\t\\tif(end>points[i][1])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tend=points[i][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n//when you find non intersecting pair just increment count and start new process.\\n\\t\\t\\telse if(end<points[i][0])\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart=-1;\\n\\t\\t\\t\\tend=-1;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n        }\\n//this is when we exit a loop end some balloon is remaining for brust so we need a one arrow for that\\n        if(start!=-1&&end!=-1)count++;\\n        return count;\\n        \\n    }\\n};\\n\\n```\\nIf you think this is beneficial for you please upvote.\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstatic bool comparator(vector<int> &a,vector<int> &b)\\n{\\n    if(a[0]<b[0])return 1;\\n    else if(a[0]==b[0])\\n    {\\n        return a[1]<b[1];\\n       \\n    }\\n    return 0;\\n} \\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        int n=points.size();\\n        int m=points[0].size();\\n        sort(points.begin(),points.end(),comparator);\\n        int i=0;\\n        int count=0;\\n        int start=-1;\\n        int end=-1;\\n        while(i<n)\\n        {\\n//new Process is start\\n            if(start==-1&&end==-1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart=points[i][0];\\n\\t\\t\\t\\tend=points[i][1];\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n//when you find intersecting pair just include that and go for next pair\\n\\t\\t\\telse if(end>=points[i][0])\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart=points[i][0];\\n\\t\\t\\t\\tif(end>points[i][1])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tend=points[i][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n//when you find non intersecting pair just increment count and start new process.\\n\\t\\t\\telse if(end<points[i][0])\\n\\t\\t\\t{\\n\\t\\t\\t\\tstart=-1;\\n\\t\\t\\t\\tend=-1;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n        }\\n//this is when we exit a loop end some balloon is remaining for brust so we need a one arrow for that\\n        if(start!=-1&&end!=-1)count++;\\n        return count;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001020,
                "title": "c-easy-to-understand-greedy-approach",
                "content": "# Intuition\\n1. Maintain the intersecting area covered by balloons while iterating the balloons\\n\\n2. If current balloon has no intersecting area with previous common area then increase asnwer and the current balloon area will be the new intersecting area\\n\\n- Eg: current common area = [2,6]\\nCurrent balloon area = [3,7] , then common area = intersecting area = [3,6]\\n\\n- Eg: current common area = [2,6]\\nCurrent balloon area = [7,9] , then new common area = [7,9] and increase the answer by 1 \\n# Approach\\n1. Sort all balloons to get start points in ascending order(start points will be sorted first and if start points are equal , then end points will be sorted) \\n\\n2. Check current intersecting area endpoint with current balloon area startpoint .\\n- If $$(xstart)curr$$ <=$$(xend)common$$ then areas are intersecting\\n\\n- else we need 1 more arrow to burst this balloon and intersecting area will be the current balloon area\\n\\n(Initial answer is set to 1 as we need a minimum of 1 arrow to burst a balloon and initial area is taken as area of first balloon)\\n\\n\\n# Complexity\\n- Time complexity : $$O(nlogn)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) \\n    {\\n        sort(points.begin(),points.end());\\n\\n        int n=points.size() , ans=1;\\n        auto curr=points[0];\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            if(points[i][0]>curr[1]) \\n            {\\n                curr=points[i] ;\\n                ans++;\\n            }\\n            else \\n            {\\n                curr[0]=max(curr[0],points[i][0]);\\n                curr[1]=min(curr[1],points[i][1]); \\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) \\n    {\\n        sort(points.begin(),points.end());\\n\\n        int n=points.size() , ans=1;\\n        auto curr=points[0];\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            if(points[i][0]>curr[1]) \\n            {\\n                curr=points[i] ;\\n                ans++;\\n            }\\n            else \\n            {\\n                curr[0]=max(curr[0],points[i][0]);\\n                curr[1]=min(curr[1],points[i][1]); \\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000957,
                "title": "python-overlapping-easy-and-simple-solution",
                "content": "# Please Upvote \\u2B06\\uFE0F if you like the solution \\uD83D\\uDE4F\\n\\n# Intuition\\nOverlapping Interval\\n\\n# Approach\\nUntil current x overlap with prev y, keep prev y to compare same.\\n\\n# Complexity\\n- Time complexity: O(NLogN)\\n\\n- Space complexity: O(LogN) assuming internally quick sort is used. And recusion used in quick sort uses logN space.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findMinArrowShots(self, points):\\n        if not points:\\n            return 0\\n        points.sort(key=lambda p: p[1])\\n        arrows = 1\\n\\n        comparision_y_to_check_if_overlapping = points[0][1]\\n        for x,y in points[1:]:\\n            if x > comparision_y_to_check_if_overlapping:\\n                arrows +=1\\n                comparision_y_to_check_if_overlapping = y\\n\\n        return arrows\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution(object):\\n    def findMinArrowShots(self, points):\\n        if not points:\\n            return 0\\n        points.sort(key=lambda p: p[1])\\n        arrows = 1\\n\\n        comparision_y_to_check_if_overlapping = points[0][1]\\n        for x,y in points[1:]:\\n            if x > comparision_y_to_check_if_overlapping:\\n                arrows +=1\\n                comparision_y_to_check_if_overlapping = y\\n\\n        return arrows\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000921,
                "title": "daily-leetcode-challenge-day-5-easiest-java-solution",
                "content": "# Approach\\n1. First, check if the size of the input array points is 1. If it is, return 1 since only one balloon needs to be shot.\\n2. Sort the array points based on the second element of each subarray\\n3. Initialize a variable count to 1 and a variable prevElement to the second element of the first subarray of points.\\n4. Iterate through the points array starting from the second element. For each iteration:\\n    - If prevElement is greater than or equal to the first element of the current subarray, continue to the next iteration.\\n    - Otherwise, increment count by 1 and set prevElement to the second element of the current subarray.  \\n1. Return count.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: **O(nlogn)**  // where n is the size of vector\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java Code\\n```\\nclass Solution {\\n    public static int sortCol(int[] v1, int[] v2) {\\n        return v1[1] - v2[1];\\n    }\\n\\n    public int findMinArrowShots(int[][] points) {\\n        if(points.length == 1)\\n            return 1;\\n        int row = points.length;\\n        int count = 1;\\n        Arrays.sort(points, Comparator.comparingInt(v -> v[1]));\\n        int prevElement = points[0][1];\\n        for(int i = 1; i < row; i++){\\n            if(prevElement >= points[i][0]){\\n                continue;\\n            }\\n            else{ \\n                count++;\\n                prevElement = points[i][1];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public static int sortCol(int[] v1, int[] v2) {\\n        return v1[1] - v2[1];\\n    }\\n\\n    public int findMinArrowShots(int[][] points) {\\n        if(points.length == 1)\\n            return 1;\\n        int row = points.length;\\n        int count = 1;\\n        Arrays.sort(points, Comparator.comparingInt(v -> v[1]));\\n        int prevElement = points[0][1];\\n        for(int i = 1; i < row; i++){\\n            if(prevElement >= points[i][0]){\\n                continue;\\n            }\\n            else{ \\n                count++;\\n                prevElement = points[i][1];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000891,
                "title": "javascript-easy-solution-tc-o-nlogn-sc-o-1",
                "content": "# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar findMinArrowShots = function(points) {\\n    points.sort((a,b)=> (a[1]-b[1] || a[0]-b[0]));\\n\\n    let arrow = points.length;\\n\\n    for(let i=1,  p = 0;i<points.length; i++){\\n        if(p === i) continue;\\n        if(points[i][1] >= points[p][1] &&  \\n            points[p][1] >= points[i][0]){\\n            arrow--\\n        }else{\\n            p = i\\n        }\\n    }\\n    \\n\\n    return arrow;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @return {number}\\n */\\nvar findMinArrowShots = function(points) {\\n    points.sort((a,b)=> (a[1]-b[1] || a[0]-b[0]));\\n\\n    let arrow = points.length;\\n\\n    for(let i=1,  p = 0;i<points.length; i++){\\n        if(p === i) continue;\\n        if(points[i][1] >= points[p][1] &&  \\n            points[p][1] >= points[i][0]){\\n            arrow--\\n        }else{\\n            p = i\\n        }\\n    }\\n    \\n\\n    return arrow;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3000787,
                "title": "multimap-c-easy",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize the counter at 1, as the minimum answer is 1, and use multimap to sort and map the points. Take xmax=the first element of the first point on the map and xmin=the second element of the first point on the map for the first check.\\n\\nIterate through all the pairs and check if xmax >= the first element of the pair (checking for overlap); if so, put the minimum value of the second element of the pair and previous xmax; for xmin, put the maximum value of the first element of the pair and previous xmin.\\n\\n\\nIf the points do not satisfy the overlapping condition, initialise xmax as the first element of the pair and xmin as the second element of the pair. Do it for the rest and return the result.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        int n=points.size();\\n        multimap<int,int>mp;\\n        for(auto it:points){\\n            mp.insert({it[0],it[1]});\\n        }\\n        auto a=mp.begin();a++;\\n        int xmin=(mp.begin())->first,xmax=(mp.begin())->second,c=1;\\n        for(a;a!=mp.end();a++){\\n            if(a->first<=xmax){\\n                xmax=min(a->second,xmax);\\n                xmin=max(a->first,xmin);\\n            }\\n            else{\\n                c++;\\n                xmax=a->second;\\n                xmin=a->first;\\n            }\\n        }\\n        return c;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        int n=points.size();\\n        multimap<int,int>mp;\\n        for(auto it:points){\\n            mp.insert({it[0],it[1]});\\n        }\\n        auto a=mp.begin();a++;\\n        int xmin=(mp.begin())->first,xmax=(mp.begin())->second,c=1;\\n        for(a;a!=mp.end();a++){\\n            if(a->first<=xmax){\\n                xmax=min(a->second,xmax);\\n                xmin=max(a->first,xmin);\\n            }\\n            else{\\n                c++;\\n                xmax=a->second;\\n                xmin=a->first;\\n            }\\n        }\\n        return c;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000763,
                "title": "easy-short-beginner-friendly-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(), points.end());\\n        int lastpoint = points[0][1];\\n        int ans = 1;\\n        for(auto point : points) {\\n            if(point[0] > lastpoint) {\\n                ans++;\\n                lastpoint = point[1];\\n            }\\n            lastpoint = min(point[1],lastpoint);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(), points.end());\\n        int lastpoint = points[0][1];\\n        int ans = 1;\\n        for(auto point : points) {\\n            if(point[0] > lastpoint) {\\n                ans++;\\n                lastpoint = point[1];\\n            }\\n            lastpoint = min(point[1],lastpoint);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000675,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: Nlog(N) for sorting and O(N) for traversal\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) constant space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        int ans=0;\\n        sort(points.begin(),points.end());\\n        int s=points[0][0],e=points[0][1]; // length of intersection that will be common(s,e) in intervals(ballons burst by one arrow)\\n        for(int i=1; i<points.size(); i++){\\n            // if current interval overlap, update intersection(s,e), only contain interval common in both prev and current\\n            // continue until we get non overlapping interval\\n            if(points[i][0]<=e){\\n                s=points[i][0];\\n                e=min(e,points[i][1]);\\n            }\\n            // once we reach non-overlapping interval, we add 1 in ans(means before current interval all ballons can burst by 1 arrow)\\n            else{\\n                ans++;\\n                s=points[i][0];\\n                e=points[i][1];\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        int ans=0;\\n        sort(points.begin(),points.end());\\n        int s=points[0][0],e=points[0][1]; // length of intersection that will be common(s,e) in intervals(ballons burst by one arrow)\\n        for(int i=1; i<points.size(); i++){\\n            // if current interval overlap, update intersection(s,e), only contain interval common in both prev and current\\n            // continue until we get non overlapping interval\\n            if(points[i][0]<=e){\\n                s=points[i][0];\\n                e=min(e,points[i][1]);\\n            }\\n            // once we reach non-overlapping interval, we add 1 in ans(means before current interval all ballons can burst by 1 arrow)\\n            else{\\n                ans++;\\n                s=points[i][0];\\n                e=points[i][1];\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000560,
                "title": "cpp-solution-sorting-greedy-easyyyyy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n  Overlapping problems !\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n  Sorting and greedy :)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  O(nlogn)  here because of sorting !\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n  O(1)\\n\\n# Code\\n```\\n// this function for sorting\\n bool comp(vector<int>&a,vector<int>&b){\\n                return a[1]<b[1];\\n           }\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        //if(points.size()==0)return 0;\\n        sort(points.begin(),points.end(),comp);\\n        int arrows=0;\\n        int end=points[0][1];\\n\\n        for(int i=1;i<points.size();i++){\\n            if(end<points[i][0]){\\n                arrows++;\\n                end=points[i][1];\\n            }\\n        }\\n        return arrows+1;\\n    }\\n};\\n\\n//An UPVOTE will be encouraging :)\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\n// this function for sorting\\n bool comp(vector<int>&a,vector<int>&b){\\n                return a[1]<b[1];\\n           }\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        //if(points.size()==0)return 0;\\n        sort(points.begin(),points.end(),comp);\\n        int arrows=0;\\n        int end=points[0][1];\\n\\n        for(int i=1;i<points.size();i++){\\n            if(end<points[i][0]){\\n                arrows++;\\n                end=points[i][1];\\n            }\\n        }\\n        return arrows+1;\\n    }\\n};\\n\\n//An UPVOTE will be encouraging :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000397,
                "title": "js-intuitive-and-easy",
                "content": "# Complexity\\n- Time complexity:\\nO(n log n)  due to sort\\n\\n- Space complexity:\\nO(n)\\n\\nVery straight forward, please upvote if you found this is helpful.\\n\\n# Code\\n```\\nvar findMinArrowShots = function (points) {\\n// Sort based on the end of each interval.\\n  let arrow = 1,arr = points.sort((a, b) => a[1] - b[1]),end = arr[0][1];\\n// If the next interval is inside the previous one, skip. \\n// Otherwise, no overlapping, arrow needs to increase by 1, and extend the end.\\n  for (let balloon of arr) {\\n    if (balloon[0] > end) {\\n      arrow++;\\n      end = balloon[1];\\n    }\\n  }\\n  return arrow;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findMinArrowShots = function (points) {\\n// Sort based on the end of each interval.\\n  let arrow = 1,arr = points.sort((a, b) => a[1] - b[1]),end = arr[0][1];\\n// If the next interval is inside the previous one, skip. \\n// Otherwise, no overlapping, arrow needs to increase by 1, and extend the end.\\n  for (let balloon of arr) {\\n    if (balloon[0] > end) {\\n      arrow++;\\n      end = balloon[1];\\n    }\\n  }\\n  return arrow;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3000343,
                "title": "minimum-number-of-arrows-to-burst-balloons-c-solution-o-nlogn",
                "content": "\\n# Please upvote if you like my solution .\\n# Code\\n```\\nbool cmp(vector<int>& a, vector<int>& b) {return a[1] < b[1];}\\nclass Solution {\\npublic:  \\n    int findMinArrowShots(vector<vector<int>>& segments) {\\n        sort(segments.begin(), segments.end(), cmp);\\n        int ans = 0, arrow = 0;\\n        for (int i = 0; i < segments.size(); i ++) {\\n            if (ans == 0 || segments[i][0] > arrow) {\\n                ans ++;\\n                arrow = segments[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes.\\nLet me know in comment if i can do better.\\nLets connect on Linkedin https://www.linkedin.com/in/kailas-rathod/",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nbool cmp(vector<int>& a, vector<int>& b) {return a[1] < b[1];}\\nclass Solution {\\npublic:  \\n    int findMinArrowShots(vector<vector<int>>& segments) {\\n        sort(segments.begin(), segments.end(), cmp);\\n        int ans = 0, arrow = 0;\\n        for (int i = 0; i < segments.size(); i ++) {\\n            if (ans == 0 || segments[i][0] > arrow) {\\n                ans ++;\\n                arrow = segments[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621881,
                "title": "simple-sol-for-simp",
                "content": "```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        int res=0, n=points.length; Integer prevEnd=null;\\n        Arrays.sort(points,(a,b)->(a[0]<b[0])?-1:1);\\n        for(int[] point: points){\\n            if(prevEnd==null || prevEnd<point[0]){\\n                res++;\\n                prevEnd=point[1];\\n            }else prevEnd=Math.min(prevEnd,point[1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        int res=0, n=points.length; Integer prevEnd=null;\\n        Arrays.sort(points,(a,b)->(a[0]<b[0])?-1:1);\\n        for(int[] point: points){\\n            if(prevEnd==null || prevEnd<point[0]){\\n                res++;\\n                prevEnd=point[1];\\n            }else prevEnd=Math.min(prevEnd,point[1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2149772,
                "title": "java-solution-easy",
                "content": "```\\n\\n\\nclass Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        // greedy method --> activity selection method\\n        // sorting according to their end time\\n        if(points.length==0) return 0;\\n        Arrays.sort(points,(a,b) -> Integer.compare(a[1],b[1]));\\n        int res =1, prev = points[0][1];\\n        for(int i = 1 ;i< points.length;i++){\\n            if(points[i][0]>prev){\\n                res++;\\n                prev=points[i][1];\\n            }\\n        }\\n        return res;\\n   \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findMinArrowShots(int[][] points) {\\n        // greedy method --> activity selection method\\n        // sorting according to their end time\\n        if(points.length==0) return 0;\\n        Arrays.sort(points,(a,b) -> Integer.compare(a[1],b[1]));\\n        int res =1, prev = points[0][1];\\n        for(int i = 1 ;i< points.length;i++){\\n            if(points[i][0]>prev){\\n                res++;\\n                prev=points[i][1];\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564712,
                "content": [
                    {
                        "username": "wateryan17",
                        "content": "Apparently a new test case has been added recently. If you cannot pass this one, then it is because the result of subtraction is too large and thus the overflow is encountered. So don\\'t use `a-b` to compare when sorting. Use `Integer.compare(a,b)` instead!!!"
                    },
                    {
                        "username": "AJReach",
                        "content": "Thanks"
                    },
                    {
                        "username": "dmproni",
                        "content": "even better for Java use Comparator.comparingInt() for clarity :)"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Thanks a lot mate! Great observation! I had this exact problem!"
                    },
                    {
                        "username": "serkora",
                        "content": "[@nikhilsteamid](/nikhilsteamid) Just plain std::sort(v.begin(), v.end()) is enough, it handles sorting of 2D vectors by default, so no need to provide your own. (And you can also use templated STL comparison functions such as std::greater<std::vector<int>>() if you need a different order.)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You can use the below code in java. a-b is still working for sorting.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three cases. but yah for making short and neat code we should use either  Integer.compare(a,b) or lamda function.\\n//code\\n Arrays.sort(arr,new Comparator<int[]>(){\\n            public int compare(int[] a1,int[] a2){\\n               //  return Integer.compare(a1[0],a2[0]); \\n               if(a1[0]>a2[0]) return 1;\\n               else if(a1[0]<a2[0]) return -1;\\n               else return 0;\\n            }\\n        });"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "[@nikhilsteamid](/nikhilsteamid)  u can use lambda function to sort the array in c++\\n"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "what is the c++ alternative?"
                    },
                    {
                        "username": "carloseddy397",
                        "content": "`\\u201CLet me take a break of 5 minutes to browse the internet.\\u201D That\\u2019s how it starts. An hour later, you are still browsing.`"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Replying after exactly 1 year mate !\\nAnniversary of your comment \\uD83D\\uDC95\\uD83E\\uDD23"
                    },
                    {
                        "username": "S_Basu",
                        "content": "true"
                    },
                    {
                        "username": "mkohar",
                        "content": "Try using **Stay Focusd** chrome extension"
                    },
                    {
                        "username": "shanks21",
                        "content": "it\\'s like all of us are leading exact same lives"
                    },
                    {
                        "username": "choi_taek",
                        "content": "programming is 1% intelligence and 99% trying not  to get distracted by internet.\\nYou can try this extension pluckeye. Its great. "
                    },
                    {
                        "username": "vaibhavbhardwaj1987",
                        "content": "![image](https://assets.leetcode.com/users/images/743abf3b-788a-4da7-b576-f043cefe87c0_1603097643.8374152.png)\\n"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@srirambadalgama](/srirambadalgama) No it will give 2 only..\\nas first start will be 3\\nand then 4<=3 false...so count = 2 and now start = 5\\n1<=5 true \\nso result will be 2"
                    },
                    {
                        "username": "srirambadalgama",
                        "content": "I think your solution will give wrong answer for test case: [[1,10],[2,3],[4,5]].\\ncorrect ans is 2. But your soln will give 1."
                    },
                    {
                        "username": "khushimattu",
                        "content": "i have a small doubt. we are checking whether the xend of start is greater than the x start of the next one or not but we arent checking the condition if that is greater than the x ed of the next one?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I didn\\'t visualize the problem like this. It seems so simple now :)"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Nice observation bro, I just sorted and used stack to find overlaps like a dummy. Anyways, here is my dum-dum solution, Its beginner friendly and more intuitive I guess :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "[@Sledge_man](/Sledge_man) same question"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "So brilliant, I like the observation. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@bean_bean](/bean_bean) savage"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "[@Sledge_man](/Sledge_man) Nope, it has to go straight up"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "you are supposed to shoot the arrow vertically up. which means parallel to the y axis. "
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Enough guys, focus on the problem...  😁🧐"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Nice hair growth\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@yl245](/yl245) why do you focus on this? \\uD83D\\uDE02"
                    },
                    {
                        "username": "Sledge_man",
                        "content": "isnt the arrow supposed to go vertically up?\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "could\\'ve cropped out those hairy legs \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Description is really stupid.\n\"spherical balloon\" is a 3D object. If you know only single coordinate of each ballon on some plane then there is many configurations.\nI always try to solve problem by my self. I did over 700 but this one is really poorly stated.\nAfter looking at official solution and the image there it turns to be really simple (just intervals on a 1D).\n[@LeetCode](/LeetCode) plese add this image to the problem descrition.\n\n![image](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/288049/Figures/452/arrows.png)\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It is a bit pedantic to complain about them using \"sphere\" rather than \"circle\", and then propose an image where you drew \"ellipses\". I'm sure if they had put that image in the statement, there would have been comments like yours calling the question \"really stupid\" for being misleading.\n\nThey clarified explicitly that everything takes place in a 2D plane, so I don't think there's much confusion about whether we should consider the problem 3D, but I agree that a similar illustration would be nice add"
                    },
                    {
                        "username": "trsuhas21",
                        "content": "Tq for elucidating "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) I agree with you, I have posted in a comment that the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!! Even with baloons and stuff, arrow is a stupid analogy since it just passes a point in 2D plain. Better could have been a knife that is cutting sausages that are overlapping on x axis (the only axis).\\n\\nI would Ignore what calm27 is saying since that roughly translates to \"we should accept everything as is, and not give any constructive feedback\"."
                    },
                    {
                        "username": "calm27",
                        "content": "> I always try to solve problem by my self\n\nyou said it like other folks do otherwise to prove your assumption that wording is bad. \n\nmajor part solves it by themselves. no one like bad wording in descriptions, but we should accept the fact it is an initial part of the problem, and the purpose of it is to \"figure out\". \nlife would be easy if all problems were clear. "
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TIP: For `C++`, the input of annonymous compare function shold be reference, or you will get TLE."
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks, was stuck because of it for a while"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "[@kriket](/kriket) Definitely. Copying is always slower, I was just surprised that it will cause such a big difference in sorting."
                    },
                    {
                        "username": "close27",
                        "content": "I think it\\'s because pass by ref does not make new copies hence it is faster."
                    },
                    {
                        "username": "close27",
                        "content": "[@MC_JRen](/MC_JRen)Did run into the problem. Can you please explain how you figured it out?"
                    },
                    {
                        "username": "L39ND",
                        "content": "thats exactly what I need, thank you so much! "
                    },
                    {
                        "username": "Kis_shot",
                        "content": "thank you so much!!!it confused me a lot until i put \"&\" to pass through"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\\n\\nWe can understand by using an example:\\n\\nGiven an 2d array of size 4 with  [10,16] , [2,8] , [1,6] , [7,12]\\n\\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\\n\\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\\n\\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\\n\\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\\n\\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\\n\\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\\n\\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\\n\\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\\n\\nAt last, return the arrow counter.\\n\\nSolution link for better understanding: [https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest)\\n\\nI hope it helps ^_^"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Very clean solution!"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "wow, I used similar theory but I used stack for replacing two balloons with their overlap instead. Here is a better written solution :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "mausami",
                        "content": "Take care of the following test cases while sorting the array:\\n1. []\\n2. [[1,2],[2,3],[3,4],[4,5]]\\n3. [[-2147483646,-2147483645],[2147483646,2147483647]]\\n4. [[10,16],[2,8],[1,6],[7,12]]\\n5. [[1,2],[3,4],[5,6],[7,8]]\\n6. [[1,2]]\\n7. [[2,3],[2,3]]\\n"
                    },
                    {
                        "username": "dvakar",
                        "content": "8. [[77171087,133597895],[45117276,135064454],[80695788,90089372],[91705403,110208054],[52392754,127005153],[53999932,118094992],[11549676,55543044],[43947739,128157751],[55636226,105334812],[69348094,125645633]]"
                    },
                    {
                        "username": "srbssv",
                        "content": "What should we return in case of [[-2147483646,-2147483645],[2147483646,2147483647]]?"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "HUH, Interesting, Funny I didnt find any of these because my stack solution handled them all ok I guess. Here it is:: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "aditisingh10022018",
                        "content": "my test case is also failing at 3rd test case why?"
                    },
                    {
                        "username": "tajnur",
                        "content": "According to the constraints, empty points is not valid. Points should have at least one element..\\n"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "also, [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] "
                    },
                    {
                        "username": "santanusen",
                        "content": "It would have taken me hours to solve such problems a few months back. I was able to solve it in 15 mins today thanks to daily leetcoding. Leetcode definitely helps.\\n\\nTip:\\nsort the points, track how many consecutive points intersect (keep tracking and narrowing down the intersecting coordinates)."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Lovely Tip. I used stack to replace a set of overlapping balloons with their overlap and count the number of balloons end at left. Here is my solution: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I have the same feeling now and it makes me happy. For everyone, keep practicing and you\\'ll be rewarded, don\\'t give up! "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "MentalHealth--;\\nStress++;"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "\\uD83D\\uDE02\\u270C\\uFE0F"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\nWhy expected output for this is 2, as per given instructions it should be 1. Can anyone please give me an explanation, it will be very helpful."
                    }
                ]
            },
            {
                "id": 1576221,
                "content": [
                    {
                        "username": "wateryan17",
                        "content": "Apparently a new test case has been added recently. If you cannot pass this one, then it is because the result of subtraction is too large and thus the overflow is encountered. So don\\'t use `a-b` to compare when sorting. Use `Integer.compare(a,b)` instead!!!"
                    },
                    {
                        "username": "AJReach",
                        "content": "Thanks"
                    },
                    {
                        "username": "dmproni",
                        "content": "even better for Java use Comparator.comparingInt() for clarity :)"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Thanks a lot mate! Great observation! I had this exact problem!"
                    },
                    {
                        "username": "serkora",
                        "content": "[@nikhilsteamid](/nikhilsteamid) Just plain std::sort(v.begin(), v.end()) is enough, it handles sorting of 2D vectors by default, so no need to provide your own. (And you can also use templated STL comparison functions such as std::greater<std::vector<int>>() if you need a different order.)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You can use the below code in java. a-b is still working for sorting.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three cases. but yah for making short and neat code we should use either  Integer.compare(a,b) or lamda function.\\n//code\\n Arrays.sort(arr,new Comparator<int[]>(){\\n            public int compare(int[] a1,int[] a2){\\n               //  return Integer.compare(a1[0],a2[0]); \\n               if(a1[0]>a2[0]) return 1;\\n               else if(a1[0]<a2[0]) return -1;\\n               else return 0;\\n            }\\n        });"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "[@nikhilsteamid](/nikhilsteamid)  u can use lambda function to sort the array in c++\\n"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "what is the c++ alternative?"
                    },
                    {
                        "username": "carloseddy397",
                        "content": "`\\u201CLet me take a break of 5 minutes to browse the internet.\\u201D That\\u2019s how it starts. An hour later, you are still browsing.`"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Replying after exactly 1 year mate !\\nAnniversary of your comment \\uD83D\\uDC95\\uD83E\\uDD23"
                    },
                    {
                        "username": "S_Basu",
                        "content": "true"
                    },
                    {
                        "username": "mkohar",
                        "content": "Try using **Stay Focusd** chrome extension"
                    },
                    {
                        "username": "shanks21",
                        "content": "it\\'s like all of us are leading exact same lives"
                    },
                    {
                        "username": "choi_taek",
                        "content": "programming is 1% intelligence and 99% trying not  to get distracted by internet.\\nYou can try this extension pluckeye. Its great. "
                    },
                    {
                        "username": "vaibhavbhardwaj1987",
                        "content": "![image](https://assets.leetcode.com/users/images/743abf3b-788a-4da7-b576-f043cefe87c0_1603097643.8374152.png)\\n"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@srirambadalgama](/srirambadalgama) No it will give 2 only..\\nas first start will be 3\\nand then 4<=3 false...so count = 2 and now start = 5\\n1<=5 true \\nso result will be 2"
                    },
                    {
                        "username": "srirambadalgama",
                        "content": "I think your solution will give wrong answer for test case: [[1,10],[2,3],[4,5]].\\ncorrect ans is 2. But your soln will give 1."
                    },
                    {
                        "username": "khushimattu",
                        "content": "i have a small doubt. we are checking whether the xend of start is greater than the x start of the next one or not but we arent checking the condition if that is greater than the x ed of the next one?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I didn\\'t visualize the problem like this. It seems so simple now :)"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Nice observation bro, I just sorted and used stack to find overlaps like a dummy. Anyways, here is my dum-dum solution, Its beginner friendly and more intuitive I guess :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "[@Sledge_man](/Sledge_man) same question"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "So brilliant, I like the observation. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@bean_bean](/bean_bean) savage"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "[@Sledge_man](/Sledge_man) Nope, it has to go straight up"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "you are supposed to shoot the arrow vertically up. which means parallel to the y axis. "
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Enough guys, focus on the problem...  😁🧐"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Nice hair growth\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@yl245](/yl245) why do you focus on this? \\uD83D\\uDE02"
                    },
                    {
                        "username": "Sledge_man",
                        "content": "isnt the arrow supposed to go vertically up?\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "could\\'ve cropped out those hairy legs \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Description is really stupid.\n\"spherical balloon\" is a 3D object. If you know only single coordinate of each ballon on some plane then there is many configurations.\nI always try to solve problem by my self. I did over 700 but this one is really poorly stated.\nAfter looking at official solution and the image there it turns to be really simple (just intervals on a 1D).\n[@LeetCode](/LeetCode) plese add this image to the problem descrition.\n\n![image](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/288049/Figures/452/arrows.png)\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It is a bit pedantic to complain about them using \"sphere\" rather than \"circle\", and then propose an image where you drew \"ellipses\". I'm sure if they had put that image in the statement, there would have been comments like yours calling the question \"really stupid\" for being misleading.\n\nThey clarified explicitly that everything takes place in a 2D plane, so I don't think there's much confusion about whether we should consider the problem 3D, but I agree that a similar illustration would be nice add"
                    },
                    {
                        "username": "trsuhas21",
                        "content": "Tq for elucidating "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) I agree with you, I have posted in a comment that the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!! Even with baloons and stuff, arrow is a stupid analogy since it just passes a point in 2D plain. Better could have been a knife that is cutting sausages that are overlapping on x axis (the only axis).\\n\\nI would Ignore what calm27 is saying since that roughly translates to \"we should accept everything as is, and not give any constructive feedback\"."
                    },
                    {
                        "username": "calm27",
                        "content": "> I always try to solve problem by my self\n\nyou said it like other folks do otherwise to prove your assumption that wording is bad. \n\nmajor part solves it by themselves. no one like bad wording in descriptions, but we should accept the fact it is an initial part of the problem, and the purpose of it is to \"figure out\". \nlife would be easy if all problems were clear. "
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TIP: For `C++`, the input of annonymous compare function shold be reference, or you will get TLE."
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks, was stuck because of it for a while"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "[@kriket](/kriket) Definitely. Copying is always slower, I was just surprised that it will cause such a big difference in sorting."
                    },
                    {
                        "username": "close27",
                        "content": "I think it\\'s because pass by ref does not make new copies hence it is faster."
                    },
                    {
                        "username": "close27",
                        "content": "[@MC_JRen](/MC_JRen)Did run into the problem. Can you please explain how you figured it out?"
                    },
                    {
                        "username": "L39ND",
                        "content": "thats exactly what I need, thank you so much! "
                    },
                    {
                        "username": "Kis_shot",
                        "content": "thank you so much!!!it confused me a lot until i put \"&\" to pass through"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\\n\\nWe can understand by using an example:\\n\\nGiven an 2d array of size 4 with  [10,16] , [2,8] , [1,6] , [7,12]\\n\\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\\n\\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\\n\\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\\n\\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\\n\\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\\n\\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\\n\\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\\n\\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\\n\\nAt last, return the arrow counter.\\n\\nSolution link for better understanding: [https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest)\\n\\nI hope it helps ^_^"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Very clean solution!"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "wow, I used similar theory but I used stack for replacing two balloons with their overlap instead. Here is a better written solution :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "mausami",
                        "content": "Take care of the following test cases while sorting the array:\\n1. []\\n2. [[1,2],[2,3],[3,4],[4,5]]\\n3. [[-2147483646,-2147483645],[2147483646,2147483647]]\\n4. [[10,16],[2,8],[1,6],[7,12]]\\n5. [[1,2],[3,4],[5,6],[7,8]]\\n6. [[1,2]]\\n7. [[2,3],[2,3]]\\n"
                    },
                    {
                        "username": "dvakar",
                        "content": "8. [[77171087,133597895],[45117276,135064454],[80695788,90089372],[91705403,110208054],[52392754,127005153],[53999932,118094992],[11549676,55543044],[43947739,128157751],[55636226,105334812],[69348094,125645633]]"
                    },
                    {
                        "username": "srbssv",
                        "content": "What should we return in case of [[-2147483646,-2147483645],[2147483646,2147483647]]?"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "HUH, Interesting, Funny I didnt find any of these because my stack solution handled them all ok I guess. Here it is:: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "aditisingh10022018",
                        "content": "my test case is also failing at 3rd test case why?"
                    },
                    {
                        "username": "tajnur",
                        "content": "According to the constraints, empty points is not valid. Points should have at least one element..\\n"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "also, [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] "
                    },
                    {
                        "username": "santanusen",
                        "content": "It would have taken me hours to solve such problems a few months back. I was able to solve it in 15 mins today thanks to daily leetcoding. Leetcode definitely helps.\\n\\nTip:\\nsort the points, track how many consecutive points intersect (keep tracking and narrowing down the intersecting coordinates)."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Lovely Tip. I used stack to replace a set of overlapping balloons with their overlap and count the number of balloons end at left. Here is my solution: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I have the same feeling now and it makes me happy. For everyone, keep practicing and you\\'ll be rewarded, don\\'t give up! "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "MentalHealth--;\\nStress++;"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "\\uD83D\\uDE02\\u270C\\uFE0F"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\nWhy expected output for this is 2, as per given instructions it should be 1. Can anyone please give me an explanation, it will be very helpful."
                    }
                ]
            },
            {
                "id": 1574502,
                "content": [
                    {
                        "username": "wateryan17",
                        "content": "Apparently a new test case has been added recently. If you cannot pass this one, then it is because the result of subtraction is too large and thus the overflow is encountered. So don\\'t use `a-b` to compare when sorting. Use `Integer.compare(a,b)` instead!!!"
                    },
                    {
                        "username": "AJReach",
                        "content": "Thanks"
                    },
                    {
                        "username": "dmproni",
                        "content": "even better for Java use Comparator.comparingInt() for clarity :)"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Thanks a lot mate! Great observation! I had this exact problem!"
                    },
                    {
                        "username": "serkora",
                        "content": "[@nikhilsteamid](/nikhilsteamid) Just plain std::sort(v.begin(), v.end()) is enough, it handles sorting of 2D vectors by default, so no need to provide your own. (And you can also use templated STL comparison functions such as std::greater<std::vector<int>>() if you need a different order.)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You can use the below code in java. a-b is still working for sorting.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three cases. but yah for making short and neat code we should use either  Integer.compare(a,b) or lamda function.\\n//code\\n Arrays.sort(arr,new Comparator<int[]>(){\\n            public int compare(int[] a1,int[] a2){\\n               //  return Integer.compare(a1[0],a2[0]); \\n               if(a1[0]>a2[0]) return 1;\\n               else if(a1[0]<a2[0]) return -1;\\n               else return 0;\\n            }\\n        });"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "[@nikhilsteamid](/nikhilsteamid)  u can use lambda function to sort the array in c++\\n"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "what is the c++ alternative?"
                    },
                    {
                        "username": "carloseddy397",
                        "content": "`\\u201CLet me take a break of 5 minutes to browse the internet.\\u201D That\\u2019s how it starts. An hour later, you are still browsing.`"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Replying after exactly 1 year mate !\\nAnniversary of your comment \\uD83D\\uDC95\\uD83E\\uDD23"
                    },
                    {
                        "username": "S_Basu",
                        "content": "true"
                    },
                    {
                        "username": "mkohar",
                        "content": "Try using **Stay Focusd** chrome extension"
                    },
                    {
                        "username": "shanks21",
                        "content": "it\\'s like all of us are leading exact same lives"
                    },
                    {
                        "username": "choi_taek",
                        "content": "programming is 1% intelligence and 99% trying not  to get distracted by internet.\\nYou can try this extension pluckeye. Its great. "
                    },
                    {
                        "username": "vaibhavbhardwaj1987",
                        "content": "![image](https://assets.leetcode.com/users/images/743abf3b-788a-4da7-b576-f043cefe87c0_1603097643.8374152.png)\\n"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@srirambadalgama](/srirambadalgama) No it will give 2 only..\\nas first start will be 3\\nand then 4<=3 false...so count = 2 and now start = 5\\n1<=5 true \\nso result will be 2"
                    },
                    {
                        "username": "srirambadalgama",
                        "content": "I think your solution will give wrong answer for test case: [[1,10],[2,3],[4,5]].\\ncorrect ans is 2. But your soln will give 1."
                    },
                    {
                        "username": "khushimattu",
                        "content": "i have a small doubt. we are checking whether the xend of start is greater than the x start of the next one or not but we arent checking the condition if that is greater than the x ed of the next one?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I didn\\'t visualize the problem like this. It seems so simple now :)"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Nice observation bro, I just sorted and used stack to find overlaps like a dummy. Anyways, here is my dum-dum solution, Its beginner friendly and more intuitive I guess :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "[@Sledge_man](/Sledge_man) same question"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "So brilliant, I like the observation. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@bean_bean](/bean_bean) savage"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "[@Sledge_man](/Sledge_man) Nope, it has to go straight up"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "you are supposed to shoot the arrow vertically up. which means parallel to the y axis. "
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Enough guys, focus on the problem...  😁🧐"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Nice hair growth\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@yl245](/yl245) why do you focus on this? \\uD83D\\uDE02"
                    },
                    {
                        "username": "Sledge_man",
                        "content": "isnt the arrow supposed to go vertically up?\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "could\\'ve cropped out those hairy legs \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Description is really stupid.\n\"spherical balloon\" is a 3D object. If you know only single coordinate of each ballon on some plane then there is many configurations.\nI always try to solve problem by my self. I did over 700 but this one is really poorly stated.\nAfter looking at official solution and the image there it turns to be really simple (just intervals on a 1D).\n[@LeetCode](/LeetCode) plese add this image to the problem descrition.\n\n![image](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/288049/Figures/452/arrows.png)\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It is a bit pedantic to complain about them using \"sphere\" rather than \"circle\", and then propose an image where you drew \"ellipses\". I'm sure if they had put that image in the statement, there would have been comments like yours calling the question \"really stupid\" for being misleading.\n\nThey clarified explicitly that everything takes place in a 2D plane, so I don't think there's much confusion about whether we should consider the problem 3D, but I agree that a similar illustration would be nice add"
                    },
                    {
                        "username": "trsuhas21",
                        "content": "Tq for elucidating "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) I agree with you, I have posted in a comment that the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!! Even with baloons and stuff, arrow is a stupid analogy since it just passes a point in 2D plain. Better could have been a knife that is cutting sausages that are overlapping on x axis (the only axis).\\n\\nI would Ignore what calm27 is saying since that roughly translates to \"we should accept everything as is, and not give any constructive feedback\"."
                    },
                    {
                        "username": "calm27",
                        "content": "> I always try to solve problem by my self\n\nyou said it like other folks do otherwise to prove your assumption that wording is bad. \n\nmajor part solves it by themselves. no one like bad wording in descriptions, but we should accept the fact it is an initial part of the problem, and the purpose of it is to \"figure out\". \nlife would be easy if all problems were clear. "
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TIP: For `C++`, the input of annonymous compare function shold be reference, or you will get TLE."
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks, was stuck because of it for a while"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "[@kriket](/kriket) Definitely. Copying is always slower, I was just surprised that it will cause such a big difference in sorting."
                    },
                    {
                        "username": "close27",
                        "content": "I think it\\'s because pass by ref does not make new copies hence it is faster."
                    },
                    {
                        "username": "close27",
                        "content": "[@MC_JRen](/MC_JRen)Did run into the problem. Can you please explain how you figured it out?"
                    },
                    {
                        "username": "L39ND",
                        "content": "thats exactly what I need, thank you so much! "
                    },
                    {
                        "username": "Kis_shot",
                        "content": "thank you so much!!!it confused me a lot until i put \"&\" to pass through"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\\n\\nWe can understand by using an example:\\n\\nGiven an 2d array of size 4 with  [10,16] , [2,8] , [1,6] , [7,12]\\n\\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\\n\\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\\n\\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\\n\\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\\n\\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\\n\\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\\n\\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\\n\\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\\n\\nAt last, return the arrow counter.\\n\\nSolution link for better understanding: [https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest)\\n\\nI hope it helps ^_^"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Very clean solution!"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "wow, I used similar theory but I used stack for replacing two balloons with their overlap instead. Here is a better written solution :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "mausami",
                        "content": "Take care of the following test cases while sorting the array:\\n1. []\\n2. [[1,2],[2,3],[3,4],[4,5]]\\n3. [[-2147483646,-2147483645],[2147483646,2147483647]]\\n4. [[10,16],[2,8],[1,6],[7,12]]\\n5. [[1,2],[3,4],[5,6],[7,8]]\\n6. [[1,2]]\\n7. [[2,3],[2,3]]\\n"
                    },
                    {
                        "username": "dvakar",
                        "content": "8. [[77171087,133597895],[45117276,135064454],[80695788,90089372],[91705403,110208054],[52392754,127005153],[53999932,118094992],[11549676,55543044],[43947739,128157751],[55636226,105334812],[69348094,125645633]]"
                    },
                    {
                        "username": "srbssv",
                        "content": "What should we return in case of [[-2147483646,-2147483645],[2147483646,2147483647]]?"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "HUH, Interesting, Funny I didnt find any of these because my stack solution handled them all ok I guess. Here it is:: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "aditisingh10022018",
                        "content": "my test case is also failing at 3rd test case why?"
                    },
                    {
                        "username": "tajnur",
                        "content": "According to the constraints, empty points is not valid. Points should have at least one element..\\n"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "also, [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] "
                    },
                    {
                        "username": "santanusen",
                        "content": "It would have taken me hours to solve such problems a few months back. I was able to solve it in 15 mins today thanks to daily leetcoding. Leetcode definitely helps.\\n\\nTip:\\nsort the points, track how many consecutive points intersect (keep tracking and narrowing down the intersecting coordinates)."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Lovely Tip. I used stack to replace a set of overlapping balloons with their overlap and count the number of balloons end at left. Here is my solution: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I have the same feeling now and it makes me happy. For everyone, keep practicing and you\\'ll be rewarded, don\\'t give up! "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "MentalHealth--;\\nStress++;"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "\\uD83D\\uDE02\\u270C\\uFE0F"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\nWhy expected output for this is 2, as per given instructions it should be 1. Can anyone please give me an explanation, it will be very helpful."
                    }
                ]
            },
            {
                "id": 1743008,
                "content": [
                    {
                        "username": "wateryan17",
                        "content": "Apparently a new test case has been added recently. If you cannot pass this one, then it is because the result of subtraction is too large and thus the overflow is encountered. So don\\'t use `a-b` to compare when sorting. Use `Integer.compare(a,b)` instead!!!"
                    },
                    {
                        "username": "AJReach",
                        "content": "Thanks"
                    },
                    {
                        "username": "dmproni",
                        "content": "even better for Java use Comparator.comparingInt() for clarity :)"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Thanks a lot mate! Great observation! I had this exact problem!"
                    },
                    {
                        "username": "serkora",
                        "content": "[@nikhilsteamid](/nikhilsteamid) Just plain std::sort(v.begin(), v.end()) is enough, it handles sorting of 2D vectors by default, so no need to provide your own. (And you can also use templated STL comparison functions such as std::greater<std::vector<int>>() if you need a different order.)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You can use the below code in java. a-b is still working for sorting.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three cases. but yah for making short and neat code we should use either  Integer.compare(a,b) or lamda function.\\n//code\\n Arrays.sort(arr,new Comparator<int[]>(){\\n            public int compare(int[] a1,int[] a2){\\n               //  return Integer.compare(a1[0],a2[0]); \\n               if(a1[0]>a2[0]) return 1;\\n               else if(a1[0]<a2[0]) return -1;\\n               else return 0;\\n            }\\n        });"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "[@nikhilsteamid](/nikhilsteamid)  u can use lambda function to sort the array in c++\\n"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "what is the c++ alternative?"
                    },
                    {
                        "username": "carloseddy397",
                        "content": "`\\u201CLet me take a break of 5 minutes to browse the internet.\\u201D That\\u2019s how it starts. An hour later, you are still browsing.`"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Replying after exactly 1 year mate !\\nAnniversary of your comment \\uD83D\\uDC95\\uD83E\\uDD23"
                    },
                    {
                        "username": "S_Basu",
                        "content": "true"
                    },
                    {
                        "username": "mkohar",
                        "content": "Try using **Stay Focusd** chrome extension"
                    },
                    {
                        "username": "shanks21",
                        "content": "it\\'s like all of us are leading exact same lives"
                    },
                    {
                        "username": "choi_taek",
                        "content": "programming is 1% intelligence and 99% trying not  to get distracted by internet.\\nYou can try this extension pluckeye. Its great. "
                    },
                    {
                        "username": "vaibhavbhardwaj1987",
                        "content": "![image](https://assets.leetcode.com/users/images/743abf3b-788a-4da7-b576-f043cefe87c0_1603097643.8374152.png)\\n"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@srirambadalgama](/srirambadalgama) No it will give 2 only..\\nas first start will be 3\\nand then 4<=3 false...so count = 2 and now start = 5\\n1<=5 true \\nso result will be 2"
                    },
                    {
                        "username": "srirambadalgama",
                        "content": "I think your solution will give wrong answer for test case: [[1,10],[2,3],[4,5]].\\ncorrect ans is 2. But your soln will give 1."
                    },
                    {
                        "username": "khushimattu",
                        "content": "i have a small doubt. we are checking whether the xend of start is greater than the x start of the next one or not but we arent checking the condition if that is greater than the x ed of the next one?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I didn\\'t visualize the problem like this. It seems so simple now :)"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Nice observation bro, I just sorted and used stack to find overlaps like a dummy. Anyways, here is my dum-dum solution, Its beginner friendly and more intuitive I guess :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "[@Sledge_man](/Sledge_man) same question"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "So brilliant, I like the observation. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@bean_bean](/bean_bean) savage"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "[@Sledge_man](/Sledge_man) Nope, it has to go straight up"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "you are supposed to shoot the arrow vertically up. which means parallel to the y axis. "
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Enough guys, focus on the problem...  😁🧐"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Nice hair growth\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@yl245](/yl245) why do you focus on this? \\uD83D\\uDE02"
                    },
                    {
                        "username": "Sledge_man",
                        "content": "isnt the arrow supposed to go vertically up?\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "could\\'ve cropped out those hairy legs \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Description is really stupid.\n\"spherical balloon\" is a 3D object. If you know only single coordinate of each ballon on some plane then there is many configurations.\nI always try to solve problem by my self. I did over 700 but this one is really poorly stated.\nAfter looking at official solution and the image there it turns to be really simple (just intervals on a 1D).\n[@LeetCode](/LeetCode) plese add this image to the problem descrition.\n\n![image](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/288049/Figures/452/arrows.png)\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It is a bit pedantic to complain about them using \"sphere\" rather than \"circle\", and then propose an image where you drew \"ellipses\". I'm sure if they had put that image in the statement, there would have been comments like yours calling the question \"really stupid\" for being misleading.\n\nThey clarified explicitly that everything takes place in a 2D plane, so I don't think there's much confusion about whether we should consider the problem 3D, but I agree that a similar illustration would be nice add"
                    },
                    {
                        "username": "trsuhas21",
                        "content": "Tq for elucidating "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) I agree with you, I have posted in a comment that the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!! Even with baloons and stuff, arrow is a stupid analogy since it just passes a point in 2D plain. Better could have been a knife that is cutting sausages that are overlapping on x axis (the only axis).\\n\\nI would Ignore what calm27 is saying since that roughly translates to \"we should accept everything as is, and not give any constructive feedback\"."
                    },
                    {
                        "username": "calm27",
                        "content": "> I always try to solve problem by my self\n\nyou said it like other folks do otherwise to prove your assumption that wording is bad. \n\nmajor part solves it by themselves. no one like bad wording in descriptions, but we should accept the fact it is an initial part of the problem, and the purpose of it is to \"figure out\". \nlife would be easy if all problems were clear. "
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TIP: For `C++`, the input of annonymous compare function shold be reference, or you will get TLE."
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks, was stuck because of it for a while"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "[@kriket](/kriket) Definitely. Copying is always slower, I was just surprised that it will cause such a big difference in sorting."
                    },
                    {
                        "username": "close27",
                        "content": "I think it\\'s because pass by ref does not make new copies hence it is faster."
                    },
                    {
                        "username": "close27",
                        "content": "[@MC_JRen](/MC_JRen)Did run into the problem. Can you please explain how you figured it out?"
                    },
                    {
                        "username": "L39ND",
                        "content": "thats exactly what I need, thank you so much! "
                    },
                    {
                        "username": "Kis_shot",
                        "content": "thank you so much!!!it confused me a lot until i put \"&\" to pass through"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\\n\\nWe can understand by using an example:\\n\\nGiven an 2d array of size 4 with  [10,16] , [2,8] , [1,6] , [7,12]\\n\\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\\n\\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\\n\\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\\n\\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\\n\\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\\n\\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\\n\\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\\n\\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\\n\\nAt last, return the arrow counter.\\n\\nSolution link for better understanding: [https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest)\\n\\nI hope it helps ^_^"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Very clean solution!"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "wow, I used similar theory but I used stack for replacing two balloons with their overlap instead. Here is a better written solution :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "mausami",
                        "content": "Take care of the following test cases while sorting the array:\\n1. []\\n2. [[1,2],[2,3],[3,4],[4,5]]\\n3. [[-2147483646,-2147483645],[2147483646,2147483647]]\\n4. [[10,16],[2,8],[1,6],[7,12]]\\n5. [[1,2],[3,4],[5,6],[7,8]]\\n6. [[1,2]]\\n7. [[2,3],[2,3]]\\n"
                    },
                    {
                        "username": "dvakar",
                        "content": "8. [[77171087,133597895],[45117276,135064454],[80695788,90089372],[91705403,110208054],[52392754,127005153],[53999932,118094992],[11549676,55543044],[43947739,128157751],[55636226,105334812],[69348094,125645633]]"
                    },
                    {
                        "username": "srbssv",
                        "content": "What should we return in case of [[-2147483646,-2147483645],[2147483646,2147483647]]?"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "HUH, Interesting, Funny I didnt find any of these because my stack solution handled them all ok I guess. Here it is:: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "aditisingh10022018",
                        "content": "my test case is also failing at 3rd test case why?"
                    },
                    {
                        "username": "tajnur",
                        "content": "According to the constraints, empty points is not valid. Points should have at least one element..\\n"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "also, [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] "
                    },
                    {
                        "username": "santanusen",
                        "content": "It would have taken me hours to solve such problems a few months back. I was able to solve it in 15 mins today thanks to daily leetcoding. Leetcode definitely helps.\\n\\nTip:\\nsort the points, track how many consecutive points intersect (keep tracking and narrowing down the intersecting coordinates)."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Lovely Tip. I used stack to replace a set of overlapping balloons with their overlap and count the number of balloons end at left. Here is my solution: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I have the same feeling now and it makes me happy. For everyone, keep practicing and you\\'ll be rewarded, don\\'t give up! "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "MentalHealth--;\\nStress++;"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "\\uD83D\\uDE02\\u270C\\uFE0F"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\nWhy expected output for this is 2, as per given instructions it should be 1. Can anyone please give me an explanation, it will be very helpful."
                    }
                ]
            },
            {
                "id": 1729822,
                "content": [
                    {
                        "username": "wateryan17",
                        "content": "Apparently a new test case has been added recently. If you cannot pass this one, then it is because the result of subtraction is too large and thus the overflow is encountered. So don\\'t use `a-b` to compare when sorting. Use `Integer.compare(a,b)` instead!!!"
                    },
                    {
                        "username": "AJReach",
                        "content": "Thanks"
                    },
                    {
                        "username": "dmproni",
                        "content": "even better for Java use Comparator.comparingInt() for clarity :)"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Thanks a lot mate! Great observation! I had this exact problem!"
                    },
                    {
                        "username": "serkora",
                        "content": "[@nikhilsteamid](/nikhilsteamid) Just plain std::sort(v.begin(), v.end()) is enough, it handles sorting of 2D vectors by default, so no need to provide your own. (And you can also use templated STL comparison functions such as std::greater<std::vector<int>>() if you need a different order.)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You can use the below code in java. a-b is still working for sorting.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three cases. but yah for making short and neat code we should use either  Integer.compare(a,b) or lamda function.\\n//code\\n Arrays.sort(arr,new Comparator<int[]>(){\\n            public int compare(int[] a1,int[] a2){\\n               //  return Integer.compare(a1[0],a2[0]); \\n               if(a1[0]>a2[0]) return 1;\\n               else if(a1[0]<a2[0]) return -1;\\n               else return 0;\\n            }\\n        });"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "[@nikhilsteamid](/nikhilsteamid)  u can use lambda function to sort the array in c++\\n"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "what is the c++ alternative?"
                    },
                    {
                        "username": "carloseddy397",
                        "content": "`\\u201CLet me take a break of 5 minutes to browse the internet.\\u201D That\\u2019s how it starts. An hour later, you are still browsing.`"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Replying after exactly 1 year mate !\\nAnniversary of your comment \\uD83D\\uDC95\\uD83E\\uDD23"
                    },
                    {
                        "username": "S_Basu",
                        "content": "true"
                    },
                    {
                        "username": "mkohar",
                        "content": "Try using **Stay Focusd** chrome extension"
                    },
                    {
                        "username": "shanks21",
                        "content": "it\\'s like all of us are leading exact same lives"
                    },
                    {
                        "username": "choi_taek",
                        "content": "programming is 1% intelligence and 99% trying not  to get distracted by internet.\\nYou can try this extension pluckeye. Its great. "
                    },
                    {
                        "username": "vaibhavbhardwaj1987",
                        "content": "![image](https://assets.leetcode.com/users/images/743abf3b-788a-4da7-b576-f043cefe87c0_1603097643.8374152.png)\\n"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@srirambadalgama](/srirambadalgama) No it will give 2 only..\\nas first start will be 3\\nand then 4<=3 false...so count = 2 and now start = 5\\n1<=5 true \\nso result will be 2"
                    },
                    {
                        "username": "srirambadalgama",
                        "content": "I think your solution will give wrong answer for test case: [[1,10],[2,3],[4,5]].\\ncorrect ans is 2. But your soln will give 1."
                    },
                    {
                        "username": "khushimattu",
                        "content": "i have a small doubt. we are checking whether the xend of start is greater than the x start of the next one or not but we arent checking the condition if that is greater than the x ed of the next one?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I didn\\'t visualize the problem like this. It seems so simple now :)"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Nice observation bro, I just sorted and used stack to find overlaps like a dummy. Anyways, here is my dum-dum solution, Its beginner friendly and more intuitive I guess :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "[@Sledge_man](/Sledge_man) same question"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "So brilliant, I like the observation. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@bean_bean](/bean_bean) savage"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "[@Sledge_man](/Sledge_man) Nope, it has to go straight up"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "you are supposed to shoot the arrow vertically up. which means parallel to the y axis. "
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Enough guys, focus on the problem...  😁🧐"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Nice hair growth\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@yl245](/yl245) why do you focus on this? \\uD83D\\uDE02"
                    },
                    {
                        "username": "Sledge_man",
                        "content": "isnt the arrow supposed to go vertically up?\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "could\\'ve cropped out those hairy legs \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Description is really stupid.\n\"spherical balloon\" is a 3D object. If you know only single coordinate of each ballon on some plane then there is many configurations.\nI always try to solve problem by my self. I did over 700 but this one is really poorly stated.\nAfter looking at official solution and the image there it turns to be really simple (just intervals on a 1D).\n[@LeetCode](/LeetCode) plese add this image to the problem descrition.\n\n![image](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/288049/Figures/452/arrows.png)\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It is a bit pedantic to complain about them using \"sphere\" rather than \"circle\", and then propose an image where you drew \"ellipses\". I'm sure if they had put that image in the statement, there would have been comments like yours calling the question \"really stupid\" for being misleading.\n\nThey clarified explicitly that everything takes place in a 2D plane, so I don't think there's much confusion about whether we should consider the problem 3D, but I agree that a similar illustration would be nice add"
                    },
                    {
                        "username": "trsuhas21",
                        "content": "Tq for elucidating "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) I agree with you, I have posted in a comment that the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!! Even with baloons and stuff, arrow is a stupid analogy since it just passes a point in 2D plain. Better could have been a knife that is cutting sausages that are overlapping on x axis (the only axis).\\n\\nI would Ignore what calm27 is saying since that roughly translates to \"we should accept everything as is, and not give any constructive feedback\"."
                    },
                    {
                        "username": "calm27",
                        "content": "> I always try to solve problem by my self\n\nyou said it like other folks do otherwise to prove your assumption that wording is bad. \n\nmajor part solves it by themselves. no one like bad wording in descriptions, but we should accept the fact it is an initial part of the problem, and the purpose of it is to \"figure out\". \nlife would be easy if all problems were clear. "
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TIP: For `C++`, the input of annonymous compare function shold be reference, or you will get TLE."
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks, was stuck because of it for a while"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "[@kriket](/kriket) Definitely. Copying is always slower, I was just surprised that it will cause such a big difference in sorting."
                    },
                    {
                        "username": "close27",
                        "content": "I think it\\'s because pass by ref does not make new copies hence it is faster."
                    },
                    {
                        "username": "close27",
                        "content": "[@MC_JRen](/MC_JRen)Did run into the problem. Can you please explain how you figured it out?"
                    },
                    {
                        "username": "L39ND",
                        "content": "thats exactly what I need, thank you so much! "
                    },
                    {
                        "username": "Kis_shot",
                        "content": "thank you so much!!!it confused me a lot until i put \"&\" to pass through"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\\n\\nWe can understand by using an example:\\n\\nGiven an 2d array of size 4 with  [10,16] , [2,8] , [1,6] , [7,12]\\n\\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\\n\\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\\n\\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\\n\\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\\n\\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\\n\\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\\n\\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\\n\\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\\n\\nAt last, return the arrow counter.\\n\\nSolution link for better understanding: [https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest)\\n\\nI hope it helps ^_^"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Very clean solution!"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "wow, I used similar theory but I used stack for replacing two balloons with their overlap instead. Here is a better written solution :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "mausami",
                        "content": "Take care of the following test cases while sorting the array:\\n1. []\\n2. [[1,2],[2,3],[3,4],[4,5]]\\n3. [[-2147483646,-2147483645],[2147483646,2147483647]]\\n4. [[10,16],[2,8],[1,6],[7,12]]\\n5. [[1,2],[3,4],[5,6],[7,8]]\\n6. [[1,2]]\\n7. [[2,3],[2,3]]\\n"
                    },
                    {
                        "username": "dvakar",
                        "content": "8. [[77171087,133597895],[45117276,135064454],[80695788,90089372],[91705403,110208054],[52392754,127005153],[53999932,118094992],[11549676,55543044],[43947739,128157751],[55636226,105334812],[69348094,125645633]]"
                    },
                    {
                        "username": "srbssv",
                        "content": "What should we return in case of [[-2147483646,-2147483645],[2147483646,2147483647]]?"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "HUH, Interesting, Funny I didnt find any of these because my stack solution handled them all ok I guess. Here it is:: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "aditisingh10022018",
                        "content": "my test case is also failing at 3rd test case why?"
                    },
                    {
                        "username": "tajnur",
                        "content": "According to the constraints, empty points is not valid. Points should have at least one element..\\n"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "also, [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] "
                    },
                    {
                        "username": "santanusen",
                        "content": "It would have taken me hours to solve such problems a few months back. I was able to solve it in 15 mins today thanks to daily leetcoding. Leetcode definitely helps.\\n\\nTip:\\nsort the points, track how many consecutive points intersect (keep tracking and narrowing down the intersecting coordinates)."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Lovely Tip. I used stack to replace a set of overlapping balloons with their overlap and count the number of balloons end at left. Here is my solution: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I have the same feeling now and it makes me happy. For everyone, keep practicing and you\\'ll be rewarded, don\\'t give up! "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "MentalHealth--;\\nStress++;"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "\\uD83D\\uDE02\\u270C\\uFE0F"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\nWhy expected output for this is 2, as per given instructions it should be 1. Can anyone please give me an explanation, it will be very helpful."
                    }
                ]
            },
            {
                "id": 1742148,
                "content": [
                    {
                        "username": "wateryan17",
                        "content": "Apparently a new test case has been added recently. If you cannot pass this one, then it is because the result of subtraction is too large and thus the overflow is encountered. So don\\'t use `a-b` to compare when sorting. Use `Integer.compare(a,b)` instead!!!"
                    },
                    {
                        "username": "AJReach",
                        "content": "Thanks"
                    },
                    {
                        "username": "dmproni",
                        "content": "even better for Java use Comparator.comparingInt() for clarity :)"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Thanks a lot mate! Great observation! I had this exact problem!"
                    },
                    {
                        "username": "serkora",
                        "content": "[@nikhilsteamid](/nikhilsteamid) Just plain std::sort(v.begin(), v.end()) is enough, it handles sorting of 2D vectors by default, so no need to provide your own. (And you can also use templated STL comparison functions such as std::greater<std::vector<int>>() if you need a different order.)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You can use the below code in java. a-b is still working for sorting.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three cases. but yah for making short and neat code we should use either  Integer.compare(a,b) or lamda function.\\n//code\\n Arrays.sort(arr,new Comparator<int[]>(){\\n            public int compare(int[] a1,int[] a2){\\n               //  return Integer.compare(a1[0],a2[0]); \\n               if(a1[0]>a2[0]) return 1;\\n               else if(a1[0]<a2[0]) return -1;\\n               else return 0;\\n            }\\n        });"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "[@nikhilsteamid](/nikhilsteamid)  u can use lambda function to sort the array in c++\\n"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "what is the c++ alternative?"
                    },
                    {
                        "username": "carloseddy397",
                        "content": "`\\u201CLet me take a break of 5 minutes to browse the internet.\\u201D That\\u2019s how it starts. An hour later, you are still browsing.`"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Replying after exactly 1 year mate !\\nAnniversary of your comment \\uD83D\\uDC95\\uD83E\\uDD23"
                    },
                    {
                        "username": "S_Basu",
                        "content": "true"
                    },
                    {
                        "username": "mkohar",
                        "content": "Try using **Stay Focusd** chrome extension"
                    },
                    {
                        "username": "shanks21",
                        "content": "it\\'s like all of us are leading exact same lives"
                    },
                    {
                        "username": "choi_taek",
                        "content": "programming is 1% intelligence and 99% trying not  to get distracted by internet.\\nYou can try this extension pluckeye. Its great. "
                    },
                    {
                        "username": "vaibhavbhardwaj1987",
                        "content": "![image](https://assets.leetcode.com/users/images/743abf3b-788a-4da7-b576-f043cefe87c0_1603097643.8374152.png)\\n"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@srirambadalgama](/srirambadalgama) No it will give 2 only..\\nas first start will be 3\\nand then 4<=3 false...so count = 2 and now start = 5\\n1<=5 true \\nso result will be 2"
                    },
                    {
                        "username": "srirambadalgama",
                        "content": "I think your solution will give wrong answer for test case: [[1,10],[2,3],[4,5]].\\ncorrect ans is 2. But your soln will give 1."
                    },
                    {
                        "username": "khushimattu",
                        "content": "i have a small doubt. we are checking whether the xend of start is greater than the x start of the next one or not but we arent checking the condition if that is greater than the x ed of the next one?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I didn\\'t visualize the problem like this. It seems so simple now :)"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Nice observation bro, I just sorted and used stack to find overlaps like a dummy. Anyways, here is my dum-dum solution, Its beginner friendly and more intuitive I guess :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "[@Sledge_man](/Sledge_man) same question"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "So brilliant, I like the observation. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@bean_bean](/bean_bean) savage"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "[@Sledge_man](/Sledge_man) Nope, it has to go straight up"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "you are supposed to shoot the arrow vertically up. which means parallel to the y axis. "
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Enough guys, focus on the problem...  😁🧐"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Nice hair growth\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@yl245](/yl245) why do you focus on this? \\uD83D\\uDE02"
                    },
                    {
                        "username": "Sledge_man",
                        "content": "isnt the arrow supposed to go vertically up?\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "could\\'ve cropped out those hairy legs \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Description is really stupid.\n\"spherical balloon\" is a 3D object. If you know only single coordinate of each ballon on some plane then there is many configurations.\nI always try to solve problem by my self. I did over 700 but this one is really poorly stated.\nAfter looking at official solution and the image there it turns to be really simple (just intervals on a 1D).\n[@LeetCode](/LeetCode) plese add this image to the problem descrition.\n\n![image](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/288049/Figures/452/arrows.png)\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It is a bit pedantic to complain about them using \"sphere\" rather than \"circle\", and then propose an image where you drew \"ellipses\". I'm sure if they had put that image in the statement, there would have been comments like yours calling the question \"really stupid\" for being misleading.\n\nThey clarified explicitly that everything takes place in a 2D plane, so I don't think there's much confusion about whether we should consider the problem 3D, but I agree that a similar illustration would be nice add"
                    },
                    {
                        "username": "trsuhas21",
                        "content": "Tq for elucidating "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) I agree with you, I have posted in a comment that the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!! Even with baloons and stuff, arrow is a stupid analogy since it just passes a point in 2D plain. Better could have been a knife that is cutting sausages that are overlapping on x axis (the only axis).\\n\\nI would Ignore what calm27 is saying since that roughly translates to \"we should accept everything as is, and not give any constructive feedback\"."
                    },
                    {
                        "username": "calm27",
                        "content": "> I always try to solve problem by my self\n\nyou said it like other folks do otherwise to prove your assumption that wording is bad. \n\nmajor part solves it by themselves. no one like bad wording in descriptions, but we should accept the fact it is an initial part of the problem, and the purpose of it is to \"figure out\". \nlife would be easy if all problems were clear. "
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TIP: For `C++`, the input of annonymous compare function shold be reference, or you will get TLE."
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks, was stuck because of it for a while"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "[@kriket](/kriket) Definitely. Copying is always slower, I was just surprised that it will cause such a big difference in sorting."
                    },
                    {
                        "username": "close27",
                        "content": "I think it\\'s because pass by ref does not make new copies hence it is faster."
                    },
                    {
                        "username": "close27",
                        "content": "[@MC_JRen](/MC_JRen)Did run into the problem. Can you please explain how you figured it out?"
                    },
                    {
                        "username": "L39ND",
                        "content": "thats exactly what I need, thank you so much! "
                    },
                    {
                        "username": "Kis_shot",
                        "content": "thank you so much!!!it confused me a lot until i put \"&\" to pass through"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\\n\\nWe can understand by using an example:\\n\\nGiven an 2d array of size 4 with  [10,16] , [2,8] , [1,6] , [7,12]\\n\\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\\n\\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\\n\\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\\n\\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\\n\\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\\n\\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\\n\\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\\n\\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\\n\\nAt last, return the arrow counter.\\n\\nSolution link for better understanding: [https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest)\\n\\nI hope it helps ^_^"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Very clean solution!"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "wow, I used similar theory but I used stack for replacing two balloons with their overlap instead. Here is a better written solution :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "mausami",
                        "content": "Take care of the following test cases while sorting the array:\\n1. []\\n2. [[1,2],[2,3],[3,4],[4,5]]\\n3. [[-2147483646,-2147483645],[2147483646,2147483647]]\\n4. [[10,16],[2,8],[1,6],[7,12]]\\n5. [[1,2],[3,4],[5,6],[7,8]]\\n6. [[1,2]]\\n7. [[2,3],[2,3]]\\n"
                    },
                    {
                        "username": "dvakar",
                        "content": "8. [[77171087,133597895],[45117276,135064454],[80695788,90089372],[91705403,110208054],[52392754,127005153],[53999932,118094992],[11549676,55543044],[43947739,128157751],[55636226,105334812],[69348094,125645633]]"
                    },
                    {
                        "username": "srbssv",
                        "content": "What should we return in case of [[-2147483646,-2147483645],[2147483646,2147483647]]?"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "HUH, Interesting, Funny I didnt find any of these because my stack solution handled them all ok I guess. Here it is:: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "aditisingh10022018",
                        "content": "my test case is also failing at 3rd test case why?"
                    },
                    {
                        "username": "tajnur",
                        "content": "According to the constraints, empty points is not valid. Points should have at least one element..\\n"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "also, [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] "
                    },
                    {
                        "username": "santanusen",
                        "content": "It would have taken me hours to solve such problems a few months back. I was able to solve it in 15 mins today thanks to daily leetcoding. Leetcode definitely helps.\\n\\nTip:\\nsort the points, track how many consecutive points intersect (keep tracking and narrowing down the intersecting coordinates)."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Lovely Tip. I used stack to replace a set of overlapping balloons with their overlap and count the number of balloons end at left. Here is my solution: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I have the same feeling now and it makes me happy. For everyone, keep practicing and you\\'ll be rewarded, don\\'t give up! "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "MentalHealth--;\\nStress++;"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "\\uD83D\\uDE02\\u270C\\uFE0F"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\nWhy expected output for this is 2, as per given instructions it should be 1. Can anyone please give me an explanation, it will be very helpful."
                    }
                ]
            },
            {
                "id": 1567539,
                "content": [
                    {
                        "username": "wateryan17",
                        "content": "Apparently a new test case has been added recently. If you cannot pass this one, then it is because the result of subtraction is too large and thus the overflow is encountered. So don\\'t use `a-b` to compare when sorting. Use `Integer.compare(a,b)` instead!!!"
                    },
                    {
                        "username": "AJReach",
                        "content": "Thanks"
                    },
                    {
                        "username": "dmproni",
                        "content": "even better for Java use Comparator.comparingInt() for clarity :)"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Thanks a lot mate! Great observation! I had this exact problem!"
                    },
                    {
                        "username": "serkora",
                        "content": "[@nikhilsteamid](/nikhilsteamid) Just plain std::sort(v.begin(), v.end()) is enough, it handles sorting of 2D vectors by default, so no need to provide your own. (And you can also use templated STL comparison functions such as std::greater<std::vector<int>>() if you need a different order.)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You can use the below code in java. a-b is still working for sorting.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three cases. but yah for making short and neat code we should use either  Integer.compare(a,b) or lamda function.\\n//code\\n Arrays.sort(arr,new Comparator<int[]>(){\\n            public int compare(int[] a1,int[] a2){\\n               //  return Integer.compare(a1[0],a2[0]); \\n               if(a1[0]>a2[0]) return 1;\\n               else if(a1[0]<a2[0]) return -1;\\n               else return 0;\\n            }\\n        });"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "[@nikhilsteamid](/nikhilsteamid)  u can use lambda function to sort the array in c++\\n"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "what is the c++ alternative?"
                    },
                    {
                        "username": "carloseddy397",
                        "content": "`\\u201CLet me take a break of 5 minutes to browse the internet.\\u201D That\\u2019s how it starts. An hour later, you are still browsing.`"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Replying after exactly 1 year mate !\\nAnniversary of your comment \\uD83D\\uDC95\\uD83E\\uDD23"
                    },
                    {
                        "username": "S_Basu",
                        "content": "true"
                    },
                    {
                        "username": "mkohar",
                        "content": "Try using **Stay Focusd** chrome extension"
                    },
                    {
                        "username": "shanks21",
                        "content": "it\\'s like all of us are leading exact same lives"
                    },
                    {
                        "username": "choi_taek",
                        "content": "programming is 1% intelligence and 99% trying not  to get distracted by internet.\\nYou can try this extension pluckeye. Its great. "
                    },
                    {
                        "username": "vaibhavbhardwaj1987",
                        "content": "![image](https://assets.leetcode.com/users/images/743abf3b-788a-4da7-b576-f043cefe87c0_1603097643.8374152.png)\\n"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@srirambadalgama](/srirambadalgama) No it will give 2 only..\\nas first start will be 3\\nand then 4<=3 false...so count = 2 and now start = 5\\n1<=5 true \\nso result will be 2"
                    },
                    {
                        "username": "srirambadalgama",
                        "content": "I think your solution will give wrong answer for test case: [[1,10],[2,3],[4,5]].\\ncorrect ans is 2. But your soln will give 1."
                    },
                    {
                        "username": "khushimattu",
                        "content": "i have a small doubt. we are checking whether the xend of start is greater than the x start of the next one or not but we arent checking the condition if that is greater than the x ed of the next one?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I didn\\'t visualize the problem like this. It seems so simple now :)"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Nice observation bro, I just sorted and used stack to find overlaps like a dummy. Anyways, here is my dum-dum solution, Its beginner friendly and more intuitive I guess :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "[@Sledge_man](/Sledge_man) same question"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "So brilliant, I like the observation. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@bean_bean](/bean_bean) savage"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "[@Sledge_man](/Sledge_man) Nope, it has to go straight up"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "you are supposed to shoot the arrow vertically up. which means parallel to the y axis. "
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Enough guys, focus on the problem...  😁🧐"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Nice hair growth\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@yl245](/yl245) why do you focus on this? \\uD83D\\uDE02"
                    },
                    {
                        "username": "Sledge_man",
                        "content": "isnt the arrow supposed to go vertically up?\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "could\\'ve cropped out those hairy legs \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Description is really stupid.\n\"spherical balloon\" is a 3D object. If you know only single coordinate of each ballon on some plane then there is many configurations.\nI always try to solve problem by my self. I did over 700 but this one is really poorly stated.\nAfter looking at official solution and the image there it turns to be really simple (just intervals on a 1D).\n[@LeetCode](/LeetCode) plese add this image to the problem descrition.\n\n![image](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/288049/Figures/452/arrows.png)\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It is a bit pedantic to complain about them using \"sphere\" rather than \"circle\", and then propose an image where you drew \"ellipses\". I'm sure if they had put that image in the statement, there would have been comments like yours calling the question \"really stupid\" for being misleading.\n\nThey clarified explicitly that everything takes place in a 2D plane, so I don't think there's much confusion about whether we should consider the problem 3D, but I agree that a similar illustration would be nice add"
                    },
                    {
                        "username": "trsuhas21",
                        "content": "Tq for elucidating "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) I agree with you, I have posted in a comment that the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!! Even with baloons and stuff, arrow is a stupid analogy since it just passes a point in 2D plain. Better could have been a knife that is cutting sausages that are overlapping on x axis (the only axis).\\n\\nI would Ignore what calm27 is saying since that roughly translates to \"we should accept everything as is, and not give any constructive feedback\"."
                    },
                    {
                        "username": "calm27",
                        "content": "> I always try to solve problem by my self\n\nyou said it like other folks do otherwise to prove your assumption that wording is bad. \n\nmajor part solves it by themselves. no one like bad wording in descriptions, but we should accept the fact it is an initial part of the problem, and the purpose of it is to \"figure out\". \nlife would be easy if all problems were clear. "
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TIP: For `C++`, the input of annonymous compare function shold be reference, or you will get TLE."
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks, was stuck because of it for a while"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "[@kriket](/kriket) Definitely. Copying is always slower, I was just surprised that it will cause such a big difference in sorting."
                    },
                    {
                        "username": "close27",
                        "content": "I think it\\'s because pass by ref does not make new copies hence it is faster."
                    },
                    {
                        "username": "close27",
                        "content": "[@MC_JRen](/MC_JRen)Did run into the problem. Can you please explain how you figured it out?"
                    },
                    {
                        "username": "L39ND",
                        "content": "thats exactly what I need, thank you so much! "
                    },
                    {
                        "username": "Kis_shot",
                        "content": "thank you so much!!!it confused me a lot until i put \"&\" to pass through"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\\n\\nWe can understand by using an example:\\n\\nGiven an 2d array of size 4 with  [10,16] , [2,8] , [1,6] , [7,12]\\n\\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\\n\\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\\n\\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\\n\\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\\n\\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\\n\\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\\n\\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\\n\\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\\n\\nAt last, return the arrow counter.\\n\\nSolution link for better understanding: [https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest)\\n\\nI hope it helps ^_^"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Very clean solution!"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "wow, I used similar theory but I used stack for replacing two balloons with their overlap instead. Here is a better written solution :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "mausami",
                        "content": "Take care of the following test cases while sorting the array:\\n1. []\\n2. [[1,2],[2,3],[3,4],[4,5]]\\n3. [[-2147483646,-2147483645],[2147483646,2147483647]]\\n4. [[10,16],[2,8],[1,6],[7,12]]\\n5. [[1,2],[3,4],[5,6],[7,8]]\\n6. [[1,2]]\\n7. [[2,3],[2,3]]\\n"
                    },
                    {
                        "username": "dvakar",
                        "content": "8. [[77171087,133597895],[45117276,135064454],[80695788,90089372],[91705403,110208054],[52392754,127005153],[53999932,118094992],[11549676,55543044],[43947739,128157751],[55636226,105334812],[69348094,125645633]]"
                    },
                    {
                        "username": "srbssv",
                        "content": "What should we return in case of [[-2147483646,-2147483645],[2147483646,2147483647]]?"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "HUH, Interesting, Funny I didnt find any of these because my stack solution handled them all ok I guess. Here it is:: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "aditisingh10022018",
                        "content": "my test case is also failing at 3rd test case why?"
                    },
                    {
                        "username": "tajnur",
                        "content": "According to the constraints, empty points is not valid. Points should have at least one element..\\n"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "also, [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] "
                    },
                    {
                        "username": "santanusen",
                        "content": "It would have taken me hours to solve such problems a few months back. I was able to solve it in 15 mins today thanks to daily leetcoding. Leetcode definitely helps.\\n\\nTip:\\nsort the points, track how many consecutive points intersect (keep tracking and narrowing down the intersecting coordinates)."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Lovely Tip. I used stack to replace a set of overlapping balloons with their overlap and count the number of balloons end at left. Here is my solution: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I have the same feeling now and it makes me happy. For everyone, keep practicing and you\\'ll be rewarded, don\\'t give up! "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "MentalHealth--;\\nStress++;"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "\\uD83D\\uDE02\\u270C\\uFE0F"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\nWhy expected output for this is 2, as per given instructions it should be 1. Can anyone please give me an explanation, it will be very helpful."
                    }
                ]
            },
            {
                "id": 1742652,
                "content": [
                    {
                        "username": "wateryan17",
                        "content": "Apparently a new test case has been added recently. If you cannot pass this one, then it is because the result of subtraction is too large and thus the overflow is encountered. So don\\'t use `a-b` to compare when sorting. Use `Integer.compare(a,b)` instead!!!"
                    },
                    {
                        "username": "AJReach",
                        "content": "Thanks"
                    },
                    {
                        "username": "dmproni",
                        "content": "even better for Java use Comparator.comparingInt() for clarity :)"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Thanks a lot mate! Great observation! I had this exact problem!"
                    },
                    {
                        "username": "serkora",
                        "content": "[@nikhilsteamid](/nikhilsteamid) Just plain std::sort(v.begin(), v.end()) is enough, it handles sorting of 2D vectors by default, so no need to provide your own. (And you can also use templated STL comparison functions such as std::greater<std::vector<int>>() if you need a different order.)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You can use the below code in java. a-b is still working for sorting.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three cases. but yah for making short and neat code we should use either  Integer.compare(a,b) or lamda function.\\n//code\\n Arrays.sort(arr,new Comparator<int[]>(){\\n            public int compare(int[] a1,int[] a2){\\n               //  return Integer.compare(a1[0],a2[0]); \\n               if(a1[0]>a2[0]) return 1;\\n               else if(a1[0]<a2[0]) return -1;\\n               else return 0;\\n            }\\n        });"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "[@nikhilsteamid](/nikhilsteamid)  u can use lambda function to sort the array in c++\\n"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "what is the c++ alternative?"
                    },
                    {
                        "username": "carloseddy397",
                        "content": "`\\u201CLet me take a break of 5 minutes to browse the internet.\\u201D That\\u2019s how it starts. An hour later, you are still browsing.`"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Replying after exactly 1 year mate !\\nAnniversary of your comment \\uD83D\\uDC95\\uD83E\\uDD23"
                    },
                    {
                        "username": "S_Basu",
                        "content": "true"
                    },
                    {
                        "username": "mkohar",
                        "content": "Try using **Stay Focusd** chrome extension"
                    },
                    {
                        "username": "shanks21",
                        "content": "it\\'s like all of us are leading exact same lives"
                    },
                    {
                        "username": "choi_taek",
                        "content": "programming is 1% intelligence and 99% trying not  to get distracted by internet.\\nYou can try this extension pluckeye. Its great. "
                    },
                    {
                        "username": "vaibhavbhardwaj1987",
                        "content": "![image](https://assets.leetcode.com/users/images/743abf3b-788a-4da7-b576-f043cefe87c0_1603097643.8374152.png)\\n"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@srirambadalgama](/srirambadalgama) No it will give 2 only..\\nas first start will be 3\\nand then 4<=3 false...so count = 2 and now start = 5\\n1<=5 true \\nso result will be 2"
                    },
                    {
                        "username": "srirambadalgama",
                        "content": "I think your solution will give wrong answer for test case: [[1,10],[2,3],[4,5]].\\ncorrect ans is 2. But your soln will give 1."
                    },
                    {
                        "username": "khushimattu",
                        "content": "i have a small doubt. we are checking whether the xend of start is greater than the x start of the next one or not but we arent checking the condition if that is greater than the x ed of the next one?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I didn\\'t visualize the problem like this. It seems so simple now :)"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Nice observation bro, I just sorted and used stack to find overlaps like a dummy. Anyways, here is my dum-dum solution, Its beginner friendly and more intuitive I guess :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "[@Sledge_man](/Sledge_man) same question"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "So brilliant, I like the observation. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@bean_bean](/bean_bean) savage"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "[@Sledge_man](/Sledge_man) Nope, it has to go straight up"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "you are supposed to shoot the arrow vertically up. which means parallel to the y axis. "
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Enough guys, focus on the problem...  😁🧐"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Nice hair growth\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@yl245](/yl245) why do you focus on this? \\uD83D\\uDE02"
                    },
                    {
                        "username": "Sledge_man",
                        "content": "isnt the arrow supposed to go vertically up?\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "could\\'ve cropped out those hairy legs \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Description is really stupid.\n\"spherical balloon\" is a 3D object. If you know only single coordinate of each ballon on some plane then there is many configurations.\nI always try to solve problem by my self. I did over 700 but this one is really poorly stated.\nAfter looking at official solution and the image there it turns to be really simple (just intervals on a 1D).\n[@LeetCode](/LeetCode) plese add this image to the problem descrition.\n\n![image](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/288049/Figures/452/arrows.png)\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It is a bit pedantic to complain about them using \"sphere\" rather than \"circle\", and then propose an image where you drew \"ellipses\". I'm sure if they had put that image in the statement, there would have been comments like yours calling the question \"really stupid\" for being misleading.\n\nThey clarified explicitly that everything takes place in a 2D plane, so I don't think there's much confusion about whether we should consider the problem 3D, but I agree that a similar illustration would be nice add"
                    },
                    {
                        "username": "trsuhas21",
                        "content": "Tq for elucidating "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) I agree with you, I have posted in a comment that the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!! Even with baloons and stuff, arrow is a stupid analogy since it just passes a point in 2D plain. Better could have been a knife that is cutting sausages that are overlapping on x axis (the only axis).\\n\\nI would Ignore what calm27 is saying since that roughly translates to \"we should accept everything as is, and not give any constructive feedback\"."
                    },
                    {
                        "username": "calm27",
                        "content": "> I always try to solve problem by my self\n\nyou said it like other folks do otherwise to prove your assumption that wording is bad. \n\nmajor part solves it by themselves. no one like bad wording in descriptions, but we should accept the fact it is an initial part of the problem, and the purpose of it is to \"figure out\". \nlife would be easy if all problems were clear. "
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TIP: For `C++`, the input of annonymous compare function shold be reference, or you will get TLE."
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks, was stuck because of it for a while"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "[@kriket](/kriket) Definitely. Copying is always slower, I was just surprised that it will cause such a big difference in sorting."
                    },
                    {
                        "username": "close27",
                        "content": "I think it\\'s because pass by ref does not make new copies hence it is faster."
                    },
                    {
                        "username": "close27",
                        "content": "[@MC_JRen](/MC_JRen)Did run into the problem. Can you please explain how you figured it out?"
                    },
                    {
                        "username": "L39ND",
                        "content": "thats exactly what I need, thank you so much! "
                    },
                    {
                        "username": "Kis_shot",
                        "content": "thank you so much!!!it confused me a lot until i put \"&\" to pass through"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\\n\\nWe can understand by using an example:\\n\\nGiven an 2d array of size 4 with  [10,16] , [2,8] , [1,6] , [7,12]\\n\\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\\n\\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\\n\\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\\n\\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\\n\\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\\n\\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\\n\\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\\n\\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\\n\\nAt last, return the arrow counter.\\n\\nSolution link for better understanding: [https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest)\\n\\nI hope it helps ^_^"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Very clean solution!"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "wow, I used similar theory but I used stack for replacing two balloons with their overlap instead. Here is a better written solution :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "mausami",
                        "content": "Take care of the following test cases while sorting the array:\\n1. []\\n2. [[1,2],[2,3],[3,4],[4,5]]\\n3. [[-2147483646,-2147483645],[2147483646,2147483647]]\\n4. [[10,16],[2,8],[1,6],[7,12]]\\n5. [[1,2],[3,4],[5,6],[7,8]]\\n6. [[1,2]]\\n7. [[2,3],[2,3]]\\n"
                    },
                    {
                        "username": "dvakar",
                        "content": "8. [[77171087,133597895],[45117276,135064454],[80695788,90089372],[91705403,110208054],[52392754,127005153],[53999932,118094992],[11549676,55543044],[43947739,128157751],[55636226,105334812],[69348094,125645633]]"
                    },
                    {
                        "username": "srbssv",
                        "content": "What should we return in case of [[-2147483646,-2147483645],[2147483646,2147483647]]?"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "HUH, Interesting, Funny I didnt find any of these because my stack solution handled them all ok I guess. Here it is:: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "aditisingh10022018",
                        "content": "my test case is also failing at 3rd test case why?"
                    },
                    {
                        "username": "tajnur",
                        "content": "According to the constraints, empty points is not valid. Points should have at least one element..\\n"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "also, [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] "
                    },
                    {
                        "username": "santanusen",
                        "content": "It would have taken me hours to solve such problems a few months back. I was able to solve it in 15 mins today thanks to daily leetcoding. Leetcode definitely helps.\\n\\nTip:\\nsort the points, track how many consecutive points intersect (keep tracking and narrowing down the intersecting coordinates)."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Lovely Tip. I used stack to replace a set of overlapping balloons with their overlap and count the number of balloons end at left. Here is my solution: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I have the same feeling now and it makes me happy. For everyone, keep practicing and you\\'ll be rewarded, don\\'t give up! "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "MentalHealth--;\\nStress++;"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "\\uD83D\\uDE02\\u270C\\uFE0F"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\nWhy expected output for this is 2, as per given instructions it should be 1. Can anyone please give me an explanation, it will be very helpful."
                    }
                ]
            },
            {
                "id": 1742423,
                "content": [
                    {
                        "username": "wateryan17",
                        "content": "Apparently a new test case has been added recently. If you cannot pass this one, then it is because the result of subtraction is too large and thus the overflow is encountered. So don\\'t use `a-b` to compare when sorting. Use `Integer.compare(a,b)` instead!!!"
                    },
                    {
                        "username": "AJReach",
                        "content": "Thanks"
                    },
                    {
                        "username": "dmproni",
                        "content": "even better for Java use Comparator.comparingInt() for clarity :)"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Thanks a lot mate! Great observation! I had this exact problem!"
                    },
                    {
                        "username": "serkora",
                        "content": "[@nikhilsteamid](/nikhilsteamid) Just plain std::sort(v.begin(), v.end()) is enough, it handles sorting of 2D vectors by default, so no need to provide your own. (And you can also use templated STL comparison functions such as std::greater<std::vector<int>>() if you need a different order.)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You can use the below code in java. a-b is still working for sorting.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three cases. but yah for making short and neat code we should use either  Integer.compare(a,b) or lamda function.\\n//code\\n Arrays.sort(arr,new Comparator<int[]>(){\\n            public int compare(int[] a1,int[] a2){\\n               //  return Integer.compare(a1[0],a2[0]); \\n               if(a1[0]>a2[0]) return 1;\\n               else if(a1[0]<a2[0]) return -1;\\n               else return 0;\\n            }\\n        });"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "[@nikhilsteamid](/nikhilsteamid)  u can use lambda function to sort the array in c++\\n"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "what is the c++ alternative?"
                    },
                    {
                        "username": "carloseddy397",
                        "content": "`\\u201CLet me take a break of 5 minutes to browse the internet.\\u201D That\\u2019s how it starts. An hour later, you are still browsing.`"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Replying after exactly 1 year mate !\\nAnniversary of your comment \\uD83D\\uDC95\\uD83E\\uDD23"
                    },
                    {
                        "username": "S_Basu",
                        "content": "true"
                    },
                    {
                        "username": "mkohar",
                        "content": "Try using **Stay Focusd** chrome extension"
                    },
                    {
                        "username": "shanks21",
                        "content": "it\\'s like all of us are leading exact same lives"
                    },
                    {
                        "username": "choi_taek",
                        "content": "programming is 1% intelligence and 99% trying not  to get distracted by internet.\\nYou can try this extension pluckeye. Its great. "
                    },
                    {
                        "username": "vaibhavbhardwaj1987",
                        "content": "![image](https://assets.leetcode.com/users/images/743abf3b-788a-4da7-b576-f043cefe87c0_1603097643.8374152.png)\\n"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@srirambadalgama](/srirambadalgama) No it will give 2 only..\\nas first start will be 3\\nand then 4<=3 false...so count = 2 and now start = 5\\n1<=5 true \\nso result will be 2"
                    },
                    {
                        "username": "srirambadalgama",
                        "content": "I think your solution will give wrong answer for test case: [[1,10],[2,3],[4,5]].\\ncorrect ans is 2. But your soln will give 1."
                    },
                    {
                        "username": "khushimattu",
                        "content": "i have a small doubt. we are checking whether the xend of start is greater than the x start of the next one or not but we arent checking the condition if that is greater than the x ed of the next one?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I didn\\'t visualize the problem like this. It seems so simple now :)"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Nice observation bro, I just sorted and used stack to find overlaps like a dummy. Anyways, here is my dum-dum solution, Its beginner friendly and more intuitive I guess :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "[@Sledge_man](/Sledge_man) same question"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "So brilliant, I like the observation. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@bean_bean](/bean_bean) savage"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "[@Sledge_man](/Sledge_man) Nope, it has to go straight up"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "you are supposed to shoot the arrow vertically up. which means parallel to the y axis. "
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Enough guys, focus on the problem...  😁🧐"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Nice hair growth\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@yl245](/yl245) why do you focus on this? \\uD83D\\uDE02"
                    },
                    {
                        "username": "Sledge_man",
                        "content": "isnt the arrow supposed to go vertically up?\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "could\\'ve cropped out those hairy legs \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Description is really stupid.\n\"spherical balloon\" is a 3D object. If you know only single coordinate of each ballon on some plane then there is many configurations.\nI always try to solve problem by my self. I did over 700 but this one is really poorly stated.\nAfter looking at official solution and the image there it turns to be really simple (just intervals on a 1D).\n[@LeetCode](/LeetCode) plese add this image to the problem descrition.\n\n![image](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/288049/Figures/452/arrows.png)\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It is a bit pedantic to complain about them using \"sphere\" rather than \"circle\", and then propose an image where you drew \"ellipses\". I'm sure if they had put that image in the statement, there would have been comments like yours calling the question \"really stupid\" for being misleading.\n\nThey clarified explicitly that everything takes place in a 2D plane, so I don't think there's much confusion about whether we should consider the problem 3D, but I agree that a similar illustration would be nice add"
                    },
                    {
                        "username": "trsuhas21",
                        "content": "Tq for elucidating "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) I agree with you, I have posted in a comment that the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!! Even with baloons and stuff, arrow is a stupid analogy since it just passes a point in 2D plain. Better could have been a knife that is cutting sausages that are overlapping on x axis (the only axis).\\n\\nI would Ignore what calm27 is saying since that roughly translates to \"we should accept everything as is, and not give any constructive feedback\"."
                    },
                    {
                        "username": "calm27",
                        "content": "> I always try to solve problem by my self\n\nyou said it like other folks do otherwise to prove your assumption that wording is bad. \n\nmajor part solves it by themselves. no one like bad wording in descriptions, but we should accept the fact it is an initial part of the problem, and the purpose of it is to \"figure out\". \nlife would be easy if all problems were clear. "
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TIP: For `C++`, the input of annonymous compare function shold be reference, or you will get TLE."
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks, was stuck because of it for a while"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "[@kriket](/kriket) Definitely. Copying is always slower, I was just surprised that it will cause such a big difference in sorting."
                    },
                    {
                        "username": "close27",
                        "content": "I think it\\'s because pass by ref does not make new copies hence it is faster."
                    },
                    {
                        "username": "close27",
                        "content": "[@MC_JRen](/MC_JRen)Did run into the problem. Can you please explain how you figured it out?"
                    },
                    {
                        "username": "L39ND",
                        "content": "thats exactly what I need, thank you so much! "
                    },
                    {
                        "username": "Kis_shot",
                        "content": "thank you so much!!!it confused me a lot until i put \"&\" to pass through"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\\n\\nWe can understand by using an example:\\n\\nGiven an 2d array of size 4 with  [10,16] , [2,8] , [1,6] , [7,12]\\n\\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\\n\\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\\n\\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\\n\\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\\n\\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\\n\\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\\n\\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\\n\\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\\n\\nAt last, return the arrow counter.\\n\\nSolution link for better understanding: [https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest)\\n\\nI hope it helps ^_^"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Very clean solution!"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "wow, I used similar theory but I used stack for replacing two balloons with their overlap instead. Here is a better written solution :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "mausami",
                        "content": "Take care of the following test cases while sorting the array:\\n1. []\\n2. [[1,2],[2,3],[3,4],[4,5]]\\n3. [[-2147483646,-2147483645],[2147483646,2147483647]]\\n4. [[10,16],[2,8],[1,6],[7,12]]\\n5. [[1,2],[3,4],[5,6],[7,8]]\\n6. [[1,2]]\\n7. [[2,3],[2,3]]\\n"
                    },
                    {
                        "username": "dvakar",
                        "content": "8. [[77171087,133597895],[45117276,135064454],[80695788,90089372],[91705403,110208054],[52392754,127005153],[53999932,118094992],[11549676,55543044],[43947739,128157751],[55636226,105334812],[69348094,125645633]]"
                    },
                    {
                        "username": "srbssv",
                        "content": "What should we return in case of [[-2147483646,-2147483645],[2147483646,2147483647]]?"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "HUH, Interesting, Funny I didnt find any of these because my stack solution handled them all ok I guess. Here it is:: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "aditisingh10022018",
                        "content": "my test case is also failing at 3rd test case why?"
                    },
                    {
                        "username": "tajnur",
                        "content": "According to the constraints, empty points is not valid. Points should have at least one element..\\n"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "also, [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] "
                    },
                    {
                        "username": "santanusen",
                        "content": "It would have taken me hours to solve such problems a few months back. I was able to solve it in 15 mins today thanks to daily leetcoding. Leetcode definitely helps.\\n\\nTip:\\nsort the points, track how many consecutive points intersect (keep tracking and narrowing down the intersecting coordinates)."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Lovely Tip. I used stack to replace a set of overlapping balloons with their overlap and count the number of balloons end at left. Here is my solution: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I have the same feeling now and it makes me happy. For everyone, keep practicing and you\\'ll be rewarded, don\\'t give up! "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "MentalHealth--;\\nStress++;"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "\\uD83D\\uDE02\\u270C\\uFE0F"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\nWhy expected output for this is 2, as per given instructions it should be 1. Can anyone please give me an explanation, it will be very helpful."
                    }
                ]
            },
            {
                "id": 1565808,
                "content": [
                    {
                        "username": "wateryan17",
                        "content": "Apparently a new test case has been added recently. If you cannot pass this one, then it is because the result of subtraction is too large and thus the overflow is encountered. So don\\'t use `a-b` to compare when sorting. Use `Integer.compare(a,b)` instead!!!"
                    },
                    {
                        "username": "AJReach",
                        "content": "Thanks"
                    },
                    {
                        "username": "dmproni",
                        "content": "even better for Java use Comparator.comparingInt() for clarity :)"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Thanks a lot mate! Great observation! I had this exact problem!"
                    },
                    {
                        "username": "serkora",
                        "content": "[@nikhilsteamid](/nikhilsteamid) Just plain std::sort(v.begin(), v.end()) is enough, it handles sorting of 2D vectors by default, so no need to provide your own. (And you can also use templated STL comparison functions such as std::greater<std::vector<int>>() if you need a different order.)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You can use the below code in java. a-b is still working for sorting.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three cases. but yah for making short and neat code we should use either  Integer.compare(a,b) or lamda function.\\n//code\\n Arrays.sort(arr,new Comparator<int[]>(){\\n            public int compare(int[] a1,int[] a2){\\n               //  return Integer.compare(a1[0],a2[0]); \\n               if(a1[0]>a2[0]) return 1;\\n               else if(a1[0]<a2[0]) return -1;\\n               else return 0;\\n            }\\n        });"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "[@nikhilsteamid](/nikhilsteamid)  u can use lambda function to sort the array in c++\\n"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "what is the c++ alternative?"
                    },
                    {
                        "username": "carloseddy397",
                        "content": "`\\u201CLet me take a break of 5 minutes to browse the internet.\\u201D That\\u2019s how it starts. An hour later, you are still browsing.`"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Replying after exactly 1 year mate !\\nAnniversary of your comment \\uD83D\\uDC95\\uD83E\\uDD23"
                    },
                    {
                        "username": "S_Basu",
                        "content": "true"
                    },
                    {
                        "username": "mkohar",
                        "content": "Try using **Stay Focusd** chrome extension"
                    },
                    {
                        "username": "shanks21",
                        "content": "it\\'s like all of us are leading exact same lives"
                    },
                    {
                        "username": "choi_taek",
                        "content": "programming is 1% intelligence and 99% trying not  to get distracted by internet.\\nYou can try this extension pluckeye. Its great. "
                    },
                    {
                        "username": "vaibhavbhardwaj1987",
                        "content": "![image](https://assets.leetcode.com/users/images/743abf3b-788a-4da7-b576-f043cefe87c0_1603097643.8374152.png)\\n"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@srirambadalgama](/srirambadalgama) No it will give 2 only..\\nas first start will be 3\\nand then 4<=3 false...so count = 2 and now start = 5\\n1<=5 true \\nso result will be 2"
                    },
                    {
                        "username": "srirambadalgama",
                        "content": "I think your solution will give wrong answer for test case: [[1,10],[2,3],[4,5]].\\ncorrect ans is 2. But your soln will give 1."
                    },
                    {
                        "username": "khushimattu",
                        "content": "i have a small doubt. we are checking whether the xend of start is greater than the x start of the next one or not but we arent checking the condition if that is greater than the x ed of the next one?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I didn\\'t visualize the problem like this. It seems so simple now :)"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Nice observation bro, I just sorted and used stack to find overlaps like a dummy. Anyways, here is my dum-dum solution, Its beginner friendly and more intuitive I guess :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "[@Sledge_man](/Sledge_man) same question"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "So brilliant, I like the observation. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@bean_bean](/bean_bean) savage"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "[@Sledge_man](/Sledge_man) Nope, it has to go straight up"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "you are supposed to shoot the arrow vertically up. which means parallel to the y axis. "
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Enough guys, focus on the problem...  😁🧐"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Nice hair growth\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@yl245](/yl245) why do you focus on this? \\uD83D\\uDE02"
                    },
                    {
                        "username": "Sledge_man",
                        "content": "isnt the arrow supposed to go vertically up?\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "could\\'ve cropped out those hairy legs \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Description is really stupid.\n\"spherical balloon\" is a 3D object. If you know only single coordinate of each ballon on some plane then there is many configurations.\nI always try to solve problem by my self. I did over 700 but this one is really poorly stated.\nAfter looking at official solution and the image there it turns to be really simple (just intervals on a 1D).\n[@LeetCode](/LeetCode) plese add this image to the problem descrition.\n\n![image](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/288049/Figures/452/arrows.png)\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It is a bit pedantic to complain about them using \"sphere\" rather than \"circle\", and then propose an image where you drew \"ellipses\". I'm sure if they had put that image in the statement, there would have been comments like yours calling the question \"really stupid\" for being misleading.\n\nThey clarified explicitly that everything takes place in a 2D plane, so I don't think there's much confusion about whether we should consider the problem 3D, but I agree that a similar illustration would be nice add"
                    },
                    {
                        "username": "trsuhas21",
                        "content": "Tq for elucidating "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) I agree with you, I have posted in a comment that the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!! Even with baloons and stuff, arrow is a stupid analogy since it just passes a point in 2D plain. Better could have been a knife that is cutting sausages that are overlapping on x axis (the only axis).\\n\\nI would Ignore what calm27 is saying since that roughly translates to \"we should accept everything as is, and not give any constructive feedback\"."
                    },
                    {
                        "username": "calm27",
                        "content": "> I always try to solve problem by my self\n\nyou said it like other folks do otherwise to prove your assumption that wording is bad. \n\nmajor part solves it by themselves. no one like bad wording in descriptions, but we should accept the fact it is an initial part of the problem, and the purpose of it is to \"figure out\". \nlife would be easy if all problems were clear. "
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TIP: For `C++`, the input of annonymous compare function shold be reference, or you will get TLE."
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks, was stuck because of it for a while"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "[@kriket](/kriket) Definitely. Copying is always slower, I was just surprised that it will cause such a big difference in sorting."
                    },
                    {
                        "username": "close27",
                        "content": "I think it\\'s because pass by ref does not make new copies hence it is faster."
                    },
                    {
                        "username": "close27",
                        "content": "[@MC_JRen](/MC_JRen)Did run into the problem. Can you please explain how you figured it out?"
                    },
                    {
                        "username": "L39ND",
                        "content": "thats exactly what I need, thank you so much! "
                    },
                    {
                        "username": "Kis_shot",
                        "content": "thank you so much!!!it confused me a lot until i put \"&\" to pass through"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\\n\\nWe can understand by using an example:\\n\\nGiven an 2d array of size 4 with  [10,16] , [2,8] , [1,6] , [7,12]\\n\\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\\n\\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\\n\\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\\n\\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\\n\\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\\n\\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\\n\\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\\n\\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\\n\\nAt last, return the arrow counter.\\n\\nSolution link for better understanding: [https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest)\\n\\nI hope it helps ^_^"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Very clean solution!"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "wow, I used similar theory but I used stack for replacing two balloons with their overlap instead. Here is a better written solution :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "mausami",
                        "content": "Take care of the following test cases while sorting the array:\\n1. []\\n2. [[1,2],[2,3],[3,4],[4,5]]\\n3. [[-2147483646,-2147483645],[2147483646,2147483647]]\\n4. [[10,16],[2,8],[1,6],[7,12]]\\n5. [[1,2],[3,4],[5,6],[7,8]]\\n6. [[1,2]]\\n7. [[2,3],[2,3]]\\n"
                    },
                    {
                        "username": "dvakar",
                        "content": "8. [[77171087,133597895],[45117276,135064454],[80695788,90089372],[91705403,110208054],[52392754,127005153],[53999932,118094992],[11549676,55543044],[43947739,128157751],[55636226,105334812],[69348094,125645633]]"
                    },
                    {
                        "username": "srbssv",
                        "content": "What should we return in case of [[-2147483646,-2147483645],[2147483646,2147483647]]?"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "HUH, Interesting, Funny I didnt find any of these because my stack solution handled them all ok I guess. Here it is:: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "aditisingh10022018",
                        "content": "my test case is also failing at 3rd test case why?"
                    },
                    {
                        "username": "tajnur",
                        "content": "According to the constraints, empty points is not valid. Points should have at least one element..\\n"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "also, [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] "
                    },
                    {
                        "username": "santanusen",
                        "content": "It would have taken me hours to solve such problems a few months back. I was able to solve it in 15 mins today thanks to daily leetcoding. Leetcode definitely helps.\\n\\nTip:\\nsort the points, track how many consecutive points intersect (keep tracking and narrowing down the intersecting coordinates)."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Lovely Tip. I used stack to replace a set of overlapping balloons with their overlap and count the number of balloons end at left. Here is my solution: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I have the same feeling now and it makes me happy. For everyone, keep practicing and you\\'ll be rewarded, don\\'t give up! "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "MentalHealth--;\\nStress++;"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "\\uD83D\\uDE02\\u270C\\uFE0F"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\nWhy expected output for this is 2, as per given instructions it should be 1. Can anyone please give me an explanation, it will be very helpful."
                    }
                ]
            },
            {
                "id": 1564712,
                "content": [
                    {
                        "username": "wateryan17",
                        "content": "Apparently a new test case has been added recently. If you cannot pass this one, then it is because the result of subtraction is too large and thus the overflow is encountered. So don\\'t use `a-b` to compare when sorting. Use `Integer.compare(a,b)` instead!!!"
                    },
                    {
                        "username": "AJReach",
                        "content": "Thanks"
                    },
                    {
                        "username": "dmproni",
                        "content": "even better for Java use Comparator.comparingInt() for clarity :)"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Thanks a lot mate! Great observation! I had this exact problem!"
                    },
                    {
                        "username": "serkora",
                        "content": "[@nikhilsteamid](/nikhilsteamid) Just plain std::sort(v.begin(), v.end()) is enough, it handles sorting of 2D vectors by default, so no need to provide your own. (And you can also use templated STL comparison functions such as std::greater<std::vector<int>>() if you need a different order.)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You can use the below code in java. a-b is still working for sorting.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three cases. but yah for making short and neat code we should use either  Integer.compare(a,b) or lamda function.\\n//code\\n Arrays.sort(arr,new Comparator<int[]>(){\\n            public int compare(int[] a1,int[] a2){\\n               //  return Integer.compare(a1[0],a2[0]); \\n               if(a1[0]>a2[0]) return 1;\\n               else if(a1[0]<a2[0]) return -1;\\n               else return 0;\\n            }\\n        });"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "[@nikhilsteamid](/nikhilsteamid)  u can use lambda function to sort the array in c++\\n"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "what is the c++ alternative?"
                    },
                    {
                        "username": "carloseddy397",
                        "content": "`\\u201CLet me take a break of 5 minutes to browse the internet.\\u201D That\\u2019s how it starts. An hour later, you are still browsing.`"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Replying after exactly 1 year mate !\\nAnniversary of your comment \\uD83D\\uDC95\\uD83E\\uDD23"
                    },
                    {
                        "username": "S_Basu",
                        "content": "true"
                    },
                    {
                        "username": "mkohar",
                        "content": "Try using **Stay Focusd** chrome extension"
                    },
                    {
                        "username": "shanks21",
                        "content": "it\\'s like all of us are leading exact same lives"
                    },
                    {
                        "username": "choi_taek",
                        "content": "programming is 1% intelligence and 99% trying not  to get distracted by internet.\\nYou can try this extension pluckeye. Its great. "
                    },
                    {
                        "username": "vaibhavbhardwaj1987",
                        "content": "![image](https://assets.leetcode.com/users/images/743abf3b-788a-4da7-b576-f043cefe87c0_1603097643.8374152.png)\\n"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@srirambadalgama](/srirambadalgama) No it will give 2 only..\\nas first start will be 3\\nand then 4<=3 false...so count = 2 and now start = 5\\n1<=5 true \\nso result will be 2"
                    },
                    {
                        "username": "srirambadalgama",
                        "content": "I think your solution will give wrong answer for test case: [[1,10],[2,3],[4,5]].\\ncorrect ans is 2. But your soln will give 1."
                    },
                    {
                        "username": "khushimattu",
                        "content": "i have a small doubt. we are checking whether the xend of start is greater than the x start of the next one or not but we arent checking the condition if that is greater than the x ed of the next one?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I didn\\'t visualize the problem like this. It seems so simple now :)"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Nice observation bro, I just sorted and used stack to find overlaps like a dummy. Anyways, here is my dum-dum solution, Its beginner friendly and more intuitive I guess :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "[@Sledge_man](/Sledge_man) same question"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "So brilliant, I like the observation. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@bean_bean](/bean_bean) savage"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "[@Sledge_man](/Sledge_man) Nope, it has to go straight up"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "you are supposed to shoot the arrow vertically up. which means parallel to the y axis. "
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Enough guys, focus on the problem...  😁🧐"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Nice hair growth\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@yl245](/yl245) why do you focus on this? \\uD83D\\uDE02"
                    },
                    {
                        "username": "Sledge_man",
                        "content": "isnt the arrow supposed to go vertically up?\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "could\\'ve cropped out those hairy legs \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Description is really stupid.\n\"spherical balloon\" is a 3D object. If you know only single coordinate of each ballon on some plane then there is many configurations.\nI always try to solve problem by my self. I did over 700 but this one is really poorly stated.\nAfter looking at official solution and the image there it turns to be really simple (just intervals on a 1D).\n[@LeetCode](/LeetCode) plese add this image to the problem descrition.\n\n![image](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/288049/Figures/452/arrows.png)\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It is a bit pedantic to complain about them using \"sphere\" rather than \"circle\", and then propose an image where you drew \"ellipses\". I'm sure if they had put that image in the statement, there would have been comments like yours calling the question \"really stupid\" for being misleading.\n\nThey clarified explicitly that everything takes place in a 2D plane, so I don't think there's much confusion about whether we should consider the problem 3D, but I agree that a similar illustration would be nice add"
                    },
                    {
                        "username": "trsuhas21",
                        "content": "Tq for elucidating "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) I agree with you, I have posted in a comment that the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!! Even with baloons and stuff, arrow is a stupid analogy since it just passes a point in 2D plain. Better could have been a knife that is cutting sausages that are overlapping on x axis (the only axis).\\n\\nI would Ignore what calm27 is saying since that roughly translates to \"we should accept everything as is, and not give any constructive feedback\"."
                    },
                    {
                        "username": "calm27",
                        "content": "> I always try to solve problem by my self\n\nyou said it like other folks do otherwise to prove your assumption that wording is bad. \n\nmajor part solves it by themselves. no one like bad wording in descriptions, but we should accept the fact it is an initial part of the problem, and the purpose of it is to \"figure out\". \nlife would be easy if all problems were clear. "
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TIP: For `C++`, the input of annonymous compare function shold be reference, or you will get TLE."
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks, was stuck because of it for a while"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "[@kriket](/kriket) Definitely. Copying is always slower, I was just surprised that it will cause such a big difference in sorting."
                    },
                    {
                        "username": "close27",
                        "content": "I think it\\'s because pass by ref does not make new copies hence it is faster."
                    },
                    {
                        "username": "close27",
                        "content": "[@MC_JRen](/MC_JRen)Did run into the problem. Can you please explain how you figured it out?"
                    },
                    {
                        "username": "L39ND",
                        "content": "thats exactly what I need, thank you so much! "
                    },
                    {
                        "username": "Kis_shot",
                        "content": "thank you so much!!!it confused me a lot until i put \"&\" to pass through"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\\n\\nWe can understand by using an example:\\n\\nGiven an 2d array of size 4 with  [10,16] , [2,8] , [1,6] , [7,12]\\n\\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\\n\\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\\n\\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\\n\\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\\n\\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\\n\\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\\n\\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\\n\\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\\n\\nAt last, return the arrow counter.\\n\\nSolution link for better understanding: [https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest)\\n\\nI hope it helps ^_^"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Very clean solution!"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "wow, I used similar theory but I used stack for replacing two balloons with their overlap instead. Here is a better written solution :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "mausami",
                        "content": "Take care of the following test cases while sorting the array:\\n1. []\\n2. [[1,2],[2,3],[3,4],[4,5]]\\n3. [[-2147483646,-2147483645],[2147483646,2147483647]]\\n4. [[10,16],[2,8],[1,6],[7,12]]\\n5. [[1,2],[3,4],[5,6],[7,8]]\\n6. [[1,2]]\\n7. [[2,3],[2,3]]\\n"
                    },
                    {
                        "username": "dvakar",
                        "content": "8. [[77171087,133597895],[45117276,135064454],[80695788,90089372],[91705403,110208054],[52392754,127005153],[53999932,118094992],[11549676,55543044],[43947739,128157751],[55636226,105334812],[69348094,125645633]]"
                    },
                    {
                        "username": "srbssv",
                        "content": "What should we return in case of [[-2147483646,-2147483645],[2147483646,2147483647]]?"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "HUH, Interesting, Funny I didnt find any of these because my stack solution handled them all ok I guess. Here it is:: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "aditisingh10022018",
                        "content": "my test case is also failing at 3rd test case why?"
                    },
                    {
                        "username": "tajnur",
                        "content": "According to the constraints, empty points is not valid. Points should have at least one element..\\n"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "also, [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] "
                    },
                    {
                        "username": "santanusen",
                        "content": "It would have taken me hours to solve such problems a few months back. I was able to solve it in 15 mins today thanks to daily leetcoding. Leetcode definitely helps.\\n\\nTip:\\nsort the points, track how many consecutive points intersect (keep tracking and narrowing down the intersecting coordinates)."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Lovely Tip. I used stack to replace a set of overlapping balloons with their overlap and count the number of balloons end at left. Here is my solution: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I have the same feeling now and it makes me happy. For everyone, keep practicing and you\\'ll be rewarded, don\\'t give up! "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "MentalHealth--;\\nStress++;"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "\\uD83D\\uDE02\\u270C\\uFE0F"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\nWhy expected output for this is 2, as per given instructions it should be 1. Can anyone please give me an explanation, it will be very helpful."
                    }
                ]
            },
            {
                "id": 1576221,
                "content": [
                    {
                        "username": "wateryan17",
                        "content": "Apparently a new test case has been added recently. If you cannot pass this one, then it is because the result of subtraction is too large and thus the overflow is encountered. So don\\'t use `a-b` to compare when sorting. Use `Integer.compare(a,b)` instead!!!"
                    },
                    {
                        "username": "AJReach",
                        "content": "Thanks"
                    },
                    {
                        "username": "dmproni",
                        "content": "even better for Java use Comparator.comparingInt() for clarity :)"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Thanks a lot mate! Great observation! I had this exact problem!"
                    },
                    {
                        "username": "serkora",
                        "content": "[@nikhilsteamid](/nikhilsteamid) Just plain std::sort(v.begin(), v.end()) is enough, it handles sorting of 2D vectors by default, so no need to provide your own. (And you can also use templated STL comparison functions such as std::greater<std::vector<int>>() if you need a different order.)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You can use the below code in java. a-b is still working for sorting.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three cases. but yah for making short and neat code we should use either  Integer.compare(a,b) or lamda function.\\n//code\\n Arrays.sort(arr,new Comparator<int[]>(){\\n            public int compare(int[] a1,int[] a2){\\n               //  return Integer.compare(a1[0],a2[0]); \\n               if(a1[0]>a2[0]) return 1;\\n               else if(a1[0]<a2[0]) return -1;\\n               else return 0;\\n            }\\n        });"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "[@nikhilsteamid](/nikhilsteamid)  u can use lambda function to sort the array in c++\\n"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "what is the c++ alternative?"
                    },
                    {
                        "username": "carloseddy397",
                        "content": "`\\u201CLet me take a break of 5 minutes to browse the internet.\\u201D That\\u2019s how it starts. An hour later, you are still browsing.`"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Replying after exactly 1 year mate !\\nAnniversary of your comment \\uD83D\\uDC95\\uD83E\\uDD23"
                    },
                    {
                        "username": "S_Basu",
                        "content": "true"
                    },
                    {
                        "username": "mkohar",
                        "content": "Try using **Stay Focusd** chrome extension"
                    },
                    {
                        "username": "shanks21",
                        "content": "it\\'s like all of us are leading exact same lives"
                    },
                    {
                        "username": "choi_taek",
                        "content": "programming is 1% intelligence and 99% trying not  to get distracted by internet.\\nYou can try this extension pluckeye. Its great. "
                    },
                    {
                        "username": "vaibhavbhardwaj1987",
                        "content": "![image](https://assets.leetcode.com/users/images/743abf3b-788a-4da7-b576-f043cefe87c0_1603097643.8374152.png)\\n"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@srirambadalgama](/srirambadalgama) No it will give 2 only..\\nas first start will be 3\\nand then 4<=3 false...so count = 2 and now start = 5\\n1<=5 true \\nso result will be 2"
                    },
                    {
                        "username": "srirambadalgama",
                        "content": "I think your solution will give wrong answer for test case: [[1,10],[2,3],[4,5]].\\ncorrect ans is 2. But your soln will give 1."
                    },
                    {
                        "username": "khushimattu",
                        "content": "i have a small doubt. we are checking whether the xend of start is greater than the x start of the next one or not but we arent checking the condition if that is greater than the x ed of the next one?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I didn\\'t visualize the problem like this. It seems so simple now :)"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Nice observation bro, I just sorted and used stack to find overlaps like a dummy. Anyways, here is my dum-dum solution, Its beginner friendly and more intuitive I guess :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "[@Sledge_man](/Sledge_man) same question"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "So brilliant, I like the observation. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@bean_bean](/bean_bean) savage"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "[@Sledge_man](/Sledge_man) Nope, it has to go straight up"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "you are supposed to shoot the arrow vertically up. which means parallel to the y axis. "
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Enough guys, focus on the problem...  😁🧐"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Nice hair growth\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@yl245](/yl245) why do you focus on this? \\uD83D\\uDE02"
                    },
                    {
                        "username": "Sledge_man",
                        "content": "isnt the arrow supposed to go vertically up?\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "could\\'ve cropped out those hairy legs \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Description is really stupid.\n\"spherical balloon\" is a 3D object. If you know only single coordinate of each ballon on some plane then there is many configurations.\nI always try to solve problem by my self. I did over 700 but this one is really poorly stated.\nAfter looking at official solution and the image there it turns to be really simple (just intervals on a 1D).\n[@LeetCode](/LeetCode) plese add this image to the problem descrition.\n\n![image](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/288049/Figures/452/arrows.png)\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It is a bit pedantic to complain about them using \"sphere\" rather than \"circle\", and then propose an image where you drew \"ellipses\". I'm sure if they had put that image in the statement, there would have been comments like yours calling the question \"really stupid\" for being misleading.\n\nThey clarified explicitly that everything takes place in a 2D plane, so I don't think there's much confusion about whether we should consider the problem 3D, but I agree that a similar illustration would be nice add"
                    },
                    {
                        "username": "trsuhas21",
                        "content": "Tq for elucidating "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) I agree with you, I have posted in a comment that the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!! Even with baloons and stuff, arrow is a stupid analogy since it just passes a point in 2D plain. Better could have been a knife that is cutting sausages that are overlapping on x axis (the only axis).\\n\\nI would Ignore what calm27 is saying since that roughly translates to \"we should accept everything as is, and not give any constructive feedback\"."
                    },
                    {
                        "username": "calm27",
                        "content": "> I always try to solve problem by my self\n\nyou said it like other folks do otherwise to prove your assumption that wording is bad. \n\nmajor part solves it by themselves. no one like bad wording in descriptions, but we should accept the fact it is an initial part of the problem, and the purpose of it is to \"figure out\". \nlife would be easy if all problems were clear. "
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TIP: For `C++`, the input of annonymous compare function shold be reference, or you will get TLE."
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks, was stuck because of it for a while"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "[@kriket](/kriket) Definitely. Copying is always slower, I was just surprised that it will cause such a big difference in sorting."
                    },
                    {
                        "username": "close27",
                        "content": "I think it\\'s because pass by ref does not make new copies hence it is faster."
                    },
                    {
                        "username": "close27",
                        "content": "[@MC_JRen](/MC_JRen)Did run into the problem. Can you please explain how you figured it out?"
                    },
                    {
                        "username": "L39ND",
                        "content": "thats exactly what I need, thank you so much! "
                    },
                    {
                        "username": "Kis_shot",
                        "content": "thank you so much!!!it confused me a lot until i put \"&\" to pass through"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\\n\\nWe can understand by using an example:\\n\\nGiven an 2d array of size 4 with  [10,16] , [2,8] , [1,6] , [7,12]\\n\\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\\n\\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\\n\\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\\n\\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\\n\\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\\n\\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\\n\\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\\n\\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\\n\\nAt last, return the arrow counter.\\n\\nSolution link for better understanding: [https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest)\\n\\nI hope it helps ^_^"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Very clean solution!"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "wow, I used similar theory but I used stack for replacing two balloons with their overlap instead. Here is a better written solution :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "mausami",
                        "content": "Take care of the following test cases while sorting the array:\\n1. []\\n2. [[1,2],[2,3],[3,4],[4,5]]\\n3. [[-2147483646,-2147483645],[2147483646,2147483647]]\\n4. [[10,16],[2,8],[1,6],[7,12]]\\n5. [[1,2],[3,4],[5,6],[7,8]]\\n6. [[1,2]]\\n7. [[2,3],[2,3]]\\n"
                    },
                    {
                        "username": "dvakar",
                        "content": "8. [[77171087,133597895],[45117276,135064454],[80695788,90089372],[91705403,110208054],[52392754,127005153],[53999932,118094992],[11549676,55543044],[43947739,128157751],[55636226,105334812],[69348094,125645633]]"
                    },
                    {
                        "username": "srbssv",
                        "content": "What should we return in case of [[-2147483646,-2147483645],[2147483646,2147483647]]?"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "HUH, Interesting, Funny I didnt find any of these because my stack solution handled them all ok I guess. Here it is:: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "aditisingh10022018",
                        "content": "my test case is also failing at 3rd test case why?"
                    },
                    {
                        "username": "tajnur",
                        "content": "According to the constraints, empty points is not valid. Points should have at least one element..\\n"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "also, [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] "
                    },
                    {
                        "username": "santanusen",
                        "content": "It would have taken me hours to solve such problems a few months back. I was able to solve it in 15 mins today thanks to daily leetcoding. Leetcode definitely helps.\\n\\nTip:\\nsort the points, track how many consecutive points intersect (keep tracking and narrowing down the intersecting coordinates)."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Lovely Tip. I used stack to replace a set of overlapping balloons with their overlap and count the number of balloons end at left. Here is my solution: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I have the same feeling now and it makes me happy. For everyone, keep practicing and you\\'ll be rewarded, don\\'t give up! "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "MentalHealth--;\\nStress++;"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "\\uD83D\\uDE02\\u270C\\uFE0F"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\nWhy expected output for this is 2, as per given instructions it should be 1. Can anyone please give me an explanation, it will be very helpful."
                    }
                ]
            },
            {
                "id": 1574502,
                "content": [
                    {
                        "username": "wateryan17",
                        "content": "Apparently a new test case has been added recently. If you cannot pass this one, then it is because the result of subtraction is too large and thus the overflow is encountered. So don\\'t use `a-b` to compare when sorting. Use `Integer.compare(a,b)` instead!!!"
                    },
                    {
                        "username": "AJReach",
                        "content": "Thanks"
                    },
                    {
                        "username": "dmproni",
                        "content": "even better for Java use Comparator.comparingInt() for clarity :)"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Thanks a lot mate! Great observation! I had this exact problem!"
                    },
                    {
                        "username": "serkora",
                        "content": "[@nikhilsteamid](/nikhilsteamid) Just plain std::sort(v.begin(), v.end()) is enough, it handles sorting of 2D vectors by default, so no need to provide your own. (And you can also use templated STL comparison functions such as std::greater<std::vector<int>>() if you need a different order.)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You can use the below code in java. a-b is still working for sorting.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three cases. but yah for making short and neat code we should use either  Integer.compare(a,b) or lamda function.\\n//code\\n Arrays.sort(arr,new Comparator<int[]>(){\\n            public int compare(int[] a1,int[] a2){\\n               //  return Integer.compare(a1[0],a2[0]); \\n               if(a1[0]>a2[0]) return 1;\\n               else if(a1[0]<a2[0]) return -1;\\n               else return 0;\\n            }\\n        });"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "[@nikhilsteamid](/nikhilsteamid)  u can use lambda function to sort the array in c++\\n"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "what is the c++ alternative?"
                    },
                    {
                        "username": "carloseddy397",
                        "content": "`\\u201CLet me take a break of 5 minutes to browse the internet.\\u201D That\\u2019s how it starts. An hour later, you are still browsing.`"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Replying after exactly 1 year mate !\\nAnniversary of your comment \\uD83D\\uDC95\\uD83E\\uDD23"
                    },
                    {
                        "username": "S_Basu",
                        "content": "true"
                    },
                    {
                        "username": "mkohar",
                        "content": "Try using **Stay Focusd** chrome extension"
                    },
                    {
                        "username": "shanks21",
                        "content": "it\\'s like all of us are leading exact same lives"
                    },
                    {
                        "username": "choi_taek",
                        "content": "programming is 1% intelligence and 99% trying not  to get distracted by internet.\\nYou can try this extension pluckeye. Its great. "
                    },
                    {
                        "username": "vaibhavbhardwaj1987",
                        "content": "![image](https://assets.leetcode.com/users/images/743abf3b-788a-4da7-b576-f043cefe87c0_1603097643.8374152.png)\\n"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@srirambadalgama](/srirambadalgama) No it will give 2 only..\\nas first start will be 3\\nand then 4<=3 false...so count = 2 and now start = 5\\n1<=5 true \\nso result will be 2"
                    },
                    {
                        "username": "srirambadalgama",
                        "content": "I think your solution will give wrong answer for test case: [[1,10],[2,3],[4,5]].\\ncorrect ans is 2. But your soln will give 1."
                    },
                    {
                        "username": "khushimattu",
                        "content": "i have a small doubt. we are checking whether the xend of start is greater than the x start of the next one or not but we arent checking the condition if that is greater than the x ed of the next one?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I didn\\'t visualize the problem like this. It seems so simple now :)"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Nice observation bro, I just sorted and used stack to find overlaps like a dummy. Anyways, here is my dum-dum solution, Its beginner friendly and more intuitive I guess :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "[@Sledge_man](/Sledge_man) same question"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "So brilliant, I like the observation. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@bean_bean](/bean_bean) savage"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "[@Sledge_man](/Sledge_man) Nope, it has to go straight up"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "you are supposed to shoot the arrow vertically up. which means parallel to the y axis. "
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Enough guys, focus on the problem...  😁🧐"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Nice hair growth\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@yl245](/yl245) why do you focus on this? \\uD83D\\uDE02"
                    },
                    {
                        "username": "Sledge_man",
                        "content": "isnt the arrow supposed to go vertically up?\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "could\\'ve cropped out those hairy legs \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Description is really stupid.\n\"spherical balloon\" is a 3D object. If you know only single coordinate of each ballon on some plane then there is many configurations.\nI always try to solve problem by my self. I did over 700 but this one is really poorly stated.\nAfter looking at official solution and the image there it turns to be really simple (just intervals on a 1D).\n[@LeetCode](/LeetCode) plese add this image to the problem descrition.\n\n![image](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/288049/Figures/452/arrows.png)\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It is a bit pedantic to complain about them using \"sphere\" rather than \"circle\", and then propose an image where you drew \"ellipses\". I'm sure if they had put that image in the statement, there would have been comments like yours calling the question \"really stupid\" for being misleading.\n\nThey clarified explicitly that everything takes place in a 2D plane, so I don't think there's much confusion about whether we should consider the problem 3D, but I agree that a similar illustration would be nice add"
                    },
                    {
                        "username": "trsuhas21",
                        "content": "Tq for elucidating "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) I agree with you, I have posted in a comment that the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!! Even with baloons and stuff, arrow is a stupid analogy since it just passes a point in 2D plain. Better could have been a knife that is cutting sausages that are overlapping on x axis (the only axis).\\n\\nI would Ignore what calm27 is saying since that roughly translates to \"we should accept everything as is, and not give any constructive feedback\"."
                    },
                    {
                        "username": "calm27",
                        "content": "> I always try to solve problem by my self\n\nyou said it like other folks do otherwise to prove your assumption that wording is bad. \n\nmajor part solves it by themselves. no one like bad wording in descriptions, but we should accept the fact it is an initial part of the problem, and the purpose of it is to \"figure out\". \nlife would be easy if all problems were clear. "
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TIP: For `C++`, the input of annonymous compare function shold be reference, or you will get TLE."
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks, was stuck because of it for a while"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "[@kriket](/kriket) Definitely. Copying is always slower, I was just surprised that it will cause such a big difference in sorting."
                    },
                    {
                        "username": "close27",
                        "content": "I think it\\'s because pass by ref does not make new copies hence it is faster."
                    },
                    {
                        "username": "close27",
                        "content": "[@MC_JRen](/MC_JRen)Did run into the problem. Can you please explain how you figured it out?"
                    },
                    {
                        "username": "L39ND",
                        "content": "thats exactly what I need, thank you so much! "
                    },
                    {
                        "username": "Kis_shot",
                        "content": "thank you so much!!!it confused me a lot until i put \"&\" to pass through"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\\n\\nWe can understand by using an example:\\n\\nGiven an 2d array of size 4 with  [10,16] , [2,8] , [1,6] , [7,12]\\n\\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\\n\\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\\n\\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\\n\\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\\n\\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\\n\\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\\n\\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\\n\\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\\n\\nAt last, return the arrow counter.\\n\\nSolution link for better understanding: [https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest)\\n\\nI hope it helps ^_^"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Very clean solution!"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "wow, I used similar theory but I used stack for replacing two balloons with their overlap instead. Here is a better written solution :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "mausami",
                        "content": "Take care of the following test cases while sorting the array:\\n1. []\\n2. [[1,2],[2,3],[3,4],[4,5]]\\n3. [[-2147483646,-2147483645],[2147483646,2147483647]]\\n4. [[10,16],[2,8],[1,6],[7,12]]\\n5. [[1,2],[3,4],[5,6],[7,8]]\\n6. [[1,2]]\\n7. [[2,3],[2,3]]\\n"
                    },
                    {
                        "username": "dvakar",
                        "content": "8. [[77171087,133597895],[45117276,135064454],[80695788,90089372],[91705403,110208054],[52392754,127005153],[53999932,118094992],[11549676,55543044],[43947739,128157751],[55636226,105334812],[69348094,125645633]]"
                    },
                    {
                        "username": "srbssv",
                        "content": "What should we return in case of [[-2147483646,-2147483645],[2147483646,2147483647]]?"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "HUH, Interesting, Funny I didnt find any of these because my stack solution handled them all ok I guess. Here it is:: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "aditisingh10022018",
                        "content": "my test case is also failing at 3rd test case why?"
                    },
                    {
                        "username": "tajnur",
                        "content": "According to the constraints, empty points is not valid. Points should have at least one element..\\n"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "also, [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] "
                    },
                    {
                        "username": "santanusen",
                        "content": "It would have taken me hours to solve such problems a few months back. I was able to solve it in 15 mins today thanks to daily leetcoding. Leetcode definitely helps.\\n\\nTip:\\nsort the points, track how many consecutive points intersect (keep tracking and narrowing down the intersecting coordinates)."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Lovely Tip. I used stack to replace a set of overlapping balloons with their overlap and count the number of balloons end at left. Here is my solution: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I have the same feeling now and it makes me happy. For everyone, keep practicing and you\\'ll be rewarded, don\\'t give up! "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "MentalHealth--;\\nStress++;"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "\\uD83D\\uDE02\\u270C\\uFE0F"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\nWhy expected output for this is 2, as per given instructions it should be 1. Can anyone please give me an explanation, it will be very helpful."
                    }
                ]
            },
            {
                "id": 1743008,
                "content": [
                    {
                        "username": "wateryan17",
                        "content": "Apparently a new test case has been added recently. If you cannot pass this one, then it is because the result of subtraction is too large and thus the overflow is encountered. So don\\'t use `a-b` to compare when sorting. Use `Integer.compare(a,b)` instead!!!"
                    },
                    {
                        "username": "AJReach",
                        "content": "Thanks"
                    },
                    {
                        "username": "dmproni",
                        "content": "even better for Java use Comparator.comparingInt() for clarity :)"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Thanks a lot mate! Great observation! I had this exact problem!"
                    },
                    {
                        "username": "serkora",
                        "content": "[@nikhilsteamid](/nikhilsteamid) Just plain std::sort(v.begin(), v.end()) is enough, it handles sorting of 2D vectors by default, so no need to provide your own. (And you can also use templated STL comparison functions such as std::greater<std::vector<int>>() if you need a different order.)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You can use the below code in java. a-b is still working for sorting.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three cases. but yah for making short and neat code we should use either  Integer.compare(a,b) or lamda function.\\n//code\\n Arrays.sort(arr,new Comparator<int[]>(){\\n            public int compare(int[] a1,int[] a2){\\n               //  return Integer.compare(a1[0],a2[0]); \\n               if(a1[0]>a2[0]) return 1;\\n               else if(a1[0]<a2[0]) return -1;\\n               else return 0;\\n            }\\n        });"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "[@nikhilsteamid](/nikhilsteamid)  u can use lambda function to sort the array in c++\\n"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "what is the c++ alternative?"
                    },
                    {
                        "username": "carloseddy397",
                        "content": "`\\u201CLet me take a break of 5 minutes to browse the internet.\\u201D That\\u2019s how it starts. An hour later, you are still browsing.`"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Replying after exactly 1 year mate !\\nAnniversary of your comment \\uD83D\\uDC95\\uD83E\\uDD23"
                    },
                    {
                        "username": "S_Basu",
                        "content": "true"
                    },
                    {
                        "username": "mkohar",
                        "content": "Try using **Stay Focusd** chrome extension"
                    },
                    {
                        "username": "shanks21",
                        "content": "it\\'s like all of us are leading exact same lives"
                    },
                    {
                        "username": "choi_taek",
                        "content": "programming is 1% intelligence and 99% trying not  to get distracted by internet.\\nYou can try this extension pluckeye. Its great. "
                    },
                    {
                        "username": "vaibhavbhardwaj1987",
                        "content": "![image](https://assets.leetcode.com/users/images/743abf3b-788a-4da7-b576-f043cefe87c0_1603097643.8374152.png)\\n"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@srirambadalgama](/srirambadalgama) No it will give 2 only..\\nas first start will be 3\\nand then 4<=3 false...so count = 2 and now start = 5\\n1<=5 true \\nso result will be 2"
                    },
                    {
                        "username": "srirambadalgama",
                        "content": "I think your solution will give wrong answer for test case: [[1,10],[2,3],[4,5]].\\ncorrect ans is 2. But your soln will give 1."
                    },
                    {
                        "username": "khushimattu",
                        "content": "i have a small doubt. we are checking whether the xend of start is greater than the x start of the next one or not but we arent checking the condition if that is greater than the x ed of the next one?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I didn\\'t visualize the problem like this. It seems so simple now :)"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Nice observation bro, I just sorted and used stack to find overlaps like a dummy. Anyways, here is my dum-dum solution, Its beginner friendly and more intuitive I guess :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "[@Sledge_man](/Sledge_man) same question"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "So brilliant, I like the observation. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@bean_bean](/bean_bean) savage"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "[@Sledge_man](/Sledge_man) Nope, it has to go straight up"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "you are supposed to shoot the arrow vertically up. which means parallel to the y axis. "
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Enough guys, focus on the problem...  😁🧐"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Nice hair growth\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@yl245](/yl245) why do you focus on this? \\uD83D\\uDE02"
                    },
                    {
                        "username": "Sledge_man",
                        "content": "isnt the arrow supposed to go vertically up?\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "could\\'ve cropped out those hairy legs \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Description is really stupid.\n\"spherical balloon\" is a 3D object. If you know only single coordinate of each ballon on some plane then there is many configurations.\nI always try to solve problem by my self. I did over 700 but this one is really poorly stated.\nAfter looking at official solution and the image there it turns to be really simple (just intervals on a 1D).\n[@LeetCode](/LeetCode) plese add this image to the problem descrition.\n\n![image](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/288049/Figures/452/arrows.png)\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It is a bit pedantic to complain about them using \"sphere\" rather than \"circle\", and then propose an image where you drew \"ellipses\". I'm sure if they had put that image in the statement, there would have been comments like yours calling the question \"really stupid\" for being misleading.\n\nThey clarified explicitly that everything takes place in a 2D plane, so I don't think there's much confusion about whether we should consider the problem 3D, but I agree that a similar illustration would be nice add"
                    },
                    {
                        "username": "trsuhas21",
                        "content": "Tq for elucidating "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) I agree with you, I have posted in a comment that the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!! Even with baloons and stuff, arrow is a stupid analogy since it just passes a point in 2D plain. Better could have been a knife that is cutting sausages that are overlapping on x axis (the only axis).\\n\\nI would Ignore what calm27 is saying since that roughly translates to \"we should accept everything as is, and not give any constructive feedback\"."
                    },
                    {
                        "username": "calm27",
                        "content": "> I always try to solve problem by my self\n\nyou said it like other folks do otherwise to prove your assumption that wording is bad. \n\nmajor part solves it by themselves. no one like bad wording in descriptions, but we should accept the fact it is an initial part of the problem, and the purpose of it is to \"figure out\". \nlife would be easy if all problems were clear. "
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TIP: For `C++`, the input of annonymous compare function shold be reference, or you will get TLE."
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks, was stuck because of it for a while"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "[@kriket](/kriket) Definitely. Copying is always slower, I was just surprised that it will cause such a big difference in sorting."
                    },
                    {
                        "username": "close27",
                        "content": "I think it\\'s because pass by ref does not make new copies hence it is faster."
                    },
                    {
                        "username": "close27",
                        "content": "[@MC_JRen](/MC_JRen)Did run into the problem. Can you please explain how you figured it out?"
                    },
                    {
                        "username": "L39ND",
                        "content": "thats exactly what I need, thank you so much! "
                    },
                    {
                        "username": "Kis_shot",
                        "content": "thank you so much!!!it confused me a lot until i put \"&\" to pass through"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\\n\\nWe can understand by using an example:\\n\\nGiven an 2d array of size 4 with  [10,16] , [2,8] , [1,6] , [7,12]\\n\\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\\n\\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\\n\\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\\n\\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\\n\\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\\n\\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\\n\\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\\n\\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\\n\\nAt last, return the arrow counter.\\n\\nSolution link for better understanding: [https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest)\\n\\nI hope it helps ^_^"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Very clean solution!"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "wow, I used similar theory but I used stack for replacing two balloons with their overlap instead. Here is a better written solution :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "mausami",
                        "content": "Take care of the following test cases while sorting the array:\\n1. []\\n2. [[1,2],[2,3],[3,4],[4,5]]\\n3. [[-2147483646,-2147483645],[2147483646,2147483647]]\\n4. [[10,16],[2,8],[1,6],[7,12]]\\n5. [[1,2],[3,4],[5,6],[7,8]]\\n6. [[1,2]]\\n7. [[2,3],[2,3]]\\n"
                    },
                    {
                        "username": "dvakar",
                        "content": "8. [[77171087,133597895],[45117276,135064454],[80695788,90089372],[91705403,110208054],[52392754,127005153],[53999932,118094992],[11549676,55543044],[43947739,128157751],[55636226,105334812],[69348094,125645633]]"
                    },
                    {
                        "username": "srbssv",
                        "content": "What should we return in case of [[-2147483646,-2147483645],[2147483646,2147483647]]?"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "HUH, Interesting, Funny I didnt find any of these because my stack solution handled them all ok I guess. Here it is:: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "aditisingh10022018",
                        "content": "my test case is also failing at 3rd test case why?"
                    },
                    {
                        "username": "tajnur",
                        "content": "According to the constraints, empty points is not valid. Points should have at least one element..\\n"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "also, [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] "
                    },
                    {
                        "username": "santanusen",
                        "content": "It would have taken me hours to solve such problems a few months back. I was able to solve it in 15 mins today thanks to daily leetcoding. Leetcode definitely helps.\\n\\nTip:\\nsort the points, track how many consecutive points intersect (keep tracking and narrowing down the intersecting coordinates)."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Lovely Tip. I used stack to replace a set of overlapping balloons with their overlap and count the number of balloons end at left. Here is my solution: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I have the same feeling now and it makes me happy. For everyone, keep practicing and you\\'ll be rewarded, don\\'t give up! "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "MentalHealth--;\\nStress++;"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "\\uD83D\\uDE02\\u270C\\uFE0F"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\nWhy expected output for this is 2, as per given instructions it should be 1. Can anyone please give me an explanation, it will be very helpful."
                    }
                ]
            },
            {
                "id": 1729822,
                "content": [
                    {
                        "username": "wateryan17",
                        "content": "Apparently a new test case has been added recently. If you cannot pass this one, then it is because the result of subtraction is too large and thus the overflow is encountered. So don\\'t use `a-b` to compare when sorting. Use `Integer.compare(a,b)` instead!!!"
                    },
                    {
                        "username": "AJReach",
                        "content": "Thanks"
                    },
                    {
                        "username": "dmproni",
                        "content": "even better for Java use Comparator.comparingInt() for clarity :)"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Thanks a lot mate! Great observation! I had this exact problem!"
                    },
                    {
                        "username": "serkora",
                        "content": "[@nikhilsteamid](/nikhilsteamid) Just plain std::sort(v.begin(), v.end()) is enough, it handles sorting of 2D vectors by default, so no need to provide your own. (And you can also use templated STL comparison functions such as std::greater<std::vector<int>>() if you need a different order.)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You can use the below code in java. a-b is still working for sorting.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three cases. but yah for making short and neat code we should use either  Integer.compare(a,b) or lamda function.\\n//code\\n Arrays.sort(arr,new Comparator<int[]>(){\\n            public int compare(int[] a1,int[] a2){\\n               //  return Integer.compare(a1[0],a2[0]); \\n               if(a1[0]>a2[0]) return 1;\\n               else if(a1[0]<a2[0]) return -1;\\n               else return 0;\\n            }\\n        });"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "[@nikhilsteamid](/nikhilsteamid)  u can use lambda function to sort the array in c++\\n"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "what is the c++ alternative?"
                    },
                    {
                        "username": "carloseddy397",
                        "content": "`\\u201CLet me take a break of 5 minutes to browse the internet.\\u201D That\\u2019s how it starts. An hour later, you are still browsing.`"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Replying after exactly 1 year mate !\\nAnniversary of your comment \\uD83D\\uDC95\\uD83E\\uDD23"
                    },
                    {
                        "username": "S_Basu",
                        "content": "true"
                    },
                    {
                        "username": "mkohar",
                        "content": "Try using **Stay Focusd** chrome extension"
                    },
                    {
                        "username": "shanks21",
                        "content": "it\\'s like all of us are leading exact same lives"
                    },
                    {
                        "username": "choi_taek",
                        "content": "programming is 1% intelligence and 99% trying not  to get distracted by internet.\\nYou can try this extension pluckeye. Its great. "
                    },
                    {
                        "username": "vaibhavbhardwaj1987",
                        "content": "![image](https://assets.leetcode.com/users/images/743abf3b-788a-4da7-b576-f043cefe87c0_1603097643.8374152.png)\\n"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@srirambadalgama](/srirambadalgama) No it will give 2 only..\\nas first start will be 3\\nand then 4<=3 false...so count = 2 and now start = 5\\n1<=5 true \\nso result will be 2"
                    },
                    {
                        "username": "srirambadalgama",
                        "content": "I think your solution will give wrong answer for test case: [[1,10],[2,3],[4,5]].\\ncorrect ans is 2. But your soln will give 1."
                    },
                    {
                        "username": "khushimattu",
                        "content": "i have a small doubt. we are checking whether the xend of start is greater than the x start of the next one or not but we arent checking the condition if that is greater than the x ed of the next one?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I didn\\'t visualize the problem like this. It seems so simple now :)"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Nice observation bro, I just sorted and used stack to find overlaps like a dummy. Anyways, here is my dum-dum solution, Its beginner friendly and more intuitive I guess :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "[@Sledge_man](/Sledge_man) same question"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "So brilliant, I like the observation. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@bean_bean](/bean_bean) savage"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "[@Sledge_man](/Sledge_man) Nope, it has to go straight up"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "you are supposed to shoot the arrow vertically up. which means parallel to the y axis. "
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Enough guys, focus on the problem...  😁🧐"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Nice hair growth\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@yl245](/yl245) why do you focus on this? \\uD83D\\uDE02"
                    },
                    {
                        "username": "Sledge_man",
                        "content": "isnt the arrow supposed to go vertically up?\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "could\\'ve cropped out those hairy legs \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Description is really stupid.\n\"spherical balloon\" is a 3D object. If you know only single coordinate of each ballon on some plane then there is many configurations.\nI always try to solve problem by my self. I did over 700 but this one is really poorly stated.\nAfter looking at official solution and the image there it turns to be really simple (just intervals on a 1D).\n[@LeetCode](/LeetCode) plese add this image to the problem descrition.\n\n![image](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/288049/Figures/452/arrows.png)\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It is a bit pedantic to complain about them using \"sphere\" rather than \"circle\", and then propose an image where you drew \"ellipses\". I'm sure if they had put that image in the statement, there would have been comments like yours calling the question \"really stupid\" for being misleading.\n\nThey clarified explicitly that everything takes place in a 2D plane, so I don't think there's much confusion about whether we should consider the problem 3D, but I agree that a similar illustration would be nice add"
                    },
                    {
                        "username": "trsuhas21",
                        "content": "Tq for elucidating "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) I agree with you, I have posted in a comment that the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!! Even with baloons and stuff, arrow is a stupid analogy since it just passes a point in 2D plain. Better could have been a knife that is cutting sausages that are overlapping on x axis (the only axis).\\n\\nI would Ignore what calm27 is saying since that roughly translates to \"we should accept everything as is, and not give any constructive feedback\"."
                    },
                    {
                        "username": "calm27",
                        "content": "> I always try to solve problem by my self\n\nyou said it like other folks do otherwise to prove your assumption that wording is bad. \n\nmajor part solves it by themselves. no one like bad wording in descriptions, but we should accept the fact it is an initial part of the problem, and the purpose of it is to \"figure out\". \nlife would be easy if all problems were clear. "
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TIP: For `C++`, the input of annonymous compare function shold be reference, or you will get TLE."
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks, was stuck because of it for a while"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "[@kriket](/kriket) Definitely. Copying is always slower, I was just surprised that it will cause such a big difference in sorting."
                    },
                    {
                        "username": "close27",
                        "content": "I think it\\'s because pass by ref does not make new copies hence it is faster."
                    },
                    {
                        "username": "close27",
                        "content": "[@MC_JRen](/MC_JRen)Did run into the problem. Can you please explain how you figured it out?"
                    },
                    {
                        "username": "L39ND",
                        "content": "thats exactly what I need, thank you so much! "
                    },
                    {
                        "username": "Kis_shot",
                        "content": "thank you so much!!!it confused me a lot until i put \"&\" to pass through"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\\n\\nWe can understand by using an example:\\n\\nGiven an 2d array of size 4 with  [10,16] , [2,8] , [1,6] , [7,12]\\n\\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\\n\\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\\n\\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\\n\\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\\n\\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\\n\\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\\n\\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\\n\\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\\n\\nAt last, return the arrow counter.\\n\\nSolution link for better understanding: [https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest)\\n\\nI hope it helps ^_^"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Very clean solution!"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "wow, I used similar theory but I used stack for replacing two balloons with their overlap instead. Here is a better written solution :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "mausami",
                        "content": "Take care of the following test cases while sorting the array:\\n1. []\\n2. [[1,2],[2,3],[3,4],[4,5]]\\n3. [[-2147483646,-2147483645],[2147483646,2147483647]]\\n4. [[10,16],[2,8],[1,6],[7,12]]\\n5. [[1,2],[3,4],[5,6],[7,8]]\\n6. [[1,2]]\\n7. [[2,3],[2,3]]\\n"
                    },
                    {
                        "username": "dvakar",
                        "content": "8. [[77171087,133597895],[45117276,135064454],[80695788,90089372],[91705403,110208054],[52392754,127005153],[53999932,118094992],[11549676,55543044],[43947739,128157751],[55636226,105334812],[69348094,125645633]]"
                    },
                    {
                        "username": "srbssv",
                        "content": "What should we return in case of [[-2147483646,-2147483645],[2147483646,2147483647]]?"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "HUH, Interesting, Funny I didnt find any of these because my stack solution handled them all ok I guess. Here it is:: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "aditisingh10022018",
                        "content": "my test case is also failing at 3rd test case why?"
                    },
                    {
                        "username": "tajnur",
                        "content": "According to the constraints, empty points is not valid. Points should have at least one element..\\n"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "also, [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] "
                    },
                    {
                        "username": "santanusen",
                        "content": "It would have taken me hours to solve such problems a few months back. I was able to solve it in 15 mins today thanks to daily leetcoding. Leetcode definitely helps.\\n\\nTip:\\nsort the points, track how many consecutive points intersect (keep tracking and narrowing down the intersecting coordinates)."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Lovely Tip. I used stack to replace a set of overlapping balloons with their overlap and count the number of balloons end at left. Here is my solution: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I have the same feeling now and it makes me happy. For everyone, keep practicing and you\\'ll be rewarded, don\\'t give up! "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "MentalHealth--;\\nStress++;"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "\\uD83D\\uDE02\\u270C\\uFE0F"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\nWhy expected output for this is 2, as per given instructions it should be 1. Can anyone please give me an explanation, it will be very helpful."
                    }
                ]
            },
            {
                "id": 1742148,
                "content": [
                    {
                        "username": "wateryan17",
                        "content": "Apparently a new test case has been added recently. If you cannot pass this one, then it is because the result of subtraction is too large and thus the overflow is encountered. So don\\'t use `a-b` to compare when sorting. Use `Integer.compare(a,b)` instead!!!"
                    },
                    {
                        "username": "AJReach",
                        "content": "Thanks"
                    },
                    {
                        "username": "dmproni",
                        "content": "even better for Java use Comparator.comparingInt() for clarity :)"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Thanks a lot mate! Great observation! I had this exact problem!"
                    },
                    {
                        "username": "serkora",
                        "content": "[@nikhilsteamid](/nikhilsteamid) Just plain std::sort(v.begin(), v.end()) is enough, it handles sorting of 2D vectors by default, so no need to provide your own. (And you can also use templated STL comparison functions such as std::greater<std::vector<int>>() if you need a different order.)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You can use the below code in java. a-b is still working for sorting.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three cases. but yah for making short and neat code we should use either  Integer.compare(a,b) or lamda function.\\n//code\\n Arrays.sort(arr,new Comparator<int[]>(){\\n            public int compare(int[] a1,int[] a2){\\n               //  return Integer.compare(a1[0],a2[0]); \\n               if(a1[0]>a2[0]) return 1;\\n               else if(a1[0]<a2[0]) return -1;\\n               else return 0;\\n            }\\n        });"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "[@nikhilsteamid](/nikhilsteamid)  u can use lambda function to sort the array in c++\\n"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "what is the c++ alternative?"
                    },
                    {
                        "username": "carloseddy397",
                        "content": "`\\u201CLet me take a break of 5 minutes to browse the internet.\\u201D That\\u2019s how it starts. An hour later, you are still browsing.`"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Replying after exactly 1 year mate !\\nAnniversary of your comment \\uD83D\\uDC95\\uD83E\\uDD23"
                    },
                    {
                        "username": "S_Basu",
                        "content": "true"
                    },
                    {
                        "username": "mkohar",
                        "content": "Try using **Stay Focusd** chrome extension"
                    },
                    {
                        "username": "shanks21",
                        "content": "it\\'s like all of us are leading exact same lives"
                    },
                    {
                        "username": "choi_taek",
                        "content": "programming is 1% intelligence and 99% trying not  to get distracted by internet.\\nYou can try this extension pluckeye. Its great. "
                    },
                    {
                        "username": "vaibhavbhardwaj1987",
                        "content": "![image](https://assets.leetcode.com/users/images/743abf3b-788a-4da7-b576-f043cefe87c0_1603097643.8374152.png)\\n"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@srirambadalgama](/srirambadalgama) No it will give 2 only..\\nas first start will be 3\\nand then 4<=3 false...so count = 2 and now start = 5\\n1<=5 true \\nso result will be 2"
                    },
                    {
                        "username": "srirambadalgama",
                        "content": "I think your solution will give wrong answer for test case: [[1,10],[2,3],[4,5]].\\ncorrect ans is 2. But your soln will give 1."
                    },
                    {
                        "username": "khushimattu",
                        "content": "i have a small doubt. we are checking whether the xend of start is greater than the x start of the next one or not but we arent checking the condition if that is greater than the x ed of the next one?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I didn\\'t visualize the problem like this. It seems so simple now :)"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Nice observation bro, I just sorted and used stack to find overlaps like a dummy. Anyways, here is my dum-dum solution, Its beginner friendly and more intuitive I guess :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "[@Sledge_man](/Sledge_man) same question"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "So brilliant, I like the observation. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@bean_bean](/bean_bean) savage"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "[@Sledge_man](/Sledge_man) Nope, it has to go straight up"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "you are supposed to shoot the arrow vertically up. which means parallel to the y axis. "
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Enough guys, focus on the problem...  😁🧐"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Nice hair growth\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@yl245](/yl245) why do you focus on this? \\uD83D\\uDE02"
                    },
                    {
                        "username": "Sledge_man",
                        "content": "isnt the arrow supposed to go vertically up?\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "could\\'ve cropped out those hairy legs \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Description is really stupid.\n\"spherical balloon\" is a 3D object. If you know only single coordinate of each ballon on some plane then there is many configurations.\nI always try to solve problem by my self. I did over 700 but this one is really poorly stated.\nAfter looking at official solution and the image there it turns to be really simple (just intervals on a 1D).\n[@LeetCode](/LeetCode) plese add this image to the problem descrition.\n\n![image](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/288049/Figures/452/arrows.png)\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It is a bit pedantic to complain about them using \"sphere\" rather than \"circle\", and then propose an image where you drew \"ellipses\". I'm sure if they had put that image in the statement, there would have been comments like yours calling the question \"really stupid\" for being misleading.\n\nThey clarified explicitly that everything takes place in a 2D plane, so I don't think there's much confusion about whether we should consider the problem 3D, but I agree that a similar illustration would be nice add"
                    },
                    {
                        "username": "trsuhas21",
                        "content": "Tq for elucidating "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) I agree with you, I have posted in a comment that the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!! Even with baloons and stuff, arrow is a stupid analogy since it just passes a point in 2D plain. Better could have been a knife that is cutting sausages that are overlapping on x axis (the only axis).\\n\\nI would Ignore what calm27 is saying since that roughly translates to \"we should accept everything as is, and not give any constructive feedback\"."
                    },
                    {
                        "username": "calm27",
                        "content": "> I always try to solve problem by my self\n\nyou said it like other folks do otherwise to prove your assumption that wording is bad. \n\nmajor part solves it by themselves. no one like bad wording in descriptions, but we should accept the fact it is an initial part of the problem, and the purpose of it is to \"figure out\". \nlife would be easy if all problems were clear. "
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TIP: For `C++`, the input of annonymous compare function shold be reference, or you will get TLE."
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks, was stuck because of it for a while"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "[@kriket](/kriket) Definitely. Copying is always slower, I was just surprised that it will cause such a big difference in sorting."
                    },
                    {
                        "username": "close27",
                        "content": "I think it\\'s because pass by ref does not make new copies hence it is faster."
                    },
                    {
                        "username": "close27",
                        "content": "[@MC_JRen](/MC_JRen)Did run into the problem. Can you please explain how you figured it out?"
                    },
                    {
                        "username": "L39ND",
                        "content": "thats exactly what I need, thank you so much! "
                    },
                    {
                        "username": "Kis_shot",
                        "content": "thank you so much!!!it confused me a lot until i put \"&\" to pass through"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\\n\\nWe can understand by using an example:\\n\\nGiven an 2d array of size 4 with  [10,16] , [2,8] , [1,6] , [7,12]\\n\\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\\n\\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\\n\\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\\n\\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\\n\\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\\n\\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\\n\\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\\n\\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\\n\\nAt last, return the arrow counter.\\n\\nSolution link for better understanding: [https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest)\\n\\nI hope it helps ^_^"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Very clean solution!"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "wow, I used similar theory but I used stack for replacing two balloons with their overlap instead. Here is a better written solution :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "mausami",
                        "content": "Take care of the following test cases while sorting the array:\\n1. []\\n2. [[1,2],[2,3],[3,4],[4,5]]\\n3. [[-2147483646,-2147483645],[2147483646,2147483647]]\\n4. [[10,16],[2,8],[1,6],[7,12]]\\n5. [[1,2],[3,4],[5,6],[7,8]]\\n6. [[1,2]]\\n7. [[2,3],[2,3]]\\n"
                    },
                    {
                        "username": "dvakar",
                        "content": "8. [[77171087,133597895],[45117276,135064454],[80695788,90089372],[91705403,110208054],[52392754,127005153],[53999932,118094992],[11549676,55543044],[43947739,128157751],[55636226,105334812],[69348094,125645633]]"
                    },
                    {
                        "username": "srbssv",
                        "content": "What should we return in case of [[-2147483646,-2147483645],[2147483646,2147483647]]?"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "HUH, Interesting, Funny I didnt find any of these because my stack solution handled them all ok I guess. Here it is:: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "aditisingh10022018",
                        "content": "my test case is also failing at 3rd test case why?"
                    },
                    {
                        "username": "tajnur",
                        "content": "According to the constraints, empty points is not valid. Points should have at least one element..\\n"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "also, [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] "
                    },
                    {
                        "username": "santanusen",
                        "content": "It would have taken me hours to solve such problems a few months back. I was able to solve it in 15 mins today thanks to daily leetcoding. Leetcode definitely helps.\\n\\nTip:\\nsort the points, track how many consecutive points intersect (keep tracking and narrowing down the intersecting coordinates)."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Lovely Tip. I used stack to replace a set of overlapping balloons with their overlap and count the number of balloons end at left. Here is my solution: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I have the same feeling now and it makes me happy. For everyone, keep practicing and you\\'ll be rewarded, don\\'t give up! "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "MentalHealth--;\\nStress++;"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "\\uD83D\\uDE02\\u270C\\uFE0F"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\nWhy expected output for this is 2, as per given instructions it should be 1. Can anyone please give me an explanation, it will be very helpful."
                    }
                ]
            },
            {
                "id": 1567539,
                "content": [
                    {
                        "username": "wateryan17",
                        "content": "Apparently a new test case has been added recently. If you cannot pass this one, then it is because the result of subtraction is too large and thus the overflow is encountered. So don\\'t use `a-b` to compare when sorting. Use `Integer.compare(a,b)` instead!!!"
                    },
                    {
                        "username": "AJReach",
                        "content": "Thanks"
                    },
                    {
                        "username": "dmproni",
                        "content": "even better for Java use Comparator.comparingInt() for clarity :)"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Thanks a lot mate! Great observation! I had this exact problem!"
                    },
                    {
                        "username": "serkora",
                        "content": "[@nikhilsteamid](/nikhilsteamid) Just plain std::sort(v.begin(), v.end()) is enough, it handles sorting of 2D vectors by default, so no need to provide your own. (And you can also use templated STL comparison functions such as std::greater<std::vector<int>>() if you need a different order.)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You can use the below code in java. a-b is still working for sorting.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three cases. but yah for making short and neat code we should use either  Integer.compare(a,b) or lamda function.\\n//code\\n Arrays.sort(arr,new Comparator<int[]>(){\\n            public int compare(int[] a1,int[] a2){\\n               //  return Integer.compare(a1[0],a2[0]); \\n               if(a1[0]>a2[0]) return 1;\\n               else if(a1[0]<a2[0]) return -1;\\n               else return 0;\\n            }\\n        });"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "[@nikhilsteamid](/nikhilsteamid)  u can use lambda function to sort the array in c++\\n"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "what is the c++ alternative?"
                    },
                    {
                        "username": "carloseddy397",
                        "content": "`\\u201CLet me take a break of 5 minutes to browse the internet.\\u201D That\\u2019s how it starts. An hour later, you are still browsing.`"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Replying after exactly 1 year mate !\\nAnniversary of your comment \\uD83D\\uDC95\\uD83E\\uDD23"
                    },
                    {
                        "username": "S_Basu",
                        "content": "true"
                    },
                    {
                        "username": "mkohar",
                        "content": "Try using **Stay Focusd** chrome extension"
                    },
                    {
                        "username": "shanks21",
                        "content": "it\\'s like all of us are leading exact same lives"
                    },
                    {
                        "username": "choi_taek",
                        "content": "programming is 1% intelligence and 99% trying not  to get distracted by internet.\\nYou can try this extension pluckeye. Its great. "
                    },
                    {
                        "username": "vaibhavbhardwaj1987",
                        "content": "![image](https://assets.leetcode.com/users/images/743abf3b-788a-4da7-b576-f043cefe87c0_1603097643.8374152.png)\\n"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@srirambadalgama](/srirambadalgama) No it will give 2 only..\\nas first start will be 3\\nand then 4<=3 false...so count = 2 and now start = 5\\n1<=5 true \\nso result will be 2"
                    },
                    {
                        "username": "srirambadalgama",
                        "content": "I think your solution will give wrong answer for test case: [[1,10],[2,3],[4,5]].\\ncorrect ans is 2. But your soln will give 1."
                    },
                    {
                        "username": "khushimattu",
                        "content": "i have a small doubt. we are checking whether the xend of start is greater than the x start of the next one or not but we arent checking the condition if that is greater than the x ed of the next one?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I didn\\'t visualize the problem like this. It seems so simple now :)"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Nice observation bro, I just sorted and used stack to find overlaps like a dummy. Anyways, here is my dum-dum solution, Its beginner friendly and more intuitive I guess :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "[@Sledge_man](/Sledge_man) same question"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "So brilliant, I like the observation. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@bean_bean](/bean_bean) savage"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "[@Sledge_man](/Sledge_man) Nope, it has to go straight up"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "you are supposed to shoot the arrow vertically up. which means parallel to the y axis. "
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Enough guys, focus on the problem...  😁🧐"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Nice hair growth\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@yl245](/yl245) why do you focus on this? \\uD83D\\uDE02"
                    },
                    {
                        "username": "Sledge_man",
                        "content": "isnt the arrow supposed to go vertically up?\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "could\\'ve cropped out those hairy legs \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Description is really stupid.\n\"spherical balloon\" is a 3D object. If you know only single coordinate of each ballon on some plane then there is many configurations.\nI always try to solve problem by my self. I did over 700 but this one is really poorly stated.\nAfter looking at official solution and the image there it turns to be really simple (just intervals on a 1D).\n[@LeetCode](/LeetCode) plese add this image to the problem descrition.\n\n![image](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/288049/Figures/452/arrows.png)\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It is a bit pedantic to complain about them using \"sphere\" rather than \"circle\", and then propose an image where you drew \"ellipses\". I'm sure if they had put that image in the statement, there would have been comments like yours calling the question \"really stupid\" for being misleading.\n\nThey clarified explicitly that everything takes place in a 2D plane, so I don't think there's much confusion about whether we should consider the problem 3D, but I agree that a similar illustration would be nice add"
                    },
                    {
                        "username": "trsuhas21",
                        "content": "Tq for elucidating "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) I agree with you, I have posted in a comment that the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!! Even with baloons and stuff, arrow is a stupid analogy since it just passes a point in 2D plain. Better could have been a knife that is cutting sausages that are overlapping on x axis (the only axis).\\n\\nI would Ignore what calm27 is saying since that roughly translates to \"we should accept everything as is, and not give any constructive feedback\"."
                    },
                    {
                        "username": "calm27",
                        "content": "> I always try to solve problem by my self\n\nyou said it like other folks do otherwise to prove your assumption that wording is bad. \n\nmajor part solves it by themselves. no one like bad wording in descriptions, but we should accept the fact it is an initial part of the problem, and the purpose of it is to \"figure out\". \nlife would be easy if all problems were clear. "
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TIP: For `C++`, the input of annonymous compare function shold be reference, or you will get TLE."
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks, was stuck because of it for a while"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "[@kriket](/kriket) Definitely. Copying is always slower, I was just surprised that it will cause such a big difference in sorting."
                    },
                    {
                        "username": "close27",
                        "content": "I think it\\'s because pass by ref does not make new copies hence it is faster."
                    },
                    {
                        "username": "close27",
                        "content": "[@MC_JRen](/MC_JRen)Did run into the problem. Can you please explain how you figured it out?"
                    },
                    {
                        "username": "L39ND",
                        "content": "thats exactly what I need, thank you so much! "
                    },
                    {
                        "username": "Kis_shot",
                        "content": "thank you so much!!!it confused me a lot until i put \"&\" to pass through"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\\n\\nWe can understand by using an example:\\n\\nGiven an 2d array of size 4 with  [10,16] , [2,8] , [1,6] , [7,12]\\n\\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\\n\\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\\n\\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\\n\\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\\n\\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\\n\\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\\n\\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\\n\\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\\n\\nAt last, return the arrow counter.\\n\\nSolution link for better understanding: [https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest)\\n\\nI hope it helps ^_^"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Very clean solution!"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "wow, I used similar theory but I used stack for replacing two balloons with their overlap instead. Here is a better written solution :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "mausami",
                        "content": "Take care of the following test cases while sorting the array:\\n1. []\\n2. [[1,2],[2,3],[3,4],[4,5]]\\n3. [[-2147483646,-2147483645],[2147483646,2147483647]]\\n4. [[10,16],[2,8],[1,6],[7,12]]\\n5. [[1,2],[3,4],[5,6],[7,8]]\\n6. [[1,2]]\\n7. [[2,3],[2,3]]\\n"
                    },
                    {
                        "username": "dvakar",
                        "content": "8. [[77171087,133597895],[45117276,135064454],[80695788,90089372],[91705403,110208054],[52392754,127005153],[53999932,118094992],[11549676,55543044],[43947739,128157751],[55636226,105334812],[69348094,125645633]]"
                    },
                    {
                        "username": "srbssv",
                        "content": "What should we return in case of [[-2147483646,-2147483645],[2147483646,2147483647]]?"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "HUH, Interesting, Funny I didnt find any of these because my stack solution handled them all ok I guess. Here it is:: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "aditisingh10022018",
                        "content": "my test case is also failing at 3rd test case why?"
                    },
                    {
                        "username": "tajnur",
                        "content": "According to the constraints, empty points is not valid. Points should have at least one element..\\n"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "also, [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] "
                    },
                    {
                        "username": "santanusen",
                        "content": "It would have taken me hours to solve such problems a few months back. I was able to solve it in 15 mins today thanks to daily leetcoding. Leetcode definitely helps.\\n\\nTip:\\nsort the points, track how many consecutive points intersect (keep tracking and narrowing down the intersecting coordinates)."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Lovely Tip. I used stack to replace a set of overlapping balloons with their overlap and count the number of balloons end at left. Here is my solution: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I have the same feeling now and it makes me happy. For everyone, keep practicing and you\\'ll be rewarded, don\\'t give up! "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "MentalHealth--;\\nStress++;"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "\\uD83D\\uDE02\\u270C\\uFE0F"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\nWhy expected output for this is 2, as per given instructions it should be 1. Can anyone please give me an explanation, it will be very helpful."
                    }
                ]
            },
            {
                "id": 1742652,
                "content": [
                    {
                        "username": "wateryan17",
                        "content": "Apparently a new test case has been added recently. If you cannot pass this one, then it is because the result of subtraction is too large and thus the overflow is encountered. So don\\'t use `a-b` to compare when sorting. Use `Integer.compare(a,b)` instead!!!"
                    },
                    {
                        "username": "AJReach",
                        "content": "Thanks"
                    },
                    {
                        "username": "dmproni",
                        "content": "even better for Java use Comparator.comparingInt() for clarity :)"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Thanks a lot mate! Great observation! I had this exact problem!"
                    },
                    {
                        "username": "serkora",
                        "content": "[@nikhilsteamid](/nikhilsteamid) Just plain std::sort(v.begin(), v.end()) is enough, it handles sorting of 2D vectors by default, so no need to provide your own. (And you can also use templated STL comparison functions such as std::greater<std::vector<int>>() if you need a different order.)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You can use the below code in java. a-b is still working for sorting.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three cases. but yah for making short and neat code we should use either  Integer.compare(a,b) or lamda function.\\n//code\\n Arrays.sort(arr,new Comparator<int[]>(){\\n            public int compare(int[] a1,int[] a2){\\n               //  return Integer.compare(a1[0],a2[0]); \\n               if(a1[0]>a2[0]) return 1;\\n               else if(a1[0]<a2[0]) return -1;\\n               else return 0;\\n            }\\n        });"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "[@nikhilsteamid](/nikhilsteamid)  u can use lambda function to sort the array in c++\\n"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "what is the c++ alternative?"
                    },
                    {
                        "username": "carloseddy397",
                        "content": "`\\u201CLet me take a break of 5 minutes to browse the internet.\\u201D That\\u2019s how it starts. An hour later, you are still browsing.`"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Replying after exactly 1 year mate !\\nAnniversary of your comment \\uD83D\\uDC95\\uD83E\\uDD23"
                    },
                    {
                        "username": "S_Basu",
                        "content": "true"
                    },
                    {
                        "username": "mkohar",
                        "content": "Try using **Stay Focusd** chrome extension"
                    },
                    {
                        "username": "shanks21",
                        "content": "it\\'s like all of us are leading exact same lives"
                    },
                    {
                        "username": "choi_taek",
                        "content": "programming is 1% intelligence and 99% trying not  to get distracted by internet.\\nYou can try this extension pluckeye. Its great. "
                    },
                    {
                        "username": "vaibhavbhardwaj1987",
                        "content": "![image](https://assets.leetcode.com/users/images/743abf3b-788a-4da7-b576-f043cefe87c0_1603097643.8374152.png)\\n"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@srirambadalgama](/srirambadalgama) No it will give 2 only..\\nas first start will be 3\\nand then 4<=3 false...so count = 2 and now start = 5\\n1<=5 true \\nso result will be 2"
                    },
                    {
                        "username": "srirambadalgama",
                        "content": "I think your solution will give wrong answer for test case: [[1,10],[2,3],[4,5]].\\ncorrect ans is 2. But your soln will give 1."
                    },
                    {
                        "username": "khushimattu",
                        "content": "i have a small doubt. we are checking whether the xend of start is greater than the x start of the next one or not but we arent checking the condition if that is greater than the x ed of the next one?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I didn\\'t visualize the problem like this. It seems so simple now :)"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Nice observation bro, I just sorted and used stack to find overlaps like a dummy. Anyways, here is my dum-dum solution, Its beginner friendly and more intuitive I guess :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "[@Sledge_man](/Sledge_man) same question"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "So brilliant, I like the observation. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@bean_bean](/bean_bean) savage"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "[@Sledge_man](/Sledge_man) Nope, it has to go straight up"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "you are supposed to shoot the arrow vertically up. which means parallel to the y axis. "
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Enough guys, focus on the problem...  😁🧐"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Nice hair growth\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@yl245](/yl245) why do you focus on this? \\uD83D\\uDE02"
                    },
                    {
                        "username": "Sledge_man",
                        "content": "isnt the arrow supposed to go vertically up?\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "could\\'ve cropped out those hairy legs \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Description is really stupid.\n\"spherical balloon\" is a 3D object. If you know only single coordinate of each ballon on some plane then there is many configurations.\nI always try to solve problem by my self. I did over 700 but this one is really poorly stated.\nAfter looking at official solution and the image there it turns to be really simple (just intervals on a 1D).\n[@LeetCode](/LeetCode) plese add this image to the problem descrition.\n\n![image](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/288049/Figures/452/arrows.png)\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It is a bit pedantic to complain about them using \"sphere\" rather than \"circle\", and then propose an image where you drew \"ellipses\". I'm sure if they had put that image in the statement, there would have been comments like yours calling the question \"really stupid\" for being misleading.\n\nThey clarified explicitly that everything takes place in a 2D plane, so I don't think there's much confusion about whether we should consider the problem 3D, but I agree that a similar illustration would be nice add"
                    },
                    {
                        "username": "trsuhas21",
                        "content": "Tq for elucidating "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) I agree with you, I have posted in a comment that the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!! Even with baloons and stuff, arrow is a stupid analogy since it just passes a point in 2D plain. Better could have been a knife that is cutting sausages that are overlapping on x axis (the only axis).\\n\\nI would Ignore what calm27 is saying since that roughly translates to \"we should accept everything as is, and not give any constructive feedback\"."
                    },
                    {
                        "username": "calm27",
                        "content": "> I always try to solve problem by my self\n\nyou said it like other folks do otherwise to prove your assumption that wording is bad. \n\nmajor part solves it by themselves. no one like bad wording in descriptions, but we should accept the fact it is an initial part of the problem, and the purpose of it is to \"figure out\". \nlife would be easy if all problems were clear. "
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TIP: For `C++`, the input of annonymous compare function shold be reference, or you will get TLE."
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks, was stuck because of it for a while"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "[@kriket](/kriket) Definitely. Copying is always slower, I was just surprised that it will cause such a big difference in sorting."
                    },
                    {
                        "username": "close27",
                        "content": "I think it\\'s because pass by ref does not make new copies hence it is faster."
                    },
                    {
                        "username": "close27",
                        "content": "[@MC_JRen](/MC_JRen)Did run into the problem. Can you please explain how you figured it out?"
                    },
                    {
                        "username": "L39ND",
                        "content": "thats exactly what I need, thank you so much! "
                    },
                    {
                        "username": "Kis_shot",
                        "content": "thank you so much!!!it confused me a lot until i put \"&\" to pass through"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\\n\\nWe can understand by using an example:\\n\\nGiven an 2d array of size 4 with  [10,16] , [2,8] , [1,6] , [7,12]\\n\\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\\n\\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\\n\\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\\n\\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\\n\\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\\n\\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\\n\\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\\n\\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\\n\\nAt last, return the arrow counter.\\n\\nSolution link for better understanding: [https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest)\\n\\nI hope it helps ^_^"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Very clean solution!"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "wow, I used similar theory but I used stack for replacing two balloons with their overlap instead. Here is a better written solution :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "mausami",
                        "content": "Take care of the following test cases while sorting the array:\\n1. []\\n2. [[1,2],[2,3],[3,4],[4,5]]\\n3. [[-2147483646,-2147483645],[2147483646,2147483647]]\\n4. [[10,16],[2,8],[1,6],[7,12]]\\n5. [[1,2],[3,4],[5,6],[7,8]]\\n6. [[1,2]]\\n7. [[2,3],[2,3]]\\n"
                    },
                    {
                        "username": "dvakar",
                        "content": "8. [[77171087,133597895],[45117276,135064454],[80695788,90089372],[91705403,110208054],[52392754,127005153],[53999932,118094992],[11549676,55543044],[43947739,128157751],[55636226,105334812],[69348094,125645633]]"
                    },
                    {
                        "username": "srbssv",
                        "content": "What should we return in case of [[-2147483646,-2147483645],[2147483646,2147483647]]?"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "HUH, Interesting, Funny I didnt find any of these because my stack solution handled them all ok I guess. Here it is:: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "aditisingh10022018",
                        "content": "my test case is also failing at 3rd test case why?"
                    },
                    {
                        "username": "tajnur",
                        "content": "According to the constraints, empty points is not valid. Points should have at least one element..\\n"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "also, [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] "
                    },
                    {
                        "username": "santanusen",
                        "content": "It would have taken me hours to solve such problems a few months back. I was able to solve it in 15 mins today thanks to daily leetcoding. Leetcode definitely helps.\\n\\nTip:\\nsort the points, track how many consecutive points intersect (keep tracking and narrowing down the intersecting coordinates)."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Lovely Tip. I used stack to replace a set of overlapping balloons with their overlap and count the number of balloons end at left. Here is my solution: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I have the same feeling now and it makes me happy. For everyone, keep practicing and you\\'ll be rewarded, don\\'t give up! "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "MentalHealth--;\\nStress++;"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "\\uD83D\\uDE02\\u270C\\uFE0F"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\nWhy expected output for this is 2, as per given instructions it should be 1. Can anyone please give me an explanation, it will be very helpful."
                    }
                ]
            },
            {
                "id": 1742423,
                "content": [
                    {
                        "username": "wateryan17",
                        "content": "Apparently a new test case has been added recently. If you cannot pass this one, then it is because the result of subtraction is too large and thus the overflow is encountered. So don\\'t use `a-b` to compare when sorting. Use `Integer.compare(a,b)` instead!!!"
                    },
                    {
                        "username": "AJReach",
                        "content": "Thanks"
                    },
                    {
                        "username": "dmproni",
                        "content": "even better for Java use Comparator.comparingInt() for clarity :)"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Thanks a lot mate! Great observation! I had this exact problem!"
                    },
                    {
                        "username": "serkora",
                        "content": "[@nikhilsteamid](/nikhilsteamid) Just plain std::sort(v.begin(), v.end()) is enough, it handles sorting of 2D vectors by default, so no need to provide your own. (And you can also use templated STL comparison functions such as std::greater<std::vector<int>>() if you need a different order.)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You can use the below code in java. a-b is still working for sorting.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three cases. but yah for making short and neat code we should use either  Integer.compare(a,b) or lamda function.\\n//code\\n Arrays.sort(arr,new Comparator<int[]>(){\\n            public int compare(int[] a1,int[] a2){\\n               //  return Integer.compare(a1[0],a2[0]); \\n               if(a1[0]>a2[0]) return 1;\\n               else if(a1[0]<a2[0]) return -1;\\n               else return 0;\\n            }\\n        });"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "[@nikhilsteamid](/nikhilsteamid)  u can use lambda function to sort the array in c++\\n"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "what is the c++ alternative?"
                    },
                    {
                        "username": "carloseddy397",
                        "content": "`\\u201CLet me take a break of 5 minutes to browse the internet.\\u201D That\\u2019s how it starts. An hour later, you are still browsing.`"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Replying after exactly 1 year mate !\\nAnniversary of your comment \\uD83D\\uDC95\\uD83E\\uDD23"
                    },
                    {
                        "username": "S_Basu",
                        "content": "true"
                    },
                    {
                        "username": "mkohar",
                        "content": "Try using **Stay Focusd** chrome extension"
                    },
                    {
                        "username": "shanks21",
                        "content": "it\\'s like all of us are leading exact same lives"
                    },
                    {
                        "username": "choi_taek",
                        "content": "programming is 1% intelligence and 99% trying not  to get distracted by internet.\\nYou can try this extension pluckeye. Its great. "
                    },
                    {
                        "username": "vaibhavbhardwaj1987",
                        "content": "![image](https://assets.leetcode.com/users/images/743abf3b-788a-4da7-b576-f043cefe87c0_1603097643.8374152.png)\\n"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@srirambadalgama](/srirambadalgama) No it will give 2 only..\\nas first start will be 3\\nand then 4<=3 false...so count = 2 and now start = 5\\n1<=5 true \\nso result will be 2"
                    },
                    {
                        "username": "srirambadalgama",
                        "content": "I think your solution will give wrong answer for test case: [[1,10],[2,3],[4,5]].\\ncorrect ans is 2. But your soln will give 1."
                    },
                    {
                        "username": "khushimattu",
                        "content": "i have a small doubt. we are checking whether the xend of start is greater than the x start of the next one or not but we arent checking the condition if that is greater than the x ed of the next one?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I didn\\'t visualize the problem like this. It seems so simple now :)"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Nice observation bro, I just sorted and used stack to find overlaps like a dummy. Anyways, here is my dum-dum solution, Its beginner friendly and more intuitive I guess :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "[@Sledge_man](/Sledge_man) same question"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "So brilliant, I like the observation. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@bean_bean](/bean_bean) savage"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "[@Sledge_man](/Sledge_man) Nope, it has to go straight up"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "you are supposed to shoot the arrow vertically up. which means parallel to the y axis. "
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Enough guys, focus on the problem...  😁🧐"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Nice hair growth\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@yl245](/yl245) why do you focus on this? \\uD83D\\uDE02"
                    },
                    {
                        "username": "Sledge_man",
                        "content": "isnt the arrow supposed to go vertically up?\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "could\\'ve cropped out those hairy legs \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Description is really stupid.\n\"spherical balloon\" is a 3D object. If you know only single coordinate of each ballon on some plane then there is many configurations.\nI always try to solve problem by my self. I did over 700 but this one is really poorly stated.\nAfter looking at official solution and the image there it turns to be really simple (just intervals on a 1D).\n[@LeetCode](/LeetCode) plese add this image to the problem descrition.\n\n![image](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/288049/Figures/452/arrows.png)\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It is a bit pedantic to complain about them using \"sphere\" rather than \"circle\", and then propose an image where you drew \"ellipses\". I'm sure if they had put that image in the statement, there would have been comments like yours calling the question \"really stupid\" for being misleading.\n\nThey clarified explicitly that everything takes place in a 2D plane, so I don't think there's much confusion about whether we should consider the problem 3D, but I agree that a similar illustration would be nice add"
                    },
                    {
                        "username": "trsuhas21",
                        "content": "Tq for elucidating "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) I agree with you, I have posted in a comment that the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!! Even with baloons and stuff, arrow is a stupid analogy since it just passes a point in 2D plain. Better could have been a knife that is cutting sausages that are overlapping on x axis (the only axis).\\n\\nI would Ignore what calm27 is saying since that roughly translates to \"we should accept everything as is, and not give any constructive feedback\"."
                    },
                    {
                        "username": "calm27",
                        "content": "> I always try to solve problem by my self\n\nyou said it like other folks do otherwise to prove your assumption that wording is bad. \n\nmajor part solves it by themselves. no one like bad wording in descriptions, but we should accept the fact it is an initial part of the problem, and the purpose of it is to \"figure out\". \nlife would be easy if all problems were clear. "
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TIP: For `C++`, the input of annonymous compare function shold be reference, or you will get TLE."
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks, was stuck because of it for a while"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "[@kriket](/kriket) Definitely. Copying is always slower, I was just surprised that it will cause such a big difference in sorting."
                    },
                    {
                        "username": "close27",
                        "content": "I think it\\'s because pass by ref does not make new copies hence it is faster."
                    },
                    {
                        "username": "close27",
                        "content": "[@MC_JRen](/MC_JRen)Did run into the problem. Can you please explain how you figured it out?"
                    },
                    {
                        "username": "L39ND",
                        "content": "thats exactly what I need, thank you so much! "
                    },
                    {
                        "username": "Kis_shot",
                        "content": "thank you so much!!!it confused me a lot until i put \"&\" to pass through"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\\n\\nWe can understand by using an example:\\n\\nGiven an 2d array of size 4 with  [10,16] , [2,8] , [1,6] , [7,12]\\n\\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\\n\\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\\n\\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\\n\\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\\n\\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\\n\\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\\n\\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\\n\\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\\n\\nAt last, return the arrow counter.\\n\\nSolution link for better understanding: [https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest)\\n\\nI hope it helps ^_^"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Very clean solution!"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "wow, I used similar theory but I used stack for replacing two balloons with their overlap instead. Here is a better written solution :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "mausami",
                        "content": "Take care of the following test cases while sorting the array:\\n1. []\\n2. [[1,2],[2,3],[3,4],[4,5]]\\n3. [[-2147483646,-2147483645],[2147483646,2147483647]]\\n4. [[10,16],[2,8],[1,6],[7,12]]\\n5. [[1,2],[3,4],[5,6],[7,8]]\\n6. [[1,2]]\\n7. [[2,3],[2,3]]\\n"
                    },
                    {
                        "username": "dvakar",
                        "content": "8. [[77171087,133597895],[45117276,135064454],[80695788,90089372],[91705403,110208054],[52392754,127005153],[53999932,118094992],[11549676,55543044],[43947739,128157751],[55636226,105334812],[69348094,125645633]]"
                    },
                    {
                        "username": "srbssv",
                        "content": "What should we return in case of [[-2147483646,-2147483645],[2147483646,2147483647]]?"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "HUH, Interesting, Funny I didnt find any of these because my stack solution handled them all ok I guess. Here it is:: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "aditisingh10022018",
                        "content": "my test case is also failing at 3rd test case why?"
                    },
                    {
                        "username": "tajnur",
                        "content": "According to the constraints, empty points is not valid. Points should have at least one element..\\n"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "also, [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] "
                    },
                    {
                        "username": "santanusen",
                        "content": "It would have taken me hours to solve such problems a few months back. I was able to solve it in 15 mins today thanks to daily leetcoding. Leetcode definitely helps.\\n\\nTip:\\nsort the points, track how many consecutive points intersect (keep tracking and narrowing down the intersecting coordinates)."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Lovely Tip. I used stack to replace a set of overlapping balloons with their overlap and count the number of balloons end at left. Here is my solution: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I have the same feeling now and it makes me happy. For everyone, keep practicing and you\\'ll be rewarded, don\\'t give up! "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "MentalHealth--;\\nStress++;"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "\\uD83D\\uDE02\\u270C\\uFE0F"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\nWhy expected output for this is 2, as per given instructions it should be 1. Can anyone please give me an explanation, it will be very helpful."
                    }
                ]
            },
            {
                "id": 1565808,
                "content": [
                    {
                        "username": "wateryan17",
                        "content": "Apparently a new test case has been added recently. If you cannot pass this one, then it is because the result of subtraction is too large and thus the overflow is encountered. So don\\'t use `a-b` to compare when sorting. Use `Integer.compare(a,b)` instead!!!"
                    },
                    {
                        "username": "AJReach",
                        "content": "Thanks"
                    },
                    {
                        "username": "dmproni",
                        "content": "even better for Java use Comparator.comparingInt() for clarity :)"
                    },
                    {
                        "username": "sanemiliano",
                        "content": "Thanks a lot mate! Great observation! I had this exact problem!"
                    },
                    {
                        "username": "serkora",
                        "content": "[@nikhilsteamid](/nikhilsteamid) Just plain std::sort(v.begin(), v.end()) is enough, it handles sorting of 2D vectors by default, so no need to provide your own. (And you can also use templated STL comparison functions such as std::greater<std::vector<int>>() if you need a different order.)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You can use the below code in java. a-b is still working for sorting.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three cases. but yah for making short and neat code we should use either  Integer.compare(a,b) or lamda function.\\n//code\\n Arrays.sort(arr,new Comparator<int[]>(){\\n            public int compare(int[] a1,int[] a2){\\n               //  return Integer.compare(a1[0],a2[0]); \\n               if(a1[0]>a2[0]) return 1;\\n               else if(a1[0]<a2[0]) return -1;\\n               else return 0;\\n            }\\n        });"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "[@nikhilsteamid](/nikhilsteamid)  u can use lambda function to sort the array in c++\\n"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "what is the c++ alternative?"
                    },
                    {
                        "username": "carloseddy397",
                        "content": "`\\u201CLet me take a break of 5 minutes to browse the internet.\\u201D That\\u2019s how it starts. An hour later, you are still browsing.`"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Replying after exactly 1 year mate !\\nAnniversary of your comment \\uD83D\\uDC95\\uD83E\\uDD23"
                    },
                    {
                        "username": "S_Basu",
                        "content": "true"
                    },
                    {
                        "username": "mkohar",
                        "content": "Try using **Stay Focusd** chrome extension"
                    },
                    {
                        "username": "shanks21",
                        "content": "it\\'s like all of us are leading exact same lives"
                    },
                    {
                        "username": "choi_taek",
                        "content": "programming is 1% intelligence and 99% trying not  to get distracted by internet.\\nYou can try this extension pluckeye. Its great. "
                    },
                    {
                        "username": "vaibhavbhardwaj1987",
                        "content": "![image](https://assets.leetcode.com/users/images/743abf3b-788a-4da7-b576-f043cefe87c0_1603097643.8374152.png)\\n"
                    },
                    {
                        "username": "thammayya",
                        "content": "[@srirambadalgama](/srirambadalgama) No it will give 2 only..\\nas first start will be 3\\nand then 4<=3 false...so count = 2 and now start = 5\\n1<=5 true \\nso result will be 2"
                    },
                    {
                        "username": "srirambadalgama",
                        "content": "I think your solution will give wrong answer for test case: [[1,10],[2,3],[4,5]].\\ncorrect ans is 2. But your soln will give 1."
                    },
                    {
                        "username": "khushimattu",
                        "content": "i have a small doubt. we are checking whether the xend of start is greater than the x start of the next one or not but we arent checking the condition if that is greater than the x ed of the next one?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I didn\\'t visualize the problem like this. It seems so simple now :)"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Nice observation bro, I just sorted and used stack to find overlaps like a dummy. Anyways, here is my dum-dum solution, Its beginner friendly and more intuitive I guess :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "calm27",
                        "content": "[@Sledge_man](/Sledge_man) same question"
                    },
                    {
                        "username": "BLOCKS",
                        "content": "So brilliant, I like the observation. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "[@bean_bean](/bean_bean) savage"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "[@Sledge_man](/Sledge_man) Nope, it has to go straight up"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "you are supposed to shoot the arrow vertically up. which means parallel to the y axis. "
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Enough guys, focus on the problem...  😁🧐"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Nice hair growth\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@yl245](/yl245) why do you focus on this? \\uD83D\\uDE02"
                    },
                    {
                        "username": "Sledge_man",
                        "content": "isnt the arrow supposed to go vertically up?\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "could\\'ve cropped out those hairy legs \\uD83D\\uDC80\\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Description is really stupid.\n\"spherical balloon\" is a 3D object. If you know only single coordinate of each ballon on some plane then there is many configurations.\nI always try to solve problem by my self. I did over 700 but this one is really poorly stated.\nAfter looking at official solution and the image there it turns to be really simple (just intervals on a 1D).\n[@LeetCode](/LeetCode) plese add this image to the problem descrition.\n\n![image](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/288049/Figures/452/arrows.png)\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "It is a bit pedantic to complain about them using \"sphere\" rather than \"circle\", and then propose an image where you drew \"ellipses\". I'm sure if they had put that image in the statement, there would have been comments like yours calling the question \"really stupid\" for being misleading.\n\nThey clarified explicitly that everything takes place in a 2D plane, so I don't think there's much confusion about whether we should consider the problem 3D, but I agree that a similar illustration would be nice add"
                    },
                    {
                        "username": "trsuhas21",
                        "content": "Tq for elucidating "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) I agree with you, I have posted in a comment that the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!! Even with baloons and stuff, arrow is a stupid analogy since it just passes a point in 2D plain. Better could have been a knife that is cutting sausages that are overlapping on x axis (the only axis).\\n\\nI would Ignore what calm27 is saying since that roughly translates to \"we should accept everything as is, and not give any constructive feedback\"."
                    },
                    {
                        "username": "calm27",
                        "content": "> I always try to solve problem by my self\n\nyou said it like other folks do otherwise to prove your assumption that wording is bad. \n\nmajor part solves it by themselves. no one like bad wording in descriptions, but we should accept the fact it is an initial part of the problem, and the purpose of it is to \"figure out\". \nlife would be easy if all problems were clear. "
                    },
                    {
                        "username": "MC_Jin",
                        "content": "TIP: For `C++`, the input of annonymous compare function shold be reference, or you will get TLE."
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks, was stuck because of it for a while"
                    },
                    {
                        "username": "MC_Jin",
                        "content": "[@kriket](/kriket) Definitely. Copying is always slower, I was just surprised that it will cause such a big difference in sorting."
                    },
                    {
                        "username": "close27",
                        "content": "I think it\\'s because pass by ref does not make new copies hence it is faster."
                    },
                    {
                        "username": "close27",
                        "content": "[@MC_JRen](/MC_JRen)Did run into the problem. Can you please explain how you figured it out?"
                    },
                    {
                        "username": "L39ND",
                        "content": "thats exactly what I need, thank you so much! "
                    },
                    {
                        "username": "Kis_shot",
                        "content": "thank you so much!!!it confused me a lot until i put \"&\" to pass through"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\\n\\nWe can understand by using an example:\\n\\nGiven an 2d array of size 4 with  [10,16] , [2,8] , [1,6] , [7,12]\\n\\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\\n\\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\\n\\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\\n\\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\\n\\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\\n\\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\\n\\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\\n\\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\\n\\nAt last, return the arrow counter.\\n\\nSolution link for better understanding: [https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000437/simple-c-code/?orderBy=newest_to_oldest)\\n\\nI hope it helps ^_^"
                    },
                    {
                        "username": "JuanQP",
                        "content": "Very clean solution!"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "wow, I used similar theory but I used stack for replacing two balloons with their overlap instead. Here is a better written solution :: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\\n"
                    },
                    {
                        "username": "mausami",
                        "content": "Take care of the following test cases while sorting the array:\\n1. []\\n2. [[1,2],[2,3],[3,4],[4,5]]\\n3. [[-2147483646,-2147483645],[2147483646,2147483647]]\\n4. [[10,16],[2,8],[1,6],[7,12]]\\n5. [[1,2],[3,4],[5,6],[7,8]]\\n6. [[1,2]]\\n7. [[2,3],[2,3]]\\n"
                    },
                    {
                        "username": "dvakar",
                        "content": "8. [[77171087,133597895],[45117276,135064454],[80695788,90089372],[91705403,110208054],[52392754,127005153],[53999932,118094992],[11549676,55543044],[43947739,128157751],[55636226,105334812],[69348094,125645633]]"
                    },
                    {
                        "username": "srbssv",
                        "content": "What should we return in case of [[-2147483646,-2147483645],[2147483646,2147483647]]?"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "HUH, Interesting, Funny I didnt find any of these because my stack solution handled them all ok I guess. Here it is:: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "aditisingh10022018",
                        "content": "my test case is also failing at 3rd test case why?"
                    },
                    {
                        "username": "tajnur",
                        "content": "According to the constraints, empty points is not valid. Points should have at least one element..\\n"
                    },
                    {
                        "username": "divyamahankali29",
                        "content": "also, [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] "
                    },
                    {
                        "username": "santanusen",
                        "content": "It would have taken me hours to solve such problems a few months back. I was able to solve it in 15 mins today thanks to daily leetcoding. Leetcode definitely helps.\\n\\nTip:\\nsort the points, track how many consecutive points intersect (keep tracking and narrowing down the intersecting coordinates)."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Lovely Tip. I used stack to replace a set of overlapping balloons with their overlap and count the number of balloons end at left. Here is my solution: https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes"
                    },
                    {
                        "username": "belinskyi",
                        "content": "I have the same feeling now and it makes me happy. For everyone, keep practicing and you\\'ll be rewarded, don\\'t give up! "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "MentalHealth--;\\nStress++;"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "\\uD83D\\uDE02\\u270C\\uFE0F"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\nWhy expected output for this is 2, as per given instructions it should be 1. Can anyone please give me an explanation, it will be very helpful."
                    }
                ]
            },
            {
                "id": 1742910,
                "content": [
                    {
                        "username": "HighViscosityFlow",
                        "content": "Why is this freaking hard for me? Is it really medium? haha"
                    },
                    {
                        "username": "rosash",
                        "content": "It was tricky to think about. Now you are prepared for the next greedy problem. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "step1: sort the array with x(end). \\nright=array[0][1], output=1\\nstep 2: loop with condition if array[i][1]>right then output++, right=array[i][1]\\nreturn output"
                    },
                    {
                        "username": "kimkapitan",
                        "content": "there is wrong test case:\\n[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n\\nIf we are going to sort by x[0], y[0] first and if x[0] == y[0] we will sort by x[1], y[1] we will get result like this:\\n[[1,10],[3,9],[4,11],[6,7],[6,9],[8,12],[9,12]]\\nWe can see that there is no x[0] which is bigger then our first element END of balloon [1,10] (all x[0] are  less then 10)\\nSo we need only 1 arrow to shoot, but 2 arrows in the test case are expected.\\n\\nAm I wrong?\\n"
                    },
                    {
                        "username": "tsd832",
                        "content": "Hopefully this picture helps clear things up, please up vote if it does :D\n\n<a href=\"https://ibb.co/sbSkczJ\"><img src=\"https://i.ibb.co/KbZRBSz/AF7-A2-ECD-C246-4057-B34-B-C3-EEE4-FAC9-C1.png\" alt=\"AF7-A2-ECD-C246-4057-B34-B-C3-EEE4-FAC9-C1\" border=\"0\"></a>\n\nBalloon D is the culprit as to why you can't get all balloons shot down in 1 shot. There are two optimal answers, shooting ABCDE then FG (Green line) or shooting ABCFG then DE (Purple line). When the array is sorted you can continue to update your greedy boundary taking the left edge to be the maximum of your current edge vs the next balloon you are comparing. The right edge will be the minimum. Once the next balloon is outside of that updated edge you can add one shot to your counter and then start with balloon that failed the boundary test and repeat the loop. I can elaborate more if this doesn't make sense. Small Python code snippet below of the min/max updating.\n\n```\nxs = max(xs, points[j][0])\nxe = min(xe, points[j][1])\n```\n\nHope this helps and happy coding!\n\n"
                    },
                    {
                        "username": "Kis_shot",
                        "content": "[@swarnarr](/swarnarr) well, I think you maybe do not understand this question so much, technically [6,7] and [9,12] mean two balloons, surely contained by [1,10] but you can not shoot them within one arrow.\\nFor example, if I choose x=6 to hit [1,10] and [6,7] with an arrow, you choose x=? To hit [6,7] and [9,12]\\uFF1F"
                    },
                    {
                        "username": "swarnarr",
                        "content": "[@Kis_shot](/Kis_shot) logically one arrow makes sense because [1,10] should cover both [6,7] & [9, 12]"
                    },
                    {
                        "username": "Kis_shot",
                        "content": "[6,7],[9,12],apparently you need at least 2 arrows. maybe sort by the second number is better"
                    },
                    {
                        "username": "upstairs_he",
                        "content": "Apparently sorting by start would fail whereas by end passed. Anyone could break down the philosophy behind?"
                    },
                    {
                        "username": "abhi098",
                        "content": "[@shriyansnaik](/shriyansnaik) this was good approach"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "[@shriyansnaik](/shriyansnaik) prev_start, prev_end is more apt than cur_start, cur_end. isn\\'t it?"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@shriyansnaik](/shriyansnaik) You don\\'t really need the cur_start. You are not really using it anywhere. You can get the answer even if you remove cur_start and its update step. "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Does not really matter. You can sort by start or end and make it work depending upon your implementation.\\nMy code which sorts by first value\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort()\\n        arrows = 1\\n        cur_start,cur_end = points[0]\\n        for start,end in points:\\n            if start>cur_end: \\n                arrows += 1\\n                cur_start,cur_end = start,end\\n            else:\\n                cur_start = max(cur_start,start)\\n                cur_end = min(cur_end,end)\\n        return arrows\\n```"
                    },
                    {
                        "username": "choi_taek",
                        "content": "if you shoot array from the end point of the ballon's diameter then sorting end points in ascending order will shoot out all other ballons whose start points are less than the end point of the shoot position. \nif you choose to work with start position then sort it in descending order. That will work. \nIn the beginning I was also trying to sort the array in ascending order according to start point. But [@vaibhavbhardwaj1987](/vaibhavbhardwaj1987) solution really helped me understand why my approach was wrong."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tpoints.sort(key = lambda x: x[1])\\n\\tcount = 0\\n\\tend = float(\"-inf\")\\n\\tfor a, b in points:\\n\\t\\tif end < a:\\n\\t\\t\\tcount += 1\\n\\t\\t\\tend = b\\n\\treturn count"
                    },
                    {
                        "username": "oliverzhuyh",
                        "content": "what is wrong with the last testcase which shows points =             \\nit equals empy, no [ ], not None, no nothing.\\nwhy? i have just made it to 50 and what?"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Classic greedy problem. For those who found this problem difficult or confusing, please read about Greedy algorithms, they can be used in such a wide variety of problems."
                    },
                    {
                        "username": "GRAv1TY_XD",
                        "content": "To solve this problem, you could follow these steps:\\n1.Sort the list of balloons by the end position of the horizontal diameter (xend).\\n2.Initialize a variable arrow_pos to the end position of the first balloon and a variable arrows to 1. This represents shooting an arrow at the end position of the first balloon.\\n3.Iterate through the list of balloons. For each balloon, if the start position (xstart) of the balloon is greater than the current arrow position, set the arrow position to the end position of the current balloon and increment the arrow count by 1. This represents shooting a new arrow at the end position of the current balloon.\\n4.Return the arrow count as the result."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] At x==7 it burst all ballons so answer should be 1...but expected output is 2 i don\\'t understand"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "[@Mariia_89](/Mariia_89) oo yeah i am sorry i didn\\'t notice that...i was having headache  solving this question reason  didn\\'t notice that..but thanks for the reply app that!"
                    },
                    {
                        "username": "praktiz",
                        "content": "I had a similar issue, I haven\\'t seen your code but in my case it was that I sorted the array but never specified to sort using the end position and that specific case failed."
                    },
                    {
                        "username": "Mariia_89",
                        "content": "But [8,12] and [9,12] can\\'t be burst by shooting X == 7"
                    },
                    {
                        "username": "adityamshidlyali",
                        "content": "Sort the balloon positions and draw them on the number line."
                    }
                ]
            },
            {
                "id": 1742847,
                "content": [
                    {
                        "username": "HighViscosityFlow",
                        "content": "Why is this freaking hard for me? Is it really medium? haha"
                    },
                    {
                        "username": "rosash",
                        "content": "It was tricky to think about. Now you are prepared for the next greedy problem. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "step1: sort the array with x(end). \\nright=array[0][1], output=1\\nstep 2: loop with condition if array[i][1]>right then output++, right=array[i][1]\\nreturn output"
                    },
                    {
                        "username": "kimkapitan",
                        "content": "there is wrong test case:\\n[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n\\nIf we are going to sort by x[0], y[0] first and if x[0] == y[0] we will sort by x[1], y[1] we will get result like this:\\n[[1,10],[3,9],[4,11],[6,7],[6,9],[8,12],[9,12]]\\nWe can see that there is no x[0] which is bigger then our first element END of balloon [1,10] (all x[0] are  less then 10)\\nSo we need only 1 arrow to shoot, but 2 arrows in the test case are expected.\\n\\nAm I wrong?\\n"
                    },
                    {
                        "username": "tsd832",
                        "content": "Hopefully this picture helps clear things up, please up vote if it does :D\n\n<a href=\"https://ibb.co/sbSkczJ\"><img src=\"https://i.ibb.co/KbZRBSz/AF7-A2-ECD-C246-4057-B34-B-C3-EEE4-FAC9-C1.png\" alt=\"AF7-A2-ECD-C246-4057-B34-B-C3-EEE4-FAC9-C1\" border=\"0\"></a>\n\nBalloon D is the culprit as to why you can't get all balloons shot down in 1 shot. There are two optimal answers, shooting ABCDE then FG (Green line) or shooting ABCFG then DE (Purple line). When the array is sorted you can continue to update your greedy boundary taking the left edge to be the maximum of your current edge vs the next balloon you are comparing. The right edge will be the minimum. Once the next balloon is outside of that updated edge you can add one shot to your counter and then start with balloon that failed the boundary test and repeat the loop. I can elaborate more if this doesn't make sense. Small Python code snippet below of the min/max updating.\n\n```\nxs = max(xs, points[j][0])\nxe = min(xe, points[j][1])\n```\n\nHope this helps and happy coding!\n\n"
                    },
                    {
                        "username": "Kis_shot",
                        "content": "[@swarnarr](/swarnarr) well, I think you maybe do not understand this question so much, technically [6,7] and [9,12] mean two balloons, surely contained by [1,10] but you can not shoot them within one arrow.\\nFor example, if I choose x=6 to hit [1,10] and [6,7] with an arrow, you choose x=? To hit [6,7] and [9,12]\\uFF1F"
                    },
                    {
                        "username": "swarnarr",
                        "content": "[@Kis_shot](/Kis_shot) logically one arrow makes sense because [1,10] should cover both [6,7] & [9, 12]"
                    },
                    {
                        "username": "Kis_shot",
                        "content": "[6,7],[9,12],apparently you need at least 2 arrows. maybe sort by the second number is better"
                    },
                    {
                        "username": "upstairs_he",
                        "content": "Apparently sorting by start would fail whereas by end passed. Anyone could break down the philosophy behind?"
                    },
                    {
                        "username": "abhi098",
                        "content": "[@shriyansnaik](/shriyansnaik) this was good approach"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "[@shriyansnaik](/shriyansnaik) prev_start, prev_end is more apt than cur_start, cur_end. isn\\'t it?"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@shriyansnaik](/shriyansnaik) You don\\'t really need the cur_start. You are not really using it anywhere. You can get the answer even if you remove cur_start and its update step. "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Does not really matter. You can sort by start or end and make it work depending upon your implementation.\\nMy code which sorts by first value\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort()\\n        arrows = 1\\n        cur_start,cur_end = points[0]\\n        for start,end in points:\\n            if start>cur_end: \\n                arrows += 1\\n                cur_start,cur_end = start,end\\n            else:\\n                cur_start = max(cur_start,start)\\n                cur_end = min(cur_end,end)\\n        return arrows\\n```"
                    },
                    {
                        "username": "choi_taek",
                        "content": "if you shoot array from the end point of the ballon's diameter then sorting end points in ascending order will shoot out all other ballons whose start points are less than the end point of the shoot position. \nif you choose to work with start position then sort it in descending order. That will work. \nIn the beginning I was also trying to sort the array in ascending order according to start point. But [@vaibhavbhardwaj1987](/vaibhavbhardwaj1987) solution really helped me understand why my approach was wrong."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tpoints.sort(key = lambda x: x[1])\\n\\tcount = 0\\n\\tend = float(\"-inf\")\\n\\tfor a, b in points:\\n\\t\\tif end < a:\\n\\t\\t\\tcount += 1\\n\\t\\t\\tend = b\\n\\treturn count"
                    },
                    {
                        "username": "oliverzhuyh",
                        "content": "what is wrong with the last testcase which shows points =             \\nit equals empy, no [ ], not None, no nothing.\\nwhy? i have just made it to 50 and what?"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Classic greedy problem. For those who found this problem difficult or confusing, please read about Greedy algorithms, they can be used in such a wide variety of problems."
                    },
                    {
                        "username": "GRAv1TY_XD",
                        "content": "To solve this problem, you could follow these steps:\\n1.Sort the list of balloons by the end position of the horizontal diameter (xend).\\n2.Initialize a variable arrow_pos to the end position of the first balloon and a variable arrows to 1. This represents shooting an arrow at the end position of the first balloon.\\n3.Iterate through the list of balloons. For each balloon, if the start position (xstart) of the balloon is greater than the current arrow position, set the arrow position to the end position of the current balloon and increment the arrow count by 1. This represents shooting a new arrow at the end position of the current balloon.\\n4.Return the arrow count as the result."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] At x==7 it burst all ballons so answer should be 1...but expected output is 2 i don\\'t understand"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "[@Mariia_89](/Mariia_89) oo yeah i am sorry i didn\\'t notice that...i was having headache  solving this question reason  didn\\'t notice that..but thanks for the reply app that!"
                    },
                    {
                        "username": "praktiz",
                        "content": "I had a similar issue, I haven\\'t seen your code but in my case it was that I sorted the array but never specified to sort using the end position and that specific case failed."
                    },
                    {
                        "username": "Mariia_89",
                        "content": "But [8,12] and [9,12] can\\'t be burst by shooting X == 7"
                    },
                    {
                        "username": "adityamshidlyali",
                        "content": "Sort the balloon positions and draw them on the number line."
                    }
                ]
            },
            {
                "id": 1704321,
                "content": [
                    {
                        "username": "HighViscosityFlow",
                        "content": "Why is this freaking hard for me? Is it really medium? haha"
                    },
                    {
                        "username": "rosash",
                        "content": "It was tricky to think about. Now you are prepared for the next greedy problem. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "step1: sort the array with x(end). \\nright=array[0][1], output=1\\nstep 2: loop with condition if array[i][1]>right then output++, right=array[i][1]\\nreturn output"
                    },
                    {
                        "username": "kimkapitan",
                        "content": "there is wrong test case:\\n[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n\\nIf we are going to sort by x[0], y[0] first and if x[0] == y[0] we will sort by x[1], y[1] we will get result like this:\\n[[1,10],[3,9],[4,11],[6,7],[6,9],[8,12],[9,12]]\\nWe can see that there is no x[0] which is bigger then our first element END of balloon [1,10] (all x[0] are  less then 10)\\nSo we need only 1 arrow to shoot, but 2 arrows in the test case are expected.\\n\\nAm I wrong?\\n"
                    },
                    {
                        "username": "tsd832",
                        "content": "Hopefully this picture helps clear things up, please up vote if it does :D\n\n<a href=\"https://ibb.co/sbSkczJ\"><img src=\"https://i.ibb.co/KbZRBSz/AF7-A2-ECD-C246-4057-B34-B-C3-EEE4-FAC9-C1.png\" alt=\"AF7-A2-ECD-C246-4057-B34-B-C3-EEE4-FAC9-C1\" border=\"0\"></a>\n\nBalloon D is the culprit as to why you can't get all balloons shot down in 1 shot. There are two optimal answers, shooting ABCDE then FG (Green line) or shooting ABCFG then DE (Purple line). When the array is sorted you can continue to update your greedy boundary taking the left edge to be the maximum of your current edge vs the next balloon you are comparing. The right edge will be the minimum. Once the next balloon is outside of that updated edge you can add one shot to your counter and then start with balloon that failed the boundary test and repeat the loop. I can elaborate more if this doesn't make sense. Small Python code snippet below of the min/max updating.\n\n```\nxs = max(xs, points[j][0])\nxe = min(xe, points[j][1])\n```\n\nHope this helps and happy coding!\n\n"
                    },
                    {
                        "username": "Kis_shot",
                        "content": "[@swarnarr](/swarnarr) well, I think you maybe do not understand this question so much, technically [6,7] and [9,12] mean two balloons, surely contained by [1,10] but you can not shoot them within one arrow.\\nFor example, if I choose x=6 to hit [1,10] and [6,7] with an arrow, you choose x=? To hit [6,7] and [9,12]\\uFF1F"
                    },
                    {
                        "username": "swarnarr",
                        "content": "[@Kis_shot](/Kis_shot) logically one arrow makes sense because [1,10] should cover both [6,7] & [9, 12]"
                    },
                    {
                        "username": "Kis_shot",
                        "content": "[6,7],[9,12],apparently you need at least 2 arrows. maybe sort by the second number is better"
                    },
                    {
                        "username": "upstairs_he",
                        "content": "Apparently sorting by start would fail whereas by end passed. Anyone could break down the philosophy behind?"
                    },
                    {
                        "username": "abhi098",
                        "content": "[@shriyansnaik](/shriyansnaik) this was good approach"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "[@shriyansnaik](/shriyansnaik) prev_start, prev_end is more apt than cur_start, cur_end. isn\\'t it?"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@shriyansnaik](/shriyansnaik) You don\\'t really need the cur_start. You are not really using it anywhere. You can get the answer even if you remove cur_start and its update step. "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Does not really matter. You can sort by start or end and make it work depending upon your implementation.\\nMy code which sorts by first value\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort()\\n        arrows = 1\\n        cur_start,cur_end = points[0]\\n        for start,end in points:\\n            if start>cur_end: \\n                arrows += 1\\n                cur_start,cur_end = start,end\\n            else:\\n                cur_start = max(cur_start,start)\\n                cur_end = min(cur_end,end)\\n        return arrows\\n```"
                    },
                    {
                        "username": "choi_taek",
                        "content": "if you shoot array from the end point of the ballon's diameter then sorting end points in ascending order will shoot out all other ballons whose start points are less than the end point of the shoot position. \nif you choose to work with start position then sort it in descending order. That will work. \nIn the beginning I was also trying to sort the array in ascending order according to start point. But [@vaibhavbhardwaj1987](/vaibhavbhardwaj1987) solution really helped me understand why my approach was wrong."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tpoints.sort(key = lambda x: x[1])\\n\\tcount = 0\\n\\tend = float(\"-inf\")\\n\\tfor a, b in points:\\n\\t\\tif end < a:\\n\\t\\t\\tcount += 1\\n\\t\\t\\tend = b\\n\\treturn count"
                    },
                    {
                        "username": "oliverzhuyh",
                        "content": "what is wrong with the last testcase which shows points =             \\nit equals empy, no [ ], not None, no nothing.\\nwhy? i have just made it to 50 and what?"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Classic greedy problem. For those who found this problem difficult or confusing, please read about Greedy algorithms, they can be used in such a wide variety of problems."
                    },
                    {
                        "username": "GRAv1TY_XD",
                        "content": "To solve this problem, you could follow these steps:\\n1.Sort the list of balloons by the end position of the horizontal diameter (xend).\\n2.Initialize a variable arrow_pos to the end position of the first balloon and a variable arrows to 1. This represents shooting an arrow at the end position of the first balloon.\\n3.Iterate through the list of balloons. For each balloon, if the start position (xstart) of the balloon is greater than the current arrow position, set the arrow position to the end position of the current balloon and increment the arrow count by 1. This represents shooting a new arrow at the end position of the current balloon.\\n4.Return the arrow count as the result."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] At x==7 it burst all ballons so answer should be 1...but expected output is 2 i don\\'t understand"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "[@Mariia_89](/Mariia_89) oo yeah i am sorry i didn\\'t notice that...i was having headache  solving this question reason  didn\\'t notice that..but thanks for the reply app that!"
                    },
                    {
                        "username": "praktiz",
                        "content": "I had a similar issue, I haven\\'t seen your code but in my case it was that I sorted the array but never specified to sort using the end position and that specific case failed."
                    },
                    {
                        "username": "Mariia_89",
                        "content": "But [8,12] and [9,12] can\\'t be burst by shooting X == 7"
                    },
                    {
                        "username": "adityamshidlyali",
                        "content": "Sort the balloon positions and draw them on the number line."
                    }
                ]
            },
            {
                "id": 1574100,
                "content": [
                    {
                        "username": "HighViscosityFlow",
                        "content": "Why is this freaking hard for me? Is it really medium? haha"
                    },
                    {
                        "username": "rosash",
                        "content": "It was tricky to think about. Now you are prepared for the next greedy problem. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "step1: sort the array with x(end). \\nright=array[0][1], output=1\\nstep 2: loop with condition if array[i][1]>right then output++, right=array[i][1]\\nreturn output"
                    },
                    {
                        "username": "kimkapitan",
                        "content": "there is wrong test case:\\n[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n\\nIf we are going to sort by x[0], y[0] first and if x[0] == y[0] we will sort by x[1], y[1] we will get result like this:\\n[[1,10],[3,9],[4,11],[6,7],[6,9],[8,12],[9,12]]\\nWe can see that there is no x[0] which is bigger then our first element END of balloon [1,10] (all x[0] are  less then 10)\\nSo we need only 1 arrow to shoot, but 2 arrows in the test case are expected.\\n\\nAm I wrong?\\n"
                    },
                    {
                        "username": "tsd832",
                        "content": "Hopefully this picture helps clear things up, please up vote if it does :D\n\n<a href=\"https://ibb.co/sbSkczJ\"><img src=\"https://i.ibb.co/KbZRBSz/AF7-A2-ECD-C246-4057-B34-B-C3-EEE4-FAC9-C1.png\" alt=\"AF7-A2-ECD-C246-4057-B34-B-C3-EEE4-FAC9-C1\" border=\"0\"></a>\n\nBalloon D is the culprit as to why you can't get all balloons shot down in 1 shot. There are two optimal answers, shooting ABCDE then FG (Green line) or shooting ABCFG then DE (Purple line). When the array is sorted you can continue to update your greedy boundary taking the left edge to be the maximum of your current edge vs the next balloon you are comparing. The right edge will be the minimum. Once the next balloon is outside of that updated edge you can add one shot to your counter and then start with balloon that failed the boundary test and repeat the loop. I can elaborate more if this doesn't make sense. Small Python code snippet below of the min/max updating.\n\n```\nxs = max(xs, points[j][0])\nxe = min(xe, points[j][1])\n```\n\nHope this helps and happy coding!\n\n"
                    },
                    {
                        "username": "Kis_shot",
                        "content": "[@swarnarr](/swarnarr) well, I think you maybe do not understand this question so much, technically [6,7] and [9,12] mean two balloons, surely contained by [1,10] but you can not shoot them within one arrow.\\nFor example, if I choose x=6 to hit [1,10] and [6,7] with an arrow, you choose x=? To hit [6,7] and [9,12]\\uFF1F"
                    },
                    {
                        "username": "swarnarr",
                        "content": "[@Kis_shot](/Kis_shot) logically one arrow makes sense because [1,10] should cover both [6,7] & [9, 12]"
                    },
                    {
                        "username": "Kis_shot",
                        "content": "[6,7],[9,12],apparently you need at least 2 arrows. maybe sort by the second number is better"
                    },
                    {
                        "username": "upstairs_he",
                        "content": "Apparently sorting by start would fail whereas by end passed. Anyone could break down the philosophy behind?"
                    },
                    {
                        "username": "abhi098",
                        "content": "[@shriyansnaik](/shriyansnaik) this was good approach"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "[@shriyansnaik](/shriyansnaik) prev_start, prev_end is more apt than cur_start, cur_end. isn\\'t it?"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@shriyansnaik](/shriyansnaik) You don\\'t really need the cur_start. You are not really using it anywhere. You can get the answer even if you remove cur_start and its update step. "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Does not really matter. You can sort by start or end and make it work depending upon your implementation.\\nMy code which sorts by first value\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort()\\n        arrows = 1\\n        cur_start,cur_end = points[0]\\n        for start,end in points:\\n            if start>cur_end: \\n                arrows += 1\\n                cur_start,cur_end = start,end\\n            else:\\n                cur_start = max(cur_start,start)\\n                cur_end = min(cur_end,end)\\n        return arrows\\n```"
                    },
                    {
                        "username": "choi_taek",
                        "content": "if you shoot array from the end point of the ballon's diameter then sorting end points in ascending order will shoot out all other ballons whose start points are less than the end point of the shoot position. \nif you choose to work with start position then sort it in descending order. That will work. \nIn the beginning I was also trying to sort the array in ascending order according to start point. But [@vaibhavbhardwaj1987](/vaibhavbhardwaj1987) solution really helped me understand why my approach was wrong."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tpoints.sort(key = lambda x: x[1])\\n\\tcount = 0\\n\\tend = float(\"-inf\")\\n\\tfor a, b in points:\\n\\t\\tif end < a:\\n\\t\\t\\tcount += 1\\n\\t\\t\\tend = b\\n\\treturn count"
                    },
                    {
                        "username": "oliverzhuyh",
                        "content": "what is wrong with the last testcase which shows points =             \\nit equals empy, no [ ], not None, no nothing.\\nwhy? i have just made it to 50 and what?"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Classic greedy problem. For those who found this problem difficult or confusing, please read about Greedy algorithms, they can be used in such a wide variety of problems."
                    },
                    {
                        "username": "GRAv1TY_XD",
                        "content": "To solve this problem, you could follow these steps:\\n1.Sort the list of balloons by the end position of the horizontal diameter (xend).\\n2.Initialize a variable arrow_pos to the end position of the first balloon and a variable arrows to 1. This represents shooting an arrow at the end position of the first balloon.\\n3.Iterate through the list of balloons. For each balloon, if the start position (xstart) of the balloon is greater than the current arrow position, set the arrow position to the end position of the current balloon and increment the arrow count by 1. This represents shooting a new arrow at the end position of the current balloon.\\n4.Return the arrow count as the result."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] At x==7 it burst all ballons so answer should be 1...but expected output is 2 i don\\'t understand"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "[@Mariia_89](/Mariia_89) oo yeah i am sorry i didn\\'t notice that...i was having headache  solving this question reason  didn\\'t notice that..but thanks for the reply app that!"
                    },
                    {
                        "username": "praktiz",
                        "content": "I had a similar issue, I haven\\'t seen your code but in my case it was that I sorted the array but never specified to sort using the end position and that specific case failed."
                    },
                    {
                        "username": "Mariia_89",
                        "content": "But [8,12] and [9,12] can\\'t be burst by shooting X == 7"
                    },
                    {
                        "username": "adityamshidlyali",
                        "content": "Sort the balloon positions and draw them on the number line."
                    }
                ]
            },
            {
                "id": 1575039,
                "content": [
                    {
                        "username": "HighViscosityFlow",
                        "content": "Why is this freaking hard for me? Is it really medium? haha"
                    },
                    {
                        "username": "rosash",
                        "content": "It was tricky to think about. Now you are prepared for the next greedy problem. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "step1: sort the array with x(end). \\nright=array[0][1], output=1\\nstep 2: loop with condition if array[i][1]>right then output++, right=array[i][1]\\nreturn output"
                    },
                    {
                        "username": "kimkapitan",
                        "content": "there is wrong test case:\\n[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n\\nIf we are going to sort by x[0], y[0] first and if x[0] == y[0] we will sort by x[1], y[1] we will get result like this:\\n[[1,10],[3,9],[4,11],[6,7],[6,9],[8,12],[9,12]]\\nWe can see that there is no x[0] which is bigger then our first element END of balloon [1,10] (all x[0] are  less then 10)\\nSo we need only 1 arrow to shoot, but 2 arrows in the test case are expected.\\n\\nAm I wrong?\\n"
                    },
                    {
                        "username": "tsd832",
                        "content": "Hopefully this picture helps clear things up, please up vote if it does :D\n\n<a href=\"https://ibb.co/sbSkczJ\"><img src=\"https://i.ibb.co/KbZRBSz/AF7-A2-ECD-C246-4057-B34-B-C3-EEE4-FAC9-C1.png\" alt=\"AF7-A2-ECD-C246-4057-B34-B-C3-EEE4-FAC9-C1\" border=\"0\"></a>\n\nBalloon D is the culprit as to why you can't get all balloons shot down in 1 shot. There are two optimal answers, shooting ABCDE then FG (Green line) or shooting ABCFG then DE (Purple line). When the array is sorted you can continue to update your greedy boundary taking the left edge to be the maximum of your current edge vs the next balloon you are comparing. The right edge will be the minimum. Once the next balloon is outside of that updated edge you can add one shot to your counter and then start with balloon that failed the boundary test and repeat the loop. I can elaborate more if this doesn't make sense. Small Python code snippet below of the min/max updating.\n\n```\nxs = max(xs, points[j][0])\nxe = min(xe, points[j][1])\n```\n\nHope this helps and happy coding!\n\n"
                    },
                    {
                        "username": "Kis_shot",
                        "content": "[@swarnarr](/swarnarr) well, I think you maybe do not understand this question so much, technically [6,7] and [9,12] mean two balloons, surely contained by [1,10] but you can not shoot them within one arrow.\\nFor example, if I choose x=6 to hit [1,10] and [6,7] with an arrow, you choose x=? To hit [6,7] and [9,12]\\uFF1F"
                    },
                    {
                        "username": "swarnarr",
                        "content": "[@Kis_shot](/Kis_shot) logically one arrow makes sense because [1,10] should cover both [6,7] & [9, 12]"
                    },
                    {
                        "username": "Kis_shot",
                        "content": "[6,7],[9,12],apparently you need at least 2 arrows. maybe sort by the second number is better"
                    },
                    {
                        "username": "upstairs_he",
                        "content": "Apparently sorting by start would fail whereas by end passed. Anyone could break down the philosophy behind?"
                    },
                    {
                        "username": "abhi098",
                        "content": "[@shriyansnaik](/shriyansnaik) this was good approach"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "[@shriyansnaik](/shriyansnaik) prev_start, prev_end is more apt than cur_start, cur_end. isn\\'t it?"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@shriyansnaik](/shriyansnaik) You don\\'t really need the cur_start. You are not really using it anywhere. You can get the answer even if you remove cur_start and its update step. "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Does not really matter. You can sort by start or end and make it work depending upon your implementation.\\nMy code which sorts by first value\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort()\\n        arrows = 1\\n        cur_start,cur_end = points[0]\\n        for start,end in points:\\n            if start>cur_end: \\n                arrows += 1\\n                cur_start,cur_end = start,end\\n            else:\\n                cur_start = max(cur_start,start)\\n                cur_end = min(cur_end,end)\\n        return arrows\\n```"
                    },
                    {
                        "username": "choi_taek",
                        "content": "if you shoot array from the end point of the ballon's diameter then sorting end points in ascending order will shoot out all other ballons whose start points are less than the end point of the shoot position. \nif you choose to work with start position then sort it in descending order. That will work. \nIn the beginning I was also trying to sort the array in ascending order according to start point. But [@vaibhavbhardwaj1987](/vaibhavbhardwaj1987) solution really helped me understand why my approach was wrong."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tpoints.sort(key = lambda x: x[1])\\n\\tcount = 0\\n\\tend = float(\"-inf\")\\n\\tfor a, b in points:\\n\\t\\tif end < a:\\n\\t\\t\\tcount += 1\\n\\t\\t\\tend = b\\n\\treturn count"
                    },
                    {
                        "username": "oliverzhuyh",
                        "content": "what is wrong with the last testcase which shows points =             \\nit equals empy, no [ ], not None, no nothing.\\nwhy? i have just made it to 50 and what?"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Classic greedy problem. For those who found this problem difficult or confusing, please read about Greedy algorithms, they can be used in such a wide variety of problems."
                    },
                    {
                        "username": "GRAv1TY_XD",
                        "content": "To solve this problem, you could follow these steps:\\n1.Sort the list of balloons by the end position of the horizontal diameter (xend).\\n2.Initialize a variable arrow_pos to the end position of the first balloon and a variable arrows to 1. This represents shooting an arrow at the end position of the first balloon.\\n3.Iterate through the list of balloons. For each balloon, if the start position (xstart) of the balloon is greater than the current arrow position, set the arrow position to the end position of the current balloon and increment the arrow count by 1. This represents shooting a new arrow at the end position of the current balloon.\\n4.Return the arrow count as the result."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] At x==7 it burst all ballons so answer should be 1...but expected output is 2 i don\\'t understand"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "[@Mariia_89](/Mariia_89) oo yeah i am sorry i didn\\'t notice that...i was having headache  solving this question reason  didn\\'t notice that..but thanks for the reply app that!"
                    },
                    {
                        "username": "praktiz",
                        "content": "I had a similar issue, I haven\\'t seen your code but in my case it was that I sorted the array but never specified to sort using the end position and that specific case failed."
                    },
                    {
                        "username": "Mariia_89",
                        "content": "But [8,12] and [9,12] can\\'t be burst by shooting X == 7"
                    },
                    {
                        "username": "adityamshidlyali",
                        "content": "Sort the balloon positions and draw them on the number line."
                    }
                ]
            },
            {
                "id": 1919834,
                "content": [
                    {
                        "username": "HighViscosityFlow",
                        "content": "Why is this freaking hard for me? Is it really medium? haha"
                    },
                    {
                        "username": "rosash",
                        "content": "It was tricky to think about. Now you are prepared for the next greedy problem. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "step1: sort the array with x(end). \\nright=array[0][1], output=1\\nstep 2: loop with condition if array[i][1]>right then output++, right=array[i][1]\\nreturn output"
                    },
                    {
                        "username": "kimkapitan",
                        "content": "there is wrong test case:\\n[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n\\nIf we are going to sort by x[0], y[0] first and if x[0] == y[0] we will sort by x[1], y[1] we will get result like this:\\n[[1,10],[3,9],[4,11],[6,7],[6,9],[8,12],[9,12]]\\nWe can see that there is no x[0] which is bigger then our first element END of balloon [1,10] (all x[0] are  less then 10)\\nSo we need only 1 arrow to shoot, but 2 arrows in the test case are expected.\\n\\nAm I wrong?\\n"
                    },
                    {
                        "username": "tsd832",
                        "content": "Hopefully this picture helps clear things up, please up vote if it does :D\n\n<a href=\"https://ibb.co/sbSkczJ\"><img src=\"https://i.ibb.co/KbZRBSz/AF7-A2-ECD-C246-4057-B34-B-C3-EEE4-FAC9-C1.png\" alt=\"AF7-A2-ECD-C246-4057-B34-B-C3-EEE4-FAC9-C1\" border=\"0\"></a>\n\nBalloon D is the culprit as to why you can't get all balloons shot down in 1 shot. There are two optimal answers, shooting ABCDE then FG (Green line) or shooting ABCFG then DE (Purple line). When the array is sorted you can continue to update your greedy boundary taking the left edge to be the maximum of your current edge vs the next balloon you are comparing. The right edge will be the minimum. Once the next balloon is outside of that updated edge you can add one shot to your counter and then start with balloon that failed the boundary test and repeat the loop. I can elaborate more if this doesn't make sense. Small Python code snippet below of the min/max updating.\n\n```\nxs = max(xs, points[j][0])\nxe = min(xe, points[j][1])\n```\n\nHope this helps and happy coding!\n\n"
                    },
                    {
                        "username": "Kis_shot",
                        "content": "[@swarnarr](/swarnarr) well, I think you maybe do not understand this question so much, technically [6,7] and [9,12] mean two balloons, surely contained by [1,10] but you can not shoot them within one arrow.\\nFor example, if I choose x=6 to hit [1,10] and [6,7] with an arrow, you choose x=? To hit [6,7] and [9,12]\\uFF1F"
                    },
                    {
                        "username": "swarnarr",
                        "content": "[@Kis_shot](/Kis_shot) logically one arrow makes sense because [1,10] should cover both [6,7] & [9, 12]"
                    },
                    {
                        "username": "Kis_shot",
                        "content": "[6,7],[9,12],apparently you need at least 2 arrows. maybe sort by the second number is better"
                    },
                    {
                        "username": "upstairs_he",
                        "content": "Apparently sorting by start would fail whereas by end passed. Anyone could break down the philosophy behind?"
                    },
                    {
                        "username": "abhi098",
                        "content": "[@shriyansnaik](/shriyansnaik) this was good approach"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "[@shriyansnaik](/shriyansnaik) prev_start, prev_end is more apt than cur_start, cur_end. isn\\'t it?"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@shriyansnaik](/shriyansnaik) You don\\'t really need the cur_start. You are not really using it anywhere. You can get the answer even if you remove cur_start and its update step. "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Does not really matter. You can sort by start or end and make it work depending upon your implementation.\\nMy code which sorts by first value\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort()\\n        arrows = 1\\n        cur_start,cur_end = points[0]\\n        for start,end in points:\\n            if start>cur_end: \\n                arrows += 1\\n                cur_start,cur_end = start,end\\n            else:\\n                cur_start = max(cur_start,start)\\n                cur_end = min(cur_end,end)\\n        return arrows\\n```"
                    },
                    {
                        "username": "choi_taek",
                        "content": "if you shoot array from the end point of the ballon's diameter then sorting end points in ascending order will shoot out all other ballons whose start points are less than the end point of the shoot position. \nif you choose to work with start position then sort it in descending order. That will work. \nIn the beginning I was also trying to sort the array in ascending order according to start point. But [@vaibhavbhardwaj1987](/vaibhavbhardwaj1987) solution really helped me understand why my approach was wrong."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tpoints.sort(key = lambda x: x[1])\\n\\tcount = 0\\n\\tend = float(\"-inf\")\\n\\tfor a, b in points:\\n\\t\\tif end < a:\\n\\t\\t\\tcount += 1\\n\\t\\t\\tend = b\\n\\treturn count"
                    },
                    {
                        "username": "oliverzhuyh",
                        "content": "what is wrong with the last testcase which shows points =             \\nit equals empy, no [ ], not None, no nothing.\\nwhy? i have just made it to 50 and what?"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Classic greedy problem. For those who found this problem difficult or confusing, please read about Greedy algorithms, they can be used in such a wide variety of problems."
                    },
                    {
                        "username": "GRAv1TY_XD",
                        "content": "To solve this problem, you could follow these steps:\\n1.Sort the list of balloons by the end position of the horizontal diameter (xend).\\n2.Initialize a variable arrow_pos to the end position of the first balloon and a variable arrows to 1. This represents shooting an arrow at the end position of the first balloon.\\n3.Iterate through the list of balloons. For each balloon, if the start position (xstart) of the balloon is greater than the current arrow position, set the arrow position to the end position of the current balloon and increment the arrow count by 1. This represents shooting a new arrow at the end position of the current balloon.\\n4.Return the arrow count as the result."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] At x==7 it burst all ballons so answer should be 1...but expected output is 2 i don\\'t understand"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "[@Mariia_89](/Mariia_89) oo yeah i am sorry i didn\\'t notice that...i was having headache  solving this question reason  didn\\'t notice that..but thanks for the reply app that!"
                    },
                    {
                        "username": "praktiz",
                        "content": "I had a similar issue, I haven\\'t seen your code but in my case it was that I sorted the array but never specified to sort using the end position and that specific case failed."
                    },
                    {
                        "username": "Mariia_89",
                        "content": "But [8,12] and [9,12] can\\'t be burst by shooting X == 7"
                    },
                    {
                        "username": "adityamshidlyali",
                        "content": "Sort the balloon positions and draw them on the number line."
                    }
                ]
            },
            {
                "id": 1743366,
                "content": [
                    {
                        "username": "HighViscosityFlow",
                        "content": "Why is this freaking hard for me? Is it really medium? haha"
                    },
                    {
                        "username": "rosash",
                        "content": "It was tricky to think about. Now you are prepared for the next greedy problem. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "step1: sort the array with x(end). \\nright=array[0][1], output=1\\nstep 2: loop with condition if array[i][1]>right then output++, right=array[i][1]\\nreturn output"
                    },
                    {
                        "username": "kimkapitan",
                        "content": "there is wrong test case:\\n[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n\\nIf we are going to sort by x[0], y[0] first and if x[0] == y[0] we will sort by x[1], y[1] we will get result like this:\\n[[1,10],[3,9],[4,11],[6,7],[6,9],[8,12],[9,12]]\\nWe can see that there is no x[0] which is bigger then our first element END of balloon [1,10] (all x[0] are  less then 10)\\nSo we need only 1 arrow to shoot, but 2 arrows in the test case are expected.\\n\\nAm I wrong?\\n"
                    },
                    {
                        "username": "tsd832",
                        "content": "Hopefully this picture helps clear things up, please up vote if it does :D\n\n<a href=\"https://ibb.co/sbSkczJ\"><img src=\"https://i.ibb.co/KbZRBSz/AF7-A2-ECD-C246-4057-B34-B-C3-EEE4-FAC9-C1.png\" alt=\"AF7-A2-ECD-C246-4057-B34-B-C3-EEE4-FAC9-C1\" border=\"0\"></a>\n\nBalloon D is the culprit as to why you can't get all balloons shot down in 1 shot. There are two optimal answers, shooting ABCDE then FG (Green line) or shooting ABCFG then DE (Purple line). When the array is sorted you can continue to update your greedy boundary taking the left edge to be the maximum of your current edge vs the next balloon you are comparing. The right edge will be the minimum. Once the next balloon is outside of that updated edge you can add one shot to your counter and then start with balloon that failed the boundary test and repeat the loop. I can elaborate more if this doesn't make sense. Small Python code snippet below of the min/max updating.\n\n```\nxs = max(xs, points[j][0])\nxe = min(xe, points[j][1])\n```\n\nHope this helps and happy coding!\n\n"
                    },
                    {
                        "username": "Kis_shot",
                        "content": "[@swarnarr](/swarnarr) well, I think you maybe do not understand this question so much, technically [6,7] and [9,12] mean two balloons, surely contained by [1,10] but you can not shoot them within one arrow.\\nFor example, if I choose x=6 to hit [1,10] and [6,7] with an arrow, you choose x=? To hit [6,7] and [9,12]\\uFF1F"
                    },
                    {
                        "username": "swarnarr",
                        "content": "[@Kis_shot](/Kis_shot) logically one arrow makes sense because [1,10] should cover both [6,7] & [9, 12]"
                    },
                    {
                        "username": "Kis_shot",
                        "content": "[6,7],[9,12],apparently you need at least 2 arrows. maybe sort by the second number is better"
                    },
                    {
                        "username": "upstairs_he",
                        "content": "Apparently sorting by start would fail whereas by end passed. Anyone could break down the philosophy behind?"
                    },
                    {
                        "username": "abhi098",
                        "content": "[@shriyansnaik](/shriyansnaik) this was good approach"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "[@shriyansnaik](/shriyansnaik) prev_start, prev_end is more apt than cur_start, cur_end. isn\\'t it?"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@shriyansnaik](/shriyansnaik) You don\\'t really need the cur_start. You are not really using it anywhere. You can get the answer even if you remove cur_start and its update step. "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Does not really matter. You can sort by start or end and make it work depending upon your implementation.\\nMy code which sorts by first value\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort()\\n        arrows = 1\\n        cur_start,cur_end = points[0]\\n        for start,end in points:\\n            if start>cur_end: \\n                arrows += 1\\n                cur_start,cur_end = start,end\\n            else:\\n                cur_start = max(cur_start,start)\\n                cur_end = min(cur_end,end)\\n        return arrows\\n```"
                    },
                    {
                        "username": "choi_taek",
                        "content": "if you shoot array from the end point of the ballon's diameter then sorting end points in ascending order will shoot out all other ballons whose start points are less than the end point of the shoot position. \nif you choose to work with start position then sort it in descending order. That will work. \nIn the beginning I was also trying to sort the array in ascending order according to start point. But [@vaibhavbhardwaj1987](/vaibhavbhardwaj1987) solution really helped me understand why my approach was wrong."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tpoints.sort(key = lambda x: x[1])\\n\\tcount = 0\\n\\tend = float(\"-inf\")\\n\\tfor a, b in points:\\n\\t\\tif end < a:\\n\\t\\t\\tcount += 1\\n\\t\\t\\tend = b\\n\\treturn count"
                    },
                    {
                        "username": "oliverzhuyh",
                        "content": "what is wrong with the last testcase which shows points =             \\nit equals empy, no [ ], not None, no nothing.\\nwhy? i have just made it to 50 and what?"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Classic greedy problem. For those who found this problem difficult or confusing, please read about Greedy algorithms, they can be used in such a wide variety of problems."
                    },
                    {
                        "username": "GRAv1TY_XD",
                        "content": "To solve this problem, you could follow these steps:\\n1.Sort the list of balloons by the end position of the horizontal diameter (xend).\\n2.Initialize a variable arrow_pos to the end position of the first balloon and a variable arrows to 1. This represents shooting an arrow at the end position of the first balloon.\\n3.Iterate through the list of balloons. For each balloon, if the start position (xstart) of the balloon is greater than the current arrow position, set the arrow position to the end position of the current balloon and increment the arrow count by 1. This represents shooting a new arrow at the end position of the current balloon.\\n4.Return the arrow count as the result."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] At x==7 it burst all ballons so answer should be 1...but expected output is 2 i don\\'t understand"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "[@Mariia_89](/Mariia_89) oo yeah i am sorry i didn\\'t notice that...i was having headache  solving this question reason  didn\\'t notice that..but thanks for the reply app that!"
                    },
                    {
                        "username": "praktiz",
                        "content": "I had a similar issue, I haven\\'t seen your code but in my case it was that I sorted the array but never specified to sort using the end position and that specific case failed."
                    },
                    {
                        "username": "Mariia_89",
                        "content": "But [8,12] and [9,12] can\\'t be burst by shooting X == 7"
                    },
                    {
                        "username": "adityamshidlyali",
                        "content": "Sort the balloon positions and draw them on the number line."
                    }
                ]
            },
            {
                "id": 1743181,
                "content": [
                    {
                        "username": "HighViscosityFlow",
                        "content": "Why is this freaking hard for me? Is it really medium? haha"
                    },
                    {
                        "username": "rosash",
                        "content": "It was tricky to think about. Now you are prepared for the next greedy problem. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "step1: sort the array with x(end). \\nright=array[0][1], output=1\\nstep 2: loop with condition if array[i][1]>right then output++, right=array[i][1]\\nreturn output"
                    },
                    {
                        "username": "kimkapitan",
                        "content": "there is wrong test case:\\n[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n\\nIf we are going to sort by x[0], y[0] first and if x[0] == y[0] we will sort by x[1], y[1] we will get result like this:\\n[[1,10],[3,9],[4,11],[6,7],[6,9],[8,12],[9,12]]\\nWe can see that there is no x[0] which is bigger then our first element END of balloon [1,10] (all x[0] are  less then 10)\\nSo we need only 1 arrow to shoot, but 2 arrows in the test case are expected.\\n\\nAm I wrong?\\n"
                    },
                    {
                        "username": "tsd832",
                        "content": "Hopefully this picture helps clear things up, please up vote if it does :D\n\n<a href=\"https://ibb.co/sbSkczJ\"><img src=\"https://i.ibb.co/KbZRBSz/AF7-A2-ECD-C246-4057-B34-B-C3-EEE4-FAC9-C1.png\" alt=\"AF7-A2-ECD-C246-4057-B34-B-C3-EEE4-FAC9-C1\" border=\"0\"></a>\n\nBalloon D is the culprit as to why you can't get all balloons shot down in 1 shot. There are two optimal answers, shooting ABCDE then FG (Green line) or shooting ABCFG then DE (Purple line). When the array is sorted you can continue to update your greedy boundary taking the left edge to be the maximum of your current edge vs the next balloon you are comparing. The right edge will be the minimum. Once the next balloon is outside of that updated edge you can add one shot to your counter and then start with balloon that failed the boundary test and repeat the loop. I can elaborate more if this doesn't make sense. Small Python code snippet below of the min/max updating.\n\n```\nxs = max(xs, points[j][0])\nxe = min(xe, points[j][1])\n```\n\nHope this helps and happy coding!\n\n"
                    },
                    {
                        "username": "Kis_shot",
                        "content": "[@swarnarr](/swarnarr) well, I think you maybe do not understand this question so much, technically [6,7] and [9,12] mean two balloons, surely contained by [1,10] but you can not shoot them within one arrow.\\nFor example, if I choose x=6 to hit [1,10] and [6,7] with an arrow, you choose x=? To hit [6,7] and [9,12]\\uFF1F"
                    },
                    {
                        "username": "swarnarr",
                        "content": "[@Kis_shot](/Kis_shot) logically one arrow makes sense because [1,10] should cover both [6,7] & [9, 12]"
                    },
                    {
                        "username": "Kis_shot",
                        "content": "[6,7],[9,12],apparently you need at least 2 arrows. maybe sort by the second number is better"
                    },
                    {
                        "username": "upstairs_he",
                        "content": "Apparently sorting by start would fail whereas by end passed. Anyone could break down the philosophy behind?"
                    },
                    {
                        "username": "abhi098",
                        "content": "[@shriyansnaik](/shriyansnaik) this was good approach"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "[@shriyansnaik](/shriyansnaik) prev_start, prev_end is more apt than cur_start, cur_end. isn\\'t it?"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@shriyansnaik](/shriyansnaik) You don\\'t really need the cur_start. You are not really using it anywhere. You can get the answer even if you remove cur_start and its update step. "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Does not really matter. You can sort by start or end and make it work depending upon your implementation.\\nMy code which sorts by first value\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort()\\n        arrows = 1\\n        cur_start,cur_end = points[0]\\n        for start,end in points:\\n            if start>cur_end: \\n                arrows += 1\\n                cur_start,cur_end = start,end\\n            else:\\n                cur_start = max(cur_start,start)\\n                cur_end = min(cur_end,end)\\n        return arrows\\n```"
                    },
                    {
                        "username": "choi_taek",
                        "content": "if you shoot array from the end point of the ballon's diameter then sorting end points in ascending order will shoot out all other ballons whose start points are less than the end point of the shoot position. \nif you choose to work with start position then sort it in descending order. That will work. \nIn the beginning I was also trying to sort the array in ascending order according to start point. But [@vaibhavbhardwaj1987](/vaibhavbhardwaj1987) solution really helped me understand why my approach was wrong."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tpoints.sort(key = lambda x: x[1])\\n\\tcount = 0\\n\\tend = float(\"-inf\")\\n\\tfor a, b in points:\\n\\t\\tif end < a:\\n\\t\\t\\tcount += 1\\n\\t\\t\\tend = b\\n\\treturn count"
                    },
                    {
                        "username": "oliverzhuyh",
                        "content": "what is wrong with the last testcase which shows points =             \\nit equals empy, no [ ], not None, no nothing.\\nwhy? i have just made it to 50 and what?"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Classic greedy problem. For those who found this problem difficult or confusing, please read about Greedy algorithms, they can be used in such a wide variety of problems."
                    },
                    {
                        "username": "GRAv1TY_XD",
                        "content": "To solve this problem, you could follow these steps:\\n1.Sort the list of balloons by the end position of the horizontal diameter (xend).\\n2.Initialize a variable arrow_pos to the end position of the first balloon and a variable arrows to 1. This represents shooting an arrow at the end position of the first balloon.\\n3.Iterate through the list of balloons. For each balloon, if the start position (xstart) of the balloon is greater than the current arrow position, set the arrow position to the end position of the current balloon and increment the arrow count by 1. This represents shooting a new arrow at the end position of the current balloon.\\n4.Return the arrow count as the result."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] At x==7 it burst all ballons so answer should be 1...but expected output is 2 i don\\'t understand"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "[@Mariia_89](/Mariia_89) oo yeah i am sorry i didn\\'t notice that...i was having headache  solving this question reason  didn\\'t notice that..but thanks for the reply app that!"
                    },
                    {
                        "username": "praktiz",
                        "content": "I had a similar issue, I haven\\'t seen your code but in my case it was that I sorted the array but never specified to sort using the end position and that specific case failed."
                    },
                    {
                        "username": "Mariia_89",
                        "content": "But [8,12] and [9,12] can\\'t be burst by shooting X == 7"
                    },
                    {
                        "username": "adityamshidlyali",
                        "content": "Sort the balloon positions and draw them on the number line."
                    }
                ]
            },
            {
                "id": 1743097,
                "content": [
                    {
                        "username": "HighViscosityFlow",
                        "content": "Why is this freaking hard for me? Is it really medium? haha"
                    },
                    {
                        "username": "rosash",
                        "content": "It was tricky to think about. Now you are prepared for the next greedy problem. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "step1: sort the array with x(end). \\nright=array[0][1], output=1\\nstep 2: loop with condition if array[i][1]>right then output++, right=array[i][1]\\nreturn output"
                    },
                    {
                        "username": "kimkapitan",
                        "content": "there is wrong test case:\\n[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n\\nIf we are going to sort by x[0], y[0] first and if x[0] == y[0] we will sort by x[1], y[1] we will get result like this:\\n[[1,10],[3,9],[4,11],[6,7],[6,9],[8,12],[9,12]]\\nWe can see that there is no x[0] which is bigger then our first element END of balloon [1,10] (all x[0] are  less then 10)\\nSo we need only 1 arrow to shoot, but 2 arrows in the test case are expected.\\n\\nAm I wrong?\\n"
                    },
                    {
                        "username": "tsd832",
                        "content": "Hopefully this picture helps clear things up, please up vote if it does :D\n\n<a href=\"https://ibb.co/sbSkczJ\"><img src=\"https://i.ibb.co/KbZRBSz/AF7-A2-ECD-C246-4057-B34-B-C3-EEE4-FAC9-C1.png\" alt=\"AF7-A2-ECD-C246-4057-B34-B-C3-EEE4-FAC9-C1\" border=\"0\"></a>\n\nBalloon D is the culprit as to why you can't get all balloons shot down in 1 shot. There are two optimal answers, shooting ABCDE then FG (Green line) or shooting ABCFG then DE (Purple line). When the array is sorted you can continue to update your greedy boundary taking the left edge to be the maximum of your current edge vs the next balloon you are comparing. The right edge will be the minimum. Once the next balloon is outside of that updated edge you can add one shot to your counter and then start with balloon that failed the boundary test and repeat the loop. I can elaborate more if this doesn't make sense. Small Python code snippet below of the min/max updating.\n\n```\nxs = max(xs, points[j][0])\nxe = min(xe, points[j][1])\n```\n\nHope this helps and happy coding!\n\n"
                    },
                    {
                        "username": "Kis_shot",
                        "content": "[@swarnarr](/swarnarr) well, I think you maybe do not understand this question so much, technically [6,7] and [9,12] mean two balloons, surely contained by [1,10] but you can not shoot them within one arrow.\\nFor example, if I choose x=6 to hit [1,10] and [6,7] with an arrow, you choose x=? To hit [6,7] and [9,12]\\uFF1F"
                    },
                    {
                        "username": "swarnarr",
                        "content": "[@Kis_shot](/Kis_shot) logically one arrow makes sense because [1,10] should cover both [6,7] & [9, 12]"
                    },
                    {
                        "username": "Kis_shot",
                        "content": "[6,7],[9,12],apparently you need at least 2 arrows. maybe sort by the second number is better"
                    },
                    {
                        "username": "upstairs_he",
                        "content": "Apparently sorting by start would fail whereas by end passed. Anyone could break down the philosophy behind?"
                    },
                    {
                        "username": "abhi098",
                        "content": "[@shriyansnaik](/shriyansnaik) this was good approach"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "[@shriyansnaik](/shriyansnaik) prev_start, prev_end is more apt than cur_start, cur_end. isn\\'t it?"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@shriyansnaik](/shriyansnaik) You don\\'t really need the cur_start. You are not really using it anywhere. You can get the answer even if you remove cur_start and its update step. "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Does not really matter. You can sort by start or end and make it work depending upon your implementation.\\nMy code which sorts by first value\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort()\\n        arrows = 1\\n        cur_start,cur_end = points[0]\\n        for start,end in points:\\n            if start>cur_end: \\n                arrows += 1\\n                cur_start,cur_end = start,end\\n            else:\\n                cur_start = max(cur_start,start)\\n                cur_end = min(cur_end,end)\\n        return arrows\\n```"
                    },
                    {
                        "username": "choi_taek",
                        "content": "if you shoot array from the end point of the ballon's diameter then sorting end points in ascending order will shoot out all other ballons whose start points are less than the end point of the shoot position. \nif you choose to work with start position then sort it in descending order. That will work. \nIn the beginning I was also trying to sort the array in ascending order according to start point. But [@vaibhavbhardwaj1987](/vaibhavbhardwaj1987) solution really helped me understand why my approach was wrong."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tpoints.sort(key = lambda x: x[1])\\n\\tcount = 0\\n\\tend = float(\"-inf\")\\n\\tfor a, b in points:\\n\\t\\tif end < a:\\n\\t\\t\\tcount += 1\\n\\t\\t\\tend = b\\n\\treturn count"
                    },
                    {
                        "username": "oliverzhuyh",
                        "content": "what is wrong with the last testcase which shows points =             \\nit equals empy, no [ ], not None, no nothing.\\nwhy? i have just made it to 50 and what?"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Classic greedy problem. For those who found this problem difficult or confusing, please read about Greedy algorithms, they can be used in such a wide variety of problems."
                    },
                    {
                        "username": "GRAv1TY_XD",
                        "content": "To solve this problem, you could follow these steps:\\n1.Sort the list of balloons by the end position of the horizontal diameter (xend).\\n2.Initialize a variable arrow_pos to the end position of the first balloon and a variable arrows to 1. This represents shooting an arrow at the end position of the first balloon.\\n3.Iterate through the list of balloons. For each balloon, if the start position (xstart) of the balloon is greater than the current arrow position, set the arrow position to the end position of the current balloon and increment the arrow count by 1. This represents shooting a new arrow at the end position of the current balloon.\\n4.Return the arrow count as the result."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] At x==7 it burst all ballons so answer should be 1...but expected output is 2 i don\\'t understand"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "[@Mariia_89](/Mariia_89) oo yeah i am sorry i didn\\'t notice that...i was having headache  solving this question reason  didn\\'t notice that..but thanks for the reply app that!"
                    },
                    {
                        "username": "praktiz",
                        "content": "I had a similar issue, I haven\\'t seen your code but in my case it was that I sorted the array but never specified to sort using the end position and that specific case failed."
                    },
                    {
                        "username": "Mariia_89",
                        "content": "But [8,12] and [9,12] can\\'t be burst by shooting X == 7"
                    },
                    {
                        "username": "adityamshidlyali",
                        "content": "Sort the balloon positions and draw them on the number line."
                    }
                ]
            },
            {
                "id": 1743069,
                "content": [
                    {
                        "username": "HighViscosityFlow",
                        "content": "Why is this freaking hard for me? Is it really medium? haha"
                    },
                    {
                        "username": "rosash",
                        "content": "It was tricky to think about. Now you are prepared for the next greedy problem. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "step1: sort the array with x(end). \\nright=array[0][1], output=1\\nstep 2: loop with condition if array[i][1]>right then output++, right=array[i][1]\\nreturn output"
                    },
                    {
                        "username": "kimkapitan",
                        "content": "there is wrong test case:\\n[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n\\nIf we are going to sort by x[0], y[0] first and if x[0] == y[0] we will sort by x[1], y[1] we will get result like this:\\n[[1,10],[3,9],[4,11],[6,7],[6,9],[8,12],[9,12]]\\nWe can see that there is no x[0] which is bigger then our first element END of balloon [1,10] (all x[0] are  less then 10)\\nSo we need only 1 arrow to shoot, but 2 arrows in the test case are expected.\\n\\nAm I wrong?\\n"
                    },
                    {
                        "username": "tsd832",
                        "content": "Hopefully this picture helps clear things up, please up vote if it does :D\n\n<a href=\"https://ibb.co/sbSkczJ\"><img src=\"https://i.ibb.co/KbZRBSz/AF7-A2-ECD-C246-4057-B34-B-C3-EEE4-FAC9-C1.png\" alt=\"AF7-A2-ECD-C246-4057-B34-B-C3-EEE4-FAC9-C1\" border=\"0\"></a>\n\nBalloon D is the culprit as to why you can't get all balloons shot down in 1 shot. There are two optimal answers, shooting ABCDE then FG (Green line) or shooting ABCFG then DE (Purple line). When the array is sorted you can continue to update your greedy boundary taking the left edge to be the maximum of your current edge vs the next balloon you are comparing. The right edge will be the minimum. Once the next balloon is outside of that updated edge you can add one shot to your counter and then start with balloon that failed the boundary test and repeat the loop. I can elaborate more if this doesn't make sense. Small Python code snippet below of the min/max updating.\n\n```\nxs = max(xs, points[j][0])\nxe = min(xe, points[j][1])\n```\n\nHope this helps and happy coding!\n\n"
                    },
                    {
                        "username": "Kis_shot",
                        "content": "[@swarnarr](/swarnarr) well, I think you maybe do not understand this question so much, technically [6,7] and [9,12] mean two balloons, surely contained by [1,10] but you can not shoot them within one arrow.\\nFor example, if I choose x=6 to hit [1,10] and [6,7] with an arrow, you choose x=? To hit [6,7] and [9,12]\\uFF1F"
                    },
                    {
                        "username": "swarnarr",
                        "content": "[@Kis_shot](/Kis_shot) logically one arrow makes sense because [1,10] should cover both [6,7] & [9, 12]"
                    },
                    {
                        "username": "Kis_shot",
                        "content": "[6,7],[9,12],apparently you need at least 2 arrows. maybe sort by the second number is better"
                    },
                    {
                        "username": "upstairs_he",
                        "content": "Apparently sorting by start would fail whereas by end passed. Anyone could break down the philosophy behind?"
                    },
                    {
                        "username": "abhi098",
                        "content": "[@shriyansnaik](/shriyansnaik) this was good approach"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "[@shriyansnaik](/shriyansnaik) prev_start, prev_end is more apt than cur_start, cur_end. isn\\'t it?"
                    },
                    {
                        "username": "dkashi",
                        "content": "[@shriyansnaik](/shriyansnaik) You don\\'t really need the cur_start. You are not really using it anywhere. You can get the answer even if you remove cur_start and its update step. "
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Does not really matter. You can sort by start or end and make it work depending upon your implementation.\\nMy code which sorts by first value\\n```\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort()\\n        arrows = 1\\n        cur_start,cur_end = points[0]\\n        for start,end in points:\\n            if start>cur_end: \\n                arrows += 1\\n                cur_start,cur_end = start,end\\n            else:\\n                cur_start = max(cur_start,start)\\n                cur_end = min(cur_end,end)\\n        return arrows\\n```"
                    },
                    {
                        "username": "choi_taek",
                        "content": "if you shoot array from the end point of the ballon's diameter then sorting end points in ascending order will shoot out all other ballons whose start points are less than the end point of the shoot position. \nif you choose to work with start position then sort it in descending order. That will work. \nIn the beginning I was also trying to sort the array in ascending order according to start point. But [@vaibhavbhardwaj1987](/vaibhavbhardwaj1987) solution really helped me understand why my approach was wrong."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tpoints.sort(key = lambda x: x[1])\\n\\tcount = 0\\n\\tend = float(\"-inf\")\\n\\tfor a, b in points:\\n\\t\\tif end < a:\\n\\t\\t\\tcount += 1\\n\\t\\t\\tend = b\\n\\treturn count"
                    },
                    {
                        "username": "oliverzhuyh",
                        "content": "what is wrong with the last testcase which shows points =             \\nit equals empy, no [ ], not None, no nothing.\\nwhy? i have just made it to 50 and what?"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Classic greedy problem. For those who found this problem difficult or confusing, please read about Greedy algorithms, they can be used in such a wide variety of problems."
                    },
                    {
                        "username": "GRAv1TY_XD",
                        "content": "To solve this problem, you could follow these steps:\\n1.Sort the list of balloons by the end position of the horizontal diameter (xend).\\n2.Initialize a variable arrow_pos to the end position of the first balloon and a variable arrows to 1. This represents shooting an arrow at the end position of the first balloon.\\n3.Iterate through the list of balloons. For each balloon, if the start position (xstart) of the balloon is greater than the current arrow position, set the arrow position to the end position of the current balloon and increment the arrow count by 1. This represents shooting a new arrow at the end position of the current balloon.\\n4.Return the arrow count as the result."
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] At x==7 it burst all ballons so answer should be 1...but expected output is 2 i don\\'t understand"
                    },
                    {
                        "username": "faisalirfan2502",
                        "content": "[@Mariia_89](/Mariia_89) oo yeah i am sorry i didn\\'t notice that...i was having headache  solving this question reason  didn\\'t notice that..but thanks for the reply app that!"
                    },
                    {
                        "username": "praktiz",
                        "content": "I had a similar issue, I haven\\'t seen your code but in my case it was that I sorted the array but never specified to sort using the end position and that specific case failed."
                    },
                    {
                        "username": "Mariia_89",
                        "content": "But [8,12] and [9,12] can\\'t be burst by shooting X == 7"
                    },
                    {
                        "username": "adityamshidlyali",
                        "content": "Sort the balloon positions and draw them on the number line."
                    }
                ]
            },
            {
                "id": 1742329,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "The mistake that I was making initially was merging the intervals.\\nInstead try finding out the <i>common parts</i> of two intervals."
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "is it possible to solve it without sort? will it be faster?"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) yeah that is what I got"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@huangqianchen2021](/huangqianchen2021) if you use normal sort without custom cmp\\nthen is short first col of matrix\\nex- \\n10 3\\n1 4\\n5 7\\n3 8\\n\\nafter sort \\n1 4\\n3 8\\n5 7 \\n10 3"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "[@huangqianchen2021](/huangqianchen2021) I didn\\'t use any compare function, it just work.\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@This_is_Allen_Lee](/This_is_Allen_Lee) how did you sort vector<vector<int>>?  check if you use & when compare."
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I don\\'t know why my code is so slow even it is the same logic as the fastest code\\nhere is the code\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        sort(points.begin(), points.end());\\n        int pointsSize = points.size();\\n        int rbound = points[0][1];\\n        int ans = 1;\\n\\n        for(int i = 1; i < pointsSize; i++){\\n            if (points[i][1] < rbound){\\n                rbound = points[i][1];\\n            }\\n            if (points[i][0] > rbound){\\n                ans++;\\n                rbound = points[i][1];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "I won't say it is not possible because it is based on how you think and what logic you use complexity can be lesser and higher.\n\nlike i can think of a solution that will solve this problem in O(N^2) without sorting\nsomeone else may be able to optimise it such that it take less complexity and he/she don't use sorting as well."
                    },
                    {
                        "username": "betaev",
                        "content": "this description is so \\uD83E\\uDD2F"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Instead of merging and increasing the width of the intervals, here we merge and shrink the intervals."
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "I am getting wrong answer for this testcase:\\npair[][]=\\n[[-2147483646,-2147483645],[2147483646,2147483647]]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- # Greedy Approach:\\n   - The \"Greedy\" approach is a simple and efficient technique to solve the \"Minimum Arrows to Burst Balloons\" problem. Here\\'s the step-by-step explanation of the approach:\\n\\n- **Sort the Balloons:**\\n   - First, we sort the array of balloons based on their end positions in ascending order. This is crucial to ensure that we can shoot an arrow at the end position of a balloon to burst all balloons that can be hit by that arrow.\\n- **Initialize Variables:**\\n   - Set prev to the end position of the first balloon in the sorted array. - This will serve as the reference for determining whether the current balloon can be burst with the same arrow as the previous one.\\n   - Initialize count to zero. This variable will keep track of the number of balloons that can be burst with a single arrow.\\n- **Iteration:**\\n   - Iterate through the sorted array of balloons starting from the second balloon (index 1).\\n   - For each balloon:\\n      - Check if its start position is less than or equal to the previous balloon\\'s end position and its end position is greater than or equal to the previous balloon\\'s end position. If this condition is met, it means the current balloon can be burst with the same arrow as the previous one, so increment the count.\\n      - If the current balloon cannot be burst with the previous one, update prev with the end position of the current balloon, indicating that a new arrow is needed.\\n- **Return the Result:**\\n  - Finally, return the minimum number of arrows required to burst all balloons, which is totalBalloons - count, where totalBalloons represents the total number of balloons in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3839256/easiest-solution-beat-99-69-submissions/"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "This question is very similar to https://leetcode.com/problems/non-overlapping-intervals/"
                    },
                    {
                        "username": "Vishal_0707",
                        "content": "Nice question it gives me lot of understanding about cmp and 2d arrays;"
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "-we must start from the left element to right so sorting will be a good idea \\n-when we see tow elements overlapping then we make them one element but with a smaller length"
                    },
                    {
                        "username": "ravishashi",
                        "content": "Why my code is giving TLE even its passed all given testcase also this is in Time complexity of O(NLogN). Kindly See this.\\n\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>v1,vector<int>v2)\\n    {\\n        return v1[1]<v2[1];\\n    }\\n\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n       sort(points.begin(),points.end(),cmp);\\n       int count=1;\\n       int end=points[0][1];\\n       for(int i=1;i<points.size();i++)\\n       {\\n           if(end<points[i][0])\\n           {\\n               count++;\\n               end=points[i][1];\\n           }\\n           else\\n           end=min(end,points[i][1]);\\n       }\\n       return count;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ravi Kant](/ravishashi) I do believe bc Sort!!! \nSo I have a minor improvement:\n\n470ms C++ 11-Jan-2023\n```\nclass Solution {\npublic:\n\n    int findMinArrowShots(vector<vector<int>>& points) {\n        sort(points.begin(),points.end());\n    int count=1 ;\n    int end= points[0][1];\n    for(int i=1;i<points.size();i++){\n        if (end > points[i][1]) {end= points[i][1]; continue;}\n        else if (end < points[i][0]) {count++; end= points[i][1];}\n    }\n    return count;\n}    \n};\n```\nGood luck!\n"
                    }
                ]
            },
            {
                "id": 1742207,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "The mistake that I was making initially was merging the intervals.\\nInstead try finding out the <i>common parts</i> of two intervals."
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "is it possible to solve it without sort? will it be faster?"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) yeah that is what I got"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@huangqianchen2021](/huangqianchen2021) if you use normal sort without custom cmp\\nthen is short first col of matrix\\nex- \\n10 3\\n1 4\\n5 7\\n3 8\\n\\nafter sort \\n1 4\\n3 8\\n5 7 \\n10 3"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "[@huangqianchen2021](/huangqianchen2021) I didn\\'t use any compare function, it just work.\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@This_is_Allen_Lee](/This_is_Allen_Lee) how did you sort vector<vector<int>>?  check if you use & when compare."
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I don\\'t know why my code is so slow even it is the same logic as the fastest code\\nhere is the code\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        sort(points.begin(), points.end());\\n        int pointsSize = points.size();\\n        int rbound = points[0][1];\\n        int ans = 1;\\n\\n        for(int i = 1; i < pointsSize; i++){\\n            if (points[i][1] < rbound){\\n                rbound = points[i][1];\\n            }\\n            if (points[i][0] > rbound){\\n                ans++;\\n                rbound = points[i][1];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "I won't say it is not possible because it is based on how you think and what logic you use complexity can be lesser and higher.\n\nlike i can think of a solution that will solve this problem in O(N^2) without sorting\nsomeone else may be able to optimise it such that it take less complexity and he/she don't use sorting as well."
                    },
                    {
                        "username": "betaev",
                        "content": "this description is so \\uD83E\\uDD2F"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Instead of merging and increasing the width of the intervals, here we merge and shrink the intervals."
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "I am getting wrong answer for this testcase:\\npair[][]=\\n[[-2147483646,-2147483645],[2147483646,2147483647]]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- # Greedy Approach:\\n   - The \"Greedy\" approach is a simple and efficient technique to solve the \"Minimum Arrows to Burst Balloons\" problem. Here\\'s the step-by-step explanation of the approach:\\n\\n- **Sort the Balloons:**\\n   - First, we sort the array of balloons based on their end positions in ascending order. This is crucial to ensure that we can shoot an arrow at the end position of a balloon to burst all balloons that can be hit by that arrow.\\n- **Initialize Variables:**\\n   - Set prev to the end position of the first balloon in the sorted array. - This will serve as the reference for determining whether the current balloon can be burst with the same arrow as the previous one.\\n   - Initialize count to zero. This variable will keep track of the number of balloons that can be burst with a single arrow.\\n- **Iteration:**\\n   - Iterate through the sorted array of balloons starting from the second balloon (index 1).\\n   - For each balloon:\\n      - Check if its start position is less than or equal to the previous balloon\\'s end position and its end position is greater than or equal to the previous balloon\\'s end position. If this condition is met, it means the current balloon can be burst with the same arrow as the previous one, so increment the count.\\n      - If the current balloon cannot be burst with the previous one, update prev with the end position of the current balloon, indicating that a new arrow is needed.\\n- **Return the Result:**\\n  - Finally, return the minimum number of arrows required to burst all balloons, which is totalBalloons - count, where totalBalloons represents the total number of balloons in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3839256/easiest-solution-beat-99-69-submissions/"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "This question is very similar to https://leetcode.com/problems/non-overlapping-intervals/"
                    },
                    {
                        "username": "Vishal_0707",
                        "content": "Nice question it gives me lot of understanding about cmp and 2d arrays;"
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "-we must start from the left element to right so sorting will be a good idea \\n-when we see tow elements overlapping then we make them one element but with a smaller length"
                    },
                    {
                        "username": "ravishashi",
                        "content": "Why my code is giving TLE even its passed all given testcase also this is in Time complexity of O(NLogN). Kindly See this.\\n\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>v1,vector<int>v2)\\n    {\\n        return v1[1]<v2[1];\\n    }\\n\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n       sort(points.begin(),points.end(),cmp);\\n       int count=1;\\n       int end=points[0][1];\\n       for(int i=1;i<points.size();i++)\\n       {\\n           if(end<points[i][0])\\n           {\\n               count++;\\n               end=points[i][1];\\n           }\\n           else\\n           end=min(end,points[i][1]);\\n       }\\n       return count;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ravi Kant](/ravishashi) I do believe bc Sort!!! \nSo I have a minor improvement:\n\n470ms C++ 11-Jan-2023\n```\nclass Solution {\npublic:\n\n    int findMinArrowShots(vector<vector<int>>& points) {\n        sort(points.begin(),points.end());\n    int count=1 ;\n    int end= points[0][1];\n    for(int i=1;i<points.size();i++){\n        if (end > points[i][1]) {end= points[i][1]; continue;}\n        else if (end < points[i][0]) {count++; end= points[i][1];}\n    }\n    return count;\n}    \n};\n```\nGood luck!\n"
                    }
                ]
            },
            {
                "id": 2068831,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "The mistake that I was making initially was merging the intervals.\\nInstead try finding out the <i>common parts</i> of two intervals."
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "is it possible to solve it without sort? will it be faster?"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) yeah that is what I got"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@huangqianchen2021](/huangqianchen2021) if you use normal sort without custom cmp\\nthen is short first col of matrix\\nex- \\n10 3\\n1 4\\n5 7\\n3 8\\n\\nafter sort \\n1 4\\n3 8\\n5 7 \\n10 3"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "[@huangqianchen2021](/huangqianchen2021) I didn\\'t use any compare function, it just work.\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@This_is_Allen_Lee](/This_is_Allen_Lee) how did you sort vector<vector<int>>?  check if you use & when compare."
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I don\\'t know why my code is so slow even it is the same logic as the fastest code\\nhere is the code\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        sort(points.begin(), points.end());\\n        int pointsSize = points.size();\\n        int rbound = points[0][1];\\n        int ans = 1;\\n\\n        for(int i = 1; i < pointsSize; i++){\\n            if (points[i][1] < rbound){\\n                rbound = points[i][1];\\n            }\\n            if (points[i][0] > rbound){\\n                ans++;\\n                rbound = points[i][1];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "I won't say it is not possible because it is based on how you think and what logic you use complexity can be lesser and higher.\n\nlike i can think of a solution that will solve this problem in O(N^2) without sorting\nsomeone else may be able to optimise it such that it take less complexity and he/she don't use sorting as well."
                    },
                    {
                        "username": "betaev",
                        "content": "this description is so \\uD83E\\uDD2F"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Instead of merging and increasing the width of the intervals, here we merge and shrink the intervals."
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "I am getting wrong answer for this testcase:\\npair[][]=\\n[[-2147483646,-2147483645],[2147483646,2147483647]]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- # Greedy Approach:\\n   - The \"Greedy\" approach is a simple and efficient technique to solve the \"Minimum Arrows to Burst Balloons\" problem. Here\\'s the step-by-step explanation of the approach:\\n\\n- **Sort the Balloons:**\\n   - First, we sort the array of balloons based on their end positions in ascending order. This is crucial to ensure that we can shoot an arrow at the end position of a balloon to burst all balloons that can be hit by that arrow.\\n- **Initialize Variables:**\\n   - Set prev to the end position of the first balloon in the sorted array. - This will serve as the reference for determining whether the current balloon can be burst with the same arrow as the previous one.\\n   - Initialize count to zero. This variable will keep track of the number of balloons that can be burst with a single arrow.\\n- **Iteration:**\\n   - Iterate through the sorted array of balloons starting from the second balloon (index 1).\\n   - For each balloon:\\n      - Check if its start position is less than or equal to the previous balloon\\'s end position and its end position is greater than or equal to the previous balloon\\'s end position. If this condition is met, it means the current balloon can be burst with the same arrow as the previous one, so increment the count.\\n      - If the current balloon cannot be burst with the previous one, update prev with the end position of the current balloon, indicating that a new arrow is needed.\\n- **Return the Result:**\\n  - Finally, return the minimum number of arrows required to burst all balloons, which is totalBalloons - count, where totalBalloons represents the total number of balloons in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3839256/easiest-solution-beat-99-69-submissions/"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "This question is very similar to https://leetcode.com/problems/non-overlapping-intervals/"
                    },
                    {
                        "username": "Vishal_0707",
                        "content": "Nice question it gives me lot of understanding about cmp and 2d arrays;"
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "-we must start from the left element to right so sorting will be a good idea \\n-when we see tow elements overlapping then we make them one element but with a smaller length"
                    },
                    {
                        "username": "ravishashi",
                        "content": "Why my code is giving TLE even its passed all given testcase also this is in Time complexity of O(NLogN). Kindly See this.\\n\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>v1,vector<int>v2)\\n    {\\n        return v1[1]<v2[1];\\n    }\\n\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n       sort(points.begin(),points.end(),cmp);\\n       int count=1;\\n       int end=points[0][1];\\n       for(int i=1;i<points.size();i++)\\n       {\\n           if(end<points[i][0])\\n           {\\n               count++;\\n               end=points[i][1];\\n           }\\n           else\\n           end=min(end,points[i][1]);\\n       }\\n       return count;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ravi Kant](/ravishashi) I do believe bc Sort!!! \nSo I have a minor improvement:\n\n470ms C++ 11-Jan-2023\n```\nclass Solution {\npublic:\n\n    int findMinArrowShots(vector<vector<int>>& points) {\n        sort(points.begin(),points.end());\n    int count=1 ;\n    int end= points[0][1];\n    for(int i=1;i<points.size();i++){\n        if (end > points[i][1]) {end= points[i][1]; continue;}\n        else if (end < points[i][0]) {count++; end= points[i][1];}\n    }\n    return count;\n}    \n};\n```\nGood luck!\n"
                    }
                ]
            },
            {
                "id": 2033732,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "The mistake that I was making initially was merging the intervals.\\nInstead try finding out the <i>common parts</i> of two intervals."
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "is it possible to solve it without sort? will it be faster?"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) yeah that is what I got"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@huangqianchen2021](/huangqianchen2021) if you use normal sort without custom cmp\\nthen is short first col of matrix\\nex- \\n10 3\\n1 4\\n5 7\\n3 8\\n\\nafter sort \\n1 4\\n3 8\\n5 7 \\n10 3"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "[@huangqianchen2021](/huangqianchen2021) I didn\\'t use any compare function, it just work.\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@This_is_Allen_Lee](/This_is_Allen_Lee) how did you sort vector<vector<int>>?  check if you use & when compare."
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I don\\'t know why my code is so slow even it is the same logic as the fastest code\\nhere is the code\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        sort(points.begin(), points.end());\\n        int pointsSize = points.size();\\n        int rbound = points[0][1];\\n        int ans = 1;\\n\\n        for(int i = 1; i < pointsSize; i++){\\n            if (points[i][1] < rbound){\\n                rbound = points[i][1];\\n            }\\n            if (points[i][0] > rbound){\\n                ans++;\\n                rbound = points[i][1];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "I won't say it is not possible because it is based on how you think and what logic you use complexity can be lesser and higher.\n\nlike i can think of a solution that will solve this problem in O(N^2) without sorting\nsomeone else may be able to optimise it such that it take less complexity and he/she don't use sorting as well."
                    },
                    {
                        "username": "betaev",
                        "content": "this description is so \\uD83E\\uDD2F"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Instead of merging and increasing the width of the intervals, here we merge and shrink the intervals."
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "I am getting wrong answer for this testcase:\\npair[][]=\\n[[-2147483646,-2147483645],[2147483646,2147483647]]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- # Greedy Approach:\\n   - The \"Greedy\" approach is a simple and efficient technique to solve the \"Minimum Arrows to Burst Balloons\" problem. Here\\'s the step-by-step explanation of the approach:\\n\\n- **Sort the Balloons:**\\n   - First, we sort the array of balloons based on their end positions in ascending order. This is crucial to ensure that we can shoot an arrow at the end position of a balloon to burst all balloons that can be hit by that arrow.\\n- **Initialize Variables:**\\n   - Set prev to the end position of the first balloon in the sorted array. - This will serve as the reference for determining whether the current balloon can be burst with the same arrow as the previous one.\\n   - Initialize count to zero. This variable will keep track of the number of balloons that can be burst with a single arrow.\\n- **Iteration:**\\n   - Iterate through the sorted array of balloons starting from the second balloon (index 1).\\n   - For each balloon:\\n      - Check if its start position is less than or equal to the previous balloon\\'s end position and its end position is greater than or equal to the previous balloon\\'s end position. If this condition is met, it means the current balloon can be burst with the same arrow as the previous one, so increment the count.\\n      - If the current balloon cannot be burst with the previous one, update prev with the end position of the current balloon, indicating that a new arrow is needed.\\n- **Return the Result:**\\n  - Finally, return the minimum number of arrows required to burst all balloons, which is totalBalloons - count, where totalBalloons represents the total number of balloons in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3839256/easiest-solution-beat-99-69-submissions/"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "This question is very similar to https://leetcode.com/problems/non-overlapping-intervals/"
                    },
                    {
                        "username": "Vishal_0707",
                        "content": "Nice question it gives me lot of understanding about cmp and 2d arrays;"
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "-we must start from the left element to right so sorting will be a good idea \\n-when we see tow elements overlapping then we make them one element but with a smaller length"
                    },
                    {
                        "username": "ravishashi",
                        "content": "Why my code is giving TLE even its passed all given testcase also this is in Time complexity of O(NLogN). Kindly See this.\\n\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>v1,vector<int>v2)\\n    {\\n        return v1[1]<v2[1];\\n    }\\n\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n       sort(points.begin(),points.end(),cmp);\\n       int count=1;\\n       int end=points[0][1];\\n       for(int i=1;i<points.size();i++)\\n       {\\n           if(end<points[i][0])\\n           {\\n               count++;\\n               end=points[i][1];\\n           }\\n           else\\n           end=min(end,points[i][1]);\\n       }\\n       return count;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ravi Kant](/ravishashi) I do believe bc Sort!!! \nSo I have a minor improvement:\n\n470ms C++ 11-Jan-2023\n```\nclass Solution {\npublic:\n\n    int findMinArrowShots(vector<vector<int>>& points) {\n        sort(points.begin(),points.end());\n    int count=1 ;\n    int end= points[0][1];\n    for(int i=1;i<points.size();i++){\n        if (end > points[i][1]) {end= points[i][1]; continue;}\n        else if (end < points[i][0]) {count++; end= points[i][1];}\n    }\n    return count;\n}    \n};\n```\nGood luck!\n"
                    }
                ]
            },
            {
                "id": 1998369,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "The mistake that I was making initially was merging the intervals.\\nInstead try finding out the <i>common parts</i> of two intervals."
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "is it possible to solve it without sort? will it be faster?"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) yeah that is what I got"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@huangqianchen2021](/huangqianchen2021) if you use normal sort without custom cmp\\nthen is short first col of matrix\\nex- \\n10 3\\n1 4\\n5 7\\n3 8\\n\\nafter sort \\n1 4\\n3 8\\n5 7 \\n10 3"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "[@huangqianchen2021](/huangqianchen2021) I didn\\'t use any compare function, it just work.\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@This_is_Allen_Lee](/This_is_Allen_Lee) how did you sort vector<vector<int>>?  check if you use & when compare."
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I don\\'t know why my code is so slow even it is the same logic as the fastest code\\nhere is the code\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        sort(points.begin(), points.end());\\n        int pointsSize = points.size();\\n        int rbound = points[0][1];\\n        int ans = 1;\\n\\n        for(int i = 1; i < pointsSize; i++){\\n            if (points[i][1] < rbound){\\n                rbound = points[i][1];\\n            }\\n            if (points[i][0] > rbound){\\n                ans++;\\n                rbound = points[i][1];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "I won't say it is not possible because it is based on how you think and what logic you use complexity can be lesser and higher.\n\nlike i can think of a solution that will solve this problem in O(N^2) without sorting\nsomeone else may be able to optimise it such that it take less complexity and he/she don't use sorting as well."
                    },
                    {
                        "username": "betaev",
                        "content": "this description is so \\uD83E\\uDD2F"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Instead of merging and increasing the width of the intervals, here we merge and shrink the intervals."
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "I am getting wrong answer for this testcase:\\npair[][]=\\n[[-2147483646,-2147483645],[2147483646,2147483647]]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- # Greedy Approach:\\n   - The \"Greedy\" approach is a simple and efficient technique to solve the \"Minimum Arrows to Burst Balloons\" problem. Here\\'s the step-by-step explanation of the approach:\\n\\n- **Sort the Balloons:**\\n   - First, we sort the array of balloons based on their end positions in ascending order. This is crucial to ensure that we can shoot an arrow at the end position of a balloon to burst all balloons that can be hit by that arrow.\\n- **Initialize Variables:**\\n   - Set prev to the end position of the first balloon in the sorted array. - This will serve as the reference for determining whether the current balloon can be burst with the same arrow as the previous one.\\n   - Initialize count to zero. This variable will keep track of the number of balloons that can be burst with a single arrow.\\n- **Iteration:**\\n   - Iterate through the sorted array of balloons starting from the second balloon (index 1).\\n   - For each balloon:\\n      - Check if its start position is less than or equal to the previous balloon\\'s end position and its end position is greater than or equal to the previous balloon\\'s end position. If this condition is met, it means the current balloon can be burst with the same arrow as the previous one, so increment the count.\\n      - If the current balloon cannot be burst with the previous one, update prev with the end position of the current balloon, indicating that a new arrow is needed.\\n- **Return the Result:**\\n  - Finally, return the minimum number of arrows required to burst all balloons, which is totalBalloons - count, where totalBalloons represents the total number of balloons in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3839256/easiest-solution-beat-99-69-submissions/"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "This question is very similar to https://leetcode.com/problems/non-overlapping-intervals/"
                    },
                    {
                        "username": "Vishal_0707",
                        "content": "Nice question it gives me lot of understanding about cmp and 2d arrays;"
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "-we must start from the left element to right so sorting will be a good idea \\n-when we see tow elements overlapping then we make them one element but with a smaller length"
                    },
                    {
                        "username": "ravishashi",
                        "content": "Why my code is giving TLE even its passed all given testcase also this is in Time complexity of O(NLogN). Kindly See this.\\n\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>v1,vector<int>v2)\\n    {\\n        return v1[1]<v2[1];\\n    }\\n\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n       sort(points.begin(),points.end(),cmp);\\n       int count=1;\\n       int end=points[0][1];\\n       for(int i=1;i<points.size();i++)\\n       {\\n           if(end<points[i][0])\\n           {\\n               count++;\\n               end=points[i][1];\\n           }\\n           else\\n           end=min(end,points[i][1]);\\n       }\\n       return count;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ravi Kant](/ravishashi) I do believe bc Sort!!! \nSo I have a minor improvement:\n\n470ms C++ 11-Jan-2023\n```\nclass Solution {\npublic:\n\n    int findMinArrowShots(vector<vector<int>>& points) {\n        sort(points.begin(),points.end());\n    int count=1 ;\n    int end= points[0][1];\n    for(int i=1;i<points.size();i++){\n        if (end > points[i][1]) {end= points[i][1]; continue;}\n        else if (end < points[i][0]) {count++; end= points[i][1];}\n    }\n    return count;\n}    \n};\n```\nGood luck!\n"
                    }
                ]
            },
            {
                "id": 1993296,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "The mistake that I was making initially was merging the intervals.\\nInstead try finding out the <i>common parts</i> of two intervals."
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "is it possible to solve it without sort? will it be faster?"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) yeah that is what I got"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@huangqianchen2021](/huangqianchen2021) if you use normal sort without custom cmp\\nthen is short first col of matrix\\nex- \\n10 3\\n1 4\\n5 7\\n3 8\\n\\nafter sort \\n1 4\\n3 8\\n5 7 \\n10 3"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "[@huangqianchen2021](/huangqianchen2021) I didn\\'t use any compare function, it just work.\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@This_is_Allen_Lee](/This_is_Allen_Lee) how did you sort vector<vector<int>>?  check if you use & when compare."
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I don\\'t know why my code is so slow even it is the same logic as the fastest code\\nhere is the code\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        sort(points.begin(), points.end());\\n        int pointsSize = points.size();\\n        int rbound = points[0][1];\\n        int ans = 1;\\n\\n        for(int i = 1; i < pointsSize; i++){\\n            if (points[i][1] < rbound){\\n                rbound = points[i][1];\\n            }\\n            if (points[i][0] > rbound){\\n                ans++;\\n                rbound = points[i][1];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "I won't say it is not possible because it is based on how you think and what logic you use complexity can be lesser and higher.\n\nlike i can think of a solution that will solve this problem in O(N^2) without sorting\nsomeone else may be able to optimise it such that it take less complexity and he/she don't use sorting as well."
                    },
                    {
                        "username": "betaev",
                        "content": "this description is so \\uD83E\\uDD2F"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Instead of merging and increasing the width of the intervals, here we merge and shrink the intervals."
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "I am getting wrong answer for this testcase:\\npair[][]=\\n[[-2147483646,-2147483645],[2147483646,2147483647]]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- # Greedy Approach:\\n   - The \"Greedy\" approach is a simple and efficient technique to solve the \"Minimum Arrows to Burst Balloons\" problem. Here\\'s the step-by-step explanation of the approach:\\n\\n- **Sort the Balloons:**\\n   - First, we sort the array of balloons based on their end positions in ascending order. This is crucial to ensure that we can shoot an arrow at the end position of a balloon to burst all balloons that can be hit by that arrow.\\n- **Initialize Variables:**\\n   - Set prev to the end position of the first balloon in the sorted array. - This will serve as the reference for determining whether the current balloon can be burst with the same arrow as the previous one.\\n   - Initialize count to zero. This variable will keep track of the number of balloons that can be burst with a single arrow.\\n- **Iteration:**\\n   - Iterate through the sorted array of balloons starting from the second balloon (index 1).\\n   - For each balloon:\\n      - Check if its start position is less than or equal to the previous balloon\\'s end position and its end position is greater than or equal to the previous balloon\\'s end position. If this condition is met, it means the current balloon can be burst with the same arrow as the previous one, so increment the count.\\n      - If the current balloon cannot be burst with the previous one, update prev with the end position of the current balloon, indicating that a new arrow is needed.\\n- **Return the Result:**\\n  - Finally, return the minimum number of arrows required to burst all balloons, which is totalBalloons - count, where totalBalloons represents the total number of balloons in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3839256/easiest-solution-beat-99-69-submissions/"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "This question is very similar to https://leetcode.com/problems/non-overlapping-intervals/"
                    },
                    {
                        "username": "Vishal_0707",
                        "content": "Nice question it gives me lot of understanding about cmp and 2d arrays;"
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "-we must start from the left element to right so sorting will be a good idea \\n-when we see tow elements overlapping then we make them one element but with a smaller length"
                    },
                    {
                        "username": "ravishashi",
                        "content": "Why my code is giving TLE even its passed all given testcase also this is in Time complexity of O(NLogN). Kindly See this.\\n\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>v1,vector<int>v2)\\n    {\\n        return v1[1]<v2[1];\\n    }\\n\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n       sort(points.begin(),points.end(),cmp);\\n       int count=1;\\n       int end=points[0][1];\\n       for(int i=1;i<points.size();i++)\\n       {\\n           if(end<points[i][0])\\n           {\\n               count++;\\n               end=points[i][1];\\n           }\\n           else\\n           end=min(end,points[i][1]);\\n       }\\n       return count;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ravi Kant](/ravishashi) I do believe bc Sort!!! \nSo I have a minor improvement:\n\n470ms C++ 11-Jan-2023\n```\nclass Solution {\npublic:\n\n    int findMinArrowShots(vector<vector<int>>& points) {\n        sort(points.begin(),points.end());\n    int count=1 ;\n    int end= points[0][1];\n    for(int i=1;i<points.size();i++){\n        if (end > points[i][1]) {end= points[i][1]; continue;}\n        else if (end < points[i][0]) {count++; end= points[i][1];}\n    }\n    return count;\n}    \n};\n```\nGood luck!\n"
                    }
                ]
            },
            {
                "id": 1979019,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "The mistake that I was making initially was merging the intervals.\\nInstead try finding out the <i>common parts</i> of two intervals."
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "is it possible to solve it without sort? will it be faster?"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) yeah that is what I got"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@huangqianchen2021](/huangqianchen2021) if you use normal sort without custom cmp\\nthen is short first col of matrix\\nex- \\n10 3\\n1 4\\n5 7\\n3 8\\n\\nafter sort \\n1 4\\n3 8\\n5 7 \\n10 3"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "[@huangqianchen2021](/huangqianchen2021) I didn\\'t use any compare function, it just work.\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@This_is_Allen_Lee](/This_is_Allen_Lee) how did you sort vector<vector<int>>?  check if you use & when compare."
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I don\\'t know why my code is so slow even it is the same logic as the fastest code\\nhere is the code\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        sort(points.begin(), points.end());\\n        int pointsSize = points.size();\\n        int rbound = points[0][1];\\n        int ans = 1;\\n\\n        for(int i = 1; i < pointsSize; i++){\\n            if (points[i][1] < rbound){\\n                rbound = points[i][1];\\n            }\\n            if (points[i][0] > rbound){\\n                ans++;\\n                rbound = points[i][1];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "I won't say it is not possible because it is based on how you think and what logic you use complexity can be lesser and higher.\n\nlike i can think of a solution that will solve this problem in O(N^2) without sorting\nsomeone else may be able to optimise it such that it take less complexity and he/she don't use sorting as well."
                    },
                    {
                        "username": "betaev",
                        "content": "this description is so \\uD83E\\uDD2F"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Instead of merging and increasing the width of the intervals, here we merge and shrink the intervals."
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "I am getting wrong answer for this testcase:\\npair[][]=\\n[[-2147483646,-2147483645],[2147483646,2147483647]]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- # Greedy Approach:\\n   - The \"Greedy\" approach is a simple and efficient technique to solve the \"Minimum Arrows to Burst Balloons\" problem. Here\\'s the step-by-step explanation of the approach:\\n\\n- **Sort the Balloons:**\\n   - First, we sort the array of balloons based on their end positions in ascending order. This is crucial to ensure that we can shoot an arrow at the end position of a balloon to burst all balloons that can be hit by that arrow.\\n- **Initialize Variables:**\\n   - Set prev to the end position of the first balloon in the sorted array. - This will serve as the reference for determining whether the current balloon can be burst with the same arrow as the previous one.\\n   - Initialize count to zero. This variable will keep track of the number of balloons that can be burst with a single arrow.\\n- **Iteration:**\\n   - Iterate through the sorted array of balloons starting from the second balloon (index 1).\\n   - For each balloon:\\n      - Check if its start position is less than or equal to the previous balloon\\'s end position and its end position is greater than or equal to the previous balloon\\'s end position. If this condition is met, it means the current balloon can be burst with the same arrow as the previous one, so increment the count.\\n      - If the current balloon cannot be burst with the previous one, update prev with the end position of the current balloon, indicating that a new arrow is needed.\\n- **Return the Result:**\\n  - Finally, return the minimum number of arrows required to burst all balloons, which is totalBalloons - count, where totalBalloons represents the total number of balloons in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3839256/easiest-solution-beat-99-69-submissions/"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "This question is very similar to https://leetcode.com/problems/non-overlapping-intervals/"
                    },
                    {
                        "username": "Vishal_0707",
                        "content": "Nice question it gives me lot of understanding about cmp and 2d arrays;"
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "-we must start from the left element to right so sorting will be a good idea \\n-when we see tow elements overlapping then we make them one element but with a smaller length"
                    },
                    {
                        "username": "ravishashi",
                        "content": "Why my code is giving TLE even its passed all given testcase also this is in Time complexity of O(NLogN). Kindly See this.\\n\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>v1,vector<int>v2)\\n    {\\n        return v1[1]<v2[1];\\n    }\\n\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n       sort(points.begin(),points.end(),cmp);\\n       int count=1;\\n       int end=points[0][1];\\n       for(int i=1;i<points.size();i++)\\n       {\\n           if(end<points[i][0])\\n           {\\n               count++;\\n               end=points[i][1];\\n           }\\n           else\\n           end=min(end,points[i][1]);\\n       }\\n       return count;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ravi Kant](/ravishashi) I do believe bc Sort!!! \nSo I have a minor improvement:\n\n470ms C++ 11-Jan-2023\n```\nclass Solution {\npublic:\n\n    int findMinArrowShots(vector<vector<int>>& points) {\n        sort(points.begin(),points.end());\n    int count=1 ;\n    int end= points[0][1];\n    for(int i=1;i<points.size();i++){\n        if (end > points[i][1]) {end= points[i][1]; continue;}\n        else if (end < points[i][0]) {count++; end= points[i][1];}\n    }\n    return count;\n}    \n};\n```\nGood luck!\n"
                    }
                ]
            },
            {
                "id": 1828204,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "The mistake that I was making initially was merging the intervals.\\nInstead try finding out the <i>common parts</i> of two intervals."
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "is it possible to solve it without sort? will it be faster?"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) yeah that is what I got"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@huangqianchen2021](/huangqianchen2021) if you use normal sort without custom cmp\\nthen is short first col of matrix\\nex- \\n10 3\\n1 4\\n5 7\\n3 8\\n\\nafter sort \\n1 4\\n3 8\\n5 7 \\n10 3"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "[@huangqianchen2021](/huangqianchen2021) I didn\\'t use any compare function, it just work.\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@This_is_Allen_Lee](/This_is_Allen_Lee) how did you sort vector<vector<int>>?  check if you use & when compare."
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I don\\'t know why my code is so slow even it is the same logic as the fastest code\\nhere is the code\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        sort(points.begin(), points.end());\\n        int pointsSize = points.size();\\n        int rbound = points[0][1];\\n        int ans = 1;\\n\\n        for(int i = 1; i < pointsSize; i++){\\n            if (points[i][1] < rbound){\\n                rbound = points[i][1];\\n            }\\n            if (points[i][0] > rbound){\\n                ans++;\\n                rbound = points[i][1];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "I won't say it is not possible because it is based on how you think and what logic you use complexity can be lesser and higher.\n\nlike i can think of a solution that will solve this problem in O(N^2) without sorting\nsomeone else may be able to optimise it such that it take less complexity and he/she don't use sorting as well."
                    },
                    {
                        "username": "betaev",
                        "content": "this description is so \\uD83E\\uDD2F"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Instead of merging and increasing the width of the intervals, here we merge and shrink the intervals."
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "I am getting wrong answer for this testcase:\\npair[][]=\\n[[-2147483646,-2147483645],[2147483646,2147483647]]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- # Greedy Approach:\\n   - The \"Greedy\" approach is a simple and efficient technique to solve the \"Minimum Arrows to Burst Balloons\" problem. Here\\'s the step-by-step explanation of the approach:\\n\\n- **Sort the Balloons:**\\n   - First, we sort the array of balloons based on their end positions in ascending order. This is crucial to ensure that we can shoot an arrow at the end position of a balloon to burst all balloons that can be hit by that arrow.\\n- **Initialize Variables:**\\n   - Set prev to the end position of the first balloon in the sorted array. - This will serve as the reference for determining whether the current balloon can be burst with the same arrow as the previous one.\\n   - Initialize count to zero. This variable will keep track of the number of balloons that can be burst with a single arrow.\\n- **Iteration:**\\n   - Iterate through the sorted array of balloons starting from the second balloon (index 1).\\n   - For each balloon:\\n      - Check if its start position is less than or equal to the previous balloon\\'s end position and its end position is greater than or equal to the previous balloon\\'s end position. If this condition is met, it means the current balloon can be burst with the same arrow as the previous one, so increment the count.\\n      - If the current balloon cannot be burst with the previous one, update prev with the end position of the current balloon, indicating that a new arrow is needed.\\n- **Return the Result:**\\n  - Finally, return the minimum number of arrows required to burst all balloons, which is totalBalloons - count, where totalBalloons represents the total number of balloons in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3839256/easiest-solution-beat-99-69-submissions/"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "This question is very similar to https://leetcode.com/problems/non-overlapping-intervals/"
                    },
                    {
                        "username": "Vishal_0707",
                        "content": "Nice question it gives me lot of understanding about cmp and 2d arrays;"
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "-we must start from the left element to right so sorting will be a good idea \\n-when we see tow elements overlapping then we make them one element but with a smaller length"
                    },
                    {
                        "username": "ravishashi",
                        "content": "Why my code is giving TLE even its passed all given testcase also this is in Time complexity of O(NLogN). Kindly See this.\\n\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>v1,vector<int>v2)\\n    {\\n        return v1[1]<v2[1];\\n    }\\n\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n       sort(points.begin(),points.end(),cmp);\\n       int count=1;\\n       int end=points[0][1];\\n       for(int i=1;i<points.size();i++)\\n       {\\n           if(end<points[i][0])\\n           {\\n               count++;\\n               end=points[i][1];\\n           }\\n           else\\n           end=min(end,points[i][1]);\\n       }\\n       return count;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ravi Kant](/ravishashi) I do believe bc Sort!!! \nSo I have a minor improvement:\n\n470ms C++ 11-Jan-2023\n```\nclass Solution {\npublic:\n\n    int findMinArrowShots(vector<vector<int>>& points) {\n        sort(points.begin(),points.end());\n    int count=1 ;\n    int end= points[0][1];\n    for(int i=1;i<points.size();i++){\n        if (end > points[i][1]) {end= points[i][1]; continue;}\n        else if (end < points[i][0]) {count++; end= points[i][1];}\n    }\n    return count;\n}    \n};\n```\nGood luck!\n"
                    }
                ]
            },
            {
                "id": 1769712,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "The mistake that I was making initially was merging the intervals.\\nInstead try finding out the <i>common parts</i> of two intervals."
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "is it possible to solve it without sort? will it be faster?"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) yeah that is what I got"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@huangqianchen2021](/huangqianchen2021) if you use normal sort without custom cmp\\nthen is short first col of matrix\\nex- \\n10 3\\n1 4\\n5 7\\n3 8\\n\\nafter sort \\n1 4\\n3 8\\n5 7 \\n10 3"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "[@huangqianchen2021](/huangqianchen2021) I didn\\'t use any compare function, it just work.\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@This_is_Allen_Lee](/This_is_Allen_Lee) how did you sort vector<vector<int>>?  check if you use & when compare."
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I don\\'t know why my code is so slow even it is the same logic as the fastest code\\nhere is the code\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        sort(points.begin(), points.end());\\n        int pointsSize = points.size();\\n        int rbound = points[0][1];\\n        int ans = 1;\\n\\n        for(int i = 1; i < pointsSize; i++){\\n            if (points[i][1] < rbound){\\n                rbound = points[i][1];\\n            }\\n            if (points[i][0] > rbound){\\n                ans++;\\n                rbound = points[i][1];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "I won't say it is not possible because it is based on how you think and what logic you use complexity can be lesser and higher.\n\nlike i can think of a solution that will solve this problem in O(N^2) without sorting\nsomeone else may be able to optimise it such that it take less complexity and he/she don't use sorting as well."
                    },
                    {
                        "username": "betaev",
                        "content": "this description is so \\uD83E\\uDD2F"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Instead of merging and increasing the width of the intervals, here we merge and shrink the intervals."
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "I am getting wrong answer for this testcase:\\npair[][]=\\n[[-2147483646,-2147483645],[2147483646,2147483647]]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- # Greedy Approach:\\n   - The \"Greedy\" approach is a simple and efficient technique to solve the \"Minimum Arrows to Burst Balloons\" problem. Here\\'s the step-by-step explanation of the approach:\\n\\n- **Sort the Balloons:**\\n   - First, we sort the array of balloons based on their end positions in ascending order. This is crucial to ensure that we can shoot an arrow at the end position of a balloon to burst all balloons that can be hit by that arrow.\\n- **Initialize Variables:**\\n   - Set prev to the end position of the first balloon in the sorted array. - This will serve as the reference for determining whether the current balloon can be burst with the same arrow as the previous one.\\n   - Initialize count to zero. This variable will keep track of the number of balloons that can be burst with a single arrow.\\n- **Iteration:**\\n   - Iterate through the sorted array of balloons starting from the second balloon (index 1).\\n   - For each balloon:\\n      - Check if its start position is less than or equal to the previous balloon\\'s end position and its end position is greater than or equal to the previous balloon\\'s end position. If this condition is met, it means the current balloon can be burst with the same arrow as the previous one, so increment the count.\\n      - If the current balloon cannot be burst with the previous one, update prev with the end position of the current balloon, indicating that a new arrow is needed.\\n- **Return the Result:**\\n  - Finally, return the minimum number of arrows required to burst all balloons, which is totalBalloons - count, where totalBalloons represents the total number of balloons in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3839256/easiest-solution-beat-99-69-submissions/"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "This question is very similar to https://leetcode.com/problems/non-overlapping-intervals/"
                    },
                    {
                        "username": "Vishal_0707",
                        "content": "Nice question it gives me lot of understanding about cmp and 2d arrays;"
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "-we must start from the left element to right so sorting will be a good idea \\n-when we see tow elements overlapping then we make them one element but with a smaller length"
                    },
                    {
                        "username": "ravishashi",
                        "content": "Why my code is giving TLE even its passed all given testcase also this is in Time complexity of O(NLogN). Kindly See this.\\n\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>v1,vector<int>v2)\\n    {\\n        return v1[1]<v2[1];\\n    }\\n\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n       sort(points.begin(),points.end(),cmp);\\n       int count=1;\\n       int end=points[0][1];\\n       for(int i=1;i<points.size();i++)\\n       {\\n           if(end<points[i][0])\\n           {\\n               count++;\\n               end=points[i][1];\\n           }\\n           else\\n           end=min(end,points[i][1]);\\n       }\\n       return count;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ravi Kant](/ravishashi) I do believe bc Sort!!! \nSo I have a minor improvement:\n\n470ms C++ 11-Jan-2023\n```\nclass Solution {\npublic:\n\n    int findMinArrowShots(vector<vector<int>>& points) {\n        sort(points.begin(),points.end());\n    int count=1 ;\n    int end= points[0][1];\n    for(int i=1;i<points.size();i++){\n        if (end > points[i][1]) {end= points[i][1]; continue;}\n        else if (end < points[i][0]) {count++; end= points[i][1];}\n    }\n    return count;\n}    \n};\n```\nGood luck!\n"
                    }
                ]
            },
            {
                "id": 1753110,
                "content": [
                    {
                        "username": "alpharomeo99",
                        "content": "The mistake that I was making initially was merging the intervals.\\nInstead try finding out the <i>common parts</i> of two intervals."
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "is it possible to solve it without sort? will it be faster?"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "[@mandliyarajendra11](/mandliyarajendra11) yeah that is what I got"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@huangqianchen2021](/huangqianchen2021) if you use normal sort without custom cmp\\nthen is short first col of matrix\\nex- \\n10 3\\n1 4\\n5 7\\n3 8\\n\\nafter sort \\n1 4\\n3 8\\n5 7 \\n10 3"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "[@huangqianchen2021](/huangqianchen2021) I didn\\'t use any compare function, it just work.\\n"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "[@This_is_Allen_Lee](/This_is_Allen_Lee) how did you sort vector<vector<int>>?  check if you use & when compare."
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I don\\'t know why my code is so slow even it is the same logic as the fastest code\\nhere is the code\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        sort(points.begin(), points.end());\\n        int pointsSize = points.size();\\n        int rbound = points[0][1];\\n        int ans = 1;\\n\\n        for(int i = 1; i < pointsSize; i++){\\n            if (points[i][1] < rbound){\\n                rbound = points[i][1];\\n            }\\n            if (points[i][0] > rbound){\\n                ans++;\\n                rbound = points[i][1];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "I won't say it is not possible because it is based on how you think and what logic you use complexity can be lesser and higher.\n\nlike i can think of a solution that will solve this problem in O(N^2) without sorting\nsomeone else may be able to optimise it such that it take less complexity and he/she don't use sorting as well."
                    },
                    {
                        "username": "betaev",
                        "content": "this description is so \\uD83E\\uDD2F"
                    },
                    {
                        "username": "user8272RT",
                        "content": "Instead of merging and increasing the width of the intervals, here we merge and shrink the intervals."
                    },
                    {
                        "username": "Prisha_1803",
                        "content": "I am getting wrong answer for this testcase:\\npair[][]=\\n[[-2147483646,-2147483645],[2147483646,2147483647]]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "- # Greedy Approach:\\n   - The \"Greedy\" approach is a simple and efficient technique to solve the \"Minimum Arrows to Burst Balloons\" problem. Here\\'s the step-by-step explanation of the approach:\\n\\n- **Sort the Balloons:**\\n   - First, we sort the array of balloons based on their end positions in ascending order. This is crucial to ensure that we can shoot an arrow at the end position of a balloon to burst all balloons that can be hit by that arrow.\\n- **Initialize Variables:**\\n   - Set prev to the end position of the first balloon in the sorted array. - This will serve as the reference for determining whether the current balloon can be burst with the same arrow as the previous one.\\n   - Initialize count to zero. This variable will keep track of the number of balloons that can be burst with a single arrow.\\n- **Iteration:**\\n   - Iterate through the sorted array of balloons starting from the second balloon (index 1).\\n   - For each balloon:\\n      - Check if its start position is less than or equal to the previous balloon\\'s end position and its end position is greater than or equal to the previous balloon\\'s end position. If this condition is met, it means the current balloon can be burst with the same arrow as the previous one, so increment the count.\\n      - If the current balloon cannot be burst with the previous one, update prev with the end position of the current balloon, indicating that a new arrow is needed.\\n- **Return the Result:**\\n  - Finally, return the minimum number of arrows required to burst all balloons, which is totalBalloons - count, where totalBalloons represents the total number of balloons in the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link for reference:-)***\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3839256/easiest-solution-beat-99-69-submissions/"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "This question is very similar to https://leetcode.com/problems/non-overlapping-intervals/"
                    },
                    {
                        "username": "Vishal_0707",
                        "content": "Nice question it gives me lot of understanding about cmp and 2d arrays;"
                    },
                    {
                        "username": "osamadrbas31",
                        "content": "-we must start from the left element to right so sorting will be a good idea \\n-when we see tow elements overlapping then we make them one element but with a smaller length"
                    },
                    {
                        "username": "ravishashi",
                        "content": "Why my code is giving TLE even its passed all given testcase also this is in Time complexity of O(NLogN). Kindly See this.\\n\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>v1,vector<int>v2)\\n    {\\n        return v1[1]<v2[1];\\n    }\\n\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n       sort(points.begin(),points.end(),cmp);\\n       int count=1;\\n       int end=points[0][1];\\n       for(int i=1;i<points.size();i++)\\n       {\\n           if(end<points[i][0])\\n           {\\n               count++;\\n               end=points[i][1];\\n           }\\n           else\\n           end=min(end,points[i][1]);\\n       }\\n       return count;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ravi Kant](/ravishashi) I do believe bc Sort!!! \nSo I have a minor improvement:\n\n470ms C++ 11-Jan-2023\n```\nclass Solution {\npublic:\n\n    int findMinArrowShots(vector<vector<int>>& points) {\n        sort(points.begin(),points.end());\n    int count=1 ;\n    int end= points[0][1];\n    for(int i=1;i<points.size();i++){\n        if (end > points[i][1]) {end= points[i][1]; continue;}\n        else if (end < points[i][0]) {count++; end= points[i][1];}\n    }\n    return count;\n}    \n};\n```\nGood luck!\n"
                    }
                ]
            },
            {
                "id": 1750620,
                "content": [
                    {
                        "username": "debdutsaini",
                        "content": "Huhhh!!\n49/49 test cases passed, still TLE!!"
                    },
                    {
                        "username": "junaidrmzn",
                        "content": "anyone face time limit exceeded at 47th test case?"
                    },
                    {
                        "username": "0_0ChaCha0_0",
                        "content": "I have questions about the examples (from 17 onwards). How there the answer should be more than 1 arrow. for example [[1,9],[7,16],[2,5],[7,12],[9,11],[2,10],[9,16],[3,9],[1,3]] one arrow should be more than enough to burst all the balls. Tell me please. (Maybe I misunderstood the condition. If so, please tell me which ones)"
                    },
                    {
                        "username": "zachweed",
                        "content": "is anyone else seeing test cases pass in ruby locally but fail on leetcode? specifically, the first test case which has an expectation of 2 is supposedly returning 4 in leetcode but it\\'s definitely returning 2 on my machine... if it matters, my solution is object oriented so it\\'s broken down into modules and I\\'m calling those modules from the method it auto-generated for me."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Shiba code: Explains well in under three minutes. Easy to understand solution\\nhttps://youtu.be/icIqE-g6RKk"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Failing at test case : [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n \\nWhat should be the expected answer? \\n1 or 2 !!?? \\nAs we can sort the array like - [[1, 10], [3, 9], [4, 11], [6, 7], [6, 9], [8, 12], [9, 12]]\\nand need one arrow shot !!\\nBut leetcode expected answer is 2? Why \\n"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "I used sort() function to solve this question. But it was giving TLE if I am using non-default comparator function. It was accepting if I use the sort method without comparator. In both the case the Algo other than sort have O(n) of time complexity. Asked my professor, he said it can be a platform issue. Because comparator is mostly O(1). Can anybody explain this?\\n"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": " If you use C++ you should get value by reference rather than value in your compare function. if not, your program will copy vector<int> inside and it will cost a lot."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Good problem! Went down the wrong path once by putting it into a heap and shooting at the right edge of every balloon and then checking the heap to see how many were covered. \nThat fails the case where [1, 10], [3,9] where the arrow at 10 wont cover this balloon.\n\nThis is a simple greedy solution by calculating overlaps."
                    },
                    {
                        "username": "mertpinarbasi",
                        "content": "Why we are sorting the endpoints instead of starting points.For the other questions like merge intervals we have always sorted with comparing the start points. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The thing is you need to know the previous `end` point to make it a threshold for check of the next `start` point.\\nThere is a good answer here https://leetcode.com/problems/non-overlapping-intervals/description/comments/1977578"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Tried to approach it with TreeSet in order to keep track of the indices covered by an arrow in sorted order but normal sorting with simple for loop approach is much simpler. "
                    }
                ]
            },
            {
                "id": 1745419,
                "content": [
                    {
                        "username": "debdutsaini",
                        "content": "Huhhh!!\n49/49 test cases passed, still TLE!!"
                    },
                    {
                        "username": "junaidrmzn",
                        "content": "anyone face time limit exceeded at 47th test case?"
                    },
                    {
                        "username": "0_0ChaCha0_0",
                        "content": "I have questions about the examples (from 17 onwards). How there the answer should be more than 1 arrow. for example [[1,9],[7,16],[2,5],[7,12],[9,11],[2,10],[9,16],[3,9],[1,3]] one arrow should be more than enough to burst all the balls. Tell me please. (Maybe I misunderstood the condition. If so, please tell me which ones)"
                    },
                    {
                        "username": "zachweed",
                        "content": "is anyone else seeing test cases pass in ruby locally but fail on leetcode? specifically, the first test case which has an expectation of 2 is supposedly returning 4 in leetcode but it\\'s definitely returning 2 on my machine... if it matters, my solution is object oriented so it\\'s broken down into modules and I\\'m calling those modules from the method it auto-generated for me."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Shiba code: Explains well in under three minutes. Easy to understand solution\\nhttps://youtu.be/icIqE-g6RKk"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Failing at test case : [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n \\nWhat should be the expected answer? \\n1 or 2 !!?? \\nAs we can sort the array like - [[1, 10], [3, 9], [4, 11], [6, 7], [6, 9], [8, 12], [9, 12]]\\nand need one arrow shot !!\\nBut leetcode expected answer is 2? Why \\n"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "I used sort() function to solve this question. But it was giving TLE if I am using non-default comparator function. It was accepting if I use the sort method without comparator. In both the case the Algo other than sort have O(n) of time complexity. Asked my professor, he said it can be a platform issue. Because comparator is mostly O(1). Can anybody explain this?\\n"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": " If you use C++ you should get value by reference rather than value in your compare function. if not, your program will copy vector<int> inside and it will cost a lot."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Good problem! Went down the wrong path once by putting it into a heap and shooting at the right edge of every balloon and then checking the heap to see how many were covered. \nThat fails the case where [1, 10], [3,9] where the arrow at 10 wont cover this balloon.\n\nThis is a simple greedy solution by calculating overlaps."
                    },
                    {
                        "username": "mertpinarbasi",
                        "content": "Why we are sorting the endpoints instead of starting points.For the other questions like merge intervals we have always sorted with comparing the start points. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The thing is you need to know the previous `end` point to make it a threshold for check of the next `start` point.\\nThere is a good answer here https://leetcode.com/problems/non-overlapping-intervals/description/comments/1977578"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Tried to approach it with TreeSet in order to keep track of the indices covered by an arrow in sorted order but normal sorting with simple for loop approach is much simpler. "
                    }
                ]
            },
            {
                "id": 1745185,
                "content": [
                    {
                        "username": "debdutsaini",
                        "content": "Huhhh!!\n49/49 test cases passed, still TLE!!"
                    },
                    {
                        "username": "junaidrmzn",
                        "content": "anyone face time limit exceeded at 47th test case?"
                    },
                    {
                        "username": "0_0ChaCha0_0",
                        "content": "I have questions about the examples (from 17 onwards). How there the answer should be more than 1 arrow. for example [[1,9],[7,16],[2,5],[7,12],[9,11],[2,10],[9,16],[3,9],[1,3]] one arrow should be more than enough to burst all the balls. Tell me please. (Maybe I misunderstood the condition. If so, please tell me which ones)"
                    },
                    {
                        "username": "zachweed",
                        "content": "is anyone else seeing test cases pass in ruby locally but fail on leetcode? specifically, the first test case which has an expectation of 2 is supposedly returning 4 in leetcode but it\\'s definitely returning 2 on my machine... if it matters, my solution is object oriented so it\\'s broken down into modules and I\\'m calling those modules from the method it auto-generated for me."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Shiba code: Explains well in under three minutes. Easy to understand solution\\nhttps://youtu.be/icIqE-g6RKk"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Failing at test case : [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n \\nWhat should be the expected answer? \\n1 or 2 !!?? \\nAs we can sort the array like - [[1, 10], [3, 9], [4, 11], [6, 7], [6, 9], [8, 12], [9, 12]]\\nand need one arrow shot !!\\nBut leetcode expected answer is 2? Why \\n"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "I used sort() function to solve this question. But it was giving TLE if I am using non-default comparator function. It was accepting if I use the sort method without comparator. In both the case the Algo other than sort have O(n) of time complexity. Asked my professor, he said it can be a platform issue. Because comparator is mostly O(1). Can anybody explain this?\\n"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": " If you use C++ you should get value by reference rather than value in your compare function. if not, your program will copy vector<int> inside and it will cost a lot."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Good problem! Went down the wrong path once by putting it into a heap and shooting at the right edge of every balloon and then checking the heap to see how many were covered. \nThat fails the case where [1, 10], [3,9] where the arrow at 10 wont cover this balloon.\n\nThis is a simple greedy solution by calculating overlaps."
                    },
                    {
                        "username": "mertpinarbasi",
                        "content": "Why we are sorting the endpoints instead of starting points.For the other questions like merge intervals we have always sorted with comparing the start points. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The thing is you need to know the previous `end` point to make it a threshold for check of the next `start` point.\\nThere is a good answer here https://leetcode.com/problems/non-overlapping-intervals/description/comments/1977578"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Tried to approach it with TreeSet in order to keep track of the indices covered by an arrow in sorted order but normal sorting with simple for loop approach is much simpler. "
                    }
                ]
            },
            {
                "id": 1745176,
                "content": [
                    {
                        "username": "debdutsaini",
                        "content": "Huhhh!!\n49/49 test cases passed, still TLE!!"
                    },
                    {
                        "username": "junaidrmzn",
                        "content": "anyone face time limit exceeded at 47th test case?"
                    },
                    {
                        "username": "0_0ChaCha0_0",
                        "content": "I have questions about the examples (from 17 onwards). How there the answer should be more than 1 arrow. for example [[1,9],[7,16],[2,5],[7,12],[9,11],[2,10],[9,16],[3,9],[1,3]] one arrow should be more than enough to burst all the balls. Tell me please. (Maybe I misunderstood the condition. If so, please tell me which ones)"
                    },
                    {
                        "username": "zachweed",
                        "content": "is anyone else seeing test cases pass in ruby locally but fail on leetcode? specifically, the first test case which has an expectation of 2 is supposedly returning 4 in leetcode but it\\'s definitely returning 2 on my machine... if it matters, my solution is object oriented so it\\'s broken down into modules and I\\'m calling those modules from the method it auto-generated for me."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Shiba code: Explains well in under three minutes. Easy to understand solution\\nhttps://youtu.be/icIqE-g6RKk"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Failing at test case : [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n \\nWhat should be the expected answer? \\n1 or 2 !!?? \\nAs we can sort the array like - [[1, 10], [3, 9], [4, 11], [6, 7], [6, 9], [8, 12], [9, 12]]\\nand need one arrow shot !!\\nBut leetcode expected answer is 2? Why \\n"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "I used sort() function to solve this question. But it was giving TLE if I am using non-default comparator function. It was accepting if I use the sort method without comparator. In both the case the Algo other than sort have O(n) of time complexity. Asked my professor, he said it can be a platform issue. Because comparator is mostly O(1). Can anybody explain this?\\n"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": " If you use C++ you should get value by reference rather than value in your compare function. if not, your program will copy vector<int> inside and it will cost a lot."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Good problem! Went down the wrong path once by putting it into a heap and shooting at the right edge of every balloon and then checking the heap to see how many were covered. \nThat fails the case where [1, 10], [3,9] where the arrow at 10 wont cover this balloon.\n\nThis is a simple greedy solution by calculating overlaps."
                    },
                    {
                        "username": "mertpinarbasi",
                        "content": "Why we are sorting the endpoints instead of starting points.For the other questions like merge intervals we have always sorted with comparing the start points. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The thing is you need to know the previous `end` point to make it a threshold for check of the next `start` point.\\nThere is a good answer here https://leetcode.com/problems/non-overlapping-intervals/description/comments/1977578"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Tried to approach it with TreeSet in order to keep track of the indices covered by an arrow in sorted order but normal sorting with simple for loop approach is much simpler. "
                    }
                ]
            },
            {
                "id": 1745080,
                "content": [
                    {
                        "username": "debdutsaini",
                        "content": "Huhhh!!\n49/49 test cases passed, still TLE!!"
                    },
                    {
                        "username": "junaidrmzn",
                        "content": "anyone face time limit exceeded at 47th test case?"
                    },
                    {
                        "username": "0_0ChaCha0_0",
                        "content": "I have questions about the examples (from 17 onwards). How there the answer should be more than 1 arrow. for example [[1,9],[7,16],[2,5],[7,12],[9,11],[2,10],[9,16],[3,9],[1,3]] one arrow should be more than enough to burst all the balls. Tell me please. (Maybe I misunderstood the condition. If so, please tell me which ones)"
                    },
                    {
                        "username": "zachweed",
                        "content": "is anyone else seeing test cases pass in ruby locally but fail on leetcode? specifically, the first test case which has an expectation of 2 is supposedly returning 4 in leetcode but it\\'s definitely returning 2 on my machine... if it matters, my solution is object oriented so it\\'s broken down into modules and I\\'m calling those modules from the method it auto-generated for me."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Shiba code: Explains well in under three minutes. Easy to understand solution\\nhttps://youtu.be/icIqE-g6RKk"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Failing at test case : [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n \\nWhat should be the expected answer? \\n1 or 2 !!?? \\nAs we can sort the array like - [[1, 10], [3, 9], [4, 11], [6, 7], [6, 9], [8, 12], [9, 12]]\\nand need one arrow shot !!\\nBut leetcode expected answer is 2? Why \\n"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "I used sort() function to solve this question. But it was giving TLE if I am using non-default comparator function. It was accepting if I use the sort method without comparator. In both the case the Algo other than sort have O(n) of time complexity. Asked my professor, he said it can be a platform issue. Because comparator is mostly O(1). Can anybody explain this?\\n"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": " If you use C++ you should get value by reference rather than value in your compare function. if not, your program will copy vector<int> inside and it will cost a lot."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Good problem! Went down the wrong path once by putting it into a heap and shooting at the right edge of every balloon and then checking the heap to see how many were covered. \nThat fails the case where [1, 10], [3,9] where the arrow at 10 wont cover this balloon.\n\nThis is a simple greedy solution by calculating overlaps."
                    },
                    {
                        "username": "mertpinarbasi",
                        "content": "Why we are sorting the endpoints instead of starting points.For the other questions like merge intervals we have always sorted with comparing the start points. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The thing is you need to know the previous `end` point to make it a threshold for check of the next `start` point.\\nThere is a good answer here https://leetcode.com/problems/non-overlapping-intervals/description/comments/1977578"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Tried to approach it with TreeSet in order to keep track of the indices covered by an arrow in sorted order but normal sorting with simple for loop approach is much simpler. "
                    }
                ]
            },
            {
                "id": 1744756,
                "content": [
                    {
                        "username": "debdutsaini",
                        "content": "Huhhh!!\n49/49 test cases passed, still TLE!!"
                    },
                    {
                        "username": "junaidrmzn",
                        "content": "anyone face time limit exceeded at 47th test case?"
                    },
                    {
                        "username": "0_0ChaCha0_0",
                        "content": "I have questions about the examples (from 17 onwards). How there the answer should be more than 1 arrow. for example [[1,9],[7,16],[2,5],[7,12],[9,11],[2,10],[9,16],[3,9],[1,3]] one arrow should be more than enough to burst all the balls. Tell me please. (Maybe I misunderstood the condition. If so, please tell me which ones)"
                    },
                    {
                        "username": "zachweed",
                        "content": "is anyone else seeing test cases pass in ruby locally but fail on leetcode? specifically, the first test case which has an expectation of 2 is supposedly returning 4 in leetcode but it\\'s definitely returning 2 on my machine... if it matters, my solution is object oriented so it\\'s broken down into modules and I\\'m calling those modules from the method it auto-generated for me."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Shiba code: Explains well in under three minutes. Easy to understand solution\\nhttps://youtu.be/icIqE-g6RKk"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Failing at test case : [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n \\nWhat should be the expected answer? \\n1 or 2 !!?? \\nAs we can sort the array like - [[1, 10], [3, 9], [4, 11], [6, 7], [6, 9], [8, 12], [9, 12]]\\nand need one arrow shot !!\\nBut leetcode expected answer is 2? Why \\n"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "I used sort() function to solve this question. But it was giving TLE if I am using non-default comparator function. It was accepting if I use the sort method without comparator. In both the case the Algo other than sort have O(n) of time complexity. Asked my professor, he said it can be a platform issue. Because comparator is mostly O(1). Can anybody explain this?\\n"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": " If you use C++ you should get value by reference rather than value in your compare function. if not, your program will copy vector<int> inside and it will cost a lot."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Good problem! Went down the wrong path once by putting it into a heap and shooting at the right edge of every balloon and then checking the heap to see how many were covered. \nThat fails the case where [1, 10], [3,9] where the arrow at 10 wont cover this balloon.\n\nThis is a simple greedy solution by calculating overlaps."
                    },
                    {
                        "username": "mertpinarbasi",
                        "content": "Why we are sorting the endpoints instead of starting points.For the other questions like merge intervals we have always sorted with comparing the start points. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The thing is you need to know the previous `end` point to make it a threshold for check of the next `start` point.\\nThere is a good answer here https://leetcode.com/problems/non-overlapping-intervals/description/comments/1977578"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Tried to approach it with TreeSet in order to keep track of the indices covered by an arrow in sorted order but normal sorting with simple for loop approach is much simpler. "
                    }
                ]
            },
            {
                "id": 1744436,
                "content": [
                    {
                        "username": "debdutsaini",
                        "content": "Huhhh!!\n49/49 test cases passed, still TLE!!"
                    },
                    {
                        "username": "junaidrmzn",
                        "content": "anyone face time limit exceeded at 47th test case?"
                    },
                    {
                        "username": "0_0ChaCha0_0",
                        "content": "I have questions about the examples (from 17 onwards). How there the answer should be more than 1 arrow. for example [[1,9],[7,16],[2,5],[7,12],[9,11],[2,10],[9,16],[3,9],[1,3]] one arrow should be more than enough to burst all the balls. Tell me please. (Maybe I misunderstood the condition. If so, please tell me which ones)"
                    },
                    {
                        "username": "zachweed",
                        "content": "is anyone else seeing test cases pass in ruby locally but fail on leetcode? specifically, the first test case which has an expectation of 2 is supposedly returning 4 in leetcode but it\\'s definitely returning 2 on my machine... if it matters, my solution is object oriented so it\\'s broken down into modules and I\\'m calling those modules from the method it auto-generated for me."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Shiba code: Explains well in under three minutes. Easy to understand solution\\nhttps://youtu.be/icIqE-g6RKk"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Failing at test case : [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n \\nWhat should be the expected answer? \\n1 or 2 !!?? \\nAs we can sort the array like - [[1, 10], [3, 9], [4, 11], [6, 7], [6, 9], [8, 12], [9, 12]]\\nand need one arrow shot !!\\nBut leetcode expected answer is 2? Why \\n"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "I used sort() function to solve this question. But it was giving TLE if I am using non-default comparator function. It was accepting if I use the sort method without comparator. In both the case the Algo other than sort have O(n) of time complexity. Asked my professor, he said it can be a platform issue. Because comparator is mostly O(1). Can anybody explain this?\\n"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": " If you use C++ you should get value by reference rather than value in your compare function. if not, your program will copy vector<int> inside and it will cost a lot."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Good problem! Went down the wrong path once by putting it into a heap and shooting at the right edge of every balloon and then checking the heap to see how many were covered. \nThat fails the case where [1, 10], [3,9] where the arrow at 10 wont cover this balloon.\n\nThis is a simple greedy solution by calculating overlaps."
                    },
                    {
                        "username": "mertpinarbasi",
                        "content": "Why we are sorting the endpoints instead of starting points.For the other questions like merge intervals we have always sorted with comparing the start points. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The thing is you need to know the previous `end` point to make it a threshold for check of the next `start` point.\\nThere is a good answer here https://leetcode.com/problems/non-overlapping-intervals/description/comments/1977578"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Tried to approach it with TreeSet in order to keep track of the indices covered by an arrow in sorted order but normal sorting with simple for loop approach is much simpler. "
                    }
                ]
            },
            {
                "id": 1743834,
                "content": [
                    {
                        "username": "debdutsaini",
                        "content": "Huhhh!!\n49/49 test cases passed, still TLE!!"
                    },
                    {
                        "username": "junaidrmzn",
                        "content": "anyone face time limit exceeded at 47th test case?"
                    },
                    {
                        "username": "0_0ChaCha0_0",
                        "content": "I have questions about the examples (from 17 onwards). How there the answer should be more than 1 arrow. for example [[1,9],[7,16],[2,5],[7,12],[9,11],[2,10],[9,16],[3,9],[1,3]] one arrow should be more than enough to burst all the balls. Tell me please. (Maybe I misunderstood the condition. If so, please tell me which ones)"
                    },
                    {
                        "username": "zachweed",
                        "content": "is anyone else seeing test cases pass in ruby locally but fail on leetcode? specifically, the first test case which has an expectation of 2 is supposedly returning 4 in leetcode but it\\'s definitely returning 2 on my machine... if it matters, my solution is object oriented so it\\'s broken down into modules and I\\'m calling those modules from the method it auto-generated for me."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Shiba code: Explains well in under three minutes. Easy to understand solution\\nhttps://youtu.be/icIqE-g6RKk"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Failing at test case : [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n \\nWhat should be the expected answer? \\n1 or 2 !!?? \\nAs we can sort the array like - [[1, 10], [3, 9], [4, 11], [6, 7], [6, 9], [8, 12], [9, 12]]\\nand need one arrow shot !!\\nBut leetcode expected answer is 2? Why \\n"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "I used sort() function to solve this question. But it was giving TLE if I am using non-default comparator function. It was accepting if I use the sort method without comparator. In both the case the Algo other than sort have O(n) of time complexity. Asked my professor, he said it can be a platform issue. Because comparator is mostly O(1). Can anybody explain this?\\n"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": " If you use C++ you should get value by reference rather than value in your compare function. if not, your program will copy vector<int> inside and it will cost a lot."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Good problem! Went down the wrong path once by putting it into a heap and shooting at the right edge of every balloon and then checking the heap to see how many were covered. \nThat fails the case where [1, 10], [3,9] where the arrow at 10 wont cover this balloon.\n\nThis is a simple greedy solution by calculating overlaps."
                    },
                    {
                        "username": "mertpinarbasi",
                        "content": "Why we are sorting the endpoints instead of starting points.For the other questions like merge intervals we have always sorted with comparing the start points. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The thing is you need to know the previous `end` point to make it a threshold for check of the next `start` point.\\nThere is a good answer here https://leetcode.com/problems/non-overlapping-intervals/description/comments/1977578"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Tried to approach it with TreeSet in order to keep track of the indices covered by an arrow in sorted order but normal sorting with simple for loop approach is much simpler. "
                    }
                ]
            },
            {
                "id": 1743622,
                "content": [
                    {
                        "username": "debdutsaini",
                        "content": "Huhhh!!\n49/49 test cases passed, still TLE!!"
                    },
                    {
                        "username": "junaidrmzn",
                        "content": "anyone face time limit exceeded at 47th test case?"
                    },
                    {
                        "username": "0_0ChaCha0_0",
                        "content": "I have questions about the examples (from 17 onwards). How there the answer should be more than 1 arrow. for example [[1,9],[7,16],[2,5],[7,12],[9,11],[2,10],[9,16],[3,9],[1,3]] one arrow should be more than enough to burst all the balls. Tell me please. (Maybe I misunderstood the condition. If so, please tell me which ones)"
                    },
                    {
                        "username": "zachweed",
                        "content": "is anyone else seeing test cases pass in ruby locally but fail on leetcode? specifically, the first test case which has an expectation of 2 is supposedly returning 4 in leetcode but it\\'s definitely returning 2 on my machine... if it matters, my solution is object oriented so it\\'s broken down into modules and I\\'m calling those modules from the method it auto-generated for me."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Shiba code: Explains well in under three minutes. Easy to understand solution\\nhttps://youtu.be/icIqE-g6RKk"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Failing at test case : [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n \\nWhat should be the expected answer? \\n1 or 2 !!?? \\nAs we can sort the array like - [[1, 10], [3, 9], [4, 11], [6, 7], [6, 9], [8, 12], [9, 12]]\\nand need one arrow shot !!\\nBut leetcode expected answer is 2? Why \\n"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "I used sort() function to solve this question. But it was giving TLE if I am using non-default comparator function. It was accepting if I use the sort method without comparator. In both the case the Algo other than sort have O(n) of time complexity. Asked my professor, he said it can be a platform issue. Because comparator is mostly O(1). Can anybody explain this?\\n"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": " If you use C++ you should get value by reference rather than value in your compare function. if not, your program will copy vector<int> inside and it will cost a lot."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Good problem! Went down the wrong path once by putting it into a heap and shooting at the right edge of every balloon and then checking the heap to see how many were covered. \nThat fails the case where [1, 10], [3,9] where the arrow at 10 wont cover this balloon.\n\nThis is a simple greedy solution by calculating overlaps."
                    },
                    {
                        "username": "mertpinarbasi",
                        "content": "Why we are sorting the endpoints instead of starting points.For the other questions like merge intervals we have always sorted with comparing the start points. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The thing is you need to know the previous `end` point to make it a threshold for check of the next `start` point.\\nThere is a good answer here https://leetcode.com/problems/non-overlapping-intervals/description/comments/1977578"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Tried to approach it with TreeSet in order to keep track of the indices covered by an arrow in sorted order but normal sorting with simple for loop approach is much simpler. "
                    }
                ]
            },
            {
                "id": 1743526,
                "content": [
                    {
                        "username": "debdutsaini",
                        "content": "Huhhh!!\n49/49 test cases passed, still TLE!!"
                    },
                    {
                        "username": "junaidrmzn",
                        "content": "anyone face time limit exceeded at 47th test case?"
                    },
                    {
                        "username": "0_0ChaCha0_0",
                        "content": "I have questions about the examples (from 17 onwards). How there the answer should be more than 1 arrow. for example [[1,9],[7,16],[2,5],[7,12],[9,11],[2,10],[9,16],[3,9],[1,3]] one arrow should be more than enough to burst all the balls. Tell me please. (Maybe I misunderstood the condition. If so, please tell me which ones)"
                    },
                    {
                        "username": "zachweed",
                        "content": "is anyone else seeing test cases pass in ruby locally but fail on leetcode? specifically, the first test case which has an expectation of 2 is supposedly returning 4 in leetcode but it\\'s definitely returning 2 on my machine... if it matters, my solution is object oriented so it\\'s broken down into modules and I\\'m calling those modules from the method it auto-generated for me."
                    },
                    {
                        "username": "Amarsanaa",
                        "content": "Shiba code: Explains well in under three minutes. Easy to understand solution\\nhttps://youtu.be/icIqE-g6RKk"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Failing at test case : [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n \\nWhat should be the expected answer? \\n1 or 2 !!?? \\nAs we can sort the array like - [[1, 10], [3, 9], [4, 11], [6, 7], [6, 9], [8, 12], [9, 12]]\\nand need one arrow shot !!\\nBut leetcode expected answer is 2? Why \\n"
                    },
                    {
                        "username": "MaNan-3",
                        "content": "I used sort() function to solve this question. But it was giving TLE if I am using non-default comparator function. It was accepting if I use the sort method without comparator. In both the case the Algo other than sort have O(n) of time complexity. Asked my professor, he said it can be a platform issue. Because comparator is mostly O(1). Can anybody explain this?\\n"
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": " If you use C++ you should get value by reference rather than value in your compare function. if not, your program will copy vector<int> inside and it will cost a lot."
                    },
                    {
                        "username": "adityadeore1979",
                        "content": "Good problem! Went down the wrong path once by putting it into a heap and shooting at the right edge of every balloon and then checking the heap to see how many were covered. \nThat fails the case where [1, 10], [3,9] where the arrow at 10 wont cover this balloon.\n\nThis is a simple greedy solution by calculating overlaps."
                    },
                    {
                        "username": "mertpinarbasi",
                        "content": "Why we are sorting the endpoints instead of starting points.For the other questions like merge intervals we have always sorted with comparing the start points. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "The thing is you need to know the previous `end` point to make it a threshold for check of the next `start` point.\\nThere is a good answer here https://leetcode.com/problems/non-overlapping-intervals/description/comments/1977578"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Tried to approach it with TreeSet in order to keep track of the indices covered by an arrow in sorted order but normal sorting with simple for loop approach is much simpler. "
                    }
                ]
            },
            {
                "id": 1743443,
                "content": [
                    {
                        "username": "wolverine99",
                        "content": "Is there any way to solve it in O(n)? Just exploring about what the approach could be and if not what is the reason behind it not being solvable in O(n)."
                    },
                    {
                        "username": "S_Basu",
                        "content": "I think it is because sorting is required for this problem, and the best possible time complexity for sorting is O(n.log(n)). Please share if you find any other approach."
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i succesfully solved the problem , but did not rank good in runtime and memory , i was checking the optimal code and it turns out that his approach is same , but he implemented his own way of sorting (quick sort ) , i used the one provided by jdk and put my own comparator , i cant understand why does his code work better than me ? IN BOTH runtime and memory."
                    },
                    {
                        "username": "Yongbi",
                        "content": "Don\\'t think too much, just enjoy the game. Anw, if you want you can run a dry check on your computer to compare your code with a best one by timeit function."
                    },
                    {
                        "username": "S_Basu",
                        "content": "sometimes submission of the same code displays different results for *Your submission Beats x%*.\\nI guess we cannot do much about it. \\n\\n\\nMaybe it depends on other factors like bandwidth, latency, waiting time for the processing request etc."
                    },
                    {
                        "username": "arpan-banerjee7",
                        "content": "Need help--\n```\nclass Solution {\n    public int findMinArrowShots(int[][] points) {\n        int n=points.length;\n        Arrays.sort(points,((a,b)->a[0]-b[0]));\n\n        List<int[]> res=new ArrayList<>();\n        res.add(points[0]);\n        int k=0;\n\n        for(int i=1;i<n;i++){\n            if(res.get(k)[1]>=points[i][0]){\n                res.set(k,new int[]{(int)points[i][0],Math.min((int)res.get(k)[1],(int)points[i][1])});\n            }else{\n                res.add(points[i]);\n                k++;\n            }\n        }\n        return res.size();\n    }\n}\n```\npoints =\n[[-2147483646,-2147483645],[2147483646,2147483647]]\nOnly this test case fails here. I have used the concept of merge intervals here. Can anyone help me with passing this test case. This is an edge case."
                    },
                    {
                        "username": "arpan-banerjee7",
                        "content": "[@aneesh1029](/aneesh1029) Thanks it worked!"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "a-b for these inputs will be giving overflow "
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Hello instead of using a[0]-b[0] use .compare method"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3004120/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": " points[i] = [xstart, xend]\\nI wish there is a way to group elements with their maximum and minimum values and for every xstart,xe in points if either the minimum or the maximum is inside the  previous groups I will skip it else if neither the xstart nor  xend not in range of previous groups I will make new Group. \\nis there any way to implement this idea?\\n\\n\\nwhen I first look at the problem I thought it can be solved by union find algorithm. is there any one who used it?\\n"
                    },
                    {
                        "username": "adityashewalkar16",
                        "content": "Here is a similar problem: [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/).\\nAbove problem can be solved by using same concept and making few minor changes in the solution of this problem."
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "Tip: Exact similar to overlapping intervals or N meetings in one Room"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "TIP for C++:\\npass vectors to compare function by reference otherwise you will get TLE"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "hey can anyone give me suggestion that what changes i have to do in my code :\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n\\n        sort(points.begin(),points.end());\\n        int count=0 ;\\n        for(int i=0;i<points.size();i++){\\n            int j=i;\\n            while(i+1<points.size() and points[j][1]>=points[i+1][0]){i++;}\\n            count++;\\n\\n        }\\n        return count ;\\n    }\\n        \\n \\n};\\nit is not working  for [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] this test case"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@JGarima2843](/JGarima2843)\\n\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(),points.end());\\n    int count=1 ;\\n    int comparator= points[0][1];\\n    for(int i=1;i<points.size();i++){\\n        if (comparator > points[i][1]) {comparator= points[i][1]; continue;}\\n        else if (comparator < points[i][0]) {count++; comparator= points[i][1];}\\n    }\\n    return count;\\n}      \\n};\\n\\nYour upper bound causes problem. Do you agree that we only increase when the last upperbound is less than current lowerbound?\\n"
                    },
                    {
                        "username": "spartex007",
                        "content": "Why its giving TLE ?\\n `bool cmp(vector <int> a , vector <int> b){\\n        return a[1] < b[1];\\n    }\\nclass Solution {\\n    public:\\n        int findMinArrowShots(vector<vector<int>>& points) {\\n            sort(points.begin() , points.end(), cmp);\\n            int flag = points[0][1] ;\\n            int ret = 1; \\n            for(auto i:points){\\n                if(i[0] > flag){\\n                    flag = i[1];\\n                    ret++;\\n                }\\n            }\\n            return ret;\\n        }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vedant Garode](/spartex007) use reference in comparator function i.e `vector<int> &` instead of normal variable to avoid copying of values. This will save a lot of time"
                    }
                ]
            },
            {
                "id": 1743413,
                "content": [
                    {
                        "username": "wolverine99",
                        "content": "Is there any way to solve it in O(n)? Just exploring about what the approach could be and if not what is the reason behind it not being solvable in O(n)."
                    },
                    {
                        "username": "S_Basu",
                        "content": "I think it is because sorting is required for this problem, and the best possible time complexity for sorting is O(n.log(n)). Please share if you find any other approach."
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i succesfully solved the problem , but did not rank good in runtime and memory , i was checking the optimal code and it turns out that his approach is same , but he implemented his own way of sorting (quick sort ) , i used the one provided by jdk and put my own comparator , i cant understand why does his code work better than me ? IN BOTH runtime and memory."
                    },
                    {
                        "username": "Yongbi",
                        "content": "Don\\'t think too much, just enjoy the game. Anw, if you want you can run a dry check on your computer to compare your code with a best one by timeit function."
                    },
                    {
                        "username": "S_Basu",
                        "content": "sometimes submission of the same code displays different results for *Your submission Beats x%*.\\nI guess we cannot do much about it. \\n\\n\\nMaybe it depends on other factors like bandwidth, latency, waiting time for the processing request etc."
                    },
                    {
                        "username": "arpan-banerjee7",
                        "content": "Need help--\n```\nclass Solution {\n    public int findMinArrowShots(int[][] points) {\n        int n=points.length;\n        Arrays.sort(points,((a,b)->a[0]-b[0]));\n\n        List<int[]> res=new ArrayList<>();\n        res.add(points[0]);\n        int k=0;\n\n        for(int i=1;i<n;i++){\n            if(res.get(k)[1]>=points[i][0]){\n                res.set(k,new int[]{(int)points[i][0],Math.min((int)res.get(k)[1],(int)points[i][1])});\n            }else{\n                res.add(points[i]);\n                k++;\n            }\n        }\n        return res.size();\n    }\n}\n```\npoints =\n[[-2147483646,-2147483645],[2147483646,2147483647]]\nOnly this test case fails here. I have used the concept of merge intervals here. Can anyone help me with passing this test case. This is an edge case."
                    },
                    {
                        "username": "arpan-banerjee7",
                        "content": "[@aneesh1029](/aneesh1029) Thanks it worked!"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "a-b for these inputs will be giving overflow "
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Hello instead of using a[0]-b[0] use .compare method"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3004120/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": " points[i] = [xstart, xend]\\nI wish there is a way to group elements with their maximum and minimum values and for every xstart,xe in points if either the minimum or the maximum is inside the  previous groups I will skip it else if neither the xstart nor  xend not in range of previous groups I will make new Group. \\nis there any way to implement this idea?\\n\\n\\nwhen I first look at the problem I thought it can be solved by union find algorithm. is there any one who used it?\\n"
                    },
                    {
                        "username": "adityashewalkar16",
                        "content": "Here is a similar problem: [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/).\\nAbove problem can be solved by using same concept and making few minor changes in the solution of this problem."
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "Tip: Exact similar to overlapping intervals or N meetings in one Room"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "TIP for C++:\\npass vectors to compare function by reference otherwise you will get TLE"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "hey can anyone give me suggestion that what changes i have to do in my code :\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n\\n        sort(points.begin(),points.end());\\n        int count=0 ;\\n        for(int i=0;i<points.size();i++){\\n            int j=i;\\n            while(i+1<points.size() and points[j][1]>=points[i+1][0]){i++;}\\n            count++;\\n\\n        }\\n        return count ;\\n    }\\n        \\n \\n};\\nit is not working  for [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] this test case"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@JGarima2843](/JGarima2843)\\n\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(),points.end());\\n    int count=1 ;\\n    int comparator= points[0][1];\\n    for(int i=1;i<points.size();i++){\\n        if (comparator > points[i][1]) {comparator= points[i][1]; continue;}\\n        else if (comparator < points[i][0]) {count++; comparator= points[i][1];}\\n    }\\n    return count;\\n}      \\n};\\n\\nYour upper bound causes problem. Do you agree that we only increase when the last upperbound is less than current lowerbound?\\n"
                    },
                    {
                        "username": "spartex007",
                        "content": "Why its giving TLE ?\\n `bool cmp(vector <int> a , vector <int> b){\\n        return a[1] < b[1];\\n    }\\nclass Solution {\\n    public:\\n        int findMinArrowShots(vector<vector<int>>& points) {\\n            sort(points.begin() , points.end(), cmp);\\n            int flag = points[0][1] ;\\n            int ret = 1; \\n            for(auto i:points){\\n                if(i[0] > flag){\\n                    flag = i[1];\\n                    ret++;\\n                }\\n            }\\n            return ret;\\n        }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vedant Garode](/spartex007) use reference in comparator function i.e `vector<int> &` instead of normal variable to avoid copying of values. This will save a lot of time"
                    }
                ]
            },
            {
                "id": 1743398,
                "content": [
                    {
                        "username": "wolverine99",
                        "content": "Is there any way to solve it in O(n)? Just exploring about what the approach could be and if not what is the reason behind it not being solvable in O(n)."
                    },
                    {
                        "username": "S_Basu",
                        "content": "I think it is because sorting is required for this problem, and the best possible time complexity for sorting is O(n.log(n)). Please share if you find any other approach."
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i succesfully solved the problem , but did not rank good in runtime and memory , i was checking the optimal code and it turns out that his approach is same , but he implemented his own way of sorting (quick sort ) , i used the one provided by jdk and put my own comparator , i cant understand why does his code work better than me ? IN BOTH runtime and memory."
                    },
                    {
                        "username": "Yongbi",
                        "content": "Don\\'t think too much, just enjoy the game. Anw, if you want you can run a dry check on your computer to compare your code with a best one by timeit function."
                    },
                    {
                        "username": "S_Basu",
                        "content": "sometimes submission of the same code displays different results for *Your submission Beats x%*.\\nI guess we cannot do much about it. \\n\\n\\nMaybe it depends on other factors like bandwidth, latency, waiting time for the processing request etc."
                    },
                    {
                        "username": "arpan-banerjee7",
                        "content": "Need help--\n```\nclass Solution {\n    public int findMinArrowShots(int[][] points) {\n        int n=points.length;\n        Arrays.sort(points,((a,b)->a[0]-b[0]));\n\n        List<int[]> res=new ArrayList<>();\n        res.add(points[0]);\n        int k=0;\n\n        for(int i=1;i<n;i++){\n            if(res.get(k)[1]>=points[i][0]){\n                res.set(k,new int[]{(int)points[i][0],Math.min((int)res.get(k)[1],(int)points[i][1])});\n            }else{\n                res.add(points[i]);\n                k++;\n            }\n        }\n        return res.size();\n    }\n}\n```\npoints =\n[[-2147483646,-2147483645],[2147483646,2147483647]]\nOnly this test case fails here. I have used the concept of merge intervals here. Can anyone help me with passing this test case. This is an edge case."
                    },
                    {
                        "username": "arpan-banerjee7",
                        "content": "[@aneesh1029](/aneesh1029) Thanks it worked!"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "a-b for these inputs will be giving overflow "
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Hello instead of using a[0]-b[0] use .compare method"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3004120/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": " points[i] = [xstart, xend]\\nI wish there is a way to group elements with their maximum and minimum values and for every xstart,xe in points if either the minimum or the maximum is inside the  previous groups I will skip it else if neither the xstart nor  xend not in range of previous groups I will make new Group. \\nis there any way to implement this idea?\\n\\n\\nwhen I first look at the problem I thought it can be solved by union find algorithm. is there any one who used it?\\n"
                    },
                    {
                        "username": "adityashewalkar16",
                        "content": "Here is a similar problem: [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/).\\nAbove problem can be solved by using same concept and making few minor changes in the solution of this problem."
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "Tip: Exact similar to overlapping intervals or N meetings in one Room"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "TIP for C++:\\npass vectors to compare function by reference otherwise you will get TLE"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "hey can anyone give me suggestion that what changes i have to do in my code :\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n\\n        sort(points.begin(),points.end());\\n        int count=0 ;\\n        for(int i=0;i<points.size();i++){\\n            int j=i;\\n            while(i+1<points.size() and points[j][1]>=points[i+1][0]){i++;}\\n            count++;\\n\\n        }\\n        return count ;\\n    }\\n        \\n \\n};\\nit is not working  for [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] this test case"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@JGarima2843](/JGarima2843)\\n\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(),points.end());\\n    int count=1 ;\\n    int comparator= points[0][1];\\n    for(int i=1;i<points.size();i++){\\n        if (comparator > points[i][1]) {comparator= points[i][1]; continue;}\\n        else if (comparator < points[i][0]) {count++; comparator= points[i][1];}\\n    }\\n    return count;\\n}      \\n};\\n\\nYour upper bound causes problem. Do you agree that we only increase when the last upperbound is less than current lowerbound?\\n"
                    },
                    {
                        "username": "spartex007",
                        "content": "Why its giving TLE ?\\n `bool cmp(vector <int> a , vector <int> b){\\n        return a[1] < b[1];\\n    }\\nclass Solution {\\n    public:\\n        int findMinArrowShots(vector<vector<int>>& points) {\\n            sort(points.begin() , points.end(), cmp);\\n            int flag = points[0][1] ;\\n            int ret = 1; \\n            for(auto i:points){\\n                if(i[0] > flag){\\n                    flag = i[1];\\n                    ret++;\\n                }\\n            }\\n            return ret;\\n        }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vedant Garode](/spartex007) use reference in comparator function i.e `vector<int> &` instead of normal variable to avoid copying of values. This will save a lot of time"
                    }
                ]
            },
            {
                "id": 1743351,
                "content": [
                    {
                        "username": "wolverine99",
                        "content": "Is there any way to solve it in O(n)? Just exploring about what the approach could be and if not what is the reason behind it not being solvable in O(n)."
                    },
                    {
                        "username": "S_Basu",
                        "content": "I think it is because sorting is required for this problem, and the best possible time complexity for sorting is O(n.log(n)). Please share if you find any other approach."
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i succesfully solved the problem , but did not rank good in runtime and memory , i was checking the optimal code and it turns out that his approach is same , but he implemented his own way of sorting (quick sort ) , i used the one provided by jdk and put my own comparator , i cant understand why does his code work better than me ? IN BOTH runtime and memory."
                    },
                    {
                        "username": "Yongbi",
                        "content": "Don\\'t think too much, just enjoy the game. Anw, if you want you can run a dry check on your computer to compare your code with a best one by timeit function."
                    },
                    {
                        "username": "S_Basu",
                        "content": "sometimes submission of the same code displays different results for *Your submission Beats x%*.\\nI guess we cannot do much about it. \\n\\n\\nMaybe it depends on other factors like bandwidth, latency, waiting time for the processing request etc."
                    },
                    {
                        "username": "arpan-banerjee7",
                        "content": "Need help--\n```\nclass Solution {\n    public int findMinArrowShots(int[][] points) {\n        int n=points.length;\n        Arrays.sort(points,((a,b)->a[0]-b[0]));\n\n        List<int[]> res=new ArrayList<>();\n        res.add(points[0]);\n        int k=0;\n\n        for(int i=1;i<n;i++){\n            if(res.get(k)[1]>=points[i][0]){\n                res.set(k,new int[]{(int)points[i][0],Math.min((int)res.get(k)[1],(int)points[i][1])});\n            }else{\n                res.add(points[i]);\n                k++;\n            }\n        }\n        return res.size();\n    }\n}\n```\npoints =\n[[-2147483646,-2147483645],[2147483646,2147483647]]\nOnly this test case fails here. I have used the concept of merge intervals here. Can anyone help me with passing this test case. This is an edge case."
                    },
                    {
                        "username": "arpan-banerjee7",
                        "content": "[@aneesh1029](/aneesh1029) Thanks it worked!"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "a-b for these inputs will be giving overflow "
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Hello instead of using a[0]-b[0] use .compare method"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3004120/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": " points[i] = [xstart, xend]\\nI wish there is a way to group elements with their maximum and minimum values and for every xstart,xe in points if either the minimum or the maximum is inside the  previous groups I will skip it else if neither the xstart nor  xend not in range of previous groups I will make new Group. \\nis there any way to implement this idea?\\n\\n\\nwhen I first look at the problem I thought it can be solved by union find algorithm. is there any one who used it?\\n"
                    },
                    {
                        "username": "adityashewalkar16",
                        "content": "Here is a similar problem: [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/).\\nAbove problem can be solved by using same concept and making few minor changes in the solution of this problem."
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "Tip: Exact similar to overlapping intervals or N meetings in one Room"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "TIP for C++:\\npass vectors to compare function by reference otherwise you will get TLE"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "hey can anyone give me suggestion that what changes i have to do in my code :\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n\\n        sort(points.begin(),points.end());\\n        int count=0 ;\\n        for(int i=0;i<points.size();i++){\\n            int j=i;\\n            while(i+1<points.size() and points[j][1]>=points[i+1][0]){i++;}\\n            count++;\\n\\n        }\\n        return count ;\\n    }\\n        \\n \\n};\\nit is not working  for [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] this test case"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@JGarima2843](/JGarima2843)\\n\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(),points.end());\\n    int count=1 ;\\n    int comparator= points[0][1];\\n    for(int i=1;i<points.size();i++){\\n        if (comparator > points[i][1]) {comparator= points[i][1]; continue;}\\n        else if (comparator < points[i][0]) {count++; comparator= points[i][1];}\\n    }\\n    return count;\\n}      \\n};\\n\\nYour upper bound causes problem. Do you agree that we only increase when the last upperbound is less than current lowerbound?\\n"
                    },
                    {
                        "username": "spartex007",
                        "content": "Why its giving TLE ?\\n `bool cmp(vector <int> a , vector <int> b){\\n        return a[1] < b[1];\\n    }\\nclass Solution {\\n    public:\\n        int findMinArrowShots(vector<vector<int>>& points) {\\n            sort(points.begin() , points.end(), cmp);\\n            int flag = points[0][1] ;\\n            int ret = 1; \\n            for(auto i:points){\\n                if(i[0] > flag){\\n                    flag = i[1];\\n                    ret++;\\n                }\\n            }\\n            return ret;\\n        }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vedant Garode](/spartex007) use reference in comparator function i.e `vector<int> &` instead of normal variable to avoid copying of values. This will save a lot of time"
                    }
                ]
            },
            {
                "id": 1743331,
                "content": [
                    {
                        "username": "wolverine99",
                        "content": "Is there any way to solve it in O(n)? Just exploring about what the approach could be and if not what is the reason behind it not being solvable in O(n)."
                    },
                    {
                        "username": "S_Basu",
                        "content": "I think it is because sorting is required for this problem, and the best possible time complexity for sorting is O(n.log(n)). Please share if you find any other approach."
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i succesfully solved the problem , but did not rank good in runtime and memory , i was checking the optimal code and it turns out that his approach is same , but he implemented his own way of sorting (quick sort ) , i used the one provided by jdk and put my own comparator , i cant understand why does his code work better than me ? IN BOTH runtime and memory."
                    },
                    {
                        "username": "Yongbi",
                        "content": "Don\\'t think too much, just enjoy the game. Anw, if you want you can run a dry check on your computer to compare your code with a best one by timeit function."
                    },
                    {
                        "username": "S_Basu",
                        "content": "sometimes submission of the same code displays different results for *Your submission Beats x%*.\\nI guess we cannot do much about it. \\n\\n\\nMaybe it depends on other factors like bandwidth, latency, waiting time for the processing request etc."
                    },
                    {
                        "username": "arpan-banerjee7",
                        "content": "Need help--\n```\nclass Solution {\n    public int findMinArrowShots(int[][] points) {\n        int n=points.length;\n        Arrays.sort(points,((a,b)->a[0]-b[0]));\n\n        List<int[]> res=new ArrayList<>();\n        res.add(points[0]);\n        int k=0;\n\n        for(int i=1;i<n;i++){\n            if(res.get(k)[1]>=points[i][0]){\n                res.set(k,new int[]{(int)points[i][0],Math.min((int)res.get(k)[1],(int)points[i][1])});\n            }else{\n                res.add(points[i]);\n                k++;\n            }\n        }\n        return res.size();\n    }\n}\n```\npoints =\n[[-2147483646,-2147483645],[2147483646,2147483647]]\nOnly this test case fails here. I have used the concept of merge intervals here. Can anyone help me with passing this test case. This is an edge case."
                    },
                    {
                        "username": "arpan-banerjee7",
                        "content": "[@aneesh1029](/aneesh1029) Thanks it worked!"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "a-b for these inputs will be giving overflow "
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Hello instead of using a[0]-b[0] use .compare method"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3004120/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": " points[i] = [xstart, xend]\\nI wish there is a way to group elements with their maximum and minimum values and for every xstart,xe in points if either the minimum or the maximum is inside the  previous groups I will skip it else if neither the xstart nor  xend not in range of previous groups I will make new Group. \\nis there any way to implement this idea?\\n\\n\\nwhen I first look at the problem I thought it can be solved by union find algorithm. is there any one who used it?\\n"
                    },
                    {
                        "username": "adityashewalkar16",
                        "content": "Here is a similar problem: [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/).\\nAbove problem can be solved by using same concept and making few minor changes in the solution of this problem."
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "Tip: Exact similar to overlapping intervals or N meetings in one Room"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "TIP for C++:\\npass vectors to compare function by reference otherwise you will get TLE"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "hey can anyone give me suggestion that what changes i have to do in my code :\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n\\n        sort(points.begin(),points.end());\\n        int count=0 ;\\n        for(int i=0;i<points.size();i++){\\n            int j=i;\\n            while(i+1<points.size() and points[j][1]>=points[i+1][0]){i++;}\\n            count++;\\n\\n        }\\n        return count ;\\n    }\\n        \\n \\n};\\nit is not working  for [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] this test case"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@JGarima2843](/JGarima2843)\\n\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(),points.end());\\n    int count=1 ;\\n    int comparator= points[0][1];\\n    for(int i=1;i<points.size();i++){\\n        if (comparator > points[i][1]) {comparator= points[i][1]; continue;}\\n        else if (comparator < points[i][0]) {count++; comparator= points[i][1];}\\n    }\\n    return count;\\n}      \\n};\\n\\nYour upper bound causes problem. Do you agree that we only increase when the last upperbound is less than current lowerbound?\\n"
                    },
                    {
                        "username": "spartex007",
                        "content": "Why its giving TLE ?\\n `bool cmp(vector <int> a , vector <int> b){\\n        return a[1] < b[1];\\n    }\\nclass Solution {\\n    public:\\n        int findMinArrowShots(vector<vector<int>>& points) {\\n            sort(points.begin() , points.end(), cmp);\\n            int flag = points[0][1] ;\\n            int ret = 1; \\n            for(auto i:points){\\n                if(i[0] > flag){\\n                    flag = i[1];\\n                    ret++;\\n                }\\n            }\\n            return ret;\\n        }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vedant Garode](/spartex007) use reference in comparator function i.e `vector<int> &` instead of normal variable to avoid copying of values. This will save a lot of time"
                    }
                ]
            },
            {
                "id": 1743324,
                "content": [
                    {
                        "username": "wolverine99",
                        "content": "Is there any way to solve it in O(n)? Just exploring about what the approach could be and if not what is the reason behind it not being solvable in O(n)."
                    },
                    {
                        "username": "S_Basu",
                        "content": "I think it is because sorting is required for this problem, and the best possible time complexity for sorting is O(n.log(n)). Please share if you find any other approach."
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i succesfully solved the problem , but did not rank good in runtime and memory , i was checking the optimal code and it turns out that his approach is same , but he implemented his own way of sorting (quick sort ) , i used the one provided by jdk and put my own comparator , i cant understand why does his code work better than me ? IN BOTH runtime and memory."
                    },
                    {
                        "username": "Yongbi",
                        "content": "Don\\'t think too much, just enjoy the game. Anw, if you want you can run a dry check on your computer to compare your code with a best one by timeit function."
                    },
                    {
                        "username": "S_Basu",
                        "content": "sometimes submission of the same code displays different results for *Your submission Beats x%*.\\nI guess we cannot do much about it. \\n\\n\\nMaybe it depends on other factors like bandwidth, latency, waiting time for the processing request etc."
                    },
                    {
                        "username": "arpan-banerjee7",
                        "content": "Need help--\n```\nclass Solution {\n    public int findMinArrowShots(int[][] points) {\n        int n=points.length;\n        Arrays.sort(points,((a,b)->a[0]-b[0]));\n\n        List<int[]> res=new ArrayList<>();\n        res.add(points[0]);\n        int k=0;\n\n        for(int i=1;i<n;i++){\n            if(res.get(k)[1]>=points[i][0]){\n                res.set(k,new int[]{(int)points[i][0],Math.min((int)res.get(k)[1],(int)points[i][1])});\n            }else{\n                res.add(points[i]);\n                k++;\n            }\n        }\n        return res.size();\n    }\n}\n```\npoints =\n[[-2147483646,-2147483645],[2147483646,2147483647]]\nOnly this test case fails here. I have used the concept of merge intervals here. Can anyone help me with passing this test case. This is an edge case."
                    },
                    {
                        "username": "arpan-banerjee7",
                        "content": "[@aneesh1029](/aneesh1029) Thanks it worked!"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "a-b for these inputs will be giving overflow "
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Hello instead of using a[0]-b[0] use .compare method"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3004120/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": " points[i] = [xstart, xend]\\nI wish there is a way to group elements with their maximum and minimum values and for every xstart,xe in points if either the minimum or the maximum is inside the  previous groups I will skip it else if neither the xstart nor  xend not in range of previous groups I will make new Group. \\nis there any way to implement this idea?\\n\\n\\nwhen I first look at the problem I thought it can be solved by union find algorithm. is there any one who used it?\\n"
                    },
                    {
                        "username": "adityashewalkar16",
                        "content": "Here is a similar problem: [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/).\\nAbove problem can be solved by using same concept and making few minor changes in the solution of this problem."
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "Tip: Exact similar to overlapping intervals or N meetings in one Room"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "TIP for C++:\\npass vectors to compare function by reference otherwise you will get TLE"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "hey can anyone give me suggestion that what changes i have to do in my code :\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n\\n        sort(points.begin(),points.end());\\n        int count=0 ;\\n        for(int i=0;i<points.size();i++){\\n            int j=i;\\n            while(i+1<points.size() and points[j][1]>=points[i+1][0]){i++;}\\n            count++;\\n\\n        }\\n        return count ;\\n    }\\n        \\n \\n};\\nit is not working  for [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] this test case"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@JGarima2843](/JGarima2843)\\n\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(),points.end());\\n    int count=1 ;\\n    int comparator= points[0][1];\\n    for(int i=1;i<points.size();i++){\\n        if (comparator > points[i][1]) {comparator= points[i][1]; continue;}\\n        else if (comparator < points[i][0]) {count++; comparator= points[i][1];}\\n    }\\n    return count;\\n}      \\n};\\n\\nYour upper bound causes problem. Do you agree that we only increase when the last upperbound is less than current lowerbound?\\n"
                    },
                    {
                        "username": "spartex007",
                        "content": "Why its giving TLE ?\\n `bool cmp(vector <int> a , vector <int> b){\\n        return a[1] < b[1];\\n    }\\nclass Solution {\\n    public:\\n        int findMinArrowShots(vector<vector<int>>& points) {\\n            sort(points.begin() , points.end(), cmp);\\n            int flag = points[0][1] ;\\n            int ret = 1; \\n            for(auto i:points){\\n                if(i[0] > flag){\\n                    flag = i[1];\\n                    ret++;\\n                }\\n            }\\n            return ret;\\n        }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vedant Garode](/spartex007) use reference in comparator function i.e `vector<int> &` instead of normal variable to avoid copying of values. This will save a lot of time"
                    }
                ]
            },
            {
                "id": 1743240,
                "content": [
                    {
                        "username": "wolverine99",
                        "content": "Is there any way to solve it in O(n)? Just exploring about what the approach could be and if not what is the reason behind it not being solvable in O(n)."
                    },
                    {
                        "username": "S_Basu",
                        "content": "I think it is because sorting is required for this problem, and the best possible time complexity for sorting is O(n.log(n)). Please share if you find any other approach."
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i succesfully solved the problem , but did not rank good in runtime and memory , i was checking the optimal code and it turns out that his approach is same , but he implemented his own way of sorting (quick sort ) , i used the one provided by jdk and put my own comparator , i cant understand why does his code work better than me ? IN BOTH runtime and memory."
                    },
                    {
                        "username": "Yongbi",
                        "content": "Don\\'t think too much, just enjoy the game. Anw, if you want you can run a dry check on your computer to compare your code with a best one by timeit function."
                    },
                    {
                        "username": "S_Basu",
                        "content": "sometimes submission of the same code displays different results for *Your submission Beats x%*.\\nI guess we cannot do much about it. \\n\\n\\nMaybe it depends on other factors like bandwidth, latency, waiting time for the processing request etc."
                    },
                    {
                        "username": "arpan-banerjee7",
                        "content": "Need help--\n```\nclass Solution {\n    public int findMinArrowShots(int[][] points) {\n        int n=points.length;\n        Arrays.sort(points,((a,b)->a[0]-b[0]));\n\n        List<int[]> res=new ArrayList<>();\n        res.add(points[0]);\n        int k=0;\n\n        for(int i=1;i<n;i++){\n            if(res.get(k)[1]>=points[i][0]){\n                res.set(k,new int[]{(int)points[i][0],Math.min((int)res.get(k)[1],(int)points[i][1])});\n            }else{\n                res.add(points[i]);\n                k++;\n            }\n        }\n        return res.size();\n    }\n}\n```\npoints =\n[[-2147483646,-2147483645],[2147483646,2147483647]]\nOnly this test case fails here. I have used the concept of merge intervals here. Can anyone help me with passing this test case. This is an edge case."
                    },
                    {
                        "username": "arpan-banerjee7",
                        "content": "[@aneesh1029](/aneesh1029) Thanks it worked!"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "a-b for these inputs will be giving overflow "
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Hello instead of using a[0]-b[0] use .compare method"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3004120/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": " points[i] = [xstart, xend]\\nI wish there is a way to group elements with their maximum and minimum values and for every xstart,xe in points if either the minimum or the maximum is inside the  previous groups I will skip it else if neither the xstart nor  xend not in range of previous groups I will make new Group. \\nis there any way to implement this idea?\\n\\n\\nwhen I first look at the problem I thought it can be solved by union find algorithm. is there any one who used it?\\n"
                    },
                    {
                        "username": "adityashewalkar16",
                        "content": "Here is a similar problem: [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/).\\nAbove problem can be solved by using same concept and making few minor changes in the solution of this problem."
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "Tip: Exact similar to overlapping intervals or N meetings in one Room"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "TIP for C++:\\npass vectors to compare function by reference otherwise you will get TLE"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "hey can anyone give me suggestion that what changes i have to do in my code :\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n\\n        sort(points.begin(),points.end());\\n        int count=0 ;\\n        for(int i=0;i<points.size();i++){\\n            int j=i;\\n            while(i+1<points.size() and points[j][1]>=points[i+1][0]){i++;}\\n            count++;\\n\\n        }\\n        return count ;\\n    }\\n        \\n \\n};\\nit is not working  for [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] this test case"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@JGarima2843](/JGarima2843)\\n\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(),points.end());\\n    int count=1 ;\\n    int comparator= points[0][1];\\n    for(int i=1;i<points.size();i++){\\n        if (comparator > points[i][1]) {comparator= points[i][1]; continue;}\\n        else if (comparator < points[i][0]) {count++; comparator= points[i][1];}\\n    }\\n    return count;\\n}      \\n};\\n\\nYour upper bound causes problem. Do you agree that we only increase when the last upperbound is less than current lowerbound?\\n"
                    },
                    {
                        "username": "spartex007",
                        "content": "Why its giving TLE ?\\n `bool cmp(vector <int> a , vector <int> b){\\n        return a[1] < b[1];\\n    }\\nclass Solution {\\n    public:\\n        int findMinArrowShots(vector<vector<int>>& points) {\\n            sort(points.begin() , points.end(), cmp);\\n            int flag = points[0][1] ;\\n            int ret = 1; \\n            for(auto i:points){\\n                if(i[0] > flag){\\n                    flag = i[1];\\n                    ret++;\\n                }\\n            }\\n            return ret;\\n        }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vedant Garode](/spartex007) use reference in comparator function i.e `vector<int> &` instead of normal variable to avoid copying of values. This will save a lot of time"
                    }
                ]
            },
            {
                "id": 1743238,
                "content": [
                    {
                        "username": "wolverine99",
                        "content": "Is there any way to solve it in O(n)? Just exploring about what the approach could be and if not what is the reason behind it not being solvable in O(n)."
                    },
                    {
                        "username": "S_Basu",
                        "content": "I think it is because sorting is required for this problem, and the best possible time complexity for sorting is O(n.log(n)). Please share if you find any other approach."
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i succesfully solved the problem , but did not rank good in runtime and memory , i was checking the optimal code and it turns out that his approach is same , but he implemented his own way of sorting (quick sort ) , i used the one provided by jdk and put my own comparator , i cant understand why does his code work better than me ? IN BOTH runtime and memory."
                    },
                    {
                        "username": "Yongbi",
                        "content": "Don\\'t think too much, just enjoy the game. Anw, if you want you can run a dry check on your computer to compare your code with a best one by timeit function."
                    },
                    {
                        "username": "S_Basu",
                        "content": "sometimes submission of the same code displays different results for *Your submission Beats x%*.\\nI guess we cannot do much about it. \\n\\n\\nMaybe it depends on other factors like bandwidth, latency, waiting time for the processing request etc."
                    },
                    {
                        "username": "arpan-banerjee7",
                        "content": "Need help--\n```\nclass Solution {\n    public int findMinArrowShots(int[][] points) {\n        int n=points.length;\n        Arrays.sort(points,((a,b)->a[0]-b[0]));\n\n        List<int[]> res=new ArrayList<>();\n        res.add(points[0]);\n        int k=0;\n\n        for(int i=1;i<n;i++){\n            if(res.get(k)[1]>=points[i][0]){\n                res.set(k,new int[]{(int)points[i][0],Math.min((int)res.get(k)[1],(int)points[i][1])});\n            }else{\n                res.add(points[i]);\n                k++;\n            }\n        }\n        return res.size();\n    }\n}\n```\npoints =\n[[-2147483646,-2147483645],[2147483646,2147483647]]\nOnly this test case fails here. I have used the concept of merge intervals here. Can anyone help me with passing this test case. This is an edge case."
                    },
                    {
                        "username": "arpan-banerjee7",
                        "content": "[@aneesh1029](/aneesh1029) Thanks it worked!"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "a-b for these inputs will be giving overflow "
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Hello instead of using a[0]-b[0] use .compare method"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3004120/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": " points[i] = [xstart, xend]\\nI wish there is a way to group elements with their maximum and minimum values and for every xstart,xe in points if either the minimum or the maximum is inside the  previous groups I will skip it else if neither the xstart nor  xend not in range of previous groups I will make new Group. \\nis there any way to implement this idea?\\n\\n\\nwhen I first look at the problem I thought it can be solved by union find algorithm. is there any one who used it?\\n"
                    },
                    {
                        "username": "adityashewalkar16",
                        "content": "Here is a similar problem: [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/).\\nAbove problem can be solved by using same concept and making few minor changes in the solution of this problem."
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "Tip: Exact similar to overlapping intervals or N meetings in one Room"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "TIP for C++:\\npass vectors to compare function by reference otherwise you will get TLE"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "hey can anyone give me suggestion that what changes i have to do in my code :\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n\\n        sort(points.begin(),points.end());\\n        int count=0 ;\\n        for(int i=0;i<points.size();i++){\\n            int j=i;\\n            while(i+1<points.size() and points[j][1]>=points[i+1][0]){i++;}\\n            count++;\\n\\n        }\\n        return count ;\\n    }\\n        \\n \\n};\\nit is not working  for [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] this test case"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@JGarima2843](/JGarima2843)\\n\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(),points.end());\\n    int count=1 ;\\n    int comparator= points[0][1];\\n    for(int i=1;i<points.size();i++){\\n        if (comparator > points[i][1]) {comparator= points[i][1]; continue;}\\n        else if (comparator < points[i][0]) {count++; comparator= points[i][1];}\\n    }\\n    return count;\\n}      \\n};\\n\\nYour upper bound causes problem. Do you agree that we only increase when the last upperbound is less than current lowerbound?\\n"
                    },
                    {
                        "username": "spartex007",
                        "content": "Why its giving TLE ?\\n `bool cmp(vector <int> a , vector <int> b){\\n        return a[1] < b[1];\\n    }\\nclass Solution {\\n    public:\\n        int findMinArrowShots(vector<vector<int>>& points) {\\n            sort(points.begin() , points.end(), cmp);\\n            int flag = points[0][1] ;\\n            int ret = 1; \\n            for(auto i:points){\\n                if(i[0] > flag){\\n                    flag = i[1];\\n                    ret++;\\n                }\\n            }\\n            return ret;\\n        }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vedant Garode](/spartex007) use reference in comparator function i.e `vector<int> &` instead of normal variable to avoid copying of values. This will save a lot of time"
                    }
                ]
            },
            {
                "id": 1743232,
                "content": [
                    {
                        "username": "wolverine99",
                        "content": "Is there any way to solve it in O(n)? Just exploring about what the approach could be and if not what is the reason behind it not being solvable in O(n)."
                    },
                    {
                        "username": "S_Basu",
                        "content": "I think it is because sorting is required for this problem, and the best possible time complexity for sorting is O(n.log(n)). Please share if you find any other approach."
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i succesfully solved the problem , but did not rank good in runtime and memory , i was checking the optimal code and it turns out that his approach is same , but he implemented his own way of sorting (quick sort ) , i used the one provided by jdk and put my own comparator , i cant understand why does his code work better than me ? IN BOTH runtime and memory."
                    },
                    {
                        "username": "Yongbi",
                        "content": "Don\\'t think too much, just enjoy the game. Anw, if you want you can run a dry check on your computer to compare your code with a best one by timeit function."
                    },
                    {
                        "username": "S_Basu",
                        "content": "sometimes submission of the same code displays different results for *Your submission Beats x%*.\\nI guess we cannot do much about it. \\n\\n\\nMaybe it depends on other factors like bandwidth, latency, waiting time for the processing request etc."
                    },
                    {
                        "username": "arpan-banerjee7",
                        "content": "Need help--\n```\nclass Solution {\n    public int findMinArrowShots(int[][] points) {\n        int n=points.length;\n        Arrays.sort(points,((a,b)->a[0]-b[0]));\n\n        List<int[]> res=new ArrayList<>();\n        res.add(points[0]);\n        int k=0;\n\n        for(int i=1;i<n;i++){\n            if(res.get(k)[1]>=points[i][0]){\n                res.set(k,new int[]{(int)points[i][0],Math.min((int)res.get(k)[1],(int)points[i][1])});\n            }else{\n                res.add(points[i]);\n                k++;\n            }\n        }\n        return res.size();\n    }\n}\n```\npoints =\n[[-2147483646,-2147483645],[2147483646,2147483647]]\nOnly this test case fails here. I have used the concept of merge intervals here. Can anyone help me with passing this test case. This is an edge case."
                    },
                    {
                        "username": "arpan-banerjee7",
                        "content": "[@aneesh1029](/aneesh1029) Thanks it worked!"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "a-b for these inputs will be giving overflow "
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Hello instead of using a[0]-b[0] use .compare method"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3004120/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": " points[i] = [xstart, xend]\\nI wish there is a way to group elements with their maximum and minimum values and for every xstart,xe in points if either the minimum or the maximum is inside the  previous groups I will skip it else if neither the xstart nor  xend not in range of previous groups I will make new Group. \\nis there any way to implement this idea?\\n\\n\\nwhen I first look at the problem I thought it can be solved by union find algorithm. is there any one who used it?\\n"
                    },
                    {
                        "username": "adityashewalkar16",
                        "content": "Here is a similar problem: [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/).\\nAbove problem can be solved by using same concept and making few minor changes in the solution of this problem."
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "Tip: Exact similar to overlapping intervals or N meetings in one Room"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "TIP for C++:\\npass vectors to compare function by reference otherwise you will get TLE"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "hey can anyone give me suggestion that what changes i have to do in my code :\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n\\n        sort(points.begin(),points.end());\\n        int count=0 ;\\n        for(int i=0;i<points.size();i++){\\n            int j=i;\\n            while(i+1<points.size() and points[j][1]>=points[i+1][0]){i++;}\\n            count++;\\n\\n        }\\n        return count ;\\n    }\\n        \\n \\n};\\nit is not working  for [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] this test case"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@JGarima2843](/JGarima2843)\\n\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(),points.end());\\n    int count=1 ;\\n    int comparator= points[0][1];\\n    for(int i=1;i<points.size();i++){\\n        if (comparator > points[i][1]) {comparator= points[i][1]; continue;}\\n        else if (comparator < points[i][0]) {count++; comparator= points[i][1];}\\n    }\\n    return count;\\n}      \\n};\\n\\nYour upper bound causes problem. Do you agree that we only increase when the last upperbound is less than current lowerbound?\\n"
                    },
                    {
                        "username": "spartex007",
                        "content": "Why its giving TLE ?\\n `bool cmp(vector <int> a , vector <int> b){\\n        return a[1] < b[1];\\n    }\\nclass Solution {\\n    public:\\n        int findMinArrowShots(vector<vector<int>>& points) {\\n            sort(points.begin() , points.end(), cmp);\\n            int flag = points[0][1] ;\\n            int ret = 1; \\n            for(auto i:points){\\n                if(i[0] > flag){\\n                    flag = i[1];\\n                    ret++;\\n                }\\n            }\\n            return ret;\\n        }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vedant Garode](/spartex007) use reference in comparator function i.e `vector<int> &` instead of normal variable to avoid copying of values. This will save a lot of time"
                    }
                ]
            },
            {
                "id": 1743151,
                "content": [
                    {
                        "username": "wolverine99",
                        "content": "Is there any way to solve it in O(n)? Just exploring about what the approach could be and if not what is the reason behind it not being solvable in O(n)."
                    },
                    {
                        "username": "S_Basu",
                        "content": "I think it is because sorting is required for this problem, and the best possible time complexity for sorting is O(n.log(n)). Please share if you find any other approach."
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i succesfully solved the problem , but did not rank good in runtime and memory , i was checking the optimal code and it turns out that his approach is same , but he implemented his own way of sorting (quick sort ) , i used the one provided by jdk and put my own comparator , i cant understand why does his code work better than me ? IN BOTH runtime and memory."
                    },
                    {
                        "username": "Yongbi",
                        "content": "Don\\'t think too much, just enjoy the game. Anw, if you want you can run a dry check on your computer to compare your code with a best one by timeit function."
                    },
                    {
                        "username": "S_Basu",
                        "content": "sometimes submission of the same code displays different results for *Your submission Beats x%*.\\nI guess we cannot do much about it. \\n\\n\\nMaybe it depends on other factors like bandwidth, latency, waiting time for the processing request etc."
                    },
                    {
                        "username": "arpan-banerjee7",
                        "content": "Need help--\n```\nclass Solution {\n    public int findMinArrowShots(int[][] points) {\n        int n=points.length;\n        Arrays.sort(points,((a,b)->a[0]-b[0]));\n\n        List<int[]> res=new ArrayList<>();\n        res.add(points[0]);\n        int k=0;\n\n        for(int i=1;i<n;i++){\n            if(res.get(k)[1]>=points[i][0]){\n                res.set(k,new int[]{(int)points[i][0],Math.min((int)res.get(k)[1],(int)points[i][1])});\n            }else{\n                res.add(points[i]);\n                k++;\n            }\n        }\n        return res.size();\n    }\n}\n```\npoints =\n[[-2147483646,-2147483645],[2147483646,2147483647]]\nOnly this test case fails here. I have used the concept of merge intervals here. Can anyone help me with passing this test case. This is an edge case."
                    },
                    {
                        "username": "arpan-banerjee7",
                        "content": "[@aneesh1029](/aneesh1029) Thanks it worked!"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "a-b for these inputs will be giving overflow "
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Hello instead of using a[0]-b[0] use .compare method"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand.\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3004120/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": " points[i] = [xstart, xend]\\nI wish there is a way to group elements with their maximum and minimum values and for every xstart,xe in points if either the minimum or the maximum is inside the  previous groups I will skip it else if neither the xstart nor  xend not in range of previous groups I will make new Group. \\nis there any way to implement this idea?\\n\\n\\nwhen I first look at the problem I thought it can be solved by union find algorithm. is there any one who used it?\\n"
                    },
                    {
                        "username": "adityashewalkar16",
                        "content": "Here is a similar problem: [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/).\\nAbove problem can be solved by using same concept and making few minor changes in the solution of this problem."
                    },
                    {
                        "username": "prayaggavshinde",
                        "content": "Tip: Exact similar to overlapping intervals or N meetings in one Room"
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "TIP for C++:\\npass vectors to compare function by reference otherwise you will get TLE"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "hey can anyone give me suggestion that what changes i have to do in my code :\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n\\n        sort(points.begin(),points.end());\\n        int count=0 ;\\n        for(int i=0;i<points.size();i++){\\n            int j=i;\\n            while(i+1<points.size() and points[j][1]>=points[i+1][0]){i++;}\\n            count++;\\n\\n        }\\n        return count ;\\n    }\\n        \\n \\n};\\nit is not working  for [[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] this test case"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@JGarima2843](/JGarima2843)\\n\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        sort(points.begin(),points.end());\\n    int count=1 ;\\n    int comparator= points[0][1];\\n    for(int i=1;i<points.size();i++){\\n        if (comparator > points[i][1]) {comparator= points[i][1]; continue;}\\n        else if (comparator < points[i][0]) {count++; comparator= points[i][1];}\\n    }\\n    return count;\\n}      \\n};\\n\\nYour upper bound causes problem. Do you agree that we only increase when the last upperbound is less than current lowerbound?\\n"
                    },
                    {
                        "username": "spartex007",
                        "content": "Why its giving TLE ?\\n `bool cmp(vector <int> a , vector <int> b){\\n        return a[1] < b[1];\\n    }\\nclass Solution {\\n    public:\\n        int findMinArrowShots(vector<vector<int>>& points) {\\n            sort(points.begin() , points.end(), cmp);\\n            int flag = points[0][1] ;\\n            int ret = 1; \\n            for(auto i:points){\\n                if(i[0] > flag){\\n                    flag = i[1];\\n                    ret++;\\n                }\\n            }\\n            return ret;\\n        }\\n};`"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vedant Garode](/spartex007) use reference in comparator function i.e `vector<int> &` instead of normal variable to avoid copying of values. This will save a lot of time"
                    }
                ]
            },
            {
                "id": 1743128,
                "content": [
                    {
                        "username": "AmreshKrrish",
                        "content": "int findMinArrowShots(vector<vector<int>>& points) {\\n    int n=points.size();\\n        sort(points.begin(),points.end());\\n        int ans=1;\\n        int top = points[0][1];\\n        for(int i=1;i<n;i++){\\n            if(points[i][0]<=top){\\n                top = min(top,points[i][1]);\\n            }\\n            else{\\n                top=points[i][1];\\n                ans++;\\n            }}\\n            return ans;\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "// Intution is to find the Intersection between lines.Modification of Merge Intervals Problem from my prespective\\nint findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        sort(points.begin() , points.end());\\n\\n        stack<pair<int,int>> s;\\n\\n        for(auto p : points){\\n            if(s.empty() or p[0]>s.top().second){\\n                s.push({p[0] , p[1]});\\n            }\\n            else if(p[0]<=s.top().second){\\n                s.top().second=min(p[1] , s.top().second);\\n            }\\n        }\\n        return s.size();\\n    }"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "In C++, if you are writing a comparator yourself, it will have two vectors as parameters like shown below. Here they are passed as reference, but if you pass them as value, your program will fail for some larger test cases due to TLE because if you pass by value compiler will make a copy which will consume time.\\n\\n`static bool compareXEnd(vector<int> &a, vector<int> &b) {\\n        return a[1] < b[1];\\n    }`"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\\n\\nHow the expected output is 2? It doesn\\'t make any sense to me."
                    },
                    {
                        "username": "Mariia_89",
                        "content": "You can sort \\'points\\', it\\'ll be look as: \\n[[0,6],[0,9],[2,8],[2,9],[3,8],[3,9],[3,9],[6,8],[7,12],[9,10]]\\nNext you should to find one of the same part for elements of sorting \\'points\\':\\n[0,6] and [0,9] - it\\'s [0,6]\\n[0,6] and [2,8] - it\\'s [2,6]\\n[2,6] and [2,9] - it\\'s [2,6]\\n[2,6] and [3,8] - it\\'s [3,6]\\n[3,6] and [3,9] - it\\'s [3,6]\\n[3,6] and [3,9] - it\\'s [3,6]\\n[3,6] and [6,8] - it\\'s only [6]\\nThis balloons you can shoot by the one arrow (arrow = 1)\\n\\n[6] and [7,12] - there isn\\'t  any same part between this elements! So you should use one more arrow (arrow = 2). And now you should continue to find one of the same part again:\\n[7,12] and [9,10] - it\\'s [9,10]. This balloons you can also shoot by the one arrow.\\n\\n\\'Points\\' is finished. Output is 2.\\n"
                    },
                    {
                        "username": "user2857Tj",
                        "content": "Adding"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "this question took almost more than 2 hours to solve but at last my solution got submitted "
                    },
                    {
                        "username": "Mathesh_2002",
                        "content": "Tips for beginners: If you are using C++ never use pass by value in the comparator lambda function, always use pass by reference or pass by pointers. Else you will encounter TLE"
                    },
                    {
                        "username": "natchyunicorn",
                        "content": "Why I pass only 47/49 testcases??"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Interesting question, even though it gave me a headache and a dozens of wrong answers. You know what I mean right ? No ? I guess its only me LOL. Anyways, here is a TIP.\n\n` TIP `\nI just used a stack and replaced two overlapping balloons with their overlap and treated it as one balloon instead. Honestly, I did a wayyyy better job explaining it here :\n\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\n\nKeep going guys.. We will get there! "
                    },
                    {
                        "username": "iLapras",
                        "content": " `sort(points.begin(), points.end(), [](auto &a, auto&b) {\\n    return a[1] <= b[1];\\n});`\\n\\n `sort(points.begin(), points.end(), [](auto &a, auto&b) {\\n    return a[1] < b[1];\\n});`\\n\\nDoes anybody knows why the bottom code (without equal comparison) gets accepted but the above code gives `runtime error: applying non-zero offset 4 to null pointer`."
                    }
                ]
            },
            {
                "id": 1743091,
                "content": [
                    {
                        "username": "AmreshKrrish",
                        "content": "int findMinArrowShots(vector<vector<int>>& points) {\\n    int n=points.size();\\n        sort(points.begin(),points.end());\\n        int ans=1;\\n        int top = points[0][1];\\n        for(int i=1;i<n;i++){\\n            if(points[i][0]<=top){\\n                top = min(top,points[i][1]);\\n            }\\n            else{\\n                top=points[i][1];\\n                ans++;\\n            }}\\n            return ans;\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "// Intution is to find the Intersection between lines.Modification of Merge Intervals Problem from my prespective\\nint findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        sort(points.begin() , points.end());\\n\\n        stack<pair<int,int>> s;\\n\\n        for(auto p : points){\\n            if(s.empty() or p[0]>s.top().second){\\n                s.push({p[0] , p[1]});\\n            }\\n            else if(p[0]<=s.top().second){\\n                s.top().second=min(p[1] , s.top().second);\\n            }\\n        }\\n        return s.size();\\n    }"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "In C++, if you are writing a comparator yourself, it will have two vectors as parameters like shown below. Here they are passed as reference, but if you pass them as value, your program will fail for some larger test cases due to TLE because if you pass by value compiler will make a copy which will consume time.\\n\\n`static bool compareXEnd(vector<int> &a, vector<int> &b) {\\n        return a[1] < b[1];\\n    }`"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\\n\\nHow the expected output is 2? It doesn\\'t make any sense to me."
                    },
                    {
                        "username": "Mariia_89",
                        "content": "You can sort \\'points\\', it\\'ll be look as: \\n[[0,6],[0,9],[2,8],[2,9],[3,8],[3,9],[3,9],[6,8],[7,12],[9,10]]\\nNext you should to find one of the same part for elements of sorting \\'points\\':\\n[0,6] and [0,9] - it\\'s [0,6]\\n[0,6] and [2,8] - it\\'s [2,6]\\n[2,6] and [2,9] - it\\'s [2,6]\\n[2,6] and [3,8] - it\\'s [3,6]\\n[3,6] and [3,9] - it\\'s [3,6]\\n[3,6] and [3,9] - it\\'s [3,6]\\n[3,6] and [6,8] - it\\'s only [6]\\nThis balloons you can shoot by the one arrow (arrow = 1)\\n\\n[6] and [7,12] - there isn\\'t  any same part between this elements! So you should use one more arrow (arrow = 2). And now you should continue to find one of the same part again:\\n[7,12] and [9,10] - it\\'s [9,10]. This balloons you can also shoot by the one arrow.\\n\\n\\'Points\\' is finished. Output is 2.\\n"
                    },
                    {
                        "username": "user2857Tj",
                        "content": "Adding"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "this question took almost more than 2 hours to solve but at last my solution got submitted "
                    },
                    {
                        "username": "Mathesh_2002",
                        "content": "Tips for beginners: If you are using C++ never use pass by value in the comparator lambda function, always use pass by reference or pass by pointers. Else you will encounter TLE"
                    },
                    {
                        "username": "natchyunicorn",
                        "content": "Why I pass only 47/49 testcases??"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Interesting question, even though it gave me a headache and a dozens of wrong answers. You know what I mean right ? No ? I guess its only me LOL. Anyways, here is a TIP.\n\n` TIP `\nI just used a stack and replaced two overlapping balloons with their overlap and treated it as one balloon instead. Honestly, I did a wayyyy better job explaining it here :\n\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\n\nKeep going guys.. We will get there! "
                    },
                    {
                        "username": "iLapras",
                        "content": " `sort(points.begin(), points.end(), [](auto &a, auto&b) {\\n    return a[1] <= b[1];\\n});`\\n\\n `sort(points.begin(), points.end(), [](auto &a, auto&b) {\\n    return a[1] < b[1];\\n});`\\n\\nDoes anybody knows why the bottom code (without equal comparison) gets accepted but the above code gives `runtime error: applying non-zero offset 4 to null pointer`."
                    }
                ]
            },
            {
                "id": 1743014,
                "content": [
                    {
                        "username": "AmreshKrrish",
                        "content": "int findMinArrowShots(vector<vector<int>>& points) {\\n    int n=points.size();\\n        sort(points.begin(),points.end());\\n        int ans=1;\\n        int top = points[0][1];\\n        for(int i=1;i<n;i++){\\n            if(points[i][0]<=top){\\n                top = min(top,points[i][1]);\\n            }\\n            else{\\n                top=points[i][1];\\n                ans++;\\n            }}\\n            return ans;\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "// Intution is to find the Intersection between lines.Modification of Merge Intervals Problem from my prespective\\nint findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        sort(points.begin() , points.end());\\n\\n        stack<pair<int,int>> s;\\n\\n        for(auto p : points){\\n            if(s.empty() or p[0]>s.top().second){\\n                s.push({p[0] , p[1]});\\n            }\\n            else if(p[0]<=s.top().second){\\n                s.top().second=min(p[1] , s.top().second);\\n            }\\n        }\\n        return s.size();\\n    }"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "In C++, if you are writing a comparator yourself, it will have two vectors as parameters like shown below. Here they are passed as reference, but if you pass them as value, your program will fail for some larger test cases due to TLE because if you pass by value compiler will make a copy which will consume time.\\n\\n`static bool compareXEnd(vector<int> &a, vector<int> &b) {\\n        return a[1] < b[1];\\n    }`"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\\n\\nHow the expected output is 2? It doesn\\'t make any sense to me."
                    },
                    {
                        "username": "Mariia_89",
                        "content": "You can sort \\'points\\', it\\'ll be look as: \\n[[0,6],[0,9],[2,8],[2,9],[3,8],[3,9],[3,9],[6,8],[7,12],[9,10]]\\nNext you should to find one of the same part for elements of sorting \\'points\\':\\n[0,6] and [0,9] - it\\'s [0,6]\\n[0,6] and [2,8] - it\\'s [2,6]\\n[2,6] and [2,9] - it\\'s [2,6]\\n[2,6] and [3,8] - it\\'s [3,6]\\n[3,6] and [3,9] - it\\'s [3,6]\\n[3,6] and [3,9] - it\\'s [3,6]\\n[3,6] and [6,8] - it\\'s only [6]\\nThis balloons you can shoot by the one arrow (arrow = 1)\\n\\n[6] and [7,12] - there isn\\'t  any same part between this elements! So you should use one more arrow (arrow = 2). And now you should continue to find one of the same part again:\\n[7,12] and [9,10] - it\\'s [9,10]. This balloons you can also shoot by the one arrow.\\n\\n\\'Points\\' is finished. Output is 2.\\n"
                    },
                    {
                        "username": "user2857Tj",
                        "content": "Adding"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "this question took almost more than 2 hours to solve but at last my solution got submitted "
                    },
                    {
                        "username": "Mathesh_2002",
                        "content": "Tips for beginners: If you are using C++ never use pass by value in the comparator lambda function, always use pass by reference or pass by pointers. Else you will encounter TLE"
                    },
                    {
                        "username": "natchyunicorn",
                        "content": "Why I pass only 47/49 testcases??"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Interesting question, even though it gave me a headache and a dozens of wrong answers. You know what I mean right ? No ? I guess its only me LOL. Anyways, here is a TIP.\n\n` TIP `\nI just used a stack and replaced two overlapping balloons with their overlap and treated it as one balloon instead. Honestly, I did a wayyyy better job explaining it here :\n\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\n\nKeep going guys.. We will get there! "
                    },
                    {
                        "username": "iLapras",
                        "content": " `sort(points.begin(), points.end(), [](auto &a, auto&b) {\\n    return a[1] <= b[1];\\n});`\\n\\n `sort(points.begin(), points.end(), [](auto &a, auto&b) {\\n    return a[1] < b[1];\\n});`\\n\\nDoes anybody knows why the bottom code (without equal comparison) gets accepted but the above code gives `runtime error: applying non-zero offset 4 to null pointer`."
                    }
                ]
            },
            {
                "id": 1742991,
                "content": [
                    {
                        "username": "AmreshKrrish",
                        "content": "int findMinArrowShots(vector<vector<int>>& points) {\\n    int n=points.size();\\n        sort(points.begin(),points.end());\\n        int ans=1;\\n        int top = points[0][1];\\n        for(int i=1;i<n;i++){\\n            if(points[i][0]<=top){\\n                top = min(top,points[i][1]);\\n            }\\n            else{\\n                top=points[i][1];\\n                ans++;\\n            }}\\n            return ans;\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "// Intution is to find the Intersection between lines.Modification of Merge Intervals Problem from my prespective\\nint findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        sort(points.begin() , points.end());\\n\\n        stack<pair<int,int>> s;\\n\\n        for(auto p : points){\\n            if(s.empty() or p[0]>s.top().second){\\n                s.push({p[0] , p[1]});\\n            }\\n            else if(p[0]<=s.top().second){\\n                s.top().second=min(p[1] , s.top().second);\\n            }\\n        }\\n        return s.size();\\n    }"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "In C++, if you are writing a comparator yourself, it will have two vectors as parameters like shown below. Here they are passed as reference, but if you pass them as value, your program will fail for some larger test cases due to TLE because if you pass by value compiler will make a copy which will consume time.\\n\\n`static bool compareXEnd(vector<int> &a, vector<int> &b) {\\n        return a[1] < b[1];\\n    }`"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\\n\\nHow the expected output is 2? It doesn\\'t make any sense to me."
                    },
                    {
                        "username": "Mariia_89",
                        "content": "You can sort \\'points\\', it\\'ll be look as: \\n[[0,6],[0,9],[2,8],[2,9],[3,8],[3,9],[3,9],[6,8],[7,12],[9,10]]\\nNext you should to find one of the same part for elements of sorting \\'points\\':\\n[0,6] and [0,9] - it\\'s [0,6]\\n[0,6] and [2,8] - it\\'s [2,6]\\n[2,6] and [2,9] - it\\'s [2,6]\\n[2,6] and [3,8] - it\\'s [3,6]\\n[3,6] and [3,9] - it\\'s [3,6]\\n[3,6] and [3,9] - it\\'s [3,6]\\n[3,6] and [6,8] - it\\'s only [6]\\nThis balloons you can shoot by the one arrow (arrow = 1)\\n\\n[6] and [7,12] - there isn\\'t  any same part between this elements! So you should use one more arrow (arrow = 2). And now you should continue to find one of the same part again:\\n[7,12] and [9,10] - it\\'s [9,10]. This balloons you can also shoot by the one arrow.\\n\\n\\'Points\\' is finished. Output is 2.\\n"
                    },
                    {
                        "username": "user2857Tj",
                        "content": "Adding"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "this question took almost more than 2 hours to solve but at last my solution got submitted "
                    },
                    {
                        "username": "Mathesh_2002",
                        "content": "Tips for beginners: If you are using C++ never use pass by value in the comparator lambda function, always use pass by reference or pass by pointers. Else you will encounter TLE"
                    },
                    {
                        "username": "natchyunicorn",
                        "content": "Why I pass only 47/49 testcases??"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Interesting question, even though it gave me a headache and a dozens of wrong answers. You know what I mean right ? No ? I guess its only me LOL. Anyways, here is a TIP.\n\n` TIP `\nI just used a stack and replaced two overlapping balloons with their overlap and treated it as one balloon instead. Honestly, I did a wayyyy better job explaining it here :\n\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\n\nKeep going guys.. We will get there! "
                    },
                    {
                        "username": "iLapras",
                        "content": " `sort(points.begin(), points.end(), [](auto &a, auto&b) {\\n    return a[1] <= b[1];\\n});`\\n\\n `sort(points.begin(), points.end(), [](auto &a, auto&b) {\\n    return a[1] < b[1];\\n});`\\n\\nDoes anybody knows why the bottom code (without equal comparison) gets accepted but the above code gives `runtime error: applying non-zero offset 4 to null pointer`."
                    }
                ]
            },
            {
                "id": 1742950,
                "content": [
                    {
                        "username": "AmreshKrrish",
                        "content": "int findMinArrowShots(vector<vector<int>>& points) {\\n    int n=points.size();\\n        sort(points.begin(),points.end());\\n        int ans=1;\\n        int top = points[0][1];\\n        for(int i=1;i<n;i++){\\n            if(points[i][0]<=top){\\n                top = min(top,points[i][1]);\\n            }\\n            else{\\n                top=points[i][1];\\n                ans++;\\n            }}\\n            return ans;\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "// Intution is to find the Intersection between lines.Modification of Merge Intervals Problem from my prespective\\nint findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        sort(points.begin() , points.end());\\n\\n        stack<pair<int,int>> s;\\n\\n        for(auto p : points){\\n            if(s.empty() or p[0]>s.top().second){\\n                s.push({p[0] , p[1]});\\n            }\\n            else if(p[0]<=s.top().second){\\n                s.top().second=min(p[1] , s.top().second);\\n            }\\n        }\\n        return s.size();\\n    }"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "In C++, if you are writing a comparator yourself, it will have two vectors as parameters like shown below. Here they are passed as reference, but if you pass them as value, your program will fail for some larger test cases due to TLE because if you pass by value compiler will make a copy which will consume time.\\n\\n`static bool compareXEnd(vector<int> &a, vector<int> &b) {\\n        return a[1] < b[1];\\n    }`"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\\n\\nHow the expected output is 2? It doesn\\'t make any sense to me."
                    },
                    {
                        "username": "Mariia_89",
                        "content": "You can sort \\'points\\', it\\'ll be look as: \\n[[0,6],[0,9],[2,8],[2,9],[3,8],[3,9],[3,9],[6,8],[7,12],[9,10]]\\nNext you should to find one of the same part for elements of sorting \\'points\\':\\n[0,6] and [0,9] - it\\'s [0,6]\\n[0,6] and [2,8] - it\\'s [2,6]\\n[2,6] and [2,9] - it\\'s [2,6]\\n[2,6] and [3,8] - it\\'s [3,6]\\n[3,6] and [3,9] - it\\'s [3,6]\\n[3,6] and [3,9] - it\\'s [3,6]\\n[3,6] and [6,8] - it\\'s only [6]\\nThis balloons you can shoot by the one arrow (arrow = 1)\\n\\n[6] and [7,12] - there isn\\'t  any same part between this elements! So you should use one more arrow (arrow = 2). And now you should continue to find one of the same part again:\\n[7,12] and [9,10] - it\\'s [9,10]. This balloons you can also shoot by the one arrow.\\n\\n\\'Points\\' is finished. Output is 2.\\n"
                    },
                    {
                        "username": "user2857Tj",
                        "content": "Adding"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "this question took almost more than 2 hours to solve but at last my solution got submitted "
                    },
                    {
                        "username": "Mathesh_2002",
                        "content": "Tips for beginners: If you are using C++ never use pass by value in the comparator lambda function, always use pass by reference or pass by pointers. Else you will encounter TLE"
                    },
                    {
                        "username": "natchyunicorn",
                        "content": "Why I pass only 47/49 testcases??"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Interesting question, even though it gave me a headache and a dozens of wrong answers. You know what I mean right ? No ? I guess its only me LOL. Anyways, here is a TIP.\n\n` TIP `\nI just used a stack and replaced two overlapping balloons with their overlap and treated it as one balloon instead. Honestly, I did a wayyyy better job explaining it here :\n\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\n\nKeep going guys.. We will get there! "
                    },
                    {
                        "username": "iLapras",
                        "content": " `sort(points.begin(), points.end(), [](auto &a, auto&b) {\\n    return a[1] <= b[1];\\n});`\\n\\n `sort(points.begin(), points.end(), [](auto &a, auto&b) {\\n    return a[1] < b[1];\\n});`\\n\\nDoes anybody knows why the bottom code (without equal comparison) gets accepted but the above code gives `runtime error: applying non-zero offset 4 to null pointer`."
                    }
                ]
            },
            {
                "id": 1742943,
                "content": [
                    {
                        "username": "AmreshKrrish",
                        "content": "int findMinArrowShots(vector<vector<int>>& points) {\\n    int n=points.size();\\n        sort(points.begin(),points.end());\\n        int ans=1;\\n        int top = points[0][1];\\n        for(int i=1;i<n;i++){\\n            if(points[i][0]<=top){\\n                top = min(top,points[i][1]);\\n            }\\n            else{\\n                top=points[i][1];\\n                ans++;\\n            }}\\n            return ans;\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "// Intution is to find the Intersection between lines.Modification of Merge Intervals Problem from my prespective\\nint findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        sort(points.begin() , points.end());\\n\\n        stack<pair<int,int>> s;\\n\\n        for(auto p : points){\\n            if(s.empty() or p[0]>s.top().second){\\n                s.push({p[0] , p[1]});\\n            }\\n            else if(p[0]<=s.top().second){\\n                s.top().second=min(p[1] , s.top().second);\\n            }\\n        }\\n        return s.size();\\n    }"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "In C++, if you are writing a comparator yourself, it will have two vectors as parameters like shown below. Here they are passed as reference, but if you pass them as value, your program will fail for some larger test cases due to TLE because if you pass by value compiler will make a copy which will consume time.\\n\\n`static bool compareXEnd(vector<int> &a, vector<int> &b) {\\n        return a[1] < b[1];\\n    }`"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\\n\\nHow the expected output is 2? It doesn\\'t make any sense to me."
                    },
                    {
                        "username": "Mariia_89",
                        "content": "You can sort \\'points\\', it\\'ll be look as: \\n[[0,6],[0,9],[2,8],[2,9],[3,8],[3,9],[3,9],[6,8],[7,12],[9,10]]\\nNext you should to find one of the same part for elements of sorting \\'points\\':\\n[0,6] and [0,9] - it\\'s [0,6]\\n[0,6] and [2,8] - it\\'s [2,6]\\n[2,6] and [2,9] - it\\'s [2,6]\\n[2,6] and [3,8] - it\\'s [3,6]\\n[3,6] and [3,9] - it\\'s [3,6]\\n[3,6] and [3,9] - it\\'s [3,6]\\n[3,6] and [6,8] - it\\'s only [6]\\nThis balloons you can shoot by the one arrow (arrow = 1)\\n\\n[6] and [7,12] - there isn\\'t  any same part between this elements! So you should use one more arrow (arrow = 2). And now you should continue to find one of the same part again:\\n[7,12] and [9,10] - it\\'s [9,10]. This balloons you can also shoot by the one arrow.\\n\\n\\'Points\\' is finished. Output is 2.\\n"
                    },
                    {
                        "username": "user2857Tj",
                        "content": "Adding"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "this question took almost more than 2 hours to solve but at last my solution got submitted "
                    },
                    {
                        "username": "Mathesh_2002",
                        "content": "Tips for beginners: If you are using C++ never use pass by value in the comparator lambda function, always use pass by reference or pass by pointers. Else you will encounter TLE"
                    },
                    {
                        "username": "natchyunicorn",
                        "content": "Why I pass only 47/49 testcases??"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Interesting question, even though it gave me a headache and a dozens of wrong answers. You know what I mean right ? No ? I guess its only me LOL. Anyways, here is a TIP.\n\n` TIP `\nI just used a stack and replaced two overlapping balloons with their overlap and treated it as one balloon instead. Honestly, I did a wayyyy better job explaining it here :\n\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\n\nKeep going guys.. We will get there! "
                    },
                    {
                        "username": "iLapras",
                        "content": " `sort(points.begin(), points.end(), [](auto &a, auto&b) {\\n    return a[1] <= b[1];\\n});`\\n\\n `sort(points.begin(), points.end(), [](auto &a, auto&b) {\\n    return a[1] < b[1];\\n});`\\n\\nDoes anybody knows why the bottom code (without equal comparison) gets accepted but the above code gives `runtime error: applying non-zero offset 4 to null pointer`."
                    }
                ]
            },
            {
                "id": 1742940,
                "content": [
                    {
                        "username": "AmreshKrrish",
                        "content": "int findMinArrowShots(vector<vector<int>>& points) {\\n    int n=points.size();\\n        sort(points.begin(),points.end());\\n        int ans=1;\\n        int top = points[0][1];\\n        for(int i=1;i<n;i++){\\n            if(points[i][0]<=top){\\n                top = min(top,points[i][1]);\\n            }\\n            else{\\n                top=points[i][1];\\n                ans++;\\n            }}\\n            return ans;\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "// Intution is to find the Intersection between lines.Modification of Merge Intervals Problem from my prespective\\nint findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        sort(points.begin() , points.end());\\n\\n        stack<pair<int,int>> s;\\n\\n        for(auto p : points){\\n            if(s.empty() or p[0]>s.top().second){\\n                s.push({p[0] , p[1]});\\n            }\\n            else if(p[0]<=s.top().second){\\n                s.top().second=min(p[1] , s.top().second);\\n            }\\n        }\\n        return s.size();\\n    }"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "In C++, if you are writing a comparator yourself, it will have two vectors as parameters like shown below. Here they are passed as reference, but if you pass them as value, your program will fail for some larger test cases due to TLE because if you pass by value compiler will make a copy which will consume time.\\n\\n`static bool compareXEnd(vector<int> &a, vector<int> &b) {\\n        return a[1] < b[1];\\n    }`"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\\n\\nHow the expected output is 2? It doesn\\'t make any sense to me."
                    },
                    {
                        "username": "Mariia_89",
                        "content": "You can sort \\'points\\', it\\'ll be look as: \\n[[0,6],[0,9],[2,8],[2,9],[3,8],[3,9],[3,9],[6,8],[7,12],[9,10]]\\nNext you should to find one of the same part for elements of sorting \\'points\\':\\n[0,6] and [0,9] - it\\'s [0,6]\\n[0,6] and [2,8] - it\\'s [2,6]\\n[2,6] and [2,9] - it\\'s [2,6]\\n[2,6] and [3,8] - it\\'s [3,6]\\n[3,6] and [3,9] - it\\'s [3,6]\\n[3,6] and [3,9] - it\\'s [3,6]\\n[3,6] and [6,8] - it\\'s only [6]\\nThis balloons you can shoot by the one arrow (arrow = 1)\\n\\n[6] and [7,12] - there isn\\'t  any same part between this elements! So you should use one more arrow (arrow = 2). And now you should continue to find one of the same part again:\\n[7,12] and [9,10] - it\\'s [9,10]. This balloons you can also shoot by the one arrow.\\n\\n\\'Points\\' is finished. Output is 2.\\n"
                    },
                    {
                        "username": "user2857Tj",
                        "content": "Adding"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "this question took almost more than 2 hours to solve but at last my solution got submitted "
                    },
                    {
                        "username": "Mathesh_2002",
                        "content": "Tips for beginners: If you are using C++ never use pass by value in the comparator lambda function, always use pass by reference or pass by pointers. Else you will encounter TLE"
                    },
                    {
                        "username": "natchyunicorn",
                        "content": "Why I pass only 47/49 testcases??"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Interesting question, even though it gave me a headache and a dozens of wrong answers. You know what I mean right ? No ? I guess its only me LOL. Anyways, here is a TIP.\n\n` TIP `\nI just used a stack and replaced two overlapping balloons with their overlap and treated it as one balloon instead. Honestly, I did a wayyyy better job explaining it here :\n\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\n\nKeep going guys.. We will get there! "
                    },
                    {
                        "username": "iLapras",
                        "content": " `sort(points.begin(), points.end(), [](auto &a, auto&b) {\\n    return a[1] <= b[1];\\n});`\\n\\n `sort(points.begin(), points.end(), [](auto &a, auto&b) {\\n    return a[1] < b[1];\\n});`\\n\\nDoes anybody knows why the bottom code (without equal comparison) gets accepted but the above code gives `runtime error: applying non-zero offset 4 to null pointer`."
                    }
                ]
            },
            {
                "id": 1742930,
                "content": [
                    {
                        "username": "AmreshKrrish",
                        "content": "int findMinArrowShots(vector<vector<int>>& points) {\\n    int n=points.size();\\n        sort(points.begin(),points.end());\\n        int ans=1;\\n        int top = points[0][1];\\n        for(int i=1;i<n;i++){\\n            if(points[i][0]<=top){\\n                top = min(top,points[i][1]);\\n            }\\n            else{\\n                top=points[i][1];\\n                ans++;\\n            }}\\n            return ans;\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "// Intution is to find the Intersection between lines.Modification of Merge Intervals Problem from my prespective\\nint findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        sort(points.begin() , points.end());\\n\\n        stack<pair<int,int>> s;\\n\\n        for(auto p : points){\\n            if(s.empty() or p[0]>s.top().second){\\n                s.push({p[0] , p[1]});\\n            }\\n            else if(p[0]<=s.top().second){\\n                s.top().second=min(p[1] , s.top().second);\\n            }\\n        }\\n        return s.size();\\n    }"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "In C++, if you are writing a comparator yourself, it will have two vectors as parameters like shown below. Here they are passed as reference, but if you pass them as value, your program will fail for some larger test cases due to TLE because if you pass by value compiler will make a copy which will consume time.\\n\\n`static bool compareXEnd(vector<int> &a, vector<int> &b) {\\n        return a[1] < b[1];\\n    }`"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\\n\\nHow the expected output is 2? It doesn\\'t make any sense to me."
                    },
                    {
                        "username": "Mariia_89",
                        "content": "You can sort \\'points\\', it\\'ll be look as: \\n[[0,6],[0,9],[2,8],[2,9],[3,8],[3,9],[3,9],[6,8],[7,12],[9,10]]\\nNext you should to find one of the same part for elements of sorting \\'points\\':\\n[0,6] and [0,9] - it\\'s [0,6]\\n[0,6] and [2,8] - it\\'s [2,6]\\n[2,6] and [2,9] - it\\'s [2,6]\\n[2,6] and [3,8] - it\\'s [3,6]\\n[3,6] and [3,9] - it\\'s [3,6]\\n[3,6] and [3,9] - it\\'s [3,6]\\n[3,6] and [6,8] - it\\'s only [6]\\nThis balloons you can shoot by the one arrow (arrow = 1)\\n\\n[6] and [7,12] - there isn\\'t  any same part between this elements! So you should use one more arrow (arrow = 2). And now you should continue to find one of the same part again:\\n[7,12] and [9,10] - it\\'s [9,10]. This balloons you can also shoot by the one arrow.\\n\\n\\'Points\\' is finished. Output is 2.\\n"
                    },
                    {
                        "username": "user2857Tj",
                        "content": "Adding"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "this question took almost more than 2 hours to solve but at last my solution got submitted "
                    },
                    {
                        "username": "Mathesh_2002",
                        "content": "Tips for beginners: If you are using C++ never use pass by value in the comparator lambda function, always use pass by reference or pass by pointers. Else you will encounter TLE"
                    },
                    {
                        "username": "natchyunicorn",
                        "content": "Why I pass only 47/49 testcases??"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Interesting question, even though it gave me a headache and a dozens of wrong answers. You know what I mean right ? No ? I guess its only me LOL. Anyways, here is a TIP.\n\n` TIP `\nI just used a stack and replaced two overlapping balloons with their overlap and treated it as one balloon instead. Honestly, I did a wayyyy better job explaining it here :\n\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\n\nKeep going guys.. We will get there! "
                    },
                    {
                        "username": "iLapras",
                        "content": " `sort(points.begin(), points.end(), [](auto &a, auto&b) {\\n    return a[1] <= b[1];\\n});`\\n\\n `sort(points.begin(), points.end(), [](auto &a, auto&b) {\\n    return a[1] < b[1];\\n});`\\n\\nDoes anybody knows why the bottom code (without equal comparison) gets accepted but the above code gives `runtime error: applying non-zero offset 4 to null pointer`."
                    }
                ]
            },
            {
                "id": 1742907,
                "content": [
                    {
                        "username": "AmreshKrrish",
                        "content": "int findMinArrowShots(vector<vector<int>>& points) {\\n    int n=points.size();\\n        sort(points.begin(),points.end());\\n        int ans=1;\\n        int top = points[0][1];\\n        for(int i=1;i<n;i++){\\n            if(points[i][0]<=top){\\n                top = min(top,points[i][1]);\\n            }\\n            else{\\n                top=points[i][1];\\n                ans++;\\n            }}\\n            return ans;\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "// Intution is to find the Intersection between lines.Modification of Merge Intervals Problem from my prespective\\nint findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        sort(points.begin() , points.end());\\n\\n        stack<pair<int,int>> s;\\n\\n        for(auto p : points){\\n            if(s.empty() or p[0]>s.top().second){\\n                s.push({p[0] , p[1]});\\n            }\\n            else if(p[0]<=s.top().second){\\n                s.top().second=min(p[1] , s.top().second);\\n            }\\n        }\\n        return s.size();\\n    }"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "In C++, if you are writing a comparator yourself, it will have two vectors as parameters like shown below. Here they are passed as reference, but if you pass them as value, your program will fail for some larger test cases due to TLE because if you pass by value compiler will make a copy which will consume time.\\n\\n`static bool compareXEnd(vector<int> &a, vector<int> &b) {\\n        return a[1] < b[1];\\n    }`"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\\n\\nHow the expected output is 2? It doesn\\'t make any sense to me."
                    },
                    {
                        "username": "Mariia_89",
                        "content": "You can sort \\'points\\', it\\'ll be look as: \\n[[0,6],[0,9],[2,8],[2,9],[3,8],[3,9],[3,9],[6,8],[7,12],[9,10]]\\nNext you should to find one of the same part for elements of sorting \\'points\\':\\n[0,6] and [0,9] - it\\'s [0,6]\\n[0,6] and [2,8] - it\\'s [2,6]\\n[2,6] and [2,9] - it\\'s [2,6]\\n[2,6] and [3,8] - it\\'s [3,6]\\n[3,6] and [3,9] - it\\'s [3,6]\\n[3,6] and [3,9] - it\\'s [3,6]\\n[3,6] and [6,8] - it\\'s only [6]\\nThis balloons you can shoot by the one arrow (arrow = 1)\\n\\n[6] and [7,12] - there isn\\'t  any same part between this elements! So you should use one more arrow (arrow = 2). And now you should continue to find one of the same part again:\\n[7,12] and [9,10] - it\\'s [9,10]. This balloons you can also shoot by the one arrow.\\n\\n\\'Points\\' is finished. Output is 2.\\n"
                    },
                    {
                        "username": "user2857Tj",
                        "content": "Adding"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "this question took almost more than 2 hours to solve but at last my solution got submitted "
                    },
                    {
                        "username": "Mathesh_2002",
                        "content": "Tips for beginners: If you are using C++ never use pass by value in the comparator lambda function, always use pass by reference or pass by pointers. Else you will encounter TLE"
                    },
                    {
                        "username": "natchyunicorn",
                        "content": "Why I pass only 47/49 testcases??"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Interesting question, even though it gave me a headache and a dozens of wrong answers. You know what I mean right ? No ? I guess its only me LOL. Anyways, here is a TIP.\n\n` TIP `\nI just used a stack and replaced two overlapping balloons with their overlap and treated it as one balloon instead. Honestly, I did a wayyyy better job explaining it here :\n\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\n\nKeep going guys.. We will get there! "
                    },
                    {
                        "username": "iLapras",
                        "content": " `sort(points.begin(), points.end(), [](auto &a, auto&b) {\\n    return a[1] <= b[1];\\n});`\\n\\n `sort(points.begin(), points.end(), [](auto &a, auto&b) {\\n    return a[1] < b[1];\\n});`\\n\\nDoes anybody knows why the bottom code (without equal comparison) gets accepted but the above code gives `runtime error: applying non-zero offset 4 to null pointer`."
                    }
                ]
            },
            {
                "id": 1742905,
                "content": [
                    {
                        "username": "AmreshKrrish",
                        "content": "int findMinArrowShots(vector<vector<int>>& points) {\\n    int n=points.size();\\n        sort(points.begin(),points.end());\\n        int ans=1;\\n        int top = points[0][1];\\n        for(int i=1;i<n;i++){\\n            if(points[i][0]<=top){\\n                top = min(top,points[i][1]);\\n            }\\n            else{\\n                top=points[i][1];\\n                ans++;\\n            }}\\n            return ans;\\n        }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "// Intution is to find the Intersection between lines.Modification of Merge Intervals Problem from my prespective\\nint findMinArrowShots(vector<vector<int>>& points) {\\n        \\n        sort(points.begin() , points.end());\\n\\n        stack<pair<int,int>> s;\\n\\n        for(auto p : points){\\n            if(s.empty() or p[0]>s.top().second){\\n                s.push({p[0] , p[1]});\\n            }\\n            else if(p[0]<=s.top().second){\\n                s.top().second=min(p[1] , s.top().second);\\n            }\\n        }\\n        return s.size();\\n    }"
                    },
                    {
                        "username": "nikhilsteamid",
                        "content": "In C++, if you are writing a comparator yourself, it will have two vectors as parameters like shown below. Here they are passed as reference, but if you pass them as value, your program will fail for some larger test cases due to TLE because if you pass by value compiler will make a copy which will consume time.\\n\\n`static bool compareXEnd(vector<int> &a, vector<int> &b) {\\n        return a[1] < b[1];\\n    }`"
                    },
                    {
                        "username": "neopraveen",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\\n\\nHow the expected output is 2? It doesn\\'t make any sense to me."
                    },
                    {
                        "username": "Mariia_89",
                        "content": "You can sort \\'points\\', it\\'ll be look as: \\n[[0,6],[0,9],[2,8],[2,9],[3,8],[3,9],[3,9],[6,8],[7,12],[9,10]]\\nNext you should to find one of the same part for elements of sorting \\'points\\':\\n[0,6] and [0,9] - it\\'s [0,6]\\n[0,6] and [2,8] - it\\'s [2,6]\\n[2,6] and [2,9] - it\\'s [2,6]\\n[2,6] and [3,8] - it\\'s [3,6]\\n[3,6] and [3,9] - it\\'s [3,6]\\n[3,6] and [3,9] - it\\'s [3,6]\\n[3,6] and [6,8] - it\\'s only [6]\\nThis balloons you can shoot by the one arrow (arrow = 1)\\n\\n[6] and [7,12] - there isn\\'t  any same part between this elements! So you should use one more arrow (arrow = 2). And now you should continue to find one of the same part again:\\n[7,12] and [9,10] - it\\'s [9,10]. This balloons you can also shoot by the one arrow.\\n\\n\\'Points\\' is finished. Output is 2.\\n"
                    },
                    {
                        "username": "user2857Tj",
                        "content": "Adding"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "this question took almost more than 2 hours to solve but at last my solution got submitted "
                    },
                    {
                        "username": "Mathesh_2002",
                        "content": "Tips for beginners: If you are using C++ never use pass by value in the comparator lambda function, always use pass by reference or pass by pointers. Else you will encounter TLE"
                    },
                    {
                        "username": "natchyunicorn",
                        "content": "Why I pass only 47/49 testcases??"
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "Interesting question, even though it gave me a headache and a dozens of wrong answers. You know what I mean right ? No ? I guess its only me LOL. Anyways, here is a TIP.\n\n` TIP `\nI just used a stack and replaced two overlapping balloons with their overlap and treated it as one balloon instead. Honestly, I did a wayyyy better job explaining it here :\n\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001279/well-explained-w-images-sorting-stack/?orderBy=most_votes\n\nKeep going guys.. We will get there! "
                    },
                    {
                        "username": "iLapras",
                        "content": " `sort(points.begin(), points.end(), [](auto &a, auto&b) {\\n    return a[1] <= b[1];\\n});`\\n\\n `sort(points.begin(), points.end(), [](auto &a, auto&b) {\\n    return a[1] < b[1];\\n});`\\n\\nDoes anybody knows why the bottom code (without equal comparison) gets accepted but the above code gives `runtime error: applying non-zero offset 4 to null pointer`."
                    }
                ]
            },
            {
                "id": 1742866,
                "content": [
                    {
                        "username": "dhirenks",
                        "content": "46/49 Test Cases Passed \\nTime Limit Exceeded coming \\n    \\nstatic bool sortcol(const vector<int> v1, const vector<int> v2)\\n    {\\n        return v1[1] < v2[1];\\n    }\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n         \\n        sort(points.begin(),points.end(),sortcol);\\n        int arrow=1;\\n        int last = points[0][1];\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]<=last)\\n                continue;\\n            else{\\n                last=points[i+1][1];\\n                arrow++;\\n            }\\n        }\\n        return arrow;\\n        }\\n\\n    "
                    },
                    {
                        "username": "jay3_chauhan",
                        "content": " `your inline code...\\n from typing import List\\n\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key = lambda x:x[1], reverse=True)\\n        left, right, arrowCount = points[0][0], points[0][1], 1\\n        for point in points[1:]:\\n            left = max(left, point[0])\\n            right = min(right, point[1])\\n            if left > right :\\n                left, right = point[0], point[1]\\n                arrowCount+=1\\n        return arrowCount\\n\\n\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you really think it is a tip?\\nLooks like spoiler, bro."
                    },
                    {
                        "username": "heenahmed08",
                        "content": "1. Arrays.sort(points, (a,b) -> Integer.compare(a[1] , b[1])); \n2. Arrays.sort(points, (a,b) -> a[1] - b[1]);\n\nwhy the above 1 works, but not the 2 statement ?"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Arrays.sort(points, (a, b) -> (a[1] - b[1])); will not work only in the case when a[1]-b[1] will exceed the Integer.MAX_VALUE or Integer.MIN_VALUE limit. In any other case the code is correct.\n\nCopied from discussion post"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "For those people who return a-b in sorting and get error in this\\n[[-2147483646,-2147483645],[2147483646,2147483647]] testcase.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three condition explicitly. (a>b  and a<b and a==b)\\nBut yah for making short and neat code you should use either Integer.compare(a,b) or lamda function.\\n//code\\nArrays.sort(arr,new Comparator<int[]>(){\\npublic int compare(int[] a1,int[] a2){\\n// return Integer.compare(a1[0],a2[0]);\\nif(a1[0]>a2[0]) return 1;\\nelse if(a1[0]<a2[0]) return -1;\\nelse return 0;\\n}\\n});"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please Watch Video for Easiest explanation \\nhttps://youtu.be/XUFdxnLRB6A"
                    },
                    {
                        "username": "user0630p",
                        "content": "The trick is to build an Interval Tree"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Another simple one guess just sort the ends and check for merging and non-merging ends. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "hello guys how to think about test cases of problem ,I solved this but after 3rd submission "
                    },
                    {
                        "username": "abhishekvallecha20",
                        "content": "Here we go again"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int findMinArrowShots(int[][] p) {\\n  Arrays.sort(p, (a, b) -> Integer.compare(a[1], b[1]));\\n        int c=1;\\n        int n=p.length;\\n        int j=0;\\n        for(int i=0;i<n;i++){\\n            if(p[j][1]>=p[i][0]){\\n                // i++;\\n                continue;\\n            }\\n            else{\\n                j=i;\\n    c++;}\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    }
                ]
            },
            {
                "id": 1742846,
                "content": [
                    {
                        "username": "dhirenks",
                        "content": "46/49 Test Cases Passed \\nTime Limit Exceeded coming \\n    \\nstatic bool sortcol(const vector<int> v1, const vector<int> v2)\\n    {\\n        return v1[1] < v2[1];\\n    }\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n         \\n        sort(points.begin(),points.end(),sortcol);\\n        int arrow=1;\\n        int last = points[0][1];\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]<=last)\\n                continue;\\n            else{\\n                last=points[i+1][1];\\n                arrow++;\\n            }\\n        }\\n        return arrow;\\n        }\\n\\n    "
                    },
                    {
                        "username": "jay3_chauhan",
                        "content": " `your inline code...\\n from typing import List\\n\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key = lambda x:x[1], reverse=True)\\n        left, right, arrowCount = points[0][0], points[0][1], 1\\n        for point in points[1:]:\\n            left = max(left, point[0])\\n            right = min(right, point[1])\\n            if left > right :\\n                left, right = point[0], point[1]\\n                arrowCount+=1\\n        return arrowCount\\n\\n\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you really think it is a tip?\\nLooks like spoiler, bro."
                    },
                    {
                        "username": "heenahmed08",
                        "content": "1. Arrays.sort(points, (a,b) -> Integer.compare(a[1] , b[1])); \n2. Arrays.sort(points, (a,b) -> a[1] - b[1]);\n\nwhy the above 1 works, but not the 2 statement ?"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Arrays.sort(points, (a, b) -> (a[1] - b[1])); will not work only in the case when a[1]-b[1] will exceed the Integer.MAX_VALUE or Integer.MIN_VALUE limit. In any other case the code is correct.\n\nCopied from discussion post"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "For those people who return a-b in sorting and get error in this\\n[[-2147483646,-2147483645],[2147483646,2147483647]] testcase.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three condition explicitly. (a>b  and a<b and a==b)\\nBut yah for making short and neat code you should use either Integer.compare(a,b) or lamda function.\\n//code\\nArrays.sort(arr,new Comparator<int[]>(){\\npublic int compare(int[] a1,int[] a2){\\n// return Integer.compare(a1[0],a2[0]);\\nif(a1[0]>a2[0]) return 1;\\nelse if(a1[0]<a2[0]) return -1;\\nelse return 0;\\n}\\n});"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please Watch Video for Easiest explanation \\nhttps://youtu.be/XUFdxnLRB6A"
                    },
                    {
                        "username": "user0630p",
                        "content": "The trick is to build an Interval Tree"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Another simple one guess just sort the ends and check for merging and non-merging ends. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "hello guys how to think about test cases of problem ,I solved this but after 3rd submission "
                    },
                    {
                        "username": "abhishekvallecha20",
                        "content": "Here we go again"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int findMinArrowShots(int[][] p) {\\n  Arrays.sort(p, (a, b) -> Integer.compare(a[1], b[1]));\\n        int c=1;\\n        int n=p.length;\\n        int j=0;\\n        for(int i=0;i<n;i++){\\n            if(p[j][1]>=p[i][0]){\\n                // i++;\\n                continue;\\n            }\\n            else{\\n                j=i;\\n    c++;}\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    }
                ]
            },
            {
                "id": 1742753,
                "content": [
                    {
                        "username": "dhirenks",
                        "content": "46/49 Test Cases Passed \\nTime Limit Exceeded coming \\n    \\nstatic bool sortcol(const vector<int> v1, const vector<int> v2)\\n    {\\n        return v1[1] < v2[1];\\n    }\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n         \\n        sort(points.begin(),points.end(),sortcol);\\n        int arrow=1;\\n        int last = points[0][1];\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]<=last)\\n                continue;\\n            else{\\n                last=points[i+1][1];\\n                arrow++;\\n            }\\n        }\\n        return arrow;\\n        }\\n\\n    "
                    },
                    {
                        "username": "jay3_chauhan",
                        "content": " `your inline code...\\n from typing import List\\n\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key = lambda x:x[1], reverse=True)\\n        left, right, arrowCount = points[0][0], points[0][1], 1\\n        for point in points[1:]:\\n            left = max(left, point[0])\\n            right = min(right, point[1])\\n            if left > right :\\n                left, right = point[0], point[1]\\n                arrowCount+=1\\n        return arrowCount\\n\\n\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you really think it is a tip?\\nLooks like spoiler, bro."
                    },
                    {
                        "username": "heenahmed08",
                        "content": "1. Arrays.sort(points, (a,b) -> Integer.compare(a[1] , b[1])); \n2. Arrays.sort(points, (a,b) -> a[1] - b[1]);\n\nwhy the above 1 works, but not the 2 statement ?"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Arrays.sort(points, (a, b) -> (a[1] - b[1])); will not work only in the case when a[1]-b[1] will exceed the Integer.MAX_VALUE or Integer.MIN_VALUE limit. In any other case the code is correct.\n\nCopied from discussion post"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "For those people who return a-b in sorting and get error in this\\n[[-2147483646,-2147483645],[2147483646,2147483647]] testcase.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three condition explicitly. (a>b  and a<b and a==b)\\nBut yah for making short and neat code you should use either Integer.compare(a,b) or lamda function.\\n//code\\nArrays.sort(arr,new Comparator<int[]>(){\\npublic int compare(int[] a1,int[] a2){\\n// return Integer.compare(a1[0],a2[0]);\\nif(a1[0]>a2[0]) return 1;\\nelse if(a1[0]<a2[0]) return -1;\\nelse return 0;\\n}\\n});"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please Watch Video for Easiest explanation \\nhttps://youtu.be/XUFdxnLRB6A"
                    },
                    {
                        "username": "user0630p",
                        "content": "The trick is to build an Interval Tree"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Another simple one guess just sort the ends and check for merging and non-merging ends. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "hello guys how to think about test cases of problem ,I solved this but after 3rd submission "
                    },
                    {
                        "username": "abhishekvallecha20",
                        "content": "Here we go again"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int findMinArrowShots(int[][] p) {\\n  Arrays.sort(p, (a, b) -> Integer.compare(a[1], b[1]));\\n        int c=1;\\n        int n=p.length;\\n        int j=0;\\n        for(int i=0;i<n;i++){\\n            if(p[j][1]>=p[i][0]){\\n                // i++;\\n                continue;\\n            }\\n            else{\\n                j=i;\\n    c++;}\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    }
                ]
            },
            {
                "id": 1742747,
                "content": [
                    {
                        "username": "dhirenks",
                        "content": "46/49 Test Cases Passed \\nTime Limit Exceeded coming \\n    \\nstatic bool sortcol(const vector<int> v1, const vector<int> v2)\\n    {\\n        return v1[1] < v2[1];\\n    }\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n         \\n        sort(points.begin(),points.end(),sortcol);\\n        int arrow=1;\\n        int last = points[0][1];\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]<=last)\\n                continue;\\n            else{\\n                last=points[i+1][1];\\n                arrow++;\\n            }\\n        }\\n        return arrow;\\n        }\\n\\n    "
                    },
                    {
                        "username": "jay3_chauhan",
                        "content": " `your inline code...\\n from typing import List\\n\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key = lambda x:x[1], reverse=True)\\n        left, right, arrowCount = points[0][0], points[0][1], 1\\n        for point in points[1:]:\\n            left = max(left, point[0])\\n            right = min(right, point[1])\\n            if left > right :\\n                left, right = point[0], point[1]\\n                arrowCount+=1\\n        return arrowCount\\n\\n\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you really think it is a tip?\\nLooks like spoiler, bro."
                    },
                    {
                        "username": "heenahmed08",
                        "content": "1. Arrays.sort(points, (a,b) -> Integer.compare(a[1] , b[1])); \n2. Arrays.sort(points, (a,b) -> a[1] - b[1]);\n\nwhy the above 1 works, but not the 2 statement ?"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Arrays.sort(points, (a, b) -> (a[1] - b[1])); will not work only in the case when a[1]-b[1] will exceed the Integer.MAX_VALUE or Integer.MIN_VALUE limit. In any other case the code is correct.\n\nCopied from discussion post"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "For those people who return a-b in sorting and get error in this\\n[[-2147483646,-2147483645],[2147483646,2147483647]] testcase.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three condition explicitly. (a>b  and a<b and a==b)\\nBut yah for making short and neat code you should use either Integer.compare(a,b) or lamda function.\\n//code\\nArrays.sort(arr,new Comparator<int[]>(){\\npublic int compare(int[] a1,int[] a2){\\n// return Integer.compare(a1[0],a2[0]);\\nif(a1[0]>a2[0]) return 1;\\nelse if(a1[0]<a2[0]) return -1;\\nelse return 0;\\n}\\n});"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please Watch Video for Easiest explanation \\nhttps://youtu.be/XUFdxnLRB6A"
                    },
                    {
                        "username": "user0630p",
                        "content": "The trick is to build an Interval Tree"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Another simple one guess just sort the ends and check for merging and non-merging ends. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "hello guys how to think about test cases of problem ,I solved this but after 3rd submission "
                    },
                    {
                        "username": "abhishekvallecha20",
                        "content": "Here we go again"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int findMinArrowShots(int[][] p) {\\n  Arrays.sort(p, (a, b) -> Integer.compare(a[1], b[1]));\\n        int c=1;\\n        int n=p.length;\\n        int j=0;\\n        for(int i=0;i<n;i++){\\n            if(p[j][1]>=p[i][0]){\\n                // i++;\\n                continue;\\n            }\\n            else{\\n                j=i;\\n    c++;}\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    }
                ]
            },
            {
                "id": 1742673,
                "content": [
                    {
                        "username": "dhirenks",
                        "content": "46/49 Test Cases Passed \\nTime Limit Exceeded coming \\n    \\nstatic bool sortcol(const vector<int> v1, const vector<int> v2)\\n    {\\n        return v1[1] < v2[1];\\n    }\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n         \\n        sort(points.begin(),points.end(),sortcol);\\n        int arrow=1;\\n        int last = points[0][1];\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]<=last)\\n                continue;\\n            else{\\n                last=points[i+1][1];\\n                arrow++;\\n            }\\n        }\\n        return arrow;\\n        }\\n\\n    "
                    },
                    {
                        "username": "jay3_chauhan",
                        "content": " `your inline code...\\n from typing import List\\n\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key = lambda x:x[1], reverse=True)\\n        left, right, arrowCount = points[0][0], points[0][1], 1\\n        for point in points[1:]:\\n            left = max(left, point[0])\\n            right = min(right, point[1])\\n            if left > right :\\n                left, right = point[0], point[1]\\n                arrowCount+=1\\n        return arrowCount\\n\\n\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you really think it is a tip?\\nLooks like spoiler, bro."
                    },
                    {
                        "username": "heenahmed08",
                        "content": "1. Arrays.sort(points, (a,b) -> Integer.compare(a[1] , b[1])); \n2. Arrays.sort(points, (a,b) -> a[1] - b[1]);\n\nwhy the above 1 works, but not the 2 statement ?"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Arrays.sort(points, (a, b) -> (a[1] - b[1])); will not work only in the case when a[1]-b[1] will exceed the Integer.MAX_VALUE or Integer.MIN_VALUE limit. In any other case the code is correct.\n\nCopied from discussion post"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "For those people who return a-b in sorting and get error in this\\n[[-2147483646,-2147483645],[2147483646,2147483647]] testcase.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three condition explicitly. (a>b  and a<b and a==b)\\nBut yah for making short and neat code you should use either Integer.compare(a,b) or lamda function.\\n//code\\nArrays.sort(arr,new Comparator<int[]>(){\\npublic int compare(int[] a1,int[] a2){\\n// return Integer.compare(a1[0],a2[0]);\\nif(a1[0]>a2[0]) return 1;\\nelse if(a1[0]<a2[0]) return -1;\\nelse return 0;\\n}\\n});"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please Watch Video for Easiest explanation \\nhttps://youtu.be/XUFdxnLRB6A"
                    },
                    {
                        "username": "user0630p",
                        "content": "The trick is to build an Interval Tree"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Another simple one guess just sort the ends and check for merging and non-merging ends. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "hello guys how to think about test cases of problem ,I solved this but after 3rd submission "
                    },
                    {
                        "username": "abhishekvallecha20",
                        "content": "Here we go again"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int findMinArrowShots(int[][] p) {\\n  Arrays.sort(p, (a, b) -> Integer.compare(a[1], b[1]));\\n        int c=1;\\n        int n=p.length;\\n        int j=0;\\n        for(int i=0;i<n;i++){\\n            if(p[j][1]>=p[i][0]){\\n                // i++;\\n                continue;\\n            }\\n            else{\\n                j=i;\\n    c++;}\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    }
                ]
            },
            {
                "id": 1742664,
                "content": [
                    {
                        "username": "dhirenks",
                        "content": "46/49 Test Cases Passed \\nTime Limit Exceeded coming \\n    \\nstatic bool sortcol(const vector<int> v1, const vector<int> v2)\\n    {\\n        return v1[1] < v2[1];\\n    }\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n         \\n        sort(points.begin(),points.end(),sortcol);\\n        int arrow=1;\\n        int last = points[0][1];\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]<=last)\\n                continue;\\n            else{\\n                last=points[i+1][1];\\n                arrow++;\\n            }\\n        }\\n        return arrow;\\n        }\\n\\n    "
                    },
                    {
                        "username": "jay3_chauhan",
                        "content": " `your inline code...\\n from typing import List\\n\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key = lambda x:x[1], reverse=True)\\n        left, right, arrowCount = points[0][0], points[0][1], 1\\n        for point in points[1:]:\\n            left = max(left, point[0])\\n            right = min(right, point[1])\\n            if left > right :\\n                left, right = point[0], point[1]\\n                arrowCount+=1\\n        return arrowCount\\n\\n\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you really think it is a tip?\\nLooks like spoiler, bro."
                    },
                    {
                        "username": "heenahmed08",
                        "content": "1. Arrays.sort(points, (a,b) -> Integer.compare(a[1] , b[1])); \n2. Arrays.sort(points, (a,b) -> a[1] - b[1]);\n\nwhy the above 1 works, but not the 2 statement ?"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Arrays.sort(points, (a, b) -> (a[1] - b[1])); will not work only in the case when a[1]-b[1] will exceed the Integer.MAX_VALUE or Integer.MIN_VALUE limit. In any other case the code is correct.\n\nCopied from discussion post"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "For those people who return a-b in sorting and get error in this\\n[[-2147483646,-2147483645],[2147483646,2147483647]] testcase.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three condition explicitly. (a>b  and a<b and a==b)\\nBut yah for making short and neat code you should use either Integer.compare(a,b) or lamda function.\\n//code\\nArrays.sort(arr,new Comparator<int[]>(){\\npublic int compare(int[] a1,int[] a2){\\n// return Integer.compare(a1[0],a2[0]);\\nif(a1[0]>a2[0]) return 1;\\nelse if(a1[0]<a2[0]) return -1;\\nelse return 0;\\n}\\n});"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please Watch Video for Easiest explanation \\nhttps://youtu.be/XUFdxnLRB6A"
                    },
                    {
                        "username": "user0630p",
                        "content": "The trick is to build an Interval Tree"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Another simple one guess just sort the ends and check for merging and non-merging ends. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "hello guys how to think about test cases of problem ,I solved this but after 3rd submission "
                    },
                    {
                        "username": "abhishekvallecha20",
                        "content": "Here we go again"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int findMinArrowShots(int[][] p) {\\n  Arrays.sort(p, (a, b) -> Integer.compare(a[1], b[1]));\\n        int c=1;\\n        int n=p.length;\\n        int j=0;\\n        for(int i=0;i<n;i++){\\n            if(p[j][1]>=p[i][0]){\\n                // i++;\\n                continue;\\n            }\\n            else{\\n                j=i;\\n    c++;}\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    }
                ]
            },
            {
                "id": 1742628,
                "content": [
                    {
                        "username": "dhirenks",
                        "content": "46/49 Test Cases Passed \\nTime Limit Exceeded coming \\n    \\nstatic bool sortcol(const vector<int> v1, const vector<int> v2)\\n    {\\n        return v1[1] < v2[1];\\n    }\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n         \\n        sort(points.begin(),points.end(),sortcol);\\n        int arrow=1;\\n        int last = points[0][1];\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]<=last)\\n                continue;\\n            else{\\n                last=points[i+1][1];\\n                arrow++;\\n            }\\n        }\\n        return arrow;\\n        }\\n\\n    "
                    },
                    {
                        "username": "jay3_chauhan",
                        "content": " `your inline code...\\n from typing import List\\n\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key = lambda x:x[1], reverse=True)\\n        left, right, arrowCount = points[0][0], points[0][1], 1\\n        for point in points[1:]:\\n            left = max(left, point[0])\\n            right = min(right, point[1])\\n            if left > right :\\n                left, right = point[0], point[1]\\n                arrowCount+=1\\n        return arrowCount\\n\\n\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you really think it is a tip?\\nLooks like spoiler, bro."
                    },
                    {
                        "username": "heenahmed08",
                        "content": "1. Arrays.sort(points, (a,b) -> Integer.compare(a[1] , b[1])); \n2. Arrays.sort(points, (a,b) -> a[1] - b[1]);\n\nwhy the above 1 works, but not the 2 statement ?"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Arrays.sort(points, (a, b) -> (a[1] - b[1])); will not work only in the case when a[1]-b[1] will exceed the Integer.MAX_VALUE or Integer.MIN_VALUE limit. In any other case the code is correct.\n\nCopied from discussion post"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "For those people who return a-b in sorting and get error in this\\n[[-2147483646,-2147483645],[2147483646,2147483647]] testcase.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three condition explicitly. (a>b  and a<b and a==b)\\nBut yah for making short and neat code you should use either Integer.compare(a,b) or lamda function.\\n//code\\nArrays.sort(arr,new Comparator<int[]>(){\\npublic int compare(int[] a1,int[] a2){\\n// return Integer.compare(a1[0],a2[0]);\\nif(a1[0]>a2[0]) return 1;\\nelse if(a1[0]<a2[0]) return -1;\\nelse return 0;\\n}\\n});"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please Watch Video for Easiest explanation \\nhttps://youtu.be/XUFdxnLRB6A"
                    },
                    {
                        "username": "user0630p",
                        "content": "The trick is to build an Interval Tree"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Another simple one guess just sort the ends and check for merging and non-merging ends. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "hello guys how to think about test cases of problem ,I solved this but after 3rd submission "
                    },
                    {
                        "username": "abhishekvallecha20",
                        "content": "Here we go again"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int findMinArrowShots(int[][] p) {\\n  Arrays.sort(p, (a, b) -> Integer.compare(a[1], b[1]));\\n        int c=1;\\n        int n=p.length;\\n        int j=0;\\n        for(int i=0;i<n;i++){\\n            if(p[j][1]>=p[i][0]){\\n                // i++;\\n                continue;\\n            }\\n            else{\\n                j=i;\\n    c++;}\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    }
                ]
            },
            {
                "id": 1742614,
                "content": [
                    {
                        "username": "dhirenks",
                        "content": "46/49 Test Cases Passed \\nTime Limit Exceeded coming \\n    \\nstatic bool sortcol(const vector<int> v1, const vector<int> v2)\\n    {\\n        return v1[1] < v2[1];\\n    }\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n         \\n        sort(points.begin(),points.end(),sortcol);\\n        int arrow=1;\\n        int last = points[0][1];\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]<=last)\\n                continue;\\n            else{\\n                last=points[i+1][1];\\n                arrow++;\\n            }\\n        }\\n        return arrow;\\n        }\\n\\n    "
                    },
                    {
                        "username": "jay3_chauhan",
                        "content": " `your inline code...\\n from typing import List\\n\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key = lambda x:x[1], reverse=True)\\n        left, right, arrowCount = points[0][0], points[0][1], 1\\n        for point in points[1:]:\\n            left = max(left, point[0])\\n            right = min(right, point[1])\\n            if left > right :\\n                left, right = point[0], point[1]\\n                arrowCount+=1\\n        return arrowCount\\n\\n\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you really think it is a tip?\\nLooks like spoiler, bro."
                    },
                    {
                        "username": "heenahmed08",
                        "content": "1. Arrays.sort(points, (a,b) -> Integer.compare(a[1] , b[1])); \n2. Arrays.sort(points, (a,b) -> a[1] - b[1]);\n\nwhy the above 1 works, but not the 2 statement ?"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Arrays.sort(points, (a, b) -> (a[1] - b[1])); will not work only in the case when a[1]-b[1] will exceed the Integer.MAX_VALUE or Integer.MIN_VALUE limit. In any other case the code is correct.\n\nCopied from discussion post"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "For those people who return a-b in sorting and get error in this\\n[[-2147483646,-2147483645],[2147483646,2147483647]] testcase.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three condition explicitly. (a>b  and a<b and a==b)\\nBut yah for making short and neat code you should use either Integer.compare(a,b) or lamda function.\\n//code\\nArrays.sort(arr,new Comparator<int[]>(){\\npublic int compare(int[] a1,int[] a2){\\n// return Integer.compare(a1[0],a2[0]);\\nif(a1[0]>a2[0]) return 1;\\nelse if(a1[0]<a2[0]) return -1;\\nelse return 0;\\n}\\n});"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please Watch Video for Easiest explanation \\nhttps://youtu.be/XUFdxnLRB6A"
                    },
                    {
                        "username": "user0630p",
                        "content": "The trick is to build an Interval Tree"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Another simple one guess just sort the ends and check for merging and non-merging ends. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "hello guys how to think about test cases of problem ,I solved this but after 3rd submission "
                    },
                    {
                        "username": "abhishekvallecha20",
                        "content": "Here we go again"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int findMinArrowShots(int[][] p) {\\n  Arrays.sort(p, (a, b) -> Integer.compare(a[1], b[1]));\\n        int c=1;\\n        int n=p.length;\\n        int j=0;\\n        for(int i=0;i<n;i++){\\n            if(p[j][1]>=p[i][0]){\\n                // i++;\\n                continue;\\n            }\\n            else{\\n                j=i;\\n    c++;}\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    }
                ]
            },
            {
                "id": 1742604,
                "content": [
                    {
                        "username": "dhirenks",
                        "content": "46/49 Test Cases Passed \\nTime Limit Exceeded coming \\n    \\nstatic bool sortcol(const vector<int> v1, const vector<int> v2)\\n    {\\n        return v1[1] < v2[1];\\n    }\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n         \\n        sort(points.begin(),points.end(),sortcol);\\n        int arrow=1;\\n        int last = points[0][1];\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]<=last)\\n                continue;\\n            else{\\n                last=points[i+1][1];\\n                arrow++;\\n            }\\n        }\\n        return arrow;\\n        }\\n\\n    "
                    },
                    {
                        "username": "jay3_chauhan",
                        "content": " `your inline code...\\n from typing import List\\n\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key = lambda x:x[1], reverse=True)\\n        left, right, arrowCount = points[0][0], points[0][1], 1\\n        for point in points[1:]:\\n            left = max(left, point[0])\\n            right = min(right, point[1])\\n            if left > right :\\n                left, right = point[0], point[1]\\n                arrowCount+=1\\n        return arrowCount\\n\\n\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you really think it is a tip?\\nLooks like spoiler, bro."
                    },
                    {
                        "username": "heenahmed08",
                        "content": "1. Arrays.sort(points, (a,b) -> Integer.compare(a[1] , b[1])); \n2. Arrays.sort(points, (a,b) -> a[1] - b[1]);\n\nwhy the above 1 works, but not the 2 statement ?"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Arrays.sort(points, (a, b) -> (a[1] - b[1])); will not work only in the case when a[1]-b[1] will exceed the Integer.MAX_VALUE or Integer.MIN_VALUE limit. In any other case the code is correct.\n\nCopied from discussion post"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "For those people who return a-b in sorting and get error in this\\n[[-2147483646,-2147483645],[2147483646,2147483647]] testcase.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three condition explicitly. (a>b  and a<b and a==b)\\nBut yah for making short and neat code you should use either Integer.compare(a,b) or lamda function.\\n//code\\nArrays.sort(arr,new Comparator<int[]>(){\\npublic int compare(int[] a1,int[] a2){\\n// return Integer.compare(a1[0],a2[0]);\\nif(a1[0]>a2[0]) return 1;\\nelse if(a1[0]<a2[0]) return -1;\\nelse return 0;\\n}\\n});"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please Watch Video for Easiest explanation \\nhttps://youtu.be/XUFdxnLRB6A"
                    },
                    {
                        "username": "user0630p",
                        "content": "The trick is to build an Interval Tree"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Another simple one guess just sort the ends and check for merging and non-merging ends. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "hello guys how to think about test cases of problem ,I solved this but after 3rd submission "
                    },
                    {
                        "username": "abhishekvallecha20",
                        "content": "Here we go again"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int findMinArrowShots(int[][] p) {\\n  Arrays.sort(p, (a, b) -> Integer.compare(a[1], b[1]));\\n        int c=1;\\n        int n=p.length;\\n        int j=0;\\n        for(int i=0;i<n;i++){\\n            if(p[j][1]>=p[i][0]){\\n                // i++;\\n                continue;\\n            }\\n            else{\\n                j=i;\\n    c++;}\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    }
                ]
            },
            {
                "id": 1742574,
                "content": [
                    {
                        "username": "dhirenks",
                        "content": "46/49 Test Cases Passed \\nTime Limit Exceeded coming \\n    \\nstatic bool sortcol(const vector<int> v1, const vector<int> v2)\\n    {\\n        return v1[1] < v2[1];\\n    }\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n         \\n        sort(points.begin(),points.end(),sortcol);\\n        int arrow=1;\\n        int last = points[0][1];\\n        for(int i=0;i<points.size()-1;i++)\\n        {\\n            if(points[i+1][0]<=last)\\n                continue;\\n            else{\\n                last=points[i+1][1];\\n                arrow++;\\n            }\\n        }\\n        return arrow;\\n        }\\n\\n    "
                    },
                    {
                        "username": "jay3_chauhan",
                        "content": " `your inline code...\\n from typing import List\\n\\nclass Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key = lambda x:x[1], reverse=True)\\n        left, right, arrowCount = points[0][0], points[0][1], 1\\n        for point in points[1:]:\\n            left = max(left, point[0])\\n            right = min(right, point[1])\\n            if left > right :\\n                left, right = point[0], point[1]\\n                arrowCount+=1\\n        return arrowCount\\n\\n\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Do you really think it is a tip?\\nLooks like spoiler, bro."
                    },
                    {
                        "username": "heenahmed08",
                        "content": "1. Arrays.sort(points, (a,b) -> Integer.compare(a[1] , b[1])); \n2. Arrays.sort(points, (a,b) -> a[1] - b[1]);\n\nwhy the above 1 works, but not the 2 statement ?"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Arrays.sort(points, (a, b) -> (a[1] - b[1])); will not work only in the case when a[1]-b[1] will exceed the Integer.MAX_VALUE or Integer.MIN_VALUE limit. In any other case the code is correct.\n\nCopied from discussion post"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "For those people who return a-b in sorting and get error in this\\n[[-2147483646,-2147483645],[2147483646,2147483647]] testcase.\\nI guess you were merging the condition of equality with \" less than or greater than sign\". you have to write condition for all three condition explicitly. (a>b  and a<b and a==b)\\nBut yah for making short and neat code you should use either Integer.compare(a,b) or lamda function.\\n//code\\nArrays.sort(arr,new Comparator<int[]>(){\\npublic int compare(int[] a1,int[] a2){\\n// return Integer.compare(a1[0],a2[0]);\\nif(a1[0]>a2[0]) return 1;\\nelse if(a1[0]<a2[0]) return -1;\\nelse return 0;\\n}\\n});"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please Watch Video for Easiest explanation \\nhttps://youtu.be/XUFdxnLRB6A"
                    },
                    {
                        "username": "user0630p",
                        "content": "The trick is to build an Interval Tree"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Another simple one guess just sort the ends and check for merging and non-merging ends. "
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "hello guys how to think about test cases of problem ,I solved this but after 3rd submission "
                    },
                    {
                        "username": "abhishekvallecha20",
                        "content": "Here we go again"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int findMinArrowShots(int[][] p) {\\n  Arrays.sort(p, (a, b) -> Integer.compare(a[1], b[1]));\\n        int c=1;\\n        int n=p.length;\\n        int j=0;\\n        for(int i=0;i<n;i++){\\n            if(p[j][1]>=p[i][0]){\\n                // i++;\\n                continue;\\n            }\\n            else{\\n                j=i;\\n    c++;}\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    }
                ]
            },
            {
                "id": 1742552,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Can we use Merge Intervals algo with some twist here?"
                    },
                    {
                        "username": "no-username",
                        "content": "Similar to finding total overlaps between intervals. This is fancy way of asking with balloons example."
                    },
                    {
                        "username": "professor_alok",
                        "content": "c++\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        int a=1;  //a=arrow\\n        int l = points[0][1]; // l= last point\\n        sort(points.begin(),points.end());\\n        for(int i=0;i<points.size();i++)\\n        {\\n            if(points[i][0]>l)\\n            {\\n                a++;\\n                l = points[i][1];\\n            }\\n            else l = min(l, points[i][1]);\\n        }\\n         return a;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "drewbie",
                        "content": "There\\'s just something with this problem that  does not settle with me. If we know two balloons overlap, how can we assume we \"take the shot\" and take out two, instead of waiting to see if more could overlap to take out more than 2 in a shot?\\n\\nWhat I\\'m trying to say is that this seems like a dynamic programming problem where you:\\n\\n- Take the shot (taking out 2 or more)\\n- Don\\'t take the shot in hopes that you can get more than 2 lining up\\n- Take out a single balloon if it\\'s alone\\n\\nWhy does the greedy algorithm work? "
                    },
                    {
                        "username": "surajku2022",
                        "content": "I think sorting the array can help in this"
                    },
                    {
                        "username": "Coderner",
                        "content": "Due to given start and finish indexes, Activity selection problem is coming to my mind\nUsing Activity selection we can find number of non-overlapping balloons, which is the required number of arrows. Please correct me if proceeding in wrong direction."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Do merge Intervals before doing this problem, the intuition comes very easily then. It's just a variation, decent one though.\n` Tip `"
                    },
                    {
                        "username": "tajnur",
                        "content": "Sort the points on basis of end point (second element of each point). By considering the second element of the first point, check each point\\'s starting point is exclude or not. Count number of arrows on basis of exclude or include point.\\n "
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\\n\\nThis test case has ans 2 but i Think answer should be 1 .. can anyone pls explain why answer is 2..."
                    },
                    {
                        "username": "ozovalihasan",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) please check [my solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3002620/ruby-solution/). I have explained it with drawings. "
                    },
                    {
                        "username": "dongliang14",
                        "content": "you need one arrow at x= 6 and another at x = 9"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Okay, the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!!"
                    },
                    {
                        "username": "mukeshkumar30112021",
                        "content": "python solution\n1. sort the given array points :--- points.sort()\n\n2. take  two variable one for comparison of start and end point of sub array (temp)  and other for counting number of arrow( temp =points[0][1]        n_O_A=1)\n3. iterate the start and end  point in points.( for start,end in points:)\n\n4. make the condition   (  if start>temp:\n                temp = end\n                n_O_A  +=1\n        return n_O_A)\n\n\n       \n       \n       \n           "
                    }
                ]
            },
            {
                "id": 1742547,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Can we use Merge Intervals algo with some twist here?"
                    },
                    {
                        "username": "no-username",
                        "content": "Similar to finding total overlaps between intervals. This is fancy way of asking with balloons example."
                    },
                    {
                        "username": "professor_alok",
                        "content": "c++\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        int a=1;  //a=arrow\\n        int l = points[0][1]; // l= last point\\n        sort(points.begin(),points.end());\\n        for(int i=0;i<points.size();i++)\\n        {\\n            if(points[i][0]>l)\\n            {\\n                a++;\\n                l = points[i][1];\\n            }\\n            else l = min(l, points[i][1]);\\n        }\\n         return a;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "drewbie",
                        "content": "There\\'s just something with this problem that  does not settle with me. If we know two balloons overlap, how can we assume we \"take the shot\" and take out two, instead of waiting to see if more could overlap to take out more than 2 in a shot?\\n\\nWhat I\\'m trying to say is that this seems like a dynamic programming problem where you:\\n\\n- Take the shot (taking out 2 or more)\\n- Don\\'t take the shot in hopes that you can get more than 2 lining up\\n- Take out a single balloon if it\\'s alone\\n\\nWhy does the greedy algorithm work? "
                    },
                    {
                        "username": "surajku2022",
                        "content": "I think sorting the array can help in this"
                    },
                    {
                        "username": "Coderner",
                        "content": "Due to given start and finish indexes, Activity selection problem is coming to my mind\nUsing Activity selection we can find number of non-overlapping balloons, which is the required number of arrows. Please correct me if proceeding in wrong direction."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Do merge Intervals before doing this problem, the intuition comes very easily then. It's just a variation, decent one though.\n` Tip `"
                    },
                    {
                        "username": "tajnur",
                        "content": "Sort the points on basis of end point (second element of each point). By considering the second element of the first point, check each point\\'s starting point is exclude or not. Count number of arrows on basis of exclude or include point.\\n "
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\\n\\nThis test case has ans 2 but i Think answer should be 1 .. can anyone pls explain why answer is 2..."
                    },
                    {
                        "username": "ozovalihasan",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) please check [my solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3002620/ruby-solution/). I have explained it with drawings. "
                    },
                    {
                        "username": "dongliang14",
                        "content": "you need one arrow at x= 6 and another at x = 9"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Okay, the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!!"
                    },
                    {
                        "username": "mukeshkumar30112021",
                        "content": "python solution\n1. sort the given array points :--- points.sort()\n\n2. take  two variable one for comparison of start and end point of sub array (temp)  and other for counting number of arrow( temp =points[0][1]        n_O_A=1)\n3. iterate the start and end  point in points.( for start,end in points:)\n\n4. make the condition   (  if start>temp:\n                temp = end\n                n_O_A  +=1\n        return n_O_A)\n\n\n       \n       \n       \n           "
                    }
                ]
            },
            {
                "id": 1742535,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Can we use Merge Intervals algo with some twist here?"
                    },
                    {
                        "username": "no-username",
                        "content": "Similar to finding total overlaps between intervals. This is fancy way of asking with balloons example."
                    },
                    {
                        "username": "professor_alok",
                        "content": "c++\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        int a=1;  //a=arrow\\n        int l = points[0][1]; // l= last point\\n        sort(points.begin(),points.end());\\n        for(int i=0;i<points.size();i++)\\n        {\\n            if(points[i][0]>l)\\n            {\\n                a++;\\n                l = points[i][1];\\n            }\\n            else l = min(l, points[i][1]);\\n        }\\n         return a;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "drewbie",
                        "content": "There\\'s just something with this problem that  does not settle with me. If we know two balloons overlap, how can we assume we \"take the shot\" and take out two, instead of waiting to see if more could overlap to take out more than 2 in a shot?\\n\\nWhat I\\'m trying to say is that this seems like a dynamic programming problem where you:\\n\\n- Take the shot (taking out 2 or more)\\n- Don\\'t take the shot in hopes that you can get more than 2 lining up\\n- Take out a single balloon if it\\'s alone\\n\\nWhy does the greedy algorithm work? "
                    },
                    {
                        "username": "surajku2022",
                        "content": "I think sorting the array can help in this"
                    },
                    {
                        "username": "Coderner",
                        "content": "Due to given start and finish indexes, Activity selection problem is coming to my mind\nUsing Activity selection we can find number of non-overlapping balloons, which is the required number of arrows. Please correct me if proceeding in wrong direction."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Do merge Intervals before doing this problem, the intuition comes very easily then. It's just a variation, decent one though.\n` Tip `"
                    },
                    {
                        "username": "tajnur",
                        "content": "Sort the points on basis of end point (second element of each point). By considering the second element of the first point, check each point\\'s starting point is exclude or not. Count number of arrows on basis of exclude or include point.\\n "
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\\n\\nThis test case has ans 2 but i Think answer should be 1 .. can anyone pls explain why answer is 2..."
                    },
                    {
                        "username": "ozovalihasan",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) please check [my solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3002620/ruby-solution/). I have explained it with drawings. "
                    },
                    {
                        "username": "dongliang14",
                        "content": "you need one arrow at x= 6 and another at x = 9"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Okay, the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!!"
                    },
                    {
                        "username": "mukeshkumar30112021",
                        "content": "python solution\n1. sort the given array points :--- points.sort()\n\n2. take  two variable one for comparison of start and end point of sub array (temp)  and other for counting number of arrow( temp =points[0][1]        n_O_A=1)\n3. iterate the start and end  point in points.( for start,end in points:)\n\n4. make the condition   (  if start>temp:\n                temp = end\n                n_O_A  +=1\n        return n_O_A)\n\n\n       \n       \n       \n           "
                    }
                ]
            },
            {
                "id": 1742479,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Can we use Merge Intervals algo with some twist here?"
                    },
                    {
                        "username": "no-username",
                        "content": "Similar to finding total overlaps between intervals. This is fancy way of asking with balloons example."
                    },
                    {
                        "username": "professor_alok",
                        "content": "c++\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        int a=1;  //a=arrow\\n        int l = points[0][1]; // l= last point\\n        sort(points.begin(),points.end());\\n        for(int i=0;i<points.size();i++)\\n        {\\n            if(points[i][0]>l)\\n            {\\n                a++;\\n                l = points[i][1];\\n            }\\n            else l = min(l, points[i][1]);\\n        }\\n         return a;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "drewbie",
                        "content": "There\\'s just something with this problem that  does not settle with me. If we know two balloons overlap, how can we assume we \"take the shot\" and take out two, instead of waiting to see if more could overlap to take out more than 2 in a shot?\\n\\nWhat I\\'m trying to say is that this seems like a dynamic programming problem where you:\\n\\n- Take the shot (taking out 2 or more)\\n- Don\\'t take the shot in hopes that you can get more than 2 lining up\\n- Take out a single balloon if it\\'s alone\\n\\nWhy does the greedy algorithm work? "
                    },
                    {
                        "username": "surajku2022",
                        "content": "I think sorting the array can help in this"
                    },
                    {
                        "username": "Coderner",
                        "content": "Due to given start and finish indexes, Activity selection problem is coming to my mind\nUsing Activity selection we can find number of non-overlapping balloons, which is the required number of arrows. Please correct me if proceeding in wrong direction."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Do merge Intervals before doing this problem, the intuition comes very easily then. It's just a variation, decent one though.\n` Tip `"
                    },
                    {
                        "username": "tajnur",
                        "content": "Sort the points on basis of end point (second element of each point). By considering the second element of the first point, check each point\\'s starting point is exclude or not. Count number of arrows on basis of exclude or include point.\\n "
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\\n\\nThis test case has ans 2 but i Think answer should be 1 .. can anyone pls explain why answer is 2..."
                    },
                    {
                        "username": "ozovalihasan",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) please check [my solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3002620/ruby-solution/). I have explained it with drawings. "
                    },
                    {
                        "username": "dongliang14",
                        "content": "you need one arrow at x= 6 and another at x = 9"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Okay, the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!!"
                    },
                    {
                        "username": "mukeshkumar30112021",
                        "content": "python solution\n1. sort the given array points :--- points.sort()\n\n2. take  two variable one for comparison of start and end point of sub array (temp)  and other for counting number of arrow( temp =points[0][1]        n_O_A=1)\n3. iterate the start and end  point in points.( for start,end in points:)\n\n4. make the condition   (  if start>temp:\n                temp = end\n                n_O_A  +=1\n        return n_O_A)\n\n\n       \n       \n       \n           "
                    }
                ]
            },
            {
                "id": 1742474,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Can we use Merge Intervals algo with some twist here?"
                    },
                    {
                        "username": "no-username",
                        "content": "Similar to finding total overlaps between intervals. This is fancy way of asking with balloons example."
                    },
                    {
                        "username": "professor_alok",
                        "content": "c++\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        int a=1;  //a=arrow\\n        int l = points[0][1]; // l= last point\\n        sort(points.begin(),points.end());\\n        for(int i=0;i<points.size();i++)\\n        {\\n            if(points[i][0]>l)\\n            {\\n                a++;\\n                l = points[i][1];\\n            }\\n            else l = min(l, points[i][1]);\\n        }\\n         return a;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "drewbie",
                        "content": "There\\'s just something with this problem that  does not settle with me. If we know two balloons overlap, how can we assume we \"take the shot\" and take out two, instead of waiting to see if more could overlap to take out more than 2 in a shot?\\n\\nWhat I\\'m trying to say is that this seems like a dynamic programming problem where you:\\n\\n- Take the shot (taking out 2 or more)\\n- Don\\'t take the shot in hopes that you can get more than 2 lining up\\n- Take out a single balloon if it\\'s alone\\n\\nWhy does the greedy algorithm work? "
                    },
                    {
                        "username": "surajku2022",
                        "content": "I think sorting the array can help in this"
                    },
                    {
                        "username": "Coderner",
                        "content": "Due to given start and finish indexes, Activity selection problem is coming to my mind\nUsing Activity selection we can find number of non-overlapping balloons, which is the required number of arrows. Please correct me if proceeding in wrong direction."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Do merge Intervals before doing this problem, the intuition comes very easily then. It's just a variation, decent one though.\n` Tip `"
                    },
                    {
                        "username": "tajnur",
                        "content": "Sort the points on basis of end point (second element of each point). By considering the second element of the first point, check each point\\'s starting point is exclude or not. Count number of arrows on basis of exclude or include point.\\n "
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\\n\\nThis test case has ans 2 but i Think answer should be 1 .. can anyone pls explain why answer is 2..."
                    },
                    {
                        "username": "ozovalihasan",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) please check [my solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3002620/ruby-solution/). I have explained it with drawings. "
                    },
                    {
                        "username": "dongliang14",
                        "content": "you need one arrow at x= 6 and another at x = 9"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Okay, the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!!"
                    },
                    {
                        "username": "mukeshkumar30112021",
                        "content": "python solution\n1. sort the given array points :--- points.sort()\n\n2. take  two variable one for comparison of start and end point of sub array (temp)  and other for counting number of arrow( temp =points[0][1]        n_O_A=1)\n3. iterate the start and end  point in points.( for start,end in points:)\n\n4. make the condition   (  if start>temp:\n                temp = end\n                n_O_A  +=1\n        return n_O_A)\n\n\n       \n       \n       \n           "
                    }
                ]
            },
            {
                "id": 1742454,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Can we use Merge Intervals algo with some twist here?"
                    },
                    {
                        "username": "no-username",
                        "content": "Similar to finding total overlaps between intervals. This is fancy way of asking with balloons example."
                    },
                    {
                        "username": "professor_alok",
                        "content": "c++\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        int a=1;  //a=arrow\\n        int l = points[0][1]; // l= last point\\n        sort(points.begin(),points.end());\\n        for(int i=0;i<points.size();i++)\\n        {\\n            if(points[i][0]>l)\\n            {\\n                a++;\\n                l = points[i][1];\\n            }\\n            else l = min(l, points[i][1]);\\n        }\\n         return a;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "drewbie",
                        "content": "There\\'s just something with this problem that  does not settle with me. If we know two balloons overlap, how can we assume we \"take the shot\" and take out two, instead of waiting to see if more could overlap to take out more than 2 in a shot?\\n\\nWhat I\\'m trying to say is that this seems like a dynamic programming problem where you:\\n\\n- Take the shot (taking out 2 or more)\\n- Don\\'t take the shot in hopes that you can get more than 2 lining up\\n- Take out a single balloon if it\\'s alone\\n\\nWhy does the greedy algorithm work? "
                    },
                    {
                        "username": "surajku2022",
                        "content": "I think sorting the array can help in this"
                    },
                    {
                        "username": "Coderner",
                        "content": "Due to given start and finish indexes, Activity selection problem is coming to my mind\nUsing Activity selection we can find number of non-overlapping balloons, which is the required number of arrows. Please correct me if proceeding in wrong direction."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Do merge Intervals before doing this problem, the intuition comes very easily then. It's just a variation, decent one though.\n` Tip `"
                    },
                    {
                        "username": "tajnur",
                        "content": "Sort the points on basis of end point (second element of each point). By considering the second element of the first point, check each point\\'s starting point is exclude or not. Count number of arrows on basis of exclude or include point.\\n "
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\\n\\nThis test case has ans 2 but i Think answer should be 1 .. can anyone pls explain why answer is 2..."
                    },
                    {
                        "username": "ozovalihasan",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) please check [my solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3002620/ruby-solution/). I have explained it with drawings. "
                    },
                    {
                        "username": "dongliang14",
                        "content": "you need one arrow at x= 6 and another at x = 9"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Okay, the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!!"
                    },
                    {
                        "username": "mukeshkumar30112021",
                        "content": "python solution\n1. sort the given array points :--- points.sort()\n\n2. take  two variable one for comparison of start and end point of sub array (temp)  and other for counting number of arrow( temp =points[0][1]        n_O_A=1)\n3. iterate the start and end  point in points.( for start,end in points:)\n\n4. make the condition   (  if start>temp:\n                temp = end\n                n_O_A  +=1\n        return n_O_A)\n\n\n       \n       \n       \n           "
                    }
                ]
            },
            {
                "id": 1742448,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Can we use Merge Intervals algo with some twist here?"
                    },
                    {
                        "username": "no-username",
                        "content": "Similar to finding total overlaps between intervals. This is fancy way of asking with balloons example."
                    },
                    {
                        "username": "professor_alok",
                        "content": "c++\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        int a=1;  //a=arrow\\n        int l = points[0][1]; // l= last point\\n        sort(points.begin(),points.end());\\n        for(int i=0;i<points.size();i++)\\n        {\\n            if(points[i][0]>l)\\n            {\\n                a++;\\n                l = points[i][1];\\n            }\\n            else l = min(l, points[i][1]);\\n        }\\n         return a;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "drewbie",
                        "content": "There\\'s just something with this problem that  does not settle with me. If we know two balloons overlap, how can we assume we \"take the shot\" and take out two, instead of waiting to see if more could overlap to take out more than 2 in a shot?\\n\\nWhat I\\'m trying to say is that this seems like a dynamic programming problem where you:\\n\\n- Take the shot (taking out 2 or more)\\n- Don\\'t take the shot in hopes that you can get more than 2 lining up\\n- Take out a single balloon if it\\'s alone\\n\\nWhy does the greedy algorithm work? "
                    },
                    {
                        "username": "surajku2022",
                        "content": "I think sorting the array can help in this"
                    },
                    {
                        "username": "Coderner",
                        "content": "Due to given start and finish indexes, Activity selection problem is coming to my mind\nUsing Activity selection we can find number of non-overlapping balloons, which is the required number of arrows. Please correct me if proceeding in wrong direction."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Do merge Intervals before doing this problem, the intuition comes very easily then. It's just a variation, decent one though.\n` Tip `"
                    },
                    {
                        "username": "tajnur",
                        "content": "Sort the points on basis of end point (second element of each point). By considering the second element of the first point, check each point\\'s starting point is exclude or not. Count number of arrows on basis of exclude or include point.\\n "
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\\n\\nThis test case has ans 2 but i Think answer should be 1 .. can anyone pls explain why answer is 2..."
                    },
                    {
                        "username": "ozovalihasan",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) please check [my solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3002620/ruby-solution/). I have explained it with drawings. "
                    },
                    {
                        "username": "dongliang14",
                        "content": "you need one arrow at x= 6 and another at x = 9"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Okay, the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!!"
                    },
                    {
                        "username": "mukeshkumar30112021",
                        "content": "python solution\n1. sort the given array points :--- points.sort()\n\n2. take  two variable one for comparison of start and end point of sub array (temp)  and other for counting number of arrow( temp =points[0][1]        n_O_A=1)\n3. iterate the start and end  point in points.( for start,end in points:)\n\n4. make the condition   (  if start>temp:\n                temp = end\n                n_O_A  +=1\n        return n_O_A)\n\n\n       \n       \n       \n           "
                    }
                ]
            },
            {
                "id": 1742443,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Can we use Merge Intervals algo with some twist here?"
                    },
                    {
                        "username": "no-username",
                        "content": "Similar to finding total overlaps between intervals. This is fancy way of asking with balloons example."
                    },
                    {
                        "username": "professor_alok",
                        "content": "c++\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        int a=1;  //a=arrow\\n        int l = points[0][1]; // l= last point\\n        sort(points.begin(),points.end());\\n        for(int i=0;i<points.size();i++)\\n        {\\n            if(points[i][0]>l)\\n            {\\n                a++;\\n                l = points[i][1];\\n            }\\n            else l = min(l, points[i][1]);\\n        }\\n         return a;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "drewbie",
                        "content": "There\\'s just something with this problem that  does not settle with me. If we know two balloons overlap, how can we assume we \"take the shot\" and take out two, instead of waiting to see if more could overlap to take out more than 2 in a shot?\\n\\nWhat I\\'m trying to say is that this seems like a dynamic programming problem where you:\\n\\n- Take the shot (taking out 2 or more)\\n- Don\\'t take the shot in hopes that you can get more than 2 lining up\\n- Take out a single balloon if it\\'s alone\\n\\nWhy does the greedy algorithm work? "
                    },
                    {
                        "username": "surajku2022",
                        "content": "I think sorting the array can help in this"
                    },
                    {
                        "username": "Coderner",
                        "content": "Due to given start and finish indexes, Activity selection problem is coming to my mind\nUsing Activity selection we can find number of non-overlapping balloons, which is the required number of arrows. Please correct me if proceeding in wrong direction."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Do merge Intervals before doing this problem, the intuition comes very easily then. It's just a variation, decent one though.\n` Tip `"
                    },
                    {
                        "username": "tajnur",
                        "content": "Sort the points on basis of end point (second element of each point). By considering the second element of the first point, check each point\\'s starting point is exclude or not. Count number of arrows on basis of exclude or include point.\\n "
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\\n\\nThis test case has ans 2 but i Think answer should be 1 .. can anyone pls explain why answer is 2..."
                    },
                    {
                        "username": "ozovalihasan",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) please check [my solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3002620/ruby-solution/). I have explained it with drawings. "
                    },
                    {
                        "username": "dongliang14",
                        "content": "you need one arrow at x= 6 and another at x = 9"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Okay, the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!!"
                    },
                    {
                        "username": "mukeshkumar30112021",
                        "content": "python solution\n1. sort the given array points :--- points.sort()\n\n2. take  two variable one for comparison of start and end point of sub array (temp)  and other for counting number of arrow( temp =points[0][1]        n_O_A=1)\n3. iterate the start and end  point in points.( for start,end in points:)\n\n4. make the condition   (  if start>temp:\n                temp = end\n                n_O_A  +=1\n        return n_O_A)\n\n\n       \n       \n       \n           "
                    }
                ]
            },
            {
                "id": 1742435,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Can we use Merge Intervals algo with some twist here?"
                    },
                    {
                        "username": "no-username",
                        "content": "Similar to finding total overlaps between intervals. This is fancy way of asking with balloons example."
                    },
                    {
                        "username": "professor_alok",
                        "content": "c++\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        int a=1;  //a=arrow\\n        int l = points[0][1]; // l= last point\\n        sort(points.begin(),points.end());\\n        for(int i=0;i<points.size();i++)\\n        {\\n            if(points[i][0]>l)\\n            {\\n                a++;\\n                l = points[i][1];\\n            }\\n            else l = min(l, points[i][1]);\\n        }\\n         return a;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "drewbie",
                        "content": "There\\'s just something with this problem that  does not settle with me. If we know two balloons overlap, how can we assume we \"take the shot\" and take out two, instead of waiting to see if more could overlap to take out more than 2 in a shot?\\n\\nWhat I\\'m trying to say is that this seems like a dynamic programming problem where you:\\n\\n- Take the shot (taking out 2 or more)\\n- Don\\'t take the shot in hopes that you can get more than 2 lining up\\n- Take out a single balloon if it\\'s alone\\n\\nWhy does the greedy algorithm work? "
                    },
                    {
                        "username": "surajku2022",
                        "content": "I think sorting the array can help in this"
                    },
                    {
                        "username": "Coderner",
                        "content": "Due to given start and finish indexes, Activity selection problem is coming to my mind\nUsing Activity selection we can find number of non-overlapping balloons, which is the required number of arrows. Please correct me if proceeding in wrong direction."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Do merge Intervals before doing this problem, the intuition comes very easily then. It's just a variation, decent one though.\n` Tip `"
                    },
                    {
                        "username": "tajnur",
                        "content": "Sort the points on basis of end point (second element of each point). By considering the second element of the first point, check each point\\'s starting point is exclude or not. Count number of arrows on basis of exclude or include point.\\n "
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\\n\\nThis test case has ans 2 but i Think answer should be 1 .. can anyone pls explain why answer is 2..."
                    },
                    {
                        "username": "ozovalihasan",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) please check [my solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3002620/ruby-solution/). I have explained it with drawings. "
                    },
                    {
                        "username": "dongliang14",
                        "content": "you need one arrow at x= 6 and another at x = 9"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Okay, the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!!"
                    },
                    {
                        "username": "mukeshkumar30112021",
                        "content": "python solution\n1. sort the given array points :--- points.sort()\n\n2. take  two variable one for comparison of start and end point of sub array (temp)  and other for counting number of arrow( temp =points[0][1]        n_O_A=1)\n3. iterate the start and end  point in points.( for start,end in points:)\n\n4. make the condition   (  if start>temp:\n                temp = end\n                n_O_A  +=1\n        return n_O_A)\n\n\n       \n       \n       \n           "
                    }
                ]
            },
            {
                "id": 1742422,
                "content": [
                    {
                        "username": "Shreyash_Yadav",
                        "content": "Can we use Merge Intervals algo with some twist here?"
                    },
                    {
                        "username": "no-username",
                        "content": "Similar to finding total overlaps between intervals. This is fancy way of asking with balloons example."
                    },
                    {
                        "username": "professor_alok",
                        "content": "c++\\nclass Solution {\\npublic:\\n    int findMinArrowShots(vector<vector<int>>& points) {\\n        int a=1;  //a=arrow\\n        int l = points[0][1]; // l= last point\\n        sort(points.begin(),points.end());\\n        for(int i=0;i<points.size();i++)\\n        {\\n            if(points[i][0]>l)\\n            {\\n                a++;\\n                l = points[i][1];\\n            }\\n            else l = min(l, points[i][1]);\\n        }\\n         return a;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "drewbie",
                        "content": "There\\'s just something with this problem that  does not settle with me. If we know two balloons overlap, how can we assume we \"take the shot\" and take out two, instead of waiting to see if more could overlap to take out more than 2 in a shot?\\n\\nWhat I\\'m trying to say is that this seems like a dynamic programming problem where you:\\n\\n- Take the shot (taking out 2 or more)\\n- Don\\'t take the shot in hopes that you can get more than 2 lining up\\n- Take out a single balloon if it\\'s alone\\n\\nWhy does the greedy algorithm work? "
                    },
                    {
                        "username": "surajku2022",
                        "content": "I think sorting the array can help in this"
                    },
                    {
                        "username": "Coderner",
                        "content": "Due to given start and finish indexes, Activity selection problem is coming to my mind\nUsing Activity selection we can find number of non-overlapping balloons, which is the required number of arrows. Please correct me if proceeding in wrong direction."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Do merge Intervals before doing this problem, the intuition comes very easily then. It's just a variation, decent one though.\n` Tip `"
                    },
                    {
                        "username": "tajnur",
                        "content": "Sort the points on basis of end point (second element of each point). By considering the second element of the first point, check each point\\'s starting point is exclude or not. Count number of arrows on basis of exclude or include point.\\n "
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "[[3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8]]\\n\\nThis test case has ans 2 but i Think answer should be 1 .. can anyone pls explain why answer is 2..."
                    },
                    {
                        "username": "ozovalihasan",
                        "content": "[@DHANANJAY SARATHE](/dhananjaysarathe26) please check [my solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3002620/ruby-solution/). I have explained it with drawings. "
                    },
                    {
                        "username": "dongliang14",
                        "content": "you need one arrow at x= 6 and another at x = 9"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Okay, the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!!"
                    },
                    {
                        "username": "mukeshkumar30112021",
                        "content": "python solution\n1. sort the given array points :--- points.sort()\n\n2. take  two variable one for comparison of start and end point of sub array (temp)  and other for counting number of arrow( temp =points[0][1]        n_O_A=1)\n3. iterate the start and end  point in points.( for start,end in points:)\n\n4. make the condition   (  if start>temp:\n                temp = end\n                n_O_A  +=1\n        return n_O_A)\n\n\n       \n       \n       \n           "
                    }
                ]
            },
            {
                "id": 1742414,
                "content": [
                    {
                        "username": "Imran_Khattak",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\n\nWe can understand by using an example:\n\nGiven an 2d array of size 4 with [10,16] , [2,8] , [1,6] , [7,12]\n\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\n\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\n\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\n\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\n\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\n\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\n\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\n\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\n\nAt last, return the arrow counter.\n\nfor code Solution checkout this...\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001126/c-minimum-number-of-arrow-to-burst-the-balloons-with-explanation-easy-solution/"
                    },
                    {
                        "username": "WannaBeProgrammer",
                        "content": "A Simple Greedy Solution.  Greedy about covering most intervals\\n\\n```class Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key = lambda x:x[1], reverse=True)\\n        left, right, arrowCount = points[0][0], points[0][1], 1\\n        for point in points[1:]:\\n            left = max(left, point[0])\\n            right = min(right, point[1])\\n            if left > right :\\n                left, right = point[0], point[1]\\n                arrowCount+=1\\n        return arrowCount"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "KyleLiuuu",
                        "content": "test case 49:\\npoints = []\\n\\nConstraints: \\n1 <= points.length <= 10^5\\n\\n??????????"
                    },
                    {
                        "username": "surajku2022",
                        "content": "It\\'s interval problem, just sort the given array"
                    },
                    {
                        "username": "be_quick",
                        "content": "Always think these cases with interval problems\\n\\n1) sorting will be the first step in interval problem, if they give unsorted\\n\\nAssuming it is sorted by left points\\n1) Non Intersecting\\n2) Intersecting\\n2.1) [[2,5],[3,7]]\\n2.2) [[1,100],[3,7]]"
                    },
                    {
                        "username": "zubinshah",
                        "content": "What would be the solution in case the question was to find the number of maximum balloons that can be burst given \\'K\\' number of arrows."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "\\nshoting time  is equal or between in start and end time of any points .. "
                    },
                    {
                        "username": "amanchandna",
                        "content": "Try to imagine this problem statement as those YouTube videos, where they arrange a lot of big balloons and try to burst them with dart and arrow, In this problem balloons are placed horizontally rather in a vertical line.\\n\\nIf you solved merge overlapping time intervals type questions, this will be easy for you.\\n\\nNote : Due to new testcase, need to use `Integer.compare(a,b)`\\nrather than `(a-b)` for sorting\\n\\nDon\\'t jump to solution directly : [solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000877/easy-java-solution/)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Check this test-case:\\n[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n\\nThen, you will recognize to update the `e1`(end of initial balloon) as `min(e1, e2)` for each point processed within the updated boundaries.\\nThank me later"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "took me ages to figure this problem out, better draw it on paper as line segments for easier understanding"
                    }
                ]
            },
            {
                "id": 1742401,
                "content": [
                    {
                        "username": "Imran_Khattak",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\n\nWe can understand by using an example:\n\nGiven an 2d array of size 4 with [10,16] , [2,8] , [1,6] , [7,12]\n\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\n\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\n\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\n\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\n\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\n\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\n\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\n\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\n\nAt last, return the arrow counter.\n\nfor code Solution checkout this...\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001126/c-minimum-number-of-arrow-to-burst-the-balloons-with-explanation-easy-solution/"
                    },
                    {
                        "username": "WannaBeProgrammer",
                        "content": "A Simple Greedy Solution.  Greedy about covering most intervals\\n\\n```class Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key = lambda x:x[1], reverse=True)\\n        left, right, arrowCount = points[0][0], points[0][1], 1\\n        for point in points[1:]:\\n            left = max(left, point[0])\\n            right = min(right, point[1])\\n            if left > right :\\n                left, right = point[0], point[1]\\n                arrowCount+=1\\n        return arrowCount"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "KyleLiuuu",
                        "content": "test case 49:\\npoints = []\\n\\nConstraints: \\n1 <= points.length <= 10^5\\n\\n??????????"
                    },
                    {
                        "username": "surajku2022",
                        "content": "It\\'s interval problem, just sort the given array"
                    },
                    {
                        "username": "be_quick",
                        "content": "Always think these cases with interval problems\\n\\n1) sorting will be the first step in interval problem, if they give unsorted\\n\\nAssuming it is sorted by left points\\n1) Non Intersecting\\n2) Intersecting\\n2.1) [[2,5],[3,7]]\\n2.2) [[1,100],[3,7]]"
                    },
                    {
                        "username": "zubinshah",
                        "content": "What would be the solution in case the question was to find the number of maximum balloons that can be burst given \\'K\\' number of arrows."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "\\nshoting time  is equal or between in start and end time of any points .. "
                    },
                    {
                        "username": "amanchandna",
                        "content": "Try to imagine this problem statement as those YouTube videos, where they arrange a lot of big balloons and try to burst them with dart and arrow, In this problem balloons are placed horizontally rather in a vertical line.\\n\\nIf you solved merge overlapping time intervals type questions, this will be easy for you.\\n\\nNote : Due to new testcase, need to use `Integer.compare(a,b)`\\nrather than `(a-b)` for sorting\\n\\nDon\\'t jump to solution directly : [solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000877/easy-java-solution/)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Check this test-case:\\n[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n\\nThen, you will recognize to update the `e1`(end of initial balloon) as `min(e1, e2)` for each point processed within the updated boundaries.\\nThank me later"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "took me ages to figure this problem out, better draw it on paper as line segments for easier understanding"
                    }
                ]
            },
            {
                "id": 1742386,
                "content": [
                    {
                        "username": "Imran_Khattak",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\n\nWe can understand by using an example:\n\nGiven an 2d array of size 4 with [10,16] , [2,8] , [1,6] , [7,12]\n\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\n\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\n\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\n\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\n\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\n\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\n\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\n\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\n\nAt last, return the arrow counter.\n\nfor code Solution checkout this...\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001126/c-minimum-number-of-arrow-to-burst-the-balloons-with-explanation-easy-solution/"
                    },
                    {
                        "username": "WannaBeProgrammer",
                        "content": "A Simple Greedy Solution.  Greedy about covering most intervals\\n\\n```class Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key = lambda x:x[1], reverse=True)\\n        left, right, arrowCount = points[0][0], points[0][1], 1\\n        for point in points[1:]:\\n            left = max(left, point[0])\\n            right = min(right, point[1])\\n            if left > right :\\n                left, right = point[0], point[1]\\n                arrowCount+=1\\n        return arrowCount"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "KyleLiuuu",
                        "content": "test case 49:\\npoints = []\\n\\nConstraints: \\n1 <= points.length <= 10^5\\n\\n??????????"
                    },
                    {
                        "username": "surajku2022",
                        "content": "It\\'s interval problem, just sort the given array"
                    },
                    {
                        "username": "be_quick",
                        "content": "Always think these cases with interval problems\\n\\n1) sorting will be the first step in interval problem, if they give unsorted\\n\\nAssuming it is sorted by left points\\n1) Non Intersecting\\n2) Intersecting\\n2.1) [[2,5],[3,7]]\\n2.2) [[1,100],[3,7]]"
                    },
                    {
                        "username": "zubinshah",
                        "content": "What would be the solution in case the question was to find the number of maximum balloons that can be burst given \\'K\\' number of arrows."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "\\nshoting time  is equal or between in start and end time of any points .. "
                    },
                    {
                        "username": "amanchandna",
                        "content": "Try to imagine this problem statement as those YouTube videos, where they arrange a lot of big balloons and try to burst them with dart and arrow, In this problem balloons are placed horizontally rather in a vertical line.\\n\\nIf you solved merge overlapping time intervals type questions, this will be easy for you.\\n\\nNote : Due to new testcase, need to use `Integer.compare(a,b)`\\nrather than `(a-b)` for sorting\\n\\nDon\\'t jump to solution directly : [solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000877/easy-java-solution/)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Check this test-case:\\n[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n\\nThen, you will recognize to update the `e1`(end of initial balloon) as `min(e1, e2)` for each point processed within the updated boundaries.\\nThank me later"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "took me ages to figure this problem out, better draw it on paper as line segments for easier understanding"
                    }
                ]
            },
            {
                "id": 1742380,
                "content": [
                    {
                        "username": "Imran_Khattak",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\n\nWe can understand by using an example:\n\nGiven an 2d array of size 4 with [10,16] , [2,8] , [1,6] , [7,12]\n\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\n\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\n\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\n\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\n\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\n\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\n\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\n\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\n\nAt last, return the arrow counter.\n\nfor code Solution checkout this...\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001126/c-minimum-number-of-arrow-to-burst-the-balloons-with-explanation-easy-solution/"
                    },
                    {
                        "username": "WannaBeProgrammer",
                        "content": "A Simple Greedy Solution.  Greedy about covering most intervals\\n\\n```class Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key = lambda x:x[1], reverse=True)\\n        left, right, arrowCount = points[0][0], points[0][1], 1\\n        for point in points[1:]:\\n            left = max(left, point[0])\\n            right = min(right, point[1])\\n            if left > right :\\n                left, right = point[0], point[1]\\n                arrowCount+=1\\n        return arrowCount"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "KyleLiuuu",
                        "content": "test case 49:\\npoints = []\\n\\nConstraints: \\n1 <= points.length <= 10^5\\n\\n??????????"
                    },
                    {
                        "username": "surajku2022",
                        "content": "It\\'s interval problem, just sort the given array"
                    },
                    {
                        "username": "be_quick",
                        "content": "Always think these cases with interval problems\\n\\n1) sorting will be the first step in interval problem, if they give unsorted\\n\\nAssuming it is sorted by left points\\n1) Non Intersecting\\n2) Intersecting\\n2.1) [[2,5],[3,7]]\\n2.2) [[1,100],[3,7]]"
                    },
                    {
                        "username": "zubinshah",
                        "content": "What would be the solution in case the question was to find the number of maximum balloons that can be burst given \\'K\\' number of arrows."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "\\nshoting time  is equal or between in start and end time of any points .. "
                    },
                    {
                        "username": "amanchandna",
                        "content": "Try to imagine this problem statement as those YouTube videos, where they arrange a lot of big balloons and try to burst them with dart and arrow, In this problem balloons are placed horizontally rather in a vertical line.\\n\\nIf you solved merge overlapping time intervals type questions, this will be easy for you.\\n\\nNote : Due to new testcase, need to use `Integer.compare(a,b)`\\nrather than `(a-b)` for sorting\\n\\nDon\\'t jump to solution directly : [solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000877/easy-java-solution/)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Check this test-case:\\n[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n\\nThen, you will recognize to update the `e1`(end of initial balloon) as `min(e1, e2)` for each point processed within the updated boundaries.\\nThank me later"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "took me ages to figure this problem out, better draw it on paper as line segments for easier understanding"
                    }
                ]
            },
            {
                "id": 1742356,
                "content": [
                    {
                        "username": "Imran_Khattak",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\n\nWe can understand by using an example:\n\nGiven an 2d array of size 4 with [10,16] , [2,8] , [1,6] , [7,12]\n\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\n\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\n\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\n\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\n\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\n\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\n\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\n\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\n\nAt last, return the arrow counter.\n\nfor code Solution checkout this...\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001126/c-minimum-number-of-arrow-to-burst-the-balloons-with-explanation-easy-solution/"
                    },
                    {
                        "username": "WannaBeProgrammer",
                        "content": "A Simple Greedy Solution.  Greedy about covering most intervals\\n\\n```class Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key = lambda x:x[1], reverse=True)\\n        left, right, arrowCount = points[0][0], points[0][1], 1\\n        for point in points[1:]:\\n            left = max(left, point[0])\\n            right = min(right, point[1])\\n            if left > right :\\n                left, right = point[0], point[1]\\n                arrowCount+=1\\n        return arrowCount"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "KyleLiuuu",
                        "content": "test case 49:\\npoints = []\\n\\nConstraints: \\n1 <= points.length <= 10^5\\n\\n??????????"
                    },
                    {
                        "username": "surajku2022",
                        "content": "It\\'s interval problem, just sort the given array"
                    },
                    {
                        "username": "be_quick",
                        "content": "Always think these cases with interval problems\\n\\n1) sorting will be the first step in interval problem, if they give unsorted\\n\\nAssuming it is sorted by left points\\n1) Non Intersecting\\n2) Intersecting\\n2.1) [[2,5],[3,7]]\\n2.2) [[1,100],[3,7]]"
                    },
                    {
                        "username": "zubinshah",
                        "content": "What would be the solution in case the question was to find the number of maximum balloons that can be burst given \\'K\\' number of arrows."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "\\nshoting time  is equal or between in start and end time of any points .. "
                    },
                    {
                        "username": "amanchandna",
                        "content": "Try to imagine this problem statement as those YouTube videos, where they arrange a lot of big balloons and try to burst them with dart and arrow, In this problem balloons are placed horizontally rather in a vertical line.\\n\\nIf you solved merge overlapping time intervals type questions, this will be easy for you.\\n\\nNote : Due to new testcase, need to use `Integer.compare(a,b)`\\nrather than `(a-b)` for sorting\\n\\nDon\\'t jump to solution directly : [solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000877/easy-java-solution/)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Check this test-case:\\n[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n\\nThen, you will recognize to update the `e1`(end of initial balloon) as `min(e1, e2)` for each point processed within the updated boundaries.\\nThank me later"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "took me ages to figure this problem out, better draw it on paper as line segments for easier understanding"
                    }
                ]
            },
            {
                "id": 1742346,
                "content": [
                    {
                        "username": "Imran_Khattak",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\n\nWe can understand by using an example:\n\nGiven an 2d array of size 4 with [10,16] , [2,8] , [1,6] , [7,12]\n\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\n\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\n\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\n\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\n\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\n\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\n\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\n\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\n\nAt last, return the arrow counter.\n\nfor code Solution checkout this...\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001126/c-minimum-number-of-arrow-to-burst-the-balloons-with-explanation-easy-solution/"
                    },
                    {
                        "username": "WannaBeProgrammer",
                        "content": "A Simple Greedy Solution.  Greedy about covering most intervals\\n\\n```class Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key = lambda x:x[1], reverse=True)\\n        left, right, arrowCount = points[0][0], points[0][1], 1\\n        for point in points[1:]:\\n            left = max(left, point[0])\\n            right = min(right, point[1])\\n            if left > right :\\n                left, right = point[0], point[1]\\n                arrowCount+=1\\n        return arrowCount"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "KyleLiuuu",
                        "content": "test case 49:\\npoints = []\\n\\nConstraints: \\n1 <= points.length <= 10^5\\n\\n??????????"
                    },
                    {
                        "username": "surajku2022",
                        "content": "It\\'s interval problem, just sort the given array"
                    },
                    {
                        "username": "be_quick",
                        "content": "Always think these cases with interval problems\\n\\n1) sorting will be the first step in interval problem, if they give unsorted\\n\\nAssuming it is sorted by left points\\n1) Non Intersecting\\n2) Intersecting\\n2.1) [[2,5],[3,7]]\\n2.2) [[1,100],[3,7]]"
                    },
                    {
                        "username": "zubinshah",
                        "content": "What would be the solution in case the question was to find the number of maximum balloons that can be burst given \\'K\\' number of arrows."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "\\nshoting time  is equal or between in start and end time of any points .. "
                    },
                    {
                        "username": "amanchandna",
                        "content": "Try to imagine this problem statement as those YouTube videos, where they arrange a lot of big balloons and try to burst them with dart and arrow, In this problem balloons are placed horizontally rather in a vertical line.\\n\\nIf you solved merge overlapping time intervals type questions, this will be easy for you.\\n\\nNote : Due to new testcase, need to use `Integer.compare(a,b)`\\nrather than `(a-b)` for sorting\\n\\nDon\\'t jump to solution directly : [solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000877/easy-java-solution/)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Check this test-case:\\n[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n\\nThen, you will recognize to update the `e1`(end of initial balloon) as `min(e1, e2)` for each point processed within the updated boundaries.\\nThank me later"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "took me ages to figure this problem out, better draw it on paper as line segments for easier understanding"
                    }
                ]
            },
            {
                "id": 1742344,
                "content": [
                    {
                        "username": "Imran_Khattak",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\n\nWe can understand by using an example:\n\nGiven an 2d array of size 4 with [10,16] , [2,8] , [1,6] , [7,12]\n\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\n\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\n\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\n\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\n\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\n\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\n\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\n\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\n\nAt last, return the arrow counter.\n\nfor code Solution checkout this...\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001126/c-minimum-number-of-arrow-to-burst-the-balloons-with-explanation-easy-solution/"
                    },
                    {
                        "username": "WannaBeProgrammer",
                        "content": "A Simple Greedy Solution.  Greedy about covering most intervals\\n\\n```class Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key = lambda x:x[1], reverse=True)\\n        left, right, arrowCount = points[0][0], points[0][1], 1\\n        for point in points[1:]:\\n            left = max(left, point[0])\\n            right = min(right, point[1])\\n            if left > right :\\n                left, right = point[0], point[1]\\n                arrowCount+=1\\n        return arrowCount"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "KyleLiuuu",
                        "content": "test case 49:\\npoints = []\\n\\nConstraints: \\n1 <= points.length <= 10^5\\n\\n??????????"
                    },
                    {
                        "username": "surajku2022",
                        "content": "It\\'s interval problem, just sort the given array"
                    },
                    {
                        "username": "be_quick",
                        "content": "Always think these cases with interval problems\\n\\n1) sorting will be the first step in interval problem, if they give unsorted\\n\\nAssuming it is sorted by left points\\n1) Non Intersecting\\n2) Intersecting\\n2.1) [[2,5],[3,7]]\\n2.2) [[1,100],[3,7]]"
                    },
                    {
                        "username": "zubinshah",
                        "content": "What would be the solution in case the question was to find the number of maximum balloons that can be burst given \\'K\\' number of arrows."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "\\nshoting time  is equal or between in start and end time of any points .. "
                    },
                    {
                        "username": "amanchandna",
                        "content": "Try to imagine this problem statement as those YouTube videos, where they arrange a lot of big balloons and try to burst them with dart and arrow, In this problem balloons are placed horizontally rather in a vertical line.\\n\\nIf you solved merge overlapping time intervals type questions, this will be easy for you.\\n\\nNote : Due to new testcase, need to use `Integer.compare(a,b)`\\nrather than `(a-b)` for sorting\\n\\nDon\\'t jump to solution directly : [solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000877/easy-java-solution/)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Check this test-case:\\n[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n\\nThen, you will recognize to update the `e1`(end of initial balloon) as `min(e1, e2)` for each point processed within the updated boundaries.\\nThank me later"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "took me ages to figure this problem out, better draw it on paper as line segments for easier understanding"
                    }
                ]
            },
            {
                "id": 1742339,
                "content": [
                    {
                        "username": "Imran_Khattak",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\n\nWe can understand by using an example:\n\nGiven an 2d array of size 4 with [10,16] , [2,8] , [1,6] , [7,12]\n\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\n\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\n\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\n\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\n\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\n\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\n\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\n\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\n\nAt last, return the arrow counter.\n\nfor code Solution checkout this...\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001126/c-minimum-number-of-arrow-to-burst-the-balloons-with-explanation-easy-solution/"
                    },
                    {
                        "username": "WannaBeProgrammer",
                        "content": "A Simple Greedy Solution.  Greedy about covering most intervals\\n\\n```class Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key = lambda x:x[1], reverse=True)\\n        left, right, arrowCount = points[0][0], points[0][1], 1\\n        for point in points[1:]:\\n            left = max(left, point[0])\\n            right = min(right, point[1])\\n            if left > right :\\n                left, right = point[0], point[1]\\n                arrowCount+=1\\n        return arrowCount"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "KyleLiuuu",
                        "content": "test case 49:\\npoints = []\\n\\nConstraints: \\n1 <= points.length <= 10^5\\n\\n??????????"
                    },
                    {
                        "username": "surajku2022",
                        "content": "It\\'s interval problem, just sort the given array"
                    },
                    {
                        "username": "be_quick",
                        "content": "Always think these cases with interval problems\\n\\n1) sorting will be the first step in interval problem, if they give unsorted\\n\\nAssuming it is sorted by left points\\n1) Non Intersecting\\n2) Intersecting\\n2.1) [[2,5],[3,7]]\\n2.2) [[1,100],[3,7]]"
                    },
                    {
                        "username": "zubinshah",
                        "content": "What would be the solution in case the question was to find the number of maximum balloons that can be burst given \\'K\\' number of arrows."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "\\nshoting time  is equal or between in start and end time of any points .. "
                    },
                    {
                        "username": "amanchandna",
                        "content": "Try to imagine this problem statement as those YouTube videos, where they arrange a lot of big balloons and try to burst them with dart and arrow, In this problem balloons are placed horizontally rather in a vertical line.\\n\\nIf you solved merge overlapping time intervals type questions, this will be easy for you.\\n\\nNote : Due to new testcase, need to use `Integer.compare(a,b)`\\nrather than `(a-b)` for sorting\\n\\nDon\\'t jump to solution directly : [solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000877/easy-java-solution/)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Check this test-case:\\n[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n\\nThen, you will recognize to update the `e1`(end of initial balloon) as `min(e1, e2)` for each point processed within the updated boundaries.\\nThank me later"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "took me ages to figure this problem out, better draw it on paper as line segments for easier understanding"
                    }
                ]
            },
            {
                "id": 1742327,
                "content": [
                    {
                        "username": "Imran_Khattak",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\n\nWe can understand by using an example:\n\nGiven an 2d array of size 4 with [10,16] , [2,8] , [1,6] , [7,12]\n\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\n\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\n\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\n\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\n\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\n\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\n\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\n\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\n\nAt last, return the arrow counter.\n\nfor code Solution checkout this...\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001126/c-minimum-number-of-arrow-to-burst-the-balloons-with-explanation-easy-solution/"
                    },
                    {
                        "username": "WannaBeProgrammer",
                        "content": "A Simple Greedy Solution.  Greedy about covering most intervals\\n\\n```class Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key = lambda x:x[1], reverse=True)\\n        left, right, arrowCount = points[0][0], points[0][1], 1\\n        for point in points[1:]:\\n            left = max(left, point[0])\\n            right = min(right, point[1])\\n            if left > right :\\n                left, right = point[0], point[1]\\n                arrowCount+=1\\n        return arrowCount"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "KyleLiuuu",
                        "content": "test case 49:\\npoints = []\\n\\nConstraints: \\n1 <= points.length <= 10^5\\n\\n??????????"
                    },
                    {
                        "username": "surajku2022",
                        "content": "It\\'s interval problem, just sort the given array"
                    },
                    {
                        "username": "be_quick",
                        "content": "Always think these cases with interval problems\\n\\n1) sorting will be the first step in interval problem, if they give unsorted\\n\\nAssuming it is sorted by left points\\n1) Non Intersecting\\n2) Intersecting\\n2.1) [[2,5],[3,7]]\\n2.2) [[1,100],[3,7]]"
                    },
                    {
                        "username": "zubinshah",
                        "content": "What would be the solution in case the question was to find the number of maximum balloons that can be burst given \\'K\\' number of arrows."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "\\nshoting time  is equal or between in start and end time of any points .. "
                    },
                    {
                        "username": "amanchandna",
                        "content": "Try to imagine this problem statement as those YouTube videos, where they arrange a lot of big balloons and try to burst them with dart and arrow, In this problem balloons are placed horizontally rather in a vertical line.\\n\\nIf you solved merge overlapping time intervals type questions, this will be easy for you.\\n\\nNote : Due to new testcase, need to use `Integer.compare(a,b)`\\nrather than `(a-b)` for sorting\\n\\nDon\\'t jump to solution directly : [solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000877/easy-java-solution/)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Check this test-case:\\n[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n\\nThen, you will recognize to update the `e1`(end of initial balloon) as `min(e1, e2)` for each point processed within the updated boundaries.\\nThank me later"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "took me ages to figure this problem out, better draw it on paper as line segments for easier understanding"
                    }
                ]
            },
            {
                "id": 1742323,
                "content": [
                    {
                        "username": "Imran_Khattak",
                        "content": "This problem is based on Greedy algorithm and we can solve this problem using this concept:\n\nWe can understand by using an example:\n\nGiven an 2d array of size 4 with [10,16] , [2,8] , [1,6] , [7,12]\n\nSuppose we shoot an arrow to [10,16] it also shoots [7,12] and if we shoot [2,8] the arrow also hits [1,6]. In simpler words, we can say if the first element of the current sub array is lesser than the targeted second element of any sub-array, the arrow hits both of them. If not, the arrow has to be shot again.\n\nBut the above theory will only work if the array is sorted for that we will get all the first elements of the array in increasing order hence, makes comparison easier without any loopholes.\n\nAfter sorting the array looks like : [ [1,6] , [2,8] , [7,12] , [10,16] ]\n\nNow we can check if the first element of the current sub array is greater than the targeted second element of any sub-array (we can also check for lesser than but then you have to subtract the result from the array length).\n\nHere, we initialize arrow with 1 as the arrow has to be shot to start the process.\nAnd, the current comparison element with which the first element of the current sub array will be compared will be set as points[0][1] as it is the targeted second element of first sub-array.\n\nAs 7>6, the arrow shot for [1,6] did not shoot [7,12], for which we had to shoot again.\n\nFor every ith element greater, we increment the arrow counter and update the comparing element to the second element of the current sub-array. This checks if there are any more elements left to be checked for given comparison element. As the array is sorted, if the comparison condition is true that means no other sub-array can be shot with the same arrow. So we update the comparison element for next shot.\n\nIf the condition does not fits then we check the minimum between the comparing element and the second element of current sub-array. As we have to check for minimums first to get correct result (that is why, we had sorted the array). We cannot jump as the current indicator is incrementing with every fulfilled or unfulfilled comparison.\n\nAt last, return the arrow counter.\n\nfor code Solution checkout this...\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3001126/c-minimum-number-of-arrow-to-burst-the-balloons-with-explanation-easy-solution/"
                    },
                    {
                        "username": "WannaBeProgrammer",
                        "content": "A Simple Greedy Solution.  Greedy about covering most intervals\\n\\n```class Solution:\\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\\n        points.sort(key = lambda x:x[1], reverse=True)\\n        left, right, arrowCount = points[0][0], points[0][1], 1\\n        for point in points[1:]:\\n            left = max(left, point[0])\\n            right = min(right, point[1])\\n            if left > right :\\n                left, right = point[0], point[1]\\n                arrowCount+=1\\n        return arrowCount"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... now what exactly do you want to discuss here in Discussion section where people rescue for tips?"
                    },
                    {
                        "username": "KyleLiuuu",
                        "content": "test case 49:\\npoints = []\\n\\nConstraints: \\n1 <= points.length <= 10^5\\n\\n??????????"
                    },
                    {
                        "username": "surajku2022",
                        "content": "It\\'s interval problem, just sort the given array"
                    },
                    {
                        "username": "be_quick",
                        "content": "Always think these cases with interval problems\\n\\n1) sorting will be the first step in interval problem, if they give unsorted\\n\\nAssuming it is sorted by left points\\n1) Non Intersecting\\n2) Intersecting\\n2.1) [[2,5],[3,7]]\\n2.2) [[1,100],[3,7]]"
                    },
                    {
                        "username": "zubinshah",
                        "content": "What would be the solution in case the question was to find the number of maximum balloons that can be burst given \\'K\\' number of arrows."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "\\nshoting time  is equal or between in start and end time of any points .. "
                    },
                    {
                        "username": "amanchandna",
                        "content": "Try to imagine this problem statement as those YouTube videos, where they arrange a lot of big balloons and try to burst them with dart and arrow, In this problem balloons are placed horizontally rather in a vertical line.\\n\\nIf you solved merge overlapping time intervals type questions, this will be easy for you.\\n\\nNote : Due to new testcase, need to use `Integer.compare(a,b)`\\nrather than `(a-b)` for sorting\\n\\nDon\\'t jump to solution directly : [solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3000877/easy-java-solution/)"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Check this test-case:\\n[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]]\\n\\nThen, you will recognize to update the `e1`(end of initial balloon) as `min(e1, e2)` for each point processed within the updated boundaries.\\nThank me later"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "took me ages to figure this problem out, better draw it on paper as line segments for easier understanding"
                    }
                ]
            },
            {
                "id": 1742319,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Okay, the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!!"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] why expected ouput 2 not 1\\narrow 10 cover all points  "
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Because of [6,7] and [8,12] can\\'t be burst by the same arrow"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a Medium problem after 4 days of easy ones. Let\\'s get our hands dirty!!!"
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "How to Solve this Que?\\n1) Sort the array on the basis of end points.\\n2) Initialize arrows = 1.\\n3) Take points[0][1] as your end.\\n4) Compare each starting point with end.\\n5) If startpoint > end then increment arrows and set end to the endpoint of that row.\\n6) Return arrows.\\n\\nCode:\\n public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\\n\\n        int arrow = 1;\\n        int end = points[0][1];\\n\\n        for(int i = 1; i < points.length; i++) {\\n            if(points[i][0] > end) {\\n                arrow++;\\n                end = points[i][1];\\n            }\\n        }\\n\\n        return arrow;\\n    }"
                    },
                    {
                        "username": "dkashi",
                        "content": "1. Draw a number line. \\n2. Place the balloons on the number line\\n3. See if you can somehow use the overlapping segments to get to the answer. "
                    },
                    {
                        "username": "dadick",
                        "content": "Could someone please share thoughts on why  `a>b` is slower than `Integer.compare(a,b)`?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I wanted to shoot at where most intervals intersect, and then shoot at the second-most place, etc. But in fact only shooting at **start** or **end** works already, just need to think how to.\\n**Hints**:\\n1.Do a few pen&paper examples.\\n2.Pick a way of sorting, options are by *start* or *end*, in *ascending* or *descending*.\\n3.Try shoot at *start* or *end*, see if your sorting works or not."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Hint: Keep shrinking the range. [My solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/2939823/keep-shrinking-the-range/)"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "For those struggling, I\\'ve seen an extremely similar problem in the past. So figuring this out seemed criminally easy. Just keep practicing and surely you\\'ll get more comfortably with them ;)."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yeah! The approach is quite obvious after reading the question\\nNon Overlapping intervals....\\nWe see that if baloons are overlapped then we need only single arrow to burst. So check of non overlapping ballons and increment arrows"
                    }
                ]
            },
            {
                "id": 1742318,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Okay, the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!!"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] why expected ouput 2 not 1\\narrow 10 cover all points  "
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Because of [6,7] and [8,12] can\\'t be burst by the same arrow"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a Medium problem after 4 days of easy ones. Let\\'s get our hands dirty!!!"
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "How to Solve this Que?\\n1) Sort the array on the basis of end points.\\n2) Initialize arrows = 1.\\n3) Take points[0][1] as your end.\\n4) Compare each starting point with end.\\n5) If startpoint > end then increment arrows and set end to the endpoint of that row.\\n6) Return arrows.\\n\\nCode:\\n public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\\n\\n        int arrow = 1;\\n        int end = points[0][1];\\n\\n        for(int i = 1; i < points.length; i++) {\\n            if(points[i][0] > end) {\\n                arrow++;\\n                end = points[i][1];\\n            }\\n        }\\n\\n        return arrow;\\n    }"
                    },
                    {
                        "username": "dkashi",
                        "content": "1. Draw a number line. \\n2. Place the balloons on the number line\\n3. See if you can somehow use the overlapping segments to get to the answer. "
                    },
                    {
                        "username": "dadick",
                        "content": "Could someone please share thoughts on why  `a>b` is slower than `Integer.compare(a,b)`?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I wanted to shoot at where most intervals intersect, and then shoot at the second-most place, etc. But in fact only shooting at **start** or **end** works already, just need to think how to.\\n**Hints**:\\n1.Do a few pen&paper examples.\\n2.Pick a way of sorting, options are by *start* or *end*, in *ascending* or *descending*.\\n3.Try shoot at *start* or *end*, see if your sorting works or not."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Hint: Keep shrinking the range. [My solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/2939823/keep-shrinking-the-range/)"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "For those struggling, I\\'ve seen an extremely similar problem in the past. So figuring this out seemed criminally easy. Just keep practicing and surely you\\'ll get more comfortably with them ;)."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yeah! The approach is quite obvious after reading the question\\nNon Overlapping intervals....\\nWe see that if baloons are overlapped then we need only single arrow to burst. So check of non overlapping ballons and increment arrows"
                    }
                ]
            },
            {
                "id": 1742317,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Okay, the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!!"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] why expected ouput 2 not 1\\narrow 10 cover all points  "
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Because of [6,7] and [8,12] can\\'t be burst by the same arrow"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a Medium problem after 4 days of easy ones. Let\\'s get our hands dirty!!!"
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "How to Solve this Que?\\n1) Sort the array on the basis of end points.\\n2) Initialize arrows = 1.\\n3) Take points[0][1] as your end.\\n4) Compare each starting point with end.\\n5) If startpoint > end then increment arrows and set end to the endpoint of that row.\\n6) Return arrows.\\n\\nCode:\\n public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\\n\\n        int arrow = 1;\\n        int end = points[0][1];\\n\\n        for(int i = 1; i < points.length; i++) {\\n            if(points[i][0] > end) {\\n                arrow++;\\n                end = points[i][1];\\n            }\\n        }\\n\\n        return arrow;\\n    }"
                    },
                    {
                        "username": "dkashi",
                        "content": "1. Draw a number line. \\n2. Place the balloons on the number line\\n3. See if you can somehow use the overlapping segments to get to the answer. "
                    },
                    {
                        "username": "dadick",
                        "content": "Could someone please share thoughts on why  `a>b` is slower than `Integer.compare(a,b)`?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I wanted to shoot at where most intervals intersect, and then shoot at the second-most place, etc. But in fact only shooting at **start** or **end** works already, just need to think how to.\\n**Hints**:\\n1.Do a few pen&paper examples.\\n2.Pick a way of sorting, options are by *start* or *end*, in *ascending* or *descending*.\\n3.Try shoot at *start* or *end*, see if your sorting works or not."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Hint: Keep shrinking the range. [My solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/2939823/keep-shrinking-the-range/)"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "For those struggling, I\\'ve seen an extremely similar problem in the past. So figuring this out seemed criminally easy. Just keep practicing and surely you\\'ll get more comfortably with them ;)."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yeah! The approach is quite obvious after reading the question\\nNon Overlapping intervals....\\nWe see that if baloons are overlapped then we need only single arrow to burst. So check of non overlapping ballons and increment arrows"
                    }
                ]
            },
            {
                "id": 1742277,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Okay, the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!!"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] why expected ouput 2 not 1\\narrow 10 cover all points  "
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Because of [6,7] and [8,12] can\\'t be burst by the same arrow"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a Medium problem after 4 days of easy ones. Let\\'s get our hands dirty!!!"
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "How to Solve this Que?\\n1) Sort the array on the basis of end points.\\n2) Initialize arrows = 1.\\n3) Take points[0][1] as your end.\\n4) Compare each starting point with end.\\n5) If startpoint > end then increment arrows and set end to the endpoint of that row.\\n6) Return arrows.\\n\\nCode:\\n public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\\n\\n        int arrow = 1;\\n        int end = points[0][1];\\n\\n        for(int i = 1; i < points.length; i++) {\\n            if(points[i][0] > end) {\\n                arrow++;\\n                end = points[i][1];\\n            }\\n        }\\n\\n        return arrow;\\n    }"
                    },
                    {
                        "username": "dkashi",
                        "content": "1. Draw a number line. \\n2. Place the balloons on the number line\\n3. See if you can somehow use the overlapping segments to get to the answer. "
                    },
                    {
                        "username": "dadick",
                        "content": "Could someone please share thoughts on why  `a>b` is slower than `Integer.compare(a,b)`?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I wanted to shoot at where most intervals intersect, and then shoot at the second-most place, etc. But in fact only shooting at **start** or **end** works already, just need to think how to.\\n**Hints**:\\n1.Do a few pen&paper examples.\\n2.Pick a way of sorting, options are by *start* or *end*, in *ascending* or *descending*.\\n3.Try shoot at *start* or *end*, see if your sorting works or not."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Hint: Keep shrinking the range. [My solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/2939823/keep-shrinking-the-range/)"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "For those struggling, I\\'ve seen an extremely similar problem in the past. So figuring this out seemed criminally easy. Just keep practicing and surely you\\'ll get more comfortably with them ;)."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yeah! The approach is quite obvious after reading the question\\nNon Overlapping intervals....\\nWe see that if baloons are overlapped then we need only single arrow to burst. So check of non overlapping ballons and increment arrows"
                    }
                ]
            },
            {
                "id": 1742268,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Okay, the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!!"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] why expected ouput 2 not 1\\narrow 10 cover all points  "
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Because of [6,7] and [8,12] can\\'t be burst by the same arrow"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a Medium problem after 4 days of easy ones. Let\\'s get our hands dirty!!!"
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "How to Solve this Que?\\n1) Sort the array on the basis of end points.\\n2) Initialize arrows = 1.\\n3) Take points[0][1] as your end.\\n4) Compare each starting point with end.\\n5) If startpoint > end then increment arrows and set end to the endpoint of that row.\\n6) Return arrows.\\n\\nCode:\\n public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\\n\\n        int arrow = 1;\\n        int end = points[0][1];\\n\\n        for(int i = 1; i < points.length; i++) {\\n            if(points[i][0] > end) {\\n                arrow++;\\n                end = points[i][1];\\n            }\\n        }\\n\\n        return arrow;\\n    }"
                    },
                    {
                        "username": "dkashi",
                        "content": "1. Draw a number line. \\n2. Place the balloons on the number line\\n3. See if you can somehow use the overlapping segments to get to the answer. "
                    },
                    {
                        "username": "dadick",
                        "content": "Could someone please share thoughts on why  `a>b` is slower than `Integer.compare(a,b)`?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I wanted to shoot at where most intervals intersect, and then shoot at the second-most place, etc. But in fact only shooting at **start** or **end** works already, just need to think how to.\\n**Hints**:\\n1.Do a few pen&paper examples.\\n2.Pick a way of sorting, options are by *start* or *end*, in *ascending* or *descending*.\\n3.Try shoot at *start* or *end*, see if your sorting works or not."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Hint: Keep shrinking the range. [My solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/2939823/keep-shrinking-the-range/)"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "For those struggling, I\\'ve seen an extremely similar problem in the past. So figuring this out seemed criminally easy. Just keep practicing and surely you\\'ll get more comfortably with them ;)."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yeah! The approach is quite obvious after reading the question\\nNon Overlapping intervals....\\nWe see that if baloons are overlapped then we need only single arrow to burst. So check of non overlapping ballons and increment arrows"
                    }
                ]
            },
            {
                "id": 1742182,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Okay, the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!!"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] why expected ouput 2 not 1\\narrow 10 cover all points  "
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Because of [6,7] and [8,12] can\\'t be burst by the same arrow"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a Medium problem after 4 days of easy ones. Let\\'s get our hands dirty!!!"
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "How to Solve this Que?\\n1) Sort the array on the basis of end points.\\n2) Initialize arrows = 1.\\n3) Take points[0][1] as your end.\\n4) Compare each starting point with end.\\n5) If startpoint > end then increment arrows and set end to the endpoint of that row.\\n6) Return arrows.\\n\\nCode:\\n public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\\n\\n        int arrow = 1;\\n        int end = points[0][1];\\n\\n        for(int i = 1; i < points.length; i++) {\\n            if(points[i][0] > end) {\\n                arrow++;\\n                end = points[i][1];\\n            }\\n        }\\n\\n        return arrow;\\n    }"
                    },
                    {
                        "username": "dkashi",
                        "content": "1. Draw a number line. \\n2. Place the balloons on the number line\\n3. See if you can somehow use the overlapping segments to get to the answer. "
                    },
                    {
                        "username": "dadick",
                        "content": "Could someone please share thoughts on why  `a>b` is slower than `Integer.compare(a,b)`?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I wanted to shoot at where most intervals intersect, and then shoot at the second-most place, etc. But in fact only shooting at **start** or **end** works already, just need to think how to.\\n**Hints**:\\n1.Do a few pen&paper examples.\\n2.Pick a way of sorting, options are by *start* or *end*, in *ascending* or *descending*.\\n3.Try shoot at *start* or *end*, see if your sorting works or not."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Hint: Keep shrinking the range. [My solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/2939823/keep-shrinking-the-range/)"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "For those struggling, I\\'ve seen an extremely similar problem in the past. So figuring this out seemed criminally easy. Just keep practicing and surely you\\'ll get more comfortably with them ;)."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yeah! The approach is quite obvious after reading the question\\nNon Overlapping intervals....\\nWe see that if baloons are overlapped then we need only single arrow to burst. So check of non overlapping ballons and increment arrows"
                    }
                ]
            },
            {
                "id": 1742144,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Okay, the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!!"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] why expected ouput 2 not 1\\narrow 10 cover all points  "
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Because of [6,7] and [8,12] can\\'t be burst by the same arrow"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a Medium problem after 4 days of easy ones. Let\\'s get our hands dirty!!!"
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "How to Solve this Que?\\n1) Sort the array on the basis of end points.\\n2) Initialize arrows = 1.\\n3) Take points[0][1] as your end.\\n4) Compare each starting point with end.\\n5) If startpoint > end then increment arrows and set end to the endpoint of that row.\\n6) Return arrows.\\n\\nCode:\\n public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\\n\\n        int arrow = 1;\\n        int end = points[0][1];\\n\\n        for(int i = 1; i < points.length; i++) {\\n            if(points[i][0] > end) {\\n                arrow++;\\n                end = points[i][1];\\n            }\\n        }\\n\\n        return arrow;\\n    }"
                    },
                    {
                        "username": "dkashi",
                        "content": "1. Draw a number line. \\n2. Place the balloons on the number line\\n3. See if you can somehow use the overlapping segments to get to the answer. "
                    },
                    {
                        "username": "dadick",
                        "content": "Could someone please share thoughts on why  `a>b` is slower than `Integer.compare(a,b)`?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I wanted to shoot at where most intervals intersect, and then shoot at the second-most place, etc. But in fact only shooting at **start** or **end** works already, just need to think how to.\\n**Hints**:\\n1.Do a few pen&paper examples.\\n2.Pick a way of sorting, options are by *start* or *end*, in *ascending* or *descending*.\\n3.Try shoot at *start* or *end*, see if your sorting works or not."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Hint: Keep shrinking the range. [My solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/2939823/keep-shrinking-the-range/)"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "For those struggling, I\\'ve seen an extremely similar problem in the past. So figuring this out seemed criminally easy. Just keep practicing and surely you\\'ll get more comfortably with them ;)."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yeah! The approach is quite obvious after reading the question\\nNon Overlapping intervals....\\nWe see that if baloons are overlapped then we need only single arrow to burst. So check of non overlapping ballons and increment arrows"
                    }
                ]
            },
            {
                "id": 1742139,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Okay, the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!!"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] why expected ouput 2 not 1\\narrow 10 cover all points  "
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Because of [6,7] and [8,12] can\\'t be burst by the same arrow"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a Medium problem after 4 days of easy ones. Let\\'s get our hands dirty!!!"
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "How to Solve this Que?\\n1) Sort the array on the basis of end points.\\n2) Initialize arrows = 1.\\n3) Take points[0][1] as your end.\\n4) Compare each starting point with end.\\n5) If startpoint > end then increment arrows and set end to the endpoint of that row.\\n6) Return arrows.\\n\\nCode:\\n public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\\n\\n        int arrow = 1;\\n        int end = points[0][1];\\n\\n        for(int i = 1; i < points.length; i++) {\\n            if(points[i][0] > end) {\\n                arrow++;\\n                end = points[i][1];\\n            }\\n        }\\n\\n        return arrow;\\n    }"
                    },
                    {
                        "username": "dkashi",
                        "content": "1. Draw a number line. \\n2. Place the balloons on the number line\\n3. See if you can somehow use the overlapping segments to get to the answer. "
                    },
                    {
                        "username": "dadick",
                        "content": "Could someone please share thoughts on why  `a>b` is slower than `Integer.compare(a,b)`?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I wanted to shoot at where most intervals intersect, and then shoot at the second-most place, etc. But in fact only shooting at **start** or **end** works already, just need to think how to.\\n**Hints**:\\n1.Do a few pen&paper examples.\\n2.Pick a way of sorting, options are by *start* or *end*, in *ascending* or *descending*.\\n3.Try shoot at *start* or *end*, see if your sorting works or not."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Hint: Keep shrinking the range. [My solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/2939823/keep-shrinking-the-range/)"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "For those struggling, I\\'ve seen an extremely similar problem in the past. So figuring this out seemed criminally easy. Just keep practicing and surely you\\'ll get more comfortably with them ;)."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yeah! The approach is quite obvious after reading the question\\nNon Overlapping intervals....\\nWe see that if baloons are overlapped then we need only single arrow to burst. So check of non overlapping ballons and increment arrows"
                    }
                ]
            },
            {
                "id": 1742906,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Okay, the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!!"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] why expected ouput 2 not 1\\narrow 10 cover all points  "
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Because of [6,7] and [8,12] can\\'t be burst by the same arrow"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a Medium problem after 4 days of easy ones. Let\\'s get our hands dirty!!!"
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "How to Solve this Que?\\n1) Sort the array on the basis of end points.\\n2) Initialize arrows = 1.\\n3) Take points[0][1] as your end.\\n4) Compare each starting point with end.\\n5) If startpoint > end then increment arrows and set end to the endpoint of that row.\\n6) Return arrows.\\n\\nCode:\\n public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\\n\\n        int arrow = 1;\\n        int end = points[0][1];\\n\\n        for(int i = 1; i < points.length; i++) {\\n            if(points[i][0] > end) {\\n                arrow++;\\n                end = points[i][1];\\n            }\\n        }\\n\\n        return arrow;\\n    }"
                    },
                    {
                        "username": "dkashi",
                        "content": "1. Draw a number line. \\n2. Place the balloons on the number line\\n3. See if you can somehow use the overlapping segments to get to the answer. "
                    },
                    {
                        "username": "dadick",
                        "content": "Could someone please share thoughts on why  `a>b` is slower than `Integer.compare(a,b)`?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I wanted to shoot at where most intervals intersect, and then shoot at the second-most place, etc. But in fact only shooting at **start** or **end** works already, just need to think how to.\\n**Hints**:\\n1.Do a few pen&paper examples.\\n2.Pick a way of sorting, options are by *start* or *end*, in *ascending* or *descending*.\\n3.Try shoot at *start* or *end*, see if your sorting works or not."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Hint: Keep shrinking the range. [My solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/2939823/keep-shrinking-the-range/)"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "For those struggling, I\\'ve seen an extremely similar problem in the past. So figuring this out seemed criminally easy. Just keep practicing and surely you\\'ll get more comfortably with them ;)."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yeah! The approach is quite obvious after reading the question\\nNon Overlapping intervals....\\nWe see that if baloons are overlapped then we need only single arrow to burst. So check of non overlapping ballons and increment arrows"
                    }
                ]
            },
            {
                "id": 1742808,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "Okay, the question is fine but what was the need of y-coordinate in framing the question, could have just said that we have ranges along x-axis that need to be captured. Y axis is just an unnecessary confusion!!!"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[[9,12],[1,10],[4,11],[8,12],[3,9],[6,9],[6,7]] why expected ouput 2 not 1\\narrow 10 cover all points  "
                    },
                    {
                        "username": "Mariia_89",
                        "content": "Because of [6,7] and [8,12] can\\'t be burst by the same arrow"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a Medium problem after 4 days of easy ones. Let\\'s get our hands dirty!!!"
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "How to Solve this Que?\\n1) Sort the array on the basis of end points.\\n2) Initialize arrows = 1.\\n3) Take points[0][1] as your end.\\n4) Compare each starting point with end.\\n5) If startpoint > end then increment arrows and set end to the endpoint of that row.\\n6) Return arrows.\\n\\nCode:\\n public int findMinArrowShots(int[][] points) {\\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\\n\\n        int arrow = 1;\\n        int end = points[0][1];\\n\\n        for(int i = 1; i < points.length; i++) {\\n            if(points[i][0] > end) {\\n                arrow++;\\n                end = points[i][1];\\n            }\\n        }\\n\\n        return arrow;\\n    }"
                    },
                    {
                        "username": "dkashi",
                        "content": "1. Draw a number line. \\n2. Place the balloons on the number line\\n3. See if you can somehow use the overlapping segments to get to the answer. "
                    },
                    {
                        "username": "dadick",
                        "content": "Could someone please share thoughts on why  `a>b` is slower than `Integer.compare(a,b)`?"
                    },
                    {
                        "username": "xeniawann",
                        "content": "I wanted to shoot at where most intervals intersect, and then shoot at the second-most place, etc. But in fact only shooting at **start** or **end** works already, just need to think how to.\\n**Hints**:\\n1.Do a few pen&paper examples.\\n2.Pick a way of sorting, options are by *start* or *end*, in *ascending* or *descending*.\\n3.Try shoot at *start* or *end*, see if your sorting works or not."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Hint: Keep shrinking the range. [My solution](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/2939823/keep-shrinking-the-range/)"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "For those struggling, I\\'ve seen an extremely similar problem in the past. So figuring this out seemed criminally easy. Just keep practicing and surely you\\'ll get more comfortably with them ;)."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yeah! The approach is quite obvious after reading the question\\nNon Overlapping intervals....\\nWe see that if baloons are overlapped then we need only single arrow to burst. So check of non overlapping ballons and increment arrows"
                    }
                ]
            }
        ]
    }
]