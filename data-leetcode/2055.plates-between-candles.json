[
    {
        "title": "Plates Between Candles",
        "question_content": "There is a long table with a line of plates and candles arranged on top of it. You are given a 0-indexed string s consisting of characters '*' and '|' only, where a '*' represents a plate and a '|' represents a candle.\nYou are also given a 0-indexed 2D integer array queries where queries[i] = [lefti, righti] denotes the substring s[lefti...righti] (inclusive). For each query, you need to find the number of plates between candles that are in the substring. A plate is considered between candles if there is at least one candle to its left and at least one candle to its right in the substring.\n\n\tFor example, s = \"||**||**|*\", and a query [3, 8] denotes the substring \"*||**|\". The number of plates between candles in this substring is 2, as each of the two plates has at least one candle in the substring to its left and right.\n\nReturn an integer array answer where answer[i] is the answer to the ith query.\n&nbsp;\nExample 1:\n\nInput: s = \"**|**|***|\", queries = [[2,5],[5,9]]\nOutput: [2,3]\nExplanation:\n- queries[0] has two plates between candles.\n- queries[1] has three plates between candles.\n\nExample 2:\n\nInput: s = \"***|**|*****|**||**|*\", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]\nOutput: [9,0,0,0,0]\nExplanation:\n- queries[0] has nine plates between candles.\n- The other queries have zero plates between candles.\n\n&nbsp;\nConstraints:\n\n\t3 <= s.length <= 105\n\ts consists of '*' and '|' characters.\n\t1 <= queries.length <= 105\n\tqueries[i].length == 2\n\t0 <= lefti <= righti < s.length",
        "solutions": [
            {
                "id": 1549018,
                "title": "java-c-python-binary-search-and-o-q-n-solution",
                "content": "\\n# **Solution 1, Binary Search**\\nFind out indices of candies and add them to a list `A`\\nFor each query `[a,b]`,\\nfind out the candies after `a` and the candies before `b`.\\n\\n`A[i] - A[j] + 1` is the length between two candies,\\n`i - j + 1`is the number of candies.\\n`(A[j] - A[i]) - (j - i)` is the number of plates between two candies.\\n<br>\\n\\n# **Complexity**\\nTime `O(N + QlogN)`\\nSpace `O(N + Q)`\\n<br>\\n\\n\\n**C++**\\n```cpp\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        vector<int> A, res;\\n        for (int i = 0; i < s.size(); ++i)\\n            if (s[i] == \\'|\\')\\n                A.push_back(i);\\n        for (int q = 0; q < queries.size(); ++q) {\\n            int i = lower_bound(A.begin(), A.end(), queries[q][0]) - A.begin();\\n            int j = upper_bound(A.begin(), A.end(), queries[q][1]) - A.begin() - 1;\\n            res.push_back(i < j ? (A[j] - A[i]) - (j - i) : 0);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def platesBetweenCandles(self, s, queries):\\n        A = [i for i,c in enumerate(s) if c == \\'|\\']\\n        res = []\\n        for a,b in queries:\\n            i = bisect.bisect_left(A, a)\\n            j = bisect.bisect(A, b) - 1\\n            res.append((A[j] - A[i]) - (j - i) if i < j else 0)\\n        return res\\n```\\n<br><br>\\n\\n# **Solution 2, Next Candle**\\n\\nFor each indice, find the nearest candle index on the left and on the right.\\n\\nExample:\\n```\\n                        0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20\\n\\n                        *  *  *  |  *  *  |  *  *  *   *   *   |   *   *   |   |   *   *   |   *\\nnearest right candle:   3  3  3  3  6  6  6  12 12 12  12 12  12  15  15  15   16  19  19  19  -\\nnearest left candle:    -  -  -  3  3  3  6  6  6  6   6  6   12  12  12  15  16  16  16   19  19\\ncandle count:           0  0  0  1  1  1  2  2  2  2   2  2    3   3   3   4   5   5   5   6   6\\n```\\n\\nTime `O(N + Q)`\\nSpace `O(N + Q)`\\n<br>\\n\\n**Java**\\nVote for @vyshnavkr solution\\n```java\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n\\n\\n        int n = s.length();\\n\\n        int[] nearestRightCandle = new int[n];\\n        int[] nearestLeftCandle = new int[n];\\n        int[] candleCount = new int[n];\\n        int[] ans = new int[queries.length];\\n\\n        int candle = -1;\\n        for (int i = 0; i < n; ++i) {\\n            if (s.charAt(i) == \\'|\\') {\\n                candle = i;\\n            }\\n            nearestLeftCandle[i] = candle;\\n        }\\n\\n        candle = -1;\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (s.charAt(i) == \\'|\\') {\\n                candle = i;\\n            }\\n            nearestRightCandle[i] = candle;\\n        }\\n\\n        int count = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (s.charAt(i) == \\'|\\') {\\n                ++count;\\n            }\\n            candleCount[i] = count;\\n        }\\n\\n        int idx = 0;\\n        for (int[] query : queries) {\\n            int left = query[0];\\n            int right = query[1];\\n\\n            int leftCandle = nearestRightCandle[left];\\n            int rightCandle = nearestLeftCandle[right];\\n\\n            int d = 0;\\n            if (leftCandle == -1 || rightCandle == -1) {\\n                ans[idx] = 0;\\n            } else {\\n                d = rightCandle - leftCandle;\\n                if (d > 1) {\\n                    ans[idx] = rightCandle - leftCandle + 1 - (candleCount[rightCandle] - candleCount[leftCandle] + 1);\\n                } else {\\n                    ans[idx] = 0;\\n                }\\n            }\\n\\n            ++idx;\\n        }\\n\\n        return ans;\\n    }\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```cpp\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        vector<int> A, res;\\n        for (int i = 0; i < s.size(); ++i)\\n            if (s[i] == \\'|\\')\\n                A.push_back(i);\\n        for (int q = 0; q < queries.size(); ++q) {\\n            int i = lower_bound(A.begin(), A.end(), queries[q][0]) - A.begin();\\n            int j = upper_bound(A.begin(), A.end(), queries[q][1]) - A.begin() - 1;\\n            res.push_back(i < j ? (A[j] - A[i]) - (j - i) : 0);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def platesBetweenCandles(self, s, queries):\\n        A = [i for i,c in enumerate(s) if c == \\'|\\']\\n        res = []\\n        for a,b in queries:\\n            i = bisect.bisect_left(A, a)\\n            j = bisect.bisect(A, b) - 1\\n            res.append((A[j] - A[i]) - (j - i) if i < j else 0)\\n        return res\\n```\n```\\n                        0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20\\n\\n                        *  *  *  |  *  *  |  *  *  *   *   *   |   *   *   |   |   *   *   |   *\\nnearest right candle:   3  3  3  3  6  6  6  12 12 12  12 12  12  15  15  15   16  19  19  19  -\\nnearest left candle:    -  -  -  3  3  3  6  6  6  6   6  6   12  12  12  15  16  16  16   19  19\\ncandle count:           0  0  0  1  1  1  2  2  2  2   2  2    3   3   3   4   5   5   5   6   6\\n```\n```java\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n\\n\\n        int n = s.length();\\n\\n        int[] nearestRightCandle = new int[n];\\n        int[] nearestLeftCandle = new int[n];\\n        int[] candleCount = new int[n];\\n        int[] ans = new int[queries.length];\\n\\n        int candle = -1;\\n        for (int i = 0; i < n; ++i) {\\n            if (s.charAt(i) == \\'|\\') {\\n                candle = i;\\n            }\\n            nearestLeftCandle[i] = candle;\\n        }\\n\\n        candle = -1;\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (s.charAt(i) == \\'|\\') {\\n                candle = i;\\n            }\\n            nearestRightCandle[i] = candle;\\n        }\\n\\n        int count = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (s.charAt(i) == \\'|\\') {\\n                ++count;\\n            }\\n            candleCount[i] = count;\\n        }\\n\\n        int idx = 0;\\n        for (int[] query : queries) {\\n            int left = query[0];\\n            int right = query[1];\\n\\n            int leftCandle = nearestRightCandle[left];\\n            int rightCandle = nearestLeftCandle[right];\\n\\n            int d = 0;\\n            if (leftCandle == -1 || rightCandle == -1) {\\n                ans[idx] = 0;\\n            } else {\\n                d = rightCandle - leftCandle;\\n                if (d > 1) {\\n                    ans[idx] = rightCandle - leftCandle + 1 - (candleCount[rightCandle] - candleCount[leftCandle] + 1);\\n                } else {\\n                    ans[idx] = 0;\\n                }\\n            }\\n\\n            ++idx;\\n        }\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1586720,
                "title": "intuition-explained-prefix-sum-and-binary-search-c-clean-code",
                "content": "# **Approach 1: Prefix Sum & Binary Search**\\n\\n**Intuition :**\\n\\n* Idea here is to pre-compute and store the count of `| (candles)` & `* (plates)` for every index from i = 0 to current.  \\n* Now, we process each query. Since we need **closest candle** from *start towards right* and closest candle from *end towards left*. \\n\\t\\t\\n\\t\\tEx :  \\n\\t\\tstart                         end\\n\\t\\t\\t*    *    |    *    |    *   |\\n\\n\\t\\t-> Closest `|` from start is at (start + 2)\\n\\t\\t-> Closest \\'|\\' from end is at end itself\\n\\t\\t\\n* As we have pre-computed count of candles | and plates * , we can easily search index of next plate to left and right from current index. \\n\\t*  Since count is monotonically increasing, we can perform binary search. \\n\\t\\t\\n\\t\\t\\tEx : s = `**|*|*|` , \\n\\t\\t\\there count = [ (0, 1), (0, 2), (1, 2), (1,3), (2, 3), (2,4), (3, 4)]\\n\\t\\t\\t\\n\\t\\t\\t-> say start = 1, end  = 6\\n\\t\\t\\t-> next candle from start is at i = 2 -> count[2] = (1,2). \\n\\t\\t\\t-> Clearly we can see count of candle at i = 2 is one greater than at i = start i.e 0\\n\\t\\t\\t\\n\\t\\t\\tSimilarly, we can do for end, just in backward direction. \\n\\t\\t\\tAnd with count of candles one lesser than value at current i.e end\\n\\t\\t\\t\\n\\t\\t* Thus, if we have candle at start/end, no need to search.\\n\\t\\t* Else, we search for closest candle using **binary search**, \\n\\t\\t\\t* with count of candles **one greater** than current, for *start*\\n\\t\\t\\t* with count of candles **one lesser** than current, for *end*\\n\\t\\t* `lower_bound` in case of start \\n\\t\\t* `upper_boumd` in case of end\\n\\n* Lets do a dry run on TC: \\n\\n\\t\\tEx : s = \"* * | * * | * * * |\" , query = [[2,5], [5,9]]\\n\\t\\t\\n\\t\\tindex     :   0  1  2  3  4  5  6  7  8  9\\n\\t\\t  s       :  \\'*  *  |  *  *  |  *  *  |  *\\'\\n\\n\\t\\tcandles   :   0  0  1  1  1  2  2  2  3  3\\n\\t\\tplates    :   1  2  2  3  4  4  5  6  6  7\\n\\t\\t\\n\\t\\t0. query[0] : [2, 5]\\n\\t\\t\\t\\n\\t\\t\\t=> start = 2, next candle at i = 2\\n\\t\\t\\t=> end = 5, prev candle at i = 5\\n\\t\\t\\t\\n\\t\\t\\tThus, count of plates from start to end = plates[5] - plates[2] = 2\\n\\n\\t\\t1. query[1] : [5, 9]\\n\\n\\t\\t\\t=> start = 5, next candle at i = 5\\n\\t\\t\\t=> end = 9, prev candle at i = 8\\n\\t\\t\\t\\n\\t\\t\\tThus, count of plates from start to end = plates[8] - plates[5] = 2\\n\\t\\t\\n\\n# Code :\\n\\n```\\nvector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        \\n\\tint n = s.size();\\n\\t\\n\\t// Here count[i][0] -> count of candles from 0 -> i\\n\\t// and count[i][1] -> count of plates from 0 -> i\\n\\t\\n\\tvector<vector<int>> count(n, vector<int>(2));\\n\\n\\tcount[0] = s[0] == \\'*\\' ? vector<int>{0, 1} : vector<int>{1, 0};\\n\\tfor(int i=1; i<n; i++) {\\n\\t\\tcount[i] = s[i] == \\'*\\' ? vector<int>{count[i-1][0], count[i-1][1] + 1} : vector<int>{count[i-1][0] + 1, count[i-1][1]};\\n\\t}\\n\\n\\tvector<int> res;\\n\\n\\tfor(auto& query : queries) {\\n\\t\\tint lo = query[0];\\n\\t\\tint hi = query[1];\\n\\n\\t\\tif(s[lo] == \\'*\\') {\\n\\t\\t\\tlo = lower_bound(count.begin() + lo, count.begin() + hi, vector<int>{count[lo][0]+1, -1}) - count.begin();\\n\\t\\t}\\n\\n\\t\\tif(s[hi] == \\'*\\') {\\n\\t\\t\\thi = upper_bound(count.begin() + lo, count.begin() + hi - 1, vector<int>{count[hi][0], -1}) - count.begin();\\n\\t\\t}\\n\\n\\t\\tres.push_back(count[hi][1] - count[lo][1]);\\n\\t}\\n\\n\\treturn res;\\n}\\n```\\n**Complexity:**\\n\\n* **Time** : `O(N + Q * log N)` , \\n\\n\\t* *N* : size of string s\\n\\t* *Q* : number of queries\\n\\n* **Space** : `O(N)` , *size of count vector*\\n\\n\\n-----------------------------------------------------------------------------------\\nThis approach is good, but we can do much better. Lets see how we will approach and solve it efficiently.\\n\\n-----------------------------------------------------------------------------------\\n# **Approach 2: Prefix Sum**\\n\\n**Intuition:**\\n\\n* Idea is similar to the previous one. But we have to every time do binary search to get closest (prev / next) plate. \\n\\n* So, to tackle this, we can pre-compute and store the index of `prevCandle` and `nextCandle`. \\n* Also, we will require count of candles from i = 0 to current index. So, we store that in `prefixSum`. \\n* Rest of the logic is same as previous approach and straight forward.\\n\\nLets now do a dry run for a test case : \\n\\t\\n\\t   Ex: s = \"* * | * * | * * * |\" , queries : [[2,5],[5,9]]\\n\\t   \\n\\t   -> First we preprocess and calculate index of prevCandle, nextCandle, \\n\\t   -> and count of \\'*\\' till current index in prefixSum vector\\n\\t   \\n\\t\\tindex     :   0  1  2  3  4  5  6  7  8  9\\n\\t\\t  s       :  \\'*  *  |  *  *  |  *  *  *  |\\'\\n\\n\\t\\tprev      :  -1 -1  2  2  2  5  5  5  5  9\\n\\t\\tnext      :   2  2  2  5  5  5  9  9  9  9\\n\\n\\t\\tprefixSum :   1  2  2  3  4  4  5  6  7  7\\n\\t\\t\\n\\t\\t0. query[0] = [2,5] \\n\\t\\t\\t\\t=> start = nextCandle[2] = 2\\n\\t\\t\\t\\t=> end = prevCandle[5] =  5\\n\\t\\t\\t\\tThus, answer[0] = prefixSum[end] - prefixSum[start] = 4 - 2 = 2\\n\\t\\t\\t\\t\\n\\t\\t1. query[1] = [5,9] \\n\\t\\t\\t\\t=> start = nextCandle[5] = 5\\n\\t\\t\\t\\t=> end = prevCandle[9] =  9\\n\\t\\t\\t\\tThus, answer[1] = prefixSum[end] - prefixSum[start] = 7 - 4 = 3\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n# Code:\\n\\n```\\nvector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        \\n\\tint n = s.size();\\n\\n\\tvector<int> nextCandle(n, n), prevCandle(n, -1), prefixSum(n, 0);\\n\\t\\n\\tfor(int i=0; i<n; i++) {\\n\\n\\t\\tprevCandle[i] = (s[i] == \\'*\\') ? ((i == 0) ? prevCandle[i] : prevCandle[i-1]) : i;\\n\\t\\tnextCandle[n-i-1] = (s[n-i-1] == \\'*\\') ? ((i == 0) ? nextCandle[n-i-1] : nextCandle[n-i]) : n-i-1;\\n\\n\\t\\tprefixSum[i] = (i == 0) ? (s[i] == \\'*\\') : prefixSum[i-1] + (s[i] == \\'*\\');\\n\\t}\\n\\n\\tvector<int> answer;\\n\\n\\tfor(auto& query : queries) {\\n\\n\\t\\tint start = nextCandle[query[0]] > query[1] ? 0 : nextCandle[query[0]];\\n\\t\\tint end = prevCandle[query[1]] < query[0] ? 0 : prevCandle[query[1]];\\n\\n\\t\\tanswer.push_back(prefixSum[end] - prefixSum[start]);\\n\\t}\\n\\n\\treturn answer;\\n}\\n```\\n\\n**Complexity:**\\n\\n* **Time** : `O(N + Q)` , \\n\\n\\t* *N* : size of string s\\n\\t* *Q* : number of queries\\n\\n* **Space** : `O(N + N + N)` = `O(N)` , *size of prevCandle, nextCandle & prefixSum*\\n\\n\\n*Writing such post takes a lot of effort and time.*\\n***So, it you find this helpful, do consider giving it a like. :)***",
                "solutionTags": [
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nvector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        \\n\\tint n = s.size();\\n\\t\\n\\t// Here count[i][0] -> count of candles from 0 -> i\\n\\t// and count[i][1] -> count of plates from 0 -> i\\n\\t\\n\\tvector<vector<int>> count(n, vector<int>(2));\\n\\n\\tcount[0] = s[0] == \\'*\\' ? vector<int>{0, 1} : vector<int>{1, 0};\\n\\tfor(int i=1; i<n; i++) {\\n\\t\\tcount[i] = s[i] == \\'*\\' ? vector<int>{count[i-1][0], count[i-1][1] + 1} : vector<int>{count[i-1][0] + 1, count[i-1][1]};\\n\\t}\\n\\n\\tvector<int> res;\\n\\n\\tfor(auto& query : queries) {\\n\\t\\tint lo = query[0];\\n\\t\\tint hi = query[1];\\n\\n\\t\\tif(s[lo] == \\'*\\') {\\n\\t\\t\\tlo = lower_bound(count.begin() + lo, count.begin() + hi, vector<int>{count[lo][0]+1, -1}) - count.begin();\\n\\t\\t}\\n\\n\\t\\tif(s[hi] == \\'*\\') {\\n\\t\\t\\thi = upper_bound(count.begin() + lo, count.begin() + hi - 1, vector<int>{count[hi][0], -1}) - count.begin();\\n\\t\\t}\\n\\n\\t\\tres.push_back(count[hi][1] - count[lo][1]);\\n\\t}\\n\\n\\treturn res;\\n}\\n```\n```\\nvector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        \\n\\tint n = s.size();\\n\\n\\tvector<int> nextCandle(n, n), prevCandle(n, -1), prefixSum(n, 0);\\n\\t\\n\\tfor(int i=0; i<n; i++) {\\n\\n\\t\\tprevCandle[i] = (s[i] == \\'*\\') ? ((i == 0) ? prevCandle[i] : prevCandle[i-1]) : i;\\n\\t\\tnextCandle[n-i-1] = (s[n-i-1] == \\'*\\') ? ((i == 0) ? nextCandle[n-i-1] : nextCandle[n-i]) : n-i-1;\\n\\n\\t\\tprefixSum[i] = (i == 0) ? (s[i] == \\'*\\') : prefixSum[i-1] + (s[i] == \\'*\\');\\n\\t}\\n\\n\\tvector<int> answer;\\n\\n\\tfor(auto& query : queries) {\\n\\n\\t\\tint start = nextCandle[query[0]] > query[1] ? 0 : nextCandle[query[0]];\\n\\t\\tint end = prevCandle[query[1]] < query[0] ? 0 : prevCandle[query[1]];\\n\\n\\t\\tanswer.push_back(prefixSum[end] - prefixSum[start]);\\n\\t}\\n\\n\\treturn answer;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1549223,
                "title": "binary-search-vs-prefix-sum",
                "content": "#### Approach 1: Binary Search\\nWe remember the position of each candle. Then, we binary-search for the leftmost (first) and rightmost (last) candle for each query.\\n\\nNow, we know how many total items are between the first and last candle, and how many candles are there.\\n\\nThe time complexity of this solution is *O(n log m)*, where *n* is the number of queries, and *m* - the length of the string.\\n\\n**C++**\\n```cpp\\nvector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n    vector<int> c, res;\\n    for (int i = 0; i < s.size(); ++i)\\n        if (s[i] == \\'|\\')\\n            c.push_back(i);\\n    for (auto &q : queries) {\\n        auto it_l = lower_bound(begin(c), end(c), q[0]);\\n        auto it_r = it_l == end(c) ? it_l : prev(upper_bound(it_l, end(c), q[1]));\\n        res.push_back(it_l < it_r ? *it_r - *it_l - (it_r - it_l) : 0);\\n    }\\n    return res;\\n}\\n```\\n#### Approach 2: Prefix Sum\\nWe can count candles between two positions in O(1) using a prefix sum array `dp`. Before we can do that, we need to find the leftmost (first) and rightmost (last) candle for each query.\\n\\nWe can also do it in O(1) by tracking `next` and `prev` candle for each position on the table.\\n\\nThe time complexity of this solution is *O(n + m)*, where *n* is the number of queries, and *m* - the length of the string.\\n\\n**C++**\\n```cpp\\nvector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n    vector<int> psum(s.size() + 1), next(s.size() + 1, INT_MAX), prev(s.size() + 1), res;\\n    for (int i = 0; i < s.size(); ++i) {\\n        psum[i + 1] = psum[i] + (s[i] == \\'|\\');\\n        prev[i + 1] = s[i] == \\'|\\' ? i : prev[i];\\n    }\\n    for (int i = s.size() - 1; i >= 0; --i)\\n        next[i] = s[i] == \\'|\\' ? i : next[i + 1];\\n    for (auto &q : queries) {\\n        int l = next[q[0]], r = prev[q[1] + 1];\\n        res.push_back(l < r ? r - l - (psum[r] - psum[l]) : 0);\\n    }\\n    return res;\\n}  \\n```\\n**Java**\\n```java\\npublic int[] platesBetweenCandles(String s, int[][] queries) {\\n    int psum[] = new int[s.length() + 1];\\n    int next[] = new int[s.length() + 1], prev[] = new int[s.length() + 1];\\n    Arrays.fill(next, Integer.MAX_VALUE);\\n    int res[] = new int[queries.length];\\n    for (int i = 0; i < s.length(); ++i) {\\n        psum[i + 1] = psum[i] + (s.charAt(i) == \\'|\\' ? 1 : 0);\\n        prev[i + 1] = s.charAt(i) == \\'|\\' ? i : prev[i];\\n    }\\n    for (int i = s.length() - 1; i >= 0; --i)\\n        next[i] = s.charAt(i) == \\'|\\' ? i : next[i + 1];\\n    for (int j = 0; j < queries.length; ++j) {\\n        int l = next[queries[j][0]], r = prev[queries[j][1] + 1];\\n        res[j] = l < r ? r - l - (psum[r] - psum[l]) : 0;\\n    }        \\n    return res;\\n}\\n```\\n**Python**\\n```python\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        psum, next, prev = [0] * (len(s) + 1), [inf] * (len(s) + 1), [0] * (len(s) + 1)\\n        res = []\\n        for i, ch in enumerate(s):\\n            psum[i + 1] = psum[i] + (ch == \\'|\\')\\n            prev[i + 1] = i if ch == \\'|\\' else prev[i]\\n        for i, ch in reversed(list(enumerate(s))):\\n            next[i] = i if ch == \\'|\\' else next[i + 1]\\n        for q in queries:\\n            l, r = next[q[0]], prev[q[1] + 1]\\n            res.append(r - l - (psum[r] - psum[l]) if l < r else 0)\\n        return res\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```cpp\\nvector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n    vector<int> c, res;\\n    for (int i = 0; i < s.size(); ++i)\\n        if (s[i] == \\'|\\')\\n            c.push_back(i);\\n    for (auto &q : queries) {\\n        auto it_l = lower_bound(begin(c), end(c), q[0]);\\n        auto it_r = it_l == end(c) ? it_l : prev(upper_bound(it_l, end(c), q[1]));\\n        res.push_back(it_l < it_r ? *it_r - *it_l - (it_r - it_l) : 0);\\n    }\\n    return res;\\n}\\n```\n```cpp\\nvector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n    vector<int> psum(s.size() + 1), next(s.size() + 1, INT_MAX), prev(s.size() + 1), res;\\n    for (int i = 0; i < s.size(); ++i) {\\n        psum[i + 1] = psum[i] + (s[i] == \\'|\\');\\n        prev[i + 1] = s[i] == \\'|\\' ? i : prev[i];\\n    }\\n    for (int i = s.size() - 1; i >= 0; --i)\\n        next[i] = s[i] == \\'|\\' ? i : next[i + 1];\\n    for (auto &q : queries) {\\n        int l = next[q[0]], r = prev[q[1] + 1];\\n        res.push_back(l < r ? r - l - (psum[r] - psum[l]) : 0);\\n    }\\n    return res;\\n}  \\n```\n```java\\npublic int[] platesBetweenCandles(String s, int[][] queries) {\\n    int psum[] = new int[s.length() + 1];\\n    int next[] = new int[s.length() + 1], prev[] = new int[s.length() + 1];\\n    Arrays.fill(next, Integer.MAX_VALUE);\\n    int res[] = new int[queries.length];\\n    for (int i = 0; i < s.length(); ++i) {\\n        psum[i + 1] = psum[i] + (s.charAt(i) == \\'|\\' ? 1 : 0);\\n        prev[i + 1] = s.charAt(i) == \\'|\\' ? i : prev[i];\\n    }\\n    for (int i = s.length() - 1; i >= 0; --i)\\n        next[i] = s.charAt(i) == \\'|\\' ? i : next[i + 1];\\n    for (int j = 0; j < queries.length; ++j) {\\n        int l = next[queries[j][0]], r = prev[queries[j][1] + 1];\\n        res[j] = l < r ? r - l - (psum[r] - psum[l]) : 0;\\n    }        \\n    return res;\\n}\\n```\n```python\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        psum, next, prev = [0] * (len(s) + 1), [inf] * (len(s) + 1), [0] * (len(s) + 1)\\n        res = []\\n        for i, ch in enumerate(s):\\n            psum[i + 1] = psum[i] + (ch == \\'|\\')\\n            prev[i + 1] = i if ch == \\'|\\' else prev[i]\\n        for i, ch in reversed(list(enumerate(s))):\\n            next[i] = i if ch == \\'|\\' else next[i + 1]\\n        for q in queries:\\n            l, r = next[q[0]], prev[q[1] + 1]\\n            res.append(r - l - (psum[r] - psum[l]) if l < r else 0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549042,
                "title": "c-easy-code-detailed-algo-explanation",
                "content": "We can approach the problem using concept of Prefix Sum Array which will result in the constant time calculation of a query.\\n\\n* Initialize two arrays leftBound and rightBound to store the count of * that are right to the most recent | and the count of * that are left to the most recent | respectively.\\n\\n* Initialize two variables, count and total to update the arrays leftBound and rightBound.\\n\\n* Traverse the given string S and if the current character is \\u2018|\\u2018 then assign the value of curr to the variable total. Otherwise, increment totals by 1 and then assign the value of curr to the rightBound[i].\\n\\n* Update the value of curr and totals to 0.\\n\\n* Traverse the string in the reverse order and in each iteration if the current character is \\u2018|\\u2018 then update the value of curr to the total. Otherwise, increment the value of total by 1 and then update the value of curr to the leftBound[i].\\n\\n* Now, traverse the given array of queries and for each query store value `(leftBound[L] + rightBound[R] - total)` into our answer array and return it.\\n\\nBelow is the working code:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string S, vector<vector<int>>& Q) {\\n        int N = S.size(), count = 0, total = 0;\\n        vector<int> leftBound(N,0);\\n        vector<int> rightBound(N,0);\\n        for(int i = 0; i < N; i++) {\\n           if (S[i] == \\'|\\')\\n             count = total;\\n           else if (S[i] == \\'*\\')\\n             total++;\\n           rightBound[i] = count;\\n        }\\n        count = 0;\\n        total = 0;\\n        for(int i = N - 1; i >= 0; i--) {\\n            if (S[i] == \\'|\\')\\n                count = total;\\n            else if (S[i] == \\'*\\')\\n                total++;\\n            leftBound[i] = count;\\n        }\\n        vector<int> ans;\\n        for(int q = 0; q < Q.size(); q++) {\\n            int L = Q[q][0];\\n            int R = Q[q][1];\\n            count = leftBound[L] + rightBound[R] - total;\\n            if(count < 0) count = 0;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIt\\'s time complexity would be O(m + n) and space O(n). Please do upvote the solution if it helped you :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string S, vector<vector<int>>& Q) {\\n        int N = S.size(), count = 0, total = 0;\\n        vector<int> leftBound(N,0);\\n        vector<int> rightBound(N,0);\\n        for(int i = 0; i < N; i++) {\\n           if (S[i] == \\'|\\')\\n             count = total;\\n           else if (S[i] == \\'*\\')\\n             total++;\\n           rightBound[i] = count;\\n        }\\n        count = 0;\\n        total = 0;\\n        for(int i = N - 1; i >= 0; i--) {\\n            if (S[i] == \\'|\\')\\n                count = total;\\n            else if (S[i] == \\'*\\')\\n                total++;\\n            leftBound[i] = count;\\n        }\\n        vector<int> ans;\\n        for(int q = 0; q < Q.size(); q++) {\\n            int L = Q[q][0];\\n            int R = Q[q][1];\\n            count = leftBound[L] + rightBound[R] - total;\\n            if(count < 0) count = 0;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549598,
                "title": "concise-java-treemap-12-lines",
                "content": "The solution is straightforward but let me know if something is not clear.\\n```java\\n public int[] platesBetweenCandles(String s, int[][] queries) {\\n        TreeMap<Integer, Integer> m = new TreeMap<>();\\n        for (int i = 0, count = 0; i < s.length(); i++)\\n            if (s.charAt(i) == \\'|\\')\\n                m.put(i, count);\\n            else count++;\\n        int[] r = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            Map.Entry<Integer, Integer> left = m.ceilingEntry(queries[i][0]), right = m.floorEntry(queries[i][1]);\\n            if (left != null && right != null)\\n                r[i] = Math.max(0, right.getValue() - left.getValue());\\n        }\\n        return r;\\n    }",
                "solutionTags": [],
                "code": "The solution is straightforward but let me know if something is not clear.\\n```java\\n public int[] platesBetweenCandles(String s, int[][] queries) {\\n        TreeMap<Integer, Integer> m = new TreeMap<>();\\n        for (int i = 0, count = 0; i < s.length(); i++)\\n            if (s.charAt(i) == \\'|\\')\\n                m.put(i, count);\\n            else count++;\\n        int[] r = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            Map.Entry<Integer, Integer> left = m.ceilingEntry(queries[i][0]), right = m.floorEntry(queries[i][1]);\\n            if (left != null && right != null)\\n                r[i] = Math.max(0, right.getValue() - left.getValue());\\n        }\\n        return r;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1604537,
                "title": "2-c-solutions-binary-search-prefix-sum",
                "content": "### Solution 1: Binary Search\\n* Store index of all candles in a vector.\\n* For each query find index of first and last candle in the given range using binary search.\\n* Number of plates between candles will be number of elements between first and last candle minus number of candles between them.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        vector<int> candlesIndex;\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s[i] == \\'|\\')\\n                candlesIndex.push_back(i);\\n        }\\n        \\n        vector<int> ans;\\n        for(auto q : queries){\\n            int firstCandleIndex = lower_bound(candlesIndex.begin() , candlesIndex.end() , q[0]) - candlesIndex.begin();\\n            int lastCandleIndex = upper_bound(candlesIndex.begin() , candlesIndex.end() , q[1]) - candlesIndex.begin() - 1;\\n            \\n            if(lastCandleIndex <= firstCandleIndex){\\n                ans.push_back(0);\\n                continue;\\n            }\\n                \\n            \\n            int tempAns = candlesIndex[lastCandleIndex] - candlesIndex[firstCandleIndex] - (lastCandleIndex - firstCandleIndex);\\n            \\n            ans.push_back(tempAns);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity: O(n + Qlogn) , where n is length of string and Q is number of queries\\nSpace Complexity: O(n) , for storing index of all candles\\n\\n### Solution 2: Prefix Sum\\n* We will use 3 vectors :\\n\\t\\t1. **prev** : to store index of candle at or just before current index\\n\\t\\t2. **next** : to store index of candle at or just after current index\\n\\t\\t3. **prefixSum** : to store number of plates till the current index\\n\\t\\n* For each query find index of first and last candle in the given range and subtract prefixSum of first from prefixSum of last.\\n\\n```\\nvector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.length();\\n        vector<int> prev(n,n) , next(n,n) , prefixSum(n,0);\\n        \\n        for(int i=0;i<n;i++){\\n           if(i==0){\\n               if(s[i] == \\'|\\')\\n                   prev[i] = i;\\n               else\\n                   prefixSum[i] = 1;\\n           }\\n            else{\\n                if(s[i] == \\'|\\'){\\n                    prev[i] = i;\\n                    prefixSum[i] = prefixSum[i-1];\\n                }\\n                else{\\n                    prev[i] = prev[i-1];\\n                    prefixSum[i] = 1 + prefixSum[i-1];\\n                }\\n            }\\n        }\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(s[i] == \\'|\\')\\n                next[i] = i;\\n            \\n            else if(i != n-1 and s[i] != \\'|\\')\\n                next[i] = next[i+1];\\n        }\\n        \\n        vector<int> ans;\\n        for(auto q : queries){\\n            int l = q[0];\\n            int r = q[1];\\n            \\n            int i = next[l];\\n            int j = prev[r];\\n            \\n            if(j<=i || j==n || i==n)\\n                ans.push_back(0);\\n            else{\\n                ans.push_back(prefixSum[j] - prefixSum[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\nTime Complexity : O(n + Q), where n is length of string and Q is number of queries\\nSpace Complexity: O(3n) => O(n)\\n\\n***Please Upvote if you find the solution helpful!\\nHappy Coding!***",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        vector<int> candlesIndex;\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s[i] == \\'|\\')\\n                candlesIndex.push_back(i);\\n        }\\n        \\n        vector<int> ans;\\n        for(auto q : queries){\\n            int firstCandleIndex = lower_bound(candlesIndex.begin() , candlesIndex.end() , q[0]) - candlesIndex.begin();\\n            int lastCandleIndex = upper_bound(candlesIndex.begin() , candlesIndex.end() , q[1]) - candlesIndex.begin() - 1;\\n            \\n            if(lastCandleIndex <= firstCandleIndex){\\n                ans.push_back(0);\\n                continue;\\n            }\\n                \\n            \\n            int tempAns = candlesIndex[lastCandleIndex] - candlesIndex[firstCandleIndex] - (lastCandleIndex - firstCandleIndex);\\n            \\n            ans.push_back(tempAns);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nvector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.length();\\n        vector<int> prev(n,n) , next(n,n) , prefixSum(n,0);\\n        \\n        for(int i=0;i<n;i++){\\n           if(i==0){\\n               if(s[i] == \\'|\\')\\n                   prev[i] = i;\\n               else\\n                   prefixSum[i] = 1;\\n           }\\n            else{\\n                if(s[i] == \\'|\\'){\\n                    prev[i] = i;\\n                    prefixSum[i] = prefixSum[i-1];\\n                }\\n                else{\\n                    prev[i] = prev[i-1];\\n                    prefixSum[i] = 1 + prefixSum[i-1];\\n                }\\n            }\\n        }\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(s[i] == \\'|\\')\\n                next[i] = i;\\n            \\n            else if(i != n-1 and s[i] != \\'|\\')\\n                next[i] = next[i+1];\\n        }\\n        \\n        vector<int> ans;\\n        for(auto q : queries){\\n            int l = q[0];\\n            int r = q[1];\\n            \\n            int i = next[l];\\n            int j = prev[r];\\n            \\n            if(j<=i || j==n || i==n)\\n                ans.push_back(0);\\n            else{\\n                ans.push_back(prefixSum[j] - prefixSum[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548978,
                "title": "simple-java-solution-prefix-sum-treeset",
                "content": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int len = s.length();\\n        int[]left= new int[len];//plates\\n        TreeSet<Integer> candles = new TreeSet<>();\\n        int leftPlateCount = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'|\\')\\n            {\\n                candles.add(i);\\n                left[i] = leftPlateCount;\\n            }else{\\n            leftPlateCount++;\\n            }\\n        }\\n        int[] result = new int[queries.length];\\n        int i=0;\\n        for(int query[] : queries){\\n            Integer leftMostCandle = candles.ceiling(query[0]);\\n            Integer rightMostCandle = candles.floor(query[1]);\\n            if(leftMostCandle!=null && rightMostCandle!=null && leftMostCandle<rightMostCandle)\\n                result[i] = left[rightMostCandle]-left[leftMostCandle];\\n            \\n            i++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int len = s.length();\\n        int[]left= new int[len];//plates\\n        TreeSet<Integer> candles = new TreeSet<>();\\n        int leftPlateCount = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'|\\')\\n            {\\n                candles.add(i);\\n                left[i] = leftPlateCount;\\n            }else{\\n            leftPlateCount++;\\n            }\\n        }\\n        int[] result = new int[queries.length];\\n        int i=0;\\n        for(int query[] : queries){\\n            Integer leftMostCandle = candles.ceiling(query[0]);\\n            Integer rightMostCandle = candles.floor(query[1]);\\n            if(leftMostCandle!=null && rightMostCandle!=null && leftMostCandle<rightMostCandle)\\n                result[i] = left[rightMostCandle]-left[leftMostCandle];\\n            \\n            i++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549304,
                "title": "100-faster-linear-python-solution-prefix-sum-o-n",
                "content": "The basic idea is I am pre-calculating the no of plates for every position along with left nearest and right nearest candles for a given point for all i = 0 -> length\\nThen to form the answer -> check if 2 candles are present inside the given boundary area [ if left nearest candle of right boundary is after left boundary and right nearest candle of left boundary is before right boundary]\\nthen we have a valid solution - i.e. (no of plates till right candle point - no of plates till left candle point)\\nThis can be compared to Prefix sum approach\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, qs: List[List[int]]) -> List[int]:\\n        n=len(s)\\n        prefcandle=[-1]*n #this stores the position of closest candle from current towards left\\n        suffcandle=[0]*n #this stores the position of closest candle from current towards right\\n        \\n        pref=[0]*n #stores the number of plates  till ith position from 0 - for i = 0 -> n \\n        \\n        ind=-1\\n        c=0\\n        #The following method calculates number of plates(*) till ith position from 0 - for i = 0 -> n \\n        for i in range(n):\\n            if ind!=-1 and s[i]==\\'*\\':\\n                c+=1\\n            elif s[i]==\\'|\\':\\n                ind=i\\n            pref[i]=c\\n              \\n        #this method calculates the left nearest candle to a point\\n        #intial is -1 as to left of leftmost element no candle can be present\\n        ind =-1\\n        for i in range(n):\\n            if s[i] == \\'|\\':\\n                ind=i\\n            prefcandle[i]=ind\\n            \\n        #this method calculates the right nearest candle to a point\\n        #intial is infinity as to right of rightmost element no candle can be present\\n        ind = float(\\'inf\\')       \\n        for i in range(n-1, -1, -1):\\n            if s[i]==\\'|\\':\\n                ind=i\\n            suffcandle[i]=ind\\n\\n        #m = no of queries\\n        m=len(qs)\\n        ans=[0]*m\\n\\n        for i in range(m):\\n            c=0\\n            l=qs[i][0]\\n            r=qs[i][1]\\n            \\n            #check if left nearest candle of right boundary is after left boundary\\n            #check if right nearest candle of left boundary is before right boundary\\n            # to summarise - here we find if there is a pair of candle present within the given range or not\\n            if prefcandle[r]<l or suffcandle[l]>r:\\n                continue\\n            \\n            #desired answer is no of pplates(*) only inside 2 candles (|) inside the given boundary area\\n            ans[i]=pref[prefcandle[r]]-pref[suffcandle[l]]\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, qs: List[List[int]]) -> List[int]:\\n        n=len(s)\\n        prefcandle=[-1]*n #this stores the position of closest candle from current towards left\\n        suffcandle=[0]*n #this stores the position of closest candle from current towards right\\n        \\n        pref=[0]*n #stores the number of plates  till ith position from 0 - for i = 0 -> n \\n        \\n        ind=-1\\n        c=0\\n        #The following method calculates number of plates(*) till ith position from 0 - for i = 0 -> n \\n        for i in range(n):\\n            if ind!=-1 and s[i]==\\'*\\':\\n                c+=1\\n            elif s[i]==\\'|\\':\\n                ind=i\\n            pref[i]=c\\n              \\n        #this method calculates the left nearest candle to a point\\n        #intial is -1 as to left of leftmost element no candle can be present\\n        ind =-1\\n        for i in range(n):\\n            if s[i] == \\'|\\':\\n                ind=i\\n            prefcandle[i]=ind\\n            \\n        #this method calculates the right nearest candle to a point\\n        #intial is infinity as to right of rightmost element no candle can be present\\n        ind = float(\\'inf\\')       \\n        for i in range(n-1, -1, -1):\\n            if s[i]==\\'|\\':\\n                ind=i\\n            suffcandle[i]=ind\\n\\n        #m = no of queries\\n        m=len(qs)\\n        ans=[0]*m\\n\\n        for i in range(m):\\n            c=0\\n            l=qs[i][0]\\n            r=qs[i][1]\\n            \\n            #check if left nearest candle of right boundary is after left boundary\\n            #check if right nearest candle of left boundary is before right boundary\\n            # to summarise - here we find if there is a pair of candle present within the given range or not\\n            if prefcandle[r]<l or suffcandle[l]>r:\\n                continue\\n            \\n            #desired answer is no of pplates(*) only inside 2 candles (|) inside the given boundary area\\n            ans[i]=pref[prefcandle[r]]-pref[suffcandle[l]]\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057259,
                "title": "java-3-solutions-prefix-sum-binary-search-treemap",
                "content": "\\n### \\u2714\\uFE0F  Solution 1: Prefix Sum\\n- Time: `O(N+Q)`\\n- Space: `O(N)`\\n```java\\npublic int[] platesBetweenCandles(String s, int[][] queries) {\\n\\tint n = s.length();\\n\\tList<Integer> presum = new ArrayList<>();\\n\\tint[] closestLeft = new int[n], closestRight = new int[n];\\n\\tint sum = 0, index = -1;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tif (s.charAt(i) == \\'*\\') sum++;\\n\\t\\telse {\\n\\t\\t\\tpresum.add(sum);\\n\\t\\t\\tindex++;\\n\\t\\t}\\n\\t\\tclosestLeft[i] = index;\\n\\t}\\n\\n\\tindex = presum.size();;\\n\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\tif (s.charAt(i) == \\'|\\') index--;\\n\\t\\tclosestRight[i] = index;\\n\\t}\\n\\n\\tint[] res = new int[queries.length];\\n\\tfor (int i = 0; i < queries.length; i++) {\\n\\t\\tint start = queries[i][0], end = queries[i][1];\\n\\t\\tint left = closestRight[start];\\n\\t\\tint right = closestLeft[end];\\n\\t\\tif (left < right) res[i] = presum.get(right) - presum.get(left);\\n\\t}\\n\\treturn res;\\n}\\n```\\n----\\n### \\u2714\\uFE0F  Solution 2: Binary Search\\n- Time: `O(N+QlogN)`\\n- Space: `O(N)`\\n```\\npublic int[] platesBetweenCandles(String s, int[][] queries) {\\n\\tint n = s.length();\\n\\tList<Integer> presum = new ArrayList<>();\\n\\tList<Integer> index = new ArrayList<>();\\n\\tint sum = 0;\\n\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tif (s.charAt(i) == \\'*\\') sum++;\\n\\t\\telse {\\n\\t\\t\\tpresum.add(sum);\\n\\t\\t\\tindex.add(i);\\n\\t\\t}\\n\\t}\\n\\n\\tint[] res = new int[queries.length];\\n\\tfor (int i = 0; i < queries.length; i++) {\\n\\t\\tint start = queries[i][0], end = queries[i][1];\\n\\t\\tint left = ceiling(index, start);\\n\\t\\tint right = floor(index, end);\\n\\t\\tif (left < right) res[i] = presum.get(right) - presum.get(left);\\n\\t}\\n\\treturn res;\\n}\\n\\nint ceiling(List<Integer> list, int target) {\\n\\tint left = 0, right = list.size();\\n\\twhile (left < right) {\\n\\t\\tint mid = left + (right - left) / 2;\\n\\t\\tif (list.get(mid) < target) left = mid + 1;\\n\\t\\telse right = mid;\\n\\t}\\n\\treturn left;\\n}\\n\\nint floor(List<Integer> list, int target) {\\n\\tint left = -1, right = list.size() - 1;\\n\\twhile (left < right) {\\n\\t\\tint mid = left + (right - left) / 2 + 1;\\n\\t\\tif (list.get(mid) > target) right = mid - 1;\\n\\t\\telse left = mid;\\n\\t}\\n\\treturn left;\\n}\\n```\\n----\\n### \\u2714\\uFE0F  Solution 3: TreeMap\\n- Time: `O((N+Q)logN)`\\n- Space: `O(N)`\\n```\\npublic int[] platesBetweenCandles(String s, int[][] queries) {\\n\\tint n = s.length();\\n\\tTreeMap<Integer, Integer> map = new TreeMap<>(); // <index, presum>\\n\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tif (s.charAt(i) == \\'*\\') sum++;\\n\\t\\telse map.put(i, sum);\\n\\t}\\n\\n\\tint m = queries.length;\\n\\tint[] res = new int[m];\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tint start = queries[i][0], end = queries[i][1];\\n\\t\\tInteger left = map.ceilingKey(start);\\n\\t\\tInteger right = map.floorKey(end);\\n\\t\\tif (left != null && right != null && left < right) {\\n\\t\\t\\tres[i] = map.get(right) - map.get(left);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```\\n\\nFeel free to let me know if you have questions about this.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int[] platesBetweenCandles(String s, int[][] queries) {\\n\\tint n = s.length();\\n\\tList<Integer> presum = new ArrayList<>();\\n\\tint[] closestLeft = new int[n], closestRight = new int[n];\\n\\tint sum = 0, index = -1;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tif (s.charAt(i) == \\'*\\') sum++;\\n\\t\\telse {\\n\\t\\t\\tpresum.add(sum);\\n\\t\\t\\tindex++;\\n\\t\\t}\\n\\t\\tclosestLeft[i] = index;\\n\\t}\\n\\n\\tindex = presum.size();;\\n\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\tif (s.charAt(i) == \\'|\\') index--;\\n\\t\\tclosestRight[i] = index;\\n\\t}\\n\\n\\tint[] res = new int[queries.length];\\n\\tfor (int i = 0; i < queries.length; i++) {\\n\\t\\tint start = queries[i][0], end = queries[i][1];\\n\\t\\tint left = closestRight[start];\\n\\t\\tint right = closestLeft[end];\\n\\t\\tif (left < right) res[i] = presum.get(right) - presum.get(left);\\n\\t}\\n\\treturn res;\\n}\\n```\n```\\npublic int[] platesBetweenCandles(String s, int[][] queries) {\\n\\tint n = s.length();\\n\\tList<Integer> presum = new ArrayList<>();\\n\\tList<Integer> index = new ArrayList<>();\\n\\tint sum = 0;\\n\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tif (s.charAt(i) == \\'*\\') sum++;\\n\\t\\telse {\\n\\t\\t\\tpresum.add(sum);\\n\\t\\t\\tindex.add(i);\\n\\t\\t}\\n\\t}\\n\\n\\tint[] res = new int[queries.length];\\n\\tfor (int i = 0; i < queries.length; i++) {\\n\\t\\tint start = queries[i][0], end = queries[i][1];\\n\\t\\tint left = ceiling(index, start);\\n\\t\\tint right = floor(index, end);\\n\\t\\tif (left < right) res[i] = presum.get(right) - presum.get(left);\\n\\t}\\n\\treturn res;\\n}\\n\\nint ceiling(List<Integer> list, int target) {\\n\\tint left = 0, right = list.size();\\n\\twhile (left < right) {\\n\\t\\tint mid = left + (right - left) / 2;\\n\\t\\tif (list.get(mid) < target) left = mid + 1;\\n\\t\\telse right = mid;\\n\\t}\\n\\treturn left;\\n}\\n\\nint floor(List<Integer> list, int target) {\\n\\tint left = -1, right = list.size() - 1;\\n\\twhile (left < right) {\\n\\t\\tint mid = left + (right - left) / 2 + 1;\\n\\t\\tif (list.get(mid) > target) right = mid - 1;\\n\\t\\telse left = mid;\\n\\t}\\n\\treturn left;\\n}\\n```\n```\\npublic int[] platesBetweenCandles(String s, int[][] queries) {\\n\\tint n = s.length();\\n\\tTreeMap<Integer, Integer> map = new TreeMap<>(); // <index, presum>\\n\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tif (s.charAt(i) == \\'*\\') sum++;\\n\\t\\telse map.put(i, sum);\\n\\t}\\n\\n\\tint m = queries.length;\\n\\tint[] res = new int[m];\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tint start = queries[i][0], end = queries[i][1];\\n\\t\\tInteger left = map.ceilingKey(start);\\n\\t\\tInteger right = map.floorKey(end);\\n\\t\\tif (left != null && right != null && left < right) {\\n\\t\\t\\tres[i] = map.get(right) - map.get(left);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1549015,
                "title": "python3-binary-search-o-n-approach",
                "content": "\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        prefix = [0]\\n        candles = []\\n        for i, ch in enumerate(s): \\n            if ch == \\'|\\': candles.append(i)\\n            if ch == \\'|\\': prefix.append(prefix[-1])\\n            else: prefix.append(prefix[-1] + 1)\\n        \\n        ans = []\\n        for x, y in queries: \\n            lo = bisect_left(candles, x)\\n            hi = bisect_right(candles, y) - 1\\n            if 0 <= hi and lo < len(candles) and lo <= hi: \\n                ans.append(prefix[candles[hi]+1] - prefix[candles[lo]])\\n            else: ans.append(0)\\n        return ans \\n```\\n\\nAdding an `O(N)` approach \\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        prefix = [0]\\n        stack = []\\n        upper = [-1]*len(s)\\n        lower = [-1]*len(s)\\n        lo = -1\\n        for i, ch in enumerate(s): \\n            prefix.append(prefix[-1] + (ch == \\'*\\'))\\n            stack.append(i)\\n            if ch == \\'|\\': \\n                while stack: upper[stack.pop()] = i \\n                lo = i \\n            lower[i] = lo \\n        \\n        ans = []\\n        for x, y in queries: \\n            lo = upper[x]\\n            hi = lower[y]\\n            if hi != -1 and lo != -1 and lo <= hi: ans.append(prefix[hi+1] - prefix[lo])\\n            else: ans.append(0)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        prefix = [0]\\n        candles = []\\n        for i, ch in enumerate(s): \\n            if ch == \\'|\\': candles.append(i)\\n            if ch == \\'|\\': prefix.append(prefix[-1])\\n            else: prefix.append(prefix[-1] + 1)\\n        \\n        ans = []\\n        for x, y in queries: \\n            lo = bisect_left(candles, x)\\n            hi = bisect_right(candles, y) - 1\\n            if 0 <= hi and lo < len(candles) and lo <= hi: \\n                ans.append(prefix[candles[hi]+1] - prefix[candles[lo]])\\n            else: ans.append(0)\\n        return ans \\n```\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        prefix = [0]\\n        stack = []\\n        upper = [-1]*len(s)\\n        lower = [-1]*len(s)\\n        lo = -1\\n        for i, ch in enumerate(s): \\n            prefix.append(prefix[-1] + (ch == \\'*\\'))\\n            stack.append(i)\\n            if ch == \\'|\\': \\n                while stack: upper[stack.pop()] = i \\n                lo = i \\n            lower[i] = lo \\n        \\n        ans = []\\n        for x, y in queries: \\n            lo = upper[x]\\n            hi = lower[y]\\n            if hi != -1 and lo != -1 and lo <= hi: ans.append(prefix[hi+1] - prefix[lo])\\n            else: ans.append(0)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549161,
                "title": "python-bisect",
                "content": "A short solution using bisect (built in library bisect [source code](https://github.com/python/cpython/blob/3.10/Lib/bisect.py)):\\n\\n`p` stores the index for each candle, \\n`p[j] - p[i]` returns how many plates there are between the two candles.\\n`j - i` returns how many candles are between these two candles\\njust be careful about the boundary conditions\\n\\n    import bisect \\n    class Solution:\\n\\t\\tdef platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n\\t\\t\\tp = [i for i in range(len(s)) if s[i] == \\'|\\']\\n\\n\\t\\t\\tres = []\\n\\t\\t\\tfor f,t in queries: \\n\\t\\t\\t\\tl = bisect.bisect_left(p, f)\\n\\t\\t\\t\\tr = bisect.bisect_right(p, t)\\n\\t\\t\\t\\tres.append(p[r-1] - p[l] - (r-1-l) if r > l else 0)\\n\\n\\t\\t\\treturn res\\n\\n(credits: Raymond for using bisect)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "A short solution using bisect (built in library bisect [source code](https://github.com/python/cpython/blob/3.10/Lib/bisect.py)):\\n\\n`p` stores the index for each candle, \\n`p[j] - p[i]` returns how many plates there are between the two candles.\\n`j - i` returns how many candles are between these two candles\\njust be careful about the boundary conditions\\n\\n    import bisect \\n    class Solution:\\n\\t\\tdef platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n\\t\\t\\tp = [i for i in range(len(s)) if s[i] == \\'|\\']\\n\\n\\t\\t\\tres = []\\n\\t\\t\\tfor f,t in queries: \\n\\t\\t\\t\\tl = bisect.bisect_left(p, f)\\n\\t\\t\\t\\tr = bisect.bisect_right(p, t)\\n\\t\\t\\t\\tres.append(p[r-1] - p[l] - (r-1-l) if r > l else 0)\\n\\n\\t\\t\\treturn res\\n\\n(credits: Raymond for using bisect)",
                "codeTag": "Java"
            },
            {
                "id": 1901506,
                "title": "custom-binary-search",
                "content": "# Idea of the approach \\n            # Store all the plates position in an array\\n            # Ex, s = \"***|**|*****|**||**|*\"\\n            # index = [3,5,12,15,16,19]\\n            # For example for query [1,17] ,I have to find the count of stars\\n            # Idea is to search if there is a plate in 1st postion if not whether\\n            # there is plate present in immediate next greater postion here  \\n            # there is 3rd position which is immediate next greater where plate is  \\n            # present\\n            \\n            #Similary for 17position check whether there is plate present in 17th\\n            # postiion if not find immediate previous smaller position here that is 16th\\n            # position where there is plate\\n            \\n            #We can do this postiion searching using binary search in (logn time)\\n            # In Binary search  l = 0 and h = len(index) - 1 for all cases\\n            \\n            #count will be done by suppose,\\n            # Ex, s = \"***|**|*****|**||**|*\"\\n            # index = [3,5,12,15,16,19]\\n            # query = [1,17]\\n            # lower_bound for 1 will be 3 (Binary search will return postion so index[postion] = 3)\\n            # upper_bound for 17 will be 16(Binary search will return postion so index[postion] = 16)\\n            # count = index[u_b] - index[l_b] - (u_b - l_b - 1) - 1\\n            # count = 16 - 3 - (4 - 0 - 1 ) - 1\\n            # count = 9\\n\\n\\tclass Solution:    \\n\\t\\n\\tdef platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:            \\n            \\n\\t\\t\\tindex = []\\n            for i in range(len(s)):\\n                if s[i] == \\'|\\':\\n                    index.append(i)\\n            res = []\\n            \\n            for q in queries:\\n\\n                if q[1] - q[0] > 1:\\n                    l_b = self.binary_search(index,q[0],0)#Find lower bound (it will return same position if present else first greater)\\n                    u_b = self.binary_search(index,q[1],1)#Find upper bound(it will return same position if present else first smaller)\\n                    \\n                    if l_b >= u_b:\\n                        res.append(0)\\n                        continue\\n                    \\n                    \\n                    count = index[u_b] - index[l_b] - (u_b - l_b - 1) - 1\\n                    res.append(count)\\n                else:\\n                    res.append(0)\\n            \\n            return res\\n    def binary_search(self,index,val,b):\\n        l = 0\\n        h = len(index) - 1\\n        \\n        while l<=h:\\n            mid = (l+h)//2\\n            \\n            if index[mid] == val:\\n                return mid # If positon matches with given position\\n            elif index[mid] > val:\\n                h = mid - 1\\n            else:\\n                l = mid + 1 \\n                \\n        if b == 0:\\n            return l\\n        else:\\n            return h\\n            \\n",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "# Idea of the approach \\n            # Store all the plates position in an array\\n            # Ex, s = \"***|**|*****|**||**|*\"\\n            # index = [3,5,12,15,16,19]\\n            # For example for query [1,17] ,I have to find the count of stars\\n            # Idea is to search if there is a plate in 1st postion if not whether\\n            # there is plate present in immediate next greater postion here  \\n            # there is 3rd position which is immediate next greater where plate is  \\n            # present\\n            \\n            #Similary for 17position check whether there is plate present in 17th\\n            # postiion if not find immediate previous smaller position here that is 16th\\n            # position where there is plate\\n            \\n            #We can do this postiion searching using binary search in (logn time)\\n            # In Binary search  l = 0 and h = len(index) - 1 for all cases\\n            \\n            #count will be done by suppose,\\n            # Ex, s = \"***|**|*****|**||**|*\"\\n            # index = [3,5,12,15,16,19]\\n            # query = [1,17]\\n            # lower_bound for 1 will be 3 (Binary search will return postion so index[postion] = 3)\\n            # upper_bound for 17 will be 16(Binary search will return postion so index[postion] = 16)\\n            # count = index[u_b] - index[l_b] - (u_b - l_b - 1) - 1\\n            # count = 16 - 3 - (4 - 0 - 1 ) - 1\\n            # count = 9\\n\\n\\tclass Solution:    \\n\\t\\n\\tdef platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:            \\n            \\n\\t\\t\\tindex = []\\n            for i in range(len(s)):\\n                if s[i] == \\'|\\':\\n                    index.append(i)\\n            res = []\\n            \\n            for q in queries:\\n\\n                if q[1] - q[0] > 1:\\n                    l_b = self.binary_search(index,q[0],0)#Find lower bound (it will return same position if present else first greater)\\n                    u_b = self.binary_search(index,q[1],1)#Find upper bound(it will return same position if present else first smaller)\\n                    \\n                    if l_b >= u_b:\\n                        res.append(0)\\n                        continue\\n                    \\n                    \\n                    count = index[u_b] - index[l_b] - (u_b - l_b - 1) - 1\\n                    res.append(count)\\n                else:\\n                    res.append(0)\\n            \\n            return res\\n    def binary_search(self,index,val,b):\\n        l = 0\\n        h = len(index) - 1\\n        \\n        while l<=h:\\n            mid = (l+h)//2\\n            \\n            if index[mid] == val:\\n                return mid # If positon matches with given position\\n            elif index[mid] > val:\\n                h = mid - 1\\n            else:\\n                l = mid + 1 \\n                \\n        if b == 0:\\n            return l\\n        else:\\n            return h\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 3813432,
                "title": "prefix-sum-easy-c-with-image-explanation",
                "content": "# Approach\\n**Precount :** Prefix-sum array that store the the number of plates(0 to i) at ith position.\\n**Candle Position:** Store the Candles position.\\n\\nhere for Each Query, we have to find out the candle\\'s Positions **(just greater or equal to q[i][0] and just lesser or equal to q[i][1])**, using these candle\\'s positions we can simply calculate the number of plates between them.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/31b12ad9-c8ec-4d65-b218-dd260654a36c_1690269367.845143.png)\\n![image.png](https://assets.leetcode.com/users/images/d40e4cf0-c034-42d1-8360-a83bd166975e_1690269575.8789282.png)\\n![image.png](https://assets.leetcode.com/users/images/809a0fe9-644d-4866-81c7-21c04ead1b99_1690269767.2205994.png)\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: O(N* Log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& q) {\\n      int n = s.size(),cnt = 0;\\n      vector<int> prec(n,0),cp,ans;\\n      for(int i = 0;i<n;i++)\\n      {\\n         if(s[i]==\\'*\\') cnt++;\\n         if(s[i]==\\'|\\') cp.push_back(i);\\n         prec[i] = cnt;\\n      }\\n      for(int i = 0;i<q.size();i++)\\n      {\\n          int l = lower_bound(cp.begin(),cp.end(),q[i][0])-cp.begin();\\n          int r = upper_bound(cp.begin(),cp.end(),q[i][1])-cp.begin();\\n          if(l<0 || l>=cp.size() || r<=0 || r>cp.size() || prec[cp[r-1]]-prec[cp[l]]<0) ans.push_back(0);\\n          else ans.push_back(prec[cp[r-1]]-prec[cp[l]]);\\n      }\\n      return ans;  \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/ebf182a3-069e-4fc4-948a-8f0671a25288_1690270886.7219605.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& q) {\\n      int n = s.size(),cnt = 0;\\n      vector<int> prec(n,0),cp,ans;\\n      for(int i = 0;i<n;i++)\\n      {\\n         if(s[i]==\\'*\\') cnt++;\\n         if(s[i]==\\'|\\') cp.push_back(i);\\n         prec[i] = cnt;\\n      }\\n      for(int i = 0;i<q.size();i++)\\n      {\\n          int l = lower_bound(cp.begin(),cp.end(),q[i][0])-cp.begin();\\n          int r = upper_bound(cp.begin(),cp.end(),q[i][1])-cp.begin();\\n          if(l<0 || l>=cp.size() || r<=0 || r>cp.size() || prec[cp[r-1]]-prec[cp[l]]<0) ans.push_back(0);\\n          else ans.push_back(prec[cp[r-1]]-prec[cp[l]]);\\n      }\\n      return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173786,
                "title": "java-time-o-m-n-space-o-n-prefix-sum",
                "content": "```\\n\\n// let\\'s walk through one example.\\n// * * | * * | * * * |\\n// 0 1 2 3 4 5 6 7 8 9 \\n\\n// given a query, you first want to know the leftmost and rightmost candle index within that\\n//query, this can be done using binary search if you can record all indices of candles..\\n\\n//however, there is a more efficient way.\\n//for every index i, we record left and right nearest candle index\\n//                     0 1 2 3 4 5 6 7 8 9 \\n//                     * * | * * | * * * |\\n//preCandleIndex      -1-1 2 2 2 5 5 5 5 9 (traverse from front)\\n//postCandleIndex      2 2 2 5 5 5 9 9 9 9 (traverse from back, every encounter of \\'|\\' updates index)\\n\\n\\n//so..., if you want to know leftmost and rightmost candle indeces in [2, 7],\\n// you will first check postCandleIndex[2] = 2, preCandleIndex[7] = 5, voila, \\n// you get them without using binary search!\\n\\n//finally, you want to count the number of plates between [leftmost candle, rightmost candle]\\n//what do you do?\\n\\n//you first count plates plus candles in [leftmost candle, rightmost candle], [2, 5] in this case..\\n// you get 5-2+1 = 4\\n\\n//and you also want to know how many candles are in [2, 5] inclusive.. you again use prefix sum \\n\\n//so in total, you get plates number as 4 - 2 (2th, 5th) = 2.\\n\\n\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int n = s.length(), m = queries.length;\\n        int[] ans = new int[m];\\n        \\n        int[] preCandleIndex = new int[n];\\n        int[] postCandleIndex = new int[n];\\n        int[] numCandle = new int[n];\\n        \\n        int ind = -1;\\n        int cnt = 0;\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)==\\'|\\'){\\n                ind = i;\\n                cnt++;\\n            }\\n            preCandleIndex[i] = ind;\\n            numCandle[i] = cnt;\\n        }\\n        \\n        ind = -1;\\n        for(int i=n-1;i>=0;i--){\\n            if(s.charAt(i)==\\'|\\')\\n                ind = i;\\n            postCandleIndex[i] = ind;\\n        }\\n        \\n        int count = 0;\\n        for(int[] query:queries){\\n            int l = postCandleIndex[query[0]];\\n            int r = preCandleIndex[query[1]];\\n            if(l==-1||r==-1||l>=r){\\n                ans[count] = 0;\\n            }else{\\n                ans[count] = r - l - (numCandle[r] - numCandle[l]);\\n            }\\n            \\n            count++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\n\\n// let\\'s walk through one example.\\n// * * | * * | * * * |\\n// 0 1 2 3 4 5 6 7 8 9 \\n\\n// given a query, you first want to know the leftmost and rightmost candle index within that\\n//query, this can be done using binary search if you can record all indices of candles..\\n\\n//however, there is a more efficient way.\\n//for every index i, we record left and right nearest candle index\\n//                     0 1 2 3 4 5 6 7 8 9 \\n//                     * * | * * | * * * |\\n//preCandleIndex      -1-1 2 2 2 5 5 5 5 9 (traverse from front)\\n//postCandleIndex      2 2 2 5 5 5 9 9 9 9 (traverse from back, every encounter of \\'|\\' updates index)\\n\\n\\n//so..., if you want to know leftmost and rightmost candle indeces in [2, 7],\\n// you will first check postCandleIndex[2] = 2, preCandleIndex[7] = 5, voila, \\n// you get them without using binary search!\\n\\n//finally, you want to count the number of plates between [leftmost candle, rightmost candle]\\n//what do you do?\\n\\n//you first count plates plus candles in [leftmost candle, rightmost candle], [2, 5] in this case..\\n// you get 5-2+1 = 4\\n\\n//and you also want to know how many candles are in [2, 5] inclusive.. you again use prefix sum \\n\\n//so in total, you get plates number as 4 - 2 (2th, 5th) = 2.\\n\\n\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int n = s.length(), m = queries.length;\\n        int[] ans = new int[m];\\n        \\n        int[] preCandleIndex = new int[n];\\n        int[] postCandleIndex = new int[n];\\n        int[] numCandle = new int[n];\\n        \\n        int ind = -1;\\n        int cnt = 0;\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)==\\'|\\'){\\n                ind = i;\\n                cnt++;\\n            }\\n            preCandleIndex[i] = ind;\\n            numCandle[i] = cnt;\\n        }\\n        \\n        ind = -1;\\n        for(int i=n-1;i>=0;i--){\\n            if(s.charAt(i)==\\'|\\')\\n                ind = i;\\n            postCandleIndex[i] = ind;\\n        }\\n        \\n        int count = 0;\\n        for(int[] query:queries){\\n            int l = postCandleIndex[query[0]];\\n            int r = preCandleIndex[query[1]];\\n            if(l==-1||r==-1||l>=r){\\n                ans[count] = 0;\\n            }else{\\n                ans[count] = r - l - (numCandle[r] - numCandle[l]);\\n            }\\n            \\n            count++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1972277,
                "title": "c-easy-solution-using-binary-search-and-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n        vector<int>pref(n);\\n        if(s[0] == \\'*\\')\\n            pref[0] = 1;\\n        else\\n            pref[0] = 0;\\n        \\n        for(int i=1;i<n;i++)\\n            if(s[i] == \\'*\\')\\n                pref[i] = pref[i-1]+1;\\n            else\\n                pref[i] = pref[i-1];\\n        \\n        \\n        vector<int>candle;\\n        for(int i=0;i<s.length();i++)\\n            if(s[i] == \\'|\\')\\n                candle.push_back(i);\\n        \\n        \\n        vector<int>ans;\\n        \\n        \\n        for(int i=0;i<queries.size();i++)\\n        {\\n            if(candle.size() <= 1)\\n            {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            int first = queries[i][0];\\n            int second = queries[i][1];\\n            \\n            int pos1 = lower_bound(candle.begin(),candle.end(),first)-candle.begin();\\n            int pos2 = --upper_bound(candle.begin(),candle.end(),second)-candle.begin();\\n            // cout<<candle[pos1]<<\" \"<<candle[pos2]<<endl;\\n            \\n            if(pos1 >= candle.size() || pos2 < 0 || pos1>=pos2)\\n                ans.push_back(0);\\n            else\\n                ans.push_back(pref[candle[pos2]]-pref[candle[pos1]]);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n        vector<int>pref(n);\\n        if(s[0] == \\'*\\')\\n            pref[0] = 1;\\n        else\\n            pref[0] = 0;\\n        \\n        for(int i=1;i<n;i++)\\n            if(s[i] == \\'*\\')\\n                pref[i] = pref[i-1]+1;\\n            else\\n                pref[i] = pref[i-1];\\n        \\n        \\n        vector<int>candle;\\n        for(int i=0;i<s.length();i++)\\n            if(s[i] == \\'|\\')\\n                candle.push_back(i);\\n        \\n        \\n        vector<int>ans;\\n        \\n        \\n        for(int i=0;i<queries.size();i++)\\n        {\\n            if(candle.size() <= 1)\\n            {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            int first = queries[i][0];\\n            int second = queries[i][1];\\n            \\n            int pos1 = lower_bound(candle.begin(),candle.end(),first)-candle.begin();\\n            int pos2 = --upper_bound(candle.begin(),candle.end(),second)-candle.begin();\\n            // cout<<candle[pos1]<<\" \"<<candle[pos2]<<endl;\\n            \\n            if(pos1 >= candle.size() || pos2 < 0 || pos1>=pos2)\\n                ans.push_back(0);\\n            else\\n                ans.push_back(pref[candle[pos2]]-pref[candle[pos1]]);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1550447,
                "title": "simple-javascript-solution-detailed-explanation-with-comments",
                "content": "##### **Steps**\\n1. Iterate string `s` while keeping track of total number of plates\\n2. Form an array `left` where `left[i]` is the total number of plates seen on the left of candle at `s[i]`\\n\\nAfter step 1 and 2, you should see this \\n(Referencing Example 2 from the question)\\n![image](https://assets.leetcode.com/users/images/f41da12a-dbde-407f-bdcf-9f896862f4a8_1635664021.2203376.png)\\n\\n```\\n// e.g. There are 3 plates on the left of candle at index 3\\n// e.g. There are 10 plates on the left of candle at index 12\\nleft = [\\n  0,  0,  0, 3, 0,  0, 5,\\n  0,  0,  0, 0, 0, 10, 0,\\n  0, 12, 12, 0, 0, 14, 0\\n]\\ncandles is a Set containing { 3, 6, 12, 15, 16, 19 }\\n```\\n\\n3. Process each query `[start, end]`\\n\\t* Check if `s[start]` is a candle. If not, find the nearest candle on the right\\n\\t* Check if `s[end]` is a candle. If not, find the nearest candle on the left\\n\\n4. Calculate the number of candles between `start` and `end`, using `left[end] - left[start]`\\n\\n##### **Example**\\nQuery [1, 17] had `start = 1` and `end = 17`. \\nBoth are not candles, so we found the nearest candles to be `start = 3` and `end = 16`.\\nThe difference (number of plates) between `start` and `end` is `left[16] - left[3] = 12 - 3 = 9`\\n\\nCase where `diff` may be negative:\\ns = `*|*****`, query = `[1,3]`\\n`start = 1`, `end = 3`\\nWe tried to find a candle on the left of `end`, but cannot find any. So `end` remains its value of `3`\\nDifference is now negative, `const diff = left[3] - left[1] = 0 - 1 = -1`\\nPush `0` to result instead since `diff` is negative\\n\\n##### **Code**\\n```\\n/**\\n * @param {string} s\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar platesBetweenCandles = function (s, queries) {\\n  const result = []\\n\\n  const left = Array(s.length).fill(0) // Initialize an array to store the number of plates seen on index i\\n  const candles = new Set() // Initialize a set to store the indexes of candles\\n\\n  let leftPlateCount = 0; // Track the total number of plates seen so far\\n  for (const i in s) {\\n    if (s[i] === \"|\") { // If you see a candle,\\n      candles.add(+i) // add index i into candles Set (\"+i\" converts i of type string into a number)\\n      left[i] = leftPlateCount // also, store the number of plates you seen into \\'left\\' array\\n    } else {\\n      leftPlateCount++ // If you see a plate, increment the total number of plates seen so far\\n    }\\n  }\\n\\n  const candlesArr = [...candles] // Converts the Set into an array to iterate on later\\n  for (let [start, end] of queries) { // Destructure [start, end] from each query\\n    if (!candles.has(start)) { // If s[start] is not in candles Set\\n      for (const v of candlesArr) { // Iterate candlesArr from the front\\n        if (v >= start) { // Find the nearest candle index and assign to \\'start\\'\\n          start = v\\n          break // Early termination\\n        }\\n      }\\n    }\\n\\n    if (!candles.has(end)) { // If s[end] is not in candles Set\\n      for (let i = candlesArr.length - 1; i > 0; i--) { // Iterate candlesArr from the back\\n        if (candlesArr[i] <= end) { // Find the nearest candle index and assign to \\'end\\'\\n          end = candlesArr[i]\\n          break // Early termination\\n        }\\n      }\\n    }\\n\\n    if (start >= end) { // If start > end, it is an invalid query and we can push \\'0\\' to result\\n      result.push(0)\\n      continue\\n    }\\n\\t\\n\\t// Number of plates between candle at index start and candle at index end\\n\\t// Plates on the left of candle at index end minus plates on the left of candle at index start\\n    const diff = left[end] - left[start]\\n    result.push(diff < 0 ? 0 : diff) // If \\'diff\\' is negative, push \\'0\\' to result, else push \\'diff\\'\\n  }\\n\\n  return result\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// e.g. There are 3 plates on the left of candle at index 3\\n// e.g. There are 10 plates on the left of candle at index 12\\nleft = [\\n  0,  0,  0, 3, 0,  0, 5,\\n  0,  0,  0, 0, 0, 10, 0,\\n  0, 12, 12, 0, 0, 14, 0\\n]\\ncandles is a Set containing { 3, 6, 12, 15, 16, 19 }\\n```\n```\\n/**\\n * @param {string} s\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar platesBetweenCandles = function (s, queries) {\\n  const result = []\\n\\n  const left = Array(s.length).fill(0) // Initialize an array to store the number of plates seen on index i\\n  const candles = new Set() // Initialize a set to store the indexes of candles\\n\\n  let leftPlateCount = 0; // Track the total number of plates seen so far\\n  for (const i in s) {\\n    if (s[i] === \"|\") { // If you see a candle,\\n      candles.add(+i) // add index i into candles Set (\"+i\" converts i of type string into a number)\\n      left[i] = leftPlateCount // also, store the number of plates you seen into \\'left\\' array\\n    } else {\\n      leftPlateCount++ // If you see a plate, increment the total number of plates seen so far\\n    }\\n  }\\n\\n  const candlesArr = [...candles] // Converts the Set into an array to iterate on later\\n  for (let [start, end] of queries) { // Destructure [start, end] from each query\\n    if (!candles.has(start)) { // If s[start] is not in candles Set\\n      for (const v of candlesArr) { // Iterate candlesArr from the front\\n        if (v >= start) { // Find the nearest candle index and assign to \\'start\\'\\n          start = v\\n          break // Early termination\\n        }\\n      }\\n    }\\n\\n    if (!candles.has(end)) { // If s[end] is not in candles Set\\n      for (let i = candlesArr.length - 1; i > 0; i--) { // Iterate candlesArr from the back\\n        if (candlesArr[i] <= end) { // Find the nearest candle index and assign to \\'end\\'\\n          end = candlesArr[i]\\n          break // Early termination\\n        }\\n      }\\n    }\\n\\n    if (start >= end) { // If start > end, it is an invalid query and we can push \\'0\\' to result\\n      result.push(0)\\n      continue\\n    }\\n\\t\\n\\t// Number of plates between candle at index start and candle at index end\\n\\t// Plates on the left of candle at index end minus plates on the left of candle at index start\\n    const diff = left[end] - left[start]\\n    result.push(diff < 0 ? 0 : diff) // If \\'diff\\' is negative, push \\'0\\' to result, else push \\'diff\\'\\n  }\\n\\n  return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2531254,
                "title": "simple-java-solution-with-explanation-o-n-time-o-n-space",
                "content": "The idea is to pre-compute the essentials, so each query can be answered in O(1) time.\\n\\nI have found the \"nearest candle to left\" and \"nearest candle to the right\" for every index by processing the string from the left and from the right respectively. In the process I have also accumulated the cumulative sum of plates.\\n\\nSo, when the query comes, it boils down to finding the \"nearest candles to the left\" for the given range maximum and \"nearest candles to the right\" for the given range minimum.\\nand ultimately finding the number of plates between these nearest candle positions using the cumulative sum of plates. \\n```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int len = s.length();\\n        int[] nearestCandleToLeft = new int[len];\\n        int[] nearestCandleToRight = new int[len];\\n        int[] plates = new int[len];\\n        \\n        int ncl = -1;\\n        if(s.charAt(0)==\\'*\\') plates[0]=1;\\n        for(int i=0;i<len;i++){\\n\\t\\t    // if plate, maintain cumulative sum\\n            if(s.charAt(i)==\\'*\\'){\\n                nearestCandleToLeft[i]=ncl;\\n                if(i!=0) plates[i]=plates[i-1]+1;\\n            }else {\\n                nearestCandleToLeft[i]=i;\\n                ncl = i;\\n                if(i!=0) plates[i]=plates[i-1];\\n            }\\n        }\\n        \\n        int ncr = Integer.MAX_VALUE;\\n        for(int i=len-1;i>=0;i--){\\n            if(s.charAt(i)==\\'|\\')\\n                ncr=i; \\n            nearestCandleToRight[i]=ncr;\\n        }\\n        \\n        int[] ans = new int[queries.length];\\n        for(int i=0;i<queries.length;i++){\\n            ncr = nearestCandleToRight[queries[i][0]];\\n            ncl = nearestCandleToLeft[queries[i][1]];\\n            if(ncl < queries[i][0] || ncr > queries[i][1]){\\n                ans[i]=0;\\n                continue;\\n            }\\n            ans[i]=plates[ncl]-plates[ncr];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int len = s.length();\\n        int[] nearestCandleToLeft = new int[len];\\n        int[] nearestCandleToRight = new int[len];\\n        int[] plates = new int[len];\\n        \\n        int ncl = -1;\\n        if(s.charAt(0)==\\'*\\') plates[0]=1;\\n        for(int i=0;i<len;i++){\\n\\t\\t    // if plate, maintain cumulative sum\\n            if(s.charAt(i)==\\'*\\'){\\n                nearestCandleToLeft[i]=ncl;\\n                if(i!=0) plates[i]=plates[i-1]+1;\\n            }else {\\n                nearestCandleToLeft[i]=i;\\n                ncl = i;\\n                if(i!=0) plates[i]=plates[i-1];\\n            }\\n        }\\n        \\n        int ncr = Integer.MAX_VALUE;\\n        for(int i=len-1;i>=0;i--){\\n            if(s.charAt(i)==\\'|\\')\\n                ncr=i; \\n            nearestCandleToRight[i]=ncr;\\n        }\\n        \\n        int[] ans = new int[queries.length];\\n        for(int i=0;i<queries.length;i++){\\n            ncr = nearestCandleToRight[queries[i][0]];\\n            ncl = nearestCandleToLeft[queries[i][1]];\\n            if(ncl < queries[i][0] || ncr > queries[i][1]){\\n                ans[i]=0;\\n                continue;\\n            }\\n            ans[i]=plates[ncl]-plates[ncr];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1608341,
                "title": "c-using-prefix-sum-technique",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& q) {\\n        \\n       int n=s.length();\\n     \\n      vector<int>stars(n,0);\\n      \\n      if(s[0]==\\'*\\')\\n        stars[0]=1;\\n      \\n      for(int i=1;i<n;i++) //  stars[i]= no of stars in a range 0.....i\\n        stars[i]=stars[i-1]+(s[i]==\\'*\\'?1:0);\\n      \\n      vector<int>leftB(n,-1); //leftB[i]=index of first left bar to index i\\n      int left=-1;\\n      for(int i=0;i<n;i++){\\n        if(s[i]==\\'|\\')\\n          left=i;\\n        leftB[i]=left;\\n      }\\n      \\n      vector<int>rightB(n,n); //rightB[i]=index of first right bar to i\\n      int right=n;\\n      for(int i=n-1;i>=0;i--){\\n        if(s[i]==\\'|\\')\\n          right=i;\\n        rightB[i]=right;\\n      }\\n      \\n      vector<int>ans(q.size());\\n      for(int i=0;i<q.size();i++){\\n        int l=q[i][0];\\n        int r=q[i][1];\\n        \\n        int LMBar=rightB[l];  // leftmost bar of range [l....r]\\n        int RMBar=leftB[r];   // rightmost bar of range [l....r]\\n        \\n        if(LMBar>r || RMBar<l || LMBar==RMBar)\\n          ans[i]=0;\\n        else{\\n      //  int RangeOfStars=RMBar-LMBar-1;\\n        int StarsInRange=0;\\n        if(LMBar==0)\\n          StarsInRange=stars[RMBar];\\n        else   // no of stars btween leftmost and rightmost bars of given range\\n          StarsInRange=stars[RMBar]-stars[LMBar-1];\\n        \\n        ans[i]=StarsInRange;\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& q) {\\n        \\n       int n=s.length();\\n     \\n      vector<int>stars(n,0);\\n      \\n      if(s[0]==\\'*\\')\\n        stars[0]=1;\\n      \\n      for(int i=1;i<n;i++) //  stars[i]= no of stars in a range 0.....i\\n        stars[i]=stars[i-1]+(s[i]==\\'*\\'?1:0);\\n      \\n      vector<int>leftB(n,-1); //leftB[i]=index of first left bar to index i\\n      int left=-1;\\n      for(int i=0;i<n;i++){\\n        if(s[i]==\\'|\\')\\n          left=i;\\n        leftB[i]=left;\\n      }\\n      \\n      vector<int>rightB(n,n); //rightB[i]=index of first right bar to i\\n      int right=n;\\n      for(int i=n-1;i>=0;i--){\\n        if(s[i]==\\'|\\')\\n          right=i;\\n        rightB[i]=right;\\n      }\\n      \\n      vector<int>ans(q.size());\\n      for(int i=0;i<q.size();i++){\\n        int l=q[i][0];\\n        int r=q[i][1];\\n        \\n        int LMBar=rightB[l];  // leftmost bar of range [l....r]\\n        int RMBar=leftB[r];   // rightmost bar of range [l....r]\\n        \\n        if(LMBar>r || RMBar<l || LMBar==RMBar)\\n          ans[i]=0;\\n        else{\\n      //  int RangeOfStars=RMBar-LMBar-1;\\n        int StarsInRange=0;\\n        if(LMBar==0)\\n          StarsInRange=stars[RMBar];\\n        else   // no of stars btween leftmost and rightmost bars of given range\\n          StarsInRange=stars[RMBar]-stars[LMBar-1];\\n        \\n        ans[i]=StarsInRange;\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548976,
                "title": "c-with-explanation",
                "content": "**Idea:-**\\n1. Let\\'s say ```query is [left,right]```. \\n2. **So in simple words we have to find``` position(p1)(left<=p1<=right)``` of candle which is closest to left and ```position(p2)(left<=p2<=right)``` of candle which is closest to right.**\\n3. **After finding p1 and p2 we have to find number of plates between these two positions.**\\n4. So for finding p1 and p2 use forward and backward array and store position of latest candle while iteratig over string in forward and backward direction respectively.\\n5. For number of plates between any two position we can use ```prefix array```.\\n\\n**Time Complexity:**:- O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& q) {\\n        int size=s.size(),fc=-1,bc=-1,plate=0;\\n        vector<int>f(size,0),b(size,0),cnt(size,0);\\n        for(int i=0;i<size;i++){\\n           if(s[i]==\\'*\\')\\n               plate++;\\n            cnt[i]=plate;\\n            if(s[i]==\\'|\\')\\n                fc=i;\\n            f[i]=fc;\\n        }\\n        for(int i=size-1;i>=0;i--){\\n            if(s[i]==\\'|\\')\\n                bc=i;\\n            b[i]=bc;\\n        }\\n        vector<int>ans;\\n        for(auto & i:q){\\n            int p1=b[i[0]],p2=f[i[1]];\\n            if( (p1!=-1 && p2!=-1) &&  p1>= i[0] && p1<=i[1] &&p2>= i[0] && p2<=i[1] )\\n                ans.push_back(cnt[p2]-cnt[p1]);\\n            else\\n                 ans.push_back(0);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :).\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```query is [left,right]```\n``` position(p1)(left<=p1<=right)```\n```position(p2)(left<=p2<=right)```\n```prefix array```\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& q) {\\n        int size=s.size(),fc=-1,bc=-1,plate=0;\\n        vector<int>f(size,0),b(size,0),cnt(size,0);\\n        for(int i=0;i<size;i++){\\n           if(s[i]==\\'*\\')\\n               plate++;\\n            cnt[i]=plate;\\n            if(s[i]==\\'|\\')\\n                fc=i;\\n            f[i]=fc;\\n        }\\n        for(int i=size-1;i>=0;i--){\\n            if(s[i]==\\'|\\')\\n                bc=i;\\n            b[i]=bc;\\n        }\\n        vector<int>ans;\\n        for(auto & i:q){\\n            int p1=b[i[0]],p2=f[i[1]];\\n            if( (p1!=-1 && p2!=-1) &&  p1>= i[0] && p1<=i[1] &&p2>= i[0] && p2<=i[1] )\\n                ans.push_back(cnt[p2]-cnt[p1]);\\n            else\\n                 ans.push_back(0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623911,
                "title": "python-easy-to-understand-prefix-sum",
                "content": "I am taking three arrays, prefix_sum : to calculate the number of plates till that index\\ncandles_left: to store the indices of the candles seen to its left\\ncandles_right: to store the indices of the candles seen to its right\\n\\nRest is pretty much easy to understand\\n\\n\\'\\'\\'\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n\\t\\n        n = len(s)\\n        res = [0] * len(queries)\\n        prefix_sum = [0] * n\\n        candles_left = [-1] * n\\n        candles_right = [-1] * n\\n        \\n        prefix_sum[0] = 1 if s[0] == \\'*\\' else 0\\n        candles_left[0] = 0 if s[0] == \\'|\\' else -1\\n        candles_right[n - 1] = n - 1 if s[n - 1] == \\'|\\' else n\\n        \\n        for i in range(1, n):\\n            prefix_sum[i] = prefix_sum[i - 1] + (1 if s[i] == \\'*\\' else 0)\\n            candles_left[i] = i if s[i] == \\'|\\' else candles_left[i - 1] \\n            \\n        for i in range(n - 2, -1, -1):\\n            candles_right[i] = i if s[i] == \\'|\\' else candles_right[i + 1]\\n            \\n        for i in range(len(queries)):\\n            \\n            start = candles_right[queries[i][0]]\\n            end = candles_left[queries[i][1]]\\n            \\n            res[i] = prefix_sum[end] - prefix_sum[start] if start < end else 0\\n            \\n        return res\\n            \\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "I am taking three arrays, prefix_sum : to calculate the number of plates till that index\\ncandles_left: to store the indices of the candles seen to its left\\ncandles_right: to store the indices of the candles seen to its right\\n\\nRest is pretty much easy to understand\\n\\n\\'\\'\\'\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n\\t\\n        n = len(s)\\n        res = [0] * len(queries)\\n        prefix_sum = [0] * n\\n        candles_left = [-1] * n\\n        candles_right = [-1] * n\\n        \\n        prefix_sum[0] = 1 if s[0] == \\'*\\' else 0\\n        candles_left[0] = 0 if s[0] == \\'|\\' else -1\\n        candles_right[n - 1] = n - 1 if s[n - 1] == \\'|\\' else n\\n        \\n        for i in range(1, n):\\n            prefix_sum[i] = prefix_sum[i - 1] + (1 if s[i] == \\'*\\' else 0)\\n            candles_left[i] = i if s[i] == \\'|\\' else candles_left[i - 1] \\n            \\n        for i in range(n - 2, -1, -1):\\n            candles_right[i] = i if s[i] == \\'|\\' else candles_right[i + 1]\\n            \\n        for i in range(len(queries)):\\n            \\n            start = candles_right[queries[i][0]]\\n            end = candles_left[queries[i][1]]\\n            \\n            res[i] = prefix_sum[end] - prefix_sum[start] if start < end else 0\\n            \\n        return res\\n            \\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2410464,
                "title": "python-binary-search-visually-explained",
                "content": "### Process\\nWe first store all the indices of all the candles in an array called` candles`.\\nNext for every query,\\n* we find the first candle closest to` query[0]` and\\n* we find the last candle closts to `query[1]`.\\nNote: Since we are finding && `candles` is sorted, we get the idea to use binary search.\\nIf these candles are not within the range `(query[0],query[1])`, then no plates between them.\\nIf not, \\n* we calculate the number of items in the range,\\n* the number of candles in the range,\\n* and remove the candles from the items to get the plates.\\n\\n### Visual Explanation\\n![image](https://assets.leetcode.com/users/images/e5a34947-ffd8-45eb-8c8f-93e9d4cb82a3_1660207343.3583345.png)\\n\\n### Code\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        #brute force\\n        n = len(s)\\n        candles = []\\n        out = []\\n        for i in range(n):\\n            if s[i]==\\'|\\':\\n                candles.append(i)    \\n        \\n        def just_smaller_than(candles,i):\\n            l,r = 0,len(candles)-1\\n            while l<=r:\\n                m = (l+r)//2\\n                if candles[m]==i:\\n                    return m\\n                elif candles[m]>i:\\n                    r=m-1\\n                else:\\n                    l=m+1\\n            return r\\n        \\n        def just_larger_than(candles,i):\\n            l,r = 0,len(candles)-1\\n            while l<=r:\\n                m = (l+r)//2\\n                if candles[m]==i:\\n                    return m\\n                elif candles[m]>i:\\n                    r=m-1\\n                else:\\n                    l=m+1\\n            return l\\n        \\n        for s,e in queries:\\n            #find the index of the first candle of the given interval, in the candles array\\n            firstIndx = just_larger_than(candles,s)\\n            \\n            #find the index of the last candle of the given interval, in the candles array\\n            lastIndx = just_smaller_than(candles,e)\\n            \\n            #if no candles in the given interval \\n            if firstIndx>=len(candles) or candles[lastIndx]>e or candles[firstIndx]<s:\\n                out.append(0)\\n                continue\\n\\n            #number of candles\\n            num_candles = lastIndx-firstIndx-1 \\n            # print(\"num candles in range\",num_candles)\\n            \\n            #number of items between first and last candle - this interval would contain both plates and candles\\n            items = candles[lastIndx]-candles[firstIndx]-1\\n            \\n            #Remove the candles from the above interval to get the plates\\n            num_plates = max(0,items-num_candles)\\n            out.append(num_plates)\\n        \\n        return out\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        #brute force\\n        n = len(s)\\n        candles = []\\n        out = []\\n        for i in range(n):\\n            if s[i]==\\'|\\':\\n                candles.append(i)    \\n        \\n        def just_smaller_than(candles,i):\\n            l,r = 0,len(candles)-1\\n            while l<=r:\\n                m = (l+r)//2\\n                if candles[m]==i:\\n                    return m\\n                elif candles[m]>i:\\n                    r=m-1\\n                else:\\n                    l=m+1\\n            return r\\n        \\n        def just_larger_than(candles,i):\\n            l,r = 0,len(candles)-1\\n            while l<=r:\\n                m = (l+r)//2\\n                if candles[m]==i:\\n                    return m\\n                elif candles[m]>i:\\n                    r=m-1\\n                else:\\n                    l=m+1\\n            return l\\n        \\n        for s,e in queries:\\n            #find the index of the first candle of the given interval, in the candles array\\n            firstIndx = just_larger_than(candles,s)\\n            \\n            #find the index of the last candle of the given interval, in the candles array\\n            lastIndx = just_smaller_than(candles,e)\\n            \\n            #if no candles in the given interval \\n            if firstIndx>=len(candles) or candles[lastIndx]>e or candles[firstIndx]<s:\\n                out.append(0)\\n                continue\\n\\n            #number of candles\\n            num_candles = lastIndx-firstIndx-1 \\n            # print(\"num candles in range\",num_candles)\\n            \\n            #number of items between first and last candle - this interval would contain both plates and candles\\n            items = candles[lastIndx]-candles[firstIndx]-1\\n            \\n            #Remove the candles from the above interval to get the plates\\n            num_plates = max(0,items-num_candles)\\n            out.append(num_plates)\\n        \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336155,
                "title": "c-o-n-solution-using-prefix-sum-detailed-explanation",
                "content": "**Algorithm:** \\nFor a query [a, b]\\n1. Find the index of the candle present to the right of the a\\n2. Find the index of the candle present to the left of the b\\n3. Count the plates present between indices a and b, which is the ans\\n\\n**Note:** If there is no candle to the left/right of any index, then store -1\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n\\t\\t// Stores the index of the candle present to the left of the current index\\n        vector<int> left(n, -1);\\n\\t\\t// Stores the index of the candle present to the right of the current index\\n        vector<int> right(n, -1);\\n\\t\\t// Prefix sum of plates\\n        vector<int> count(n, 0);\\n        \\n\\t\\tcount[0] = (s.front() == \\'*\\' ? 1 : 0);\\n        left[0] = (s.front() == \\'|\\' ? 0 : -1);\\n        right[n-1] = (s.back() == \\'|\\' ? n-1 : -1);\\n        \\n        int start = 1, end = n-2;\\n        \\n\\t\\t// Calculating indices and prefix sum\\n        while(start < n){\\n            count[start] = (s[start] == \\'*\\' ? 1 : 0) + count[start-1];\\n            left[start] = (s[start] == \\'|\\' ? start : left[start-1]);\\n            right[end] = (s[end] == \\'|\\' ? end : right[end+1]);    \\n            start++;\\n            end--;\\n        }\\n        \\n        vector<int> ans;\\n        for(auto it: queries){\\n            int l = right[it[0]], r = left[it[1]];\\n\\t\\t\\t\\n\\t\\t\\t// No proper candle boundaries\\n            if(l == -1 || r == -1 || l >= r){\\n                ans.push_back(0);\\n            }\\n            else{\\n                ans.push_back(count[r]-count[l]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n\\t\\t// Stores the index of the candle present to the left of the current index\\n        vector<int> left(n, -1);\\n\\t\\t// Stores the index of the candle present to the right of the current index\\n        vector<int> right(n, -1);\\n\\t\\t// Prefix sum of plates\\n        vector<int> count(n, 0);\\n        \\n\\t\\tcount[0] = (s.front() == \\'*\\' ? 1 : 0);\\n        left[0] = (s.front() == \\'|\\' ? 0 : -1);\\n        right[n-1] = (s.back() == \\'|\\' ? n-1 : -1);\\n        \\n        int start = 1, end = n-2;\\n        \\n\\t\\t// Calculating indices and prefix sum\\n        while(start < n){\\n            count[start] = (s[start] == \\'*\\' ? 1 : 0) + count[start-1];\\n            left[start] = (s[start] == \\'|\\' ? start : left[start-1]);\\n            right[end] = (s[end] == \\'|\\' ? end : right[end+1]);    \\n            start++;\\n            end--;\\n        }\\n        \\n        vector<int> ans;\\n        for(auto it: queries){\\n            int l = right[it[0]], r = left[it[1]];\\n\\t\\t\\t\\n\\t\\t\\t// No proper candle boundaries\\n            if(l == -1 || r == -1 || l >= r){\\n                ans.push_back(0);\\n            }\\n            else{\\n                ans.push_back(count[r]-count[l]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1648902,
                "title": "python-prefix-sum-o-n",
                "content": "Time_Complexity-O(N)\\nSpace_Complexity-O(N)\\ntotal_plates-> Denotes total no of plates encountered till that index while iterating from left to right\\nleft->Denotes next(latest) candle from that index to right side of string\\nright->Denotes next(latest) candle from that index to left side of string\\n\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        n,m=len(s),len(queries)\\n        total_plates=[0]*n\\n        left,right=[-1]*n,[-1]*n\\n        for i,c in enumerate(s):\\n            if i==0: continue\\n            if c==\\'*\\': total_plates[i]=total_plates[i-1]+1\\n            else: total_plates[i]=total_plates[i-1]\\n        right_latest,left_latest=-1,-1\\n        for i,c in enumerate(s):\\n            if c==\\'|\\': right_latest=i\\n            right[i]=right_latest\\n        for i in range(n-1,-1,-1):\\n            c=s[i]\\n            if c==\\'|\\': left_latest=i\\n            left[i]=left_latest\\n        ans=[0]*m\\n        for i,(l,r) in enumerate(queries):\\n            left_plate,right_plate=left[l],right[r]\\n            if left_plate==-1 or right_plate==-1 or (left_plate>=right_plate):\\n                continue\\n            val=total_plates[right_plate]-total_plates[left_plate]\\n            ans[i]=val\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        n,m=len(s),len(queries)\\n        total_plates=[0]*n\\n        left,right=[-1]*n,[-1]*n\\n        for i,c in enumerate(s):\\n            if i==0: continue\\n            if c==\\'*\\': total_plates[i]=total_plates[i-1]+1\\n            else: total_plates[i]=total_plates[i-1]\\n        right_latest,left_latest=-1,-1\\n        for i,c in enumerate(s):\\n            if c==\\'|\\': right_latest=i\\n            right[i]=right_latest\\n        for i in range(n-1,-1,-1):\\n            c=s[i]\\n            if c==\\'|\\': left_latest=i\\n            left[i]=left_latest\\n        ans=[0]*m\\n        for i,(l,r) in enumerate(queries):\\n            left_plate,right_plate=left[l],right[r]\\n            if left_plate==-1 or right_plate==-1 or (left_plate>=right_plate):\\n                continue\\n            val=total_plates[right_plate]-total_plates[left_plate]\\n            ans[i]=val\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569561,
                "title": "python-o-n-easy-to-understand-with-explanation",
                "content": "```\\nclass Solution(object):\\n    def platesBetweenCandles(self, s, queries):\\n        \"\"\"\\n        :type s: str\\n        :type queries: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        # before[i] sums the plates between candles before i.\\n        before = [0] * len(s)\\n        if s[0] == \\'|\\':\\n            can = 0\\n        else:\\n            can = None\\n        for i in range(1, len(s)):\\n            if s[i] == \\'|\\':\\n                if can is not None:\\n                    before[i] = before[i-1] + can\\n                can = 0\\n            else:\\n                before[i] = before[i-1]\\n                if can is not None:\\n                    can += 1\\n        \\n        # after[i] sums the plates between candles after i.\\n        after = [0] * len(s)\\n        if s[-1] == \\'|\\':\\n            can = 0\\n        else:\\n            can = None\\n        for i in range(len(s) - 2, -1, -1):\\n            if s[i] == \\'|\\':\\n                if can is not None:\\n                    after[i] = after[i + 1] + can\\n                can = 0\\n            else:\\n                after[i] = after[i + 1]\\n                if can is not None:\\n                    can += 1\\n\\n        # total sums all the plates between candles in s.\\n        total = max(before)\\n        \\n        # after[left]:   -------------*******************\\n        # before[right]: ******************--------------\\n        # total:         ********************************\\n        ret = [0] * len(queries)\\n        for i, [left, right] in enumerate(queries):\\n            ret[i] = max(0, after[left] + before[right] - total)\\n\\n        return ret\\n```\\n**If you have any questoins, feel free to ask. If you like the solution and explanation, please upvote!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def platesBetweenCandles(self, s, queries):\\n        \"\"\"\\n        :type s: str\\n        :type queries: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        # before[i] sums the plates between candles before i.\\n        before = [0] * len(s)\\n        if s[0] == \\'|\\':\\n            can = 0\\n        else:\\n            can = None\\n        for i in range(1, len(s)):\\n            if s[i] == \\'|\\':\\n                if can is not None:\\n                    before[i] = before[i-1] + can\\n                can = 0\\n            else:\\n                before[i] = before[i-1]\\n                if can is not None:\\n                    can += 1\\n        \\n        # after[i] sums the plates between candles after i.\\n        after = [0] * len(s)\\n        if s[-1] == \\'|\\':\\n            can = 0\\n        else:\\n            can = None\\n        for i in range(len(s) - 2, -1, -1):\\n            if s[i] == \\'|\\':\\n                if can is not None:\\n                    after[i] = after[i + 1] + can\\n                can = 0\\n            else:\\n                after[i] = after[i + 1]\\n                if can is not None:\\n                    can += 1\\n\\n        # total sums all the plates between candles in s.\\n        total = max(before)\\n        \\n        # after[left]:   -------------*******************\\n        # before[right]: ******************--------------\\n        # total:         ********************************\\n        ret = [0] * len(queries)\\n        for i, [left, right] in enumerate(queries):\\n            ret[i] = max(0, after[left] + before[right] - total)\\n\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551005,
                "title": "java-treemap-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n       TreeMap<Integer,Integer> maps = new TreeMap<Integer,Integer>();\\n       char[] array = s.toCharArray(); \\n       int p = 0;\\n       for(int i = 0; i < array.length; i++){\\n           if(array[i] == \\'|\\') maps.put(i,p++);\\n       } \\n        \\n       int[] result = new int[queries.length];\\n       for(int i = 0;i < queries.length; i++){\\n           try{\\n           Map.Entry<Integer,Integer> startKey = maps.ceilingEntry(queries[i][0]);\\n           Map.Entry<Integer,Integer> endKey = maps.floorEntry(queries[i][1]);\\n           result[i] = endKey.getKey() - startKey.getKey() - (endKey.getValue() - startKey.getValue());\\n           if(result[i] < 0) result[i] = 0;\\n            \\n           }\\n           catch(Exception exp){}\\n       } \\n      \\n       return result; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n       TreeMap<Integer,Integer> maps = new TreeMap<Integer,Integer>();\\n       char[] array = s.toCharArray(); \\n       int p = 0;\\n       for(int i = 0; i < array.length; i++){\\n           if(array[i] == \\'|\\') maps.put(i,p++);\\n       } \\n        \\n       int[] result = new int[queries.length];\\n       for(int i = 0;i < queries.length; i++){\\n           try{\\n           Map.Entry<Integer,Integer> startKey = maps.ceilingEntry(queries[i][0]);\\n           Map.Entry<Integer,Integer> endKey = maps.floorEntry(queries[i][1]);\\n           result[i] = endKey.getKey() - startKey.getKey() - (endKey.getValue() - startKey.getValue());\\n           if(result[i] < 0) result[i] = 0;\\n            \\n           }\\n           catch(Exception exp){}\\n       } \\n      \\n       return result; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562293,
                "title": "simple-c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.size();  \\n        vector<int> cnt(n);\\n        if(s[0] == \\'*\\') \\n            cnt[0] = 1;\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(s[i] == \\'*\\')\\n                cnt[i] = cnt[i-1] + 1;\\n            else\\n                cnt[i] = cnt[i-1];\\n        } \\n        vector<int> left(n);\\n        if(s[0] == \\'|\\')\\n            left[0] = 0;\\n        else\\n            left[0] = -1;\\n        for(int i = 1; i < n; i++) {\\n            if(s[i] == \\'|\\')\\n                left[i] = i;\\n            else \\n                left[i] = left[i-1];\\n        }\\n\\n        vector<int> right(n);\\n        if(s[n-1] == \\'|\\')\\n            right[n-1] = n-1;\\n        else\\n            right[n-1] = -1;\\n        for(int i = n - 2; i >= 0; i--) {\\n            if(s[i] == \\'|\\')\\n                right[i] = i;\\n            else\\n                right[i] = right[i+1];\\n        }\\n        \\n        int q;\\n        q = queries.size();\\n        vector<int> ans;\\n        for(int i = 0; i < q; i++){\\n            int l = right[queries[i][0]];\\n            int r = left[queries[i][1]];\\n            if(l == -1 || r == -1 || l >= r) {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            ans.push_back(cnt[r] - cnt[l]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.size();  \\n        vector<int> cnt(n);\\n        if(s[0] == \\'*\\') \\n            cnt[0] = 1;\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(s[i] == \\'*\\')\\n                cnt[i] = cnt[i-1] + 1;\\n            else\\n                cnt[i] = cnt[i-1];\\n        } \\n        vector<int> left(n);\\n        if(s[0] == \\'|\\')\\n            left[0] = 0;\\n        else\\n            left[0] = -1;\\n        for(int i = 1; i < n; i++) {\\n            if(s[i] == \\'|\\')\\n                left[i] = i;\\n            else \\n                left[i] = left[i-1];\\n        }\\n\\n        vector<int> right(n);\\n        if(s[n-1] == \\'|\\')\\n            right[n-1] = n-1;\\n        else\\n            right[n-1] = -1;\\n        for(int i = n - 2; i >= 0; i--) {\\n            if(s[i] == \\'|\\')\\n                right[i] = i;\\n            else\\n                right[i] = right[i+1];\\n        }\\n        \\n        int q;\\n        q = queries.size();\\n        vector<int> ans;\\n        for(int i = 0; i < q; i++){\\n            int l = right[queries[i][0]];\\n            int r = left[queries[i][1]];\\n            if(l == -1 || r == -1 || l >= r) {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            ans.push_back(cnt[r] - cnt[l]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678618,
                "title": "o-n-q-i-think-prefix-sum-array",
                "content": "Calculate total sum + how much to subtract at each spot (prefix sum arrays).\\n\\nFor example:\\n```\\n| * | * * | * * * | | * \\n0 1 1 3 3 3 6 6 6 6 6 6\\n0 0 1 1 1 3 3 3 3 6 6 6\\n```\\nFirst row is how much to subtract and second row is how much to add. Anything below zero is set to zero. Basically second row is how many \"complete\" candles to include, and first row is how many \"incomplete\" candles to uninclude.\\nFor a query `[4 9]` take 6 - 3 to get 3 candles between the two.\\n### C++\\n```\\nvector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n    const int n = s.length();\\n    vector<int> addVal(n), subVal(n);\\n    int cnt = 0;\\n    int tc = 0;\\n    int start = -1;\\n    for(int i = 0; i < n; i++){\\n        if(s[i] == \\'|\\'){\\n            tc = cnt;\\n            for(int j = i; j > start; j--){\\n                subVal[j] = tc;\\n            }\\n            start = i;\\n        } else cnt ++;\\n        addVal[i] = tc;\\n    }\\n    for(int j = start + 1; j < n; j++){\\n        subVal[j] = tc;\\n    }\\n    vector<int> res;\\n    for(auto q: queries){\\n        int ans = addVal[q[1]] - subVal[q[0]];\\n        if(ans < 0) ans = 0;\\n        res.push_back(ans);\\n    }\\n    return res;\\n}\\n```\\n\\n##### Note on time complexity:\\n```\\nfor(int i = 0; i < n; i++){\\n    if(s[i] == \\'|\\'){\\n        tc = cnt;\\n        for(int j = i; j > start; j--){\\n            subVal[j] = tc;\\n        }\\n        start = i;\\n    } else cnt ++;\\n    addVal[i] = tc;\\n}\\nfor(int j = start + 1; j < n; j++){\\n    subVal[j] = tc;\\n}\\n```\\nThis is O(2N) since `j` is limited to run `n` times at most. This set of loops is therefore O(N) time. All inner opporations are O(1) time.\\n```\\nfor(auto q: queries){\\n    int ans = addVal[q[1]] - subVal[q[0]];\\n    if(ans < 0) ans = 0;\\n    res.push_back(ans);\\n}\\n```\\nThis is O(Q) time since the inner operations are O(1) time, run Q times.",
                "solutionTags": [],
                "code": "```\\n| * | * * | * * * | | * \\n0 1 1 3 3 3 6 6 6 6 6 6\\n0 0 1 1 1 3 3 3 3 6 6 6\\n```\n```\\nvector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n    const int n = s.length();\\n    vector<int> addVal(n), subVal(n);\\n    int cnt = 0;\\n    int tc = 0;\\n    int start = -1;\\n    for(int i = 0; i < n; i++){\\n        if(s[i] == \\'|\\'){\\n            tc = cnt;\\n            for(int j = i; j > start; j--){\\n                subVal[j] = tc;\\n            }\\n            start = i;\\n        } else cnt ++;\\n        addVal[i] = tc;\\n    }\\n    for(int j = start + 1; j < n; j++){\\n        subVal[j] = tc;\\n    }\\n    vector<int> res;\\n    for(auto q: queries){\\n        int ans = addVal[q[1]] - subVal[q[0]];\\n        if(ans < 0) ans = 0;\\n        res.push_back(ans);\\n    }\\n    return res;\\n}\\n```\n```\\nfor(int i = 0; i < n; i++){\\n    if(s[i] == \\'|\\'){\\n        tc = cnt;\\n        for(int j = i; j > start; j--){\\n            subVal[j] = tc;\\n        }\\n        start = i;\\n    } else cnt ++;\\n    addVal[i] = tc;\\n}\\nfor(int j = start + 1; j < n; j++){\\n    subVal[j] = tc;\\n}\\n```\n```\\nfor(auto q: queries){\\n    int ans = addVal[q[1]] - subVal[q[0]];\\n    if(ans < 0) ans = 0;\\n    res.push_back(ans);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2572970,
                "title": "easy-python-o-q-n-solution-using-preprocessing-without-the-need-of-binary-search",
                "content": "```\\n# O(Q+N)\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        candle = int(s[0] == \\'*\\')\\n        before = [0] * len(s)\\n        # pass 1: forward\\n        for i in range(1, len(s)):\\n            if s[i] == \\'*\\':\\n                candle += 1\\n                before[i] = before[i-1]\\n            else: before[i] = candle;\\n                \\n        total = candle \\n        candle = int(s[-1] == \\'*\\')\\n        after = [0] * len(s)\\n        # pass 2: backwards\\n        for i in range(len(s)-2, -1, -1):\\n            if s[i] == \\'*\\':\\n                candle += 1\\n                after[i] = after[i+1]\\n            else:\\n                after[i] = candle\\n        \\n        # getting the results:\\n        # after l = after the first dish in that bound\\n        # before r = before the last dish in that bound\\n        # desired values are counted twice: which can be eliminated by -total\\n        ans = []\\n        for l, r in queries:\\n            ans.append(max(0, after[l] + before[r] - total))\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# O(Q+N)\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        candle = int(s[0] == \\'*\\')\\n        before = [0] * len(s)\\n        # pass 1: forward\\n        for i in range(1, len(s)):\\n            if s[i] == \\'*\\':\\n                candle += 1\\n                before[i] = before[i-1]\\n            else: before[i] = candle;\\n                \\n        total = candle \\n        candle = int(s[-1] == \\'*\\')\\n        after = [0] * len(s)\\n        # pass 2: backwards\\n        for i in range(len(s)-2, -1, -1):\\n            if s[i] == \\'*\\':\\n                candle += 1\\n                after[i] = after[i+1]\\n            else:\\n                after[i] = candle\\n        \\n        # getting the results:\\n        # after l = after the first dish in that bound\\n        # before r = before the last dish in that bound\\n        # desired values are counted twice: which can be eliminated by -total\\n        ans = []\\n        for l, r in queries:\\n            ans.append(max(0, after[l] + before[r] - total))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2530494,
                "title": "python-binary-search",
                "content": "For every query, we should find out the right most candle and left most candle.\\nThen we just count the number of plates between left most and right most candles.\\n\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        # Fine the candles indexes\\n        cand_idx = []\\n        for idx in range(len(s)):\\n            if s[idx] == \"|\":\\n                cand_idx.append(idx)\\n        \\n        ans = []\\n        for query in queries:\\n            left, right = query\\n            \\n            # find the left most candles in the query\\n            l = bisect.bisect_left(cand_idx, left)\\n            \\n            # find the right most candles in the query\\n            r = bisect.bisect_right(cand_idx, right)\\n            \\n            # if l == r, it means there is no candle in\\n            # the query range\\n            if l == r:\\n                ans.append(0)\\n                continue\\n            \\n            # find the left most candle index in original array\\n            l_idx = cand_idx[l]\\n            \\n            # find the right most candle index in original array\\n            r_idx = cand_idx[r-1]\\n            \\n            # find the candles count by checking the index in cand_idx\\n            cand_count = r - l\\n            \\n            # `r_idx - l_idx + 1`: the number of something between\\n            # left most and right most candles\\n            # then minus the number of candles count\\n            ans.append(r_idx - l_idx + 1 - cand_count)\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        # Fine the candles indexes\\n        cand_idx = []\\n        for idx in range(len(s)):\\n            if s[idx] == \"|\":\\n                cand_idx.append(idx)\\n        \\n        ans = []\\n        for query in queries:\\n            left, right = query\\n            \\n            # find the left most candles in the query\\n            l = bisect.bisect_left(cand_idx, left)\\n            \\n            # find the right most candles in the query\\n            r = bisect.bisect_right(cand_idx, right)\\n            \\n            # if l == r, it means there is no candle in\\n            # the query range\\n            if l == r:\\n                ans.append(0)\\n                continue\\n            \\n            # find the left most candle index in original array\\n            l_idx = cand_idx[l]\\n            \\n            # find the right most candle index in original array\\n            r_idx = cand_idx[r-1]\\n            \\n            # find the candles count by checking the index in cand_idx\\n            cand_count = r - l\\n            \\n            # `r_idx - l_idx + 1`: the number of something between\\n            # left most and right most candles\\n            # then minus the number of candles count\\n            ans.append(r_idx - l_idx + 1 - cand_count)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2483886,
                "title": "treeset-java-easy-and-concise",
                "content": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int len = s.length();\\n        int[]left= new int[len];\\n        TreeSet<Integer> candles = new TreeSet<>();\\n        int leftPlateCount = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'|\\')\\n            {\\n                candles.add(i);\\n                left[i] = leftPlateCount;\\n            }else{\\n            leftPlateCount++;\\n            }\\n        }\\n        int[] result = new int[queries.length];\\n        int i=0;\\n        for(int query[] : queries){\\n            Integer leftMostCandle = candles.ceiling(query[0]);\\n            Integer rightMostCandle = candles.floor(query[1]);\\n            if(leftMostCandle!=null && rightMostCandle!=null && leftMostCandle<rightMostCandle)\\n                result[i] = left[rightMostCandle]-left[leftMostCandle];\\n            \\n            i++;\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int len = s.length();\\n        int[]left= new int[len];\\n        TreeSet<Integer> candles = new TreeSet<>();\\n        int leftPlateCount = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'|\\')\\n            {\\n                candles.add(i);\\n                left[i] = leftPlateCount;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2331945,
                "title": "c-2-solution-brute-force-optimized-binary-search",
                "content": "***Brute Force Approach***\\n```\\nint countn( string st , int s, int e ){\\n        bool c = false;\\n        int endind= -1;\\n        int startind =-1;\\n        int count =0;\\n        int n=0;\\n        for(int i=s; i<=e; i++){\\n            if(c==true){\\n                count++;\\n            }\\n            if(st[i]==\\'|\\'){\\n                if( c== false){\\n                    c= true;\\n                    startind= i; \\n                }\\n                n++;\\n                endind=i;\\n            }\\n        }\\n        \\n        if( n==0 || n==1 ) return 0;\\n        return ((endind - startind+1)- n);\\n    }\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto i: queries){\\n            int st = i[0];\\n            int e = i[1];\\n            int count = countn(s, st, e);\\n            ans.push_back( count);\\n        }\\n        return ans;\\n    }\\n```\\n\\n\\n***Binary search approach***\\n\\n```\\nvector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        vector<int> v;\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            if( s[i]==\\'|\\'){\\n                v.emplace_back(i);\\n            }\\n        }\\n        vector<int> ans;\\n        for(auto i: queries){\\n            if( i[0]==i[1] || i[1]-i[0]==1){\\n                ans.emplace_back(0);\\n                continue;\\n            }\\n            int st = lower_bound(v.begin(), v.end(),i[0]) - v.begin();\\n            int e = upper_bound(v.begin(), v.end(), i[1]) - v.begin();\\n            \\n            --e;\\n            int count =  (v[e]-v[st]+1)- (e-st+1);\\n            count = count<0? 0: count;\\n            ans.emplace_back( count);\\n        }\\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint countn( string st , int s, int e ){\\n        bool c = false;\\n        int endind= -1;\\n        int startind =-1;\\n        int count =0;\\n        int n=0;\\n        for(int i=s; i<=e; i++){\\n            if(c==true){\\n                count++;\\n            }\\n            if(st[i]==\\'|\\'){\\n                if( c== false){\\n                    c= true;\\n                    startind= i; \\n                }\\n                n++;\\n                endind=i;\\n            }\\n        }\\n        \\n        if( n==0 || n==1 ) return 0;\\n        return ((endind - startind+1)- n);\\n    }\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto i: queries){\\n            int st = i[0];\\n            int e = i[1];\\n            int count = countn(s, st, e);\\n            ans.push_back( count);\\n        }\\n        return ans;\\n    }\\n```\n```\\nvector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        vector<int> v;\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            if( s[i]==\\'|\\'){\\n                v.emplace_back(i);\\n            }\\n        }\\n        vector<int> ans;\\n        for(auto i: queries){\\n            if( i[0]==i[1] || i[1]-i[0]==1){\\n                ans.emplace_back(0);\\n                continue;\\n            }\\n            int st = lower_bound(v.begin(), v.end(),i[0]) - v.begin();\\n            int e = upper_bound(v.begin(), v.end(), i[1]) - v.begin();\\n            \\n            --e;\\n            int count =  (v[e]-v[st]+1)- (e-st+1);\\n            count = count<0? 0: count;\\n            ans.emplace_back( count);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2245878,
                "title": "c-tricky-prefix-sum-solution-diagram",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        \\n        int n = s.size();\\n        \\n        //Plate Prefix Sum  \\n        vector<int> total(n);\\n        if(s[0] == \\'*\\') \\n            total[0] = 1;\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            if(s[i] == \\'*\\')\\n                total[i] = total[i-1] + 1;\\n            else\\n                total[i] = total[i-1];\\n        }\\n        \\n        //Candle - Leftmost Nearest Prefix Sum \\n        vector<int> left(n);\\n        if(s[0] == \\'|\\')\\n            left[0] = 0;\\n        else\\n            left[0] = -1;\\n        for(int i=1; i<n; i++)\\n        {\\n            if(s[i] == \\'|\\')\\n                left[i] = i;\\n            else \\n                left[i] = left[i-1];\\n        }\\n        \\n        //Candle - Rightmost Nearest Prefix Sum \\n        vector<int> right(n);\\n        if(s[n-1] == \\'|\\')\\n            right[n-1] = n-1;\\n        else\\n            right[n-1] = -1;\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            if(s[i] == \\'|\\')\\n                right[i] = i;\\n            else\\n                right[i] = right[i+1];\\n        }\\n        \\n        int q;\\n        q = queries.size();\\n        vector<int> ans;\\n        for(int i=0; i<queries.size(); i++){\\n            int l = right[queries[i][0]];\\n            int r = left[queries[i][1]];\\n            if(l == -1 || r==-1 || l>=r)\\n            {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            ans.push_back(total[r]-total[l]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nDo Checkeout Code Explainer\\'s video on this \\n![image](https://assets.leetcode.com/users/images/6c5dcfc5-9c9a-47f4-939d-0e9d3e603f99_1657104374.1560383.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        \\n        int n = s.size();\\n        \\n        //Plate Prefix Sum  \\n        vector<int> total(n);\\n        if(s[0] == \\'*\\') \\n            total[0] = 1;\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            if(s[i] == \\'*\\')\\n                total[i] = total[i-1] + 1;\\n            else\\n                total[i] = total[i-1];\\n        }\\n        \\n        //Candle - Leftmost Nearest Prefix Sum \\n        vector<int> left(n);\\n        if(s[0] == \\'|\\')\\n            left[0] = 0;\\n        else\\n            left[0] = -1;\\n        for(int i=1; i<n; i++)\\n        {\\n            if(s[i] == \\'|\\')\\n                left[i] = i;\\n            else \\n                left[i] = left[i-1];\\n        }\\n        \\n        //Candle - Rightmost Nearest Prefix Sum \\n        vector<int> right(n);\\n        if(s[n-1] == \\'|\\')\\n            right[n-1] = n-1;\\n        else\\n            right[n-1] = -1;\\n        for(int i=n-2; i>=0; i--)\\n        {\\n            if(s[i] == \\'|\\')\\n                right[i] = i;\\n            else\\n                right[i] = right[i+1];\\n        }\\n        \\n        int q;\\n        q = queries.size();\\n        vector<int> ans;\\n        for(int i=0; i<queries.size(); i++){\\n            int l = right[queries[i][0]];\\n            int r = left[queries[i][1]];\\n            if(l == -1 || r==-1 || l>=r)\\n            {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            ans.push_back(total[r]-total[l]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899500,
                "title": "simple-solution-in-java-without-inbuilt-binary-search-function-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        \\n        List<Integer> candles = new ArrayList<>();\\n        int[] preSum = new int[s.length()];\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i) == \\'|\\'){\\n                candles.add(i);\\n            }\\n            \\n            preSum[i] += ( i >= 1 ? preSum[i-1] : 0) + (s.charAt(i) == \\'*\\' ?  1 : 0);\\n        }\\n        \\n        // Do the binary search to find starting and the ending candle \\n        int[] res = new int[queries.length];\\n        if(candles.size() == 0) return res;\\n        \\n        // System.out.println(candles);\\n        for(int i=0; i<queries.length; i++){\\n            if(queries[i][0] == queries[i][1] || queries[i][0] + 1 == queries[i][1]) continue;\\n            \\n            int startCandle = find(candles, queries[i][0]);\\n            int endCandle = find(candles, queries[i][1]);\\n            \\n            //System.out.println(startCandle + \" \" + endCandle);\\n            if(candles.get(endCandle) > queries[i][1]) endCandle -= 1;\\n            \\n            if(endCandle <= startCandle) continue;\\n            \\n            res[i] = preSum[candles.get(endCandle)] - preSum[candles.get(startCandle)];\\n            //System.out.println(res[i]);\\n        }\\n            \\n        return res;\\n    }\\n    \\n    private int find(List<Integer> candles, int key){\\n        int numCandles = candles.size();\\n        \\n        if(candles.get(numCandles-1) < key) return candles.size() - 1;\\n        if(candles.get(0) > key) return 0;\\n        \\n        int l = 0;\\n        int h = candles.size() - 1;\\n        \\n        while(l < h){\\n            int m =  l + (h-l)/2;\\n            \\n            if(candles.get(m) < key){\\n                l = m + 1;\\n            }else{\\n                h = m;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        \\n        List<Integer> candles = new ArrayList<>();\\n        int[] preSum = new int[s.length()];\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i) == \\'|\\'){\\n                candles.add(i);\\n            }\\n            \\n            preSum[i] += ( i >= 1 ? preSum[i-1] : 0) + (s.charAt(i) == \\'*\\' ?  1 : 0);\\n        }\\n        \\n        // Do the binary search to find starting and the ending candle \\n        int[] res = new int[queries.length];\\n        if(candles.size() == 0) return res;\\n        \\n        // System.out.println(candles);\\n        for(int i=0; i<queries.length; i++){\\n            if(queries[i][0] == queries[i][1] || queries[i][0] + 1 == queries[i][1]) continue;\\n            \\n            int startCandle = find(candles, queries[i][0]);\\n            int endCandle = find(candles, queries[i][1]);\\n            \\n            //System.out.println(startCandle + \" \" + endCandle);\\n            if(candles.get(endCandle) > queries[i][1]) endCandle -= 1;\\n            \\n            if(endCandle <= startCandle) continue;\\n            \\n            res[i] = preSum[candles.get(endCandle)] - preSum[candles.get(startCandle)];\\n            //System.out.println(res[i]);\\n        }\\n            \\n        return res;\\n    }\\n    \\n    private int find(List<Integer> candles, int key){\\n        int numCandles = candles.size();\\n        \\n        if(candles.get(numCandles-1) < key) return candles.size() - 1;\\n        if(candles.get(0) > key) return 0;\\n        \\n        int l = 0;\\n        int h = candles.size() - 1;\\n        \\n        while(l < h){\\n            int m =  l + (h-l)/2;\\n            \\n            if(candles.get(m) < key){\\n                l = m + 1;\\n            }else{\\n                h = m;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1773161,
                "title": "java-o-n-simple-solution-using-prefix-sum-with-algorithm-explanations",
                "content": "Linear time and space:\\nTime complexity: `O(s + q)`, where `s` is the length of the string, and `q` is the number of queries.\\nSpace complexity: `O(s)`.\\n\\n**Approach:**\\n1. Calculate cumulative number of plates (prefix sum) in `O(s)`.\\n2. For each index, calculate the closest candle from left and from right in `O(s)`.\\n3. For each query (`O(q)`) :\\n\\ta. Get updated indexes of substring that include candles (using arrays calculated is step 2) in `O(1)`.\\n\\tb. If new substring boundaries are valid, get the number of plates between them in `O(1)`.\\n\\n**Java code:**\\n\\n```\\nclass Solution {\\n    // O(sLen + queries.length) time, O(sLen) space\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int sLen = s.length();\\n        // cumulative number of plates from the left\\n        int[] numberOfPlates = new int[sLen+1];\\n        for (int i=0; i<sLen; i++) {\\n            numberOfPlates[i+1] = numberOfPlates[i] + (s.charAt(i) == \\'*\\' ? 1 : 0);\\n        }\\n        // closest candle to the left\\n        int[] candleToTheLeft = new int[sLen];\\n        int cand = -1;\\n        for (int i=0; i<sLen; i++) {\\n            if (s.charAt(i) == \\'|\\') {\\n                cand = i;\\n            }\\n            candleToTheLeft[i] = cand;\\n        }\\n        // closest candle to the right\\n        int[] candleToTheRight = new int[sLen];\\n        cand = -1;\\n        for (int i=sLen-1; i>=0; i--) {\\n            if (s.charAt(i) == \\'|\\') {\\n                cand = i;\\n            }\\n            candleToTheRight[i] = cand;\\n        }\\n        // for each query - count the number of plates between closest candles\\n        int[] res = new int[queries.length];\\n        for (int i=0; i<queries.length; i++) {\\n            int left = candleToTheRight[queries[i][0]];\\n            int right = candleToTheLeft[queries[i][1]];\\n            if (left == -1 || right == -1 || left >= right) {\\n                res[i] = 0;\\n            } else {\\n                res[i] = numberOfPlates[right+1] - numberOfPlates[left];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    // O(sLen + queries.length) time, O(sLen) space\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int sLen = s.length();\\n        // cumulative number of plates from the left\\n        int[] numberOfPlates = new int[sLen+1];\\n        for (int i=0; i<sLen; i++) {\\n            numberOfPlates[i+1] = numberOfPlates[i] + (s.charAt(i) == \\'*\\' ? 1 : 0);\\n        }\\n        // closest candle to the left\\n        int[] candleToTheLeft = new int[sLen];\\n        int cand = -1;\\n        for (int i=0; i<sLen; i++) {\\n            if (s.charAt(i) == \\'|\\') {\\n                cand = i;\\n            }\\n            candleToTheLeft[i] = cand;\\n        }\\n        // closest candle to the right\\n        int[] candleToTheRight = new int[sLen];\\n        cand = -1;\\n        for (int i=sLen-1; i>=0; i--) {\\n            if (s.charAt(i) == \\'|\\') {\\n                cand = i;\\n            }\\n            candleToTheRight[i] = cand;\\n        }\\n        // for each query - count the number of plates between closest candles\\n        int[] res = new int[queries.length];\\n        for (int i=0; i<queries.length; i++) {\\n            int left = candleToTheRight[queries[i][0]];\\n            int right = candleToTheLeft[queries[i][1]];\\n            if (left == -1 || right == -1 || left >= right) {\\n                res[i] = 0;\\n            } else {\\n                res[i] = numberOfPlates[right+1] - numberOfPlates[left];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552817,
                "title": "c-100-faster-prefix-and-suffix-array-easy-and-simple",
                "content": "**rdp_plates[i]** keeps count of no of plates which are at index greater than or equal to i\\n**ldp_candle[i]**  stores the maximum index value which is left or equal to i and has candle at that index if no such index found it stores -1\\n**rdp_candle[i]**  stores the minimum index value which is right or equal to i and has candle at that index if no\\nsuch index found it stores -1\\n\\n**no of plates betwen two indices i and j which are surrounded by candles = no of plates between rdp_candle[i] and ldp_candle[j]**\\n\\n\"\"\"\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& q) {\\n        \\n        int n=s.size();\\n        \\n        vector<int>rdp_plates(n,0);\\n        int ct=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'*\\') \\n                ct++;\\n            rdp_plates[i]=ct;\\n        }\\n         \\n\\n        vector<int>ldp_candle(n,0);\\n        vector<int>rdp_candle(n,0);\\n        ldp_candle[0]=s[0]==\\'|\\'?0:-1;\\n        rdp_candle[n-1]=s[n-1]==\\'|\\'?n-1:-1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            ldp_candle[i]= s[i]==\\'|\\'?i:ldp_candle[i-1];\\n            rdp_candle[n-1-i]= s[n-1-i]==\\'|\\'?n-1-i:rdp_candle[n-i];\\n        }\\n        \\n        vector<int>res;\\n        int st,end;\\n        for(int i=0;i<q.size();i++){\\n            st=rdp_candle[q[i][0]];end=ldp_candle[q[i][1]];\\n            if(st!=-1 && end!=-1 && st<end)\\n                res.push_back(rdp_plates[st]-rdp_plates[end]);\\n            else\\n                res.push_back(0);\\n        }\\n         \\n        return res;\\n    }\\n};\\n\"\"\"",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& q) {\\n        \\n        int n=s.size();\\n        \\n        vector<int>rdp_plates(n,0);\\n        int ct=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'*\\') \\n                ct++;\\n            rdp_plates[i]=ct;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1549692,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) we avoid TLE by preprocessing the input similar to [[42. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/discuss/1374857/The-ART-of-Dynamic-Programming)] to find the closest candle `\\'|\\'` to-the-left `L` and to-the-right `R` of each i<sup>th</sup> index of the input string `s` in O(1) time.  And use [prefix sums](https://en.wikipedia.org/wiki/Prefix_sum) to count the plates `\\'*\\'` from `i..j` inclusive in O(1) time via the formula: `P[j] - P[i]`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun platesBetweenCandles(s: String, A: Array<IntArray>): IntArray {\\n        var N = s.length\\n        var (L, R, P) = listOf(IntArray(N) { it }, IntArray(N) { it }, IntArray(N))\\n        for (i in 1 until N)\\n            L[i] = if (s[i] == \\'|\\') i else L[i - 1]\\n        for (i in N - 2 downTo 0)\\n            R[i] = if (s[i] == \\'|\\') i else R[i + 1]\\n        P[0] = if (s[0] == \\'*\\') 1 else 0\\n        for (i in 1 until N)\\n            P[i] = P[i - 1] + if (s[i] == \\'*\\') 1 else 0\\n        fun f(i: Int, j: Int): Int {\\n            var (u, v) = listOf(R[i], L[j])\\n            return Math.max(0, P[v] - P[u])\\n        }\\n        return A.map{ (i, j) -> f(i, j) }.toIntArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet platesBetweenCandles = (s, A) => {\\n    let N = s.length;\\n    let [L, R, P] = [[...Array(N).keys()], [...Array(N).keys()], Array(N)];\\n    for (let i = 1; i < N; ++i)\\n        L[i] = s[i] == \\'|\\' ? i : L[i - 1];\\n    for (let i = N - 2; 0 <= i; --i)\\n        R[i] = s[i] == \\'|\\' ? i : R[i + 1];\\n    P[0] = Number(s[0] == \\'*\\');\\n    for (let i = 1; i < N; ++i)\\n        P[i] = P[i - 1] + Number(s[i] == \\'*\\');\\n    let f = (i, j) => {\\n        let [u, v] = [R[i], L[j]];\\n        return Math.max(0, P[v] - P[u])\\n    };\\n    return A.map(([i, j]) => f(i, j));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, A: List[List[int]]) -> List[int]:\\n        N = len(s)\\n        L, R, P = [i for i in range(N)], [i for i in range(N)], [0] * N\\n        for i in range(1, N):\\n            L[i] = i if s[i] == \\'|\\' else L[i - 1]\\n        for i in range(N - 2, -1, -1):\\n            R[i] = i if s[i] == \\'|\\' else R[i + 1]\\n        P[0] = int(s[0] == \\'*\\')\\n        for i in range(1, N):\\n            P[i] = P[i - 1] + int(s[i] == \\'*\\')\\n        def f(i, j):\\n            u, v = R[i], L[j]\\n            return max(0, P[v] - P[u])\\n        return [f(i, j) for i, j in A]\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    VI platesBetweenCandles(string s, VVI& A, VI ans = {}) {\\n        int N = s.size();\\n        VI L(N); iota(L.begin(), L.end(), 0);\\n        VI R(N); iota(R.begin(), R.end(), 0);\\n        VI P(N);\\n        for (auto i{ 1 }; i < N; ++i)\\n            L[i] = s[i] == \\'|\\' ? i : L[i - 1];\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            R[i] = s[i] == \\'|\\' ? i : R[i + 1];\\n        P[0] = int(s[0] == \\'*\\');\\n        for (auto i{ 1 }; i < N; ++i)\\n            P[i] = P[i - 1] + int(s[i] == \\'*\\');\\n        transform(A.begin(), A.end(), back_inserter(ans), [&](auto& query) {\\n            auto [i, j] = tie(query[0], query[1]);\\n            auto [u, v] = tie(R[i], L[j]);\\n            return max(0, P[v] - P[u]);\\n        });\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun platesBetweenCandles(s: String, A: Array<IntArray>): IntArray {\\n        var N = s.length\\n        var (L, R, P) = listOf(IntArray(N) { it }, IntArray(N) { it }, IntArray(N))\\n        for (i in 1 until N)\\n            L[i] = if (s[i] == \\'|\\') i else L[i - 1]\\n        for (i in N - 2 downTo 0)\\n            R[i] = if (s[i] == \\'|\\') i else R[i + 1]\\n        P[0] = if (s[0] == \\'*\\') 1 else 0\\n        for (i in 1 until N)\\n            P[i] = P[i - 1] + if (s[i] == \\'*\\') 1 else 0\\n        fun f(i: Int, j: Int): Int {\\n            var (u, v) = listOf(R[i], L[j])\\n            return Math.max(0, P[v] - P[u])\\n        }\\n        return A.map{ (i, j) -> f(i, j) }.toIntArray()\\n    }\\n}\\n```\n```\\nlet platesBetweenCandles = (s, A) => {\\n    let N = s.length;\\n    let [L, R, P] = [[...Array(N).keys()], [...Array(N).keys()], Array(N)];\\n    for (let i = 1; i < N; ++i)\\n        L[i] = s[i] == \\'|\\' ? i : L[i - 1];\\n    for (let i = N - 2; 0 <= i; --i)\\n        R[i] = s[i] == \\'|\\' ? i : R[i + 1];\\n    P[0] = Number(s[0] == \\'*\\');\\n    for (let i = 1; i < N; ++i)\\n        P[i] = P[i - 1] + Number(s[i] == \\'*\\');\\n    let f = (i, j) => {\\n        let [u, v] = [R[i], L[j]];\\n        return Math.max(0, P[v] - P[u])\\n    };\\n    return A.map(([i, j]) => f(i, j));\\n};\\n```\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, A: List[List[int]]) -> List[int]:\\n        N = len(s)\\n        L, R, P = [i for i in range(N)], [i for i in range(N)], [0] * N\\n        for i in range(1, N):\\n            L[i] = i if s[i] == \\'|\\' else L[i - 1]\\n        for i in range(N - 2, -1, -1):\\n            R[i] = i if s[i] == \\'|\\' else R[i + 1]\\n        P[0] = int(s[0] == \\'*\\')\\n        for i in range(1, N):\\n            P[i] = P[i - 1] + int(s[i] == \\'*\\')\\n        def f(i, j):\\n            u, v = R[i], L[j]\\n            return max(0, P[v] - P[u])\\n        return [f(i, j) for i, j in A]\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    VI platesBetweenCandles(string s, VVI& A, VI ans = {}) {\\n        int N = s.size();\\n        VI L(N); iota(L.begin(), L.end(), 0);\\n        VI R(N); iota(R.begin(), R.end(), 0);\\n        VI P(N);\\n        for (auto i{ 1 }; i < N; ++i)\\n            L[i] = s[i] == \\'|\\' ? i : L[i - 1];\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            R[i] = s[i] == \\'|\\' ? i : R[i + 1];\\n        P[0] = int(s[0] == \\'*\\');\\n        for (auto i{ 1 }; i < N; ++i)\\n            P[i] = P[i - 1] + int(s[i] == \\'*\\');\\n        transform(A.begin(), A.end(), back_inserter(ans), [&](auto& query) {\\n            auto [i, j] = tie(query[0], query[1]);\\n            auto [u, v] = tie(R[i], L[j]);\\n            return max(0, P[v] - P[u]);\\n        });\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549137,
                "title": "python3-precomputation-o-n-o-1-for-each-query",
                "content": "```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        n=len(s)\\n        pre=[0]*n\\n        left=[-1]*n\\n        right=[n+1]*n\\n        c=-1\\n        for i in range(n):\\n            left[i]=c\\n            if s[i]==\"|\":\\n                c=i\\n                left[i]=c\\n        c=n+1\\n        for i in range(n-1,-1,-1):\\n            right[i]=c\\n            if s[i]==\"|\":\\n                c=i\\n                right[i]=c\\n            \\n        c=0\\n        star=[0]*n\\n        for i in range(n):\\n            star[i]=star[i-1]\\n            if s[i]==\"*\":\\n                c+=1\\n                star[i]=c\\n        res=[]\\n        for start,end in queries:\\n            st1=right[start]\\n            end1=left[end]\\n            if st1==end1 or st1>end or end1<st1:\\n                res.append(0)\\n            else:\\n                res.append(star[end1]-star[st1])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        n=len(s)\\n        pre=[0]*n\\n        left=[-1]*n\\n        right=[n+1]*n\\n        c=-1\\n        for i in range(n):\\n            left[i]=c\\n            if s[i]==\"|\":\\n                c=i\\n                left[i]=c\\n        c=n+1\\n        for i in range(n-1,-1,-1):\\n            right[i]=c\\n            if s[i]==\"|\":\\n                c=i\\n                right[i]=c\\n            \\n        c=0\\n        star=[0]*n\\n        for i in range(n):\\n            star[i]=star[i-1]\\n            if s[i]==\"*\":\\n                c+=1\\n                star[i]=c\\n        res=[]\\n        for start,end in queries:\\n            st1=right[start]\\n            end1=left[end]\\n            if st1==end1 or st1>end or end1<st1:\\n                res.append(0)\\n            else:\\n                res.append(star[end1]-star[st1])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549105,
                "title": "preffix-and-suffix-sum-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.size(), val = 0, cnt = 0;\\n        int pre[n+1], suff[n+1], cntstar[n+1];\\n        vector<int>res;\\n        for(int i=0;i<s.size();i++)\\n        {\\n           if(s[i]==\\'|\\') val = i;\\n           pre[i] = val;\\n           if(s[i]==\\'*\\') cnt++;\\n           cntstar[i] = cnt;\\n        }\\n        \\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'|\\') val = i;\\n            suff[i] = val;\\n        }\\n        \\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int x = cntstar[pre[queries[i][1]]];\\n            int y = cntstar[suff[queries[i][0]]];\\n            if((x-y)<0) x = y;\\n            res.push_back(x-y);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.size(), val = 0, cnt = 0;\\n        int pre[n+1], suff[n+1], cntstar[n+1];\\n        vector<int>res;\\n        for(int i=0;i<s.size();i++)\\n        {\\n           if(s[i]==\\'|\\') val = i;\\n           pre[i] = val;\\n           if(s[i]==\\'*\\') cnt++;\\n           cntstar[i] = cnt;\\n        }\\n        \\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'|\\') val = i;\\n            suff[i] = val;\\n        }\\n        \\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int x = cntstar[pre[queries[i][1]]];\\n            int y = cntstar[suff[queries[i][0]]];\\n            if((x-y)<0) x = y;\\n            res.push_back(x-y);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548971,
                "title": "c-easy-to-understand-binary-search-count-between-two-plates",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        map<int,int> m;\\n        vector<int> cand;\\n        int count=0;\\n        bool flag=true;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'*\\')\\n                count++;\\n            if(s[i]==\\'|\\')\\n            {\\n                  cand.push_back(i); // store index of every candle\\n                if(flag)\\n                { // if first candle then don\\'t add previous plates to the count \\n                    flag=false;\\n                    count=0; \\n                }\\n                else {\\n\\t\\t\\t\\t  // count of plates from 1st cantle till the candle at ith position\\n                    m[i]=count;\\n                    }\\n            }\\n        }\\n        vector<int> result;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int a=queries[i][0];\\n            int b=queries[i][1];\\n\\t\\t\\t// binary search to find the position of candle between the particular interval\\n            int x=lower_bound(cand.begin(),cand.end(),a)-cand.begin();\\n            int y=lower_bound(cand.begin(),cand.end(),b)-cand.begin();\\n\\t\\t\\t\\n            if(cand[y]!=b)\\n                y--;\\n            x=cand[x];\\n            y=cand[y];\\n            if(y>=x)\\n            result.push_back(m[y]-m[x]);\\n            else result.push_back(0);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        map<int,int> m;\\n        vector<int> cand;\\n        int count=0;\\n        bool flag=true;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'*\\')\\n                count++;\\n            if(s[i]==\\'|\\')\\n            {\\n                  cand.push_back(i); // store index of every candle\\n                if(flag)\\n                { // if first candle then don\\'t add previous plates to the count \\n                    flag=false;\\n                    count=0; \\n                }\\n                else {\\n\\t\\t\\t\\t  // count of plates from 1st cantle till the candle at ith position\\n                    m[i]=count;\\n                    }\\n            }\\n        }\\n        vector<int> result;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int a=queries[i][0];\\n            int b=queries[i][1];\\n\\t\\t\\t// binary search to find the position of candle between the particular interval\\n            int x=lower_bound(cand.begin(),cand.end(),a)-cand.begin();\\n            int y=lower_bound(cand.begin(),cand.end(),b)-cand.begin();\\n\\t\\t\\t\\n            if(cand[y]!=b)\\n                y--;\\n            x=cand[x];\\n            y=cand[y];\\n            if(y>=x)\\n            result.push_back(m[y]-m[x]);\\n            else result.push_back(0);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770863,
                "title": "python-3-prefix-sum-binary-search-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. Binary Search\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        candies = [i for i, c in enumerate(s) if c == \"|\"]\\n        \\n        def bns(x: int) -> int:\\n            l, r = 0, len(candies) - 1\\n            while l <= r:\\n                m = (l + r) // 2\\n                if candies[m] < x: l = m + 1\\n                else: r = m - 1\\n            return l\\n\\n        ans = []\\n        for a, b in queries:\\n            l, r = bns(a), bns(b + 1) - 1\\n            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)\\n        return ans\\n```\\n- TC: $$O(NlogN)$$\\n- SC: $$O(N)$$\\n\\n2. Prefix Sum\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        psum, next, prev = [0] * (len(s) + 1), [float(\"inf\")] * (len(s) + 1), [0] * (len(s) + 1)\\n        res = []\\n        for i, ch in enumerate(s):\\n            psum[i + 1] = psum[i] + (ch == \\'|\\')\\n            prev[i + 1] = i if ch == \\'|\\' else prev[i]\\n        for i, ch in reversed(list(enumerate(s))):\\n            next[i] = i if ch == \\'|\\' else next[i + 1]\\n        for q in queries:\\n            l, r = next[q[0]], prev[q[1] + 1]\\n            res.append(r - l - (psum[r] - psum[l]) if l < r else 0)\\n        return res\\n```\\n- TC: $$O(N)$$\\n- SC: $$O(N)$$",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        candies = [i for i, c in enumerate(s) if c == \"|\"]\\n        \\n        def bns(x: int) -> int:\\n            l, r = 0, len(candies) - 1\\n            while l <= r:\\n                m = (l + r) // 2\\n                if candies[m] < x: l = m + 1\\n                else: r = m - 1\\n            return l\\n\\n        ans = []\\n        for a, b in queries:\\n            l, r = bns(a), bns(b + 1) - 1\\n            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)\\n        return ans\\n```\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        psum, next, prev = [0] * (len(s) + 1), [float(\"inf\")] * (len(s) + 1), [0] * (len(s) + 1)\\n        res = []\\n        for i, ch in enumerate(s):\\n            psum[i + 1] = psum[i] + (ch == \\'|\\')\\n            prev[i + 1] = i if ch == \\'|\\' else prev[i]\\n        for i, ch in reversed(list(enumerate(s))):\\n            next[i] = i if ch == \\'|\\' else next[i + 1]\\n        for q in queries:\\n            l, r = next[q[0]], prev[q[1] + 1]\\n            res.append(r - l - (psum[r] - psum[l]) if l < r else 0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987779,
                "title": "q2055-accepted-c-used-binarysearch-easy-simple",
                "content": "CRUX\\n1) We need to calculate the number of plates between two candles.\\n2) The two candles must be equal to or smaller then the queries indexes given.\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        vector <int> idx;\\n        for(int i=0;i<s.size();i++)\\n            if(s[i]==\\'|\\')\\n                idx.push_back(i);\\n        vector <int> ans;\\n        for(int i=0;i<queries.size();i++){\\n            int s=queries[i][0];\\n            int e=queries[i][1];\\n            int l=lower_bound(idx.begin(),idx.end(),s)-idx.begin(); // Will provide the left candle\\n            int r=upper_bound(idx.begin(),idx.end(),e)-idx.begin()-1; // Will provide the right candle\\n            if(l>=r)\\n                ans.push_back(0); //If l & r cross eachother then there will be no possible plates\\n            else\\n                ans.push_back(idx[r]-idx[l]-(r-l)); From Ex 16 -3 -(4 - 0)\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        vector <int> idx;\\n        for(int i=0;i<s.size();i++)\\n            if(s[i]==\\'|\\')\\n                idx.push_back(i);\\n        vector <int> ans;\\n        for(int i=0;i<queries.size();i++){\\n            int s=queries[i][0];\\n            int e=queries[i][1];\\n            int l=lower_bound(idx.begin(),idx.end(),s)-idx.begin(); // Will provide the left candle\\n            int r=upper_bound(idx.begin(),idx.end(),e)-idx.begin()-1; // Will provide the right candle\\n            if(l>=r)\\n                ans.push_back(0); //If l & r cross eachother then there will be no possible plates\\n            else\\n                ans.push_back(idx[r]-idx[l]-(r-l)); From Ex 16 -3 -(4 - 0)\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701089,
                "title": "c-prefix-solution",
                "content": "```\\npublic class Solution {\\n    public int[] PlatesBetweenCandles(string s, int[][] queries) {\\n        int n = s.Length;\\n        int[] candlesPref = new int[n];\\n        int[] leftClosestCandle = new int[n];\\n\\n        int candleIdx = -1, candleCount = 0;\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'|\\') {\\n                candleIdx = i;\\n                candleCount++;\\n            }\\n            leftClosestCandle[i] = candleIdx;\\n            candlesPref[i] = candleCount;\\n        }\\n\\n        candleIdx = -1;\\n        int[] rightClosestCandle = new int[n];\\n        for(int i = n-1; i >= 0; i--){\\n            if(s[i] == \\'|\\') candleIdx = i;\\n            rightClosestCandle[i] = candleIdx;\\n        }\\n\\n        int idx = 0;        \\n        int[] res = new int[queries.Length];\\n        foreach(int[] query in queries){\\n            int leftCandleIdx = rightClosestCandle[query[0]];\\n            int rightCandleIdx = leftClosestCandle[query[1]];\\n            if(leftCandleIdx != -1 && rightCandleIdx > leftCandleIdx){\\n                res[idx++] = (rightCandleIdx-leftCandleIdx+1) - (candlesPref[rightCandleIdx]-candlesPref[leftCandleIdx]+1);\\n            } else{\\n                res[idx++] = 0;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Prefix Sum"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] PlatesBetweenCandles(string s, int[][] queries) {\\n        int n = s.Length;\\n        int[] candlesPref = new int[n];\\n        int[] leftClosestCandle = new int[n];\\n\\n        int candleIdx = -1, candleCount = 0;\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'|\\') {\\n                candleIdx = i;\\n                candleCount++;\\n            }\\n            leftClosestCandle[i] = candleIdx;\\n            candlesPref[i] = candleCount;\\n        }\\n\\n        candleIdx = -1;\\n        int[] rightClosestCandle = new int[n];\\n        for(int i = n-1; i >= 0; i--){\\n            if(s[i] == \\'|\\') candleIdx = i;\\n            rightClosestCandle[i] = candleIdx;\\n        }\\n\\n        int idx = 0;        \\n        int[] res = new int[queries.Length];\\n        foreach(int[] query in queries){\\n            int leftCandleIdx = rightClosestCandle[query[0]];\\n            int rightCandleIdx = leftClosestCandle[query[1]];\\n            if(leftCandleIdx != -1 && rightCandleIdx > leftCandleIdx){\\n                res[idx++] = (rightCandleIdx-leftCandleIdx+1) - (candlesPref[rightCandleIdx]-candlesPref[leftCandleIdx]+1);\\n            } else{\\n                res[idx++] = 0;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611680,
                "title": "java-binary-search-vs-prefix-sum-two-approach",
                "content": "To understand the code better, dry run\\nthe below codes for the example test cases\\ngiven in the description.\\n\\nApproach 1:\\nBinary Search\\n```\\nclass Solution {\\n    private int lowerBound ;\\n    private int upperBound ;\\n    \\n    private void binarySearch(ArrayList<Integer> arr, int target) {\\n        int low = 0 ;\\n        int high = arr.size()-1 ;\\n        \\n        while (low <= high) {\\n            int mid = low + (high-low)/2 ;\\n            \\n            if (arr.get(mid) == target) {\\n                upperBound = lowerBound = mid ;\\n                return ;\\n            }\\n            else if (arr.get(mid) < target)\\n                low = mid+1 ;\\n            else high = mid-1 ;\\n        }\\n        lowerBound = low ;\\n        upperBound = high ;\\n    }\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int n = s.length() ;\\n        int m = queries.length ;\\n        ArrayList<Integer> barIndex = new ArrayList<>() ;\\n        int[] result = new int [m] ;\\n        \\n        for (int i = 0; i < n; i++)\\n            if (s.charAt(i) == \\'|\\')\\n                barIndex.add(i) ;\\n        \\n        for (int i = 0; i < m; i++) {\\n            binarySearch(barIndex, queries[i][0]) ;\\n            int j = lowerBound ;\\n            \\n            binarySearch(barIndex, queries[i][1]) ;\\n            int k = upperBound ;\\n            \\n            if (j >= k) result[i] = 0 ;\\n            else result[i] = barIndex.get(k)-barIndex.get(j) - (k-j) ;\\n        }\\n        return result ;\\n    }\\n}\\n```\\n\\n\\nAppraoch 2:\\nPrefix Sum\\n```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int n = s.length() ;\\n        int m = queries.length ;\\n        int[] left = new int [n] ;\\n        int[] right = new int [n] ;\\n        int[] prefixSum = new int [n] ;\\n        int[] result = new int [m] ;\\n        \\n        if (s.charAt(0) == \\'*\\') {\\n            right[0] = -1 ;\\n            prefixSum[0] = 1 ;\\n        }\\n        if (s.charAt(n-1) == \\'*\\') left[n-1] = n ;\\n        else left[n-1] = n-1 ;\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (s.charAt(i) == \\'*\\') {\\n                right[i] = right[i-1] ;\\n                prefixSum[i] = prefixSum[i-1]+1 ;\\n            }\\n            else {\\n                right[i] = i ;\\n                prefixSum[i] = prefixSum[i-1] ;\\n            }\\n            \\n            if (s.charAt(n-i-1) == \\'*\\') left[n-i-1] = left[n-i] ;\\n            else left[n-i-1] = (n-i-1) ;\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            int j = left[queries[i][0]] ;\\n            int k = right[queries[i][1]] ;\\n            \\n            if (j > k) result[i] = 0 ;\\n            else result[i] = prefixSum[k]-prefixSum[j] ;\\n        }\\n        return result ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    private int lowerBound ;\\n    private int upperBound ;\\n    \\n    private void binarySearch(ArrayList<Integer> arr, int target) {\\n        int low = 0 ;\\n        int high = arr.size()-1 ;\\n        \\n        while (low <= high) {\\n            int mid = low + (high-low)/2 ;\\n            \\n            if (arr.get(mid) == target) {\\n                upperBound = lowerBound = mid ;\\n                return ;\\n            }\\n            else if (arr.get(mid) < target)\\n                low = mid+1 ;\\n            else high = mid-1 ;\\n        }\\n        lowerBound = low ;\\n        upperBound = high ;\\n    }\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int n = s.length() ;\\n        int m = queries.length ;\\n        ArrayList<Integer> barIndex = new ArrayList<>() ;\\n        int[] result = new int [m] ;\\n        \\n        for (int i = 0; i < n; i++)\\n            if (s.charAt(i) == \\'|\\')\\n                barIndex.add(i) ;\\n        \\n        for (int i = 0; i < m; i++) {\\n            binarySearch(barIndex, queries[i][0]) ;\\n            int j = lowerBound ;\\n            \\n            binarySearch(barIndex, queries[i][1]) ;\\n            int k = upperBound ;\\n            \\n            if (j >= k) result[i] = 0 ;\\n            else result[i] = barIndex.get(k)-barIndex.get(j) - (k-j) ;\\n        }\\n        return result ;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int n = s.length() ;\\n        int m = queries.length ;\\n        int[] left = new int [n] ;\\n        int[] right = new int [n] ;\\n        int[] prefixSum = new int [n] ;\\n        int[] result = new int [m] ;\\n        \\n        if (s.charAt(0) == \\'*\\') {\\n            right[0] = -1 ;\\n            prefixSum[0] = 1 ;\\n        }\\n        if (s.charAt(n-1) == \\'*\\') left[n-1] = n ;\\n        else left[n-1] = n-1 ;\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (s.charAt(i) == \\'*\\') {\\n                right[i] = right[i-1] ;\\n                prefixSum[i] = prefixSum[i-1]+1 ;\\n            }\\n            else {\\n                right[i] = i ;\\n                prefixSum[i] = prefixSum[i-1] ;\\n            }\\n            \\n            if (s.charAt(n-i-1) == \\'*\\') left[n-i-1] = left[n-i] ;\\n            else left[n-i-1] = (n-i-1) ;\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            int j = left[queries[i][0]] ;\\n            int k = right[queries[i][1]] ;\\n            \\n            if (j > k) result[i] = 0 ;\\n            else result[i] = prefixSum[k]-prefixSum[j] ;\\n        }\\n        return result ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444665,
                "title": "java-solution-binary-search-prefix-sum",
                "content": "```java \\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int[] a=new int[queries.length];\\n        ArrayList<Integer> list = new ArrayList<>();    //List to Store Candle indices\\n        int[] pSum = new int[s.length()];    //Prefix sum Array\\n        \\n        int plates=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'*\\')\\n                plates++;\\n            pSum[i]=plates;     //Prefix Sum\\n            if(s.charAt(i)==\\'|\\')\\n                list.add(i);\\n        }\\n        \\n        int i=0;\\n        for(int[] x: queries)\\n        {\\n            int start = search1(x[0],list);\\n            if(start==-1){\\n                a[i++]=0;\\n                continue;\\n            }\\n            int end = search2(x[1],list);\\n            if(start>end || end==-1)\\n                a[i++]=0;\\n            else\\n                a[i++]=pSum[end]-pSum[start];\\n        }\\n        return a;\\n    }\\n    \\n    private int search1(int idx,ArrayList<Integer> list)\\n    {\\n        int start = 0;\\n        int end = list.size()-1;\\n        while(start<=end)\\n        {\\n            int mid = (start+end)/2;\\n            if(list.get(mid)<idx){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        if(start==list.size())\\n            return -1;\\n        return list.get(start);\\n    }\\n    \\n    private int search2(int idx,ArrayList<Integer> list)\\n    {\\n        int start = 0;\\n        int end = list.size()-1;\\n        while(start<=end)\\n        {\\n            int mid = (start+end)/2;\\n            if(list.get(mid)>idx){\\n                end=mid-1;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        if(end==-1)\\n            return -1;\\n        return list.get(end);\\n    }\\n}",
                "solutionTags": [
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int[] a=new int[queries.length];\\n        ArrayList<Integer> list = new ArrayList<>();    //List to Store Candle indices\\n        int[] pSum = new int[s.length()];    //Prefix sum Array\\n        \\n        int plates=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'*\\')\\n                plates++;\\n            pSum[i]=plates;     //Prefix Sum\\n            if(s.charAt(i)==\\'|\\')\\n                list.add(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2251901,
                "title": "c-solution",
                "content": "```\\npublic static int[] PlatesBetweenCandles(string s, int[][] queries)\\n{\\n\\t\\tint n = s.Length;\\n\\n\\t\\tint[] nearestLeftCandle = new int[n];\\n\\t\\tint[] nearestRightCandle = new int[n];\\n\\t\\tint[] candleCount = new int[n];\\n\\t\\tint[] result = new int[queries.Length];\\n\\n\\t\\tint candle = -1;\\n\\t\\tfor (int i = 0; i < n; ++i)\\n\\t\\t{\\n\\t\\t\\tif (s[i] == \\'|\\')\\n\\t\\t\\t\\tcandle = i;\\n\\t\\t\\tnearestLeftCandle[i] = candle;\\n\\t\\t}\\n\\n\\t\\tcandle = -1;\\n\\t\\tfor (int i = n - 1; i >= 0; --i)\\n\\t\\t{\\n\\t\\t\\tif (s[i] == \\'|\\')\\n\\t\\t\\t\\tcandle = i;\\n\\t\\t\\tnearestRightCandle[i] = candle;\\n\\t\\t}\\n\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < n; ++i)\\n\\t\\t{\\n\\t\\t\\tif (s[i] == \\'|\\')\\n\\t\\t\\t\\t++count;\\n\\t\\t\\tcandleCount[i] = count;\\n\\t\\t}\\n\\n\\t\\tint index = 0;\\n\\t\\tforeach(var query in queries)\\n\\t\\t{ \\n\\t\\t\\tint left = query[0];\\n\\t\\t\\tint right = query[1];\\n\\n\\t\\t\\tint leftCandle = nearestRightCandle[left];\\n\\t\\t\\tint rightCandle = nearestLeftCandle[right];\\n\\n\\t\\t\\tint d = 0;\\n\\t\\t\\tif (leftCandle == -1 || rightCandle == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult[index] = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\td = rightCandle - leftCandle;\\n\\t\\t\\t\\tif (d > 1)\\n\\t\\t\\t\\t\\tresult[index] = rightCandle - leftCandle + 1 - (candleCount[rightCandle] - candleCount[leftCandle] + 1);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tresult[index] = 0;\\n\\t\\t\\t}\\n\\t\\t\\t++index;\\n\\t\\t}\\n\\t\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic static int[] PlatesBetweenCandles(string s, int[][] queries)\\n{\\n\\t\\tint n = s.Length;\\n\\n\\t\\tint[] nearestLeftCandle = new int[n];\\n\\t\\tint[] nearestRightCandle = new int[n];\\n\\t\\tint[] candleCount = new int[n];\\n\\t\\tint[] result = new int[queries.Length];\\n\\n\\t\\tint candle = -1;\\n\\t\\tfor (int i = 0; i < n; ++i)\\n\\t\\t{\\n\\t\\t\\tif (s[i] == \\'|\\')\\n\\t\\t\\t\\tcandle = i;\\n\\t\\t\\tnearestLeftCandle[i] = candle;\\n\\t\\t}\\n\\n\\t\\tcandle = -1;\\n\\t\\tfor (int i = n - 1; i >= 0; --i)\\n\\t\\t{\\n\\t\\t\\tif (s[i] == \\'|\\')\\n\\t\\t\\t\\tcandle = i;\\n\\t\\t\\tnearestRightCandle[i] = candle;\\n\\t\\t}\\n\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < n; ++i)\\n\\t\\t{\\n\\t\\t\\tif (s[i] == \\'|\\')\\n\\t\\t\\t\\t++count;\\n\\t\\t\\tcandleCount[i] = count;\\n\\t\\t}\\n\\n\\t\\tint index = 0;\\n\\t\\tforeach(var query in queries)\\n\\t\\t{ \\n\\t\\t\\tint left = query[0];\\n\\t\\t\\tint right = query[1];\\n\\n\\t\\t\\tint leftCandle = nearestRightCandle[left];\\n\\t\\t\\tint rightCandle = nearestLeftCandle[right];\\n\\n\\t\\t\\tint d = 0;\\n\\t\\t\\tif (leftCandle == -1 || rightCandle == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult[index] = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\td = rightCandle - leftCandle;\\n\\t\\t\\t\\tif (d > 1)\\n\\t\\t\\t\\t\\tresult[index] = rightCandle - leftCandle + 1 - (candleCount[rightCandle] - candleCount[leftCandle] + 1);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tresult[index] = 0;\\n\\t\\t\\t}\\n\\t\\t\\t++index;\\n\\t\\t}\\n\\t\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1704328,
                "title": "python-3-simple-and-fast-use-difference-btw-cumulative-sums",
                "content": "\\n```\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        \\n        nP = s.count(\\'*\\')\\n        \\n        cntPrev = cntCurr = 0\\n        listSumLeft = [0] * ( lS:=len(s) )\\n        for i,c in enumerate(s):\\n            if c==\\'*\\':                      cntCurr += 1\\n            elif cntPrev<cntCurr:           cntPrev = cntCurr\\n            listSumLeft[i] = cntPrev\\n        \\n        cntPrev = cntCurr = 0\\n        listSumRight = [0] * lS\\n        for j,c in enumerate(s[::-1]):\\n            i = lS-1 - j\\n            if c==\\'*\\':                      cntCurr += 1\\n            elif cntPrev<cntCurr:           cntPrev = cntCurr\\n            listSumRight[i] = nP - cntPrev\\n        \\n        return [ max(0, listSumLeft[r]-listSumRight[l]) for l,r in queries ]\\n```",
                "solutionTags": [],
                "code": "```\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        \\n        nP = s.count(\\'*\\')\\n        \\n        cntPrev = cntCurr = 0\\n        listSumLeft = [0] * ( lS:=len(s) )\\n        for i,c in enumerate(s):\\n            if c==\\'*\\':                      cntCurr += 1\\n            elif cntPrev<cntCurr:           cntPrev = cntCurr\\n            listSumLeft[i] = cntPrev\\n        \\n        cntPrev = cntCurr = 0\\n        listSumRight = [0] * lS\\n        for j,c in enumerate(s[::-1]):\\n            i = lS-1 - j\\n            if c==\\'*\\':                      cntCurr += 1\\n            elif cntPrev<cntCurr:           cntPrev = cntCurr\\n            listSumRight[i] = nP - cntPrev\\n        \\n        return [ max(0, listSumLeft[r]-listSumRight[l]) for l,r in queries ]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1605632,
                "title": "c-binary-search-n-nlogn-time-solution",
                "content": "**Binary Search Approach :**\\n\\n* Store index of all candles in a vector.\\n* For each query find index of first and last candle in the given range using binary search.\\n* Number of plates between candles will be number of elements between first and last candle minus number of candles between them.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        vector<int> candles;\\n        int n = s.length();\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'|\\') candles.push_back(i);\\n        }\\n        vector<int> res;\\n        for(auto &q : queries){\\n            int first = lower_bound(candles.begin(), candles.end(), q[0]) - candles.begin();\\n            int last = lower_bound(candles.begin(), candles.end(), q[1]) - candles.begin();\\n            \\n            if(first >= last) res.push_back(0);\\n            else {\\n                if(last == n || candles[last] != q[1]) last--;\\n                res.push_back(candles[last] - candles[first] - (last-first));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        vector<int> candles;\\n        int n = s.length();\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'|\\') candles.push_back(i);\\n        }\\n        vector<int> res;\\n        for(auto &q : queries){\\n            int first = lower_bound(candles.begin(), candles.end(), q[0]) - candles.begin();\\n            int last = lower_bound(candles.begin(), candles.end(), q[1]) - candles.begin();\\n            \\n            if(first >= last) res.push_back(0);\\n            else {\\n                if(last == n || candles[last] != q[1]) last--;\\n                res.push_back(candles[last] - candles[first] - (last-first));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549201,
                "title": "c-solution-using-prefix-sum-array",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int prefix[100001];\\n        int cnt=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'*\\') cnt++;\\n            prefix[i]=cnt;\\n        }\\n        \\n        int left[100001];\\n        int right[100001];\\n        int val=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'|\\')\\n            {\\n                val=i;\\n                left[i]=i;\\n            }\\n            else\\n                left[i]=val;\\n        }\\n        val=0;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'|\\')\\n            {\\n                val=i;\\n                right[i]=i;\\n            }\\n            else\\n                right[i]=val;\\n        }\\n      \\n        vector<int>res;\\n        for(auto q:queries)\\n        {\\n            int v1=prefix[right[q[0]]];\\n            int v2=prefix[left[q[1]]];\\n            if((v2-v1)<0)\\n                v2=v1;\\n            res.push_back(v2-v1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int prefix[100001];\\n        int cnt=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'*\\') cnt++;\\n            prefix[i]=cnt;\\n        }\\n        \\n        int left[100001];\\n        int right[100001];\\n        int val=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'|\\')\\n            {\\n                val=i;\\n                left[i]=i;\\n            }\\n            else\\n                left[i]=val;\\n        }\\n        val=0;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'|\\')\\n            {\\n                val=i;\\n                right[i]=i;\\n            }\\n            else\\n                right[i]=val;\\n        }\\n      \\n        vector<int>res;\\n        for(auto q:queries)\\n        {\\n            int v1=prefix[right[q[0]]];\\n            int v2=prefix[left[q[1]]];\\n            if((v2-v1)<0)\\n                v2=v1;\\n            res.push_back(v2-v1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549068,
                "title": "java-hashmap-o-s-p-brute-force",
                "content": "\\nfor each index `i` of string `s`, keep nearest left index of `|` and nearest right index of `|`, and how many `|` so far from begining... `{left, right, count}`\\n\\n```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        Map<Integer, int[]> map = new HashMap<>();\\n        \\n        int left = s.length(), count = 0;\\n        for(int i = 0; i < s.length(); ++i) {\\n            if(s.charAt(i) == \\'|\\') {\\n                left = i;\\n                count++;\\n            }    \\n            int curr[] = new int[]{left, 0, count};\\n            map.put(i, curr);\\n        }\\n        \\n        int right = -1;\\n        for(int j = s.length() - 1; j >= 0; --j) {\\n            if(s.charAt(j) == \\'|\\')\\n                right = j;\\n            \\n            map.get(j)[1] = right;\\n        }\\n        \\n        int[] result = new int[queries.length];\\n        for(int k = 0; k < queries.length; ++k) {\\n            \\n\\t\\t\\tint x = queries[k][0], y = queries[k][1];\\n\\t\\t\\tint start = map.get(x)[1], end = map.get(y)[0];\\n\\t\\t\\tint total = map.get(y)[2] - map.get(x)[2];\\n            \\n            if(s.charAt(x) == \\'|\\') start++;\\n            \\n            int curr = (end - start - total + 1 > 0) ? end - start - total + 1 : 0;\\n            result[k] = curr;\\n        } \\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        Map<Integer, int[]> map = new HashMap<>();\\n        \\n        int left = s.length(), count = 0;\\n        for(int i = 0; i < s.length(); ++i) {\\n            if(s.charAt(i) == \\'|\\') {\\n                left = i;\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1549048,
                "title": "java-treeset-solution",
                "content": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int len = s.length();\\n        \\n        TreeSet<Integer> set = new TreeSet<>();\\n        \\n        for(int i = 0; i < len; i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'|\\') set.add(i);\\n        }\\n        \\n        \\n        int[] count = new int[len];\\n        count[0] = s.charAt(0) == \\'|\\' ? 0 : 1;\\n        \\n        for(int i = 1; i < len; i++){\\n            count[i] = count[i-1] + (s.charAt(i) == \\'|\\' ? 0 : 1);\\n        }\\n        \\n        \\n        int[] res = new int[queries.length];\\n        for(int i = 0; i < queries.length; i++){\\n            res[i] = getValue(queries[i][0], queries[i][1], set, count); \\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int getValue(int start, int end, TreeSet<Integer> set, int[] count){\\n        Integer fir = set.ceiling(start);\\n        Integer sec = set.floor(end);\\n        \\n        if(fir == null || sec == null || fir >= sec) return 0;\\n        \\n        int diff1 = count[end] - count[sec];\\n        int diff2 = count[fir] - (start-1 < 0 ? 0 : count[start-1]);\\n        \\n        return (count[end] - (start-1 < 0 ? 0 : count[start-1])) - diff1 - diff2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int len = s.length();\\n        \\n        TreeSet<Integer> set = new TreeSet<>();\\n        \\n        for(int i = 0; i < len; i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'|\\') set.add(i);\\n        }\\n        \\n        \\n        int[] count = new int[len];\\n        count[0] = s.charAt(0) == \\'|\\' ? 0 : 1;\\n        \\n        for(int i = 1; i < len; i++){\\n            count[i] = count[i-1] + (s.charAt(i) == \\'|\\' ? 0 : 1);\\n        }\\n        \\n        \\n        int[] res = new int[queries.length];\\n        for(int i = 0; i < queries.length; i++){\\n            res[i] = getValue(queries[i][0], queries[i][1], set, count); \\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int getValue(int start, int end, TreeSet<Integer> set, int[] count){\\n        Integer fir = set.ceiling(start);\\n        Integer sec = set.floor(end);\\n        \\n        if(fir == null || sec == null || fir >= sec) return 0;\\n        \\n        int diff1 = count[end] - count[sec];\\n        int diff2 = count[fir] - (start-1 < 0 ? 0 : count[start-1]);\\n        \\n        return (count[end] - (start-1 < 0 ? 0 : count[start-1])) - diff1 - diff2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065855,
                "title": "golang-binary-search",
                "content": "```\\npackage main\\n\\nimport (\\n\\t\"sort\"\\n)\\n\\nfunc platesBetweenCandles(s string, queries [][]int) []int {\\n\\tcandles := make([]int, 0, len(s))\\n\\n\\tfor i, ch := range s {\\n\\t\\tif ch == \\'|\\' {\\n\\t\\t\\tcandles = append(candles, i)\\n\\t\\t}\\n\\t}\\n\\n\\tans := make([]int, 0, len(queries))\\n\\n\\tfor _, query := range queries {\\n\\t\\tl := query[0]\\n\\t\\tr := query[1]\\n\\n\\t\\tleft := sort.Search(len(candles), func(i int) bool {\\n\\t\\t\\treturn candles[i] >= l\\n\\t\\t})\\n\\n\\t\\tright := sort.Search(len(candles), func(i int) bool {\\n\\t\\t\\treturn candles[i] > r\\n\\t\\t}) - 1\\n\\n\\t\\tif right <= left {\\n\\t\\t\\tans = append(ans, 0)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tc := (candles[right] - candles[left]) - (right - left)\\n\\t\\tans = append(ans, c)\\n\\t}\\n\\n\\treturn ans\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\nimport (\\n\\t\"sort\"\\n)\\n\\nfunc platesBetweenCandles(s string, queries [][]int) []int {\\n\\tcandles := make([]int, 0, len(s))\\n\\n\\tfor i, ch := range s {\\n\\t\\tif ch == \\'|\\' {\\n\\t\\t\\tcandles = append(candles, i)\\n\\t\\t}\\n\\t}\\n\\n\\tans := make([]int, 0, len(queries))\\n\\n\\tfor _, query := range queries {\\n\\t\\tl := query[0]\\n\\t\\tr := query[1]\\n\\n\\t\\tleft := sort.Search(len(candles), func(i int) bool {\\n\\t\\t\\treturn candles[i] >= l\\n\\t\\t})\\n\\n\\t\\tright := sort.Search(len(candles), func(i int) bool {\\n\\t\\t\\treturn candles[i] > r\\n\\t\\t}) - 1\\n\\n\\t\\tif right <= left {\\n\\t\\t\\tans = append(ans, 0)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tc := (candles[right] - candles[left]) - (right - left)\\n\\t\\tans = append(ans, c)\\n\\t}\\n\\n\\treturn ans\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2822877,
                "title": "python-simple-explanation",
                "content": "\\n# Code\\n```\\n# Slightly modified Binary search\\n# Say you have an array [3, 5, 7, 9, 15] and you have an element\\n# 6 and you want to find closest elements on the left and right\\n# of 6 in the array. You can run binary search and ultimately\\n# r will point to 5 and l will point to 7, i.e r, l gives the boundary\\n# However, if the query is 5, both r, l will point to 5 (note)\\n# Also, if q is 16, r will point to 15 but l will point to an element\\n# at index = len(array) + 1 ( which doesn\\'t exist) -- so need to handle\\n# these cases.\\n\\n# Using this logic in this problem we\\'ll use Binary Search to find \\n# the closest candle on the right of the first element in the \\n# query and the closest candle on the left of the second element in the query.\\n# The we\\'ll use the prefix sum already computed to compute the \\n# sum of the plates between these candles\\n\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        look_up, pre_sum, res = [], [], []\\n        for i, e in enumerate(s):\\n            if s[i] == \\'|\\':\\n                look_up.append(i)\\n                pre_sum.append(pre_sum[-1] if pre_sum else 0)\\n            else:\\n                pre_sum.append(pre_sum[-1] + 1 if pre_sum else 1)\\n        \\n        for st, end in queries:\\n            _, r = self.range_bs(look_up, st)\\n            l, _ = self.range_bs(look_up, end)\\n            if st < end and 0<= r < len(look_up) and 0 <= l < len(look_up):\\n                res.append(\\n                    max(pre_sum[look_up[l]] - pre_sum[look_up[r]], 0)\\n                )\\n            else:\\n                res.append(0)\\n         \\n        return res\\n                \\n        \\n    def range_bs(self, look_up, q):\\n        l, r = 0, len(look_up) - 1\\n        while l <= r:\\n            mid = (l+r)//2\\n            if look_up[mid] == q:\\n                return mid, mid\\n            elif look_up[mid] < q:\\n                l = mid+1\\n            else:\\n                r = mid-1\\n        return r, l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Slightly modified Binary search\\n# Say you have an array [3, 5, 7, 9, 15] and you have an element\\n# 6 and you want to find closest elements on the left and right\\n# of 6 in the array. You can run binary search and ultimately\\n# r will point to 5 and l will point to 7, i.e r, l gives the boundary\\n# However, if the query is 5, both r, l will point to 5 (note)\\n# Also, if q is 16, r will point to 15 but l will point to an element\\n# at index = len(array) + 1 ( which doesn\\'t exist) -- so need to handle\\n# these cases.\\n\\n# Using this logic in this problem we\\'ll use Binary Search to find \\n# the closest candle on the right of the first element in the \\n# query and the closest candle on the left of the second element in the query.\\n# The we\\'ll use the prefix sum already computed to compute the \\n# sum of the plates between these candles\\n\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        look_up, pre_sum, res = [], [], []\\n        for i, e in enumerate(s):\\n            if s[i] == \\'|\\':\\n                look_up.append(i)\\n                pre_sum.append(pre_sum[-1] if pre_sum else 0)\\n            else:\\n                pre_sum.append(pre_sum[-1] + 1 if pre_sum else 1)\\n        \\n        for st, end in queries:\\n            _, r = self.range_bs(look_up, st)\\n            l, _ = self.range_bs(look_up, end)\\n            if st < end and 0<= r < len(look_up) and 0 <= l < len(look_up):\\n                res.append(\\n                    max(pre_sum[look_up[l]] - pre_sum[look_up[r]], 0)\\n                )\\n            else:\\n                res.append(0)\\n         \\n        return res\\n                \\n        \\n    def range_bs(self, look_up, q):\\n        l, r = 0, len(look_up) - 1\\n        while l <= r:\\n            mid = (l+r)//2\\n            if look_up[mid] == q:\\n                return mid, mid\\n            elif look_up[mid] < q:\\n                l = mid+1\\n            else:\\n                r = mid-1\\n        return r, l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750388,
                "title": "easy-java-solution-binary-search-prefix-sum",
                "content": "```\\nprivate int binarySeachCeiling(int[] nums, int num) {\\n\\t\\tint start = 0;\\n\\t\\tint end = nums.length - 1;\\n\\t\\tint ans = -1;\\n\\t\\twhile (start <= end) {\\n\\t\\t\\tint mid = (start + end) / 2;\\n\\t\\t\\tif (nums[mid] == num) {\\n\\t\\t\\t\\treturn ans = nums[mid];\\n\\t\\t\\t} else if (nums[mid] > num) {\\n\\t\\t\\t\\tans = nums[mid];\\n\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate int binarySeachFloor(int[] nums, int num) {\\n\\t\\tint start = 0;\\n\\t\\tint end = nums.length - 1;\\n\\t\\tint ans = -1;\\n\\t\\twhile (start <= end) {\\n\\t\\t\\tint mid = (start + end) / 2;\\n\\t\\t\\tif (nums[mid] == num) {\\n\\t\\t\\t\\treturn ans = nums[mid];\\n\\t\\t\\t} else if (nums[mid] < num) {\\n\\t\\t\\t\\tans = nums[mid];\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tpublic int[] platesBetweenCandles(String s, int[][] queries) {\\n\\t\\tint[] prefix = new int[s.length()];\\n\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\tif (s.charAt(0) == \\'*\\') {\\n\\t\\t\\tprefix[0] = 1;\\n\\t\\t} else {\\n\\t\\t\\tprefix[0] = 0;\\n\\t\\t\\tlist.add(0);\\n\\t\\t}\\n\\t\\tfor (int i = 1; i < s.length(); i++) {\\n\\t\\t\\tif (s.charAt(i) == \\'*\\') {\\n\\t\\t\\t\\tprefix[i] = prefix[i - 1] + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tprefix[i] = prefix[i - 1];\\n\\t\\t\\t\\tlist.add(i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint[] ans = new int[queries.length];\\n\\t\\tint i = 0;\\n\\t\\tint[] nums = list.stream().mapToInt(num -> num).toArray();\\n\\t\\tfor (int[] query : queries) {\\n\\t\\t\\t\\n\\t\\t\\tint firstCandle = binarySeachCeiling(nums, query[0]);\\n\\t\\t\\tint secondCandle = binarySeachFloor(nums, query[1]);\\n\\t\\t\\tif (firstCandle!= -1 && secondCandle != -1 && firstCandle < secondCandle) {\\n\\t\\t\\t\\tans[i] = prefix[secondCandle] - prefix[firstCandle];\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nprivate int binarySeachCeiling(int[] nums, int num) {\\n\\t\\tint start = 0;\\n\\t\\tint end = nums.length - 1;\\n\\t\\tint ans = -1;\\n\\t\\twhile (start <= end) {\\n\\t\\t\\tint mid = (start + end) / 2;\\n\\t\\t\\tif (nums[mid] == num) {\\n\\t\\t\\t\\treturn ans = nums[mid];\\n\\t\\t\\t} else if (nums[mid] > num) {\\n\\t\\t\\t\\tans = nums[mid];\\n\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate int binarySeachFloor(int[] nums, int num) {\\n\\t\\tint start = 0;\\n\\t\\tint end = nums.length - 1;\\n\\t\\tint ans = -1;\\n\\t\\twhile (start <= end) {\\n\\t\\t\\tint mid = (start + end) / 2;\\n\\t\\t\\tif (nums[mid] == num) {\\n\\t\\t\\t\\treturn ans = nums[mid];\\n\\t\\t\\t} else if (nums[mid] < num) {\\n\\t\\t\\t\\tans = nums[mid];\\n\\t\\t\\t\\tstart = mid + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tend = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tpublic int[] platesBetweenCandles(String s, int[][] queries) {\\n\\t\\tint[] prefix = new int[s.length()];\\n\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\tif (s.charAt(0) == \\'*\\') {\\n\\t\\t\\tprefix[0] = 1;\\n\\t\\t} else {\\n\\t\\t\\tprefix[0] = 0;\\n\\t\\t\\tlist.add(0);\\n\\t\\t}\\n\\t\\tfor (int i = 1; i < s.length(); i++) {\\n\\t\\t\\tif (s.charAt(i) == \\'*\\') {\\n\\t\\t\\t\\tprefix[i] = prefix[i - 1] + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tprefix[i] = prefix[i - 1];\\n\\t\\t\\t\\tlist.add(i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint[] ans = new int[queries.length];\\n\\t\\tint i = 0;\\n\\t\\tint[] nums = list.stream().mapToInt(num -> num).toArray();\\n\\t\\tfor (int[] query : queries) {\\n\\t\\t\\t\\n\\t\\t\\tint firstCandle = binarySeachCeiling(nums, query[0]);\\n\\t\\t\\tint secondCandle = binarySeachFloor(nums, query[1]);\\n\\t\\t\\tif (firstCandle!= -1 && secondCandle != -1 && firstCandle < secondCandle) {\\n\\t\\t\\t\\tans[i] = prefix[secondCandle] - prefix[firstCandle];\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2581160,
                "title": "java-binary-search-prefix-sum-easy-understand",
                "content": "### Intuition\\n\\n* Since this is an range question prefixSum could be useful for this. \\n* But for every query we need to reduce the query size such that both the ends are candles. This will give us right result everytime. \\n* If there are no canldes return 0. \\n* To reduce the size we can do a linear search for stat index and end index to find the nearest candle.\\n* After linear search next optimization is of binary search\\n* But we need a sorted array to do a binary search\\n* Truck is to create an array of position of candles, which will be naturally sorted.\\n\\n\\n### Algorithm\\n* Firstly create a prefix sum over the input array\\n\\t* start counting from the first time algorithm sees ``` \\'|\\' ``` or candle\\n\\t* ```if(s.charAt(index) == \\'|\\')``` carry over the prefix sum of i-1\\n\\t* ``` if(s.charAt(index) != \\'|\\')``` add 1 to the prfix sum of i-1\\n* While calucating prefixsum also create a List of index where ```s.charAt(index) == \\'|\\'``` call this ```arr```\\n* Prefix sum array will be used to give range result and ```arr``` will be used for binary seach\\n* Iterate over all the queries\\n\\t* for starting and ending range in each query do a binary search on ```arr```\\n\\t* the output of binary search will give you appropiate position to insert your range\\n\\t* decrement the last index by 1, coz you need the last ``` \\'|\\' ``` or candle before the range ends\\n* Handle other edge cases as the final step\\n\\n```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        \\n        int[]  prefix = new int[s.length()];\\n        \\n        List<Integer> arr = new ArrayList<>();\\n        \\n        int index = 0;\\n        \\n        int[] ans = new int[queries.length];\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i) == \\'|\\') arr.add(i);\\n        }\\n        \\n        while(index < s.length() && s.charAt(index) != \\'|\\'){\\n            prefix[index] = 0;\\n            index++;\\n        }\\n        \\n        for(;index<s.length();index++){\\n            if(s.charAt(index) == \\'|\\'){\\n                prefix[index] = index-1>=0 ? prefix[index-1] : 0;\\n            }else{\\n                prefix[index] += index-1>=0 ? prefix[index-1] : 0;\\n                prefix[index] +=1;\\n            }\\n        }\\n        \\n        int i = 0;\\n        \\n        for(int[] q: queries){\\n            int last = bs(arr,q[1]);\\n            int start = bs(arr,q[0]);\\n            if(!arr.isEmpty()){\\n                if(last>=arr.size() || arr.get(last) != q[1]) last--;\\n                if(start >= arr.size()) start--;\\n            }\\n\\n            \\n//             while(s.charAt(last) != \\'|\\'){\\n//                 last--;\\n//             }\\n            \\n//             while(s.charAt(start) != \\'|\\'){\\n//                 start++;\\n//             }\\n            \\n            if(last<0) last=0;\\n            \\n            if(!arr.isEmpty()) ans[i] = prefix[arr.get(last)]-prefix[arr.get(start)];\\n            if(ans[i]<0) ans[i]=0;\\n            i++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    public int bs(List<Integer> ls, int target){\\n        int l =0;\\n        int h = ls.size();\\n        \\n        \\n        while(l<h){\\n            int m = l + (h-l)/2; \\n            if(ls.get(m) < target){\\n                l = m+1;\\n            }else{\\n                h = m;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```\\n\\nTime complexity : 0(N) + O(K*log(M)) => N is the length of string to create prefixsum and arr\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t => K: number of queries\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t => M: number of candles",
                "solutionTags": [
                    "Java",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "``` \\'|\\' ```\n```if(s.charAt(index) == \\'|\\')```\n``` if(s.charAt(index) != \\'|\\')```\n```s.charAt(index) == \\'|\\'```\n```arr```\n```arr```\n```arr```\n``` \\'|\\' ```\n```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        \\n        int[]  prefix = new int[s.length()];\\n        \\n        List<Integer> arr = new ArrayList<>();\\n        \\n        int index = 0;\\n        \\n        int[] ans = new int[queries.length];\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i) == \\'|\\') arr.add(i);\\n        }\\n        \\n        while(index < s.length() && s.charAt(index) != \\'|\\'){\\n            prefix[index] = 0;\\n            index++;\\n        }\\n        \\n        for(;index<s.length();index++){\\n            if(s.charAt(index) == \\'|\\'){\\n                prefix[index] = index-1>=0 ? prefix[index-1] : 0;\\n            }else{\\n                prefix[index] += index-1>=0 ? prefix[index-1] : 0;\\n                prefix[index] +=1;\\n            }\\n        }\\n        \\n        int i = 0;\\n        \\n        for(int[] q: queries){\\n            int last = bs(arr,q[1]);\\n            int start = bs(arr,q[0]);\\n            if(!arr.isEmpty()){\\n                if(last>=arr.size() || arr.get(last) != q[1]) last--;\\n                if(start >= arr.size()) start--;\\n            }\\n\\n            \\n//             while(s.charAt(last) != \\'|\\'){\\n//                 last--;\\n//             }\\n            \\n//             while(s.charAt(start) != \\'|\\'){\\n//                 start++;\\n//             }\\n            \\n            if(last<0) last=0;\\n            \\n            if(!arr.isEmpty()) ans[i] = prefix[arr.get(last)]-prefix[arr.get(start)];\\n            if(ans[i]<0) ans[i]=0;\\n            i++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    public int bs(List<Integer> ls, int target){\\n        int l =0;\\n        int h = ls.size();\\n        \\n        \\n        while(l<h){\\n            int m = l + (h-l)/2; \\n            if(ls.get(m) < target){\\n                l = m+1;\\n            }else{\\n                h = m;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415099,
                "title": "cpp-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int search(vector<int> &vec,int k){\\n        int l = 0;\\n        int r = vec.size()-1;\\n        int ans = -1;\\n        while(l<=r){\\n            int m  = (l+r)/2;\\n            // cout<<ans<<\" \"<<k<<\" a\\\\n\";\\n            if(vec[m]>=k){\\n                ans = m;\\n                r = m-1;\\n            }\\n            else{\\n                l = m+1;\\n            }\\n        }\\n        // cout<<ans<<\" ans\\\\n\";\\n        return ans;\\n    }\\n    int search2(vector<int> &vec,int k){\\n        int l = 0;\\n        int r = vec.size()-1;\\n        int ans = -1;\\n        while(l<=r){\\n            int m  = (l+r)/2;\\n            if(vec[m]<=k){\\n                ans = m;\\n                l = m+1;\\n            }\\n            else{\\n                r = m-1;\\n            }\\n        }\\n        // cout<<ans<<\" ans2\\\\n\";\\n        return ans;\\n    }\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& q) {\\n        vector<int> cand;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'|\\'){\\n                cand.push_back(i);\\n                // cout<<cand.back()<<\" \";\\n            }\\n        }\\n        // cout<<\"\\\\n\";\\n        vector<int> ans;\\n        int j =0;\\n        int h =0;\\n        for(auto x:q){\\n            if(cand.size()<=1) {\\n                ans.push_back(0); continue;}\\n            if(x[0]!=x[1]){\\n                j = search(cand,x[0]);\\n                h = search2(cand,x[1]);\\n                // cout<<j<<\" \"<<h<<\" op\\\\n\";\\n                int tot = cand[h] - cand[j]-1;\\n                if(tot-(h-j-1)>=0)\\n                    ans.push_back(tot-(h-j-1));\\n                else{\\n                    ans.push_back(0);\\n                }\\n            }\\n            else{\\n                ans.push_back(0);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int> &vec,int k){\\n        int l = 0;\\n        int r = vec.size()-1;\\n        int ans = -1;\\n        while(l<=r){\\n            int m  = (l+r)/2;\\n            // cout<<ans<<\" \"<<k<<\" a\\\\n\";\\n            if(vec[m]>=k){\\n                ans = m;\\n                r = m-1;\\n            }\\n            else{\\n                l = m+1;\\n            }\\n        }\\n        // cout<<ans<<\" ans\\\\n\";\\n        return ans;\\n    }\\n    int search2(vector<int> &vec,int k){\\n        int l = 0;\\n        int r = vec.size()-1;\\n        int ans = -1;\\n        while(l<=r){\\n            int m  = (l+r)/2;\\n            if(vec[m]<=k){\\n                ans = m;\\n                l = m+1;\\n            }\\n            else{\\n                r = m-1;\\n            }\\n        }\\n        // cout<<ans<<\" ans2\\\\n\";\\n        return ans;\\n    }\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& q) {\\n        vector<int> cand;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'|\\'){\\n                cand.push_back(i);\\n                // cout<<cand.back()<<\" \";\\n            }\\n        }\\n        // cout<<\"\\\\n\";\\n        vector<int> ans;\\n        int j =0;\\n        int h =0;\\n        for(auto x:q){\\n            if(cand.size()<=1) {\\n                ans.push_back(0); continue;}\\n            if(x[0]!=x[1]){\\n                j = search(cand,x[0]);\\n                h = search2(cand,x[1]);\\n                // cout<<j<<\" \"<<h<<\" op\\\\n\";\\n                int tot = cand[h] - cand[j]-1;\\n                if(tot-(h-j-1)>=0)\\n                    ans.push_back(tot-(h-j-1));\\n                else{\\n                    ans.push_back(0);\\n                }\\n            }\\n            else{\\n                ans.push_back(0);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2405156,
                "title": "java-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int[] ans = new int[queries.length];\\n        \\n        HashMap<Integer,Integer> nextOnRight = new HashMap<>();\\n        HashMap<Integer,Integer> nextOnLeft = new HashMap<>();\\n        HashMap<Integer,Integer> prefixSum = new HashMap<>();\\n        Stack<Integer> st = new Stack<>();\\n        \\n        int count = 0;\\n        boolean inBetween = false;\\n        \\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'|\\'){\\n                \\n                if(inBetween){\\n                    prefixSum.put(i,count);\\n                }\\n                inBetween = true;\\n            }else{\\n                if(inBetween){\\n                    count++;\\n                }\\n            }\\n        }\\n        // System.out.println(prefixSum);\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'*\\'){\\n               st.push(i); \\n            }else{\\n                while(!st.isEmpty()){\\n                    int val = st.pop();\\n                    nextOnRight.put(val,i);\\n                }\\n            }\\n        }\\n        st = new Stack<>();\\n        for(int i=s.length()-1;i>=0;i--){\\n            char ch = s.charAt(i);\\n            if(ch == \\'*\\'){\\n                st.push(i);\\n            }else{\\n                while(!st.isEmpty()){\\n                    int val = st.pop();\\n                    nextOnLeft.put(val,i);\\n                }\\n            }\\n        }\\n        //--------\\n        for(int i=0;i<queries.length;i++){\\n            int start = queries[i][0];\\n            int end = queries[i][1];\\n            if(s.charAt(start) == \\'*\\'){\\n                if(nextOnRight.containsKey(start)){\\n                    start = nextOnRight.get(start);\\n                }else{\\n                    ans[i] = 0;\\n                    continue;\\n                }\\n            }\\n            if(s.charAt(end) == \\'*\\'){\\n                if(nextOnLeft.containsKey(end)){\\n                    if(nextOnLeft.get(end)<=start){\\n                        ans[i] = 0;\\n                        continue;\\n                    }\\n                    end = nextOnLeft.get(end);\\n                }else{\\n                    continue;\\n                }\\n            }\\n            ans[i] = prefixSum.getOrDefault(end,0) - prefixSum.getOrDefault(start,0);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int[] ans = new int[queries.length];\\n        \\n        HashMap<Integer,Integer> nextOnRight = new HashMap<>();\\n        HashMap<Integer,Integer> nextOnLeft = new HashMap<>();\\n        HashMap<Integer,Integer> prefixSum = new HashMap<>();\\n        Stack<Integer> st = new Stack<>();\\n        \\n        int count = 0;\\n        boolean inBetween = false;\\n        \\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'|\\'){\\n                \\n                if(inBetween){\\n                    prefixSum.put(i,count);\\n                }\\n                inBetween = true;\\n            }else{\\n                if(inBetween){\\n                    count++;\\n                }\\n            }\\n        }\\n        // System.out.println(prefixSum);\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'*\\'){\\n               st.push(i); \\n            }else{\\n                while(!st.isEmpty()){\\n                    int val = st.pop();\\n                    nextOnRight.put(val,i);\\n                }\\n            }\\n        }\\n        st = new Stack<>();\\n        for(int i=s.length()-1;i>=0;i--){\\n            char ch = s.charAt(i);\\n            if(ch == \\'*\\'){\\n                st.push(i);\\n            }else{\\n                while(!st.isEmpty()){\\n                    int val = st.pop();\\n                    nextOnLeft.put(val,i);\\n                }\\n            }\\n        }\\n        //--------\\n        for(int i=0;i<queries.length;i++){\\n            int start = queries[i][0];\\n            int end = queries[i][1];\\n            if(s.charAt(start) == \\'*\\'){\\n                if(nextOnRight.containsKey(start)){\\n                    start = nextOnRight.get(start);\\n                }else{\\n                    ans[i] = 0;\\n                    continue;\\n                }\\n            }\\n            if(s.charAt(end) == \\'*\\'){\\n                if(nextOnLeft.containsKey(end)){\\n                    if(nextOnLeft.get(end)<=start){\\n                        ans[i] = 0;\\n                        continue;\\n                    }\\n                    end = nextOnLeft.get(end);\\n                }else{\\n                    continue;\\n                }\\n            }\\n            ans[i] = prefixSum.getOrDefault(end,0) - prefixSum.getOrDefault(start,0);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399781,
                "title": "go-solution-o-n-m",
                "content": "\\n```\\nfunc platesBetweenCandles(s string, queries [][]int) []int {\\n    \\n    prefixSum :=  make([]int,len(s))\\n    candleLeft :=  make([]int,len(s))\\n    candleRight :=  make([]int,len(s))\\n    \\n    if s[0] == \\'|\\' {\\n      prefixSum[0] = 0\\n      candleLeft[0] = 0\\n    } else {\\n      prefixSum[0] = 1\\n      candleLeft[0] = -1\\n    }\\n    \\n    if s[len(s) -1] == \\'|\\' {\\n      candleRight[len(s) -1] = len(s) -1\\n    } else {\\n       candleRight[len(s) -1] = -1\\n    }\\n    \\n    for i := 1; i < len(s); i++ {\\n        if s[i] == \\'|\\' {\\n            prefixSum[i] = prefixSum[i - 1 ] \\n            candleLeft[i] = i\\n        } else {\\n            prefixSum[i] = prefixSum[i - 1 ] + 1\\n            candleLeft[i] = candleLeft[i - 1]\\n        }\\n        \\n        if s[len(s) - 1 - i] == \\'|\\' {\\n            candleRight[len(s) - 1 - i] = len(s) - 1 - i\\n        } else {\\n            candleRight[len(s) - 1 - i] = candleRight[len(s) - i]\\n        }\\n    }\\n    \\n    resp := make([]int,len(queries))\\n    for i := range queries {\\n        start := candleRight[queries[i][0]]\\n        end := candleLeft[queries[i][1]]\\n        if start != -1 && end != -1 {\\n            sum :=  prefixSum[end] - prefixSum[start]\\n            if sum > 0 {\\n                resp[i] = sum\\n            }   \\n        }\\n    }\\n    \\n    return resp\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc platesBetweenCandles(s string, queries [][]int) []int {\\n    \\n    prefixSum :=  make([]int,len(s))\\n    candleLeft :=  make([]int,len(s))\\n    candleRight :=  make([]int,len(s))\\n    \\n    if s[0] == \\'|\\' {\\n      prefixSum[0] = 0\\n      candleLeft[0] = 0\\n    } else {\\n      prefixSum[0] = 1\\n      candleLeft[0] = -1\\n    }\\n    \\n    if s[len(s) -1] == \\'|\\' {\\n      candleRight[len(s) -1] = len(s) -1\\n    } else {\\n       candleRight[len(s) -1] = -1\\n    }\\n    \\n    for i := 1; i < len(s); i++ {\\n        if s[i] == \\'|\\' {\\n            prefixSum[i] = prefixSum[i - 1 ] \\n            candleLeft[i] = i\\n        } else {\\n            prefixSum[i] = prefixSum[i - 1 ] + 1\\n            candleLeft[i] = candleLeft[i - 1]\\n        }\\n        \\n        if s[len(s) - 1 - i] == \\'|\\' {\\n            candleRight[len(s) - 1 - i] = len(s) - 1 - i\\n        } else {\\n            candleRight[len(s) - 1 - i] = candleRight[len(s) - i]\\n        }\\n    }\\n    \\n    resp := make([]int,len(queries))\\n    for i := range queries {\\n        start := candleRight[queries[i][0]]\\n        end := candleLeft[queries[i][1]]\\n        if start != -1 && end != -1 {\\n            sum :=  prefixSum[end] - prefixSum[start]\\n            if sum > 0 {\\n                resp[i] = sum\\n            }   \\n        }\\n    }\\n    \\n    return resp\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2388583,
                "title": "javascript-solution-with-o-n-m",
                "content": "```\\n// time O(N + M) Space O(N) N = s.length M = query.length\\nvar platesBetweenCandles = function(s, queries) {\\n    let platPreFixSum = [...Array(s.length + 1)];\\n    let leftViewCandle = [...Array(s.length + 1)];\\n    let rightViewCandle = [...Array(s.length + 1)];\\n    \\n    platPreFixSum[0] = 0;\\n    leftViewCandle[0] = -1;\\n    rightViewCandle[s.length] = -1;\\n    \\n    for(let i = 1; i <= s.length; i++){\\n        platPreFixSum[i] = s[i-1] == \\'*\\' ? platPreFixSum[i - 1] + 1 : platPreFixSum[i - 1];\\n        leftViewCandle[i] = s[i - 1] == \\'|\\' ? i - 1 : leftViewCandle[i - 1];\\n        rightViewCandle[s.length - i] = s[s.length - i] == \\'|\\' ? s.length - i : rightViewCandle[s.length - i + 1];\\n    }\\n    \\n    let result = [];\\n    \\n    queries.forEach(([left, right]) => {\\n        if(rightViewCandle[left] >= 0 && leftViewCandle[right + 1] >= 0 &&\\n           rightViewCandle[left] <  leftViewCandle[right + 1]) {\\n            result.push(platPreFixSum[leftViewCandle[right + 1]] - platPreFixSum[rightViewCandle[left]]);\\n        } else {\\n            result.push(0);\\n        }\\n    });\\n    \\n    return result;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// time O(N + M) Space O(N) N = s.length M = query.length\\nvar platesBetweenCandles = function(s, queries) {\\n    let platPreFixSum = [...Array(s.length + 1)];\\n    let leftViewCandle = [...Array(s.length + 1)];\\n    let rightViewCandle = [...Array(s.length + 1)];\\n    \\n    platPreFixSum[0] = 0;\\n    leftViewCandle[0] = -1;\\n    rightViewCandle[s.length] = -1;\\n    \\n    for(let i = 1; i <= s.length; i++){\\n        platPreFixSum[i] = s[i-1] == \\'*\\' ? platPreFixSum[i - 1] + 1 : platPreFixSum[i - 1];\\n        leftViewCandle[i] = s[i - 1] == \\'|\\' ? i - 1 : leftViewCandle[i - 1];\\n        rightViewCandle[s.length - i] = s[s.length - i] == \\'|\\' ? s.length - i : rightViewCandle[s.length - i + 1];\\n    }\\n    \\n    let result = [];\\n    \\n    queries.forEach(([left, right]) => {\\n        if(rightViewCandle[left] >= 0 && leftViewCandle[right + 1] >= 0 &&\\n           rightViewCandle[left] <  leftViewCandle[right + 1]) {\\n            result.push(platPreFixSum[leftViewCandle[right + 1]] - platPreFixSum[rightViewCandle[left]]);\\n        } else {\\n            result.push(0);\\n        }\\n    });\\n    \\n    return result;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2381453,
                "title": "python3-o-n-q-solution-very-simple-explanation-code-comment",
                "content": "```\\ndef solution(s, queries):\\n  \\'\\'\\'\\n  Observation:\\n  (1). To quickly find # of plates within [L, R] boundary we can use prefix sum by converting\\n  s[i] = 1 if s[i] is a plate else 0. Then # of plates = ps[R] - ps[L]\\n\\n  (2). There are several edge cases:\\n    (2.1). [ *|...|* ] either s[L] or s[R] is not a candle: invalid boundary.\\n    (2.2). [ *** ]: there is no candle in between.\\n\\n  (3). Thus:\\n    (3.1). Given L we need to find the rightmost candle starting from L.\\n    (3.2). Given R we need to find the leftmost candle starting from R.\\n\\n  Algorithm:\\n  (1). Convert s to {0, 1}\\n  (2). Calculate prefix sum O(N)\\n  (3). Determine leftmost_candle[i] (leftmost candle starting from 0-->i) O(N)\\n  (4). Determine rightmost_candle[i] (rightmost candle starting from i-->n-1) O(N)\\n  For each query:\\n  (5). new_L = leftmost_candle[right] and new_R = rightmost_candle[left] O(1)\\n\\n  Time complexity: O(N + Q)\\n  \\'\\'\\'\\n  s = list(s)\\n  n = len(s)\\n  for i in range(n):\\n    s[i] = 0 if s[i] == \\'|\\' else 1\\n\\n  ps = [num for num in s]\\n  for i in range(1, n):\\n    ps[i] += ps[i - 1]\\n\\n  leftmost_candle = [-1 for i in range(n)]\\n  leftmost_candle[0] = 0 if s[0] == 0 else -1\\n  for i in range(1, n):\\n    leftmost_candle[i] = i if s[i] == 0 else leftmost_candle[i - 1]\\n\\n  rightmost_candle = [n for i in range(n)]\\n  rightmost_candle[-1] = n - 1 if s[-1] == 0 else n\\n  for i in reversed(range(n - 1)):\\n    rightmost_candle[i] = i if s[i] == 0 else rightmost_candle[i + 1]\\n\\n  result = []\\n\\n  for left, right in queries:\\n    L, R = rightmost_candle[left], leftmost_candle[right]\\n    if L == -1 or R == n or L > R: # L > R means there is no candle in between\\n      result.append(0)\\n    else:\\n      result.append(ps[R] - (ps[L] if L >= 0 else 0))\\n\\n  return result\\n\\ns = \\'**|**|***|\\'\\nqueries = [[2,5],[5,9]]\\nprint(solution(s, queries))\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\ndef solution(s, queries):\\n  \\'\\'\\'\\n  Observation:\\n  (1). To quickly find # of plates within [L, R] boundary we can use prefix sum by converting\\n  s[i] = 1 if s[i] is a plate else 0. Then # of plates = ps[R] - ps[L]\\n\\n  (2). There are several edge cases:\\n    (2.1). [ *|...|* ] either s[L] or s[R] is not a candle: invalid boundary.\\n    (2.2). [ *** ]: there is no candle in between.\\n\\n  (3). Thus:\\n    (3.1). Given L we need to find the rightmost candle starting from L.\\n    (3.2). Given R we need to find the leftmost candle starting from R.\\n\\n  Algorithm:\\n  (1). Convert s to {0, 1}\\n  (2). Calculate prefix sum O(N)\\n  (3). Determine leftmost_candle[i] (leftmost candle starting from 0-->i) O(N)\\n  (4). Determine rightmost_candle[i] (rightmost candle starting from i-->n-1) O(N)\\n  For each query:\\n  (5). new_L = leftmost_candle[right] and new_R = rightmost_candle[left] O(1)\\n\\n  Time complexity: O(N + Q)\\n  \\'\\'\\'\\n  s = list(s)\\n  n = len(s)\\n  for i in range(n):\\n    s[i] = 0 if s[i] == \\'|\\' else 1\\n\\n  ps = [num for num in s]\\n  for i in range(1, n):\\n    ps[i] += ps[i - 1]\\n\\n  leftmost_candle = [-1 for i in range(n)]\\n  leftmost_candle[0] = 0 if s[0] == 0 else -1\\n  for i in range(1, n):\\n    leftmost_candle[i] = i if s[i] == 0 else leftmost_candle[i - 1]\\n\\n  rightmost_candle = [n for i in range(n)]\\n  rightmost_candle[-1] = n - 1 if s[-1] == 0 else n\\n  for i in reversed(range(n - 1)):\\n    rightmost_candle[i] = i if s[i] == 0 else rightmost_candle[i + 1]\\n\\n  result = []\\n\\n  for left, right in queries:\\n    L, R = rightmost_candle[left], leftmost_candle[right]\\n    if L == -1 or R == n or L > R: # L > R means there is no candle in between\\n      result.append(0)\\n    else:\\n      result.append(ps[R] - (ps[L] if L >= 0 else 0))\\n\\n  return result\\n\\ns = \\'**|**|***|\\'\\nqueries = [[2,5],[5,9]]\\nprint(solution(s, queries))\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2361424,
                "title": "c-easy-and-commented-solution-with-basic-binary-search-lower-bound-upper-bound-approach",
                "content": "```\\nvector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n    vector<int> result;\\n\\n    // Collect all the candles indexes only\\n    vector<int> candles;\\n    for (int i = 0; i < s.size(); ++i) {\\n        if (s[i] == \\'|\\') candles.push_back(i);\\n    }\\n\\n    // Iterate over all queries (start index - end index)\\n    for (auto &query: queries) {\\n        int startIndex = query[0];\\n        int endIndex = query[1];\\n\\n        // Find the index of the candles with a value that is equal or greater than startIndex\\n        auto left = std::lower_bound(candles.begin(), candles.end(), startIndex) - candles.begin();\\n        // Find the index of the candles with a value that is greater than endIndex and subtract 1, eg. index - 1\\n        auto right = (std::upper_bound(candles.begin(), candles.end(), endIndex) - candles.begin()) - 1;\\n\\n        if (left < right) {\\n            // Guess the number of candles calculating the difference between (candles indexes on the string)\\n            // so we get the exact number of plates only and subtracting (indexes of the candles vector) that is the\\n            // candles count we could obtain the number of plates only\\n            auto plates = ((candles[right] - candles[left]) - (right - left));\\n\\n            result.push_back((int) plates);\\n        } else {\\n            // No plates found as we reached an invalid candles indices\\n            result.push_back(0);\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nvector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n    vector<int> result;\\n\\n    // Collect all the candles indexes only\\n    vector<int> candles;\\n    for (int i = 0; i < s.size(); ++i) {\\n        if (s[i] == \\'|\\') candles.push_back(i);\\n    }\\n\\n    // Iterate over all queries (start index - end index)\\n    for (auto &query: queries) {\\n        int startIndex = query[0];\\n        int endIndex = query[1];\\n\\n        // Find the index of the candles with a value that is equal or greater than startIndex\\n        auto left = std::lower_bound(candles.begin(), candles.end(), startIndex) - candles.begin();\\n        // Find the index of the candles with a value that is greater than endIndex and subtract 1, eg. index - 1\\n        auto right = (std::upper_bound(candles.begin(), candles.end(), endIndex) - candles.begin()) - 1;\\n\\n        if (left < right) {\\n            // Guess the number of candles calculating the difference between (candles indexes on the string)\\n            // so we get the exact number of plates only and subtracting (indexes of the candles vector) that is the\\n            // candles count we could obtain the number of plates only\\n            auto plates = ((candles[right] - candles[left]) - (right - left));\\n\\n            result.push_back((int) plates);\\n        } else {\\n            // No plates found as we reached an invalid candles indices\\n            result.push_back(0);\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2337061,
                "title": "java-solution-with-comments-easy-to-understand-binary-search-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int helper(int [] query,int candlepos[],int sumarray[]){\\n        int left=0;int right=candlepos.length-1;\\n        // find the left candle just greater that then the from query;\\n        int leftcandle=-1;\\n        while(left<=right){\\n            int mid=(left+right)/2;\\n            if(candlepos[mid]<query[0])\\n                left=mid+1;\\n            else{\\n                leftcandle=candlepos[mid];\\n                right=mid-1;\\n            }\\n        }\\n        int rightcandle=sumarray.length;\\n        // find the right candle just less that then the to query;\\n        left=0;right=candlepos.length-1;\\n        while(left<=right){\\n            int mid=(left+right)/2;\\n            if(candlepos[mid]>query[1])\\n                right=mid-1;\\n            else{\\n                rightcandle=candlepos[mid];\\n                left=mid+1;\\n            }\\n        }\\n        if(leftcandle==-1||rightcandle==sumarray.length)\\n            return 0;\\n        if(leftcandle>=rightcandle)\\n            return 0;\\n        // calculate the number of plates present between the candles leftcandle and rightcandle\\n        return (rightcandle-leftcandle)-(sumarray[rightcandle]-sumarray[leftcandle]);\\n    }\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        \\n        int sumarray[]=new int[s.length()]; // stores the number of candles till ith index(inc. i)\\n        int sum=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'|\\'){\\n                sum++;\\n            }\\n            sumarray[i]=sum;\\n        }\\n        int candlepos[]=new int[sum];// stores the position of candles\\n        int pos=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'|\\'){\\n                candlepos[pos]=i;\\n                pos++;\\n            }\\n        }\\n        int ans[]=new int[queries.length];\\n        int i=0;\\n        for(int [] query:queries){\\n            ans[i]=helper(query,candlepos,sumarray);\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int helper(int [] query,int candlepos[],int sumarray[]){\\n        int left=0;int right=candlepos.length-1;\\n        // find the left candle just greater that then the from query;\\n        int leftcandle=-1;\\n        while(left<=right){\\n            int mid=(left+right)/2;\\n            if(candlepos[mid]<query[0])\\n                left=mid+1;\\n            else{\\n                leftcandle=candlepos[mid];\\n                right=mid-1;\\n            }\\n        }\\n        int rightcandle=sumarray.length;\\n        // find the right candle just less that then the to query;\\n        left=0;right=candlepos.length-1;\\n        while(left<=right){\\n            int mid=(left+right)/2;\\n            if(candlepos[mid]>query[1])\\n                right=mid-1;\\n            else{\\n                rightcandle=candlepos[mid];\\n                left=mid+1;\\n            }\\n        }\\n        if(leftcandle==-1||rightcandle==sumarray.length)\\n            return 0;\\n        if(leftcandle>=rightcandle)\\n            return 0;\\n        // calculate the number of plates present between the candles leftcandle and rightcandle\\n        return (rightcandle-leftcandle)-(sumarray[rightcandle]-sumarray[leftcandle]);\\n    }\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        \\n        int sumarray[]=new int[s.length()]; // stores the number of candles till ith index(inc. i)\\n        int sum=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'|\\'){\\n                sum++;\\n            }\\n            sumarray[i]=sum;\\n        }\\n        int candlepos[]=new int[sum];// stores the position of candles\\n        int pos=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'|\\'){\\n                candlepos[pos]=i;\\n                pos++;\\n            }\\n        }\\n        int ans[]=new int[queries.length];\\n        int i=0;\\n        for(int [] query:queries){\\n            ans[i]=helper(query,candlepos,sumarray);\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2331057,
                "title": "easy-solution-using-treeset-and-prefixcount",
                "content": "class Solution {\\n    static TreeSet<Integer> al;\\n    static int[] freq;\\n    public int[] platesBetweenCandles(String s, int[][] q) {\\n        char[] arr = s.toCharArray();\\n        int[] ans = new int[q.length];\\n        al = new TreeSet<>();\\n        freq = new int[s.length()];\\n        int count = 0;\\n        for(int i = 0;i<arr.length;i++){\\n            if(arr[i] == \\'|\\'){\\n                al.add(i);\\n                count++;\\n            }\\n            freq[i] = count;\\n        }\\n        for(int i = 0;i<q.length;i++){\\n            ans[i] = find(arr,q[i][0],q[i][1]);\\n        }\\n        return ans;\\n    }\\n    public int find(char[] arr,int low,int high){\\n        int a = -1;\\n        int b = -1;\\n        if(al.size() == 0){\\n            return 0;\\n        }\\n        if(al.first() <= high){\\n        a = al.floor(high);\\n        }\\n        if(al.last() >= low){\\n        b = al.ceiling(low);\\n        }\\n        if(a == -1 || b == -1 || a < low || a > high || b < low || b > high){\\n            return 0;\\n        }\\n        int ans = freq[a];\\n        int ans1 = freq[b];\\n        return 1+Math.abs(b-a)-(ans-ans1+((arr[b] == \\'|\\')?1:0));\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    static TreeSet<Integer> al;\\n    static int[] freq;\\n    public int[] platesBetweenCandles(String s, int[][] q) {\\n        char[] arr = s.toCharArray();\\n        int[] ans = new int[q.length];\\n        al = new TreeSet<>();\\n        freq = new int[s.length()];\\n        int count = 0;\\n        for(int i = 0;i<arr.length;i++){\\n            if(arr[i] == \\'|\\'){\\n                al.add(i);\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2310428,
                "title": "python3-segment-tree-solution",
                "content": "Just wonder why there is no segment tree solution yet even it is not optimal solution.\\nThe solution idea is simple: find left and right boundary by binary search and query segment tree for summation.\\n\\nThe solution below can be a simple practice to be familiar with segment tree template:\\n\\n```\\nclass Node:\\n    def __init__(self, lo, hi, sm=0, mx=0, lazy=None): # lazy=0 for rangeAdd\\n        self.lo = lo\\n        self.hi = hi\\n        self.sm = sm # range sum from low to high\\n        self.mx = mx # range max from low to high\\n        self.lazy = lazy # lazy propagation for range update\\n        self.left = None\\n        self.right = None\\n\\nclass SegmentTree:\\n    def __init__(self, lo, hi, A=[]):\\n        if A: self.root = self._build(lo, hi, A)\\n        else: self.root = Node(lo, hi)\\n\\n    def _build(self, lo, hi, A):\\n        node = Node(lo, hi)\\n        if lo==hi: \\n            node.sm = A[lo]\\n            node.mx = A[lo]\\n        else:\\n            m = (lo+hi)//2\\n            node.left = self._build(lo, m, A)\\n            node.right = self._build(m+1, hi, A)\\n            node.sm = node.left.sm + node.right.sm\\n            node.mx = max(node.left.mx, node.right.mx)\\n        return node\\n\\n    def _sumQuery(self, node, lo, hi):\\n        if not node: return 0\\n        if node.lo==lo and node.hi==hi: return node.sm\\n        m = (node.lo+node.hi)//2\\n        if hi<=m: return self._sumQuery(node.left, lo, hi)\\n        elif lo>m: return self._sumQuery(node.right, lo, hi)\\n        else: return self._sumQuery(node.left, lo, m)+self._sumQuery(node.right, m+1, hi)\\n        \\n        \\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        candles = [-inf]+[i for i, x in enumerate(s) if x==\\'|\\']+[inf]\\n        A = [1 if c==\\'*\\' else 0 for c in s]\\n        st = SegmentTree(0, len(A)-1, A)\\n        ans = []\\n        for l, r in queries:\\n            ll = bisect_right(candles, l-1)\\n            rr = bisect_left(candles, r+1)\\n            ll, rr = candles[ll], candles[rr-1]\\n            if ll<rr: ans.append(st._sumQuery(st.root, ll, rr))\\n            else: ans.append(0)\\n        return ans\\n```\\n\\nI also attached the ultimate template for all segment tree problem for you to refer. So given a problem, you will only need to pick up necessary functions in the template and come up with the main function, good luck.\\n\\n``` py\\n# Discretization from value to index if necessary\\nv2i = {x: i for i, x in enumerate(sorted(set(A)))}\\n\\nclass Node:\\n    def __init__(self, lo, hi, sm=0, mx=0, lazy=None): # lazy=0 for rangeAdd\\n        self.lo = lo\\n        self.hi = hi\\n        self.sm = sm # range sum from low to high\\n        self.mx = mx # range max from low to high\\n        self.lazy = lazy # lazy propagation for range update\\n        self.left = None\\n        self.right = None\\n\\nclass SegmentTree:\\n    def __init__(self, lo, hi, A=[]):\\n        if A: self.root = self._build(lo, hi, A)\\n        else: self.root = Node(lo, hi)\\n\\n    def _build(self, lo, hi, A):\\n        node = Node(lo, hi)\\n        if lo==hi: \\n            node.sm = A[lo]\\n            node.mx = A[lo]\\n        else:\\n            m = (lo+hi)//2\\n            node.left = self._build(lo, m, A)\\n            node.right = self._build(m+1, hi, A)\\n            node.sm = node.left.sm + node.right.sm\\n            node.mx = max(node.left.mx, node.right.mx)\\n        return node\\n    \\n    def _add(self, node, i, val):\\n        if node.lo==node.hi:\\n            node.sm += val\\n            node.mx += val\\n            return \\n        m = (node.lo+node.hi)//2\\n        # dynamic growing without building tree\\n        if not node.left and not node.right: \\n            node.left = Node(node.lo, m)\\n            node.right = Node(m+1, node.hi)\\n\\n        if i<=m: self._add(node.left, i, val)\\n        elif i>m: self._add(node.right, i, val)\\n        node.sm = node.left.sm + node.right.sm\\n        node.mx = max(node.left.mx, node.right.mx)\\n\\n    def _set(self, node, i, val):\\n        if node.lo==node.hi:\\n            node.sm = val\\n            node.mx = val\\n            return \\n        m = (node.lo+node.hi)//2\\n        # dynamic growing without building tree\\n        if not node.left and not node.right: \\n            node.left = Node(node.lo, m)\\n            node.right = Node(m+1, node.hi)\\n\\n        if i<=m: self._set(node.left, i, val)\\n        elif i>m: self._set(node.right, i, val)\\n        node.sm = node.left.sm + node.right.sm\\n        node.mx = max(node.left.mx, node.right.mx)        \\n\\n    def _sumQuery(self, node, lo, hi):\\n        if not node: return 0\\n        if node.lo==lo and node.hi==hi: return node.sm\\n        m = (node.lo+node.hi)//2\\n        if hi<=m: return self._sumQuery(node.left, lo, hi)\\n        elif lo>m: return self._sumQuery(node.right, lo, hi)\\n        else: return self._sumQuery(node.left, lo, m)+self._sumQuery(node.right, m+1, hi)\\n\\n    def _maxQuery(self, node, lo, hi):\\n        if not node: return 0\\n        if node.lo==lo and node.hi==hi: return node.mx\\n        m = (node.lo+node.hi)//2\\n        if hi<=m: return self._maxQuery(node.left, lo, hi)\\n        elif lo>m: return self._maxQuery(node.right, lo, hi)\\n        else: return max(self._maxQuery(node.left, lo, m), self._maxQuery(node.right, m+1, hi))\\n\\n    \"\"\"\\n    Range add sum & query\\n    \"\"\"\\n    def rangeAddSum(self, node, val, lo, hi):\\n        if node.lo==lo and node.hi==hi:\\n            node.sm += val\\n            node.lazy += val\\n            return \\n        \\n        m = (node.lo+node.hi)//2\\n        # push lazy to children, if no children, create them\\n        if not node.left and not node.right:\\n            node.left = Node(node.lo, m, 0, None, 0)\\n            node.right = Node(m+1, node.hi, 0, None, 0)\\n        else:\\n            node.left.sm += node.lazy\\n            node.left.lazy += node.lazy\\n            node.right.sm += node.lazy\\n            node.right.lazy += node.lazy\\n        node.lazy = None\\n        # update the children\\n        if m>=hi:\\n            self.rangeAddSum(node.left, val, lo, hi)\\n        elif m<lo:\\n            self.rangeAddSum(node.right, val, lo, hi)\\n        else:\\n            self.rangeAddSum(node.left, val, lo, m)\\n            self.rangeAddSum(node.right, val, m+1, hi)\\n        # update the node\\n        node.sm = node.left.sm + node.right.sm\\n        return\\n\\n    def rangeAddSumQuery(self, node, lo, hi):\\n        if not node: return 0\\n        if node.lo==lo and node.hi==hi: return node.sm\\n        m = (node.lo+node.hi)//2\\n        if hi<=m: return node.lazy+self.rangeAddSumQuery(node.left, lo, hi)\\n        elif lo>m: return node.lazy+self.rangeAddSumQuery(node.right, lo, hi)\\n        else: return node.lazy+self.rangeAddSumQuery(node.left, lo, m)+self.rangeAddSumQuery(node.right, m+1, hi)\\n\\n    \"\"\"\\n    Range add max & query: 732, 731, 729\\n    \"\"\"\\n    def rangeAddMax(self, node, val, lo, hi):\\n        if node.lo==lo and node.hi==hi:\\n            node.mx += val\\n            node.lazy += val\\n            return \\n        \\n        m = (node.lo+node.hi)//2\\n        # push lazy to children, if no children, create them\\n        if not node.left and not node.right:\\n            node.left = Node(node.lo, m, 0, node.lazy, node.lazy)\\n            node.right = Node(m+1, node.hi, 0, node.lazy, node.lazy)\\n        else:\\n            node.left.mx += node.lazy\\n            node.left.lazy += node.lazy\\n            node.right.mx += node.lazy\\n            node.right.lazy += node.lazy\\n        node.lazy = 0\\n        # update the children\\n        if m>=hi:\\n            self.rangeAddMax(node.left, val, lo, hi)\\n        elif m<lo:\\n            self.rangeAddMax(node.right, val, lo, hi)\\n        else:\\n            self.rangeAddMax(node.left, val, lo, m)\\n            self.rangeAddMax(node.right, val, m+1, hi)\\n        # update the node\\n        node.mx = max(node.left.mx, node.right.mx)\\n        return\\n\\n    def rangeAddMaxQuery(self, node, lo, hi):\\n        if not node: return 0\\n        if node.lo==lo and node.hi==hi: return node.mx\\n        m = (node.lo+node.hi)//2\\n        if node.lazy!=None: return node.lazy\\n        if hi<=m: return node.lazy+self.rangeAddMaxQuery(node.left, lo, hi)\\n        elif lo>m: return node.lazy+self.rangeAddMaxQuery(node.right, lo, hi)\\n        else: return node.lazy+max(self.rangeAddMaxQuery(node.left, lo, m), self.rangeAddMaxQuery(node.right, m+1, hi))\\n\\n    \\n    \"\"\"\\n    range set sum & query: 715\\n    \"\"\"\\n    def rangeSetSum(self, node, val, lo, hi):\\n        if node.lo==lo and node.hi==hi:\\n            node.sm = val*(node.hi-node.lo+1)\\n            node.lazy = val\\n            return \\n        \\n        m = (node.lo+node.hi)//2\\n        # push lazy to children, if no children, create them on the fly\\n        if not node.left and not node.right:\\n            if node.lazy!=None:\\n                node.left = Node(node.lo, m, node.lazy*(m-node.lo+1), None, node.lazy)\\n                node.right = Node(m+1, node.hi, node.lazy*(node.hi-m), None, node.lazy)\\n            else:\\n                node.left = Node(node.lo, m)\\n                node.right = Node(m+1, node.hi)\\n        elif node.lazy!=None:\\n            node.left.sm = node.lazy*(m-node.lo+1)\\n            node.left.lazy = node.lazy\\n            node.right.sm = node.lazy*(node.hi-m)\\n            node.right.lazy = node.lazy\\n        # reset lazy tag\\n        node.lazy = None\\n        # update the children\\n        if m>=hi:\\n            self.rangeSetSum(node.left, val, lo, hi)\\n        elif m<lo:\\n            self.rangeSetSum(node.right, val, lo, hi)\\n        else:\\n            self.rangeSetSum(node.left, val, lo, m)\\n            self.rangeSetSum(node.right, val, m+1, hi)\\n        # update the node\\n        node.sm = node.left.sm+node.right.sm\\n        return\\n\\n    def rangeSetSumQuery(self, node, lo, hi):\\n        if not node: return 0\\n        if node.lo==lo and node.hi==hi: return node.sm\\n        m = (node.lo+node.hi)//2\\n        if node.lazy!=None: return node.lazy*(hi-lo+1)\\n        if hi<=m: return self.rangeSetSumQuery(node.left, lo, hi)\\n        elif lo>m: return self.rangeSetSumQuery(node.right, lo, hi)\\n        else: return self.rangeSetSumQuery(node.left, lo, m)+self.rangeSetSumQuery(node.right, m+1, hi)\\n\\n    \"\"\"\\n    range set max: 699\\n    \"\"\"\\n    def rangeSetMax(self, node, val, lo, hi):\\n        if node.lo==lo and node.hi==hi:\\n            node.mx = val\\n            node.lazy = val\\n            return \\n        \\n        m = (node.lo+node.hi)//2\\n        # push lazy to children, if no children, create them on the fly\\n        if not node.left and not node.right:\\n            node.left = Node(node.lo, m, None, 0, node.lazy)\\n            node.right = Node(m+1, node.hi, None, 0, node.lazy)\\n        elif node.lazy!=None:\\n            node.left.mx = node.lazy\\n            node.left.lazy = node.lazy\\n            node.right.mx = node.lazy\\n            node.right.lazy = node.lazy\\n        # reset lazy tag\\n        node.lazy = None\\n        # update the children\\n        if m>=hi: self.rangeSetMax(node.left, val, lo, hi)\\n        elif m<lo: self.rangeSetMax(node.right, val, lo, hi)\\n        else:\\n            self.rangeSetMax(node.left, val, lo, m)\\n            self.rangeSetMax(node.right, val, m+1, hi)\\n        # update the node\\n        node.mx = max(node.left.mx, node.right.mx, node.mx)\\n        return\\n\\n    def rangeSetMaxQuery(self, node, lo, hi):\\n        if not node: return 0\\n        if node.lo==lo and node.hi==hi: return node.mx\\n        m = (node.lo+node.hi)//2\\n        if node.lazy!=None: return node.lazy\\n        if hi<=m: return self.rangeSetMaxQuery(node.left, lo, hi)\\n        elif lo>m: return self.rangeSetMaxQuery(node.right, lo, hi)\\n        else: return max(self.rangeSetMaxQuery(node.left, lo, m), self.rangeSetMaxQuery(node.right, m+1, hi))\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, lo, hi, sm=0, mx=0, lazy=None): # lazy=0 for rangeAdd\\n        self.lo = lo\\n        self.hi = hi\\n        self.sm = sm # range sum from low to high\\n        self.mx = mx # range max from low to high\\n        self.lazy = lazy # lazy propagation for range update\\n        self.left = None\\n        self.right = None\\n\\nclass SegmentTree:\\n    def __init__(self, lo, hi, A=[]):\\n        if A: self.root = self._build(lo, hi, A)\\n        else: self.root = Node(lo, hi)\\n\\n    def _build(self, lo, hi, A):\\n        node = Node(lo, hi)\\n        if lo==hi: \\n            node.sm = A[lo]\\n            node.mx = A[lo]\\n        else:\\n            m = (lo+hi)//2\\n            node.left = self._build(lo, m, A)\\n            node.right = self._build(m+1, hi, A)\\n            node.sm = node.left.sm + node.right.sm\\n            node.mx = max(node.left.mx, node.right.mx)\\n        return node\\n\\n    def _sumQuery(self, node, lo, hi):\\n        if not node: return 0\\n        if node.lo==lo and node.hi==hi: return node.sm\\n        m = (node.lo+node.hi)//2\\n        if hi<=m: return self._sumQuery(node.left, lo, hi)\\n        elif lo>m: return self._sumQuery(node.right, lo, hi)\\n        else: return self._sumQuery(node.left, lo, m)+self._sumQuery(node.right, m+1, hi)\\n        \\n        \\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        candles = [-inf]+[i for i, x in enumerate(s) if x==\\'|\\']+[inf]\\n        A = [1 if c==\\'*\\' else 0 for c in s]\\n        st = SegmentTree(0, len(A)-1, A)\\n        ans = []\\n        for l, r in queries:\\n            ll = bisect_right(candles, l-1)\\n            rr = bisect_left(candles, r+1)\\n            ll, rr = candles[ll], candles[rr-1]\\n            if ll<rr: ans.append(st._sumQuery(st.root, ll, rr))\\n            else: ans.append(0)\\n        return ans\\n```\n``` py\\n# Discretization from value to index if necessary\\nv2i = {x: i for i, x in enumerate(sorted(set(A)))}\\n\\nclass Node:\\n    def __init__(self, lo, hi, sm=0, mx=0, lazy=None): # lazy=0 for rangeAdd\\n        self.lo = lo\\n        self.hi = hi\\n        self.sm = sm # range sum from low to high\\n        self.mx = mx # range max from low to high\\n        self.lazy = lazy # lazy propagation for range update\\n        self.left = None\\n        self.right = None\\n\\nclass SegmentTree:\\n    def __init__(self, lo, hi, A=[]):\\n        if A: self.root = self._build(lo, hi, A)\\n        else: self.root = Node(lo, hi)\\n\\n    def _build(self, lo, hi, A):\\n        node = Node(lo, hi)\\n        if lo==hi: \\n            node.sm = A[lo]\\n            node.mx = A[lo]\\n        else:\\n            m = (lo+hi)//2\\n            node.left = self._build(lo, m, A)\\n            node.right = self._build(m+1, hi, A)\\n            node.sm = node.left.sm + node.right.sm\\n            node.mx = max(node.left.mx, node.right.mx)\\n        return node\\n    \\n    def _add(self, node, i, val):\\n        if node.lo==node.hi:\\n            node.sm += val\\n            node.mx += val\\n            return \\n        m = (node.lo+node.hi)//2\\n        # dynamic growing without building tree\\n        if not node.left and not node.right: \\n            node.left = Node(node.lo, m)\\n            node.right = Node(m+1, node.hi)\\n\\n        if i<=m: self._add(node.left, i, val)\\n        elif i>m: self._add(node.right, i, val)\\n        node.sm = node.left.sm + node.right.sm\\n        node.mx = max(node.left.mx, node.right.mx)\\n\\n    def _set(self, node, i, val):\\n        if node.lo==node.hi:\\n            node.sm = val\\n            node.mx = val\\n            return \\n        m = (node.lo+node.hi)//2\\n        # dynamic growing without building tree\\n        if not node.left and not node.right: \\n            node.left = Node(node.lo, m)\\n            node.right = Node(m+1, node.hi)\\n\\n        if i<=m: self._set(node.left, i, val)\\n        elif i>m: self._set(node.right, i, val)\\n        node.sm = node.left.sm + node.right.sm\\n        node.mx = max(node.left.mx, node.right.mx)        \\n\\n    def _sumQuery(self, node, lo, hi):\\n        if not node: return 0\\n        if node.lo==lo and node.hi==hi: return node.sm\\n        m = (node.lo+node.hi)//2\\n        if hi<=m: return self._sumQuery(node.left, lo, hi)\\n        elif lo>m: return self._sumQuery(node.right, lo, hi)\\n        else: return self._sumQuery(node.left, lo, m)+self._sumQuery(node.right, m+1, hi)\\n\\n    def _maxQuery(self, node, lo, hi):\\n        if not node: return 0\\n        if node.lo==lo and node.hi==hi: return node.mx\\n        m = (node.lo+node.hi)//2\\n        if hi<=m: return self._maxQuery(node.left, lo, hi)\\n        elif lo>m: return self._maxQuery(node.right, lo, hi)\\n        else: return max(self._maxQuery(node.left, lo, m), self._maxQuery(node.right, m+1, hi))\\n\\n    \"\"\"\\n    Range add sum & query\\n    \"\"\"\\n    def rangeAddSum(self, node, val, lo, hi):\\n        if node.lo==lo and node.hi==hi:\\n            node.sm += val\\n            node.lazy += val\\n            return \\n        \\n        m = (node.lo+node.hi)//2\\n        # push lazy to children, if no children, create them\\n        if not node.left and not node.right:\\n            node.left = Node(node.lo, m, 0, None, 0)\\n            node.right = Node(m+1, node.hi, 0, None, 0)\\n        else:\\n            node.left.sm += node.lazy\\n            node.left.lazy += node.lazy\\n            node.right.sm += node.lazy\\n            node.right.lazy += node.lazy\\n        node.lazy = None\\n        # update the children\\n        if m>=hi:\\n            self.rangeAddSum(node.left, val, lo, hi)\\n        elif m<lo:\\n            self.rangeAddSum(node.right, val, lo, hi)\\n        else:\\n            self.rangeAddSum(node.left, val, lo, m)\\n            self.rangeAddSum(node.right, val, m+1, hi)\\n        # update the node\\n        node.sm = node.left.sm + node.right.sm\\n        return\\n\\n    def rangeAddSumQuery(self, node, lo, hi):\\n        if not node: return 0\\n        if node.lo==lo and node.hi==hi: return node.sm\\n        m = (node.lo+node.hi)//2\\n        if hi<=m: return node.lazy+self.rangeAddSumQuery(node.left, lo, hi)\\n        elif lo>m: return node.lazy+self.rangeAddSumQuery(node.right, lo, hi)\\n        else: return node.lazy+self.rangeAddSumQuery(node.left, lo, m)+self.rangeAddSumQuery(node.right, m+1, hi)\\n\\n    \"\"\"\\n    Range add max & query: 732, 731, 729\\n    \"\"\"\\n    def rangeAddMax(self, node, val, lo, hi):\\n        if node.lo==lo and node.hi==hi:\\n            node.mx += val\\n            node.lazy += val\\n            return \\n        \\n        m = (node.lo+node.hi)//2\\n        # push lazy to children, if no children, create them\\n        if not node.left and not node.right:\\n            node.left = Node(node.lo, m, 0, node.lazy, node.lazy)\\n            node.right = Node(m+1, node.hi, 0, node.lazy, node.lazy)\\n        else:\\n            node.left.mx += node.lazy\\n            node.left.lazy += node.lazy\\n            node.right.mx += node.lazy\\n            node.right.lazy += node.lazy\\n        node.lazy = 0\\n        # update the children\\n        if m>=hi:\\n            self.rangeAddMax(node.left, val, lo, hi)\\n        elif m<lo:\\n            self.rangeAddMax(node.right, val, lo, hi)\\n        else:\\n            self.rangeAddMax(node.left, val, lo, m)\\n            self.rangeAddMax(node.right, val, m+1, hi)\\n        # update the node\\n        node.mx = max(node.left.mx, node.right.mx)\\n        return\\n\\n    def rangeAddMaxQuery(self, node, lo, hi):\\n        if not node: return 0\\n        if node.lo==lo and node.hi==hi: return node.mx\\n        m = (node.lo+node.hi)//2\\n        if node.lazy!=None: return node.lazy\\n        if hi<=m: return node.lazy+self.rangeAddMaxQuery(node.left, lo, hi)\\n        elif lo>m: return node.lazy+self.rangeAddMaxQuery(node.right, lo, hi)\\n        else: return node.lazy+max(self.rangeAddMaxQuery(node.left, lo, m), self.rangeAddMaxQuery(node.right, m+1, hi))\\n\\n    \\n    \"\"\"\\n    range set sum & query: 715\\n    \"\"\"\\n    def rangeSetSum(self, node, val, lo, hi):\\n        if node.lo==lo and node.hi==hi:\\n            node.sm = val*(node.hi-node.lo+1)\\n            node.lazy = val\\n            return \\n        \\n        m = (node.lo+node.hi)//2\\n        # push lazy to children, if no children, create them on the fly\\n        if not node.left and not node.right:\\n            if node.lazy!=None:\\n                node.left = Node(node.lo, m, node.lazy*(m-node.lo+1), None, node.lazy)\\n                node.right = Node(m+1, node.hi, node.lazy*(node.hi-m), None, node.lazy)\\n            else:\\n                node.left = Node(node.lo, m)\\n                node.right = Node(m+1, node.hi)\\n        elif node.lazy!=None:\\n            node.left.sm = node.lazy*(m-node.lo+1)\\n            node.left.lazy = node.lazy\\n            node.right.sm = node.lazy*(node.hi-m)\\n            node.right.lazy = node.lazy\\n        # reset lazy tag\\n        node.lazy = None\\n        # update the children\\n        if m>=hi:\\n            self.rangeSetSum(node.left, val, lo, hi)\\n        elif m<lo:\\n            self.rangeSetSum(node.right, val, lo, hi)\\n        else:\\n            self.rangeSetSum(node.left, val, lo, m)\\n            self.rangeSetSum(node.right, val, m+1, hi)\\n        # update the node\\n        node.sm = node.left.sm+node.right.sm\\n        return\\n\\n    def rangeSetSumQuery(self, node, lo, hi):\\n        if not node: return 0\\n        if node.lo==lo and node.hi==hi: return node.sm\\n        m = (node.lo+node.hi)//2\\n        if node.lazy!=None: return node.lazy*(hi-lo+1)\\n        if hi<=m: return self.rangeSetSumQuery(node.left, lo, hi)\\n        elif lo>m: return self.rangeSetSumQuery(node.right, lo, hi)\\n        else: return self.rangeSetSumQuery(node.left, lo, m)+self.rangeSetSumQuery(node.right, m+1, hi)\\n\\n    \"\"\"\\n    range set max: 699\\n    \"\"\"\\n    def rangeSetMax(self, node, val, lo, hi):\\n        if node.lo==lo and node.hi==hi:\\n            node.mx = val\\n            node.lazy = val\\n            return \\n        \\n        m = (node.lo+node.hi)//2\\n        # push lazy to children, if no children, create them on the fly\\n        if not node.left and not node.right:\\n            node.left = Node(node.lo, m, None, 0, node.lazy)\\n            node.right = Node(m+1, node.hi, None, 0, node.lazy)\\n        elif node.lazy!=None:\\n            node.left.mx = node.lazy\\n            node.left.lazy = node.lazy\\n            node.right.mx = node.lazy\\n            node.right.lazy = node.lazy\\n        # reset lazy tag\\n        node.lazy = None\\n        # update the children\\n        if m>=hi: self.rangeSetMax(node.left, val, lo, hi)\\n        elif m<lo: self.rangeSetMax(node.right, val, lo, hi)\\n        else:\\n            self.rangeSetMax(node.left, val, lo, m)\\n            self.rangeSetMax(node.right, val, m+1, hi)\\n        # update the node\\n        node.mx = max(node.left.mx, node.right.mx, node.mx)\\n        return\\n\\n    def rangeSetMaxQuery(self, node, lo, hi):\\n        if not node: return 0\\n        if node.lo==lo and node.hi==hi: return node.mx\\n        m = (node.lo+node.hi)//2\\n        if node.lazy!=None: return node.lazy\\n        if hi<=m: return self.rangeSetMaxQuery(node.left, lo, hi)\\n        elif lo>m: return self.rangeSetMaxQuery(node.right, lo, hi)\\n        else: return max(self.rangeSetMaxQuery(node.left, lo, m), self.rangeSetMaxQuery(node.right, m+1, hi))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263905,
                "title": "prefix-sum-treeset",
                "content": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int n = s.length();\\n        int m = queries.length;\\n        int[] pre = new int[n];\\n        TreeSet<Integer> candles = new TreeSet<>();\\n        List<Integer> res = new ArrayList<>();\\n        \\n        if (s.charAt(0) == \\'*\\') {\\n            pre[0] = 1;\\n        } else {\\n            pre[0] = 0;\\n            candles.add(0);\\n        }\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (s.charAt(i) == \\'*\\') {\\n                pre[i] = pre[i-1] + 1;\\n            } else {\\n                pre[i] = pre[i-1];\\n                candles.add(i);\\n            }\\n        }\\n        \\n        for (int[] q : queries) {\\n            Integer end = candles.floor(q[1]);\\n            Integer start = candles.ceiling(q[0]);\\n            if (start == null || end == null) {\\n                res.add(0);\\n                continue;\\n            }\\n            int cnt = pre[end] - pre[start];\\n            int tmp = cnt < 0 ? 0 : cnt;\\n            res.add(tmp);\\n        }\\n        int[] ans = new int[m];\\n        for (int i = 0; i < m; i++) ans[i] = res.get(i);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int n = s.length();\\n        int m = queries.length;\\n        int[] pre = new int[n];\\n        TreeSet<Integer> candles = new TreeSet<>();\\n        List<Integer> res = new ArrayList<>();\\n        \\n        if (s.charAt(0) == \\'*\\') {\\n            pre[0] = 1;\\n        } else {\\n            pre[0] = 0;\\n            candles.add(0);\\n        }\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (s.charAt(i) == \\'*\\') {\\n                pre[i] = pre[i-1] + 1;\\n            } else {\\n                pre[i] = pre[i-1];\\n                candles.add(i);\\n            }\\n        }\\n        \\n        for (int[] q : queries) {\\n            Integer end = candles.floor(q[1]);\\n            Integer start = candles.ceiling(q[0]);\\n            if (start == null || end == null) {\\n                res.add(0);\\n                continue;\\n            }\\n            int cnt = pre[end] - pre[start];\\n            int tmp = cnt < 0 ? 0 : cnt;\\n            res.add(tmp);\\n        }\\n        int[] ans = new int[m];\\n        for (int i = 0; i < m; i++) ans[i] = res.get(i);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214774,
                "title": "binary-search-memory-efficient-solution-easy-to-understand",
                "content": "**Upvote if Found Helpful**\\n\\n##### INTUTION\\n\\nstore the INDEX of all the candles in a vector ( SORTED )\\n\\nuse upper bound function to get the FIRST and LAST candle location in the given query range\\n\\nstore the answers in a vector and return.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) \\n    {\\n        vector<int> vec;\\n        vector<int> ans;\\n        \\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i] == \\'|\\')\\n                vec.push_back(i);\\n        }\\n        \\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            int a = queries[i][0];\\n            int b = queries[i][1];\\n            \\n            int lb = (upper_bound(vec.begin(), vec.end(), a)-vec.begin())-1;\\n            \\n            if(lb==-1)\\n                lb++;\\n            \\n            else if(vec[lb] < a)\\n                lb++;\\n            \\n            int ub = (upper_bound(vec.begin(), vec.end(), b)-vec.begin())-1;\\n            \\n            if(ub>lb)\\n            ans.push_back((vec[ub]-vec[lb]+1)-(ub-lb+1));\\n            else\\n                ans.push_back(0);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nHOPE IT HELPS!!!",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) \\n    {\\n        vector<int> vec;\\n        vector<int> ans;\\n        \\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i] == \\'|\\')\\n                vec.push_back(i);\\n        }\\n        \\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            int a = queries[i][0];\\n            int b = queries[i][1];\\n            \\n            int lb = (upper_bound(vec.begin(), vec.end(), a)-vec.begin())-1;\\n            \\n            if(lb==-1)\\n                lb++;\\n            \\n            else if(vec[lb] < a)\\n                lb++;\\n            \\n            int ub = (upper_bound(vec.begin(), vec.end(), b)-vec.begin())-1;\\n            \\n            if(ub>lb)\\n            ans.push_back((vec[ub]-vec[lb]+1)-(ub-lb+1));\\n            else\\n                ans.push_back(0);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187527,
                "title": "c-acha-que-hai-try-kiye-bina-sol-mt-dkhna-lower-bound",
                "content": "![image](https://assets.leetcode.com/users/images/045921b2-c752-452d-9f6b-90a7c448df5e_1655990476.1437244.png)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> platesBetweenCandles(string s, vector<vector<int>>& q) {\\n\\t\\t\\tvector<int>v;\\n\\t\\t\\tfor(int i=0;i<s.size();i++){\\n\\t\\t\\t\\tif(s[i]==\\'|\\')v.push_back(i);\\n\\t\\t\\t}\\n\\t\\t\\tvector<int>ans(q.size(),0);\\n\\t\\t\\tfor(int i=0;i<q.size();i++){\\n\\t\\t\\t\\tvector<int>:: iterator x=lower_bound(v.begin(),v.end(),q[i][0]);\\n\\t\\t\\t\\tvector<int>:: iterator y=lower_bound(v.begin(),v.end(),q[i][1]);\\n\\t\\t\\t\\tif(v.size()==0)break; \\n\\t\\t\\t\\tif(y==v.end())y--;\\n\\t\\t\\t\\telse if(*y!=q[i][1])y--;\\n\\t\\t\\t\\tif(x==v.end()|| x>=y)continue;    \\n\\t\\t\\t\\tans[i]=(*y-*x-1-(y-x-1));\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> platesBetweenCandles(string s, vector<vector<int>>& q) {\\n\\t\\t\\tvector<int>v;\\n\\t\\t\\tfor(int i=0;i<s.size();i++){\\n\\t\\t\\t\\tif(s[i]==\\'|\\')v.push_back(i);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2180318,
                "title": "java-naive-binary-search-and-prefix-sum-solutions",
                "content": "```\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\n/**\\n * There is a long table with a line of plates and candles arranged on top of\\n * it. You are given a 0-indexed string s consisting of characters \\'*\\' and \\'|\\'\\n * only, where a \\'*\\' represents a plate and a \\'|\\' represents a candle.\\n * You are also given a 0-indexed 2D integer array queries where queries[i] =\\n * [lefti, righti] denotes the substring s[lefti...righti] (inclusive). For each\\n * query, you need to find the number of plates between candles that are in the\\n * substring. A plate is considered between candles if there is at least one\\n * candle to its left and at least one candle to its right in the substring.\\n * For example, s = \"||**||**|*\", and a query [3, 8] denotes the substring\\n * \"*||**|\". The number of plates between candles in this substring is 2, as\\n * each of the two plates has at least one candle in the substring to its left\\n * and right.\\n * Return an integer array answer where answer[i] is the answer to the ith\\n * query.\\n */\\npublic class PlatesBetweenCandles {\\n\\n    // T = O(s + n) | S = O(s + n)\\n    // where s is the size of the string and n is the sizeof the array.\\n    public static int[] prefixSumSolution(String s, int[][] queries) {\\n        int firstPipeIndex = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'|\\') {\\n                firstPipeIndex = i;\\n                break;\\n            }\\n        }\\n\\n        int[] leftPlates = new int[s.length()];\\n\\n        int platesCount = 0;\\n        for (int i = firstPipeIndex + 1; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'*\\') {\\n                ++platesCount;\\n            } else {\\n                leftPlates[i] = platesCount;\\n                for (int j = i - 1; s.charAt(j) != \\'|\\'; --j) {\\n                    leftPlates[j] = platesCount;\\n                }\\n            }\\n        }\\n\\n        for (int j = s.length() - 1; j >= 0 && s.charAt(j) != \\'|\\'; --j) {\\n            leftPlates[j] = platesCount;\\n        }\\n\\n        int[] rightPlates = new int[s.length()];\\n\\n        platesCount = 0;\\n        int currentPlatesCount = 0;\\n        for (int i = firstPipeIndex + 1; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'*\\') {\\n                ++currentPlatesCount;\\n            } else {\\n                platesCount += currentPlatesCount;\\n                currentPlatesCount = 0;\\n            }\\n\\n            rightPlates[i] = platesCount;\\n        }\\n\\n        int[] result = new int[queries.length];\\n        for (int i = 0; i < queries.length; ++i) {\\n            result[i] = Math.max(0, rightPlates[queries[i][1]] - leftPlates[queries[i][0]]);\\n        }\\n\\n        return result;\\n    }\\n\\n    // T = O(s + nlog(s)) | S = O(s + n)\\n    // where s is the size of the string and n is the sizeof the array.\\n    // Uses binary search.\\n    public static int[] binarySearchSolution(String s, int[][] queries) {\\n        List<Integer> pipeLocations = new ArrayList<>();\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'|\\') {\\n                pipeLocations.add(i);\\n            }\\n        }\\n\\n        int[] result = new int[queries.length];\\n        for (int i = 0; i < queries.length; ++i) {\\n            int left = binarySearch(pipeLocations, queries[i][0]);\\n            int right = binarySearch(pipeLocations, queries[i][1]);\\n            if (right >= pipeLocations.size() || pipeLocations.get(right) > queries[i][1]) {\\n                --right;\\n            }\\n\\n            if (left > right) {\\n                result[i] = 0;\\n            } else {\\n                result[i] = (pipeLocations.get(right) - pipeLocations.get(left) + 1) - (right - left + 1);\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private static int binarySearch(List<Integer> array, int target) {\\n        int left = 0, right = array.size();\\n        while (left < right) {\\n            int middle = (left + right) / 2;\\n            if (array.get(middle) >= target) {\\n                right = middle;\\n            } else {\\n                left = middle + 1;\\n            }\\n        }\\n\\n        return left;\\n    }\\n\\n    // T = O(s*n) | S = O(n)\\n    // where s is the size of the string and n is the sizeof the array.\\n    public static int[] naiveSolution(String s, int[][] queries) {\\n        int[] result = new int[queries.length];\\n        for (int i = 0; i < queries.length; ++i) {\\n            int[] query = queries[i];\\n\\n            int left = query[0];\\n            while (s.charAt(left) == \\'*\\' && left < s.length()) {\\n                ++left;\\n            }\\n\\n            int right = query[1];\\n            while (s.charAt(right) == \\'*\\' && right >= 0) {\\n                --right;\\n            }\\n\\n            int count = 0;\\n            while (left <= right) {\\n                if (s.charAt(left) == \\'*\\') {\\n                    ++count;\\n                }\\n                ++left;\\n            }\\n\\n            result[i] = count;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\n/**\\n * There is a long table with a line of plates and candles arranged on top of\\n * it. You are given a 0-indexed string s consisting of characters \\'*\\' and \\'|\\'\\n * only, where a \\'*\\' represents a plate and a \\'|\\' represents a candle.\\n * You are also given a 0-indexed 2D integer array queries where queries[i] =\\n * [lefti, righti] denotes the substring s[lefti...righti] (inclusive). For each\\n * query, you need to find the number of plates between candles that are in the\\n * substring. A plate is considered between candles if there is at least one\\n * candle to its left and at least one candle to its right in the substring.\\n * For example, s = \"||**||**|*\", and a query [3, 8] denotes the substring\\n * \"*||**|\". The number of plates between candles in this substring is 2, as\\n * each of the two plates has at least one candle in the substring to its left\\n * and right.\\n * Return an integer array answer where answer[i] is the answer to the ith\\n * query.\\n */\\npublic class PlatesBetweenCandles {\\n\\n    // T = O(s + n) | S = O(s + n)\\n    // where s is the size of the string and n is the sizeof the array.\\n    public static int[] prefixSumSolution(String s, int[][] queries) {\\n        int firstPipeIndex = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'|\\') {\\n                firstPipeIndex = i;\\n                break;\\n            }\\n        }\\n\\n        int[] leftPlates = new int[s.length()];\\n\\n        int platesCount = 0;\\n        for (int i = firstPipeIndex + 1; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'*\\') {\\n                ++platesCount;\\n            } else {\\n                leftPlates[i] = platesCount;\\n                for (int j = i - 1; s.charAt(j) != \\'|\\'; --j) {\\n                    leftPlates[j] = platesCount;\\n                }\\n            }\\n        }\\n\\n        for (int j = s.length() - 1; j >= 0 && s.charAt(j) != \\'|\\'; --j) {\\n            leftPlates[j] = platesCount;\\n        }\\n\\n        int[] rightPlates = new int[s.length()];\\n\\n        platesCount = 0;\\n        int currentPlatesCount = 0;\\n        for (int i = firstPipeIndex + 1; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'*\\') {\\n                ++currentPlatesCount;\\n            } else {\\n                platesCount += currentPlatesCount;\\n                currentPlatesCount = 0;\\n            }\\n\\n            rightPlates[i] = platesCount;\\n        }\\n\\n        int[] result = new int[queries.length];\\n        for (int i = 0; i < queries.length; ++i) {\\n            result[i] = Math.max(0, rightPlates[queries[i][1]] - leftPlates[queries[i][0]]);\\n        }\\n\\n        return result;\\n    }\\n\\n    // T = O(s + nlog(s)) | S = O(s + n)\\n    // where s is the size of the string and n is the sizeof the array.\\n    // Uses binary search.\\n    public static int[] binarySearchSolution(String s, int[][] queries) {\\n        List<Integer> pipeLocations = new ArrayList<>();\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'|\\') {\\n                pipeLocations.add(i);\\n            }\\n        }\\n\\n        int[] result = new int[queries.length];\\n        for (int i = 0; i < queries.length; ++i) {\\n            int left = binarySearch(pipeLocations, queries[i][0]);\\n            int right = binarySearch(pipeLocations, queries[i][1]);\\n            if (right >= pipeLocations.size() || pipeLocations.get(right) > queries[i][1]) {\\n                --right;\\n            }\\n\\n            if (left > right) {\\n                result[i] = 0;\\n            } else {\\n                result[i] = (pipeLocations.get(right) - pipeLocations.get(left) + 1) - (right - left + 1);\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private static int binarySearch(List<Integer> array, int target) {\\n        int left = 0, right = array.size();\\n        while (left < right) {\\n            int middle = (left + right) / 2;\\n            if (array.get(middle) >= target) {\\n                right = middle;\\n            } else {\\n                left = middle + 1;\\n            }\\n        }\\n\\n        return left;\\n    }\\n\\n    // T = O(s*n) | S = O(n)\\n    // where s is the size of the string and n is the sizeof the array.\\n    public static int[] naiveSolution(String s, int[][] queries) {\\n        int[] result = new int[queries.length];\\n        for (int i = 0; i < queries.length; ++i) {\\n            int[] query = queries[i];\\n\\n            int left = query[0];\\n            while (s.charAt(left) == \\'*\\' && left < s.length()) {\\n                ++left;\\n            }\\n\\n            int right = query[1];\\n            while (s.charAt(right) == \\'*\\' && right >= 0) {\\n                --right;\\n            }\\n\\n            int count = 0;\\n            while (left <= right) {\\n                if (s.charAt(left) == \\'*\\') {\\n                    ++count;\\n                }\\n                ++left;\\n            }\\n\\n            result[i] = count;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147122,
                "title": "simplified-program",
                "content": "My code will run perfectly within time on diffrent IDE such as pycharm, But Leetcode throws an \\'TLE\\' error.\\n\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        res=[]\\n        for i in queries:\\n            temp_arr = s[i[0]:i[1]+1]\\n            sum=0\\n            j=0\\n            while j < len(temp_arr)-1:\\n                if temp_arr[j] == \"|\" and temp_arr[j + 1] != \"|\":\\n                    k=j+1\\n                    if \\'|\\' in temp_arr[k:]:\\n                        idx=temp_arr[k:].index(\\'|\\')\\n                        end = k+idx\\n                        sum += temp_arr[k:end].count(\\'*\\')\\n                        j=end-1\\n                j+=1\\n            res.append(sum)\\n        return res\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "My code will run perfectly within time on diffrent IDE such as pycharm, But Leetcode throws an \\'TLE\\' error.\\n\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        res=[]\\n        for i in queries:\\n            temp_arr = s[i[0]:i[1]+1]\\n            sum=0\\n            j=0\\n            while j < len(temp_arr)-1:\\n                if temp_arr[j] == \"|\" and temp_arr[j + 1] != \"|\":\\n                    k=j+1\\n                    if \\'|\\' in temp_arr[k:]:\\n                        idx=temp_arr[k:].index(\\'|\\')\\n                        end = k+idx\\n                        sum += temp_arr[k:end].count(\\'*\\')\\n                        j=end-1\\n                j+=1\\n            res.append(sum)\\n        return res\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2146470,
                "title": "90-prefix-sum",
                "content": "```python\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        res = []\\n        N = len(s)\\n\\n        prefixSum = [0] * N  # prefix sum for candles (it is also a mapping from i-th index)\\n        barrier = {}  # a (inverse) mapping from i-th candle to index\\n        iBarrier = 0\\n        for i in range(N):\\n            if i == 0:\\n                prefixSum[i] = (1 if s[i] == \"|\" else 0)\\n                if s[i] == \"|\":\\n                    barrier[iBarrier] = i\\n                    iBarrier += 1\\n            else:\\n                prefixSum[i] = prefixSum[i - 1] + (1 if s[i] == \"|\" else 0)\\n                if s[i] == \"|\":\\n                    barrier[iBarrier] = i\\n                    iBarrier += 1\\n        for query in queries:\\n            # find left candle & right candle\\n            if prefixSum[query[0]] == prefixSum[query[1]]:  # if there is no candle between [query[0], query[1]], skip\\n                res.append(0)\\n                continue\\n            if s[query[0]] == \"|\":  # if left is barrier, return it. Or find barrier[prefixSum[query[0]]]\\n                left = query[0]\\n            else:\\n                left = barrier[prefixSum[query[0]]]\\n            if s[query[1]] == \"|\":  # if right is barrier, return it. Or find barrier[prefixSum[query[1]-1]]\\n                right = query[1]\\n            else:\\n                if prefixSum[query[1]] - 1 < 0:\\n                    res.append(0)\\n                    continue\\n                right = barrier[prefixSum[query[1]] - 1]\\n            res.append(right - left - (prefixSum[right] - prefixSum[left]))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        res = []\\n        N = len(s)\\n\\n        prefixSum = [0] * N  # prefix sum for candles (it is also a mapping from i-th index)\\n        barrier = {}  # a (inverse) mapping from i-th candle to index\\n        iBarrier = 0\\n        for i in range(N):\\n            if i == 0:\\n                prefixSum[i] = (1 if s[i] == \"|\" else 0)\\n                if s[i] == \"|\":\\n                    barrier[iBarrier] = i\\n                    iBarrier += 1\\n            else:\\n                prefixSum[i] = prefixSum[i - 1] + (1 if s[i] == \"|\" else 0)\\n                if s[i] == \"|\":\\n                    barrier[iBarrier] = i\\n                    iBarrier += 1\\n        for query in queries:\\n            # find left candle & right candle\\n            if prefixSum[query[0]] == prefixSum[query[1]]:  # if there is no candle between [query[0], query[1]], skip\\n                res.append(0)\\n                continue\\n            if s[query[0]] == \"|\":  # if left is barrier, return it. Or find barrier[prefixSum[query[0]]]\\n                left = query[0]\\n            else:\\n                left = barrier[prefixSum[query[0]]]\\n            if s[query[1]] == \"|\":  # if right is barrier, return it. Or find barrier[prefixSum[query[1]-1]]\\n                right = query[1]\\n            else:\\n                if prefixSum[query[1]] - 1 < 0:\\n                    res.append(0)\\n                    continue\\n                right = barrier[prefixSum[query[1]] - 1]\\n            res.append(right - left - (prefixSum[right] - prefixSum[left]))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131104,
                "title": "easy-c-code",
                "content": "class Solution\\n{\\npublic:\\n\\n    int fun(int l, int r, vector<pair<int, int>> &pre, string &s)   // to calculate the no of candle\\'s btw the given range\\n    {\\n        return pre[r].first - pre[l].first + (s[l] == \\'|\\' ? 1 : 0);\\n    }\\n\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>> &queries)\\n    {\\n\\t\\t\\t/*\\n\\t\\t\\t\\tat index i pre[i] ex {x,y}   x => no of candles from index 0\\n\\t\\t\\t\\t\\t\\t\\ty => no of plates btw the candles(if given condition holds) from index 0\\n\\t\\t\\t\\t\\tex  \\n\\t\\t\\t\\t\\tstr is = >  *|**|*|**\\n\\t\\t\\t\\t\\tfor index i = 5  pre[5] =  {2, 2};\\n\\t\\t\\t\\t\\tas there are 2 candles from indx 0 but only two plates are there btw the plates\\n\\t\\t\\t*/\\n        vector<pair<int, int>> pre(s.size(), {0, 0});   \\n        vector<int> ans, p;\\n\\n        int x = 0;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (s[i] == \\'|\\')   //to store the index of candles\\n                p.push_back(i);\\n\\n            if (s[i] == \\'*\\')\\n            {\\n                x++; \\n                if (i != 0)\\n                    pre[i] = pre[i - 1];\\n            }\\n            else if (s[i] == \\'|\\' and i == 0)\\n                pre[i] = {1, 0};\\n            \\n            else if (s[i] == \\'|\\')\\n            {\\n                if (pre[i - 1].first >= 1)\\n                    pre[i].second = pre[i - 1].second + x;\\n\\n                else\\n                    pre[i].second = 0;\\n\\n                pre[i].first = pre[i - 1].first + 1;\\n                x = 0;\\n            }\\n        }\\n\\n        for (auto &v : queries)\\n        {\\n            int l = v[0], r = v[1];\\n            if (fun(l, r, pre, s) >= 2)  \\n            {\\n                l = *lower_bound(p.begin(), p.end(), l);   // to find the position of candle\\n                ans.push_back(pre[r].second - pre[l].second);\\n            }\\n            else\\n                ans.push_back(0);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "class Solution\\n{\\npublic:\\n\\n    int fun(int l, int r, vector<pair<int, int>> &pre, string &s)   // to calculate the no of candle\\'s btw the given range\\n    {\\n        return pre[r].first - pre[l].first + (s[l] == \\'|\\' ? 1 : 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2071638,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int[] arr = new int[s.length()];\\n        int tp=0;\\n        int[] left =new int[s.length()];\\n        int[] right = new int[s.length()];\\n        int ind=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'*\\') tp++;\\n            if(s.charAt(i)==\\'|\\') ind=i;\\n            arr[i]=tp;\\n            left[i]=ind;\\n        }\\n        int t=0;\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(s.charAt(i)==\\'|\\') t=i;\\n            right[i]=t;\\n        }\\n        int[] res = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            int st = queries[i][0], ed = queries[i][1];\\n            if(st==ed) continue;\\n            if(right[st]<left[ed]) res[i]=arr[left[ed]]-arr[right[st]];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int[] arr = new int[s.length()];\\n        int tp=0;\\n        int[] left =new int[s.length()];\\n        int[] right = new int[s.length()];\\n        int ind=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'*\\') tp++;\\n            if(s.charAt(i)==\\'|\\') ind=i;\\n            arr[i]=tp;\\n            left[i]=ind;\\n        }\\n        int t=0;\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(s.charAt(i)==\\'|\\') t=i;\\n            right[i]=t;\\n        }\\n        int[] res = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            int st = queries[i][0], ed = queries[i][1];\\n            if(st==ed) continue;\\n            if(right[st]<left[ed]) res[i]=arr[left[ed]]-arr[right[st]];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036467,
                "title": "simple-o-n-solution",
                "content": "Suppose query is q[l, r]\\n\\n1. get the count of plates between candels => prefix sum `O(n)`\\n2.  find out what is next nearest  \\'|\\' position from l towards right => left `O(n)`\\n4.  just return Math.max(0, count[r] - count[left]) `O(1)`\\n```\\nclass Solution {\\n  int [] getCount(String s) {\\n    int n = s.length();\\n    int plates = 0;\\n    int candels = 0;\\n    int [] count = new int[n];\\n    for(int idx=0; idx < n; ++idx) {\\n      if(s.charAt(idx) == \\'|\\') ++candels;\\n      else if(candels > 0) ++plates;\\n      \\n      if(idx > 0) count[idx] = count[idx-1];\\n      \\n      if(candels == 2) {\\n        candels -= 1;\\n        count[idx] += plates;\\n        plates = 0;\\n      }\\n    }\\n    return count;\\n  }\\n\\n  public int[] platesBetweenCandles(String s, int[][] queries) {\\n    int n = s.length();\\n    int [] out = new int[queries.length];\\n    int [] count = getCount(s);\\n    int [] next = new int[count.length];\\n    \\n    next[n-1] = n-1;\\n    for(int idx=n-2; idx >= 0; --idx) {\\n      if(s.charAt(idx) == \\'|\\') next[idx] = idx;\\n      else next[idx] = next[idx+1];\\n    }\\n    \\n    int pos = 0;\\n    for(int [] q : queries) {\\n      int left = next[q[0]];\\n      out[pos++] = Math.max(0, count[q[1]]-count[left]);\\n    }\\n\\n    return out;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  int [] getCount(String s) {\\n    int n = s.length();\\n    int plates = 0;\\n    int candels = 0;\\n    int [] count = new int[n];\\n    for(int idx=0; idx < n; ++idx) {\\n      if(s.charAt(idx) == \\'|\\') ++candels;\\n      else if(candels > 0) ++plates;\\n      \\n      if(idx > 0) count[idx] = count[idx-1];\\n      \\n      if(candels == 2) {\\n        candels -= 1;\\n        count[idx] += plates;\\n        plates = 0;\\n      }\\n    }\\n    return count;\\n  }\\n\\n  public int[] platesBetweenCandles(String s, int[][] queries) {\\n    int n = s.length();\\n    int [] out = new int[queries.length];\\n    int [] count = getCount(s);\\n    int [] next = new int[count.length];\\n    \\n    next[n-1] = n-1;\\n    for(int idx=n-2; idx >= 0; --idx) {\\n      if(s.charAt(idx) == \\'|\\') next[idx] = idx;\\n      else next[idx] = next[idx+1];\\n    }\\n    \\n    int pos = 0;\\n    for(int [] q : queries) {\\n      int left = next[q[0]];\\n      out[pos++] = Math.max(0, count[q[1]]-count[left]);\\n    }\\n\\n    return out;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026078,
                "title": "easy-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        vector<int> ans(queries.size(), 0), pxsm, left(n,0), right(n,0);\\n        int sidx, eidx, prxsm = 0;\\n        for(int j = 0; j < n; j++)\\n        {\\n            if(s[j] == \\'*\\')\\n                prxsm += 1;\\n            pxsm.push_back(prxsm);\\n        }\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(s[i] == \\'|\\')\\n                left[i] = i;\\n            else\\n                left[i] = left[i-1];\\n        }\\n        if(s[n-1] == \\'|\\')\\n            right[n-1] = n-1;\\n        for(int i = n-2; i >= 0; i--)\\n        {\\n            if(s[i] == \\'|\\')\\n                right[i] = i;\\n            else\\n                right[i] = right[i+1];\\n        }\\n        for(int i = 0; i < queries.size(); i++)\\n        {\\n            sidx = queries[i][0];\\n            eidx = queries[i][1];\\n            if(left[sidx] != left[eidx] || right[sidx] != right[eidx])\\n            {\\n                ans[i] = pxsm[left[eidx]] - pxsm[right[sidx]];\\n            }\\n        }\\n        return ans;\\n    }\\n}; \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        vector<int> ans(queries.size(), 0), pxsm, left(n,0), right(n,0);\\n        int sidx, eidx, prxsm = 0;\\n        for(int j = 0; j < n; j++)\\n        {\\n            if(s[j] == \\'*\\')\\n                prxsm += 1;\\n            pxsm.push_back(prxsm);\\n        }\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(s[i] == \\'|\\')\\n                left[i] = i;\\n            else\\n                left[i] = left[i-1];\\n        }\\n        if(s[n-1] == \\'|\\')\\n            right[n-1] = n-1;\\n        for(int i = n-2; i >= 0; i--)\\n        {\\n            if(s[i] == \\'|\\')\\n                right[i] = i;\\n            else\\n                right[i] = right[i+1];\\n        }\\n        for(int i = 0; i < queries.size(); i++)\\n        {\\n            sidx = queries[i][0];\\n            eidx = queries[i][1];\\n            if(left[sidx] != left[eidx] || right[sidx] != right[eidx])\\n            {\\n                ans[i] = pxsm[left[eidx]] - pxsm[right[sidx]];\\n            }\\n        }\\n        return ans;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999614,
                "title": "o-n-q-prefix-sum-with-commented-code",
                "content": "```\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        const int n = s.size();\\n        // store the first boundary bar found by going\\n        // right from the index. e.g. *|*|*, nextRightBar[0] -> 1\\n        auto nextRightBar = vector<int>(n);\\n\\n        // store the first boundary bar found by going\\n        // left from the index. e.g. *|*|*, nextLeftBar[4] -> 3\\n        auto nextLeftBar = vector<int>(n);\\n\\n        // store the count of total bars up to the index\\n        // e.g. *|*|*, barCountAtIndex[0] -> 0, barCountAtIndex[3] -> 2\\n        auto barCountAtIndex = vector<int>(n);\\n        auto res = vector<int>();\\n        res.reserve(n);\\n        \\n        // build nextLeftBar by going left to right, filling in the index of\\n        // the last seen bar from the left. Use this process to store bar counts\\n        // in barCountAtIndex by keeping bar count up to the current index\\n        //\\n        // build nextRightBar by going right to left, filling in the index of\\n        // the last seen bar from the right\\n        for (int i = 0, j = n - 1 - i; i < n; ++i, --j) {\\n            if (s[i] == \\'|\\') {\\n                nextLeftBar[i] = i;\\n                barCountAtIndex[i] = i == 0 ? 1 : barCountAtIndex[i - 1] + 1;\\n            } else {\\n                nextLeftBar[i] = i == 0 ? -1 : nextLeftBar[i - 1];\\n                barCountAtIndex[i] = i == 0 ? 0 : barCountAtIndex[i - 1];\\n            }\\n            \\n            if (s[j] == \\'|\\') nextRightBar[j] = j;\\n            else nextRightBar[j] = j == n - 1 ? -1 : nextRightBar[j + 1];\\n        }\\n        \\n        // process queries\\n        for (const auto& q : queries) {\\n            const int left = nextRightBar[q[0]];\\n            const int right = nextLeftBar[q[1]];\\n            // handle queries of a single char or of range w/o at least two boundaries\\n            if (left >= right || left == -1 || right == -1) res.push_back(0);\\n            else {\\n                // happy path is size from outer right boundary to outer left boundary\\n                // minus the inclusive bar count between the boundaries\\n                const int numOfBars = barCountAtIndex[right] - barCountAtIndex[left] + 1;\\n                res.push_back((right - left + 1) - numOfBars);   \\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        const int n = s.size();\\n        // store the first boundary bar found by going\\n        // right from the index. e.g. *|*|*, nextRightBar[0] -> 1\\n        auto nextRightBar = vector<int>(n);\\n\\n        // store the first boundary bar found by going\\n        // left from the index. e.g. *|*|*, nextLeftBar[4] -> 3\\n        auto nextLeftBar = vector<int>(n);\\n\\n        // store the count of total bars up to the index\\n        // e.g. *|*|*, barCountAtIndex[0] -> 0, barCountAtIndex[3] -> 2\\n        auto barCountAtIndex = vector<int>(n);\\n        auto res = vector<int>();\\n        res.reserve(n);\\n        \\n        // build nextLeftBar by going left to right, filling in the index of\\n        // the last seen bar from the left. Use this process to store bar counts\\n        // in barCountAtIndex by keeping bar count up to the current index\\n        //\\n        // build nextRightBar by going right to left, filling in the index of\\n        // the last seen bar from the right\\n        for (int i = 0, j = n - 1 - i; i < n; ++i, --j) {\\n            if (s[i] == \\'|\\') {\\n                nextLeftBar[i] = i;\\n                barCountAtIndex[i] = i == 0 ? 1 : barCountAtIndex[i - 1] + 1;\\n            } else {\\n                nextLeftBar[i] = i == 0 ? -1 : nextLeftBar[i - 1];\\n                barCountAtIndex[i] = i == 0 ? 0 : barCountAtIndex[i - 1];\\n            }\\n            \\n            if (s[j] == \\'|\\') nextRightBar[j] = j;\\n            else nextRightBar[j] = j == n - 1 ? -1 : nextRightBar[j + 1];\\n        }\\n        \\n        // process queries\\n        for (const auto& q : queries) {\\n            const int left = nextRightBar[q[0]];\\n            const int right = nextLeftBar[q[1]];\\n            // handle queries of a single char or of range w/o at least two boundaries\\n            if (left >= right || left == -1 || right == -1) res.push_back(0);\\n            else {\\n                // happy path is size from outer right boundary to outer left boundary\\n                // minus the inclusive bar count between the boundaries\\n                const int numOfBars = barCountAtIndex[right] - barCountAtIndex[left] + 1;\\n                res.push_back((right - left + 1) - numOfBars);   \\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1988980,
                "title": "kotlin-treemap",
                "content": "```\\nval m = TreeMap<Int, Int>()\\n    val result = mutableListOf<Int>()\\n    var plates = 0\\n    for (a in 0..s.indices.last) {\\n        if (s[a] == \\'|\\') m[a] = plates\\n        else plates++\\n    }\\n    for (query in queries) {\\n        if (m.isEmpty()\\n            || m.lastKey() < query[0]\\n            || m.firstKey() > query[1]\\n        ) result.add(0)\\n        else {\\n            val (_, leftValue) = m.ceilingEntry(query[0])\\n            val (_, rightValue) = m.floorEntry(query[1])\\n            result.add((rightValue - leftValue).coerceAtLeast(0))\\n        }\\n    }\\n    return result.toIntArray()\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Tree"
                ],
                "code": "```\\nval m = TreeMap<Int, Int>()\\n    val result = mutableListOf<Int>()\\n    var plates = 0\\n    for (a in 0..s.indices.last) {\\n        if (s[a] == \\'|\\') m[a] = plates\\n        else plates++\\n    }\\n    for (query in queries) {\\n        if (m.isEmpty()\\n            || m.lastKey() < query[0]\\n            || m.firstKey() > query[1]\\n        ) result.add(0)\\n        else {\\n            val (_, leftValue) = m.ceilingEntry(query[0])\\n            val (_, rightValue) = m.floorEntry(query[1])\\n            result.add((rightValue - leftValue).coerceAtLeast(0))\\n        }\\n    }\\n    return result.toIntArray()\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934381,
                "title": "ruby-solution-with-prefix-count",
                "content": "A Ruby solution that uses pre-calculated prefix counts.\\nIt\\'s written to be very explicit and readable. Some things are inefficient for the sake of clarity (e.g. duplicated loop left-to-right).\\n\\n```ruby\\ndef plates_between_candles(s, queries)\\n  n = s.length\\n\\n  # prepare data\\n  closest_left_candle = Array.new(n)\\n  closest_right_candle = Array.new(n)\\n  plates_on_left = Array.new(n)\\n\\n  c = -1 # candle position\\n  (0...n).each do |i|\\n    c = i if s[i] == \"|\"\\n    closest_left_candle[i] = c\\n  end\\n\\n  c = n + 1 # candle position\\n  (n - 1).downto(0).each do |i|\\n    c = i if s[i] == \"|\"\\n    closest_right_candle[i] = c\\n  end\\n\\n  p = 0 # plate count\\n  (0...n).each do |i|\\n    if s[i] == \"*\"\\n      p += 1\\n    else\\n      plates_on_left[i] = p\\n    end\\n  end\\n\\n  # puts \"closest_left_candle:  #{closest_left_candle}\"\\n  # puts \"closest_right_candle: #{closest_right_candle}\"\\n  # puts \"plates_on_left:       #{plates_on_left}\"\\n\\n  queries.map do |start, stop|\\n    a = closest_right_candle[start]\\n    b = closest_left_candle[stop]\\n\\n    # (-1) ***************|*****************************|**************** (n+1)\\n    #\\n    #            start    a                             b     stop                (valid)\\n    #\\n    #            start   a+b      stop\\n    #\\n    #                     b    start          stop      a\\n    #\\n    #   b   start  stop   a\\n    #\\n    #                                                   b    start  stop   a\\n    #\\n    if a == b || a > stop\\n      0\\n    else\\n      plates_on_left[b] - plates_on_left[a]\\n    end\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef plates_between_candles(s, queries)\\n  n = s.length\\n\\n  # prepare data\\n  closest_left_candle = Array.new(n)\\n  closest_right_candle = Array.new(n)\\n  plates_on_left = Array.new(n)\\n\\n  c = -1 # candle position\\n  (0...n).each do |i|\\n    c = i if s[i] == \"|\"\\n    closest_left_candle[i] = c\\n  end\\n\\n  c = n + 1 # candle position\\n  (n - 1).downto(0).each do |i|\\n    c = i if s[i] == \"|\"\\n    closest_right_candle[i] = c\\n  end\\n\\n  p = 0 # plate count\\n  (0...n).each do |i|\\n    if s[i] == \"*\"\\n      p += 1\\n    else\\n      plates_on_left[i] = p\\n    end\\n  end\\n\\n  # puts \"closest_left_candle:  #{closest_left_candle}\"\\n  # puts \"closest_right_candle: #{closest_right_candle}\"\\n  # puts \"plates_on_left:       #{plates_on_left}\"\\n\\n  queries.map do |start, stop|\\n    a = closest_right_candle[start]\\n    b = closest_left_candle[stop]\\n\\n    # (-1) ***************|*****************************|**************** (n+1)\\n    #\\n    #            start    a                             b     stop                (valid)\\n    #\\n    #            start   a+b      stop\\n    #\\n    #                     b    start          stop      a\\n    #\\n    #   b   start  stop   a\\n    #\\n    #                                                   b    start  stop   a\\n    #\\n    if a == b || a > stop\\n      0\\n    else\\n      plates_on_left[b] - plates_on_left[a]\\n    end\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1829228,
                "title": "c-straightforward-o-n-solution-without-binary-search",
                "content": "2 times loop from head to tale and from tale to head\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        vector<int> ans, plate1, plate2;\\n\\t\\t// the first loop will count how many plates from head to each location\\n\\t\\tint last=-1, sum=0;\\n        for(int i=0; i<s.length();i++){\\n            if(s[i]==\\'|\\' && last<0) last=i;\\n            else if(s[i]==\\'|\\' && last>=0) {sum+=i-last-1;last=i;}\\n            plate1.push_back(sum);\\n        }\\n\\t\\t// the second loop will count how many plates from tale to each location\\n        last=-1; sum=0;\\n        for(int i=s.length()-1; i>=0;i--){\\n            if(s[i]==\\'|\\' && last<0) last=i;\\n            else if(s[i]==\\'|\\' && last>=0) {sum+=last-i-1;last=i;}\\n            plate2.push_back(sum);\\n        }\\n        reverse(plate2.begin(),plate2.end());\\n\\t\\t\\n\\t\\t//Basic logic: answer = plates after query.first + plates before query.second - all plates\\n        for(auto query: queries){\\n            if(plate1[query[1]]==plate1[query[0]]) ans.push_back(0);\\n            else ans.push_back(plate1[query[1]]+plate2[query[0]]-plate1[s.length()-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        vector<int> ans, plate1, plate2;\\n\\t\\t// the first loop will count how many plates from head to each location\\n\\t\\tint last=-1, sum=0;\\n        for(int i=0; i<s.length();i++){\\n            if(s[i]==\\'|\\' && last<0) last=i;\\n            else if(s[i]==\\'|\\' && last>=0) {sum+=i-last-1;last=i;}\\n            plate1.push_back(sum);\\n        }\\n\\t\\t// the second loop will count how many plates from tale to each location\\n        last=-1; sum=0;\\n        for(int i=s.length()-1; i>=0;i--){\\n            if(s[i]==\\'|\\' && last<0) last=i;\\n            else if(s[i]==\\'|\\' && last>=0) {sum+=last-i-1;last=i;}\\n            plate2.push_back(sum);\\n        }\\n        reverse(plate2.begin(),plate2.end());\\n\\t\\t\\n\\t\\t//Basic logic: answer = plates after query.first + plates before query.second - all plates\\n        for(auto query: queries){\\n            if(plate1[query[1]]==plate1[query[0]]) ans.push_back(0);\\n            else ans.push_back(plate1[query[1]]+plate2[query[0]]-plate1[s.length()-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807755,
                "title": "binary-search-o-qlogn-and-tiktok-oa-stars-and-bars",
                "content": "Below Ans is for Original Questions\\nand TikTok has different input types so I also offer answer for TikTok question\\n\\nOringal Question\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        bars = [index for index in range(len(s)) if s[index] == \\'|\\']\\n        ans = []\\n        for query in queries:\\n            # find index >= query[0] in bars\\n            left = bisect.bisect_left(bars, query[0])\\n            # find index <= query[0] in bars\\n            right = bisect.bisect_right(bars, query[1]) - 1\\n            # if left > right, count how many plates between bars, else 0\\n            if left < right:\\n                ans.append(len(s[bars[left]: bars[right]+1]) - (right - left + 1))\\n            else:\\n                ans.append(0)\\n        return ans\\n```\\n\\n**TikTok question**\\n**Constrain**: index in startIndex and endIndex is start from 1 not 0\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, startIndex: List[int], endIndex: List[int]) -> List[int]:\\n        bars = [index for index in range(len(s)) if s[index] == \\'|\\']\\n        ans = []\\n        for index in range(len(startIndex)):\\n            # find index >= query[0] in bars\\n            left = bisect.bisect_left(bars, startIndex[index] -1)\\n            # find index <= query[0] in bars\\n            right = bisect.bisect_right(bars, endIndex[index] -1) - 1\\n            # if left > right, count how many plates between bars, else 0\\n            if left < right:\\n                ans.append(len(s[bars[left]: bars[right]+1]) - (right - left + 1))\\n            else:\\n                ans.append(0)\\n        return ans\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        bars = [index for index in range(len(s)) if s[index] == \\'|\\']\\n        ans = []\\n        for query in queries:\\n            # find index >= query[0] in bars\\n            left = bisect.bisect_left(bars, query[0])\\n            # find index <= query[0] in bars\\n            right = bisect.bisect_right(bars, query[1]) - 1\\n            # if left > right, count how many plates between bars, else 0\\n            if left < right:\\n                ans.append(len(s[bars[left]: bars[right]+1]) - (right - left + 1))\\n            else:\\n                ans.append(0)\\n        return ans\\n```\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, startIndex: List[int], endIndex: List[int]) -> List[int]:\\n        bars = [index for index in range(len(s)) if s[index] == \\'|\\']\\n        ans = []\\n        for index in range(len(startIndex)):\\n            # find index >= query[0] in bars\\n            left = bisect.bisect_left(bars, startIndex[index] -1)\\n            # find index <= query[0] in bars\\n            right = bisect.bisect_right(bars, endIndex[index] -1) - 1\\n            # if left > right, count how many plates between bars, else 0\\n            if left < right:\\n                ans.append(len(s[bars[left]: bars[right]+1]) - (right - left + 1))\\n            else:\\n                ans.append(0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636558,
                "title": "python-o-n-q-time-o-n-space-easy-commented-code",
                "content": "```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        \"\"\"\\n        Use of Prefix Sum Logic and\\n        Some additional memory to store closest plate to the\\n        left and right of given \\'index\\'\\n        \"\"\"\\n\\n        n = len(s)\\n        # finds next candle to Right of given Index\\n        nextCandle2R = [0]*n\\n        \\n        # finds next candle to Left of given Index\\n        nextCandle2L = [n]*n\\n        \\n        # prefix array storing cumulative plates upto given index i in string \\'s\\' at cumPlates[i+1]\\n        cumPlates = [0]*(n+1)\\n        \\n        candleL = -1\\n        count = 0\\n        for i in range(n):\\n            if s[i] == \\'*\\':\\n                count +=1\\n            cumPlates[i+1] = count\\n            if s[i] == \\'|\\':\\n                candleL = i\\n            nextCandle2L[i] = candleL\\n        \\n        candleR = n\\n        for i in range(n-1,-1,-1):\\n            if s[i] == \\'|\\':\\n                candleR = i\\n            nextCandle2R[i] = candleR\\n        \"\"\"\\n        print(\"total length of s: \",n)\\n        print(\"nextcandle 2 left of given index: \",nextCandle2L)\\n        print(\"nextcandle 2 right of given index: \",nextCandle2R)\\n        print(\"prefix array: \",cumPlates)\\n        \"\"\"\\n        ans = []\\n        \\n        for query in queries:\\n            start = query[0]\\n            end = query[1]\\n            #print(start,end)\\n\\t\\t\\t\\n\\t\\t\\t# find next closest plate to right of \\'start\\' in s\\n            next_plateR = nextCandle2R[start]\\n\\t\\t\\t# find next closest plate to left of \\'end\\' in s\\n            next_plateL = nextCandle2L[end]\\n            if next_plateL < next_plateR:\\n                ans.append(0)\\n            else:\\n                ans.append(cumPlates[next_plateL+1]-cumPlates[next_plateR+1])\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        \"\"\"\\n        Use of Prefix Sum Logic and\\n        Some additional memory to store closest plate to the\\n        left and right of given \\'index\\'\\n        \"\"\"\\n\\n        n = len(s)\\n        # finds next candle to Right of given Index\\n        nextCandle2R = [0]*n\\n        \\n        # finds next candle to Left of given Index\\n        nextCandle2L = [n]*n\\n        \\n        # prefix array storing cumulative plates upto given index i in string \\'s\\' at cumPlates[i+1]\\n        cumPlates = [0]*(n+1)\\n        \\n        candleL = -1\\n        count = 0\\n        for i in range(n):\\n            if s[i] == \\'*\\':\\n                count +=1\\n            cumPlates[i+1] = count\\n            if s[i] == \\'|\\':\\n                candleL = i\\n            nextCandle2L[i] = candleL\\n        \\n        candleR = n\\n        for i in range(n-1,-1,-1):\\n            if s[i] == \\'|\\':\\n                candleR = i\\n            nextCandle2R[i] = candleR\\n        \"\"\"\\n        print(\"total length of s: \",n)\\n        print(\"nextcandle 2 left of given index: \",nextCandle2L)\\n        print(\"nextcandle 2 right of given index: \",nextCandle2R)\\n        print(\"prefix array: \",cumPlates)\\n        \"\"\"\\n        ans = []\\n        \\n        for query in queries:\\n            start = query[0]\\n            end = query[1]\\n            #print(start,end)\\n\\t\\t\\t\\n\\t\\t\\t# find next closest plate to right of \\'start\\' in s\\n            next_plateR = nextCandle2R[start]\\n\\t\\t\\t# find next closest plate to left of \\'end\\' in s\\n            next_plateL = nextCandle2L[end]\\n            if next_plateL < next_plateR:\\n                ans.append(0)\\n            else:\\n                ans.append(cumPlates[next_plateL+1]-cumPlates[next_plateR+1])\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634520,
                "title": "c-prefix-sum-o-q-n-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n        vector<int> forward(n,-1),backward(n,-1);\\n        int prev=-1;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\'|\\')\\n                prev=i;\\n            forward[i]=prev;\\n        }\\n        prev=-1;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'|\\')\\n                prev=i;\\n            backward[i]=prev;\\n        }\\n        vector<int> presum={0};\\n        for(int i=1;i<n;i++){\\n            if(forward[i]==-1 or backward[i]==-1){\\n                presum.push_back(0);\\n                continue;\\n            }\\n            if(s[i]==\\'*\\')\\n                presum.push_back(presum.back()+1);\\n            else\\n                presum.push_back(presum.back());\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++){\\n            int l=queries[i][0];\\n            int r=queries[i][1];\\n            if(forward[l]==-1 || backward[r]==-1 || forward[l]>=backward[r])\\n                ans.push_back(0);\\n            else\\n                ans.push_back(presum[backward[r]]-presum[forward[l]]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n        vector<int> forward(n,-1),backward(n,-1);\\n        int prev=-1;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\'|\\')\\n                prev=i;\\n            forward[i]=prev;\\n        }\\n        prev=-1;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'|\\')\\n                prev=i;\\n            backward[i]=prev;\\n        }\\n        vector<int> presum={0};\\n        for(int i=1;i<n;i++){\\n            if(forward[i]==-1 or backward[i]==-1){\\n                presum.push_back(0);\\n                continue;\\n            }\\n            if(s[i]==\\'*\\')\\n                presum.push_back(presum.back()+1);\\n            else\\n                presum.push_back(presum.back());\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++){\\n            int l=queries[i][0];\\n            int r=queries[i][1];\\n            if(forward[l]==-1 || backward[r]==-1 || forward[l]>=backward[r])\\n                ans.push_back(0);\\n            else\\n                ans.push_back(presum[backward[r]]-presum[forward[l]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630811,
                "title": "c-solution",
                "content": "Binary Search\\n```\\npublic class Solution {\\n    public int[] PlatesBetweenCandles(string s, int[][] queries) {\\n        int[] r = new int[queries.Length];\\n        \\n        List<int> ci = new List<int>();\\n        for (int i = 0; i < s.Length; ++i) {\\n            if (s[i] == \\'|\\') ci.Add(i);\\n        }\\n        \\n        for (int i = 0; i < queries.Length; ++i) {\\n            int[] query = queries[i];\\n            int lm = LBinarySearch(ci, query[0]);\\n            int rm = RBinarySearch(ci, query[1]) - 1;\\n\\n            if (lm < rm) {\\n                r[i] = ci[rm] - ci[lm] - (rm - lm);\\n            } else {\\n                r[i] = 0;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n    \\n    public int LBinarySearch(List<int> ci, int lb) {\\n        int l = 0, r = ci.Count;\\n        \\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (ci[m] >= lb) {\\n                r = m;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n    \\n    public int RBinarySearch(List<int> ci, int rb) {\\n        int l = 0, r = ci.Count;\\n\\t\\t\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (ci[m] <= rb) {\\n                l = m + 1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n}\\n```\\n\\nCandle Count\\n```\\npublic class Solution {\\n    public int[] PlatesBetweenCandles(string s, int[][] queries) {\\n        int[] lc = new int[s.Length], rc = new int[s.Length], cc = new int[s.Length], res = new int[queries.Length];\\n        int c = -1;\\n        for (int i = 0; i < s.Length; ++i) {\\n            if (s[i] == \\'|\\') c = i;\\n            lc[i] = c;\\n        }\\n        \\n        c = -1;\\n        for (int i = s.Length - 1; i >= 0; --i) {\\n            if (s[i] == \\'|\\') c = i;\\n            rc[i] = c;\\n        }\\n        \\n        c = 0;\\n        for (int i = 0; i < s.Length; ++i) {\\n            if (s[i] == \\'|\\') c++;\\n            cc[i] = c;\\n        }\\n        \\n        for (int i = 0; i < queries.Length; ++i) {\\n            int[] q = queries[i];\\n            int l = rc[q[0]], r = lc[q[1]], d = 0;\\n            if (l == -1 || r == -1) {\\n                res[i] = 0;\\n            } else {\\n                d = r - l;\\n                if (d > 0) {\\n                    res[i] = (r - l + 1) - (cc[r] - cc[l] + 1);\\n                } else {\\n                    res[i] = 0;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] PlatesBetweenCandles(string s, int[][] queries) {\\n        int[] r = new int[queries.Length];\\n        \\n        List<int> ci = new List<int>();\\n        for (int i = 0; i < s.Length; ++i) {\\n            if (s[i] == \\'|\\') ci.Add(i);\\n        }\\n        \\n        for (int i = 0; i < queries.Length; ++i) {\\n            int[] query = queries[i];\\n            int lm = LBinarySearch(ci, query[0]);\\n            int rm = RBinarySearch(ci, query[1]) - 1;\\n\\n            if (lm < rm) {\\n                r[i] = ci[rm] - ci[lm] - (rm - lm);\\n            } else {\\n                r[i] = 0;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n    \\n    public int LBinarySearch(List<int> ci, int lb) {\\n        int l = 0, r = ci.Count;\\n        \\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (ci[m] >= lb) {\\n                r = m;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n    \\n    public int RBinarySearch(List<int> ci, int rb) {\\n        int l = 0, r = ci.Count;\\n\\t\\t\\n        while (l < r) {\\n            int m = l + (r - l) / 2;\\n            if (ci[m] <= rb) {\\n                l = m + 1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int[] PlatesBetweenCandles(string s, int[][] queries) {\\n        int[] lc = new int[s.Length], rc = new int[s.Length], cc = new int[s.Length], res = new int[queries.Length];\\n        int c = -1;\\n        for (int i = 0; i < s.Length; ++i) {\\n            if (s[i] == \\'|\\') c = i;\\n            lc[i] = c;\\n        }\\n        \\n        c = -1;\\n        for (int i = s.Length - 1; i >= 0; --i) {\\n            if (s[i] == \\'|\\') c = i;\\n            rc[i] = c;\\n        }\\n        \\n        c = 0;\\n        for (int i = 0; i < s.Length; ++i) {\\n            if (s[i] == \\'|\\') c++;\\n            cc[i] = c;\\n        }\\n        \\n        for (int i = 0; i < queries.Length; ++i) {\\n            int[] q = queries[i];\\n            int l = rc[q[0]], r = lc[q[1]], d = 0;\\n            if (l == -1 || r == -1) {\\n                res[i] = 0;\\n            } else {\\n                d = r - l;\\n                if (d > 0) {\\n                    res[i] = (r - l + 1) - (cc[r] - cc[l] + 1);\\n                } else {\\n                    res[i] = 0;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618681,
                "title": "swift-simple-solution",
                "content": "```\\nclass Solution {\\n    func platesBetweenCandles(_ s: String, _ queries: [[Int]]) -> [Int] {\\n\\n        var answer = [Int]()\\n        var arrayOfCandels = [Int]()\\n\\n        for (index, key) in s.enumerated() where key == \"|\" {\\n            arrayOfCandels.append(index)\\n        }\\n\\n        for each in queries {\\n            if let firstIndex = arrayOfCandels.firstIndex(where: { $0 >= each[0] && $0 < each[1] }),\\n               let lastIndex = arrayOfCandels.lastIndex(where: { $0 <= each[1] && $0 > each[0] }),\\n                firstIndex != lastIndex {\\n\\t\\t\\t\\tanswer.append(arrayOfCandels[lastIndex]-arrayOfCandels[firstIndex]-(lastIndex-firstIndex))\\n            } else {\\n                answer.append(0)\\n            }\\n        }\\n\\n        return answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func platesBetweenCandles(_ s: String, _ queries: [[Int]]) -> [Int] {\\n\\n        var answer = [Int]()\\n        var arrayOfCandels = [Int]()\\n\\n        for (index, key) in s.enumerated() where key == \"|\" {\\n            arrayOfCandels.append(index)\\n        }\\n\\n        for each in queries {\\n            if let firstIndex = arrayOfCandels.firstIndex(where: { $0 >= each[0] && $0 < each[1] }),\\n               let lastIndex = arrayOfCandels.lastIndex(where: { $0 <= each[1] && $0 > each[0] }),\\n                firstIndex != lastIndex {\\n\\t\\t\\t\\tanswer.append(arrayOfCandels[lastIndex]-arrayOfCandels[firstIndex]-(lastIndex-firstIndex))\\n            } else {\\n                answer.append(0)\\n            }\\n        }\\n\\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607036,
                "title": "quirky-and-simple-java-treeset-solution-that-doesn-t-tle",
                "content": "Time: O(nlogn + qlogn)\\nSpace: O(n)\\n\\n```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries)\\n    {\\n        BitSet plates = new BitSet(s.length());\\n        TreeSet<Integer> candles = new TreeSet<Integer>();\\n        int i;\\n        for (i = 0; i < s.length(); i++)\\n        {\\n            if (s.charAt(i) == \\'*\\')\\n            {\\n                plates.set(i);\\n            }\\n            else\\n            {\\n                candles.add(i);\\n            }\\n        }\\n        int [] output = new int [queries.length];\\n        int [] query, limits;\\n        Integer tmp;\\n        for (i = 0; i < queries.length; i++)\\n        {\\n            query = queries[i];\\n            limits = new int [2];\\n            if (s.charAt(query[0]) == \\'|\\')\\n            {\\n                limits[0] = query[0];\\n            }\\n            else\\n            {\\n                tmp = candles.higher(query[0]);\\n                if (tmp == null || tmp >= query[1])\\n                {\\n                    continue;\\n                }\\n                limits[0] = tmp;\\n            }\\n            if (s.charAt(query[1]) == \\'|\\')\\n            {\\n                limits[1] = query[1];\\n            }\\n            else\\n            {\\n                tmp = candles.lower(query[1]);\\n                if (tmp == null || tmp <= query[0])\\n                {\\n                    continue;\\n                }\\n                limits[1] = tmp;\\n            }\\n            output[i] = plates.get(limits[0], limits[1] + 1).cardinality();\\n        }\\n        return output;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries)\\n    {\\n        BitSet plates = new BitSet(s.length());\\n        TreeSet<Integer> candles = new TreeSet<Integer>();\\n        int i;\\n        for (i = 0; i < s.length(); i++)\\n        {\\n            if (s.charAt(i) == \\'*\\')\\n            {\\n                plates.set(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1605103,
                "title": "python3-easy-simple-to-understand-solution-good-example-o-n-q",
                "content": "**Algorithm : O(N + Q)**\\n\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n    # accumulated sum of \\'*\\'\\n\\t\\taccumulated = []               \\t\\t\\n        accumulated.append(int(s[0] == \\'|\\'))\\n        for char in s[1:]:                                    # ex.     \"*  *  |  *  *  |  *  *  *  | \" \\n            val = accumulated[-1] + (char == \\'*\\')             #         [1, 2, 2, 3, 4, 4, 5, 6, 7, 7]\\n            accumulated.append(val)\\n\\t\\t\\t\\n\\t# nearest \\'|\\' position from right (i)\\t\\n        near_i = [0] * len(s)               \\n\\t\\tk = 0                                    \\n        for i in range(len(s)):                               # ex.    \"*  *  |  *  *  |  *  *  *  |\" \\n            while s[i] == \\'|\\' and k <= i:                     #        [2, 2, 2, 5, 5, 5, 9, 9, 9, 9]\\n                near_i[k] = i                                 #            i >\\n                k += 1\\n\\t\\t\\t\\t\\n\\t# nearest \\'|\\' position from left (j)\\n        near_j = [0] * len(s)    \\t\\t    \\n        k = len(s) - 1\\n        for j in reversed(range(len(s))):                     # ex.    \"*  *  |  *  *  |  *  *  *  |\" \\n            while s[j] == \\'|\\' and k >= j:                     #        [0, 0, 2, 2, 2, 5, 5, 5, 5, 9]\\n                near_j[k] = j                                 #                            < j\\n                k -= 1\\n        \\n        result = []\\n        for i, j in queries:\\n\\t\\t\\tif abs(j - i) <= 1:             # base case: i+1 < j-1 because of the word \\'between\\'\\n                val = 0\\n            else:\\n                ni, nj = near_i[i], near_j[j]\\n                val = accumulated[nj] - accumulated[ni]\\n            cnt = max(0, val)               # base case: count >= 0 because no negative count exists\\n            result.append(cnt)\\n        \\n        return result\\n```\\n      \\n- Runtime: 2124 ms, faster than 45.61% of Python3 online submissions for Plates Between Candles.\\n- Memory Usage: 54.1 MB, less than 25.42% of Python3 online submissions for Plates Between Candles.\\n\\nUPVOTE IS LOVE",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n    # accumulated sum of \\'*\\'\\n\\t\\taccumulated = []               \\t\\t\\n        accumulated.append(int(s[0] == \\'|\\'))\\n        for char in s[1:]:                                    # ex.     \"*  *  |  *  *  |  *  *  *  | \" \\n            val = accumulated[-1] + (char == \\'*\\')             #         [1, 2, 2, 3, 4, 4, 5, 6, 7, 7]\\n            accumulated.append(val)\\n\\t\\t\\t\\n\\t# nearest \\'|\\' position from right (i)\\t\\n        near_i = [0] * len(s)               \\n\\t\\tk = 0                                    \\n        for i in range(len(s)):                               # ex.    \"*  *  |  *  *  |  *  *  *  |\" \\n            while s[i] == \\'|\\' and k <= i:                     #        [2, 2, 2, 5, 5, 5, 9, 9, 9, 9]\\n                near_i[k] = i                                 #            i >\\n                k += 1\\n\\t\\t\\t\\t\\n\\t# nearest \\'|\\' position from left (j)\\n        near_j = [0] * len(s)    \\t\\t    \\n        k = len(s) - 1\\n        for j in reversed(range(len(s))):                     # ex.    \"*  *  |  *  *  |  *  *  *  |\" \\n            while s[j] == \\'|\\' and k >= j:                     #        [0, 0, 2, 2, 2, 5, 5, 5, 5, 9]\\n                near_j[k] = j                                 #                            < j\\n                k -= 1\\n        \\n        result = []\\n        for i, j in queries:\\n\\t\\t\\tif abs(j - i) <= 1:             # base case: i+1 < j-1 because of the word \\'between\\'\\n                val = 0\\n            else:\\n                ni, nj = near_i[i], near_j[j]\\n                val = accumulated[nj] - accumulated[ni]\\n            cnt = max(0, val)               # base case: count >= 0 because no negative count exists\\n            result.append(cnt)\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570229,
                "title": "c-prefix-sum-binary-search-intuitive",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.size();       \\n        vector<int> barLocs, prefix(n+1, 0), res, revBarLocs; \\n\\n        for(int i=0; i<n ; i++){\\n            if(s[i] == \\'|\\') barLocs.push_back(i); \\n            prefix[i+1] = prefix[i] + (s[i] == \\'*\\'); \\n        }\\n        revBarLocs = barLocs; \\n        reverse(revBarLocs.begin(), revBarLocs.end()); \\n\\n        for(auto x:queries){\\n            auto left = lower_bound(barLocs.begin(), barLocs.end(), x[0]); \\n            auto right = lower_bound(revBarLocs.begin(), revBarLocs.end(), x[1], greater<int>());\\n            if(right == revBarLocs.end() || left == barLocs.end()) res.push_back(0); \\n            else res.push_back(max(prefix[*right+1]-prefix[*left], 0)); \\n        }\\n        return res ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.size();       \\n        vector<int> barLocs, prefix(n+1, 0), res, revBarLocs; \\n\\n        for(int i=0; i<n ; i++){\\n            if(s[i] == \\'|\\') barLocs.push_back(i); \\n            prefix[i+1] = prefix[i] + (s[i] == \\'*\\'); \\n        }\\n        revBarLocs = barLocs; \\n        reverse(revBarLocs.begin(), revBarLocs.end()); \\n\\n        for(auto x:queries){\\n            auto left = lower_bound(barLocs.begin(), barLocs.end(), x[0]); \\n            auto right = lower_bound(revBarLocs.begin(), revBarLocs.end(), x[1], greater<int>());\\n            if(right == revBarLocs.end() || left == barLocs.end()) res.push_back(0); \\n            else res.push_back(max(prefix[*right+1]-prefix[*left], 0)); \\n        }\\n        return res ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562435,
                "title": "binary-search-prefix-sum-javascript",
                "content": "1) Binary Search\\n\\t```\\n\\t/**\\n\\t * @param {string} s\\n\\t * @param {number[][]} queries\\n\\t * @return {number[]}\\n\\t */\\n\\tvar platesBetweenCandles = function (s, queries) {\\n\\t  const bars = [],\\n\\t\\tres = [];\\n\\n\\t  for (let i = 0; i < s.length; i++) {\\n\\t\\tif (s[i] === \"|\") {\\n\\t\\t  bars.push(i);\\n\\t\\t}\\n\\t  }\\n\\n\\t  for (let q = 0; q < queries.length; q++) {\\n\\t\\tconst i = lb(bars, queries[q][0]);\\n\\t\\tconst j = ub(bars, queries[q][1]) - 1;\\n\\n\\t\\tres.push(i < j ? bars[j] - bars[i] - (j - i) : 0);\\n\\t  }\\n\\n\\t  return res;\\n\\t};\\n\\n\\tfunction lb(arr, ele) {\\n\\t  let l = 0;\\n\\t  let h = arr.length;\\n\\n\\t  while (l < h) {\\n\\t\\tconst mid = (l + h) >> 1;\\n\\t\\tif (ele <= arr[mid]) {\\n\\t\\t  h = mid;\\n\\t\\t} else {\\n\\t\\t  l = mid + 1;\\n\\t\\t}\\n\\t  }\\n\\n\\t  return l;\\n\\t}\\n\\n\\tfunction ub(arr, ele) {\\n\\t  let l = 0;\\n\\t  let h = arr.length;\\n\\n\\t  while (l < h) {\\n\\t\\tconst mid = (l + h) >> 1;\\n\\t\\tif (ele >= arr[mid]) {\\n\\t\\t  l = mid + 1;\\n\\t\\t} else {\\n\\t\\t  h = mid;\\n\\t\\t}\\n\\t  }\\n\\n\\t  return l;\\n\\t}\\n\\t```\\n2) Prefix Sum\\n\\t```\\n\\t/**\\n\\t * @param {string} s\\n\\t * @param {number[][]} queries\\n\\t * @return {number[]}\\n\\t */\\n\\tvar platesBetweenCandles = function (s, queries) {\\n\\t  const n = s.length,ans = [];\\n\\t  const next = new Array(n).fill(n);\\n\\t  const prev = new Array(n).fill(n);\\n\\t  const prefixSum = new Array(n).fill(0);\\n\\n\\t  for (let i = 0; i < s.length; i++) {\\n\\t\\tif (s[i] === \"|\") {\\n\\t\\t  prev[i] = i;\\n\\t\\t  prefixSum[i] = i === 0 ? 1 : prefixSum[i - 1];\\n\\t\\t} else {\\n\\t\\t  prev[i] = i === 0 ? prev[i] : prev[i - 1];\\n\\t\\t  prefixSum[i] = i === 0 ? 1 : prefixSum[i - 1] + 1;\\n\\t\\t}\\n\\t  }\\n\\n\\t  for (let i = n - 1; i >= 0; i--) {\\n\\t\\tif (s[i] === \"|\") {\\n\\t\\t  next[i] = i;\\n\\t\\t} else {\\n\\t\\t  next[i] = i === n - 1 ? next[i] : next[i + 1];\\n\\t\\t}\\n\\t  }\\n\\n\\t  for (const [l,r] of queries) {\\n\\t\\tconst i = next[l];\\n\\t\\tconst j = prev[r];\\n\\n\\t\\tans.push(i < j && j !== n && i !== n ? prefixSum[j] - prefixSum[i] : 0);\\n\\t  }\\n\\n\\t  return ans;\\n\\t};\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\t/**\\n\\t * @param {string} s\\n\\t * @param {number[][]} queries\\n\\t * @return {number[]}\\n\\t */\\n\\tvar platesBetweenCandles = function (s, queries) {\\n\\t  const bars = [],\\n\\t\\tres = [];\\n\\n\\t  for (let i = 0; i < s.length; i++) {\\n\\t\\tif (s[i] === \"|\") {\\n\\t\\t  bars.push(i);\\n\\t\\t}\\n\\t  }\\n\\n\\t  for (let q = 0; q < queries.length; q++) {\\n\\t\\tconst i = lb(bars, queries[q][0]);\\n\\t\\tconst j = ub(bars, queries[q][1]) - 1;\\n\\n\\t\\tres.push(i < j ? bars[j] - bars[i] - (j - i) : 0);\\n\\t  }\\n\\n\\t  return res;\\n\\t};\\n\\n\\tfunction lb(arr, ele) {\\n\\t  let l = 0;\\n\\t  let h = arr.length;\\n\\n\\t  while (l < h) {\\n\\t\\tconst mid = (l + h) >> 1;\\n\\t\\tif (ele <= arr[mid]) {\\n\\t\\t  h = mid;\\n\\t\\t} else {\\n\\t\\t  l = mid + 1;\\n\\t\\t}\\n\\t  }\\n\\n\\t  return l;\\n\\t}\\n\\n\\tfunction ub(arr, ele) {\\n\\t  let l = 0;\\n\\t  let h = arr.length;\\n\\n\\t  while (l < h) {\\n\\t\\tconst mid = (l + h) >> 1;\\n\\t\\tif (ele >= arr[mid]) {\\n\\t\\t  l = mid + 1;\\n\\t\\t} else {\\n\\t\\t  h = mid;\\n\\t\\t}\\n\\t  }\\n\\n\\t  return l;\\n\\t}\\n\\t```\n```\\n\\t/**\\n\\t * @param {string} s\\n\\t * @param {number[][]} queries\\n\\t * @return {number[]}\\n\\t */\\n\\tvar platesBetweenCandles = function (s, queries) {\\n\\t  const n = s.length,ans = [];\\n\\t  const next = new Array(n).fill(n);\\n\\t  const prev = new Array(n).fill(n);\\n\\t  const prefixSum = new Array(n).fill(0);\\n\\n\\t  for (let i = 0; i < s.length; i++) {\\n\\t\\tif (s[i] === \"|\") {\\n\\t\\t  prev[i] = i;\\n\\t\\t  prefixSum[i] = i === 0 ? 1 : prefixSum[i - 1];\\n\\t\\t} else {\\n\\t\\t  prev[i] = i === 0 ? prev[i] : prev[i - 1];\\n\\t\\t  prefixSum[i] = i === 0 ? 1 : prefixSum[i - 1] + 1;\\n\\t\\t}\\n\\t  }\\n\\n\\t  for (let i = n - 1; i >= 0; i--) {\\n\\t\\tif (s[i] === \"|\") {\\n\\t\\t  next[i] = i;\\n\\t\\t} else {\\n\\t\\t  next[i] = i === n - 1 ? next[i] : next[i + 1];\\n\\t\\t}\\n\\t  }\\n\\n\\t  for (const [l,r] of queries) {\\n\\t\\tconst i = next[l];\\n\\t\\tconst j = prev[r];\\n\\n\\t\\tans.push(i < j && j !== n && i !== n ? prefixSum[j] - prefixSum[i] : 0);\\n\\t  }\\n\\n\\t  return ans;\\n\\t};\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1561940,
                "title": "c-simple-o-n-logn-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        map<int,int> m;\\n        int count = 0;\\n        for(int i = 0;i<s.size();i++) {\\n            if(s[i] == \\'|\\') {\\n                m[i] = count;\\n            } else {\\n                count++;\\n            }\\n        }\\n        vector<int> ret; \\n        for(auto&& q:queries) {\\n            int l = q[0];\\n            int r = q[1];\\n            auto ptr = m.lower_bound(l);\\n            if(ptr == m.end() || ptr->first>= r) {\\n                ret.push_back(0);\\n                continue;\\n            }\\n            auto r_ptr = m.upper_bound(r);\\n            if(r_ptr == m.begin()) {\\n                ret.push_back(0);\\n                continue;\\n            }\\n            r_ptr--; \\n            if(r_ptr->first<=l) {\\n                ret.push_back(0);\\n                continue;\\n            }\\n            ret.push_back(r_ptr->second - ptr->second);\\n        }\\n        return ret; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        map<int,int> m;\\n        int count = 0;\\n        for(int i = 0;i<s.size();i++) {\\n            if(s[i] == \\'|\\') {\\n                m[i] = count;\\n            } else {\\n                count++;\\n            }\\n        }\\n        vector<int> ret; \\n        for(auto&& q:queries) {\\n            int l = q[0];\\n            int r = q[1];\\n            auto ptr = m.lower_bound(l);\\n            if(ptr == m.end() || ptr->first>= r) {\\n                ret.push_back(0);\\n                continue;\\n            }\\n            auto r_ptr = m.upper_bound(r);\\n            if(r_ptr == m.begin()) {\\n                ret.push_back(0);\\n                continue;\\n            }\\n            r_ptr--; \\n            if(r_ptr->first<=l) {\\n                ret.push_back(0);\\n                continue;\\n            }\\n            ret.push_back(r_ptr->second - ptr->second);\\n        }\\n        return ret; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1558860,
                "title": "c-using-bs-t-c-2-n-logn",
                "content": "\\n\\tclass Solution {\\n\\n\\tpublic:\\n\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        // using the concept of binary search\\n        \\n        vector<int> barIndex;\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'|\\'){\\n                barIndex.push_back(i);\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        \\n        for(auto it: queries){\\n            int l= it[0];\\n            int r= it[1];\\n            \\n            int i= lower_bound(barIndex.begin(), barIndex.end(), l)- barIndex.begin();\\n            \\n            int j= upper_bound(barIndex.begin(), barIndex.end(),r)- barIndex.begin()-1;\\n            \\n            \\n            if(j<=i){\\n                ans.push_back(0);\\n            }\\n            else{\\n                ans.push_back(barIndex[j]- barIndex[i]-(j-i));\\n            }\\n        }\\n        return  ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\n\\tpublic:\\n\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        // using the concept of binary search\\n        \\n        vector<int> barIndex;\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'|\\'){\\n                barIndex.push_back(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1557109,
                "title": "python-prefix-and-suffix-sums-easy-readable-code",
                "content": "```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries):\\n        prebar, suffbar, prestar= [], [], []\\n        res = []\\n        \\n        # calculating Prefix sum of all stars\\n        stars = 0\\n        for i in s:\\n            if i == \\'*\\':\\n                stars+=1\\n            prestar.append(stars)\\n            \\n        # calculating Prefix indexes of all bars\\n        i = len(s) - 1\\n        n = len(s)\\n        while i >= 0:\\n            if s[i] == \\'|\\':\\n                n = i\\n            i-=1\\n            prebar.append(n)\\n        prebar.reverse()\\n        \\n        # calculating Suffix indexes of all bars\\n        n = len(s)\\n        for i in range(len(s)):\\n            if s[i] == \\'|\\':\\n                n = i\\n            suffbar.append(n)\\n        \\n        # main \\n        for i in queries:\\n            l = prebar[i[0]]\\n            r = suffbar[i[1]]\\n            if r <= l or r == len(s) or l == len(s):\\n                res.append(0)\\n            else:\\n                res.append(prestar[r]-prestar[l])\\n        return res",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries):\\n        prebar, suffbar, prestar= [], [], []\\n        res = []\\n        \\n        # calculating Prefix sum of all stars\\n        stars = 0\\n        for i in s:\\n            if i == \\'*\\':\\n                stars+=1\\n            prestar.append(stars)\\n            \\n        # calculating Prefix indexes of all bars\\n        i = len(s) - 1\\n        n = len(s)\\n        while i >= 0:\\n            if s[i] == \\'|\\':\\n                n = i\\n            i-=1\\n            prebar.append(n)\\n        prebar.reverse()\\n        \\n        # calculating Suffix indexes of all bars\\n        n = len(s)\\n        for i in range(len(s)):\\n            if s[i] == \\'|\\':\\n                n = i\\n            suffbar.append(n)\\n        \\n        # main \\n        for i in queries:\\n            l = prebar[i[0]]\\n            r = suffbar[i[1]]\\n            if r <= l or r == len(s) or l == len(s):\\n                res.append(0)\\n            else:\\n                res.append(prestar[r]-prestar[l])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1554510,
                "title": "c-beats-100-user-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n        int pre[n] //it will store most near left side candle;\\n        int post[n] // it will store most near right side candle;\\n        int star[n] //it will store no of star;\\n        for(int i=0;i<n;i++){\\n            pre[i]=-1,post[i]=-1,star[i]=0;\\n        }\\n\\t\\t\\n        pre[0]=s[0]==\\'|\\'?0:-1;\\n        star[0]=s[0]==\\'*\\'?1:0;\\n        for(int i=1;i<n;i++){\\n          \\n            if(s[i]==\\'|\\'){\\n\\t\\t\\t//if this is index have candle \\n                pre[i]=i;\\n                star[i]=star[i-1];\\n            }\\n            else{\\n\\t\\t\\t// if this index dont have candle just copy the answer of previous candle\\n                pre[i]=pre[i-1];\\n                star[i]=star[i-1]+1; \\n                }\\n\\n        }\\n        post[n-1]=s[n-1]==\\'|\\'?n-1:-1;\\n        for(int i=n-2;i>=0;i--){\\n\\t\\t\\t// same idea as prefix\\n            if(s[i]==\\'|\\')post[i]=i;\\n            else post[i]=post[i+1];\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++){\\n           int left=queries[i][0],right=queries[i][1];\\n            int first=-1,last=-1;\\n\\t\\t\\t\\n            if(pre[left]==left){\\n\\t\\t\\t//if left have candle\\n                first=left;\\n            }else{\\n\\t\\t\\t\\t// *|**|** the right will give us candle which nearest to end because we always storing nearest\\n\\t\\t\\t\\t\\n                first=post[left];\\n            }\\n\\t\\t\\t//same idea as above\\n            if(post[right]==right){\\n                last=right;\\n            }else{\\n                last=pre[right];\\n            }\\n           \\n            if(first>right||last<left||first==last||first==-1||last==-1){\\n\\t\\t\\t\\t// if we dont find any candle or one candle or out of bound candle\\n                ans.push_back(0);\\n            }else{\\n                ans.push_back(star[last]-star[first]);\\n                // cout<<first<<\" \"<<last<<\" \"<<star[last]-star[first-1]<<endl;\\n            }\\n            \\n             \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n        int pre[n] //it will store most near left side candle;\\n        int post[n] // it will store most near right side candle;\\n        int star[n] //it will store no of star;\\n        for(int i=0;i<n;i++){\\n            pre[i]=-1,post[i]=-1,star[i]=0;\\n        }\\n\\t\\t\\n        pre[0]=s[0]==\\'|\\'?0:-1;\\n        star[0]=s[0]==\\'*\\'?1:0;\\n        for(int i=1;i<n;i++){\\n          \\n            if(s[i]==\\'|\\'){\\n\\t\\t\\t//if this is index have candle \\n                pre[i]=i;\\n                star[i]=star[i-1];\\n            }\\n            else{\\n\\t\\t\\t// if this index dont have candle just copy the answer of previous candle\\n                pre[i]=pre[i-1];\\n                star[i]=star[i-1]+1; \\n                }\\n\\n        }\\n        post[n-1]=s[n-1]==\\'|\\'?n-1:-1;\\n        for(int i=n-2;i>=0;i--){\\n\\t\\t\\t// same idea as prefix\\n            if(s[i]==\\'|\\')post[i]=i;\\n            else post[i]=post[i+1];\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++){\\n           int left=queries[i][0],right=queries[i][1];\\n            int first=-1,last=-1;\\n\\t\\t\\t\\n            if(pre[left]==left){\\n\\t\\t\\t//if left have candle\\n                first=left;\\n            }else{\\n\\t\\t\\t\\t// *|**|** the right will give us candle which nearest to end because we always storing nearest\\n\\t\\t\\t\\t\\n                first=post[left];\\n            }\\n\\t\\t\\t//same idea as above\\n            if(post[right]==right){\\n                last=right;\\n            }else{\\n                last=pre[right];\\n            }\\n           \\n            if(first>right||last<left||first==last||first==-1||last==-1){\\n\\t\\t\\t\\t// if we dont find any candle or one candle or out of bound candle\\n                ans.push_back(0);\\n            }else{\\n                ans.push_back(star[last]-star[first]);\\n                // cout<<first<<\" \"<<last<<\" \"<<star[last]-star[first-1]<<endl;\\n            }\\n            \\n             \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1550778,
                "title": "c-prefix-sum-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n        int l[n];\\n        int r[n];\\n        int lind=0,rind=0;\\n        for(int i=0;i<n;i++){\\n            l[i]=-1;\\n            r[i]=-1;\\n        }\\n        l[0]=-1;\\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'|\\')\\n                l[i]=i;\\n            else\\n                l[i]=l[i-1];\\n        }\\n        r[n-1]=-1;\\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]==\\'|\\')\\n                r[i]=i;\\n            else\\n                r[i]=r[i+1];\\n        }\\n        int count[n];\\n        int x=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'*\\')\\n                x++;\\n            count[i]=x;\\n        }\\n        vector<int> ans;\\n        for(auto x: queries){\\n            int ll=x[0];\\n            int rr=x[1];\\n            int prevInd=l[rr];\\n            int nextInd=r[ll];\\n            int c=0;\\n            if(prevInd>nextInd)\\n                c=count[prevInd]-count[nextInd];\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n        int l[n];\\n        int r[n];\\n        int lind=0,rind=0;\\n        for(int i=0;i<n;i++){\\n            l[i]=-1;\\n            r[i]=-1;\\n        }\\n        l[0]=-1;\\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'|\\')\\n                l[i]=i;\\n            else\\n                l[i]=l[i-1];\\n        }\\n        r[n-1]=-1;\\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]==\\'|\\')\\n                r[i]=i;\\n            else\\n                r[i]=r[i+1];\\n        }\\n        int count[n];\\n        int x=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'*\\')\\n                x++;\\n            count[i]=x;\\n        }\\n        vector<int> ans;\\n        for(auto x: queries){\\n            int ll=x[0];\\n            int rr=x[1];\\n            int prevInd=l[rr];\\n            int nextInd=r[ll];\\n            int c=0;\\n            if(prevInd>nextInd)\\n                c=count[prevInd]-count[nextInd];\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550166,
                "title": "c-solution-o-1-each-queries",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) \\n    {\\n        int n=s.size();\\n        vector<int>left(n),right(n);\\n        vector<int>sum(n,0);\\n        if(s[0]==\\'*\\')\\n        {\\n            sum[0]=1;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            sum[i]=sum[i-1];\\n            if(s[i]==\\'*\\')\\n            {\\n                sum[i]++;\\n            }\\n        }\\n        int curr=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'|\\')\\n            {\\n                curr=i;\\n            }\\n            left[i]=curr;\\n        }\\n        curr=-1;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'|\\')\\n            {\\n                curr=i;\\n            }\\n            right[i]=curr;\\n        }\\n        vector<int>ans(queries.size(),0);\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int l=right[queries[i][0]];\\n            int r=left[queries[i][1]];\\n            // cout<<l<<\" \"<<r<<endl;\\n            if(l==-1||r==-1||l>r)\\n            {\\n                continue;\\n            }\\n            ans[i]=sum[r]-sum[l];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) \\n    {\\n        int n=s.size();\\n        vector<int>left(n),right(n);\\n        vector<int>sum(n,0);\\n        if(s[0]==\\'*\\')\\n        {\\n            sum[0]=1;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            sum[i]=sum[i-1];\\n            if(s[i]==\\'*\\')\\n            {\\n                sum[i]++;\\n            }\\n        }\\n        int curr=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'|\\')\\n            {\\n                curr=i;\\n            }\\n            left[i]=curr;\\n        }\\n        curr=-1;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'|\\')\\n            {\\n                curr=i;\\n            }\\n            right[i]=curr;\\n        }\\n        vector<int>ans(queries.size(),0);\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int l=right[queries[i][0]];\\n            int r=left[queries[i][1]];\\n            // cout<<l<<\" \"<<r<<endl;\\n            if(l==-1||r==-1||l>r)\\n            {\\n                continue;\\n            }\\n            ans[i]=sum[r]-sum[l];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1549677,
                "title": "c-simple-and-clean-prefix-sum-solution-detailed-explanation",
                "content": "**Idea:**\\nWe use three vectors:\\n`prev` - for each index to know the previous candle.\\n`next` - for each index to know the next candle.\\n`prefix` - to count the prefix sum of candles.\\n\\nNow, in each query, we need to find the leftmost and rightmost candle within the substring.\\nWe know easily: the `first` candle is at `next[q[0]]`, and the last candle is at `prev[q[1]]`.\\nThe amount of plates between `first` and `last` is the total `last - first` minus the candles - `prefix[last] - prefix[first]`.\\nIf we got a negative result - we have none.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(n)\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int first, last, curr;\\n        vector<int> prev(s.size(), 0), next(s.size(), 0), prefix(s.size(), 0);\\n        \\n        for (int i = 1; i < s.size(); i++) {\\n            prev[i] = s[i] == \\'|\\' ? i : prev[i-1];\\n            prefix[i] = prefix[i-1] + (s[i] == \\'|\\');\\n        }\\n        \\n        for (int i = s.size()-2; i >= 0; i--) {\\n            next[i] = s[i] == \\'|\\' ? i : next[i+1];\\n        }\\n        \\n        vector<int> res;\\n        for (auto q : queries) {\\n            first = next[q[0]], last = prev[q[1]];\\n            curr = last - first - (prefix[last] - prefix[first]);\\n            res.push_back(curr > 0 ? curr : 0);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int first, last, curr;\\n        vector<int> prev(s.size(), 0), next(s.size(), 0), prefix(s.size(), 0);\\n        \\n        for (int i = 1; i < s.size(); i++) {\\n            prev[i] = s[i] == \\'|\\' ? i : prev[i-1];\\n            prefix[i] = prefix[i-1] + (s[i] == \\'|\\');\\n        }\\n        \\n        for (int i = s.size()-2; i >= 0; i--) {\\n            next[i] = s[i] == \\'|\\' ? i : next[i+1];\\n        }\\n        \\n        vector<int> res;\\n        for (auto q : queries) {\\n            first = next[q[0]], last = prev[q[1]];\\n            curr = last - first - (prefix[last] - prefix[first]);\\n            res.push_back(curr > 0 ? curr : 0);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549381,
                "title": "c-prefix-sum-sc-o-n-tc-o-n",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n        vector<int>v(n);\\n        for(int i=0;i<n;i++){\\n            (s[i]==\\'|\\')?v[i]=0:v[i]=1;\\n            if(i) {\\n\\t\\t\\t\\tv[i]+=v[i-1];\\n\\t\\t\\t}\\n        }\\n        vector<int>pre(n),suf(n);\\n        \\n        pre[0]=-1;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'|\\'){\\n                pre[i]=i;\\n            }else{\\n                if(i){\\n                    pre[i]=pre[i-1];\\n\\t\\t\\t\\t}\\n            }\\n        }\\n        \\n        suf[n-1]=-1;\\n        for(int i=n-1;~i;i--){\\n            if(s[i]==\\'|\\'){\\n                suf[i]=i;\\n            }else{\\n                if(i<n-1){\\n                    suf[i]=suf[i+1];\\n\\t\\t\\t\\t}\\n            }\\n        }\\n        \\n        vector<int>ans;\\n        for(auto it:queries){\\n            int a=it[0],b=it[1];\\n            {   \\n                if(a==0){\\n                    ans.push_back(v[b]);\\n                }else{\\n                    ans.push_back(v[b]-v[a-1]);\\n                }\\n            }\\n            \\n            int f=suf[a],s=pre[b];\\n            if(f!=-1 && s!=-1){\\n                ans.back()-=(b-s)+(f-a);\\n                if(ans.back()<0) ans.back()=0;\\n            }else {\\n                ans.back()=0;\\n            }\\n            \\n            \\n        }\\n        return ans;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n        vector<int>v(n);\\n        for(int i=0;i<n;i++){\\n            (s[i]==\\'|\\')?v[i]=0:v[i]=1;\\n            if(i) {\\n\\t\\t\\t\\tv[i]+=v[i-1];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1549350,
                "title": "javascript-cut-max-consective-substring-binary-search-3692ms",
                "content": "```\\n/////////////////////////////////// Template /////////////////////////////////////////////////////////////////////////////////////\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            x < a[mid] ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n\\nconst cutMaxConsecutive = (a_or_s) => { let d = [], start = 0, n = a_or_s.length; for (let i = 0; i + 1 < n; i++) { if (a_or_s[i + 1] != a_or_s[i]) { d.push(a_or_s.slice(start, i + 1)); start = i + 1; } } d.push(a_or_s.slice(start)); return d; };\\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nconst platesBetweenCandles = (ss, queries) => {\\n    let aa = cutMaxConsecutive(ss);\\n    let L = [], R = []; // record each |****.......***|     start index and end index in L and R respectively\\n    let preL = 0;\\n    for (const s of aa) {\\n        if (s[0] == \\'*\\') {\\n            let l = preL, r = l + s.length - 1;\\n            if (l - 1 >= 0 && r + 1 < ss.length) { // ss[l - 1] is left \"|\", ss[r + 1] is right \"|\"\\n                L.push(l - 1);\\n                R.push(r + 1);\\n            }\\n        }\\n        preL += s.length;\\n    }\\n    let res = [];\\n    let bi = new Bisect();\\n    for (const [curL, curR] of queries) {\\n        let cnt = 0;\\n        let li = bi.bisect_left(L, curL); // get the left starting searching index, using lower_bound()\\n        for (let i = li; i < L.length; i++) {\\n            let l = L[i], r = R[i];\\n            let len = r - l + 1 - 2; // -2 to remove left \"|\" and right \"|\"\\n            if (l > curR) break;\\n            if (curL <= l && curR >= r) {\\n                cnt += len;\\n            }\\n        }\\n        res.push(cnt);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\n/////////////////////////////////// Template /////////////////////////////////////////////////////////////////////////////////////\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            x < a[mid] ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n\\nconst cutMaxConsecutive = (a_or_s) => { let d = [], start = 0, n = a_or_s.length; for (let i = 0; i + 1 < n; i++) { if (a_or_s[i + 1] != a_or_s[i]) { d.push(a_or_s.slice(start, i + 1)); start = i + 1; } } d.push(a_or_s.slice(start)); return d; };\\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nconst platesBetweenCandles = (ss, queries) => {\\n    let aa = cutMaxConsecutive(ss);\\n    let L = [], R = []; // record each |****.......***|     start index and end index in L and R respectively\\n    let preL = 0;\\n    for (const s of aa) {\\n        if (s[0] == \\'*\\') {\\n            let l = preL, r = l + s.length - 1;\\n            if (l - 1 >= 0 && r + 1 < ss.length) { // ss[l - 1] is left \"|\", ss[r + 1] is right \"|\"\\n                L.push(l - 1);\\n                R.push(r + 1);\\n            }\\n        }\\n        preL += s.length;\\n    }\\n    let res = [];\\n    let bi = new Bisect();\\n    for (const [curL, curR] of queries) {\\n        let cnt = 0;\\n        let li = bi.bisect_left(L, curL); // get the left starting searching index, using lower_bound()\\n        for (let i = li; i < L.length; i++) {\\n            let l = L[i], r = R[i];\\n            let len = r - l + 1 - 2; // -2 to remove left \"|\" and right \"|\"\\n            if (l > curR) break;\\n            if (curL <= l && curR >= r) {\\n                cnt += len;\\n            }\\n        }\\n        res.push(cnt);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1549345,
                "title": "java-prefix-suffix-count",
                "content": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int n = s.length();\\n        int leftCandle[] = new int[n];\\n        int rightCandle[] = new int[n];\\n        int count[] = new int[n];\\n        int res[] = new int[queries.length];\\n        \\n        int candle = -1;\\n        for(int i = 0;i< n;i++){\\n            if(s.charAt(i) == \\'|\\')candle = i;\\n            leftCandle[i] = candle;\\n        }\\n        \\n        candle = -1;\\n        for(int i = n-1;i>=0;i--){\\n            if(s.charAt(i) == \\'|\\')candle = i;\\n            rightCandle[i] = candle;\\n        }\\n        \\n        int c = 0;\\n        for(int i = 0;i< n;i++){\\n            if(s.charAt(i) == \\'|\\')c++;\\n            count[i] = c;\\n        }\\n        \\n        int distance = 0;\\n        int idx = 0;\\n        \\n        for(int i[] : queries){\\n            int start = i[0];\\n            int end = i[1];\\n            int lcandle = rightCandle[start];\\n            int rcandle = leftCandle[end];\\n            \\n            if(lcandle == -1 || rcandle == -1){\\n                res[idx] = 0;\\n            }else{\\n                distance  = rcandle - lcandle;\\n                if(distance > 1){\\n                    int total_distance = rcandle - lcandle + 1;\\n                    int total_candles_in_the_given_distance = count[rcandle] - count[lcandle] + 1;\\n                    // Distance - Candle count \\n                    res[idx] = total_distance - total_candles_in_the_given_distance;\\n                }else{ \\n                    res[idx] = 0;\\n                }\\n            }\\n            \\n            idx++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int n = s.length();\\n        int leftCandle[] = new int[n];\\n        int rightCandle[] = new int[n];\\n        int count[] = new int[n];\\n        int res[] = new int[queries.length];\\n        \\n        int candle = -1;\\n        for(int i = 0;i< n;i++){\\n            if(s.charAt(i) == \\'|\\')candle = i;\\n            leftCandle[i] = candle;\\n        }\\n        \\n        candle = -1;\\n        for(int i = n-1;i>=0;i--){\\n            if(s.charAt(i) == \\'|\\')candle = i;\\n            rightCandle[i] = candle;\\n        }\\n        \\n        int c = 0;\\n        for(int i = 0;i< n;i++){\\n            if(s.charAt(i) == \\'|\\')c++;\\n            count[i] = c;\\n        }\\n        \\n        int distance = 0;\\n        int idx = 0;\\n        \\n        for(int i[] : queries){\\n            int start = i[0];\\n            int end = i[1];\\n            int lcandle = rightCandle[start];\\n            int rcandle = leftCandle[end];\\n            \\n            if(lcandle == -1 || rcandle == -1){\\n                res[idx] = 0;\\n            }else{\\n                distance  = rcandle - lcandle;\\n                if(distance > 1){\\n                    int total_distance = rcandle - lcandle + 1;\\n                    int total_candles_in_the_given_distance = count[rcandle] - count[lcandle] + 1;\\n                    // Distance - Candle count \\n                    res[idx] = total_distance - total_candles_in_the_given_distance;\\n                }else{ \\n                    res[idx] = 0;\\n                }\\n            }\\n            \\n            idx++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549289,
                "title": "java-o-n-linear",
                "content": "```\\npublic int helper(int l, int r, char str[], int dp[][]){\\n        int l1 = dp[l][2];\\n        int r1 = dp[r][1];\\n        if(l1 >= r1) return 0;\\n        else return dp[r1][0] - dp[l1][0]; \\n    }\\n    public int[] platesBetweenCandles(String s, int[][] chk) {\\n        char str[] = s.toCharArray();\\n        int arr[][] = new int[str.length][3];\\n        int c1 = 0;\\n        int c2 = -1;\\n        int c3 = -1;\\n        for(int i = 0; i < str.length; i ++){\\n            if(str[i] == \\'*\\') c1 ++;\\n            if(str[i] == \\'|\\') c2 = i;\\n            arr[i][0] = c1;\\n            arr[i][1] = c2;\\n        }\\n        for(int i = str.length - 1; i >= 0; i --){\\n            if(str[i] == \\'|\\') c3 = i;\\n            arr[i][2] = c3;\\n        }\\n        int ans[] = new int[chk.length];\\n        for(int i = 0; i < chk.length; i ++){\\n            ans[i] = helper(chk[i][0], chk[i][1], str, arr);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int helper(int l, int r, char str[], int dp[][]){\\n        int l1 = dp[l][2];\\n        int r1 = dp[r][1];\\n        if(l1 >= r1) return 0;\\n        else return dp[r1][0] - dp[l1][0]; \\n    }\\n    public int[] platesBetweenCandles(String s, int[][] chk) {\\n        char str[] = s.toCharArray();\\n        int arr[][] = new int[str.length][3];\\n        int c1 = 0;\\n        int c2 = -1;\\n        int c3 = -1;\\n        for(int i = 0; i < str.length; i ++){\\n            if(str[i] == \\'*\\') c1 ++;\\n            if(str[i] == \\'|\\') c2 = i;\\n            arr[i][0] = c1;\\n            arr[i][1] = c2;\\n        }\\n        for(int i = str.length - 1; i >= 0; i --){\\n            if(str[i] == \\'|\\') c3 = i;\\n            arr[i][2] = c3;\\n        }\\n        int ans[] = new int[chk.length];\\n        for(int i = 0; i < chk.length; i ++){\\n            ans[i] = helper(chk[i][0], chk[i][1], str, arr);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1549192,
                "title": "c-prefix-sum-no-binary-search-o-q-n-solution",
                "content": "### **let\\'s take this example**\\n`s = \"***|**|*****|**||**|*\"`\\n\\n![image](https://assets.leetcode.com/users/images/93de4e6d-afb8-4f56-bbd7-3d8e4cf41fd5_1635610335.2372036.png)\\n\\n0. For Above example, array `left` will be :\\n`3 3 3 3 6 6 6 12 12 12 12 12 12 15 15 15 16 19 19 19  -1 `\\nThis array shows that, the **Left** most candle position for each queries `left i` value\\n***Example:*** if the `queries[i] = [left i, right i] = [1,9] `, left[1] =3, which means the **Left** most candle **after** 1st position(inclusive) is **`3`**\\n\\n1. And array `right` will be: \\n`-1 -1 -1 3 3 3 6 6 6 6 6 6 12 12 12 15 16 16 16 19 19 `\\nThis array shows that, the **Right** most candle position for each queries `right i` value\\n***Example:*** if the `queries[i] = [left i, right i] = [1,9] `, left[1] =3, which means the **Right** most candle **before** 9th position(inclusive) is **`6`**\\n\\n2. And for prefix sum is array `plates`, which will be:\\n`1 2 3 3 4 5 5 6 7 8 9 10 10 11 12 12 12 13 14 14 15 `\\nThis denotes total number of plates before `ith` index\\n\\nSo, for each query, we can get **left and right most candle position** *(using left and right array)* and easily count total plater between candles using prefixsum array `plates`\\n\\n#### Code with O(n) time\\n```\\nvector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n\\tint n  = s.length(), cnt = 0, left_inx = -1, right_inx = -1;\\n\\tvector<int> plates(n,0);\\n\\tvector<int> left(n,0); \\n\\tvector<int> right(n,0);\\n\\n\\tfor(int i=0; i<n; i++){\\n\\t\\tif(s[i]==\\'|\\'){\\n\\t\\t\\tright_inx = i;\\n\\t\\t}\\n\\t\\tright[i] = right_inx;\\n\\n\\t\\tif(s[i]==\\'*\\'){\\n\\t\\t\\tcnt++;\\n\\t\\t}\\n\\t\\t// counting plates before ith index\\n\\t\\tplates[i] = cnt;\\n\\t}\\n\\n\\tfor(int i=n-1; i>=0; i--){\\n\\t\\tif(s[i]==\\'|\\'){\\n\\t\\t\\tleft_inx = i;\\n\\t\\t}\\n\\t\\tleft[i] = left_inx;\\n\\t}\\n\\tvector<int> res;\\n\\tfor(auto q:queries) {\\n\\t\\tint l = left[q[0]];     //  left most candle position\\n\\t\\tint r = right[q[1]];    // right most candle position\\n\\t\\tif (l==-1 || r==-1 || l>=r) res.push_back(0); // if no plate in between candles\\n\\t\\telse res.push_back(plates[r]-plates[l]);\\n\\t}\\n\\treturn res;\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n\\tint n  = s.length(), cnt = 0, left_inx = -1, right_inx = -1;\\n\\tvector<int> plates(n,0);\\n\\tvector<int> left(n,0); \\n\\tvector<int> right(n,0);\\n\\n\\tfor(int i=0; i<n; i++){\\n\\t\\tif(s[i]==\\'|\\'){\\n\\t\\t\\tright_inx = i;\\n\\t\\t}\\n\\t\\tright[i] = right_inx;\\n\\n\\t\\tif(s[i]==\\'*\\'){\\n\\t\\t\\tcnt++;\\n\\t\\t}\\n\\t\\t// counting plates before ith index\\n\\t\\tplates[i] = cnt;\\n\\t}\\n\\n\\tfor(int i=n-1; i>=0; i--){\\n\\t\\tif(s[i]==\\'|\\'){\\n\\t\\t\\tleft_inx = i;\\n\\t\\t}\\n\\t\\tleft[i] = left_inx;\\n\\t}\\n\\tvector<int> res;\\n\\tfor(auto q:queries) {\\n\\t\\tint l = left[q[0]];     //  left most candle position\\n\\t\\tint r = right[q[1]];    // right most candle position\\n\\t\\tif (l==-1 || r==-1 || l>=r) res.push_back(0); // if no plate in between candles\\n\\t\\telse res.push_back(plates[r]-plates[l]);\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1549032,
                "title": "c-supereasy-prefix-sum",
                "content": "# ***Approach***\\n```\\n(1) leftie vector stores index of next candle index for a given index\\n(2) rightie vector stroes index of previous candle index for a given index\\n(3) sums maintains count of prefix sums\\n\\nFor a given interval [a,b]\\ntry to find convert it into valid candle points using leftie and rightie\\nleft = rightie[a] , right = leftie[b];\\nthen simply find answer for given interval using sums\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>> &queries) {\\n        vector<int> v , res , sums , leftie , rightie(s.size()) ;\\n        \\n        int count = 0 , value = -1 , running_sum = 0;\\n        bool flag = false;\\n        \\n        for(int i = 0 ; i < s.size() ; ++i)\\n        {\\n            if(s[i] == \\'|\\')\\n            {\\n                value = i;\\n                v.push_back(i);\\n            }\\n            else\\n                ++running_sum , ++count;\\n            sums.push_back(running_sum);\\n            leftie.push_back(value);\\n        }\\n        \\n        value = -1;\\n        for(int i = s.size() - 1 ; i >= 0 ; --i)\\n        {\\n            if(s[i] == \\'|\\')\\n                value = i;\\n            rightie[i] = value;\\n        }\\n        \\n        for(auto q : queries)\\n        {\\n            int a = q[0] , b = q[1];\\n            int left = rightie[a] , right = leftie[b]; \\n            if(left == -1 or right == -1)\\n                res.push_back(0);\\n            else\\n                res.push_back(max(0 , sums[right] - sums[left]));\\n        }\\n        return res;\\n    }\\n};\\n```\\n# ***If you liked the solution , Give it an Upvote :)***",
                "solutionTags": [],
                "code": "```\\n(1) leftie vector stores index of next candle index for a given index\\n(2) rightie vector stroes index of previous candle index for a given index\\n(3) sums maintains count of prefix sums\\n\\nFor a given interval [a,b]\\ntry to find convert it into valid candle points using leftie and rightie\\nleft = rightie[a] , right = leftie[b];\\nthen simply find answer for given interval using sums\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>> &queries) {\\n        vector<int> v , res , sums , leftie , rightie(s.size()) ;\\n        \\n        int count = 0 , value = -1 , running_sum = 0;\\n        bool flag = false;\\n        \\n        for(int i = 0 ; i < s.size() ; ++i)\\n        {\\n            if(s[i] == \\'|\\')\\n            {\\n                value = i;\\n                v.push_back(i);\\n            }\\n            else\\n                ++running_sum , ++count;\\n            sums.push_back(running_sum);\\n            leftie.push_back(value);\\n        }\\n        \\n        value = -1;\\n        for(int i = s.size() - 1 ; i >= 0 ; --i)\\n        {\\n            if(s[i] == \\'|\\')\\n                value = i;\\n            rightie[i] = value;\\n        }\\n        \\n        for(auto q : queries)\\n        {\\n            int a = q[0] , b = q[1];\\n            int left = rightie[a] , right = leftie[b]; \\n            if(left == -1 or right == -1)\\n                res.push_back(0);\\n            else\\n                res.push_back(max(0 , sums[right] - sums[left]));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549008,
                "title": "simple-swift-solution",
                "content": "```\\n    func platesBetweenCandles(_ s: String, _ queries: [[Int]]) -> [Int] {\\n        var list = [Int]()\\n        let a = Array(s)\\n        for i in 0..<a.count {\\n            if a[i] == \"|\" {\\n                list.append(i)\\n            }\\n        }\\n        var res = [Int](repeating: 0, count: queries.count)\\n        for i in 0..<queries.count {\\n            if let l = list.firstIndex(where: {$0 >= queries[i][0]}), let r = list.lastIndex(where: {$0 <= queries[i][1]}) {\\n                if l < r {\\n                    res[i] = list[r] - list[l] - r + l\\n                }\\n            }\\n        }\\n        return res\\n    }\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n    func platesBetweenCandles(_ s: String, _ queries: [[Int]]) -> [Int] {\\n        var list = [Int]()\\n        let a = Array(s)\\n        for i in 0..<a.count {\\n            if a[i] == \"|\" {\\n                list.append(i)\\n            }\\n        }\\n        var res = [Int](repeating: 0, count: queries.count)\\n        for i in 0..<queries.count {\\n            if let l = list.firstIndex(where: {$0 >= queries[i][0]}), let r = list.lastIndex(where: {$0 <= queries[i][1]}) {\\n                if l < r {\\n                    res[i] = list[r] - list[l] - r + l\\n                }\\n            }\\n        }\\n        return res\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1548995,
                "title": "java-tle-naive",
                "content": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int[] ans=new int[queries.length];\\n        int k=0;\\n        for(int[] query : queries)\\n        {\\n            int left=query[0];\\n            int right=query[1];\\n            \\n            boolean leftPlate=false;\\n            int len=0;\\n            int currentNest=0;\\n           \\n            for(int i=left;i<=right;i++)\\n            {\\n                if(s.charAt(i)==\\'*\\' && leftPlate){\\n                    len++;\\n                    currentNest++;\\n                }else if(s.charAt(i)==\\'*\\' && !leftPlate)\\n                {\\n                    continue;\\n                }else if(s.charAt(i)==\\'|\\' && leftPlate){\\n                    currentNest=0;\\n                    if(i==right)\\n                    leftPlate=false;\\n                }else if(s.charAt(i)==\\'|\\' && !leftPlate)\\n                {\\n                    leftPlate=true;\\n                }\\n            }\\n            if(leftPlate)len-=currentNest;\\n            ans[k++]=len;\\n        }\\n        \\n        return ans;\\n                                                                   \\n                                                                  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int[] ans=new int[queries.length];\\n        int k=0;\\n        for(int[] query : queries)\\n        {\\n            int left=query[0];\\n            int right=query[1];\\n            \\n            boolean leftPlate=false;\\n            int len=0;\\n            int currentNest=0;\\n           \\n            for(int i=left;i<=right;i++)\\n            {\\n                if(s.charAt(i)==\\'*\\' && leftPlate){\\n                    len++;\\n                    currentNest++;\\n                }else if(s.charAt(i)==\\'*\\' && !leftPlate)\\n                {\\n                    continue;\\n                }else if(s.charAt(i)==\\'|\\' && leftPlate){\\n                    currentNest=0;\\n                    if(i==right)\\n                    leftPlate=false;\\n                }else if(s.charAt(i)==\\'|\\' && !leftPlate)\\n                {\\n                    leftPlate=true;\\n                }\\n            }\\n            if(leftPlate)len-=currentNest;\\n            ans[k++]=len;\\n        }\\n        \\n        return ans;\\n                                                                   \\n                                                                  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548991,
                "title": "java-binary-search-insert-position",
                "content": "Take the second example\\n```\\nInput: s = \"***|**|*****|**||**|*\"\\nqueries = [[1,17],[4,5],[14,17],[5,11],[15,16]]\\n```\\n\\nStore the indices of the candles in a list\\n```\\ncandleIndices = [3, 6, 12, 15, 16, 19]\\nsumList       = [0, 2,  7,  9,  9, 11]\\nNumber of plates between (6, 15) = sumList[3] - sumList[1] = 7\\n```\\n\\nTo find the number of plates between any 2 candles `(i, j)`, do `sumList[xj] - sumList[xi]` where `xi` and `xj` are the indices in `candleIndices`. For example, number of plates between `6` and `15` can be found by doing `sumList[3] - sumList[1]` where `1`,`3`  are the indices of the values `6`,`15` in `candleList`. But the problem is the indices given in the queries might not be candle indices neccessarily, so a binary search can help find the next highest after `query[0]` and next lowest element before `query[1]` respectively.\\n\\n```java\\npublic int[] platesBetweenCandles(String s, int[][] queries) {\\n\\tvar candleIndices = new ArrayList<Integer>();  // list of indices containing candles\\n\\tvar sumList = new ArrayList<Integer>();        // running sum of plates between candle indices\\n\\n\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\tif (s.charAt(i) == \\'|\\') {\\n\\t\\t\\tcandleIndices.add(i);\\n\\t\\t\\tif (candleIndices.size() < 2) {\\n\\t\\t\\t\\tsumList.add(0);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvar x = candleIndices.get(candleIndices.size()-1) - candleIndices.get(candleIndices.size()-2)-1;\\n\\t\\t\\t\\tsumList.add(sumList.get(sumList.size() -1) + x);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvar result = new int[queries.length];\\n\\tif (candleIndices.size() == s.length() || candleIndices.size() == 0) {\\n\\t\\tArrays.fill(result, 0);\\n\\t} else {\\n\\t\\tint i = 0;\\n\\t\\tfor (var query : queries) {\\n\\t\\t\\tint leftIndex = nextHighest(candleIndices, query[0]);\\n\\t\\t\\tint rightIndex = nextSmallest(candleIndices, query[1]);\\n\\n\\t\\t\\tif (leftIndex >= rightIndex) {\\n\\t\\t\\t\\tresult[i++] = 0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresult[i++] = sumList.get(rightIndex) - sumList.get(leftIndex);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n\\n// get index of needle if it exists or the index of the next highest number in the list\\npublic int nextHighest(List<Integer> list, int needle) {\\n\\tvar index = Collections.binarySearch(list, needle);\\n\\tif (index >= 0) {\\n\\t\\treturn index;\\n\\t}\\n\\treturn (index + 1) * -1;\\n}\\n\\n// get index of needle if it exists or the index of the next smallest number in the list\\npublic int nextSmallest(List<Integer> list, int needle) {\\n\\tvar index = Collections.binarySearch(list, needle);\\n\\tif (index >= 0) {\\n\\t\\treturn index;\\n\\t}\\n\\treturn ((index + 1) * -1) - 1;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nInput: s = \"***|**|*****|**||**|*\"\\nqueries = [[1,17],[4,5],[14,17],[5,11],[15,16]]\\n```\n```\\ncandleIndices = [3, 6, 12, 15, 16, 19]\\nsumList       = [0, 2,  7,  9,  9, 11]\\nNumber of plates between (6, 15) = sumList[3] - sumList[1] = 7\\n```\n```java\\npublic int[] platesBetweenCandles(String s, int[][] queries) {\\n\\tvar candleIndices = new ArrayList<Integer>();  // list of indices containing candles\\n\\tvar sumList = new ArrayList<Integer>();        // running sum of plates between candle indices\\n\\n\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\tif (s.charAt(i) == \\'|\\') {\\n\\t\\t\\tcandleIndices.add(i);\\n\\t\\t\\tif (candleIndices.size() < 2) {\\n\\t\\t\\t\\tsumList.add(0);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvar x = candleIndices.get(candleIndices.size()-1) - candleIndices.get(candleIndices.size()-2)-1;\\n\\t\\t\\t\\tsumList.add(sumList.get(sumList.size() -1) + x);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvar result = new int[queries.length];\\n\\tif (candleIndices.size() == s.length() || candleIndices.size() == 0) {\\n\\t\\tArrays.fill(result, 0);\\n\\t} else {\\n\\t\\tint i = 0;\\n\\t\\tfor (var query : queries) {\\n\\t\\t\\tint leftIndex = nextHighest(candleIndices, query[0]);\\n\\t\\t\\tint rightIndex = nextSmallest(candleIndices, query[1]);\\n\\n\\t\\t\\tif (leftIndex >= rightIndex) {\\n\\t\\t\\t\\tresult[i++] = 0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresult[i++] = sumList.get(rightIndex) - sumList.get(leftIndex);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n\\n// get index of needle if it exists or the index of the next highest number in the list\\npublic int nextHighest(List<Integer> list, int needle) {\\n\\tvar index = Collections.binarySearch(list, needle);\\n\\tif (index >= 0) {\\n\\t\\treturn index;\\n\\t}\\n\\treturn (index + 1) * -1;\\n}\\n\\n// get index of needle if it exists or the index of the next smallest number in the list\\npublic int nextSmallest(List<Integer> list, int needle) {\\n\\tvar index = Collections.binarySearch(list, needle);\\n\\tif (index >= 0) {\\n\\t\\treturn index;\\n\\t}\\n\\treturn ((index + 1) * -1) - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1548983,
                "title": "java-solution-with-explanation",
                "content": "- For each candle, calculate the number of plates from starting of array till that candle and store in an array `counts`.\\n- For each query `[left, right]`, we will calculate the index of rightmost nearest candle for `left` index (let\\'s call it `l`) and index of leftmost nearest candle for `right` index (let\\'s call it `r`). If `left` or `right` index are themselved candles then they can also be considered.\\n- Finally calculate counts[r] - counts[l].\\n\\n```java\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int n = s.length();\\n        int count = 0;\\n        int[] counts = new int[n];\\n        int left[] = new int[n], right[] = new int[n];\\n        int l = -1;\\n        for(int i = 0; i<n; ++i){\\n            char ch = s.charAt(i);\\n            if(ch == \\'*\\')\\n                ++count;\\n            else{\\n                l = i;\\n            }\\n            left[i] = l;\\n            counts[i] = count;\\n        }\\n        \\n        int r = -1;\\n        for(int i = n-1; i>=0; --i){\\n            if(s.charAt(i) == \\'|\\'){\\n                r = i;\\n            }\\n            right[i] = r;\\n        }\\n        \\n        int q = queries.length;\\n        int[] ans = new int[q];\\n        for(int i = 0; i<q; ++i){\\n            int[] query = queries[i];\\n            int a = right[query[0]], b = left[query[1]];\\n            if(a == -1 || b == -1 || a > b)\\n                continue;\\n            ans[i] = counts[b] - counts[a];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int n = s.length();\\n        int count = 0;\\n        int[] counts = new int[n];\\n        int left[] = new int[n], right[] = new int[n];\\n        int l = -1;\\n        for(int i = 0; i<n; ++i){\\n            char ch = s.charAt(i);\\n            if(ch == \\'*\\')\\n                ++count;\\n            else{\\n                l = i;\\n            }\\n            left[i] = l;\\n            counts[i] = count;\\n        }\\n        \\n        int r = -1;\\n        for(int i = n-1; i>=0; --i){\\n            if(s.charAt(i) == \\'|\\'){\\n                r = i;\\n            }\\n            right[i] = r;\\n        }\\n        \\n        int q = queries.length;\\n        int[] ans = new int[q];\\n        for(int i = 0; i<q; ++i){\\n            int[] query = queries[i];\\n            int a = right[query[0]], b = left[query[1]];\\n            if(a == -1 || b == -1 || a > b)\\n                continue;\\n            ans[i] = counts[b] - counts[a];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548979,
                "title": "python-prefix-plates-binary-search",
                "content": "```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        n = len(s)\\n        cum_plates = [0] * n    # cumulative count of plates in [0...i]\\n        cum_plates[0] = 1 if s[0] == \\'*\\' else 0\\n        for i in range(1, n):\\n            cum_plates[i] = cum_plates[i-1] + (s[i] == \\'*\\')\\n        \\n        candle_indices = [i for i in range(n) if s[i] == \\'|\\']    # sorted indices array\\n        \\n        res = []\\n        for start, end in queries:\\n            first_candle = bisect.bisect_left(candle_indices, start)\\n            last_candle = bisect.bisect_right(candle_indices, end) - 1\\n            \\n            if first_candle >= last_candle:    # <=1 candles in substring -- not valid\\n                res.append(0)\\n            else:\\n                res.append(cum_plates[candle_indices[last_candle]] - cum_plates[candle_indices[first_candle]])\\n        \\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        n = len(s)\\n        cum_plates = [0] * n    # cumulative count of plates in [0...i]\\n        cum_plates[0] = 1 if s[0] == \\'*\\' else 0\\n        for i in range(1, n):\\n            cum_plates[i] = cum_plates[i-1] + (s[i] == \\'*\\')\\n        \\n        candle_indices = [i for i in range(n) if s[i] == \\'|\\']    # sorted indices array\\n        \\n        res = []\\n        for start, end in queries:\\n            first_candle = bisect.bisect_left(candle_indices, start)\\n            last_candle = bisect.bisect_right(candle_indices, end) - 1\\n            \\n            if first_candle >= last_candle:    # <=1 candles in substring -- not valid\\n                res.append(0)\\n            else:\\n                res.append(cum_plates[candle_indices[last_candle]] - cum_plates[candle_indices[first_candle]])\\n        \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082320,
                "title": "o-n-q-easy-c-solution-with-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ndefine 3 arrays\\ncount of all plates\\nleftcandle\\nrightcandle\\n\\nif we see a candle record that index or else if travelling from left -> right keep the last index \\nif we see a candle record that index or else if travelling from right -> left keep the index of num +1\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n+q) where n is string length and q - #of queries\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] PlatesBetweenCandles(string s, int[][] queries) {\\n        int n = s.Length;\\n        // total plates \\n        int[] totPlates = new int[n];\\n        int[] candleLeft = new int[n];\\n        int[] candleRight = new int[n];\\n        int[] result = new int[queries.Length];\\n\\n        // initiate 0th location - total plates and candleleft\\n        totPlates[0] = s[0]==\\'*\\'? 1:0;\\n        candleLeft[0] = s[0]==\\'|\\'? 0 :-1;\\n\\n        //since traverseing left to right -- fill in both the arrays\\n        // if we see a candle mark that index or keep the previous index\\n        for(int i =1; i<n; i++){\\n            totPlates[i] = totPlates[i-1]+(s[i]==\\'*\\'? 1:0);\\n            candleLeft[i] = s[i] ==\\'|\\'? i : candleLeft[i-1];\\n        }\\n        //candleRight we will start from back\\n        candleRight[n-1] = s[n-1]==\\'|\\'? n-1:n;\\n\\n        // if we see a candle mark the index or keep the same index as next number\\n        for(int i = n-2; i>=0; i--){\\n            candleRight[i] = s[i]==\\'|\\' ? i :candleRight[i +1];      \\n            \\n            }\\n\\n        for(int i =0; i<queries.Length; i++){\\n            //example --> 2,5 we need right candle of 2 and left candle of 5\\n            int right = candleRight[queries[i][0]]; //right candle of 2\\n            int left = candleLeft[queries[i][1]];// left candle of 5\\n\\n            // always check the boundary -- right>=left\\n            result[i] = right>=left? 0 : totPlates[left] - totPlates[right];\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] PlatesBetweenCandles(string s, int[][] queries) {\\n        int n = s.Length;\\n        // total plates \\n        int[] totPlates = new int[n];\\n        int[] candleLeft = new int[n];\\n        int[] candleRight = new int[n];\\n        int[] result = new int[queries.Length];\\n\\n        // initiate 0th location - total plates and candleleft\\n        totPlates[0] = s[0]==\\'*\\'? 1:0;\\n        candleLeft[0] = s[0]==\\'|\\'? 0 :-1;\\n\\n        //since traverseing left to right -- fill in both the arrays\\n        // if we see a candle mark that index or keep the previous index\\n        for(int i =1; i<n; i++){\\n            totPlates[i] = totPlates[i-1]+(s[i]==\\'*\\'? 1:0);\\n            candleLeft[i] = s[i] ==\\'|\\'? i : candleLeft[i-1];\\n        }\\n        //candleRight we will start from back\\n        candleRight[n-1] = s[n-1]==\\'|\\'? n-1:n;\\n\\n        // if we see a candle mark the index or keep the same index as next number\\n        for(int i = n-2; i>=0; i--){\\n            candleRight[i] = s[i]==\\'|\\' ? i :candleRight[i +1];      \\n            \\n            }\\n\\n        for(int i =0; i<queries.Length; i++){\\n            //example --> 2,5 we need right candle of 2 and left candle of 5\\n            int right = candleRight[queries[i][0]]; //right candle of 2\\n            int left = candleLeft[queries[i][1]];// left candle of 5\\n\\n            // always check the boundary -- right>=left\\n            result[i] = right>=left? 0 : totPlates[left] - totPlates[right];\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062389,
                "title": "linear-prefixsum-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // O(n + q) time | O(n) space\\n    // n = length of string\\n    // q = length of queries\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        vector<int> res;\\n        vector<PrefixData*> prefixSums(n, nullptr);\\n\\n        int sum = 0;\\n        int prevCandleIndex = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (s[i] == \\'*\\') sum++;\\n            if (s[i] == \\'|\\') prevCandleIndex = i;\\n            prefixSums[i] = new PrefixData();\\n            prefixSums[i] -> sum = sum;\\n            prefixSums[i] -> prevCandleIndex = prevCandleIndex;\\n        }\\n\\n        int nextCandleIndex = n;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (s[i] == \\'|\\') nextCandleIndex = i;\\n            prefixSums[i] -> nextCandleIndex = nextCandleIndex;\\n        }\\n\\n        for (auto& q : queries) {\\n            int start = q[0], end = q[1];\\n            int startCandle = prefixSums[start] -> nextCandleIndex;\\n            int endCandle = prefixSums[end] -> prevCandleIndex;\\n\\n            int plates = 0;\\n            if (startCandle < endCandle) {\\n                plates = prefixSums[endCandle] -> sum - prefixSums[startCandle] -> sum;\\n            }\\n            res.push_back(plates);\\n        }\\n        return res;\\n    }\\n\\nprivate:\\n    struct PrefixData {\\n        int sum;\\n        int prevCandleIndex;\\n        int nextCandleIndex;\\n\\n        PrefixData(): sum(0), prevCandleIndex(-1), nextCandleIndex(-1) {}\\n    };\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // O(n + q) time | O(n) space\\n    // n = length of string\\n    // q = length of queries\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        vector<int> res;\\n        vector<PrefixData*> prefixSums(n, nullptr);\\n\\n        int sum = 0;\\n        int prevCandleIndex = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (s[i] == \\'*\\') sum++;\\n            if (s[i] == \\'|\\') prevCandleIndex = i;\\n            prefixSums[i] = new PrefixData();\\n            prefixSums[i] -> sum = sum;\\n            prefixSums[i] -> prevCandleIndex = prevCandleIndex;\\n        }\\n\\n        int nextCandleIndex = n;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (s[i] == \\'|\\') nextCandleIndex = i;\\n            prefixSums[i] -> nextCandleIndex = nextCandleIndex;\\n        }\\n\\n        for (auto& q : queries) {\\n            int start = q[0], end = q[1];\\n            int startCandle = prefixSums[start] -> nextCandleIndex;\\n            int endCandle = prefixSums[end] -> prevCandleIndex;\\n\\n            int plates = 0;\\n            if (startCandle < endCandle) {\\n                plates = prefixSums[endCandle] -> sum - prefixSums[startCandle] -> sum;\\n            }\\n            res.push_back(plates);\\n        }\\n        return res;\\n    }\\n\\nprivate:\\n    struct PrefixData {\\n        int sum;\\n        int prevCandleIndex;\\n        int nextCandleIndex;\\n\\n        PrefixData(): sum(0), prevCandleIndex(-1), nextCandleIndex(-1) {}\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057570,
                "title": "c-explanation-o-n-space-o-n-q-runtime",
                "content": "# Approach\\n\\nIt\\'s another \"prefix sum\"-solvable problem. Given a query $[\\u03B1, \\u03B2]$, we want to know 1) position of the closest candle in the interval $[\\u03B1..n)$, let\\'s call it $\\u03B1\\'$. *(and similarly for \\u03B2 but in reverse, let\\'s call it $b\\'$)*, and 2) after we got $1$, we want to know how many plates are there in the interval $(\\u03B1\\'..\\u03B2\\')$.\\n\\nTo solve 1-st point we can simply create two prefx-sums of candles, one where at each $i$ we store the index of the closest candle on the left, and another where we store the index of the closest index on the right. Thus given a query $[\\u03B1, \\u03B2]$ we know immediately the position of closest candles, because positions are stored at $\\u03B1$ and $\\u03B2$ indices accordingly.\\n\\nAfter that, to count the plates we use the usual prefix-sum that stores plates count at each index, and by subtracting the left side from the right side we get the amount of plates inside $(\\u03B1\\'..\\u03B2\\')$.\\n\\n# Complexity\\n- Time complexity: $$O(n + q)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(const string s, const vector<vector<int>>& queries) {\\n        vector<uint> plates(s.size());\\n        vector<int> c_l2r(s.size()), c_r2l(s.size());\\n        for (size_t i = 0; i < s.size(); ++i) {\\n            plates[i] = (i == 0? 0 : plates[i-1]) + (s[i] == \\'*\\'? 1 : 0);\\n            c_l2r[i] = s[i] == \\'|\\'? i : (i == 0? -1 : c_l2r[i-1]);\\n            int rev_i = s.size() - i - 1;\\n            c_r2l[rev_i] = s[rev_i] == \\'|\\'? rev_i : (i == 0? -1 : c_r2l[s.size() - i]);\\n        }\\n        vector<int> ret;\\n        for (const vector<int>& q : queries) {\\n            int closest_l2r_candle = c_l2r[q[1]],\\n                closest_r2l_candle = c_r2l[q[0]];\\n            ret.push_back((closest_l2r_candle != -1 && closest_r2l_candle != -1 && closest_l2r_candle > closest_r2l_candle)\\n                          ? plates[closest_l2r_candle] - plates[closest_r2l_candle]\\n                          : 0);\\n        }\\n        return ret;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(const string s, const vector<vector<int>>& queries) {\\n        vector<uint> plates(s.size());\\n        vector<int> c_l2r(s.size()), c_r2l(s.size());\\n        for (size_t i = 0; i < s.size(); ++i) {\\n            plates[i] = (i == 0? 0 : plates[i-1]) + (s[i] == \\'*\\'? 1 : 0);\\n            c_l2r[i] = s[i] == \\'|\\'? i : (i == 0? -1 : c_l2r[i-1]);\\n            int rev_i = s.size() - i - 1;\\n            c_r2l[rev_i] = s[rev_i] == \\'|\\'? rev_i : (i == 0? -1 : c_r2l[s.size() - i]);\\n        }\\n        vector<int> ret;\\n        for (const vector<int>& q : queries) {\\n            int closest_l2r_candle = c_l2r[q[1]],\\n                closest_r2l_candle = c_r2l[q[0]];\\n            ret.push_back((closest_l2r_candle != -1 && closest_r2l_candle != -1 && closest_l2r_candle > closest_r2l_candle)\\n                          ? plates[closest_l2r_candle] - plates[closest_r2l_candle]\\n                          : 0);\\n        }\\n        return ret;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021996,
                "title": "easy-c-solution-using-binary-search-and-prefix-sum",
                "content": "# Intuition\\n1) Store all the indices where candles are present\\n2) Maintain a prefix sum of plates \\n3) For each query given find the left most candle using the vector that stores candle indices that lie within the given range\\n4) Similary find the right most candle for the given range\\n5) if there are no left or right candle for a given query store 0 in answer array else ans=prefix_sum[candles[right_most_idx]]-prefix_sum[candles[left_most_idx]]\\n6) Return the answer array\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int find_left(vector<int> &candles,int l,int r){\\n        int start=0;\\n        int end=candles.size()-1;\\n        int ans=-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(candles[mid]<l){\\n                start=mid+1;\\n            }\\n            else{\\n                if(candles[mid]<=r){\\n                    ans=mid;\\n                }\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int find_right(vector<int> &candles,int l,int r){\\n        int start=0;\\n        int end=candles.size()-1;\\n        int ans=-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(candles[mid]>r){\\n                end=mid-1;\\n            }\\n            else{\\n                if(candles[mid]>=l){\\n                    ans=mid;\\n                }\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        vector<int> candles;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'|\\'){\\n                candles.push_back(i);\\n            }\\n        }\\n        int n=s.length();\\n        vector<int> pre_sum(n,0);\\n        vector<int> ans;\\n        int pre=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'*\\') pre++;\\n            pre_sum[i]=pre;\\n        }        \\n        for(auto it:queries){\\n            int left_idx=find_left(candles,it[0],it[1]);\\n            int right_idx=find_right(candles,it[0],it[1]);\\n            if(left_idx==-1 || right_idx==-1){\\n                ans.push_back(0);\\n                continue;\\n            }\\n    ans.push_back(pre_sum[candles[right_idx]]-pre_sum[candles[left_idx]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int find_left(vector<int> &candles,int l,int r){\\n        int start=0;\\n        int end=candles.size()-1;\\n        int ans=-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(candles[mid]<l){\\n                start=mid+1;\\n            }\\n            else{\\n                if(candles[mid]<=r){\\n                    ans=mid;\\n                }\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int find_right(vector<int> &candles,int l,int r){\\n        int start=0;\\n        int end=candles.size()-1;\\n        int ans=-1;\\n        while(start<=end){\\n            int mid=(start+end)/2;\\n            if(candles[mid]>r){\\n                end=mid-1;\\n            }\\n            else{\\n                if(candles[mid]>=l){\\n                    ans=mid;\\n                }\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        vector<int> candles;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'|\\'){\\n                candles.push_back(i);\\n            }\\n        }\\n        int n=s.length();\\n        vector<int> pre_sum(n,0);\\n        vector<int> ans;\\n        int pre=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'*\\') pre++;\\n            pre_sum[i]=pre;\\n        }        \\n        for(auto it:queries){\\n            int left_idx=find_left(candles,it[0],it[1]);\\n            int right_idx=find_right(candles,it[0],it[1]);\\n            if(left_idx==-1 || right_idx==-1){\\n                ans.push_back(0);\\n                continue;\\n            }\\n    ans.push_back(pre_sum[candles[right_idx]]-pre_sum[candles[left_idx]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011046,
                "title": "with-segment-tree",
                "content": "# Complexity\\n- Time complexity: $$O(n ~ log~n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct SegmentTree {\\nprivate:\\n    vector<int> count;\\n    vector<pair<int, int>> boundary;\\n\\n    void build(const string& s, int i, int l, int r) {\\n        if (r - l == 1) {\\n            count[i] = calc(s[l]);\\n            boundary[i].first = l;\\n            boundary[i].second = l;\\n        } else {\\n            int m = (l + r) / 2;\\n            build(s, 2 * i + 1, l, m);\\n            build(s, 2 * i + 2, m, r);\\n            count[i] = count[2 * i + 1] + count[2 * i + 2];\\n            boundary[i].first = l;\\n            boundary[i].second = r - 1;\\n        }\\n    }\\n\\n    int calc(const char& ch) {\\n        return ch == \\'*\\';\\n    }\\n\\npublic:\\n    SegmentTree(const std::string& s) {\\n        int len = 1, size = s.size();\\n\\n        while (len < size) len *= 2;\\n        string ns = s;\\n\\n        ns.resize(len);\\n        count.resize(2 * len - 1, 0);\\n        boundary.resize(2 * len - 1);\\n        build(ns, 0, 0, len);\\n    }\\n\\n    int query(int node, int a, int b) {\\n        int l = boundary[node].first;\\n        int r = boundary[node].second;\\n        if (r < a || b < l) return 0;\\n        if (l >= a && r <= b) return count[node];\\n        return query(2 * node + 1, a, b) + query(2 * node + 2, a, b);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        SegmentTree segmentTree(s);\\n        vector<int> left(s.size()), right(s.size());\\n\\n        int pred = -1;\\n\\n        for (int i = s.size() - 1; i > -1; i--) {\\n            if (s[i] == \\'|\\') {\\n                left[i] = i;\\n                pred = i;\\n            }\\n            else left[i] = pred;\\n        }\\n\\n        pred = -1;\\n\\n        for (size_t i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'|\\') {\\n                right[i] = i;\\n                pred = i;\\n            }\\n            else right[i] = pred;\\n        }\\n        vector<int> ans;\\n        for (const auto& p : queries) {\\n            int l = left[p[0]];\\n            int r = right[p[1]];\\n            if (l == -1 || r == -1) ans.push_back(0);\\n            else ans.push_back(segmentTree.query(0, l, r));\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nstruct SegmentTree {\\nprivate:\\n    vector<int> count;\\n    vector<pair<int, int>> boundary;\\n\\n    void build(const string& s, int i, int l, int r) {\\n        if (r - l == 1) {\\n            count[i] = calc(s[l]);\\n            boundary[i].first = l;\\n            boundary[i].second = l;\\n        } else {\\n            int m = (l + r) / 2;\\n            build(s, 2 * i + 1, l, m);\\n            build(s, 2 * i + 2, m, r);\\n            count[i] = count[2 * i + 1] + count[2 * i + 2];\\n            boundary[i].first = l;\\n            boundary[i].second = r - 1;\\n        }\\n    }\\n\\n    int calc(const char& ch) {\\n        return ch == \\'*\\';\\n    }\\n\\npublic:\\n    SegmentTree(const std::string& s) {\\n        int len = 1, size = s.size();\\n\\n        while (len < size) len *= 2;\\n        string ns = s;\\n\\n        ns.resize(len);\\n        count.resize(2 * len - 1, 0);\\n        boundary.resize(2 * len - 1);\\n        build(ns, 0, 0, len);\\n    }\\n\\n    int query(int node, int a, int b) {\\n        int l = boundary[node].first;\\n        int r = boundary[node].second;\\n        if (r < a || b < l) return 0;\\n        if (l >= a && r <= b) return count[node];\\n        return query(2 * node + 1, a, b) + query(2 * node + 2, a, b);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        SegmentTree segmentTree(s);\\n        vector<int> left(s.size()), right(s.size());\\n\\n        int pred = -1;\\n\\n        for (int i = s.size() - 1; i > -1; i--) {\\n            if (s[i] == \\'|\\') {\\n                left[i] = i;\\n                pred = i;\\n            }\\n            else left[i] = pred;\\n        }\\n\\n        pred = -1;\\n\\n        for (size_t i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'|\\') {\\n                right[i] = i;\\n                pred = i;\\n            }\\n            else right[i] = pred;\\n        }\\n        vector<int> ans;\\n        for (const auto& p : queries) {\\n            int l = left[p[0]];\\n            int r = right[p[1]];\\n            if (l == -1 || r == -1) ans.push_back(0);\\n            else ans.push_back(segmentTree.query(0, l, r));\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981314,
                "title": "binarysearch-in-java-with-simplest-way-to-implement-and-details-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis Approach make use of binary search in JAVA without using complicated way to implement it.\\n\\n# Approach\\nThe binarySearchLeft and binarySearchRight are two methods.\\nThe difference between the Right and Left are Left reutrning low value and Right returning high value.\\n\\nWe can imagine the target only can be two situations \\n#1 \\ntarget hits the mid value\\n#2\\ntarget does not hit the mid value (inbetween the high and low value)\\n\\nwe image there are two values\\nl refer to low, m refer to mid, h refer to high\\n```\\n0 1 2\\nl m h \\n\\n```\\n\\nwe discuss #2 first,\\n```\\n0 1 2\\nl m h\\n```\\nFor method binarySearchLeft,\\nwe image the target is inbetween .get(m) and .get(h),\\nthe result should be like :  t refer to target\\n```\\n0 1  2\\n     lmh\\n  h  l\\n    t\\n```\\nSo we should return l for the Left hand side because we want count the number of plates in right side of candle!\\n\\nFor method binarySearchRight,\\nwe image the target is inbetween .get(m) and .get(h),\\nthe result should be like :  t refer to target\\n```\\n0 1  2\\n     lmh\\n  h  l\\n    t\\n```\\nSo we should return h for the Right hand side because we want count the number of plates in Left side of candle!\\n\\n\\n\\nwe discuss #1 now,\\nIf the .get(mid) == target\\nFor method binarySearchLeft , \\n```\\n0  1 2\\nl  m h \\n0  1 2\\nlmh\\nh  l\\n```\\n\\n\\nthe high value will be lower than low value => there are we should return l value Left target.\\n\\nFor method binarySearchRight,\\n```\\n0 1 2\\nl m h\\n    lmh\\n  h l\\n```\\nwe must add = into the if statement of if (list.get(mid) <= target),\\nthe result would be like:\\n```\\n0   1  2 \\nl   m  h\\nlmh\\nh   l\\n```\\n\\nand we return h is incorrect for right target.\\n\\n\\n\\n. Let\\'s discuss \\nres.add((A.get(j) - A.get(i)) - (j - i));\\nFor A.get(j) means index of higher bound of plate while A.get(i) is lower bound of plate.\\n```\\nExmaple:\\n**|***|**|**\\n```\\nA.get(j) - A.get(i) means , difference between two targets.\\nj-i means the number of plates in the range of target : eg :\\nwe now have 3  plates, assume j =2, i = 1, \\nj-i = 1 implies that there are 1 plates in the range of query.\\n(A.get(j) - A.get(i)) - (j - i) = index difference in query range - number of plates in between the range of the query = number of candle in the range of query.\\n\\n# Code\\n```\\nclass Solution {\\npublic int[] platesBetweenCandles(String s, int[][] queries) {\\nList<Integer> res = new ArrayList<>();\\nList<Integer> A = new ArrayList<>();\\n\\n\\n    for (int i = 0; i < s.length(); i++) {\\n        if (s.charAt(i) == \\'|\\') {\\n            A.add(i);\\n        }\\n    }\\n    \\n    for (int[] query : queries) {\\n        int a = query[0];\\n        int b = query[1];\\n        \\n        int i = binarySearchLeft(A, a);\\n        int j = binarySearchRight(A, b);\\n        \\n        if (i < j) {\\n            res.add((A.get(j) - A.get(i)) - (j - i));\\n        } else {\\n            res.add(0);\\n        }\\n    }\\n    \\n    return res.stream().mapToInt(Integer::intValue).toArray();\\n}\\n\\nprivate int binarySearchLeft(List<Integer> list, int target) {\\n    int low = 0;\\n    int high = list.size() - 1;\\n    \\n    while (low <= high) {\\n        int mid = low + (high - low) / 2;\\n        if (list.get(mid) < target) {\\n            low = mid + 1;\\n        } else {\\n            high = mid - 1;\\n        }\\n    }\\n    \\n    return low;\\n}\\n\\nprivate int binarySearchRight(List<Integer> list, int target) {\\n    int low = 0;\\n    int high = list.size() - 1;\\n    \\n    while (low <= high) {\\n        int mid = low + (high - low) / 2;\\n        if (list.get(mid) <= target) {\\n            low = mid + 1;\\n        } else {\\n            high = mid - 1;\\n        }\\n    }\\n    \\n    return high;\\n}\\n}\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n0 1 2\\nl m h \\n\\n```\n```\\n0 1 2\\nl m h\\n```\n```\\n0 1  2\\n     lmh\\n  h  l\\n    t\\n```\n```\\n0 1  2\\n     lmh\\n  h  l\\n    t\\n```\n```\\n0  1 2\\nl  m h \\n0  1 2\\nlmh\\nh  l\\n```\n```\\n0 1 2\\nl m h\\n    lmh\\n  h l\\n```\n```\\n0   1  2 \\nl   m  h\\nlmh\\nh   l\\n```\n```\\nExmaple:\\n**|***|**|**\\n```\n```\\nclass Solution {\\npublic int[] platesBetweenCandles(String s, int[][] queries) {\\nList<Integer> res = new ArrayList<>();\\nList<Integer> A = new ArrayList<>();\\n\\n\\n    for (int i = 0; i < s.length(); i++) {\\n        if (s.charAt(i) == \\'|\\') {\\n            A.add(i);\\n        }\\n    }\\n    \\n    for (int[] query : queries) {\\n        int a = query[0];\\n        int b = query[1];\\n        \\n        int i = binarySearchLeft(A, a);\\n        int j = binarySearchRight(A, b);\\n        \\n        if (i < j) {\\n            res.add((A.get(j) - A.get(i)) - (j - i));\\n        } else {\\n            res.add(0);\\n        }\\n    }\\n    \\n    return res.stream().mapToInt(Integer::intValue).toArray();\\n}\\n\\nprivate int binarySearchLeft(List<Integer> list, int target) {\\n    int low = 0;\\n    int high = list.size() - 1;\\n    \\n    while (low <= high) {\\n        int mid = low + (high - low) / 2;\\n        if (list.get(mid) < target) {\\n            low = mid + 1;\\n        } else {\\n            high = mid - 1;\\n        }\\n    }\\n    \\n    return low;\\n}\\n\\nprivate int binarySearchRight(List<Integer> list, int target) {\\n    int low = 0;\\n    int high = list.size() - 1;\\n    \\n    while (low <= high) {\\n        int mid = low + (high - low) / 2;\\n        if (list.get(mid) <= target) {\\n            low = mid + 1;\\n        } else {\\n            high = mid - 1;\\n        }\\n    }\\n    \\n    return high;\\n}\\n}\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980959,
                "title": "java-python-clean-and-simple-solution-with-prefix-sum",
                "content": "# Java Solution\\n\\n```\\nimport static java.util.Arrays.parallelPrefix;\\n\\nclass Solution {\\n    private static final char CANDLE = \\'|\\';\\n\\n    public int[] platesBetweenCandles(String s, int[][] Q) {\\n        int[] T = cumulativeCandles(s);\\n        int[] R = nearestCandleInRight(s), L = nearestCandleInLeft(s);\\n\\n        int[] output = new int[Q.length];\\n\\n        for (int i = 0; i < Q.length; i++) {\\n            int a = Q[i][0], b = Q[i][1];\\n\\n            a = R[a];\\n            b = L[b];\\n\\n            output[i] = a > b ? 0 : (b - T[b]) - (a - T[a]);\\n        }\\n\\n        return output;\\n    }\\n\\n    private static int[] cumulativeCandles(String s) {\\n        int[] output = s.chars()\\n                .map(c -> c == CANDLE ? 1 : 0)\\n                .toArray();\\n\\n        parallelPrefix(output, Integer::sum);\\n\\n        return output;\\n\\n    }\\n\\n    private static int[] nearestCandleInLeft(String s) {\\n        int n = s.length();\\n\\n        int[] output = new int[n];\\n        int lastSeen = -1;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) == CANDLE)\\n                lastSeen = i;\\n\\n            output[i] = lastSeen;\\n        }\\n\\n        return output;\\n    }\\n\\n    private static int[] nearestCandleInRight(String s) {\\n        int n = s.length();\\n\\n        int[] output = new int[n];\\n        int lastSeen = n;\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (s.charAt(i) == CANDLE)\\n                lastSeen = i;\\n\\n            output[i] = lastSeen;\\n        }\\n\\n        return output;\\n    }\\n}\\n```\\n\\n# Python Solution\\n\\n```\\nfrom itertools import accumulate\\n\\nCANDLE = \\'|\\'\\n\\n\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, Q: list[list[int]]) -> list[int]:\\n        A = [int(c == CANDLE) for c in s]\\n\\n        T = [*accumulate(A)]\\n        R = self.nearest_candle_in_right(A)\\n        L = self.nearest_candle_in_left(A)\\n\\n        output = []\\n\\n        for a, b in Q:\\n            a, b = R[a], L[b]\\n\\n            if a > b:\\n                output.append(0)\\n            else:\\n                output.append((b - T[b]) - (a - T[a]))\\n\\n        return output\\n\\n    @staticmethod\\n    def nearest_candle_in_left(A: list[int]) -> list[int]:\\n        n = len(A)\\n\\n        last_seen_1 = -1\\n        output = [0] * n\\n\\n        for i, a in enumerate(A):\\n            if a:\\n                last_seen_1 = i\\n            \\n            output[i] = last_seen_1\\n\\n        return output\\n\\n    @staticmethod\\n    def nearest_candle_in_right(A: list[int]) -> list[int]:\\n        n = len(A)\\n\\n        last_seen_1 = n\\n        output = [0] * n\\n\\n        for i in range(n)[::-1]:\\n            if A[i]:\\n                last_seen_1 = i\\n\\n            output[i] = last_seen_1\\n\\n        return output\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nimport static java.util.Arrays.parallelPrefix;\\n\\nclass Solution {\\n    private static final char CANDLE = \\'|\\';\\n\\n    public int[] platesBetweenCandles(String s, int[][] Q) {\\n        int[] T = cumulativeCandles(s);\\n        int[] R = nearestCandleInRight(s), L = nearestCandleInLeft(s);\\n\\n        int[] output = new int[Q.length];\\n\\n        for (int i = 0; i < Q.length; i++) {\\n            int a = Q[i][0], b = Q[i][1];\\n\\n            a = R[a];\\n            b = L[b];\\n\\n            output[i] = a > b ? 0 : (b - T[b]) - (a - T[a]);\\n        }\\n\\n        return output;\\n    }\\n\\n    private static int[] cumulativeCandles(String s) {\\n        int[] output = s.chars()\\n                .map(c -> c == CANDLE ? 1 : 0)\\n                .toArray();\\n\\n        parallelPrefix(output, Integer::sum);\\n\\n        return output;\\n\\n    }\\n\\n    private static int[] nearestCandleInLeft(String s) {\\n        int n = s.length();\\n\\n        int[] output = new int[n];\\n        int lastSeen = -1;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) == CANDLE)\\n                lastSeen = i;\\n\\n            output[i] = lastSeen;\\n        }\\n\\n        return output;\\n    }\\n\\n    private static int[] nearestCandleInRight(String s) {\\n        int n = s.length();\\n\\n        int[] output = new int[n];\\n        int lastSeen = n;\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (s.charAt(i) == CANDLE)\\n                lastSeen = i;\\n\\n            output[i] = lastSeen;\\n        }\\n\\n        return output;\\n    }\\n}\\n```\n```\\nfrom itertools import accumulate\\n\\nCANDLE = \\'|\\'\\n\\n\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, Q: list[list[int]]) -> list[int]:\\n        A = [int(c == CANDLE) for c in s]\\n\\n        T = [*accumulate(A)]\\n        R = self.nearest_candle_in_right(A)\\n        L = self.nearest_candle_in_left(A)\\n\\n        output = []\\n\\n        for a, b in Q:\\n            a, b = R[a], L[b]\\n\\n            if a > b:\\n                output.append(0)\\n            else:\\n                output.append((b - T[b]) - (a - T[a]))\\n\\n        return output\\n\\n    @staticmethod\\n    def nearest_candle_in_left(A: list[int]) -> list[int]:\\n        n = len(A)\\n\\n        last_seen_1 = -1\\n        output = [0] * n\\n\\n        for i, a in enumerate(A):\\n            if a:\\n                last_seen_1 = i\\n            \\n            output[i] = last_seen_1\\n\\n        return output\\n\\n    @staticmethod\\n    def nearest_candle_in_right(A: list[int]) -> list[int]:\\n        n = len(A)\\n\\n        last_seen_1 = n\\n        output = [0] * n\\n\\n        for i in range(n)[::-1]:\\n            if A[i]:\\n                last_seen_1 = i\\n\\n            output[i] = last_seen_1\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978435,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int result[]=new int[queries.length];\\n        ArrayList<Integer> l=new ArrayList<Integer>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'|\\')\\n            {\\n                l.add(i);\\n            }\\n        }\\n        if(l.size()==0)\\n        {\\n            return result;\\n        }\\n        int pref[]=new int[l.size()];\\n        int sum=0;\\n        pref[0]=0;\\n        for(int i=1;i<l.size();i++)\\n        {\\n           sum+=l.get(i)-l.get(i-1)-1;\\n           pref[i]=sum;\\n        }\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int left=queries[i][0];\\n            int right=queries[i][1];\\n            int low=0,high=l.size()-1,leftIndex=0,rightIndex=0;\\n            while(low<=high)\\n            {\\n                int mid=(low+high)/2;\\n                if(l.get(mid)>left)\\n                {\\n                    leftIndex=mid;\\n                    high=mid-1;\\n                }\\n                else if(l.get(mid)==left)\\n                {\\n                    leftIndex=mid;\\n                    break;\\n                }\\n                else\\n                {\\n                    leftIndex=mid+1;\\n                    low=mid+1;\\n                }\\n            }\\n            low=0;\\n            high=l.size()-1;\\n            while(low<=high)\\n            {\\n                int mid=(low+high)/2;\\n                if(l.get(mid)>right)\\n                {\\n                    rightIndex=mid-1;\\n                    high=mid-1;\\n                }\\n                else if(l.get(mid)==right)\\n                {\\n                    rightIndex=mid;\\n                    break;\\n                }\\n                else\\n                {\\n                    rightIndex=mid;\\n                    low=mid+1;\\n                }\\n            }\\n            if(leftIndex<=rightIndex)\\n            {\\n                result[i]=pref[rightIndex]-pref[leftIndex];\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int result[]=new int[queries.length];\\n        ArrayList<Integer> l=new ArrayList<Integer>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'|\\')\\n            {\\n                l.add(i);\\n            }\\n        }\\n        if(l.size()==0)\\n        {\\n            return result;\\n        }\\n        int pref[]=new int[l.size()];\\n        int sum=0;\\n        pref[0]=0;\\n        for(int i=1;i<l.size();i++)\\n        {\\n           sum+=l.get(i)-l.get(i-1)-1;\\n           pref[i]=sum;\\n        }\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int left=queries[i][0];\\n            int right=queries[i][1];\\n            int low=0,high=l.size()-1,leftIndex=0,rightIndex=0;\\n            while(low<=high)\\n            {\\n                int mid=(low+high)/2;\\n                if(l.get(mid)>left)\\n                {\\n                    leftIndex=mid;\\n                    high=mid-1;\\n                }\\n                else if(l.get(mid)==left)\\n                {\\n                    leftIndex=mid;\\n                    break;\\n                }\\n                else\\n                {\\n                    leftIndex=mid+1;\\n                    low=mid+1;\\n                }\\n            }\\n            low=0;\\n            high=l.size()-1;\\n            while(low<=high)\\n            {\\n                int mid=(low+high)/2;\\n                if(l.get(mid)>right)\\n                {\\n                    rightIndex=mid-1;\\n                    high=mid-1;\\n                }\\n                else if(l.get(mid)==right)\\n                {\\n                    rightIndex=mid;\\n                    break;\\n                }\\n                else\\n                {\\n                    rightIndex=mid;\\n                    low=mid+1;\\n                }\\n            }\\n            if(leftIndex<=rightIndex)\\n            {\\n                result[i]=pref[rightIndex]-pref[leftIndex];\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960324,
                "title": "simple-js",
                "content": "\\n# Approach\\nfind all delimiter positions and save number of items before each delimiter, then just find nearest delimiter for each query and calculate number of items between them (with some corner cases)\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar platesBetweenCandles = function(s, queries) {\\n    const results = [];\\n\\tconst left = Array(s.length).fill(0);\\n\\tconst items = new Set();\\n\\tlet j = 0;\\n\\n\\tfor(let i = 0; i < s.length; i++) {\\n\\t\\tif (s[i] === \\'|\\') {\\n\\t\\t\\titems.add(i); // Save where items placed\\n\\t\\t\\tleft[i] = j; // Save latest number of items\\n\\t\\t} else {\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t}\\n\\n\\tconst tmp = [...items]\\n\\n\\tfor(let i = 0; i < queries.length; i++) {\\n\\t\\tconst end = queries[i][1];\\n\\t\\tconst start = queries[i][0];\\n\\n        // Now we need to set real index\\n\\t\\tlet endIndex = end;\\n\\t\\tif(!items.has(endIndex)) { // If endIndex is not on delimiter position, then go to nearest delimiter position (left side)\\n\\t\\t\\tfor(let i = tmp.length - 1; i >= 0; i--) { \\n\\t\\t\\t\\tif (tmp[i] <= end) {\\n\\t\\t\\t\\t\\tendIndex = tmp[i];\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tlet startIndex = start;\\n        // We can do here while, but it freaking slow on big data\\n\\t\\tif(!items.has(startIndex)) {\\n\\t\\t\\t// If startIndex is not on delimiter position, then go to nearest delimiter position (right side)\\n\\t\\t\\tfor(let v of tmp) { \\n\\t\\t\\t\\tif (v >= start) {\\n\\t\\t\\t\\t\\tstartIndex = v;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// If we have startIndex > endIndex, then we have no delimiter between them\\n\\t\\tif(endIndex < startIndex) {\\n\\t\\t\\tresults.push(0);\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tif (endIndex < 0 || startIndex >= s.length) {\\n\\t\\t\\tresults.push(0);\\n\\t\\t} else {\\n\\t\\t\\tif(left[endIndex] - left[startIndex] < 0) {\\n\\t\\t\\t\\tresults.push(0);\\n\\t\\t\\t} else \\n\\t\\t\\t\\tresults.push(left[endIndex] - left[startIndex]);\\n\\t\\t}\\n\\t}\\n\\n    return results;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar platesBetweenCandles = function(s, queries) {\\n    const results = [];\\n\\tconst left = Array(s.length).fill(0);\\n\\tconst items = new Set();\\n\\tlet j = 0;\\n\\n\\tfor(let i = 0; i < s.length; i++) {\\n\\t\\tif (s[i] === \\'|\\') {\\n\\t\\t\\titems.add(i); // Save where items placed\\n\\t\\t\\tleft[i] = j; // Save latest number of items\\n\\t\\t} else {\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t}\\n\\n\\tconst tmp = [...items]\\n\\n\\tfor(let i = 0; i < queries.length; i++) {\\n\\t\\tconst end = queries[i][1];\\n\\t\\tconst start = queries[i][0];\\n\\n        // Now we need to set real index\\n\\t\\tlet endIndex = end;\\n\\t\\tif(!items.has(endIndex)) { // If endIndex is not on delimiter position, then go to nearest delimiter position (left side)\\n\\t\\t\\tfor(let i = tmp.length - 1; i >= 0; i--) { \\n\\t\\t\\t\\tif (tmp[i] <= end) {\\n\\t\\t\\t\\t\\tendIndex = tmp[i];\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tlet startIndex = start;\\n        // We can do here while, but it freaking slow on big data\\n\\t\\tif(!items.has(startIndex)) {\\n\\t\\t\\t// If startIndex is not on delimiter position, then go to nearest delimiter position (right side)\\n\\t\\t\\tfor(let v of tmp) { \\n\\t\\t\\t\\tif (v >= start) {\\n\\t\\t\\t\\t\\tstartIndex = v;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// If we have startIndex > endIndex, then we have no delimiter between them\\n\\t\\tif(endIndex < startIndex) {\\n\\t\\t\\tresults.push(0);\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tif (endIndex < 0 || startIndex >= s.length) {\\n\\t\\t\\tresults.push(0);\\n\\t\\t} else {\\n\\t\\t\\tif(left[endIndex] - left[startIndex] < 0) {\\n\\t\\t\\t\\tresults.push(0);\\n\\t\\t\\t} else \\n\\t\\t\\t\\tresults.push(left[endIndex] - left[startIndex]);\\n\\t\\t}\\n\\t}\\n\\n    return results;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3945585,
                "title": "easy-finding-plates-between-candles-using-c",
                "content": "# Intuition \\uD83E\\uDD14\\nImagine you have a table with plates and candles on it. Each plate is represented by `*` and each candle by `|`. You need to count the number of `*` characters between two `|` candles for different queries. To do this efficiently, let\\'s find the positions of the candles first and then count the `*` characters between them for each query.\\n\\n# Approach \\uD83D\\uDE80\\n\\uD83D\\uDD6F\\uFE0F First, let\\'s find the positions of the candles. Loop through the string and remember where each `|` candle is placed. Store these positions in a vector v.\\n\\n\\uD83C\\uDF7D\\uFE0F For each query, we\\'ll use binary search to find the nearest left and right candles within the query range. This will help us locate the plates surrounded by candles.\\n\\n\\uD83C\\uDF7D\\uFE0F If we find valid candles on both sides, count the `*` characters between them. For this, iterate through the string between the candles and count the `*` characters.\\n\\n\\uD83D\\uDCCA Store the count for each query in the ans vector.\\n\\n\\uD83C\\uDF89 Finally, return the ans vector containing the results for each query.\\n\\n# Complexity \\uD83D\\uDCCA\\n- Time Complexity: Since we go through the input string once to find candle positions, and then through each query\\'s range once, the overall time complexity is O(n + q), where n is the length of the input string and q is the number of queries.:\\n\\n\\n- Space Complexity: We use extra space to store candle positions and the answer vector, so the space complexity is O(n + q).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        vector<int> v; // Store candle positions\\n\\n        // Find candle positions\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'|\\') {\\n                v.push_back(i);\\n            }\\n        }\\n\\n        vector<int> ans(queries.size(), 0);\\n\\n        for (int i = 0; i < queries.size(); i++) {\\n            auto x = lower_bound(v.begin(), v.end(), queries[i][0]);\\n            auto y = lower_bound(v.begin(), v.end(), queries[i][1]);\\n\\n            if (v.size() == 0) break;\\n            \\n            if (y == v.end()) y--;\\n            else if (*y != queries[i][1]) y--;\\n\\n            if (x == v.end() || x >= y) continue;\\n\\n            ans[i] = (*y - *x - 1 - (y - x - 1));\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        vector<int> v; // Store candle positions\\n\\n        // Find candle positions\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'|\\') {\\n                v.push_back(i);\\n            }\\n        }\\n\\n        vector<int> ans(queries.size(), 0);\\n\\n        for (int i = 0; i < queries.size(); i++) {\\n            auto x = lower_bound(v.begin(), v.end(), queries[i][0]);\\n            auto y = lower_bound(v.begin(), v.end(), queries[i][1]);\\n\\n            if (v.size() == 0) break;\\n            \\n            if (y == v.end()) y--;\\n            else if (*y != queries[i][1]) y--;\\n\\n            if (x == v.end() || x >= y) continue;\\n\\n            ans[i] = (*y - *x - 1 - (y - x - 1));\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938460,
                "title": "prefix-sum-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& quer) {\\n        vector<int> ans;\\n        int n = s.length();\\n        vector<int> lol(n, 0);\\n        int i=0;\\n        int curr = 0;\\n        int cnt = 0;\\n        while(i < n && s[i] == \\'*\\'){\\n            lol[i++] = curr;\\n        }\\n        while(i<n){\\n            while(i <  n && s[i] == \\'|\\'){\\n                lol[i++] = curr;\\n            }\\n            while(i < n && s[i] == \\'*\\'){\\n                cnt++;\\n                lol[i++] = curr;\\n            }\\n            if(i < n && s[i] == \\'|\\')lol[i] = cnt;\\n            curr = cnt;\\n            i++;\\n        }\\n\\n        // for(auto it: lol){\\n        //     cout<<it<<\" \";\\n        // }cout<<endl;\\n\\n        vector<int> v;\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'|\\'){\\n                v.push_back(i);\\n            }\\n        }\\n\\n        for(int i=0; i<quer.size(); i++){\\n            if(quer[i][0] == quer[i][1] || v.size() == 0){\\n                ans.push_back(0);\\n                continue;\\n            }\\n            int a = lower_bound(v.begin(), v.end(),  quer[i][0])-v.begin();\\n            int b= lower_bound(v.begin(), v.end(),  quer[i][1])-v.begin();\\n            if(v[b] != quer[i][1])b--;\\n            // cout<<a<<\" \"<<b<<endl;\\n            auto diff = lol[v[b]] - lol[v[a]];\\n            if(diff < 0)diff =0;\\n            ans.push_back(diff);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& quer) {\\n        vector<int> ans;\\n        int n = s.length();\\n        vector<int> lol(n, 0);\\n        int i=0;\\n        int curr = 0;\\n        int cnt = 0;\\n        while(i < n && s[i] == \\'*\\'){\\n            lol[i++] = curr;\\n        }\\n        while(i<n){\\n            while(i <  n && s[i] == \\'|\\'){\\n                lol[i++] = curr;\\n            }\\n            while(i < n && s[i] == \\'*\\'){\\n                cnt++;\\n                lol[i++] = curr;\\n            }\\n            if(i < n && s[i] == \\'|\\')lol[i] = cnt;\\n            curr = cnt;\\n            i++;\\n        }\\n\\n        // for(auto it: lol){\\n        //     cout<<it<<\" \";\\n        // }cout<<endl;\\n\\n        vector<int> v;\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'|\\'){\\n                v.push_back(i);\\n            }\\n        }\\n\\n        for(int i=0; i<quer.size(); i++){\\n            if(quer[i][0] == quer[i][1] || v.size() == 0){\\n                ans.push_back(0);\\n                continue;\\n            }\\n            int a = lower_bound(v.begin(), v.end(),  quer[i][0])-v.begin();\\n            int b= lower_bound(v.begin(), v.end(),  quer[i][1])-v.begin();\\n            if(v[b] != quer[i][1])b--;\\n            // cout<<a<<\" \"<<b<<endl;\\n            auto diff = lol[v[b]] - lol[v[a]];\\n            if(diff < 0)diff =0;\\n            ans.push_back(diff);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3925494,
                "title": "c-simple-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries)\\n    {\\n        vector<int> plat;\\n        for(int i=0;i<s.size();i++){if(s[i]==\\'|\\'){plat.push_back(i);}}\\n        int m = plat.size();\\n        if(m<=1){vector<int> ans(queries.size(),0);return ans;}\\n        vector<int> pf(m,0);\\n        for(int i=1;i<m;i++){pf[i]=pf[i-1]+plat[i]-plat[i-1]-1;}\\n        int n = queries.size();\\n        vector<int> ans(n, 0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int l1 = 0;\\n            int r1 = m-1;\\n            while(l1<r1)\\n            {\\n                int m1 = l1+(r1-l1)/2;\\n                if(plat[m1]>=queries[i][0]){r1=m1;}\\n                else{l1=m1+1;}\\n            }\\n            int l2 = 0;\\n            int r2 = m;\\n            while(l2<r2)\\n            {\\n                int m2 = l2+(r2-l2)/2;\\n                if(plat[m2]>queries[i][1]){r2=m2;}\\n                else{l2=m2+1;}\\n            }\\n            l2--;\\n            if(l1<l2){ans[i]=pf[l2]-pf[l1];}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries)\\n    {\\n        vector<int> plat;\\n        for(int i=0;i<s.size();i++){if(s[i]==\\'|\\'){plat.push_back(i);}}\\n        int m = plat.size();\\n        if(m<=1){vector<int> ans(queries.size(),0);return ans;}\\n        vector<int> pf(m,0);\\n        for(int i=1;i<m;i++){pf[i]=pf[i-1]+plat[i]-plat[i-1]-1;}\\n        int n = queries.size();\\n        vector<int> ans(n, 0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int l1 = 0;\\n            int r1 = m-1;\\n            while(l1<r1)\\n            {\\n                int m1 = l1+(r1-l1)/2;\\n                if(plat[m1]>=queries[i][0]){r1=m1;}\\n                else{l1=m1+1;}\\n            }\\n            int l2 = 0;\\n            int r2 = m;\\n            while(l2<r2)\\n            {\\n                int m2 = l2+(r2-l2)/2;\\n                if(plat[m2]>queries[i][1]){r2=m2;}\\n                else{l2=m2+1;}\\n            }\\n            l2--;\\n            if(l1<l2){ans[i]=pf[l2]-pf[l1];}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910768,
                "title": "java-simple-and-clean-code",
                "content": "# Approach\\n1. Traverse the string and use an int[3][s.length] to mark the leftMost/rightMose and count of plates.\\n2. For a given query [L,R] , find the closest candle at the right of L and the closest candle at the left of R. (x1, x2)/\\n3. Thus, your x1,x2 is the interval that is cornered by 2 plates. \\n4. Add few checks for x1,x2 EG: x1==x2 or x2<x1 or x1 == -1 or x2 == -1 (no left,right plate)\\n5. Knowing the prefixSum of plates, determine the difference between prefixSum[x2] - prefixSum[x1-1]. \\n\\n# Complexity\\n- Time complexity:$$O(n + q)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(3 * n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int[][] posAndNumberOfCandles = getPosAndNumberOfCandles(s);\\n        int[] answer = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            answer[i] = answerQuery(posAndNumberOfCandles, queries[i][0], queries[i][1]);\\n        }\\n        return answer;\\n    }\\n\\n    private int answerQuery(int[][] posAndNumberOfCandles, int leftQuery, int rightQuery) {\\n        int firstCandleOnLeft = posAndNumberOfCandles[1][leftQuery];\\n        int lastCandleOnRight = posAndNumberOfCandles[0][rightQuery];\\n        if (firstCandleOnLeft == -1 || lastCandleOnRight == -1 || lastCandleOnRight <= firstCandleOnLeft\\n            || lastCandleOnRight > rightQuery || firstCandleOnLeft < leftQuery) {\\n            return 0;\\n        }\\n        int validInterval = (lastCandleOnRight - firstCandleOnLeft) + 1;\\n        int candleCount = posAndNumberOfCandles[2][lastCandleOnRight] - (firstCandleOnLeft == 0 ? 0 : posAndNumberOfCandles[2][firstCandleOnLeft - 1]);\\n        return validInterval - candleCount;\\n    }\\n\\n    private int[][] getPosAndNumberOfCandles(String s) {\\n        int[][] posAndNumberOfCandles = new int[3][s.length()];\\n        char left, right;\\n        int i = 0, j = s.length() - 1;\\n        posAndNumberOfCandles[0][0] = -1;\\n        posAndNumberOfCandles[1][j] = -1;\\n        if (s.charAt(i) == \\'|\\') {\\n            posAndNumberOfCandles[0][0] = 0;\\n            posAndNumberOfCandles[2][0] = 1;\\n        }\\n        if (s.charAt(j) == \\'|\\') {\\n            posAndNumberOfCandles[1][j] = j;\\n            posAndNumberOfCandles[2][j] = 1;\\n        }\\n        while(++i < s.length()) {\\n            j--;\\n            left = s.charAt(i);\\n            right = s.charAt(j);\\n            posAndNumberOfCandles[0][i] = left == \\'|\\' ? i : posAndNumberOfCandles[0][i-1];\\n            posAndNumberOfCandles[1][j] = right == \\'|\\' ? j : posAndNumberOfCandles[1][j+1];\\n            posAndNumberOfCandles[2][i] = left == \\'|\\' ? posAndNumberOfCandles[2][i-1] + 1: posAndNumberOfCandles[2][i-1];\\n        }\\n        return posAndNumberOfCandles;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int[][] posAndNumberOfCandles = getPosAndNumberOfCandles(s);\\n        int[] answer = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            answer[i] = answerQuery(posAndNumberOfCandles, queries[i][0], queries[i][1]);\\n        }\\n        return answer;\\n    }\\n\\n    private int answerQuery(int[][] posAndNumberOfCandles, int leftQuery, int rightQuery) {\\n        int firstCandleOnLeft = posAndNumberOfCandles[1][leftQuery];\\n        int lastCandleOnRight = posAndNumberOfCandles[0][rightQuery];\\n        if (firstCandleOnLeft == -1 || lastCandleOnRight == -1 || lastCandleOnRight <= firstCandleOnLeft\\n            || lastCandleOnRight > rightQuery || firstCandleOnLeft < leftQuery) {\\n            return 0;\\n        }\\n        int validInterval = (lastCandleOnRight - firstCandleOnLeft) + 1;\\n        int candleCount = posAndNumberOfCandles[2][lastCandleOnRight] - (firstCandleOnLeft == 0 ? 0 : posAndNumberOfCandles[2][firstCandleOnLeft - 1]);\\n        return validInterval - candleCount;\\n    }\\n\\n    private int[][] getPosAndNumberOfCandles(String s) {\\n        int[][] posAndNumberOfCandles = new int[3][s.length()];\\n        char left, right;\\n        int i = 0, j = s.length() - 1;\\n        posAndNumberOfCandles[0][0] = -1;\\n        posAndNumberOfCandles[1][j] = -1;\\n        if (s.charAt(i) == \\'|\\') {\\n            posAndNumberOfCandles[0][0] = 0;\\n            posAndNumberOfCandles[2][0] = 1;\\n        }\\n        if (s.charAt(j) == \\'|\\') {\\n            posAndNumberOfCandles[1][j] = j;\\n            posAndNumberOfCandles[2][j] = 1;\\n        }\\n        while(++i < s.length()) {\\n            j--;\\n            left = s.charAt(i);\\n            right = s.charAt(j);\\n            posAndNumberOfCandles[0][i] = left == \\'|\\' ? i : posAndNumberOfCandles[0][i-1];\\n            posAndNumberOfCandles[1][j] = right == \\'|\\' ? j : posAndNumberOfCandles[1][j+1];\\n            posAndNumberOfCandles[2][i] = left == \\'|\\' ? posAndNumberOfCandles[2][i-1] + 1: posAndNumberOfCandles[2][i-1];\\n        }\\n        return posAndNumberOfCandles;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869551,
                "title": "python-prefix-sum-solution-very-straight-forward-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor every given query there is the query boundary and the candle boundry within the query boundary. Only the latter matters. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every given query we consider three case. \\n1) query lies directly on two candles.\\n2) query lies on one candle and one plate.\\n3) query lies on two plates\\n\\nCase 1) can be directly solved by calculating the difference of prefix sums. Case 2) and 3) can be calculated by first getting the candle boundries and then calculate the difference of prefix sums of the candle boundaries.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        prefix = [0] * len(s)\\n        right_nei = [0] * len(s) # right side nearest candle\\n        left_nei = [0] * len(s) # left side nearest candle\\n\\n        cur_sum = 0\\n        for i, ch in enumerate(s):\\n            if ch == \"*\":\\n                cur_sum += 1\\n            prefix[i] = cur_sum\\n        \\n        last_candle = -1\\n        for i in range(len(s)):\\n            if s[i] == \"|\":\\n                last_candle = i\\n            left_nei[i] = last_candle\\n\\n        last_candle = len(s)\\n        for i in reversed(range(len(s))):\\n            if s[i] == \"|\":\\n                last_candle = i\\n            right_nei[i] = last_candle\\n        \\n        ans = []\\n        for start, end in queries:\\n            left, right = right_nei[start], left_nei[end]\\n            if (left == -1 or \\n                right == len(s) or\\n                right <= left):\\n                ans.append(0)\\n            else:\\n                ans.append(prefix[right] - prefix[left])\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        prefix = [0] * len(s)\\n        right_nei = [0] * len(s) # right side nearest candle\\n        left_nei = [0] * len(s) # left side nearest candle\\n\\n        cur_sum = 0\\n        for i, ch in enumerate(s):\\n            if ch == \"*\":\\n                cur_sum += 1\\n            prefix[i] = cur_sum\\n        \\n        last_candle = -1\\n        for i in range(len(s)):\\n            if s[i] == \"|\":\\n                last_candle = i\\n            left_nei[i] = last_candle\\n\\n        last_candle = len(s)\\n        for i in reversed(range(len(s))):\\n            if s[i] == \"|\":\\n                last_candle = i\\n            right_nei[i] = last_candle\\n        \\n        ans = []\\n        for start, end in queries:\\n            left, right = right_nei[start], left_nei[end]\\n            if (left == -1 or \\n                right == len(s) or\\n                right <= left):\\n                ans.append(0)\\n            else:\\n                ans.append(prefix[right] - prefix[left])\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853859,
                "title": "java-prefix-solution-clean",
                "content": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int[] res = new int[queries.length];\\n\\n        int[] platesRight = new int[s.length()];\\n        int[] candleLeft = new int[s.length()];\\n        int[] candleRight = new int[s.length()];\\n        int platesRightCount = 0;\\n        int candleRightPos = -1;\\n        int candleLeftPos = -1;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            int posEnd = s.length() - 1 - i;\\n            if (s.charAt(posEnd) == \\'*\\') {\\n                platesRightCount++;\\n            } else {\\n                candleRightPos = posEnd;\\n            }\\n\\n            if (s.charAt(i) == \\'|\\') {\\n                candleLeftPos = i;\\n            }\\n\\n            platesRight[posEnd] = platesRightCount;\\n            candleRight[posEnd] = candleRightPos;\\n            candleLeft[i] = candleLeftPos;\\n        }\\n\\n        for (int i = 0; i < queries.length; i++) {\\n            int left = candleRight[queries[i][0]];\\n            int right = candleLeft[queries[i][1]];\\n            \\n            if (left == -1 || right == -1) {\\n                continue;\\n            }\\n\\n            res[i] = Math.max(0, platesRight[left] - platesRight[right]);\\n        }\\n\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int[] res = new int[queries.length];\\n\\n        int[] platesRight = new int[s.length()];\\n        int[] candleLeft = new int[s.length()];\\n        int[] candleRight = new int[s.length()];\\n        int platesRightCount = 0;\\n        int candleRightPos = -1;\\n        int candleLeftPos = -1;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            int posEnd = s.length() - 1 - i;\\n            if (s.charAt(posEnd) == \\'*\\') {\\n                platesRightCount++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3834701,
                "title": "beats-100-of-submissions-simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain Running sum of #plates seen so far from the beginning. Also maintain sorted list of positions at which candles seen.\\n#plates between Range(start, end) = Sum(plates till last Candle in given range) - Sum(plates till first Candle in given Range)\\n\\n# Complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Time complexity: \\n#Queries=k\\n#StringSize=n\\nO(klogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        vector<int> candlePositions;\\n        vector<int> numPlates;\\n        int count=0;\\n        int i=0;\\n        while(i<s.size()) {\\n            if(s[i]==\\'|\\') {\\n                candlePositions.push_back(i);\\n                numPlates.push_back(count);\\n            } else count++;\\n            i++;\\n        }\\n        vector<int> solution(queries.size(),0);\\n        if(candlePositions.empty()) return solution;\\n        int index=0;\\n        for(auto&query:queries) {\\n            auto start=lower_bound(candlePositions.begin(),candlePositions.end(),query[0]);\\n            if(start==std::end(candlePositions) || *start<query[0] || *start>query[1]) { index++; continue;} \\n            auto end=lower_bound(candlePositions.begin(),candlePositions.end(),query[1]+1);\\n            end--; \\n            auto from=start-candlePositions.begin();\\n            auto to=end-candlePositions.begin();\\n            solution[index++]=numPlates[to]-numPlates[from];\\n        }\\n        return solution;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        vector<int> candlePositions;\\n        vector<int> numPlates;\\n        int count=0;\\n        int i=0;\\n        while(i<s.size()) {\\n            if(s[i]==\\'|\\') {\\n                candlePositions.push_back(i);\\n                numPlates.push_back(count);\\n            } else count++;\\n            i++;\\n        }\\n        vector<int> solution(queries.size(),0);\\n        if(candlePositions.empty()) return solution;\\n        int index=0;\\n        for(auto&query:queries) {\\n            auto start=lower_bound(candlePositions.begin(),candlePositions.end(),query[0]);\\n            if(start==std::end(candlePositions) || *start<query[0] || *start>query[1]) { index++; continue;} \\n            auto end=lower_bound(candlePositions.begin(),candlePositions.end(),query[1]+1);\\n            end--; \\n            auto from=start-candlePositions.begin();\\n            auto to=end-candlePositions.begin();\\n            solution[index++]=numPlates[to]-numPlates[from];\\n        }\\n        return solution;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799749,
                "title": "pre-sum-using-map",
                "content": "# Intuition\\npre sum\\n\\n# Approach\\nuse a map to track pre sum\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        map<int, int> m;\\n        int i = 0;\\n        int nq = queries.size();\\n        while (i < n && s[i] == \\'*\\') i++;\\n        if (i == n) return vector<int>(nq, 0);\\n        int r = n - 1;\\n        while (r >= i && s[r] == \\'*\\') r--;\\n        int c = 0;\\n        for (; i <= r; i++) {\\n            if (s[i] == \\'|\\') m[i] = c;\\n            else c++;\\n        }\\n        m[n] = c;\\n        \\n        vector<int> ret;\\n        ret.reserve(nq);\\n\\n        for (vector<int>& query : queries) {\\n            auto l = m.lower_bound(query[0]);\\n            auto r = prev(m.upper_bound(query[1])); \\n            ret.push_back(max(0, r->second - l->second));\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        map<int, int> m;\\n        int i = 0;\\n        int nq = queries.size();\\n        while (i < n && s[i] == \\'*\\') i++;\\n        if (i == n) return vector<int>(nq, 0);\\n        int r = n - 1;\\n        while (r >= i && s[r] == \\'*\\') r--;\\n        int c = 0;\\n        for (; i <= r; i++) {\\n            if (s[i] == \\'|\\') m[i] = c;\\n            else c++;\\n        }\\n        m[n] = c;\\n        \\n        vector<int> ret;\\n        ret.reserve(nq);\\n\\n        for (vector<int>& query : queries) {\\n            auto l = m.lower_bound(query[0]);\\n            auto r = prev(m.upper_bound(query[1])); \\n            ret.push_back(max(0, r->second - l->second));\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798197,
                "title": "simple-c-solution-o-n-q",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nprefix sum\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N+Q) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) to store prefixSum, index of left and right candle for each position\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.length();\\n        int prefixSum[n];\\n        pair<int,int> nearestCandle[n];\\n        int cumulativeCount = 0;\\n        int leftPos = -1;\\n        int rightPos = n;\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'|\\'){\\n                leftPos = i;\\n            }else{\\n                cumulativeCount++;\\n            }\\n            prefixSum[i] = cumulativeCount;\\n            nearestCandle[i].first = leftPos;\\n\\n             if(s[n-i-1] == \\'|\\'){\\n                rightPos = n-i-1;\\n            }\\n            nearestCandle[n-i-1].second = rightPos;\\n        }\\n       \\n\\n        vector<int> answers;\\n        for (auto &query : queries){\\n            int i = query[0];\\n            int j = query[1];\\n            int ci = nearestCandle[i].second; // nearest right candle\\n            int cj = nearestCandle[j].first; // nearest left candle\\n            int ans = 0;\\n            if(!(ci == -1 || cj == n || cj == -1 || ci == n || cj <= ci)){\\n                ans = prefixSum[cj] - prefixSum[ci];\\n            }\\n            answers.push_back(ans);\\n        }\\n        return answers;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.length();\\n        int prefixSum[n];\\n        pair<int,int> nearestCandle[n];\\n        int cumulativeCount = 0;\\n        int leftPos = -1;\\n        int rightPos = n;\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'|\\'){\\n                leftPos = i;\\n            }else{\\n                cumulativeCount++;\\n            }\\n            prefixSum[i] = cumulativeCount;\\n            nearestCandle[i].first = leftPos;\\n\\n             if(s[n-i-1] == \\'|\\'){\\n                rightPos = n-i-1;\\n            }\\n            nearestCandle[n-i-1].second = rightPos;\\n        }\\n       \\n\\n        vector<int> answers;\\n        for (auto &query : queries){\\n            int i = query[0];\\n            int j = query[1];\\n            int ci = nearestCandle[i].second; // nearest right candle\\n            int cj = nearestCandle[j].first; // nearest left candle\\n            int ans = 0;\\n            if(!(ci == -1 || cj == n || cj == -1 || ci == n || cj <= ci)){\\n                ans = prefixSum[cj] - prefixSum[ci];\\n            }\\n            answers.push_back(ans);\\n        }\\n        return answers;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785116,
                "title": "simple-java-clean-code-explained",
                "content": "# Approach\\n- Store the cumulative plates count in plates array in O(N) (Left to right)\\n- Instead of going Right to Left seperately to store the nearest right candle index , store it in a different array in the same loop with a variable to traverse from right\\n- Go over the queries array to find the difference for each query. \\n- As we store the cumulative plates sum at the appropriate candle index , it is easy to retrieve the cumulative plates sum at each candle index in O(1) \\n\\n# Complexity\\n- Time complexity:O(N) + O(Q)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n\\n        if (s == null || s.length() == 0 || queries.length == 0) {\\n            return new int[]{};\\n        }\\n\\n        int plates[] = new int[s.length()];\\n        int UBCandleIndexMap[] = new int[s.length()];\\n        int c=-1;\\n        int n = s.length()-1;\\n        int previousCandlePos = n;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'|\\')\\n            {\\n                c = c==-1?0:c;\\n                if(i-1>=0)\\n                plates[i] = plates[i-1] + c; \\n                c=0;\\n            }\\n            else\\n            {\\n                if(c>=0)\\n                {\\n                    c++;\\n                }\\n                if(i-1>=0)\\n                plates[i] = plates[i-1];\\n            }\\n            if(s.charAt(n)==\\'|\\')\\n            {\\n                previousCandlePos = n;\\n            }\\n            UBCandleIndexMap[n]=previousCandlePos;\\n            n--;\\n        }\\n        int result[] = new int[queries.length];\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            //end - lowerbound - stored automatically\\n            //start - upperbound\\n            int sindex = UBCandleIndexMap[queries[i][0]];\\n            int sum = plates[queries[i][1]] - plates[sindex];\\n            result[i] = sum<=0?0:sum;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n\\n        if (s == null || s.length() == 0 || queries.length == 0) {\\n            return new int[]{};\\n        }\\n\\n        int plates[] = new int[s.length()];\\n        int UBCandleIndexMap[] = new int[s.length()];\\n        int c=-1;\\n        int n = s.length()-1;\\n        int previousCandlePos = n;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'|\\')\\n            {\\n                c = c==-1?0:c;\\n                if(i-1>=0)\\n                plates[i] = plates[i-1] + c; \\n                c=0;\\n            }\\n            else\\n            {\\n                if(c>=0)\\n                {\\n                    c++;\\n                }\\n                if(i-1>=0)\\n                plates[i] = plates[i-1];\\n            }\\n            if(s.charAt(n)==\\'|\\')\\n            {\\n                previousCandlePos = n;\\n            }\\n            UBCandleIndexMap[n]=previousCandlePos;\\n            n--;\\n        }\\n        int result[] = new int[queries.length];\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            //end - lowerbound - stored automatically\\n            //start - upperbound\\n            int sindex = UBCandleIndexMap[queries[i][0]];\\n            int sum = plates[queries[i][1]] - plates[sindex];\\n            result[i] = sum<=0?0:sum;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782787,
                "title": "c-binary-search-prefix-sum",
                "content": "```\\nvector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n    int n = s.size();\\n    \\n    vector<int> candles;\\n    for (int i = 0; i < n; i++) {\\n        if (s[i] == \\'|\\') {\\n            candles.push_back(i);\\n        }\\n    }\\n    \\n    vector<int> ans;\\n    for (auto x : queries) {\\n        int i = lower_bound(candles.begin(), candles.end(), x[0]) - candles.begin();\\n        int j = upper_bound(candles.begin(), candles.end(), x[1]) - candles.begin() - 1;\\n        \\n        // (candles[j] - candles[i] + 1) -> total space b/w\\n        // (j - i + 1) -> total indexes/candles b/w i and j\\n        if (i < j) {\\n            ans.push_back(candles[j] - candles[i] - (j - i));    \\n        } else {\\n            ans.push_back(0);\\n        }\\n    }\\n    \\n    return ans;\\n}\\n```\\n```\\nvector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n    int n = s.size();\\n\\n    vector<int> pref(n + 1), left(n, -1), right(n, -1);\\n    for (int i = 0; i < n; i++) {\\n        pref[i + 1] = pref[i] + (s[i] == \\'*\\');\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        if (s[i] == \\'|\\') {\\n            left[i] = i;\\n        } else {\\n            if (i - 1 >= 0) left[i] = left[i - 1];\\n        }\\n    }\\n\\n    for (int i = n - 1; i >= 0; i--) {\\n        if (s[i] == \\'|\\') {\\n            right[i] = i;\\n        } else {\\n            if (i + 1 < n) right[i] = right[i + 1];\\n        }\\n    }\\n\\n    vector<int> ans;\\n    for (auto x : queries) {\\n        if (right[x[0]] == -1 || left[x[1]] == -1 || left[x[1]] < right[x[0]]) {\\n            ans.push_back(0);\\n        } else {\\n            ans.push_back(pref[left[x[1]]] - pref[right[x[0]]]);\\n        }\\n    }\\n\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nvector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n    int n = s.size();\\n    \\n    vector<int> candles;\\n    for (int i = 0; i < n; i++) {\\n        if (s[i] == \\'|\\') {\\n            candles.push_back(i);\\n        }\\n    }\\n    \\n    vector<int> ans;\\n    for (auto x : queries) {\\n        int i = lower_bound(candles.begin(), candles.end(), x[0]) - candles.begin();\\n        int j = upper_bound(candles.begin(), candles.end(), x[1]) - candles.begin() - 1;\\n        \\n        // (candles[j] - candles[i] + 1) -> total space b/w\\n        // (j - i + 1) -> total indexes/candles b/w i and j\\n        if (i < j) {\\n            ans.push_back(candles[j] - candles[i] - (j - i));    \\n        } else {\\n            ans.push_back(0);\\n        }\\n    }\\n    \\n    return ans;\\n}\\n```\n```\\nvector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n    int n = s.size();\\n\\n    vector<int> pref(n + 1), left(n, -1), right(n, -1);\\n    for (int i = 0; i < n; i++) {\\n        pref[i + 1] = pref[i] + (s[i] == \\'*\\');\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        if (s[i] == \\'|\\') {\\n            left[i] = i;\\n        } else {\\n            if (i - 1 >= 0) left[i] = left[i - 1];\\n        }\\n    }\\n\\n    for (int i = n - 1; i >= 0; i--) {\\n        if (s[i] == \\'|\\') {\\n            right[i] = i;\\n        } else {\\n            if (i + 1 < n) right[i] = right[i + 1];\\n        }\\n    }\\n\\n    vector<int> ans;\\n    for (auto x : queries) {\\n        if (right[x[0]] == -1 || left[x[1]] == -1 || left[x[1]] < right[x[0]]) {\\n            ans.push_back(0);\\n        } else {\\n            ans.push_back(pref[left[x[1]]] - pref[right[x[0]]]);\\n        }\\n    }\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3761636,
                "title": "java-ranges-treemap-easily-readable-and-explained",
                "content": "# Intuition\\nWe can store the ranges of plates.\\nFor every range which we capture from left to right we store:\\n- range begining idx\\n- number of plates in the range\\n- \\'prefix sum\\' - cumulative sum of the ranges on the left \\n\\n# Approach\\nWe need to store ranges in the TreeMap to run queries, for every query we query it just couple times: \\n- to get the range after the query from idx \\n- to get the range before query end idx\\n- from prefix sum we know the sum of plates on the left\\n- if the last range ends before the query end idx we count its number of plates\\n\\n# Complexity\\n- Time complexity:\\nO(N) to get through the string + O(N*log(N)) to build the TreeMap \\n\\nfor every query: O(Q*log(N)) where Q is number of queries\\n\\n- Space complexity:\\nO(N) for the TreeMap, result array we don\\'t count\\n\\n# Code\\n```\\nimport java.util.NavigableMap;\\n\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int leftCandleIdx = -1;\\n        NavigableMap<Integer,int[]> ranges = new TreeMap<>();\\n        int prefixSum = 0;\\n\\n        for(int i=0; i<s.length(); i++){\\n            boolean isCandle = s.charAt(i)==\\'|\\';\\n\\n            if(isCandle){\\n                if(leftCandleIdx > -1){\\n                    int rangeStartIdx = leftCandleIdx + 1;\\n                    int rangeCount = i - leftCandleIdx - 1;\\n                    ranges.put(rangeStartIdx, new int[]{rangeCount, prefixSum}); // previous ranges total\\n                    prefixSum += rangeCount;\\n                }\\n                leftCandleIdx = i;\\n            }\\n            else \\n                ; // plate, do nothing\\n        }\\n\\n        int[] result = new int[queries.length];\\n\\n        for(int i=0; i<queries.length; i++){\\n            int[] query = queries[i];\\n\\n            Integer firstRangeStartIdx = ranges.higherKey(query[0]);\\n            if(firstRangeStartIdx == null)\\n                continue;\\n\\n            int[] firstRange = ranges.get(firstRangeStartIdx);\\n\\n            Integer lastRangeStartIdx = ranges.lowerKey(query[1]);\\n            if(lastRangeStartIdx == null  ||  firstRangeStartIdx > lastRangeStartIdx)\\n                continue;\\n\\n            int[] lastRange = ranges.get(lastRangeStartIdx);\\n\\n            result[i] = lastRange[1] - firstRange[1] + (lastRangeStartIdx + lastRange[0] - 1 < query[1] ? lastRange[0] : 0);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.NavigableMap;\\n\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int leftCandleIdx = -1;\\n        NavigableMap<Integer,int[]> ranges = new TreeMap<>();\\n        int prefixSum = 0;\\n\\n        for(int i=0; i<s.length(); i++){\\n            boolean isCandle = s.charAt(i)==\\'|\\';\\n\\n            if(isCandle){\\n                if(leftCandleIdx > -1){\\n                    int rangeStartIdx = leftCandleIdx + 1;\\n                    int rangeCount = i - leftCandleIdx - 1;\\n                    ranges.put(rangeStartIdx, new int[]{rangeCount, prefixSum}); // previous ranges total\\n                    prefixSum += rangeCount;\\n                }\\n                leftCandleIdx = i;\\n            }\\n            else \\n                ; // plate, do nothing\\n        }\\n\\n        int[] result = new int[queries.length];\\n\\n        for(int i=0; i<queries.length; i++){\\n            int[] query = queries[i];\\n\\n            Integer firstRangeStartIdx = ranges.higherKey(query[0]);\\n            if(firstRangeStartIdx == null)\\n                continue;\\n\\n            int[] firstRange = ranges.get(firstRangeStartIdx);\\n\\n            Integer lastRangeStartIdx = ranges.lowerKey(query[1]);\\n            if(lastRangeStartIdx == null  ||  firstRangeStartIdx > lastRangeStartIdx)\\n                continue;\\n\\n            int[] lastRange = ranges.get(lastRangeStartIdx);\\n\\n            result[i] = lastRange[1] - firstRange[1] + (lastRangeStartIdx + lastRange[0] - 1 < query[1] ? lastRange[0] : 0);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745259,
                "title": "python-easy-solution-beats-99-6",
                "content": "# Intuition\\nFind the candle to the right of the start index and candle to the left of the end index. If the former is lesser than the latter, subtract the number of plates between the start index to end of array and between the end index to end of array\\n\\n# Complexity\\n- Time complexity:\\nO(n + m)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        n = len(s)\\n        left = [-1] * n\\n        right = [inf] * n\\n        plates = {}\\n        #Left Array\\n        if s[0] == \"|\": \\n            left[0] = 0\\n        for i in range(1, n):\\n            if s[i] == \"|\": \\n                left[i] = i\\n            else: \\n                left[i] = left[i-1]\\n        #Right Array\\n        if s[-1] == \"|\": \\n            right[-1] = n - 1\\n            plates[n-1] = 0\\n        for i in range(n - 2, -1 , -1):\\n            if s[i] == \"|\": \\n                right[i] = i\\n                plates[i] = n - i - 1 - len(plates)\\n            else:  \\n                right[i] = right[i + 1]\\n        #Calculate query results\\n        ans = [0] * len(queries)\\n        for i in range(len(queries)):\\n            start, end = queries[i]\\n            if right[start] < left[end]:\\n                ans[i] = plates[right[start]] - plates[left[end]]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        n = len(s)\\n        left = [-1] * n\\n        right = [inf] * n\\n        plates = {}\\n        #Left Array\\n        if s[0] == \"|\": \\n            left[0] = 0\\n        for i in range(1, n):\\n            if s[i] == \"|\": \\n                left[i] = i\\n            else: \\n                left[i] = left[i-1]\\n        #Right Array\\n        if s[-1] == \"|\": \\n            right[-1] = n - 1\\n            plates[n-1] = 0\\n        for i in range(n - 2, -1 , -1):\\n            if s[i] == \"|\": \\n                right[i] = i\\n                plates[i] = n - i - 1 - len(plates)\\n            else:  \\n                right[i] = right[i + 1]\\n        #Calculate query results\\n        ans = [0] * len(queries)\\n        for i in range(len(queries)):\\n            start, end = queries[i]\\n            if right[start] < left[end]:\\n                ans[i] = plates[right[start]] - plates[left[end]]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740197,
                "title": "go-prefix-binsearch-o-len-queries-log-n",
                "content": "\\n# Code\\n```\\nfunc lessOrEqual(candles []int, idx int) int {\\n\\tif len(candles) == 0 {\\n\\t\\treturn -1\\n\\t}\\n\\tl, r := 0, len(candles)-1\\n\\tfor l+1 < r {\\n\\t\\tmid := l + (r-l)/2\\n\\t\\tif candles[mid] < idx {\\n\\t\\t\\tl = mid\\n\\t\\t} else {\\n\\t\\t\\tr = mid\\n\\t\\t}\\n\\t}\\n\\tif candles[r] <= idx {\\n\\t\\treturn candles[r]\\n\\t}\\n\\tif candles[l] <= idx {\\n\\t\\treturn candles[l]\\n\\t}\\n\\treturn -1\\n}\\n\\nfunc upperOrEqual(candles []int, idx int) int {\\n\\tif len(candles) == 0 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tl, r := 0, len(candles)-1\\n\\tfor l+1 < r {\\n\\t\\tmid := l + (r-l)/2\\n\\t\\tif candles[mid] <= idx {\\n\\t\\t\\tl = mid\\n\\t\\t} else {\\n\\t\\t\\tr = mid\\n\\t\\t}\\n\\t}\\n\\n\\tif candles[l] >= idx {\\n\\t\\treturn candles[l]\\n\\t}\\n\\tif candles[r] >= idx {\\n\\t\\treturn candles[r]\\n\\t}\\n\\treturn -1\\n}\\n\\nfunc platesBetweenCandles(s string, queries [][]int) []int {\\n\\tprefixPlates := make([]int, len(s)+1)\\n\\tprefixPlates[0] = 0\\n\\tcandles := make([]int, 0, len(s))\\n\\tfor i := 1; i < len(prefixPlates); i++ {\\n\\t\\tprefixPlates[i] = prefixPlates[i-1]\\n\\t\\tif s[i-1] == \\'*\\' {\\n\\t\\t\\tprefixPlates[i]++\\n\\t\\t} else {\\n\\t\\t\\tcandles = append(candles, i-1)\\n\\t\\t}\\n\\t}\\n\\n\\tout := make([]int, 0, len(queries))\\n\\tfor _, query := range queries {\\n\\t\\tleft := upperOrEqual(candles, query[0])\\n\\t\\tright := lessOrEqual(candles, query[1])\\n\\t\\tif right == -1 || left == -1 || right <= left {\\n\\t\\t\\tout = append(out, 0)\\n\\t\\t} else {\\n\\t\\t\\tout = append(out, prefixPlates[right]-prefixPlates[left])\\n\\t\\t}\\n\\t}\\n\\treturn out\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc lessOrEqual(candles []int, idx int) int {\\n\\tif len(candles) == 0 {\\n\\t\\treturn -1\\n\\t}\\n\\tl, r := 0, len(candles)-1\\n\\tfor l+1 < r {\\n\\t\\tmid := l + (r-l)/2\\n\\t\\tif candles[mid] < idx {\\n\\t\\t\\tl = mid\\n\\t\\t} else {\\n\\t\\t\\tr = mid\\n\\t\\t}\\n\\t}\\n\\tif candles[r] <= idx {\\n\\t\\treturn candles[r]\\n\\t}\\n\\tif candles[l] <= idx {\\n\\t\\treturn candles[l]\\n\\t}\\n\\treturn -1\\n}\\n\\nfunc upperOrEqual(candles []int, idx int) int {\\n\\tif len(candles) == 0 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tl, r := 0, len(candles)-1\\n\\tfor l+1 < r {\\n\\t\\tmid := l + (r-l)/2\\n\\t\\tif candles[mid] <= idx {\\n\\t\\t\\tl = mid\\n\\t\\t} else {\\n\\t\\t\\tr = mid\\n\\t\\t}\\n\\t}\\n\\n\\tif candles[l] >= idx {\\n\\t\\treturn candles[l]\\n\\t}\\n\\tif candles[r] >= idx {\\n\\t\\treturn candles[r]\\n\\t}\\n\\treturn -1\\n}\\n\\nfunc platesBetweenCandles(s string, queries [][]int) []int {\\n\\tprefixPlates := make([]int, len(s)+1)\\n\\tprefixPlates[0] = 0\\n\\tcandles := make([]int, 0, len(s))\\n\\tfor i := 1; i < len(prefixPlates); i++ {\\n\\t\\tprefixPlates[i] = prefixPlates[i-1]\\n\\t\\tif s[i-1] == \\'*\\' {\\n\\t\\t\\tprefixPlates[i]++\\n\\t\\t} else {\\n\\t\\t\\tcandles = append(candles, i-1)\\n\\t\\t}\\n\\t}\\n\\n\\tout := make([]int, 0, len(queries))\\n\\tfor _, query := range queries {\\n\\t\\tleft := upperOrEqual(candles, query[0])\\n\\t\\tright := lessOrEqual(candles, query[1])\\n\\t\\tif right == -1 || left == -1 || right <= left {\\n\\t\\t\\tout = append(out, 0)\\n\\t\\t} else {\\n\\t\\t\\tout = append(out, prefixPlates[right]-prefixPlates[left])\\n\\t\\t}\\n\\t}\\n\\treturn out\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3716379,
                "title": "solotion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        prefix = [0]\\n        candles = []\\n        for i, ch in enumerate(s): \\n            if ch == \\'|\\': candles.append(i)\\n            if ch == \\'|\\': prefix.append(prefix[-1])\\n            else: prefix.append(prefix[-1] + 1)\\n        \\n        ans = []\\n        for x, y in queries: \\n            lo = bisect_left(candles, x)\\n            hi = bisect_right(candles, y) - 1\\n            if 0 <= hi and lo < len(candles) and lo <= hi: \\n                ans.append(prefix[candles[hi]+1] - prefix[candles[lo]])\\n            else: ans.append(0)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        prefix = [0]\\n        candles = []\\n        for i, ch in enumerate(s): \\n            if ch == \\'|\\': candles.append(i)\\n            if ch == \\'|\\': prefix.append(prefix[-1])\\n            else: prefix.append(prefix[-1] + 1)\\n        \\n        ans = []\\n        for x, y in queries: \\n            lo = bisect_left(candles, x)\\n            hi = bisect_right(candles, y) - 1\\n            if 0 <= hi and lo < len(candles) and lo <= hi: \\n                ans.append(prefix[candles[hi]+1] - prefix[candles[lo]])\\n            else: ans.append(0)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688784,
                "title": "prefix-sum-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        \\n        int m = queries.size();\\n        int n = s.size();\\n\\n        int pre[n + 1];\\n\\n        if(s[0]==\\'*\\')pre[0] = 1;\\n        else pre[0] = 0;\\n\\n        for(int i = 1; i < n; i++) {\\n            if(s[i] == \\'*\\') pre[i] = pre[i - 1] + 1;\\n            else pre[i] = pre[i - 1];\\n        }\\n\\n        vector<int>poss;\\n        vector<int>ans;\\n\\n\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'|\\')\\n            poss.push_back(i);\\n        }\\n\\n        // for(auto it : poss)cout<<it<<\" \";\\n\\n        for(int k = 0 ; k < m; k++) {\\n            \\n            int i = queries[k][0];\\n            int j = queries[k][1];\\n\\n            int right = -1;\\n            \\n            int l = 0;\\n            int r = poss.size() - 1;\\n            while(l <= r) {\\n                int mid = l + (r - l)/2 ;\\n                if(poss[mid] > j) {\\n                    r = mid - 1;\\n                } else {\\n                    right = poss[mid];\\n                    l = mid + 1;\\n                }\\n            }\\n\\n\\n            int left = -1;\\n            l = 0;\\n            r = poss.size() - 1;\\n            while(l <= r) {\\n                int mid = l + (r - l)/2 ;\\n                if(poss[mid] < i) {\\n                    l = mid + 1;\\n                }else {\\n                    left = poss[mid];\\n                    r = mid - 1;\\n                }\\n            }\\n\\n            cout<<left<<\" \"<<right<<endl;\\n\\n\\n            if(left == -1 || right == -1 || (left == right) || (left > j) || (right < i)) {\\n                ans.push_back(0);\\n            } else {\\n                int val;\\n                if(left == 0) {\\n                    val = pre[right - 1];\\n                } else {\\n                    val = pre[right] - pre[left - 1];\\n                }\\n                ans.push_back(val);\\n            }\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        \\n        int m = queries.size();\\n        int n = s.size();\\n\\n        int pre[n + 1];\\n\\n        if(s[0]==\\'*\\')pre[0] = 1;\\n        else pre[0] = 0;\\n\\n        for(int i = 1; i < n; i++) {\\n            if(s[i] == \\'*\\') pre[i] = pre[i - 1] + 1;\\n            else pre[i] = pre[i - 1];\\n        }\\n\\n        vector<int>poss;\\n        vector<int>ans;\\n\\n\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'|\\')\\n            poss.push_back(i);\\n        }\\n\\n        // for(auto it : poss)cout<<it<<\" \";\\n\\n        for(int k = 0 ; k < m; k++) {\\n            \\n            int i = queries[k][0];\\n            int j = queries[k][1];\\n\\n            int right = -1;\\n            \\n            int l = 0;\\n            int r = poss.size() - 1;\\n            while(l <= r) {\\n                int mid = l + (r - l)/2 ;\\n                if(poss[mid] > j) {\\n                    r = mid - 1;\\n                } else {\\n                    right = poss[mid];\\n                    l = mid + 1;\\n                }\\n            }\\n\\n\\n            int left = -1;\\n            l = 0;\\n            r = poss.size() - 1;\\n            while(l <= r) {\\n                int mid = l + (r - l)/2 ;\\n                if(poss[mid] < i) {\\n                    l = mid + 1;\\n                }else {\\n                    left = poss[mid];\\n                    r = mid - 1;\\n                }\\n            }\\n\\n            cout<<left<<\" \"<<right<<endl;\\n\\n\\n            if(left == -1 || right == -1 || (left == right) || (left > j) || (right < i)) {\\n                ans.push_back(0);\\n            } else {\\n                int val;\\n                if(left == 0) {\\n                    val = pre[right - 1];\\n                } else {\\n                    val = pre[right] - pre[left - 1];\\n                }\\n                ans.push_back(val);\\n            }\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3672431,
                "title": "two-arrays-for-candles-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar platesBetweenCandles = function (s, queries) {\\n    let ansArray = [], platesArray = [], rightCandlesArray = [-1], leftCandlesArray = [s.length - 1];\\n\\n    let tempPlates = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \\'*\\') {\\n            tempPlates = tempPlates + 1;\\n            rightCandlesArray.push(rightCandlesArray[i])\\n        } else {\\n            rightCandlesArray.push(i)\\n        }\\n        if (s[s.length - (1 + i)] === \"|\") {\\n            leftCandlesArray.push(s.length - (1 + i))\\n        } else {\\n            leftCandlesArray.push(leftCandlesArray[i])\\n        }\\n        platesArray.push(tempPlates);\\n    }\\n    leftCandlesArray.sort((a, b) => { return a - b })\\n\\n    for (let i = 0; i < queries.length; i++) {\\n        let ta = 0;\\n        let r = rightCandlesArray[queries[i][1] + 1];\\n        let l = leftCandlesArray[queries[i][0]];\\n        let rp = platesArray[l];\\n        let lp = platesArray[r];\\n        if (r < 0 || lp - rp < 0) {\\n            ta = 0;\\n        } else {\\n            ta = lp - rp;\\n        }\\n        ansArray.push(ta);\\n    }\\n    return ansArray;\\n\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar platesBetweenCandles = function (s, queries) {\\n    let ansArray = [], platesArray = [], rightCandlesArray = [-1], leftCandlesArray = [s.length - 1];\\n\\n    let tempPlates = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === \\'*\\') {\\n            tempPlates = tempPlates + 1;\\n            rightCandlesArray.push(rightCandlesArray[i])\\n        } else {\\n            rightCandlesArray.push(i)\\n        }\\n        if (s[s.length - (1 + i)] === \"|\") {\\n            leftCandlesArray.push(s.length - (1 + i))\\n        } else {\\n            leftCandlesArray.push(leftCandlesArray[i])\\n        }\\n        platesArray.push(tempPlates);\\n    }\\n    leftCandlesArray.sort((a, b) => { return a - b })\\n\\n    for (let i = 0; i < queries.length; i++) {\\n        let ta = 0;\\n        let r = rightCandlesArray[queries[i][1] + 1];\\n        let l = leftCandlesArray[queries[i][0]];\\n        let rp = platesArray[l];\\n        let lp = platesArray[r];\\n        if (r < 0 || lp - rp < 0) {\\n            ta = 0;\\n        } else {\\n            ta = lp - rp;\\n        }\\n        ansArray.push(ta);\\n    }\\n    return ansArray;\\n\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3662213,
                "title": "easy-to-understand-binary-search-function-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        unordered_map<int, long long> m;\\n        vector<int> v;\\n        vector<int> ans;\\n        int x, y;\\n        long long sum = 0;\\n        for(int i=0; i<n; ++i){\\n            if(s[i] == \\'*\\'){\\n                sum += 1;\\n            }\\n            else{\\n                v.push_back(i);\\n                m[i] = sum;\\n            }\\n        }\\n        n = queries.size();\\n        for(int i=0; i<n; ++i){\\n            x = lower_bound(v.begin(), v.end(), queries[i][0]) - v.begin();\\n            y = upper_bound(v.begin(), v.end(), queries[i][1]) - v.begin();\\n            if(y > x){\\n                ans.push_back(m[v[y-1]]-m[v[x]]);\\n            }\\n            else{\\n                ans.push_back(0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        unordered_map<int, long long> m;\\n        vector<int> v;\\n        vector<int> ans;\\n        int x, y;\\n        long long sum = 0;\\n        for(int i=0; i<n; ++i){\\n            if(s[i] == \\'*\\'){\\n                sum += 1;\\n            }\\n            else{\\n                v.push_back(i);\\n                m[i] = sum;\\n            }\\n        }\\n        n = queries.size();\\n        for(int i=0; i<n; ++i){\\n            x = lower_bound(v.begin(), v.end(), queries[i][0]) - v.begin();\\n            y = upper_bound(v.begin(), v.end(), queries[i][1]) - v.begin();\\n            if(y > x){\\n                ans.push_back(m[v[y-1]]-m[v[x]]);\\n            }\\n            else{\\n                ans.push_back(0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635282,
                "title": "java-beat-100-using-only-array",
                "content": "# Intuition\\nThe point here is try to find the index of nearest candles in both two sides (two indexs of each queries). Then minus the amount of candles between them.\\n\\n# Approach\\n- Make 3 different arrays to memory, it is easily to make, so I will not explain.\\n\\n        * * * | * * | * * * *  *  |  *  *  |  |  *  *  |  *\\n        0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\\n    ```\\n    go[] : memory the index of the next nearest candle or itself:\\n        ex: go[1] = 3, go[6] = 6, go[10] = go[11] = 12,...\\n    back[]: memory the index of the previous nearest candle or itself\\n        ex : back[2] = 0, back[13] = back[12] = 12,...\\n    cans[]: memory the amount of candles from start:\\n        ex: cans[1] = 0, cans[14] = 3, cans[15] = 4,...\\n- So, we easily calculate the amount of plates in any range.\\n    ```\\n    queries[i]: [first, end]\\n        int f = go[first]; // nearest next candles\\n        int e = back[end]; // nearest prev candles\\n        int can = can[e] - can[f] + 1; // amount of candles include two sides\\n        \\n        result[i] = e - f - can;\\n# Complexity\\n- Time complexity:\\nO(2n+queries.length) ~ O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        char[] arr = s.toCharArray();\\n        int size = arr.length;\\n        int[] res = new int[queries.length];\\n\\n        int[] go = new int[size];\\n        int[] back = new int[size];\\n        int[] cans = new int[size];\\n\\n        go[size-1] = size-1;\\n        back[0] = 0;\\n        if (arr[0] == \\'*\\') cans[0] = 0;\\n        else cans[0] = 1;\\n\\n        for (int i = size-2; i >=0; i--) {\\n            if (arr[i] == \\'*\\' || (arr[i] == \\'|\\' && arr[i+1] == \\'|\\')) go[i] = go[i+1];\\n            else go[i] = i;\\n        }\\n\\n        for (int i = 1; i < size; i++) {\\n            if (arr[i] == \\'*\\' || (arr[i] == \\'|\\' && arr[i-1] == \\'|\\')) back[i] = back[i-1];\\n            else back[i] = i;\\n\\n            if (arr[i] == \\'*\\') cans[i] = cans[i-1];\\n            else cans[i] = cans[i-1] + 1;\\n        }\\n\\n        for (int i = 0; i < res.length; i++) {\\n            int first = go[queries[i][0]];\\n            int end = back[queries[i][1]];\\n            int t = end - first + 1 - (cans[end] - cans[first] + 1);\\n\\n            if (t < 0) t = 0;\\n            res[i] = t;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    go[] : memory the index of the next nearest candle or itself:\\n        ex: go[1] = 3, go[6] = 6, go[10] = go[11] = 12,...\\n    back[]: memory the index of the previous nearest candle or itself\\n        ex : back[2] = 0, back[13] = back[12] = 12,...\\n    cans[]: memory the amount of candles from start:\\n        ex: cans[1] = 0, cans[14] = 3, cans[15] = 4,...\\n- So, we easily calculate the amount of plates in any range.\\n    ```\n```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        char[] arr = s.toCharArray();\\n        int size = arr.length;\\n        int[] res = new int[queries.length];\\n\\n        int[] go = new int[size];\\n        int[] back = new int[size];\\n        int[] cans = new int[size];\\n\\n        go[size-1] = size-1;\\n        back[0] = 0;\\n        if (arr[0] == \\'*\\') cans[0] = 0;\\n        else cans[0] = 1;\\n\\n        for (int i = size-2; i >=0; i--) {\\n            if (arr[i] == \\'*\\' || (arr[i] == \\'|\\' && arr[i+1] == \\'|\\')) go[i] = go[i+1];\\n            else go[i] = i;\\n        }\\n\\n        for (int i = 1; i < size; i++) {\\n            if (arr[i] == \\'*\\' || (arr[i] == \\'|\\' && arr[i-1] == \\'|\\')) back[i] = back[i-1];\\n            else back[i] = i;\\n\\n            if (arr[i] == \\'*\\') cans[i] = cans[i-1];\\n            else cans[i] = cans[i-1] + 1;\\n        }\\n\\n        for (int i = 0; i < res.length; i++) {\\n            int first = go[queries[i][0]];\\n            int end = back[queries[i][1]];\\n            int t = end - first + 1 - (cans[end] - cans[first] + 1);\\n\\n            if (t < 0) t = 0;\\n            res[i] = t;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540424,
                "title": "java-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private int BinarySearch1(List<Integer> plates,int ele){\\n        int n = plates.size();\\n        int lo = 0;\\n        int hi = n-1;\\n\\n        int mid ;\\n        int idx = -1;\\n        while(lo<=hi){\\n            mid = lo+(hi-lo)/2;\\n            if(plates.get(mid) < ele){\\n                lo = mid+1;\\n            }\\n            else{\\n                hi = mid-1;\\n                idx = mid;\\n            }\\n        }\\n        if(idx == -1){\\n            return -1;\\n        }\\n\\n        return plates.get(idx);\\n    }\\n\\n\\n    private int BinarySearch2(List<Integer> plates, int ele){\\n        int n = plates.size();\\n        int lo = 0;\\n        int hi = n-1;\\n        int idx = -1;\\n        int mid ;\\n        while(lo<=hi){\\n            mid = lo+(hi-lo)/2;\\n            \\n            if(plates.get(mid) <= ele){\\n                idx = mid;\\n                lo = mid+1;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n        if(idx == -1){\\n            return -1;\\n        }\\n        return plates.get(idx);\\n    }\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int n = s.length();\\n        int[] pre = new int[n];\\n        List<Integer> plates = new ArrayList<>();\\n        if(s.charAt(0) == \\'*\\'){\\n            pre[0] = 1;\\n        }\\n        else{\\n            plates.add(0);\\n        }\\n        for(int i=1;i<n;i++){\\n            if(s.charAt(i) == \\'*\\'){\\n                pre[i] = pre[i-1]+1;\\n            }\\n            else{\\n                pre[i] = pre[i-1];\\n                plates.add(i);\\n            }\\n        }\\n        int[] ans = new int[queries.length];\\n        int j = 0;\\n        for(int[] q : queries){\\n            int l = BinarySearch1(plates,q[0]);\\n            int r = BinarySearch2(plates, q[1]);\\n            if(l < r && (l != -1 && r != -1)){\\n                System.out.println(l +\" \" + r);\\n                ans[j] = l == 0 ? pre[r] : (pre[r]-pre[l-1]);\\n            }\\n            else{\\n                System.out.println(\"Not Possible\");\\n            }\\n            \\n            j++;\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n/** \\n\\nplates = 3 6 12 15 16 19\\n\\n[7, 11]\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    private int BinarySearch1(List<Integer> plates,int ele){\\n        int n = plates.size();\\n        int lo = 0;\\n        int hi = n-1;\\n\\n        int mid ;\\n        int idx = -1;\\n        while(lo<=hi){\\n            mid = lo+(hi-lo)/2;\\n            if(plates.get(mid) < ele){\\n                lo = mid+1;\\n            }\\n            else{\\n                hi = mid-1;\\n                idx = mid;\\n            }\\n        }\\n        if(idx == -1){\\n            return -1;\\n        }\\n\\n        return plates.get(idx);\\n    }\\n\\n\\n    private int BinarySearch2(List<Integer> plates, int ele){\\n        int n = plates.size();\\n        int lo = 0;\\n        int hi = n-1;\\n        int idx = -1;\\n        int mid ;\\n        while(lo<=hi){\\n            mid = lo+(hi-lo)/2;\\n            \\n            if(plates.get(mid) <= ele){\\n                idx = mid;\\n                lo = mid+1;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n        if(idx == -1){\\n            return -1;\\n        }\\n        return plates.get(idx);\\n    }\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int n = s.length();\\n        int[] pre = new int[n];\\n        List<Integer> plates = new ArrayList<>();\\n        if(s.charAt(0) == \\'*\\'){\\n            pre[0] = 1;\\n        }\\n        else{\\n            plates.add(0);\\n        }\\n        for(int i=1;i<n;i++){\\n            if(s.charAt(i) == \\'*\\'){\\n                pre[i] = pre[i-1]+1;\\n            }\\n            else{\\n                pre[i] = pre[i-1];\\n                plates.add(i);\\n            }\\n        }\\n        int[] ans = new int[queries.length];\\n        int j = 0;\\n        for(int[] q : queries){\\n            int l = BinarySearch1(plates,q[0]);\\n            int r = BinarySearch2(plates, q[1]);\\n            if(l < r && (l != -1 && r != -1)){\\n                System.out.println(l +\" \" + r);\\n                ans[j] = l == 0 ? pre[r] : (pre[r]-pre[l-1]);\\n            }\\n            else{\\n                System.out.println(\"Not Possible\");\\n            }\\n            \\n            j++;\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n/** \\n\\nplates = 3 6 12 15 16 19\\n\\n[7, 11]\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529251,
                "title": "java-3-helper-arrays-are-all-you-needed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] qs) {\\n        int n = s.length();\\n        int left = 0, right = s.length() - 1;\\n        for (int i = 0; i < n; i++){\\n            if (s.charAt(i) == \\'|\\') {\\n                left = i;\\n                break;\\n            }\\n        }\\n        for (int i = n - 1; i >= 0; i--){\\n            if (s.charAt(i) == \\'|\\') {\\n                right = i;\\n                break;\\n            }\\n        }\\n        int[] res = new int[qs.length];\\n        if (left == right) return res;\\n\\n        int[] preSum = new int[n + 1];\\n        int[] preIndex = new int[n + 1];\\n        int[] sufIndex = new int[n + 1];\\n        preIndex[0] = left;\\n        sufIndex[n] = right;\\n        for (int i = 1; i < n + 1; i++){\\n            if (s.charAt(i - 1) == \\'|\\'){\\n                preSum[i] = preSum[i - 1];\\n                preIndex[i] = i - 1;\\n            } else {\\n                preSum[i] = preSum[i - 1] + 1;\\n                preIndex[i] = preIndex[i - 1];\\n            }\\n        }\\n        for (int i = n - 1; i >= 0; i--){\\n            if (s.charAt(i) == \\'*\\'){\\n                sufIndex[i] = sufIndex[i + 1];\\n            } else {\\n                sufIndex[i] = i;\\n            }\\n        }\\n        int k = 0;\\n        for (int[] q: qs){\\n            int l = q[0];\\n            int r = q[1] + 1;\\n            res[k++] = preSum[preIndex[r]] - preSum[sufIndex[l]] > 0?preSum[preIndex[r]] - preSum[sufIndex[l]]:0;\\n        }\\n        return res;\\n\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] qs) {\\n        int n = s.length();\\n        int left = 0, right = s.length() - 1;\\n        for (int i = 0; i < n; i++){\\n            if (s.charAt(i) == \\'|\\') {\\n                left = i;\\n                break;\\n            }\\n        }\\n        for (int i = n - 1; i >= 0; i--){\\n            if (s.charAt(i) == \\'|\\') {\\n                right = i;\\n                break;\\n            }\\n        }\\n        int[] res = new int[qs.length];\\n        if (left == right) return res;\\n\\n        int[] preSum = new int[n + 1];\\n        int[] preIndex = new int[n + 1];\\n        int[] sufIndex = new int[n + 1];\\n        preIndex[0] = left;\\n        sufIndex[n] = right;\\n        for (int i = 1; i < n + 1; i++){\\n            if (s.charAt(i - 1) == \\'|\\'){\\n                preSum[i] = preSum[i - 1];\\n                preIndex[i] = i - 1;\\n            } else {\\n                preSum[i] = preSum[i - 1] + 1;\\n                preIndex[i] = preIndex[i - 1];\\n            }\\n        }\\n        for (int i = n - 1; i >= 0; i--){\\n            if (s.charAt(i) == \\'*\\'){\\n                sufIndex[i] = sufIndex[i + 1];\\n            } else {\\n                sufIndex[i] = i;\\n            }\\n        }\\n        int k = 0;\\n        for (int[] q: qs){\\n            int l = q[0];\\n            int r = q[1] + 1;\\n            res[k++] = preSum[preIndex[r]] - preSum[sufIndex[l]] > 0?preSum[preIndex[r]] - preSum[sufIndex[l]]:0;\\n        }\\n        return res;\\n\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494317,
                "title": "c-binary-search-o-nlog-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& q) {\\n        vector<int> cnd;\\n        if(s[0]==\\'|\\') cnd.push_back(0);\\n        int n=s.size();\\n        vector<int> ans(q.size(),0);\\n        if(n<3) ans;\\n        vector<int> pre(n);\\n        pre[0]=(s[0]==\\'*\\')?1:0;\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1];\\n            if(s[i]==\\'*\\') pre[i]++;\\n            else cnd.push_back(i);\\n        }\\n        int m=cnd.size();\\n        if(m<2) return ans;\\n        for(int i=0;i<q.size();i++){\\n            int a=q[i][0];\\n            int b=q[i][1];\\n            int y=lower_bound(cnd.begin(),cnd.end(),b+1)-cnd.begin();\\n            if(y>0 && cnd[y-1]>=a){\\n                int x=lower_bound(cnd.begin(),cnd.end(),a)-cnd.begin();\\n                ans[i]=pre[cnd[y-1]]-pre[cnd[x]];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& q) {\\n        vector<int> cnd;\\n        if(s[0]==\\'|\\') cnd.push_back(0);\\n        int n=s.size();\\n        vector<int> ans(q.size(),0);\\n        if(n<3) ans;\\n        vector<int> pre(n);\\n        pre[0]=(s[0]==\\'*\\')?1:0;\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1];\\n            if(s[i]==\\'*\\') pre[i]++;\\n            else cnd.push_back(i);\\n        }\\n        int m=cnd.size();\\n        if(m<2) return ans;\\n        for(int i=0;i<q.size();i++){\\n            int a=q[i][0];\\n            int b=q[i][1];\\n            int y=lower_bound(cnd.begin(),cnd.end(),b+1)-cnd.begin();\\n            if(y>0 && cnd[y-1]>=a){\\n                int x=lower_bound(cnd.begin(),cnd.end(),a)-cnd.begin();\\n                ans[i]=pre[cnd[y-1]]-pre[cnd[x]];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481379,
                "title": "python3-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        \\n        indices=[]\\n        \\n        for i,ch in enumerate(s):\\n            if ch==\"|\":\\n                indices.append(i)\\n        \\n        ans=[]\\n        \\n        for a,b in queries:\\n            \\n            l=bisect_left(indices,a)\\n            \\n            r=bisect_right(indices,b)-1\\n            \\n            if l>=r:\\n                ans.append(0)\\n                continue\\n\\n            mid=r-l-1\\n            diff=indices[r]-indices[l]-1\\n            ans.append(diff-mid)\\n        \\n        return ans\\n            \\n            \\n            \\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        \\n        indices=[]\\n        \\n        for i,ch in enumerate(s):\\n            if ch==\"|\":\\n                indices.append(i)\\n        \\n        ans=[]\\n        \\n        for a,b in queries:\\n            \\n            l=bisect_left(indices,a)\\n            \\n            r=bisect_right(indices,b)-1\\n            \\n            if l>=r:\\n                ans.append(0)\\n                continue\\n\\n            mid=r-l-1\\n            diff=indices[r]-indices[l]-1\\n            ans.append(diff-mid)\\n        \\n        return ans\\n            \\n            \\n            \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464203,
                "title": "javascript-solution-o-n-time-complexity",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar platesBetweenCandles = function(s, queries) {\\n  debugger;\\n  let ans = [];\\n  let prefixSum = new Array(s.length).fill(0);\\n  let nearestContainerWall = new Array(s.length).fill(0);\\n  let containerOpen = false;\\n  let totalCount = 0;\\n  let tempCount = 0;\\n  for (let i = 0; i < s.length; i++) {\\n    if (s[i] == \\'|\\') {\\n      if (containerOpen) {\\n        totalCount += tempCount;\\n        tempCount = 0; // reset temp count\\n      } else {\\n        containerOpen = true;\\n      }\\n    } else if (containerOpen) {\\n      tempCount++;\\n    }\\n    prefixSum[i] = totalCount;\\n  }\\n\\n  let lastWallIndex = -1;\\n  for (let i = s.length - 1; i >= 0; i--) {\\n    if (s[i] == \\'|\\') {\\n      lastWallIndex = i;\\n    }\\n    nearestContainerWall[i] = lastWallIndex;\\n  }\\n\\n  for (let i = 0; i < queries.length; i++) {\\n    let startIndex = queries[i][0];\\n    let endIndex = queries[i][1];\\n    let nearestStart = nearestContainerWall[startIndex];\\n    if (nearestStart > endIndex || nearestStart == -1) {\\n      ans.push(0);\\n    } else {\\n      let val = prefixSum[endIndex] - prefixSum[nearestStart];\\n      ans.push(val);\\n    }\\n  }\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar platesBetweenCandles = function(s, queries) {\\n  debugger;\\n  let ans = [];\\n  let prefixSum = new Array(s.length).fill(0);\\n  let nearestContainerWall = new Array(s.length).fill(0);\\n  let containerOpen = false;\\n  let totalCount = 0;\\n  let tempCount = 0;\\n  for (let i = 0; i < s.length; i++) {\\n    if (s[i] == \\'|\\') {\\n      if (containerOpen) {\\n        totalCount += tempCount;\\n        tempCount = 0; // reset temp count\\n      } else {\\n        containerOpen = true;\\n      }\\n    } else if (containerOpen) {\\n      tempCount++;\\n    }\\n    prefixSum[i] = totalCount;\\n  }\\n\\n  let lastWallIndex = -1;\\n  for (let i = s.length - 1; i >= 0; i--) {\\n    if (s[i] == \\'|\\') {\\n      lastWallIndex = i;\\n    }\\n    nearestContainerWall[i] = lastWallIndex;\\n  }\\n\\n  for (let i = 0; i < queries.length; i++) {\\n    let startIndex = queries[i][0];\\n    let endIndex = queries[i][1];\\n    let nearestStart = nearestContainerWall[startIndex];\\n    if (nearestStart > endIndex || nearestStart == -1) {\\n      ans.push(0);\\n    } else {\\n      let val = prefixSum[endIndex] - prefixSum[nearestStart];\\n      ans.push(val);\\n    }\\n  }\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3450348,
                "title": "python-binary-search-prefix-sum-solution-with-explanation",
                "content": "### binary search\\n\\n```python\\n\\'\\'\\'\\nuse binary serach to find the candle closest to left bound (>=l) and the candle closest to right bound (<=r).\\nso, candles[rightCandle] - candles[leftCandle] + 1 is the length between two candles,\\nrightCandle - leftCandle + 1 is the number of candles between two candles,\\ncandles[rightCandle] - candles[leftCandle] - (rightCandle - leftCandle) is v number of plate between two candles.\\n\\ntc is O(len(s) + len(queries) log(len(s))), sc is O(len(s))\\n\\'\\'\\'\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        candles = []\\n        for idx, le in enumerate(s):\\n            if le == \\'|\\': candles.append(idx)\\n        def findLeftBound(arr, target):\\n            l, r = 0, len(arr)\\n            while l < r:\\n                m = (l + r) // 2\\n                if target > arr[m]:\\n                    l = m + 1\\n                else: r = m\\n            return l\\n        def findRightBound(arr, target):\\n            l, r = 0, len(arr)\\n            while l < r:\\n                m = (l + r)//2\\n                if target >= arr[m]:\\n                    l = m + 1\\n                else: r = m\\n            return r - 1\\n        ans = [0] * len(queries)\\n        for idx, (l, r) in enumerate(queries):\\n            leftCandle = findLeftBound(candles, l)\\n            rightCandle = findRightBound(candles, r)\\n\\t\\t\\t# [1,3,3,4,5], find 0 -> left bound is at index 0, right bound is at -1; find 6 -> left bound is at index 5, right bound is at 4\\n\\t\\t\\t# leftCandle is in [0, len(candles)], rightCandle is in [-1, len(candles)-1]\\n            if leftCandle == len(candles) or rightCandle == -1 or candles[leftCandle] > candles[rightCandle]: continue\\n            ans[idx] = candles[rightCandle] - candles[leftCandle] - (rightCandle - leftCandle)\\n        return ans\\n```\\n\\n### prefix sum\\n```python\\n\\'\\'\\'\\nwe can pre-calculate the nearest candles left and right for each position, \\nand use prefix sum to query the number of plates between both candle.\\ntc is O(len(s) + len(queries)), sc is O(len(s))\\n\\'\\'\\'\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        prefix = [0]\\n        left = [-1] * len(s)\\n        right = [-1] * len(s)\\n        l = 0\\n        r = len(s) - 1\\n        p = q = -1\\n        for idx, le in enumerate(s):\\n            prefix.append(prefix[-1] + (1 if le == \\'*\\' else 0))\\n\\n            if s[l] == \\'|\\': p = l\\n            if s[r] == \\'|\\': q = r\\n            left[l] = p\\n            right[r] = q\\n            l += 1\\n            r -= 1\\n\\t\\t\\n        ans = [0] * len(queries)\\n        for idx, (l, r) in enumerate(queries):\\n            leftCandle = right[l]\\n            rightCandle = left[r]\\n            if leftCandle != -1 and rightCandle > leftCandle: ans[idx] = prefix[rightCandle] - prefix[leftCandle]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```python\\n\\'\\'\\'\\nuse binary serach to find the candle closest to left bound (>=l) and the candle closest to right bound (<=r).\\nso, candles[rightCandle] - candles[leftCandle] + 1 is the length between two candles,\\nrightCandle - leftCandle + 1 is the number of candles between two candles,\\ncandles[rightCandle] - candles[leftCandle] - (rightCandle - leftCandle) is v number of plate between two candles.\\n\\ntc is O(len(s) + len(queries) log(len(s))), sc is O(len(s))\\n\\'\\'\\'\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        candles = []\\n        for idx, le in enumerate(s):\\n            if le == \\'|\\': candles.append(idx)\\n        def findLeftBound(arr, target):\\n            l, r = 0, len(arr)\\n            while l < r:\\n                m = (l + r) // 2\\n                if target > arr[m]:\\n                    l = m + 1\\n                else: r = m\\n            return l\\n        def findRightBound(arr, target):\\n            l, r = 0, len(arr)\\n            while l < r:\\n                m = (l + r)//2\\n                if target >= arr[m]:\\n                    l = m + 1\\n                else: r = m\\n            return r - 1\\n        ans = [0] * len(queries)\\n        for idx, (l, r) in enumerate(queries):\\n            leftCandle = findLeftBound(candles, l)\\n            rightCandle = findRightBound(candles, r)\\n\\t\\t\\t# [1,3,3,4,5], find 0 -> left bound is at index 0, right bound is at -1; find 6 -> left bound is at index 5, right bound is at 4\\n\\t\\t\\t# leftCandle is in [0, len(candles)], rightCandle is in [-1, len(candles)-1]\\n            if leftCandle == len(candles) or rightCandle == -1 or candles[leftCandle] > candles[rightCandle]: continue\\n            ans[idx] = candles[rightCandle] - candles[leftCandle] - (rightCandle - leftCandle)\\n        return ans\\n```\n```python\\n\\'\\'\\'\\nwe can pre-calculate the nearest candles left and right for each position, \\nand use prefix sum to query the number of plates between both candle.\\ntc is O(len(s) + len(queries)), sc is O(len(s))\\n\\'\\'\\'\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        prefix = [0]\\n        left = [-1] * len(s)\\n        right = [-1] * len(s)\\n        l = 0\\n        r = len(s) - 1\\n        p = q = -1\\n        for idx, le in enumerate(s):\\n            prefix.append(prefix[-1] + (1 if le == \\'*\\' else 0))\\n\\n            if s[l] == \\'|\\': p = l\\n            if s[r] == \\'|\\': q = r\\n            left[l] = p\\n            right[r] = q\\n            l += 1\\n            r -= 1\\n\\t\\t\\n        ans = [0] * len(queries)\\n        for idx, (l, r) in enumerate(queries):\\n            leftCandle = right[l]\\n            rightCandle = left[r]\\n            if leftCandle != -1 and rightCandle > leftCandle: ans[idx] = prefix[rightCandle] - prefix[leftCandle]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421171,
                "title": "c-2-solutions-1-tc-o-qlogn-n-2-tc-o-q-n",
                "content": "# Code\\n```\\n// Solution 1 : Prefix Sum + Binary Search [TC = O(qlogn + n)]\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.length(), sum = 0;\\n        vector<int> candle, prefix(n);\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'*\\') {\\n                sum++;\\n            } else {\\n                candle.push_back(i);\\n            }\\n            prefix[i] = sum;\\n        }\\n        vector<int> ans;\\n        for(vector<int> q: queries) {\\n            auto iter1 = lower_bound(candle.begin(), candle.end(), q[0]);\\n            auto iter2 = upper_bound(candle.begin(), candle.end(), q[1]);\\n            if(iter1 == candle.end() || iter2 == candle.begin() || iter1 >= iter2) \\n                ans.push_back(0);\\n            else\\n                ans.push_back(prefix[candle[iter2 - candle.begin() - 1]] - prefix[candle[iter1 - candle.begin()]]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Solution2 : Prefix Sum and precomputation [TC = O(q + n)]\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.length(), sum = 0;\\n        vector<int> prefix(n), left(n), right(n, -1);\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'*\\') {\\n                sum++;\\n            } \\n            prefix[i] = sum;\\n        }\\n        left[0] = (s[0] == \\'|\\'? 0: -1);\\n        right[n - 1] = (s[n - 1] == \\'|\\'? n - 1: -1);\\n        for(int i = 1; i < n; i++) {\\n            left[i] = (s[i] == \\'|\\'? i: left[i - 1]);\\n            right[n - i - 1] = (s[n - i - 1] == \\'|\\'? n - i - 1: right[n - i]);\\n        }\\n        vector<int> ans;\\n        for(vector<int> q: queries) {\\n            if(right[q[0]] == -1 || left[q[1]] == -1 || right[q[0]] >= left[q[1]]) \\n                ans.push_back(0);\\n            else\\n                ans.push_back(prefix[left[q[1]]] - prefix[right[q[0]]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\n// Solution 1 : Prefix Sum + Binary Search [TC = O(qlogn + n)]\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.length(), sum = 0;\\n        vector<int> candle, prefix(n);\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'*\\') {\\n                sum++;\\n            } else {\\n                candle.push_back(i);\\n            }\\n            prefix[i] = sum;\\n        }\\n        vector<int> ans;\\n        for(vector<int> q: queries) {\\n            auto iter1 = lower_bound(candle.begin(), candle.end(), q[0]);\\n            auto iter2 = upper_bound(candle.begin(), candle.end(), q[1]);\\n            if(iter1 == candle.end() || iter2 == candle.begin() || iter1 >= iter2) \\n                ans.push_back(0);\\n            else\\n                ans.push_back(prefix[candle[iter2 - candle.begin() - 1]] - prefix[candle[iter1 - candle.begin()]]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Solution2 : Prefix Sum and precomputation [TC = O(q + n)]\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.length(), sum = 0;\\n        vector<int> prefix(n), left(n), right(n, -1);\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'*\\') {\\n                sum++;\\n            } \\n            prefix[i] = sum;\\n        }\\n        left[0] = (s[0] == \\'|\\'? 0: -1);\\n        right[n - 1] = (s[n - 1] == \\'|\\'? n - 1: -1);\\n        for(int i = 1; i < n; i++) {\\n            left[i] = (s[i] == \\'|\\'? i: left[i - 1]);\\n            right[n - i - 1] = (s[n - i - 1] == \\'|\\'? n - i - 1: right[n - i]);\\n        }\\n        vector<int> ans;\\n        for(vector<int> q: queries) {\\n            if(right[q[0]] == -1 || left[q[1]] == -1 || right[q[0]] >= left[q[1]]) \\n                ans.push_back(0);\\n            else\\n                ans.push_back(prefix[left[q[1]]] - prefix[right[q[0]]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3403569,
                "title": "binary-search-and-prefix-sum-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int left(vector<int>&v, int ind)\\n    {\\n        int ans = -1, l = 0, r = v.size()-1;\\n        while(l <= r)\\n        {\\n            int mid = (l+r)/2;\\n            if (v[mid] >= ind) {\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else l = mid+1;\\n        }\\n        return ans;\\n    }\\n    int right(vector<int>&v, int ind)\\n    {\\n        int ans = -1, l = 0, r = v.size()-1;\\n        while(l <= r)\\n        {\\n            int mid = (l+r)/2;\\n            if (v[mid] <= ind) {\\n                ans = mid;\\n                l = mid+1;\\n            }\\n            else r = mid-1;\\n        }\\n        return ans;\\n    }\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& a) \\n    {\\n        int n = s.size();\\n        vector <int> pre(n), v1, ans(a.size());\\n        for (int i = 0; i < n; i++) \\n        {\\n            if (s[i] == \\'*\\') pre[i] = 1;\\n            if (s[i] == \\'|\\') v1.push_back(i);\\n        }\\n        for (int i = 1; i < n; i++) pre[i] += pre[i-1];\\n\\n        for (int i = 0; i < a.size(); i++)\\n        {\\n            int l = left(v1,a[i][0]), r = right(v1, a[i][1]);\\n            if (l < r and l >= 0 and r >= 0)\\n            {\\n                int val = pre[v1[r]]-pre[v1[l]];\\n                ans[i] = val;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int left(vector<int>&v, int ind)\\n    {\\n        int ans = -1, l = 0, r = v.size()-1;\\n        while(l <= r)\\n        {\\n            int mid = (l+r)/2;\\n            if (v[mid] >= ind) {\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else l = mid+1;\\n        }\\n        return ans;\\n    }\\n    int right(vector<int>&v, int ind)\\n    {\\n        int ans = -1, l = 0, r = v.size()-1;\\n        while(l <= r)\\n        {\\n            int mid = (l+r)/2;\\n            if (v[mid] <= ind) {\\n                ans = mid;\\n                l = mid+1;\\n            }\\n            else r = mid-1;\\n        }\\n        return ans;\\n    }\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& a) \\n    {\\n        int n = s.size();\\n        vector <int> pre(n), v1, ans(a.size());\\n        for (int i = 0; i < n; i++) \\n        {\\n            if (s[i] == \\'*\\') pre[i] = 1;\\n            if (s[i] == \\'|\\') v1.push_back(i);\\n        }\\n        for (int i = 1; i < n; i++) pre[i] += pre[i-1];\\n\\n        for (int i = 0; i < a.size(); i++)\\n        {\\n            int l = left(v1,a[i][0]), r = right(v1, a[i][1]);\\n            if (l < r and l >= 0 and r >= 0)\\n            {\\n                int val = pre[v1[r]]-pre[v1[l]];\\n                ans[i] = val;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388252,
                "title": "javascript-binary-search-detailed-explanation-clean-code",
                "content": "# Problem Statement\\nYou are given a string s containing only stars (*) and vertical bars (|). You are also given a list of queries, where each query is represented by a pair of integers [l, r]. For each query, you need to find the number of plates that are between the candles at positions l and r (inclusive). A plate is a substring of s that starts and ends with a vertical bar (|). The plates between the candles at positions l and r do not include the candles themselves.\\n\\n# Solution\\nThe problem can be solved using binary search to find the positions of the candles at or immediately to the left of l and r. Once we have the positions of the candles, we can calculate the number of plates between them by counting the number of stars between the vertical bars and subtracting the number of verticals in between.\\n\\nWe can use two binary search functions, lowerBound and upperBound, to find the positions of the candles. The lowerBound function finds the index of the first candle in range of [l, r], and the upperBound function finds the index of the last candle in range of [l, r]. We can then use these indexes to compute the number of plates between the candles.\\n\\nHere\\'s the JavaScript code for the lowerBound and upperBound functions:\\n\\n```\\nfunction lowerBound(arr, start, end, value) {\\n  while (start < end) {\\n    const mid = start + Math.floor((end - start) / 2);\\n\\n    if (arr[mid] < value) {\\n      start = mid + 1;\\n    } else {\\n      end = mid;\\n    }\\n  }\\n\\n  return start;\\n}\\n```\\n\\n```\\nfunction upperBound(arr, start, end, value) {\\n  while (start <= end) {\\n    const mid = start + Math.floor((end - start) / 2);\\n\\n    if (arr[mid] > value) {\\n      end = mid - 1;\\n    } else {\\n      start = mid + 1;\\n    }\\n  }\\n\\n  return end;\\n}\\n```\\n\\nThe platesBetweenCandles function iterates through the queries list and uses lowerBound and upperBound to find the positions of the candles for each query. It then calculates the number of plates between the candles and adds it to the platesBetweenCandles list.\\n\\nHere\\'s the JavaScript code for the platesBetweenCandles function:\\n\\n```\\nfunction platesBetweenCandles(s, queries) {\\n  let candleIndexes = [];\\n\\n  for (let i = 0; i < s.length; i++) {\\n    if (s[i] === \\'|\\') {\\n      candleIndexes.push(i);\\n    }\\n  }\\n\\n  let platesBetweenCandles = [];\\n\\n  for (let [start, end] of queries) {\\n    const left = lowerBound(candleIndexes, 0, candleIndexes.length - 1, start);\\n    const right = upperBound(\\n      candleIndexes,\\n      left,\\n      candleIndexes.length - 1,\\n      end\\n    );\\n    const plates = candleIndexes[right] - candleIndexes[left] - right + left;\\n\\n    if (plates > 0) {\\n      platesBetweenCandles.push(plates);\\n    } else {\\n      platesBetweenCandles.push(0);\\n    }\\n  }\\n\\n  return platesBetweenCandles;\\n}\\n```\\n\\n# Complexity Analysis\\n\\nThe time complexity of the **platesBetweenCandles** function is `O(q log n)`, where q is the number of queries and n is the length of the string s. The function iterates through the queries list, and for each query, it performs two binary searches, each taking `O(log n)` time. The **lowerBound** and **upperBound** functions have a time complexity of `O(log n)`.\\n\\nThe space complexity of the platesBetweenCandles function is `O(n)`, where n is the length of the string s. The function creates an array candleIndexes to store the positions of the candles, which has a maximum length of n. The platesBetweenCandles list has a maximum length of q.\\n\\n# Conclusion\\nThe problem can be solved using binary search to find the positions of the candles and counting the number of plates between them. The time complexity of the solution is O(q log n), and the space complexity is O(n).",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nfunction lowerBound(arr, start, end, value) {\\n  while (start < end) {\\n    const mid = start + Math.floor((end - start) / 2);\\n\\n    if (arr[mid] < value) {\\n      start = mid + 1;\\n    } else {\\n      end = mid;\\n    }\\n  }\\n\\n  return start;\\n}\\n```\n```\\nfunction upperBound(arr, start, end, value) {\\n  while (start <= end) {\\n    const mid = start + Math.floor((end - start) / 2);\\n\\n    if (arr[mid] > value) {\\n      end = mid - 1;\\n    } else {\\n      start = mid + 1;\\n    }\\n  }\\n\\n  return end;\\n}\\n```\n```\\nfunction platesBetweenCandles(s, queries) {\\n  let candleIndexes = [];\\n\\n  for (let i = 0; i < s.length; i++) {\\n    if (s[i] === \\'|\\') {\\n      candleIndexes.push(i);\\n    }\\n  }\\n\\n  let platesBetweenCandles = [];\\n\\n  for (let [start, end] of queries) {\\n    const left = lowerBound(candleIndexes, 0, candleIndexes.length - 1, start);\\n    const right = upperBound(\\n      candleIndexes,\\n      left,\\n      candleIndexes.length - 1,\\n      end\\n    );\\n    const plates = candleIndexes[right] - candleIndexes[left] - right + left;\\n\\n    if (plates > 0) {\\n      platesBetweenCandles.push(plates);\\n    } else {\\n      platesBetweenCandles.push(0);\\n    }\\n  }\\n\\n  return platesBetweenCandles;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3381911,
                "title": "easy-java-solution-with-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount the plates from left to right and count the candles from both side and then compare differences based on substring.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Store the plates count from left to right in an array.\\n2.Store the candles in 2d array where candles[i][1] will be counted from right to left and candles[i][0] is counted from left to right.\\n3.Initially assign r and l with candles[queries[i][1]][1]. For each query check candles are there in the queries[queries[i][0]][1] ,if not the take the count of candles[i][0], at the same time check if the position is excedding from queries[i][0], if yes then ans it as 0; \\n4.Then substract number of plates from right to left.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int n = queries.length,count=0, pos=-1;\\n        int[] ans = new int[n];\\n        int[] plates = new int[s.length()];\\n        int[][] candles = new int[s.length()][2];\\n        for(int i=s.length()-1;i>=0;i--){\\n            if (s.charAt(i)==\\'|\\') pos = i;\\n            candles[i][1] = pos;\\n        }\\n        pos=-1;\\n        for(int i=0;i<s.length();i++){\\n            if (s.charAt(i)==\\'*\\') count++;\\n            plates[i]=count;\\n            if (s.charAt(i)==\\'|\\') pos = i;\\n            candles[i][0] = pos;\\n        }\\n        for(int i=0;i<n;i++){\\n            int x= queries[i][0],y=queries[i][1],r=candles[y][1],l=candles[x][1];\\n            if (r==-1 && l==-1 && candles[x][0] == -1 && candles[x][0] == -1)\\n                ans[i] = 0;\\n            if (s.charAt(y) == \\'*\\'){\\n                if(candles[y][0]>x)\\n                    r = candles[y][0];\\n                else{\\n                    ans[i] = 0;\\n                    continue;\\n                }                    \\n            }\\n            ans[i]=plates[r] - plates[l]; \\n        }\\n        return ans;\\n    }\\n   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int n = queries.length,count=0, pos=-1;\\n        int[] ans = new int[n];\\n        int[] plates = new int[s.length()];\\n        int[][] candles = new int[s.length()][2];\\n        for(int i=s.length()-1;i>=0;i--){\\n            if (s.charAt(i)==\\'|\\') pos = i;\\n            candles[i][1] = pos;\\n        }\\n        pos=-1;\\n        for(int i=0;i<s.length();i++){\\n            if (s.charAt(i)==\\'*\\') count++;\\n            plates[i]=count;\\n            if (s.charAt(i)==\\'|\\') pos = i;\\n            candles[i][0] = pos;\\n        }\\n        for(int i=0;i<n;i++){\\n            int x= queries[i][0],y=queries[i][1],r=candles[y][1],l=candles[x][1];\\n            if (r==-1 && l==-1 && candles[x][0] == -1 && candles[x][0] == -1)\\n                ans[i] = 0;\\n            if (s.charAt(y) == \\'*\\'){\\n                if(candles[y][0]>x)\\n                    r = candles[y][0];\\n                else{\\n                    ans[i] = 0;\\n                    continue;\\n                }                    \\n            }\\n            ans[i]=plates[r] - plates[l]; \\n        }\\n        return ans;\\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377124,
                "title": "simple-c-solution-using-prefix-sum-and-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        int m = queries.size();\\n        vector<int> ans(m, 0);\\n\\n        vector<int> candles;\\n        vector<int> prevCandle(n , -1);\\n        vector<int> plates(n , 0);\\n        plates[0] = (s[0]==\\'*\\');\\n        int prev = -1;\\n\\n        for(int i=0 ; i<n ; i++){\\n            if(s[i]==\\'|\\') {\\n                prevCandle[i] = i;\\n                candles.push_back(i);\\n                prev = i;\\n            }\\n            else{\\n                prevCandle[i] = prev;\\n            }\\n            if(i>0) plates[i] = (s[i]==\\'*\\') + plates[i-1];\\n\\n        }\\n\\n      \\n\\n        for(int i=0 ; i<m ; i++){\\n            int l = queries[i][0];\\n            int r = queries[i][1];\\n            \\n            auto it = lower_bound(candles.begin() , candles.end() , l);\\n            if(it==candles.end()) continue;\\n            int start = *it;\\n            int end = prevCandle[r];\\n            if(end==-1) continue;\\n\\n            if(start>=end) continue;\\n        \\n\\n            ans[i] = ((end>0 ? plates[end-1]: 0) - plates[start]);\\n\\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        int m = queries.size();\\n        vector<int> ans(m, 0);\\n\\n        vector<int> candles;\\n        vector<int> prevCandle(n , -1);\\n        vector<int> plates(n , 0);\\n        plates[0] = (s[0]==\\'*\\');\\n        int prev = -1;\\n\\n        for(int i=0 ; i<n ; i++){\\n            if(s[i]==\\'|\\') {\\n                prevCandle[i] = i;\\n                candles.push_back(i);\\n                prev = i;\\n            }\\n            else{\\n                prevCandle[i] = prev;\\n            }\\n            if(i>0) plates[i] = (s[i]==\\'*\\') + plates[i-1];\\n\\n        }\\n\\n      \\n\\n        for(int i=0 ; i<m ; i++){\\n            int l = queries[i][0];\\n            int r = queries[i][1];\\n            \\n            auto it = lower_bound(candles.begin() , candles.end() , l);\\n            if(it==candles.end()) continue;\\n            int start = *it;\\n            int end = prevCandle[r];\\n            if(end==-1) continue;\\n\\n            if(start>=end) continue;\\n        \\n\\n            ans[i] = ((end>0 ? plates[end-1]: 0) - plates[start]);\\n\\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373251,
                "title": "binary-search-mlogn-solution",
                "content": "# Intuition\\nStore the candle indices into a list/array.\\nThen for each query, perform binary search on start/end against the sorted candle array.\\n\\nMore comments on code\\n\\n# Complexity\\n- Time complexity:\\nO(mlogn) - where m is length of queries and n is length of input string s\\n\\n- Space complexity:\\nO(m + n)\\n\\n# Code\\n```\\nclass Solution {\\n  private static final char CANDLE = \\'|\\';\\n  public int[] platesBetweenCandles(String s, int[][] queries) {\\n    int n = s.length();\\n    int j = 0;\\n    for (int i = 0; i < n; i++)\\n      if (s.charAt(i) == CANDLE)\\n        j++;\\n    int[] candles = new int[j];\\n    j = 0;\\n    for (int i = 0; i < n; i++)\\n      if (s.charAt(i) == CANDLE)\\n        candles[j++] = i;\\n\\n    int[] result = new int[queries.length];\\n    int r = 0;\\n    for (int[] query : queries) { // O(m)\\n      int start = query[0];\\n      int end = query[1];\\n\\n      int left = findcandles(candles, start, end, true);\\n      int right = findcandles(candles, end, end, false);\\n      if (left != -1 && right != -1) {\\n        int candlesinbetween = right - left - 1;\\n        int plates = candles[right] - candles[left] - 1 - candlesinbetween;\\n        result[r++] = plates;\\n      } else {\\n        result[r++] = 0;\\n      }\\n    }\\n\\n    return result;\\n  }\\n\\n  private int findcandles(int[] candles, int start, int end, boolean direction) {\\n    int result = -1;\\n\\n    // initialize search space range, all candle positions\\n    int l = 0, r = candles.length - 1;\\n    while (l <= r) {\\n      int m = l + (r - l) / 2;\\n      int candleindex = candles[m];\\n\\n      // if candleindex is outside of range\\n      if (candleindex < start) {\\n        // outside range, left side of start\\n        l = m + 1;\\n      } else if (candleindex > end) {\\n        // outside range, right side of end\\n        r = m - 1;\\n      } else {\\n        // used a flag to reuse this same binarysearch function\\n        if (direction) {\\n          // when searching for leftmost candle within range, \\n          // we want the search space to be reduced by\\n          // moving right pointer and subsequently \\n          // scan the left side\\n          result = m;\\n          r = m - 1;\\n        } else {\\n          // when searching for rightmost candle within range, \\n          // we want the search space to be reduced by\\n          // moving left pointer and subsequently \\n          // scan the right side\\n          result = m;\\n          l = m + 1;\\n        }\\n      }          \\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n  private static final char CANDLE = \\'|\\';\\n  public int[] platesBetweenCandles(String s, int[][] queries) {\\n    int n = s.length();\\n    int j = 0;\\n    for (int i = 0; i < n; i++)\\n      if (s.charAt(i) == CANDLE)\\n        j++;\\n    int[] candles = new int[j];\\n    j = 0;\\n    for (int i = 0; i < n; i++)\\n      if (s.charAt(i) == CANDLE)\\n        candles[j++] = i;\\n\\n    int[] result = new int[queries.length];\\n    int r = 0;\\n    for (int[] query : queries) { // O(m)\\n      int start = query[0];\\n      int end = query[1];\\n\\n      int left = findcandles(candles, start, end, true);\\n      int right = findcandles(candles, end, end, false);\\n      if (left != -1 && right != -1) {\\n        int candlesinbetween = right - left - 1;\\n        int plates = candles[right] - candles[left] - 1 - candlesinbetween;\\n        result[r++] = plates;\\n      } else {\\n        result[r++] = 0;\\n      }\\n    }\\n\\n    return result;\\n  }\\n\\n  private int findcandles(int[] candles, int start, int end, boolean direction) {\\n    int result = -1;\\n\\n    // initialize search space range, all candle positions\\n    int l = 0, r = candles.length - 1;\\n    while (l <= r) {\\n      int m = l + (r - l) / 2;\\n      int candleindex = candles[m];\\n\\n      // if candleindex is outside of range\\n      if (candleindex < start) {\\n        // outside range, left side of start\\n        l = m + 1;\\n      } else if (candleindex > end) {\\n        // outside range, right side of end\\n        r = m - 1;\\n      } else {\\n        // used a flag to reuse this same binarysearch function\\n        if (direction) {\\n          // when searching for leftmost candle within range, \\n          // we want the search space to be reduced by\\n          // moving right pointer and subsequently \\n          // scan the left side\\n          result = m;\\n          r = m - 1;\\n        } else {\\n          // when searching for rightmost candle within range, \\n          // we want the search space to be reduced by\\n          // moving left pointer and subsequently \\n          // scan the right side\\n          result = m;\\n          l = m + 1;\\n        }\\n      }          \\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359664,
                "title": "c-very-easy-approach-in-linear-time",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n=s.length();\\n        int q=queries.size();\\n        vector<int>total(n);\\n        if(s[0]==\\'*\\') total[0]=1;\\n        vector<int> right(n);\\n        vector<int> left(n);\\n        for(int i=1;i<n;i++){\\n             if(s[i]==\\'*\\') total[i]=total[i-1]+1;\\n             else total[i]=total[i-1];\\n        }\\n        if(s[0]==\\'|\\') left[0]=0;\\n        else left[0]=-1;\\n        if(s[n-1]==\\'|\\') right[n-1]=n-1;\\n        else right[n-1]=-1;\\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'|\\') left[i]=i;\\n            else left[i]=left[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]==\\'|\\') right[i]=i;\\n            else right[i]=right[i+1];\\n        }\\n        vector<int>ans(q);\\n        for(int i=0;i<q;i++){\\n            int lchar = right[queries[i][0]];\\n            int rchar = left[queries[i][1]];\\n\\n            if(lchar==-1 || rchar==-1|| lchar>=rchar) ans[i]=0;\\n            else ans[i]= total[rchar]-total[lchar];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int n=s.length();\\n        int q=queries.size();\\n        vector<int>total(n);\\n        if(s[0]==\\'*\\') total[0]=1;\\n        vector<int> right(n);\\n        vector<int> left(n);\\n        for(int i=1;i<n;i++){\\n             if(s[i]==\\'*\\') total[i]=total[i-1]+1;\\n             else total[i]=total[i-1];\\n        }\\n        if(s[0]==\\'|\\') left[0]=0;\\n        else left[0]=-1;\\n        if(s[n-1]==\\'|\\') right[n-1]=n-1;\\n        else right[n-1]=-1;\\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'|\\') left[i]=i;\\n            else left[i]=left[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]==\\'|\\') right[i]=i;\\n            else right[i]=right[i+1];\\n        }\\n        vector<int>ans(q);\\n        for(int i=0;i<q;i++){\\n            int lchar = right[queries[i][0]];\\n            int rchar = left[queries[i][1]];\\n\\n            if(lchar==-1 || rchar==-1|| lchar>=rchar) ans[i]=0;\\n            else ans[i]= total[rchar]-total[lchar];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358603,
                "title": "c-two-approaches",
                "content": "**Basic Idea:**\\n\\t\\t1. Count how many plates on the left side of each candle\\n\\t\\t2. Find the leftmost and rightmost candles of each query\\n\\t\\t3. Calculate the number of plates between them\\n\\n# Approach 1: Binary Search\\n\\n```\\n#include <string>\\n#include <vector>\\n#include <array>\\n#include <algorithm>\\n\\nusing std::string;\\nusing std::vector;\\nusing std::array;\\n\\nclass Solution {\\nprivate:\\n\\tconstexpr static char plate { \\'*\\' }, candle { \\'|\\' };\\n\\npublic:\\n    vector<int> platesBetweenCandles(const string& s, const vector<vector<int>>& queries) {\\n        int idx { 0 }, cnt { 0 };           //idx: index of a candle;  cnt: count of plates on the left side so far\\n        vector<array<int, 2>> counts {};    //array[0]: index of a candle;  array[1]: number of plates on its left side\\n\\t\\tvector<int> result {};\\n        \\n        auto lambda = [](const auto& ary, int val) { return ary[0] < val; };\\n\\n\\t\\tresult.reserve(queries.size());\\n\\n        //move index to the first candle\\n\\t\\tfor( ; idx < s.size() && s[idx] == plate; ++idx);\\n\\n\\t\\tfor( ; idx < s.size(); ++idx) {\\n\\t\\t\\tif (s[idx] == plate) {          //a little trick here\\n\\t\\t\\t\\tif (s[idx - 1] == candle)\\n\\t\\t\\t\\t\\tcounts.push_back({ idx - 1 , cnt });\\n\\n\\t\\t\\t\\t++cnt;\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n        //if the last one is a candle, don\\'t forget it\\n        if (s.back() == candle)\\n            counts.push_back({ idx - 1 , cnt });\\n        \\n        //the result of a query is the number of plates between leftmost and rightmost candles of the query\\n\\t\\tfor(const auto& query : queries) {\\n\\t\\t\\tauto iterL { std::lower_bound(counts.begin(), counts.end(), query[0], lambda) };\\n\\t\\t\\tauto iterR { std::lower_bound(counts.begin(), counts.end(), query[1], lambda) };\\n            \\n            if (s[query[1]] == plate && iterR != counts.begin())\\n                --iterR;\\n\\n\\t\\t\\tresult.push_back(iterR <= iterL ? 0 : (*iterR)[1] - (*iterL)[1]);\\n\\t\\t}\\n\\n\\t\\treturn result;\\n    }\\n};\\n```\\n\\nTime   complexity: O(NlogN)\\nSpace complexity: O(N)\\n\\n\\n# Approach 2: Enchanced one\\n\\n````\\n#include <string>\\n#include <vector>\\n\\nusing std::string;\\nusing std::vector;\\n\\nclass Solution {\\nprivate:\\n    struct info {\\n        int left  { 0 };       //index of the nearest left  candle\\n        int right { 0 };       //index of the nearest right candle\\n        int count { 0 };       //number of plates on the left side\\n    };\\n    \\n\\tconstexpr static char plate { \\'*\\' }, candle { \\'|\\' };\\n\\npublic:\\n    vector<int> platesBetweenCandles(const string& s, const vector<vector<int>>& queries) {\\n        const int sz { static_cast<int>(s.size()) };\\n        \\n        vector<info> vec    {};\\n        vector<int>  result {};\\n\\n\\t\\tvec.reserve(sz);\\n\\t\\tresult.reserve(queries.size());\\n        \\n        vec.assign(sz, info{});\\n\\n        //idx: index of the nearest left candle;  count: number of plates on the left so far\\n\\t\\tfor(int i { 0 }, idx { 0 }, count { 0 }; i < sz; ++i) {\\n\\t\\t\\tvec[i].count = count;\\n\\n\\t\\t\\tif (s[i] == plate)\\n\\t\\t\\t\\t++count;\\n\\t\\t\\telse\\n\\t\\t\\t\\tidx = i;\\n\\n\\t\\t\\tvec[i].left = idx;\\n\\t\\t}\\n\\n        //idx: index of the nearest right candle\\n\\t\\tfor(int i { sz - 1 }, idx { i }; 0 <= i; --i) {\\n\\t\\t\\tif (s[i] == candle)\\n\\t\\t\\t\\tidx = i;\\n\\n\\t\\t\\tvec[i].right = idx;\\n\\t\\t}\\n\\n        //the result of a query is the number of plates between leftmost and rightmost candles of the query\\n\\t\\tfor(const auto& query : queries) {\\n            // i / j: index of the leftmost / rightmost candle in a query\\n\\t\\t\\tauto i { vec[query[0]].right }, j { vec[query[1]].left };\\n\\n            //the number of plates in a query is the difference between vec[j].count and vec[i].count\\n\\t\\t\\tresult.push_back(i < j ? vec[j].count - vec[i].count : 0);\\n\\t\\t}\\n\\n\\t\\treturn result;\\n    }\\n};\\n````\\n\\nTime   complexity: O(N)\\nSpace complexity: O(N)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include <string>\\n#include <vector>\\n#include <array>\\n#include <algorithm>\\n\\nusing std::string;\\nusing std::vector;\\nusing std::array;\\n\\nclass Solution {\\nprivate:\\n\\tconstexpr static char plate { \\'*\\' }, candle { \\'|\\' };\\n\\npublic:\\n    vector<int> platesBetweenCandles(const string& s, const vector<vector<int>>& queries) {\\n        int idx { 0 }, cnt { 0 };           //idx: index of a candle;  cnt: count of plates on the left side so far\\n        vector<array<int, 2>> counts {};    //array[0]: index of a candle;  array[1]: number of plates on its left side\\n\\t\\tvector<int> result {};\\n        \\n        auto lambda = [](const auto& ary, int val) { return ary[0] < val; };\\n\\n\\t\\tresult.reserve(queries.size());\\n\\n        //move index to the first candle\\n\\t\\tfor( ; idx < s.size() && s[idx] == plate; ++idx);\\n\\n\\t\\tfor( ; idx < s.size(); ++idx) {\\n\\t\\t\\tif (s[idx] == plate) {          //a little trick here\\n\\t\\t\\t\\tif (s[idx - 1] == candle)\\n\\t\\t\\t\\t\\tcounts.push_back({ idx - 1 , cnt });\\n\\n\\t\\t\\t\\t++cnt;\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n        //if the last one is a candle, don\\'t forget it\\n        if (s.back() == candle)\\n            counts.push_back({ idx - 1 , cnt });\\n        \\n        //the result of a query is the number of plates between leftmost and rightmost candles of the query\\n\\t\\tfor(const auto& query : queries) {\\n\\t\\t\\tauto iterL { std::lower_bound(counts.begin(), counts.end(), query[0], lambda) };\\n\\t\\t\\tauto iterR { std::lower_bound(counts.begin(), counts.end(), query[1], lambda) };\\n            \\n            if (s[query[1]] == plate && iterR != counts.begin())\\n                --iterR;\\n\\n\\t\\t\\tresult.push_back(iterR <= iterL ? 0 : (*iterR)[1] - (*iterL)[1]);\\n\\t\\t}\\n\\n\\t\\treturn result;\\n    }\\n};\\n```\n````\\n#include <string>\\n#include <vector>\\n\\nusing std::string;\\nusing std::vector;\\n\\nclass Solution {\\nprivate:\\n    struct info {\\n        int left  { 0 };       //index of the nearest left  candle\\n        int right { 0 };       //index of the nearest right candle\\n        int count { 0 };       //number of plates on the left side\\n    };\\n    \\n\\tconstexpr static char plate { \\'*\\' }, candle { \\'|\\' };\\n\\npublic:\\n    vector<int> platesBetweenCandles(const string& s, const vector<vector<int>>& queries) {\\n        const int sz { static_cast<int>(s.size()) };\\n        \\n        vector<info> vec    {};\\n        vector<int>  result {};\\n\\n\\t\\tvec.reserve(sz);\\n\\t\\tresult.reserve(queries.size());\\n        \\n        vec.assign(sz, info{});\\n\\n        //idx: index of the nearest left candle;  count: number of plates on the left so far\\n\\t\\tfor(int i { 0 }, idx { 0 }, count { 0 }; i < sz; ++i) {\\n\\t\\t\\tvec[i].count = count;\\n\\n\\t\\t\\tif (s[i] == plate)\\n\\t\\t\\t\\t++count;\\n\\t\\t\\telse\\n\\t\\t\\t\\tidx = i;\\n\\n\\t\\t\\tvec[i].left = idx;\\n\\t\\t}\\n\\n        //idx: index of the nearest right candle\\n\\t\\tfor(int i { sz - 1 }, idx { i }; 0 <= i; --i) {\\n\\t\\t\\tif (s[i] == candle)\\n\\t\\t\\t\\tidx = i;\\n\\n\\t\\t\\tvec[i].right = idx;\\n\\t\\t}\\n\\n        //the result of a query is the number of plates between leftmost and rightmost candles of the query\\n\\t\\tfor(const auto& query : queries) {\\n            // i / j: index of the leftmost / rightmost candle in a query\\n\\t\\t\\tauto i { vec[query[0]].right }, j { vec[query[1]].left };\\n\\n            //the number of plates in a query is the difference between vec[j].count and vec[i].count\\n\\t\\t\\tresult.push_back(i < j ? vec[j].count - vec[i].count : 0);\\n\\t\\t}\\n\\n\\t\\treturn result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3353887,
                "title": "c-map-upper-bound-lower-bound",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nunordered_map have two really useful functions: lowerbound and upperbound. If we populate the positions the candles into a map along with the count of candles this candle is then we can calculate the number of plates.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        const int N = s.size();\\n        Table tb{};\\n\\n        int candle_count = 0;\\n        for (int i = 0; i < N; i++)\\n        {\\n            if (s[i] == \\'|\\') \\n            {\\n                candle_count++;\\n                tb[i] = candle_count;\\n            }\\n        }\\n\\n        vector<int> answers{};\\n        for (const auto v : queries)\\n        {\\n            const int i = v[0]; const int j = v[1];\\n            auto i_it = tb.lower_bound(i);\\n            auto j_it = tb.upper_bound(j);\\n\\n            if (j_it == tb.begin()) { answers.emplace_back(0); continue; }\\n            j_it = prev(j_it);\\n\\n            const int i_index = i_it->first; const int j_index = j_it->first;\\n            if (i_index >= j_index) { answers.emplace_back(0); continue; }\\n            int plates = j_index - i_index - 1;\\n            const int candles_inbetween = j_it->second - i_it->second - 1;\\n            plates -= candles_inbetween;\\n            answers.emplace_back(plates);\\n        }\\n        return answers;\\n    }\\nprivate:\\n    using Table = map<int, int>; // location of candles : candle count;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        const int N = s.size();\\n        Table tb{};\\n\\n        int candle_count = 0;\\n        for (int i = 0; i < N; i++)\\n        {\\n            if (s[i] == \\'|\\') \\n            {\\n                candle_count++;\\n                tb[i] = candle_count;\\n            }\\n        }\\n\\n        vector<int> answers{};\\n        for (const auto v : queries)\\n        {\\n            const int i = v[0]; const int j = v[1];\\n            auto i_it = tb.lower_bound(i);\\n            auto j_it = tb.upper_bound(j);\\n\\n            if (j_it == tb.begin()) { answers.emplace_back(0); continue; }\\n            j_it = prev(j_it);\\n\\n            const int i_index = i_it->first; const int j_index = j_it->first;\\n            if (i_index >= j_index) { answers.emplace_back(0); continue; }\\n            int plates = j_index - i_index - 1;\\n            const int candles_inbetween = j_it->second - i_it->second - 1;\\n            plates -= candles_inbetween;\\n            answers.emplace_back(plates);\\n        }\\n        return answers;\\n    }\\nprivate:\\n    using Table = map<int, int>; // location of candles : candle count;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329575,
                "title": "c-o-1-solution-with-two-unordered-maps",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int sz = s.size();\\n        int plates = 0, partial = 0;\\n        int candle = 0;\\n        unordered_map<int, pair<int, int>> pmap; // i-s, <i-candle, plates>\\n        unordered_map<int, int> cmap; // i-candle, i-s\\n        for (int i = 0; i < sz; i++) {\\n            if (candle > 0 && s[i] == \\'*\\') {\\n                partial++;\\n            } else if (s[i] == \\'|\\') {\\n                candle++;\\n                cmap[candle] = i;\\n                if (partial) {\\n                    plates += partial;\\n                    partial = 0;\\n                }\\n            }\\n            pmap[i] = pair<int, int>{candle, plates};\\n        }\\n        vector<int> ret;\\n        for (auto& query : queries) {\\n            pair<int, int> cp0 = pmap[query[0]], cp1 = pmap[query[1]];\\n            int candle0 = cp0.first, plates0 = cp0.second, candle1 = cp1.first, plates1 = cp1.second;\\n            if (s[query[0]] == \\'*\\') candle0 = min(candle0 + 1, candle);\\n            pair<int, int> cpc0 = pmap[cmap[candle0]], cpc1 = pmap[cmap[candle1]];\\n            int plates_c0 = cpc0.second, plates_c1 = cpc1.second;\\n            ret.emplace_back(max(plates_c1 - plates_c0, 0));\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\\n        int sz = s.size();\\n        int plates = 0, partial = 0;\\n        int candle = 0;\\n        unordered_map<int, pair<int, int>> pmap; // i-s, <i-candle, plates>\\n        unordered_map<int, int> cmap; // i-candle, i-s\\n        for (int i = 0; i < sz; i++) {\\n            if (candle > 0 && s[i] == \\'*\\') {\\n                partial++;\\n            } else if (s[i] == \\'|\\') {\\n                candle++;\\n                cmap[candle] = i;\\n                if (partial) {\\n                    plates += partial;\\n                    partial = 0;\\n                }\\n            }\\n            pmap[i] = pair<int, int>{candle, plates};\\n        }\\n        vector<int> ret;\\n        for (auto& query : queries) {\\n            pair<int, int> cp0 = pmap[query[0]], cp1 = pmap[query[1]];\\n            int candle0 = cp0.first, plates0 = cp0.second, candle1 = cp1.first, plates1 = cp1.second;\\n            if (s[query[0]] == \\'*\\') candle0 = min(candle0 + 1, candle);\\n            pair<int, int> cpc0 = pmap[cmap[candle0]], cpc1 = pmap[cmap[candle1]];\\n            int plates_c0 = cpc0.second, plates_c1 = cpc1.second;\\n            ret.emplace_back(max(plates_c1 - plates_c0, 0));\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328301,
                "title": "easy-solution-using-lower-bound-and-upper-bound-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries){\\n      vector<int>index;\\n      int n = s.size();\\n      for(int i = 0 ; i<n ; i++){\\n        if(s[i]==\\'|\\'){\\n          index.push_back(i);\\n        }\\n      }\\n      vector<int>ans;\\n      int l = index.size();\\n      for(int i = 0 ; i<queries.size() ; i++){\\n      int left = queries[i][0];\\n      int right = queries[i][1];  \\n      int start = lower_bound(index.begin(),index.end(),left) - index.begin();\\n      int end = upper_bound(index.begin(),index.end(),right) - index.begin()-1;\\n      if(start<0 or start>=l or end<0 or end>=l){\\n        ans.push_back(0);\\n        continue;\\n      }  \\n        \\n      int current = index[start];\\n      int temp = index[end];\\n      int res = (temp-current)-(end-start);\\n      if(res<0){\\n        ans.push_back(0);\\n        continue;\\n      }  \\n      ans.push_back(res);  \\n      }\\n      \\n      return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries){\\n      vector<int>index;\\n      int n = s.size();\\n      for(int i = 0 ; i<n ; i++){\\n        if(s[i]==\\'|\\'){\\n          index.push_back(i);\\n        }\\n      }\\n      vector<int>ans;\\n      int l = index.size();\\n      for(int i = 0 ; i<queries.size() ; i++){\\n      int left = queries[i][0];\\n      int right = queries[i][1];  \\n      int start = lower_bound(index.begin(),index.end(),left) - index.begin();\\n      int end = upper_bound(index.begin(),index.end(),right) - index.begin()-1;\\n      if(start<0 or start>=l or end<0 or end>=l){\\n        ans.push_back(0);\\n        continue;\\n      }  \\n        \\n      int current = index[start];\\n      int temp = index[end];\\n      int res = (temp-current)-(end-start);\\n      if(res<0){\\n        ans.push_back(0);\\n        continue;\\n      }  \\n      ans.push_back(res);  \\n      }\\n      \\n      return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308805,
                "title": "using-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int [] nearestLeftCandle = new int[s.length()];\\n        int [] nearestRightCandle = new int[s.length()];\\n        int [] platesPrefixSum = new int[s.length()];\\n        int curPlateCount = 0;\\n        int lastPlateIndex = -1;\\n        for(int i = 0 ; i < s.length(); i++)\\n        {\\n            if(s.charAt(i) == \\'*\\')\\n            curPlateCount++;\\n            else\\n            lastPlateIndex = i;\\n\\n            platesPrefixSum[i] = curPlateCount;\\n            nearestLeftCandle[i] = lastPlateIndex;\\n        }\\n        lastPlateIndex = s.length();\\n        for(int i = s.length() - 1; i >= 0; i--)\\n        {\\n            if(s.charAt(i) == \\'|\\')\\n            lastPlateIndex = i;\\n\\n            nearestRightCandle[i] = lastPlateIndex;\\n        }\\n        \\n        int [] res = new int[queries.length];\\n        for(int i = 0 ; i < queries.length; i++)\\n        {\\n            int leftCandleIndex = nearestRightCandle[queries[i][0]];\\n            int rightCandleIndex = nearestLeftCandle[queries[i][1]];\\n            if(leftCandleIndex < rightCandleIndex)\\n            res[i] = platesPrefixSum[rightCandleIndex] - platesPrefixSum[leftCandleIndex];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] platesBetweenCandles(String s, int[][] queries) {\\n        int [] nearestLeftCandle = new int[s.length()];\\n        int [] nearestRightCandle = new int[s.length()];\\n        int [] platesPrefixSum = new int[s.length()];\\n        int curPlateCount = 0;\\n        int lastPlateIndex = -1;\\n        for(int i = 0 ; i < s.length(); i++)\\n        {\\n            if(s.charAt(i) == \\'*\\')\\n            curPlateCount++;\\n            else\\n            lastPlateIndex = i;\\n\\n            platesPrefixSum[i] = curPlateCount;\\n            nearestLeftCandle[i] = lastPlateIndex;\\n        }\\n        lastPlateIndex = s.length();\\n        for(int i = s.length() - 1; i >= 0; i--)\\n        {\\n            if(s.charAt(i) == \\'|\\')\\n            lastPlateIndex = i;\\n\\n            nearestRightCandle[i] = lastPlateIndex;\\n        }\\n        \\n        int [] res = new int[queries.length];\\n        for(int i = 0 ; i < queries.length; i++)\\n        {\\n            int leftCandleIndex = nearestRightCandle[queries[i][0]];\\n            int rightCandleIndex = nearestLeftCandle[queries[i][1]];\\n            if(leftCandleIndex < rightCandleIndex)\\n            res[i] = platesPrefixSum[rightCandleIndex] - platesPrefixSum[leftCandleIndex];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1707873,
                "content": [
                    {
                        "username": "janakagoon",
                        "content": "A simple binary search with caching is failing for me with \"Time Limit Exceeded\", even though, if I run that failing test case - 12/36 - it passes in the debugger with a run time of 80 milliseconds.\\n\\nAny ideas? I suspect this is a leetcode back end issue. \\n\\n```\\nfunc find(v int, a []int) (int, bool) {\\n\\n    lo := 0\\n    hi := len(a) - 1\\n\\n    for lo <= hi {\\n        mid := (lo + hi)/2\\n\\n        if a[mid] == v {\\n            return mid, true\\n        } else if a[mid] > v {\\n            hi = mid - 1\\n        } else {\\n            lo = mid + 1\\n        }\\n    }\\n\\n    if lo > hi {\\n        return hi, false\\n    }\\n\\n    return lo, false                            \\n}\\n\\ntype ValFound struct {\\n    val int\\n    found bool\\n}\\n\\nfunc platesBetweenCandles(s string, queries [][]int) []int {\\n    // scan s from left to right and store the index of candles in an array\\n    // given[start, end], bin search for start and end on the above array\\n    // find the indexes of the candles and count the difference. this \\n    // is the number of candles between them\\n\\n    indexCache := make(map[int]*ValFound)\\n    candleIdx := []int{}\\n    for i := range s {\\n        if s[i] == \\'|\\' {\\n            candleIdx = append(candleIdx, i)\\n        }\\n    }\\n\\n    res := []int{}\\n    for _, q := range queries {\\n        if len(candleIdx) <= 1 {\\n            res = append(res, 0)\\n            continue\\n        }\\n\\n        left := q[0]\\n        right := q[1]\\n        candles := 0\\n        if len(candleIdx) > 0 {\\n            var leftIdx int\\n            var found bool \\n\\n            if cv, ok := indexCache[left]; ok {\\n                leftIdx = cv.val\\n                found = cv.found\\n            } else {\\n                leftIdx, found = find(left, candleIdx)\\n\\n                indexCache[left] = &ValFound{\\n                    leftIdx,\\n                    found,\\n                }\\n            }\\n\\n            if !found {\\n                if leftIdx < 0 {\\n                    leftIdx = 0\\n                } else if candleIdx[leftIdx] < left {\\n                    leftIdx++\\n                }\\n            }\\n\\n            var rightIdx int\\n\\n            if cv, ok := indexCache[right]; ok {\\n                rightIdx = cv.val\\n                found = cv.found\\n            } else {\\n                rightIdx, found = find(right, candleIdx)\\n\\n                indexCache[right] = &ValFound{\\n                    rightIdx,\\n                    found,\\n                }\\n            }\\n\\n            if !found {\\n                 if rightIdx < 0 {\\n                    leftIdx = 0\\n                } else if candleIdx[rightIdx] > right {\\n                    rightIdx--\\n                }\\n            }\\n    \\n            for i := leftIdx; i < rightIdx; i++ {\\n                candles += candleIdx[i+1] - candleIdx[i] - 1 \\n            }\\n        }\\n\\n        res = append(res, candles)\\n    }\\n\\n    return res\\n}\\n```"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is hard to code"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip: \n- Traverse the string and mark the presence/index of each plate from the left (prefixPosition) and from the right/end(suffix) and the prefixSum of candles.\n- Given a string \"* | * | * | * | *\": your leftPresence index array would be [-1,1,1,3,3,5,5,7,7], rightPresence index would be [1,1,3,3,5,5,7,7,-1] and prefixSum would be  [0,1,1,2,2,3,3,4,4].\n- Given a query [0,5]\n1. The closest candle on the right of 0 is rightPresence [0] = 1.\n2. The closest candle from the left of position 5 is leftPresence [5] = 5.\n3. Thus, you real reference interval is [1,5].\n4. Add few checks for consistency: if rightPresence == -1 OR leftPresence == -1 (no left/right candle) or right==left OR right < left return 0 as there are no candles to surround plates.\n5. Your interval reference has 5 elements and inside this interval you have prefixSum[5] - prefixSum[0] candles: 3.\nThus, 5-3 = 2 plates.\n"
                    },
                    {
                        "username": "user8272RT",
                        "content": "This is my thought process.\\n\\n1. I arrived at this problem after doing problem 34, so I knew I had to use binary search. \\n2. I had to find the left most and the right most candles in a given query. If I can do this, then I can use presum of plates to get the result.\\n3.  I populated a list of only candles and applied binary search to find the left and right most candles for a query.\\n4. Used presum to find the count of plates between the candles."
                    },
                    {
                        "username": "SriNarayana",
                        "content": "can anyone explain how did they get the intuition to do this? Like how did you think of using a treemap or a treeset or even prefix sum or binary search? I got nothing."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@average_leetcoder](/average_leetcoder) It didn\\'t click for him. That\\'s why he asked."
                    },
                    {
                        "username": "average_leetcoder",
                        "content": "Study each algorithm and pattern well and it will click to you upon seeing it"
                    }
                ]
            },
            {
                "id": 2028108,
                "content": [
                    {
                        "username": "janakagoon",
                        "content": "A simple binary search with caching is failing for me with \"Time Limit Exceeded\", even though, if I run that failing test case - 12/36 - it passes in the debugger with a run time of 80 milliseconds.\\n\\nAny ideas? I suspect this is a leetcode back end issue. \\n\\n```\\nfunc find(v int, a []int) (int, bool) {\\n\\n    lo := 0\\n    hi := len(a) - 1\\n\\n    for lo <= hi {\\n        mid := (lo + hi)/2\\n\\n        if a[mid] == v {\\n            return mid, true\\n        } else if a[mid] > v {\\n            hi = mid - 1\\n        } else {\\n            lo = mid + 1\\n        }\\n    }\\n\\n    if lo > hi {\\n        return hi, false\\n    }\\n\\n    return lo, false                            \\n}\\n\\ntype ValFound struct {\\n    val int\\n    found bool\\n}\\n\\nfunc platesBetweenCandles(s string, queries [][]int) []int {\\n    // scan s from left to right and store the index of candles in an array\\n    // given[start, end], bin search for start and end on the above array\\n    // find the indexes of the candles and count the difference. this \\n    // is the number of candles between them\\n\\n    indexCache := make(map[int]*ValFound)\\n    candleIdx := []int{}\\n    for i := range s {\\n        if s[i] == \\'|\\' {\\n            candleIdx = append(candleIdx, i)\\n        }\\n    }\\n\\n    res := []int{}\\n    for _, q := range queries {\\n        if len(candleIdx) <= 1 {\\n            res = append(res, 0)\\n            continue\\n        }\\n\\n        left := q[0]\\n        right := q[1]\\n        candles := 0\\n        if len(candleIdx) > 0 {\\n            var leftIdx int\\n            var found bool \\n\\n            if cv, ok := indexCache[left]; ok {\\n                leftIdx = cv.val\\n                found = cv.found\\n            } else {\\n                leftIdx, found = find(left, candleIdx)\\n\\n                indexCache[left] = &ValFound{\\n                    leftIdx,\\n                    found,\\n                }\\n            }\\n\\n            if !found {\\n                if leftIdx < 0 {\\n                    leftIdx = 0\\n                } else if candleIdx[leftIdx] < left {\\n                    leftIdx++\\n                }\\n            }\\n\\n            var rightIdx int\\n\\n            if cv, ok := indexCache[right]; ok {\\n                rightIdx = cv.val\\n                found = cv.found\\n            } else {\\n                rightIdx, found = find(right, candleIdx)\\n\\n                indexCache[right] = &ValFound{\\n                    rightIdx,\\n                    found,\\n                }\\n            }\\n\\n            if !found {\\n                 if rightIdx < 0 {\\n                    leftIdx = 0\\n                } else if candleIdx[rightIdx] > right {\\n                    rightIdx--\\n                }\\n            }\\n    \\n            for i := leftIdx; i < rightIdx; i++ {\\n                candles += candleIdx[i+1] - candleIdx[i] - 1 \\n            }\\n        }\\n\\n        res = append(res, candles)\\n    }\\n\\n    return res\\n}\\n```"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is hard to code"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip: \n- Traverse the string and mark the presence/index of each plate from the left (prefixPosition) and from the right/end(suffix) and the prefixSum of candles.\n- Given a string \"* | * | * | * | *\": your leftPresence index array would be [-1,1,1,3,3,5,5,7,7], rightPresence index would be [1,1,3,3,5,5,7,7,-1] and prefixSum would be  [0,1,1,2,2,3,3,4,4].\n- Given a query [0,5]\n1. The closest candle on the right of 0 is rightPresence [0] = 1.\n2. The closest candle from the left of position 5 is leftPresence [5] = 5.\n3. Thus, you real reference interval is [1,5].\n4. Add few checks for consistency: if rightPresence == -1 OR leftPresence == -1 (no left/right candle) or right==left OR right < left return 0 as there are no candles to surround plates.\n5. Your interval reference has 5 elements and inside this interval you have prefixSum[5] - prefixSum[0] candles: 3.\nThus, 5-3 = 2 plates.\n"
                    },
                    {
                        "username": "user8272RT",
                        "content": "This is my thought process.\\n\\n1. I arrived at this problem after doing problem 34, so I knew I had to use binary search. \\n2. I had to find the left most and the right most candles in a given query. If I can do this, then I can use presum of plates to get the result.\\n3.  I populated a list of only candles and applied binary search to find the left and right most candles for a query.\\n4. Used presum to find the count of plates between the candles."
                    },
                    {
                        "username": "SriNarayana",
                        "content": "can anyone explain how did they get the intuition to do this? Like how did you think of using a treemap or a treeset or even prefix sum or binary search? I got nothing."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@average_leetcoder](/average_leetcoder) It didn\\'t click for him. That\\'s why he asked."
                    },
                    {
                        "username": "average_leetcoder",
                        "content": "Study each algorithm and pattern well and it will click to you upon seeing it"
                    }
                ]
            },
            {
                "id": 2014529,
                "content": [
                    {
                        "username": "janakagoon",
                        "content": "A simple binary search with caching is failing for me with \"Time Limit Exceeded\", even though, if I run that failing test case - 12/36 - it passes in the debugger with a run time of 80 milliseconds.\\n\\nAny ideas? I suspect this is a leetcode back end issue. \\n\\n```\\nfunc find(v int, a []int) (int, bool) {\\n\\n    lo := 0\\n    hi := len(a) - 1\\n\\n    for lo <= hi {\\n        mid := (lo + hi)/2\\n\\n        if a[mid] == v {\\n            return mid, true\\n        } else if a[mid] > v {\\n            hi = mid - 1\\n        } else {\\n            lo = mid + 1\\n        }\\n    }\\n\\n    if lo > hi {\\n        return hi, false\\n    }\\n\\n    return lo, false                            \\n}\\n\\ntype ValFound struct {\\n    val int\\n    found bool\\n}\\n\\nfunc platesBetweenCandles(s string, queries [][]int) []int {\\n    // scan s from left to right and store the index of candles in an array\\n    // given[start, end], bin search for start and end on the above array\\n    // find the indexes of the candles and count the difference. this \\n    // is the number of candles between them\\n\\n    indexCache := make(map[int]*ValFound)\\n    candleIdx := []int{}\\n    for i := range s {\\n        if s[i] == \\'|\\' {\\n            candleIdx = append(candleIdx, i)\\n        }\\n    }\\n\\n    res := []int{}\\n    for _, q := range queries {\\n        if len(candleIdx) <= 1 {\\n            res = append(res, 0)\\n            continue\\n        }\\n\\n        left := q[0]\\n        right := q[1]\\n        candles := 0\\n        if len(candleIdx) > 0 {\\n            var leftIdx int\\n            var found bool \\n\\n            if cv, ok := indexCache[left]; ok {\\n                leftIdx = cv.val\\n                found = cv.found\\n            } else {\\n                leftIdx, found = find(left, candleIdx)\\n\\n                indexCache[left] = &ValFound{\\n                    leftIdx,\\n                    found,\\n                }\\n            }\\n\\n            if !found {\\n                if leftIdx < 0 {\\n                    leftIdx = 0\\n                } else if candleIdx[leftIdx] < left {\\n                    leftIdx++\\n                }\\n            }\\n\\n            var rightIdx int\\n\\n            if cv, ok := indexCache[right]; ok {\\n                rightIdx = cv.val\\n                found = cv.found\\n            } else {\\n                rightIdx, found = find(right, candleIdx)\\n\\n                indexCache[right] = &ValFound{\\n                    rightIdx,\\n                    found,\\n                }\\n            }\\n\\n            if !found {\\n                 if rightIdx < 0 {\\n                    leftIdx = 0\\n                } else if candleIdx[rightIdx] > right {\\n                    rightIdx--\\n                }\\n            }\\n    \\n            for i := leftIdx; i < rightIdx; i++ {\\n                candles += candleIdx[i+1] - candleIdx[i] - 1 \\n            }\\n        }\\n\\n        res = append(res, candles)\\n    }\\n\\n    return res\\n}\\n```"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is hard to code"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip: \n- Traverse the string and mark the presence/index of each plate from the left (prefixPosition) and from the right/end(suffix) and the prefixSum of candles.\n- Given a string \"* | * | * | * | *\": your leftPresence index array would be [-1,1,1,3,3,5,5,7,7], rightPresence index would be [1,1,3,3,5,5,7,7,-1] and prefixSum would be  [0,1,1,2,2,3,3,4,4].\n- Given a query [0,5]\n1. The closest candle on the right of 0 is rightPresence [0] = 1.\n2. The closest candle from the left of position 5 is leftPresence [5] = 5.\n3. Thus, you real reference interval is [1,5].\n4. Add few checks for consistency: if rightPresence == -1 OR leftPresence == -1 (no left/right candle) or right==left OR right < left return 0 as there are no candles to surround plates.\n5. Your interval reference has 5 elements and inside this interval you have prefixSum[5] - prefixSum[0] candles: 3.\nThus, 5-3 = 2 plates.\n"
                    },
                    {
                        "username": "user8272RT",
                        "content": "This is my thought process.\\n\\n1. I arrived at this problem after doing problem 34, so I knew I had to use binary search. \\n2. I had to find the left most and the right most candles in a given query. If I can do this, then I can use presum of plates to get the result.\\n3.  I populated a list of only candles and applied binary search to find the left and right most candles for a query.\\n4. Used presum to find the count of plates between the candles."
                    },
                    {
                        "username": "SriNarayana",
                        "content": "can anyone explain how did they get the intuition to do this? Like how did you think of using a treemap or a treeset or even prefix sum or binary search? I got nothing."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@average_leetcoder](/average_leetcoder) It didn\\'t click for him. That\\'s why he asked."
                    },
                    {
                        "username": "average_leetcoder",
                        "content": "Study each algorithm and pattern well and it will click to you upon seeing it"
                    }
                ]
            },
            {
                "id": 2010859,
                "content": [
                    {
                        "username": "janakagoon",
                        "content": "A simple binary search with caching is failing for me with \"Time Limit Exceeded\", even though, if I run that failing test case - 12/36 - it passes in the debugger with a run time of 80 milliseconds.\\n\\nAny ideas? I suspect this is a leetcode back end issue. \\n\\n```\\nfunc find(v int, a []int) (int, bool) {\\n\\n    lo := 0\\n    hi := len(a) - 1\\n\\n    for lo <= hi {\\n        mid := (lo + hi)/2\\n\\n        if a[mid] == v {\\n            return mid, true\\n        } else if a[mid] > v {\\n            hi = mid - 1\\n        } else {\\n            lo = mid + 1\\n        }\\n    }\\n\\n    if lo > hi {\\n        return hi, false\\n    }\\n\\n    return lo, false                            \\n}\\n\\ntype ValFound struct {\\n    val int\\n    found bool\\n}\\n\\nfunc platesBetweenCandles(s string, queries [][]int) []int {\\n    // scan s from left to right and store the index of candles in an array\\n    // given[start, end], bin search for start and end on the above array\\n    // find the indexes of the candles and count the difference. this \\n    // is the number of candles between them\\n\\n    indexCache := make(map[int]*ValFound)\\n    candleIdx := []int{}\\n    for i := range s {\\n        if s[i] == \\'|\\' {\\n            candleIdx = append(candleIdx, i)\\n        }\\n    }\\n\\n    res := []int{}\\n    for _, q := range queries {\\n        if len(candleIdx) <= 1 {\\n            res = append(res, 0)\\n            continue\\n        }\\n\\n        left := q[0]\\n        right := q[1]\\n        candles := 0\\n        if len(candleIdx) > 0 {\\n            var leftIdx int\\n            var found bool \\n\\n            if cv, ok := indexCache[left]; ok {\\n                leftIdx = cv.val\\n                found = cv.found\\n            } else {\\n                leftIdx, found = find(left, candleIdx)\\n\\n                indexCache[left] = &ValFound{\\n                    leftIdx,\\n                    found,\\n                }\\n            }\\n\\n            if !found {\\n                if leftIdx < 0 {\\n                    leftIdx = 0\\n                } else if candleIdx[leftIdx] < left {\\n                    leftIdx++\\n                }\\n            }\\n\\n            var rightIdx int\\n\\n            if cv, ok := indexCache[right]; ok {\\n                rightIdx = cv.val\\n                found = cv.found\\n            } else {\\n                rightIdx, found = find(right, candleIdx)\\n\\n                indexCache[right] = &ValFound{\\n                    rightIdx,\\n                    found,\\n                }\\n            }\\n\\n            if !found {\\n                 if rightIdx < 0 {\\n                    leftIdx = 0\\n                } else if candleIdx[rightIdx] > right {\\n                    rightIdx--\\n                }\\n            }\\n    \\n            for i := leftIdx; i < rightIdx; i++ {\\n                candles += candleIdx[i+1] - candleIdx[i] - 1 \\n            }\\n        }\\n\\n        res = append(res, candles)\\n    }\\n\\n    return res\\n}\\n```"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is hard to code"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip: \n- Traverse the string and mark the presence/index of each plate from the left (prefixPosition) and from the right/end(suffix) and the prefixSum of candles.\n- Given a string \"* | * | * | * | *\": your leftPresence index array would be [-1,1,1,3,3,5,5,7,7], rightPresence index would be [1,1,3,3,5,5,7,7,-1] and prefixSum would be  [0,1,1,2,2,3,3,4,4].\n- Given a query [0,5]\n1. The closest candle on the right of 0 is rightPresence [0] = 1.\n2. The closest candle from the left of position 5 is leftPresence [5] = 5.\n3. Thus, you real reference interval is [1,5].\n4. Add few checks for consistency: if rightPresence == -1 OR leftPresence == -1 (no left/right candle) or right==left OR right < left return 0 as there are no candles to surround plates.\n5. Your interval reference has 5 elements and inside this interval you have prefixSum[5] - prefixSum[0] candles: 3.\nThus, 5-3 = 2 plates.\n"
                    },
                    {
                        "username": "user8272RT",
                        "content": "This is my thought process.\\n\\n1. I arrived at this problem after doing problem 34, so I knew I had to use binary search. \\n2. I had to find the left most and the right most candles in a given query. If I can do this, then I can use presum of plates to get the result.\\n3.  I populated a list of only candles and applied binary search to find the left and right most candles for a query.\\n4. Used presum to find the count of plates between the candles."
                    },
                    {
                        "username": "SriNarayana",
                        "content": "can anyone explain how did they get the intuition to do this? Like how did you think of using a treemap or a treeset or even prefix sum or binary search? I got nothing."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@average_leetcoder](/average_leetcoder) It didn\\'t click for him. That\\'s why he asked."
                    },
                    {
                        "username": "average_leetcoder",
                        "content": "Study each algorithm and pattern well and it will click to you upon seeing it"
                    }
                ]
            },
            {
                "id": 1862445,
                "content": [
                    {
                        "username": "janakagoon",
                        "content": "A simple binary search with caching is failing for me with \"Time Limit Exceeded\", even though, if I run that failing test case - 12/36 - it passes in the debugger with a run time of 80 milliseconds.\\n\\nAny ideas? I suspect this is a leetcode back end issue. \\n\\n```\\nfunc find(v int, a []int) (int, bool) {\\n\\n    lo := 0\\n    hi := len(a) - 1\\n\\n    for lo <= hi {\\n        mid := (lo + hi)/2\\n\\n        if a[mid] == v {\\n            return mid, true\\n        } else if a[mid] > v {\\n            hi = mid - 1\\n        } else {\\n            lo = mid + 1\\n        }\\n    }\\n\\n    if lo > hi {\\n        return hi, false\\n    }\\n\\n    return lo, false                            \\n}\\n\\ntype ValFound struct {\\n    val int\\n    found bool\\n}\\n\\nfunc platesBetweenCandles(s string, queries [][]int) []int {\\n    // scan s from left to right and store the index of candles in an array\\n    // given[start, end], bin search for start and end on the above array\\n    // find the indexes of the candles and count the difference. this \\n    // is the number of candles between them\\n\\n    indexCache := make(map[int]*ValFound)\\n    candleIdx := []int{}\\n    for i := range s {\\n        if s[i] == \\'|\\' {\\n            candleIdx = append(candleIdx, i)\\n        }\\n    }\\n\\n    res := []int{}\\n    for _, q := range queries {\\n        if len(candleIdx) <= 1 {\\n            res = append(res, 0)\\n            continue\\n        }\\n\\n        left := q[0]\\n        right := q[1]\\n        candles := 0\\n        if len(candleIdx) > 0 {\\n            var leftIdx int\\n            var found bool \\n\\n            if cv, ok := indexCache[left]; ok {\\n                leftIdx = cv.val\\n                found = cv.found\\n            } else {\\n                leftIdx, found = find(left, candleIdx)\\n\\n                indexCache[left] = &ValFound{\\n                    leftIdx,\\n                    found,\\n                }\\n            }\\n\\n            if !found {\\n                if leftIdx < 0 {\\n                    leftIdx = 0\\n                } else if candleIdx[leftIdx] < left {\\n                    leftIdx++\\n                }\\n            }\\n\\n            var rightIdx int\\n\\n            if cv, ok := indexCache[right]; ok {\\n                rightIdx = cv.val\\n                found = cv.found\\n            } else {\\n                rightIdx, found = find(right, candleIdx)\\n\\n                indexCache[right] = &ValFound{\\n                    rightIdx,\\n                    found,\\n                }\\n            }\\n\\n            if !found {\\n                 if rightIdx < 0 {\\n                    leftIdx = 0\\n                } else if candleIdx[rightIdx] > right {\\n                    rightIdx--\\n                }\\n            }\\n    \\n            for i := leftIdx; i < rightIdx; i++ {\\n                candles += candleIdx[i+1] - candleIdx[i] - 1 \\n            }\\n        }\\n\\n        res = append(res, candles)\\n    }\\n\\n    return res\\n}\\n```"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is hard to code"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip: \n- Traverse the string and mark the presence/index of each plate from the left (prefixPosition) and from the right/end(suffix) and the prefixSum of candles.\n- Given a string \"* | * | * | * | *\": your leftPresence index array would be [-1,1,1,3,3,5,5,7,7], rightPresence index would be [1,1,3,3,5,5,7,7,-1] and prefixSum would be  [0,1,1,2,2,3,3,4,4].\n- Given a query [0,5]\n1. The closest candle on the right of 0 is rightPresence [0] = 1.\n2. The closest candle from the left of position 5 is leftPresence [5] = 5.\n3. Thus, you real reference interval is [1,5].\n4. Add few checks for consistency: if rightPresence == -1 OR leftPresence == -1 (no left/right candle) or right==left OR right < left return 0 as there are no candles to surround plates.\n5. Your interval reference has 5 elements and inside this interval you have prefixSum[5] - prefixSum[0] candles: 3.\nThus, 5-3 = 2 plates.\n"
                    },
                    {
                        "username": "user8272RT",
                        "content": "This is my thought process.\\n\\n1. I arrived at this problem after doing problem 34, so I knew I had to use binary search. \\n2. I had to find the left most and the right most candles in a given query. If I can do this, then I can use presum of plates to get the result.\\n3.  I populated a list of only candles and applied binary search to find the left and right most candles for a query.\\n4. Used presum to find the count of plates between the candles."
                    },
                    {
                        "username": "SriNarayana",
                        "content": "can anyone explain how did they get the intuition to do this? Like how did you think of using a treemap or a treeset or even prefix sum or binary search? I got nothing."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "[@average_leetcoder](/average_leetcoder) It didn\\'t click for him. That\\'s why he asked."
                    },
                    {
                        "username": "average_leetcoder",
                        "content": "Study each algorithm and pattern well and it will click to you upon seeing it"
                    }
                ]
            }
        ]
    }
]