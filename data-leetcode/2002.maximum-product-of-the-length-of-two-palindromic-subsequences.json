[
    {
        "title": "Guess the Word",
        "question_content": "You are given an array of unique strings words where words[i] is six letters long. One word of words was chosen as a secret word.\nYou are also given the helper object Master. You may call Master.guess(word) where word is a six-letter-long string, and it must be from words. Master.guess(word) returns:\n\n\t-1 if word is not from words, or\n\tan integer representing the number of exact matches (value and position) of your guess to the secret word.\n\nThere is a parameter allowedGuesses for each test case where allowedGuesses is the maximum number of times you can call Master.guess(word).\nFor each test case, you should call Master.guess with the secret word without exceeding the maximum number of allowed guesses. You will get:\n\n\t\"Either you took too many guesses, or you did not find the secret word.\" if you called Master.guess more than allowedGuesses times or if you did not call Master.guess with the secret word, or\n\t\"You guessed the secret word correctly.\" if you called Master.guess with the secret word with the number of calls to Master.guess less than or equal to allowedGuesses.\n\nThe test cases are generated such that you can guess the secret word with a reasonable strategy (other than using the bruteforce method).\n&nbsp;\nExample 1:\n\nInput: secret = \"acckzz\", words = [\"acckzz\",\"ccbazz\",\"eiowzz\",\"abcczz\"], allowedGuesses = 10\nOutput: You guessed the secret word correctly.\nExplanation:\nmaster.guess(\"aaaaaa\") returns -1, because \"aaaaaa\" is not in wordlist.\nmaster.guess(\"acckzz\") returns 6, because \"acckzz\" is secret and has all 6 matches.\nmaster.guess(\"ccbazz\") returns 3, because \"ccbazz\" has 3 matches.\nmaster.guess(\"eiowzz\") returns 2, because \"eiowzz\" has 2 matches.\nmaster.guess(\"abcczz\") returns 4, because \"abcczz\" has 4 matches.\nWe made 5 calls to master.guess, and one of them was the secret, so we pass the test case.\n\nExample 2:\n\nInput: secret = \"hamada\", words = [\"hamada\",\"khaled\"], allowedGuesses = 10\nOutput: You guessed the secret word correctly.\nExplanation: Since there are two words, you can guess both.\n\n&nbsp;\nConstraints:\n\n\t1 <= words.length <= 100\n\twords[i].length == 6\n\twords[i] consist of lowercase English letters.\n\tAll the strings of wordlist are unique.\n\tsecret exists in words.\n\t10 <= allowedGuesses <= 30",
        "solutions": [
            {
                "id": 556075,
                "title": "how-to-explain-to-interviewer-843-guess-the-word",
                "content": "Thanks to @lee215 sharing his amazing thoughts in [This Post](https://leetcode.com/problems/guess-the-word/discuss/133862/Random-Guess-and-Minimax-Guess-with-Comparison)\\n\\n#### 1. Clarify\\n1) Does the algorithm I design have to find the secret word within 10 times of guesses? The answer is No, you only need to design an algorithm that can find the secret word in as less times as possible.\\n#### 2. Idea\\nBecause if we find the secret word after 10 times of calling master.guess(), we fail the test case, **let\\'s call master.guess() 10 times or until we find the secret word, whichever comes first**. \\n\\nBecause there is no guanrantee that we can find the secret word within 10 calls, now our goal is to design a algorithm to find the secret word in as less times of calling master.guess() as possible. \\n\\nHow to find the secret word in as less times of calling master.guess() as possible? The answer is **trying to narrow the candidates after each time we call master.guess()**\\n\\nFor now, the structure of our algorithm is:\\n```java\\n//pseudocode version 1\\nfor(int i = 0, matches = 0; i < 10 && matches != 6; i ++){\\n\\tmatches = master.guess(a word in candidate);\\n\\treduce the number of words in candidate\\n}\\n```\\n\\nNow the key problem is, **how to narrow the candidates**?\\nwe have `x = master.guess(word)`\\n`if x == 6, we find the secret word, the algorithm ends`\\n`if x != 6, it means secret has exactly x matches with word`\\n\\nBecause secret has exactly x matches with word, we can just search in the candidates, and **only keep the ones that have exact x matches with word**. In this way, we narrow the candidates after we call master.guess(), and guarantee that secret is in candidates left\\n\\nFor now, the structure of our algorithm is changed to \\n```java\\n//pseudocode version 2\\nfor(int i = 0, matches = 0; i < 10 && matches != 6; i ++){\\n\\tmatches = master.guess(a word in candidates);\\n\\n\\tfor(String candidate: candidates){\\n\\t\\tif(matches == getMatches(candidate, word)){\\n\\t\\t\\ttempCandidates.add(candidate);\\n\\t\\t}\\n\\t}\\n\\n\\tcandidates = tempCandidates;\\n}\\n```\\n\\nSo we need a helper method to check the number of matches between two words:\\n```java\\nint getMatches(String word1, String word2){\\n\\tint matches = 0;\\n\\tfor(int i = 0; i < 6; i ++){\\n\\t\\tif(word1.charAt(i) == word2.charAt(i)){\\n\\t\\t\\tmatches ++;\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\nNow the key problem is **how to select word in candidates as the input of master.guess()?**\\nWe have two options:\\n\\n- option-1: select the first candidate as the input of master.guess() every time\\n- option-2: randomly select one word from candidates as the input of master.guess()\\n\\nWhich is better? The analysis is below:\\n\\np(x) means the possibility of `master.guess(word) == x`, we have \\n`p(x) = C(6, x) * (1/26)^x * (25/26)^(6-x)`\\n\\n`p(0) = 79.03%`\\n`p(1) = 18.97%`\\n`p(2) = 1.90%`\\n`p(3) = 0.10%`\\n`p(4) = 0.003%`\\n`p(5) = 4.85e-5%`\\n`p(6) = 3.24e-7%`\\n\\n- if `master.guess(word) == 0`, we\\'ll keep all the candidates that getMatches(word, candidate), because now word is already known, and all the candidates are generated randomly, so we have p(0) = 79.03% candidates that have 0 matches with word, and the possibility of `master.guess(word) == 0` is 79.03%, so if `master.guess(word) == 0`, we will keep 79.03%*79.03% = 62.45% candidates. \\n- if `master.guess(word) == 1`, we will keep 18.97% * 18.97% = 3.60%\\n- if `master.guess(word) == 2`, we will keep 1.90% * 1.90% = 0.03\\n- if `master.guess(word) == 3`, we will keep 0\\n- if `master.guess(word) == 4`, we will keep 0\\n- if `master.guess(word) == 5`, we will keep 0\\n- if `master.guess(word) == 6`, we will keep 0\\n\\nThe expectation of ratio of candidates we will keep after calling master.guess() is: 66.05% (sum of the percentages above)\\n\\nAt the beginning, we have 100 candidates, after each calling, we keep 66.05% of them\\n| Round of calling guess|  number of candidates left|\\n| :--------: | :--------:| \\n|initiation| 100|\\n| 1  | 66.05 | \\n| 2  | 43.63 |\\n| 3  | 28.81 |\\n| 4  | 19.03 |\\n| 5  | 12.57 |\\n| 6  | 8.30 |\\n| 7  | 5.48 |\\n| 8  | 3.62 |\\n| 9  | 2.39 |\\n| 10  | 0.68 |\\n\\nlet q(x) the possibility that we can find secret in the xth round\\nq(1) = 1/100\\nq(2) = 99/100 * 1/66.05 (didn\\'t find in 1st round but find secret in the 2nd round)\\nq(3) = 99/100 * 65.06/66.05 * 1/43.63 (didn\\'t find in 1st and 2nd round, but find in 3rd round)\\n...\\n\\nafter calculation, q(1) + q(2) + ... q(9) + q(10) = 75.70%\\nSo in this solution, the chance that we can find the secret word within 10 calls is 75.70%\\n\\nBecause all the candidates in wordlist are generated randomly, both option1 and option2 have the same chance 75.70%. But because leetcode only provide 5 test cases for this problem and each wordlist only contains 100 words, in statistic, option2 is better\\n\\nFor now, the structure of our algorithm is changed to \\n```java\\n//pseudocode version 3\\nfor(int i = 0, matches = 0; i < 10 && matches != 6; i ++){\\n\\tmatches = master.guess(randomly select a word in candidates);\\n\\tfor(String candidate: candidates){\\n\\t\\tif(matches == getMatches(candidate, word)){\\n\\t\\t\\ttempCandidates.add(candidate);\\n\\t\\t}\\n\\t}\\n\\n\\tcandidates = tempCandidates;\\n}\\n```\\n\\n#### 3. Code\\n```java\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Random random = new Random();\\n        for(int i = 0, matches = 0; i < 10 && matches != 6; i ++){\\n            String guess = wordlist[random.nextInt(wordlist.length)];\\n            matches = master.guess(guess);\\n            List<String> candidates = new ArrayList<>();\\n            for(String word: wordlist){\\n                if(matches == getMatches(guess, word)){\\n                    candidates.add(word);\\n                }\\n            }\\n            \\n            wordlist = candidates.toArray(new String[0]);\\n        }\\n    }\\n    \\n    private int getMatches(String word1, String word2){\\n        int matches = 0;\\n        for(int i = 0; i < word1.length(); i ++){\\n            if(word1.charAt(i) == word2.charAt(i)){\\n                matches ++;\\n            }\\n        }\\n        \\n        return matches;\\n    }\\n}\\n```\\n\\n#### 4. Complexity\\nTime Complexity: O(10n) = O(n), beucase the for loop runs 10 or less times and in each iteration, we traverse the wordlist, \\nSpace Complexity: O(10n) = O(n)\\n\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348) Thanks for voting!**",
                "solutionTags": [],
                "code": "```java\\n//pseudocode version 1\\nfor(int i = 0, matches = 0; i < 10 && matches != 6; i ++){\\n\\tmatches = master.guess(a word in candidate);\\n\\treduce the number of words in candidate\\n}\\n```\n```java\\n//pseudocode version 2\\nfor(int i = 0, matches = 0; i < 10 && matches != 6; i ++){\\n\\tmatches = master.guess(a word in candidates);\\n\\n\\tfor(String candidate: candidates){\\n\\t\\tif(matches == getMatches(candidate, word)){\\n\\t\\t\\ttempCandidates.add(candidate);\\n\\t\\t}\\n\\t}\\n\\n\\tcandidates = tempCandidates;\\n}\\n```\n```java\\nint getMatches(String word1, String word2){\\n\\tint matches = 0;\\n\\tfor(int i = 0; i < 6; i ++){\\n\\t\\tif(word1.charAt(i) == word2.charAt(i)){\\n\\t\\t\\tmatches ++;\\n\\t\\t}\\n\\t}\\n}\\n```\n```java\\n//pseudocode version 3\\nfor(int i = 0, matches = 0; i < 10 && matches != 6; i ++){\\n\\tmatches = master.guess(randomly select a word in candidates);\\n\\tfor(String candidate: candidates){\\n\\t\\tif(matches == getMatches(candidate, word)){\\n\\t\\t\\ttempCandidates.add(candidate);\\n\\t\\t}\\n\\t}\\n\\n\\tcandidates = tempCandidates;\\n}\\n```\n```java\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Random random = new Random();\\n        for(int i = 0, matches = 0; i < 10 && matches != 6; i ++){\\n            String guess = wordlist[random.nextInt(wordlist.length)];\\n            matches = master.guess(guess);\\n            List<String> candidates = new ArrayList<>();\\n            for(String word: wordlist){\\n                if(matches == getMatches(guess, word)){\\n                    candidates.add(word);\\n                }\\n            }\\n            \\n            wordlist = candidates.toArray(new String[0]);\\n        }\\n    }\\n    \\n    private int getMatches(String word1, String word2){\\n        int matches = 0;\\n        for(int i = 0; i < word1.length(); i ++){\\n            if(word1.charAt(i) == word2.charAt(i)){\\n                matches ++;\\n            }\\n        }\\n        \\n        return matches;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160945,
                "title": "python-o-n-with-maximum-overlap-heuristic",
                "content": "Same as other solutions - repeatedly choose a word to guess and eliminate all words that do not have the same number of matches as the\\nchosen word.\\n\\nTo choose a word, calculate a matrix counting the number of words where each char is in each position. Then score each word by adding the number of words that have the same chars in the same positions.\\n\\nSo this is O(n) time and not O(n^2) because I don\\'t check all pairs.\\n\\n```\\nclass Solution(object):\\n    def findSecretWord(self, wordlist, master):\\n\\t\\t\\n        def pair_matches(a, b):         # count the number of matching characters\\n            return sum(c1 == c2 for c1, c2 in zip(a, b))\\n\\n        def most_overlap_word():\\n            counts = [[0 for _ in range(26)] for _ in range(6)]     # counts[i][j] is nb of words with char j at index i\\n            for word in candidates:\\n                for i, c in enumerate(word):\\n                    counts[i][ord(c) - ord(\"a\")] += 1\\n\\n            best_score = 0\\n            for word in candidates:\\n                score = 0\\n                for i, c in enumerate(word):\\n                    score += counts[i][ord(c) - ord(\"a\")]           # all words with same chars in same positions\\n                if score > best_score:\\n                    best_score = score\\n                    best_word = word\\n\\n            return best_word\\n\\n        candidates = wordlist[:]        # all remaining candidates, initially all words\\n        while candidates:\\n\\n            s = most_overlap_word()     # guess the word that overlaps with most others\\n            matches = master.guess(s)\\n\\n            if matches == 6:\\n                return\\n\\n            candidates = [w for w in candidates if pair_matches(s, w) == matches]   # filter words with same matches\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findSecretWord(self, wordlist, master):\\n\\t\\t\\n        def pair_matches(a, b):         # count the number of matching characters\\n            return sum(c1 == c2 for c1, c2 in zip(a, b))\\n\\n        def most_overlap_word():\\n            counts = [[0 for _ in range(26)] for _ in range(6)]     # counts[i][j] is nb of words with char j at index i\\n            for word in candidates:\\n                for i, c in enumerate(word):\\n                    counts[i][ord(c) - ord(\"a\")] += 1\\n\\n            best_score = 0\\n            for word in candidates:\\n                score = 0\\n                for i, c in enumerate(word):\\n                    score += counts[i][ord(c) - ord(\"a\")]           # all words with same chars in same positions\\n                if score > best_score:\\n                    best_score = score\\n                    best_word = word\\n\\n            return best_word\\n\\n        candidates = wordlist[:]        # all remaining candidates, initially all words\\n        while candidates:\\n\\n            s = most_overlap_word()     # guess the word that overlaps with most others\\n            matches = master.guess(s)\\n\\n            if matches == 6:\\n                return\\n\\n            candidates = [w for w in candidates if pair_matches(s, w) == matches]   # filter words with same matches\\n```",
                "codeTag": "Java"
            },
            {
                "id": 134087,
                "title": "elimination-histogram",
                "content": "The basic idea is to get a similarity score between secret and a `guess`. Say, it\\'s `3`. Then, we compute a similarity score between `guess` and all candidates. If a similarity between `guess` and some other candidate is not `3`, this candidate can be eliminated as it cannot be a secret.\\n\\nAn improvement to this idea is to pick a candidate `guess` in a certain way, so that we maximize the number of candidates we can eliminate each turn. For that, we use the elimination histogram. \\n\\n#### Solution\\nWe compute a position/character histogram for remaining candidates and use it to select the next word to guess (O(n)). After each guess, we eliminate all words with different similarity and update the histogram.\\n\\nIn order to reduce the number of guesses, the strategy is to pick such a word that would maximize the amount of information we can get per each guess. For example, if 30 words start with \\'a\\', and a guess for ```\"a*****\"``` returned ```0```, this single turn eliminates 30 words. So, we can build a histogram of how often each character appears for each position. For example, if our words only contain characters from \\'a\\' to \\'e\\', we can get something like this:\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/votrubac/image_1527661420.png)\\nAccording to this histogram, the word that would give us maximum information is \"bdaced\" - if this word exists in the list, of course. We need to score each word according to this histogram (in my case, multiply count of each character), and use the one with the highest score.\\n\\nWhile writing this, I got an idea to use synthetic words (\"bdaced\" in our example) to maximize the initial elimination. According to my tests, using a synthetic word for the very first turn gives the best result.\\n\\nI tested the Minimax solution by Lee, and my two solutions when running 10,000 test cases with 100 randombly generated strings, and here are the results:\\nMetric | Minimax | Histogram | Histogram + Synthetic Turn\\n--- | --- | --- | ---\\nTotal runtime | 10306 ms | 15 ms | 13 ms\\nAverage attemts | 5.9578 | 5.5857 | 5.4538\\nMax attemps | 13 | 11 | 11\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/votrubac/image_1527477618.png)\\n**C++**\\n```cpp\\nint res = 0, probs[6][26] = {};\\nint match(string &w1, string &w2) {\\n    return inner_product(begin(w1), end(w1), begin(w2), 0, plus<int>(), equal_to<char>());\\n}\\nstring bestCandidate(list<string>& words) {\\n    string best;\\n    int max_score = 0;\\n    for (auto w : words) {\\n        int score = 1;\\n        for (auto i = 0; i < 6; ++i)\\n            score *= probs[i][w[i] - \\'a\\'];\\n        if (score > max_score) {\\n            max_score = score;\\n            best = w;\\n        }\\n    }\\n    return best;\\n}\\nvoid findSecretWord(vector<string>& wordlist, Master& master) {\\n    list<string> remWords(begin(wordlist), end(wordlist));\\n    auto add_prob = [&](string &w, int d = 1) {\\n        for (auto i = 0; i < 6; ++i)\\n            probs[i][w[i] - \\'a\\'] += d;\\n    };\\n    for_each(begin(wordlist), end(wordlist), add_prob);\\n    while (res < 6) {\\n        auto candidate = bestCandidate(remWords);\\n        res = master.guess(candidate);\\n        for (auto it = remWords.begin(); it != remWords.end(); )\\n            if (match(*it, candidate) != res) {\\n                add_prob(*it, -1);\\n                remWords.erase(it++);\\n            }\\n            else \\n                ++it;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\"a*****\"```\n```0```\n```cpp\\nint res = 0, probs[6][26] = {};\\nint match(string &w1, string &w2) {\\n    return inner_product(begin(w1), end(w1), begin(w2), 0, plus<int>(), equal_to<char>());\\n}\\nstring bestCandidate(list<string>& words) {\\n    string best;\\n    int max_score = 0;\\n    for (auto w : words) {\\n        int score = 1;\\n        for (auto i = 0; i < 6; ++i)\\n            score *= probs[i][w[i] - \\'a\\'];\\n        if (score > max_score) {\\n            max_score = score;\\n            best = w;\\n        }\\n    }\\n    return best;\\n}\\nvoid findSecretWord(vector<string>& wordlist, Master& master) {\\n    list<string> remWords(begin(wordlist), end(wordlist));\\n    auto add_prob = [&](string &w, int d = 1) {\\n        for (auto i = 0; i < 6; ++i)\\n            probs[i][w[i] - \\'a\\'] += d;\\n    };\\n    for_each(begin(wordlist), end(wordlist), add_prob);\\n    while (res < 6) {\\n        auto candidate = bestCandidate(remWords);\\n        res = master.guess(candidate);\\n        for (auto it = remWords.begin(); it != remWords.end(); )\\n            if (match(*it, candidate) != res) {\\n                add_prob(*it, -1);\\n                remWords.erase(it++);\\n            }\\n            else \\n                ++it;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 134251,
                "title": "optimal-minmax-solution-extra-challenging-test-cases",
                "content": "**Intuition:**\\nWe start by taking all words as potential candidates. If we guess a word, we\\'re given its distance from the secret, which allows us to eliminate words whose distance from the guess is different. That is, if we know that the secret is 4 characters away from the guess, then we can eliminate all words whose distance from the guess is not 4, because they can\\'t be the secret.\\n\\nIn order to maximize the number of words we eliminate at each guess, we choose a guess that partitions the potential candidate set roughly equally by all possible distances. That is, if we choose a guess that\\'s roughly equally at distance 0 from 1/6 of all words, distance 1 from 1/6 of all words, etc., we know that whatever distance the secret happens to be from the guess, we can eliminate a substantial number of words. This is where we use a MinMax heuristic. For each word, we compute a histogram of its distance from every word in the candidate set, and then select the word whose histogram peak (max) is smallest (min). That property guarantees that the selected word partitions the candidate set well by distance and that it has the potential to eliminate the maximum number of elements. That\\'s the word we choose as a guess. Once we offer it and obtain its distance from the secret, then we can eliminate all candidates that don\\'t have the same distance to it.\\n\\nWe repeat the same process iteratively, taking words from the full word set, but compute the histogram of their distances to the reduced candidate set only. The reason is that a word that is bad at partitioning the full word set may be good at partitioning the reduced candidate set at a later iteration. Choosing guess words from the full set also allows us to avoid falling into a local optimum valley where the reduced candidate set contains only words that partition it very poorly.\\n\\n\\n**Solution:**\\n\\n```\\nclass Solution {\\n\\n    int dist(const string& a, const string &b) \\n    {\\n        // Maybe this can be memoized if too slow.\\n        int dist = 0;\\n        for (int idx = 0; idx < a.size(); ++idx) {\\n            dist += a[idx] == b[idx];\\n        }\\n        return dist;\\n    }\\n    \\n    int maxEquidistantSetSize(const string& word, const unordered_set<string>& guessSet) \\n    {\\n        vector<int> hist(word.size() + 1, 0);    \\n        for (auto& guess : guessSet) {\\n            ++hist[dist(word, guess)];\\n        }\\n        return *max_element(hist.cbegin(), hist.cend());\\n    }\\n    \\n    string maxPartitioningGuess(const vector<string>& wordlist, const unordered_set<string>& guessSet)\\n    {\\n        auto maxGuessIt = wordlist.cend();\\n        int minMax = wordlist.size();\\n        for (auto it = wordlist.cbegin(); it != wordlist.cend(); ++it) {\\n            int curMax = maxEquidistantSetSize(*it, guessSet);\\n            if (curMax < minMax) {\\n                minMax = curMax;\\n                maxGuessIt = it;\\n            }\\n        }\\n        return *maxGuessIt;\\n    }\\n    \\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) \\n    {\\n        // Start guessing\\n        unordered_set<string> guessSet(wordlist.cbegin(), wordlist.cend());\\n        while (guessSet.size() > 1) {\\n            // Calculate max partitioning elem taken from full word list\\n            string guessWord = maxPartitioningGuess(wordlist, guessSet);\\n        \\n            // Try the guess\\n            int d = master.guess(guessWord);\\n            if (d == guessWord.size()) return; // Got lucky!\\n\\n            // Eliminate words whose distance != d\\n            for (auto it = guessSet.begin(); it != guessSet.end();) {\\n                if (dist(guessWord, *it) != d) {\\n                    it = guessSet.erase(it);\\n                } else {\\n                    ++it;\\n                }\\n            }\\n        }\\n        if (!guessSet.empty()) {\\n            master.guess(*guessSet.cbegin());\\n        }\\n    }\\n};\\n```\\n\\n**Testing:**\\n\\nMost of the other posted solutions so far can\\'t seem to handle the following test cases:\\n\\n```\\n\"aaponm\"\\n[\"aazyxw\",\"aayxwv\",\"aaxwvu\",\"aawvut\",\"aavuts\",\"aautsr\",\"aatsrq\",\"aasrqp\",\"aarqpo\",\"aaqpon\",\"aaponm\",\"aaonml\",\"aanmlk\",\"aamlkj\",\"aalkji\",\"aakjih\",\"aajihg\",\"aaihgf\",\"aahgfe\",\"aagfed\",\"aafedc\",\"ccwwww\",\"ccssss\",\"ccoooo\",\"cckkkk\",\"ccgggg\",\"cccccc\",\"ccyyyy\",\"ccuuuu\",\"ccqqqq\",\"ccmmmm\",\"ddwwww\",\"ddssss\",\"ddoooo\",\"ddkkkk\",\"ddgggg\",\"ddcccc\",\"ddyyyy\",\"dduuuu\",\"ddqqqq\",\"ddmmmm\",\"eewwww\",\"eessss\",\"eeoooo\",\"eekkkk\",\"eegggg\",\"eecccc\",\"eeyyyy\",\"eeuuuu\",\"eeqqqq\",\"eemmmm\",\"ffwwww\",\"ffssss\",\"ffoooo\",\"ffkkkk\",\"ffgggg\",\"ffcccc\",\"ffyyyy\",\"ffuuuu\",\"ffqqqq\",\"ffmmmm\",\"ggwwww\",\"ggssss\",\"ggoooo\",\"ggkkkk\",\"gggggg\",\"ggcccc\",\"ggyyyy\",\"gguuuu\",\"ggqqqq\",\"ggmmmm\",\"hhwwww\",\"hhssss\",\"hhoooo\",\"hhkkkk\",\"hhgggg\",\"hhcccc\",\"hhyyyy\",\"hhuuuu\",\"hhqqqq\",\"hhmmmm\",\"iiwwww\",\"iissss\",\"iioooo\",\"iikkkk\",\"iigggg\",\"iicccc\",\"iiyyyy\",\"iiuuuu\",\"iiqqqq\",\"iimmmm\",\"jjwwww\",\"jjssss\",\"jjoooo\",\"jjkkkk\",\"jjgggg\",\"jjcccc\",\"jjyyyy\",\"jjuuuu\",\"jjqqqq\"]\\n10\\n```\\n\\nHere are some less strong ones:\\n\\n```\\n\"aiaaaa\"\\n[\"azbbbb\",\"aybbbb\",\"axcccc\",\"awcccc\",\"avaaaa\",\"auaaaa\",\"ataaaa\",\"asaaaa\",\"araaaa\",\"aqaaaa\",\"agaaaa\",\"ahaaaa\",\"aiaaaa\",\"ajaaaa\",\"akaaaa\",\"alaaaa\",\"amaaaa\",\"anaaaa\",\"aoaaaa\",\"apaaaa\",\"afaaaa\",\"aeaaaa\",\"cxcccc\",\"cwcccc\",\"cvcccc\",\"cucccc\",\"ctcccc\",\"cscccc\",\"crcccc\",\"cqcccc\",\"dzdddd\",\"dydddd\",\"dxdddd\",\"dwdddd\",\"dvdddd\",\"dudddd\",\"dtdddd\",\"dsdddd\",\"drdddd\",\"dqdddd\",\"ezeeee\",\"eyeeee\",\"exeeee\",\"eweeee\",\"eveeee\",\"eueeee\",\"eteeee\",\"eseeee\",\"ereeee\",\"eqeeee\",\"fzffff\",\"fyffff\",\"fxffff\",\"fwffff\",\"fvffff\",\"fuffff\",\"ftffff\",\"fsffff\",\"frffff\",\"fqffff\",\"gzgggg\",\"gygggg\",\"gxgggg\",\"gwgggg\",\"gvgggg\",\"gugggg\",\"gtgggg\",\"gsgggg\",\"grgggg\",\"gqgggg\",\"hzhhhh\",\"hyhhhh\",\"hxhhhh\",\"hwhhhh\",\"hvhhhh\",\"huhhhh\",\"hthhhh\",\"hshhhh\",\"hrhhhh\",\"hqhhhh\",\"iziiii\",\"iyiiii\",\"ixiiii\",\"iwiiii\",\"iviiii\",\"iuiiii\",\"itiiii\",\"isiiii\",\"iriiii\",\"iqiiii\",\"jzjjjj\",\"jyjjjj\",\"jxjjjj\",\"jwjjjj\",\"jvjjjj\",\"jujjjj\",\"jtjjjj\",\"jsjjjj\",\"jrjjjj\",\"jqjjjj\"]\\n10\\n\\n\"azaaaa\"\\n[\"azaaaa\",\"ayaaaa\",\"axaaaa\",\"awaaaa\",\"avaaaa\",\"auaaaa\",\"ataaaa\",\"asaaaa\",\"araaaa\",\"aqaaaa\",\"bzbbbb\",\"bybbbb\",\"bxbbbb\",\"bwbbbb\",\"bvbbbb\",\"bubbbb\",\"btbbbb\",\"bsbbbb\",\"brbbbb\",\"apaaaa\",\"czcccc\",\"cycccc\",\"cxcccc\",\"cwcccc\",\"cvcccc\",\"cucccc\",\"ctcccc\",\"cscccc\",\"crcccc\",\"cqcccc\",\"dzdddd\",\"dydddd\",\"dxdddd\",\"dwdddd\",\"dvdddd\",\"dudddd\",\"dtdddd\",\"dsdddd\",\"drdddd\",\"dqdddd\",\"ezeeee\",\"eyeeee\",\"exeeee\",\"eweeee\",\"eveeee\",\"eueeee\",\"eteeee\",\"eseeee\",\"ereeee\",\"eqeeee\",\"fzffff\",\"fyffff\",\"fxffff\",\"fwffff\",\"fvffff\",\"fuffff\",\"ftffff\",\"fsffff\",\"frffff\",\"fqffff\",\"gzgggg\",\"gygggg\",\"gxgggg\",\"gwgggg\",\"gvgggg\",\"gugggg\",\"gtgggg\",\"gsgggg\",\"grgggg\",\"gqgggg\",\"hzhhhh\",\"hyhhhh\",\"hxhhhh\",\"hwhhhh\",\"hvhhhh\",\"huhhhh\",\"hthhhh\",\"hshhhh\",\"hrhhhh\",\"hqhhhh\",\"iziiii\",\"iyiiii\",\"ixiiii\",\"iwiiii\",\"iviiii\",\"iuiiii\",\"itiiii\",\"isiiii\",\"iriiii\",\"iqiiii\",\"jzjjjj\",\"jyjjjj\",\"jxjjjj\",\"jwjjjj\",\"jvjjjj\",\"jujjjj\",\"jtjjjj\",\"jsjjjj\",\"jrjjjj\",\"jqjjjj\"]\\n10\\n\\n\"apaaaa\"\\n[\"azbbbb\",\"aybbbb\",\"axcccc\",\"awcccc\",\"avdddd\",\"audddd\",\"ateeee\",\"aseeee\",\"arffff\",\"aqffff\",\"bzbbbb\",\"bybbbb\",\"bxbbbb\",\"bwbbbb\",\"akaaaa\",\"alaaaa\",\"amaaaa\",\"anaaaa\",\"aoaaaa\",\"apaaaa\",\"czcccc\",\"cycccc\",\"cxcccc\",\"cwcccc\",\"cvcccc\",\"cucccc\",\"ctcccc\",\"cscccc\",\"crcccc\",\"cqcccc\",\"dzdddd\",\"dydddd\",\"dxdddd\",\"dwdddd\",\"dvdddd\",\"dudddd\",\"dtdddd\",\"dsdddd\",\"drdddd\",\"dqdddd\",\"ezeeee\",\"eyeeee\",\"exeeee\",\"eweeee\",\"eveeee\",\"eueeee\",\"eteeee\",\"eseeee\",\"ereeee\",\"eqeeee\",\"fzffff\",\"fyffff\",\"fxffff\",\"fwffff\",\"fvffff\",\"fuffff\",\"ftffff\",\"fsffff\",\"frffff\",\"fqffff\",\"gzgggg\",\"gygggg\",\"gxgggg\",\"gwgggg\",\"gvgggg\",\"gugggg\",\"gtgggg\",\"gsgggg\",\"grgggg\",\"gqgggg\",\"hzhhhh\",\"hyhhhh\",\"hxhhhh\",\"hwhhhh\",\"hvhhhh\",\"huhhhh\",\"hthhhh\",\"hshhhh\",\"hrhhhh\",\"hqhhhh\",\"iziiii\",\"iyiiii\",\"ixiiii\",\"iwiiii\",\"iviiii\",\"iuiiii\",\"itiiii\",\"isiiii\",\"iriiii\",\"iqiiii\",\"jzjjjj\",\"jyjjjj\",\"jxjjjj\",\"jwjjjj\",\"jvjjjj\",\"jujjjj\",\"jtjjjj\",\"jsjjjj\",\"jrjjjj\",\"jqjjjj\"]\\n10\\n```\\n\\nThe point is that most solutions start from the minmax set and then proceed to use guesses from within the same reduced set. The following test case\\n```\\n\"aaponm\"\\n[\"aazyxw\",\"aayxwv\",\"aaxwvu\",\"aawvut\",\"aavuts\",\"aautsr\",\"aatsrq\",\"aasrqp\",\"aarqpo\",\"aaqpon\",\"aaponm\",\"aaonml\",\"aanmlk\",\"aamlkj\",\"aalkji\",\"aakjih\",\"aajihg\",\"aaihgf\",\"aahgfe\",\"aagfed\",\"aafedc\",\"ccwwww\",\"ccssss\",\"ccoooo\",\"cckkkk\",\"ccgggg\",\"cccccc\",\"ccyyyy\",\"ccuuuu\",\"ccqqqq\",\"ccmmmm\",\"ddwwww\",\"ddssss\",\"ddoooo\",\"ddkkkk\",\"ddgggg\",\"ddcccc\",\"ddyyyy\",\"dduuuu\",\"ddqqqq\",\"ddmmmm\",\"eewwww\",\"eessss\",\"eeoooo\",\"eekkkk\",\"eegggg\",\"eecccc\",\"eeyyyy\",\"eeuuuu\",\"eeqqqq\",\"eemmmm\",\"ffwwww\",\"ffssss\",\"ffoooo\",\"ffkkkk\",\"ffgggg\",\"ffcccc\",\"ffyyyy\",\"ffuuuu\",\"ffqqqq\",\"ffmmmm\",\"ggwwww\",\"ggssss\",\"ggoooo\",\"ggkkkk\",\"gggggg\",\"ggcccc\",\"ggyyyy\",\"gguuuu\",\"ggqqqq\",\"ggmmmm\",\"hhwwww\",\"hhssss\",\"hhoooo\",\"hhkkkk\",\"hhgggg\",\"hhcccc\",\"hhyyyy\",\"hhuuuu\",\"hhqqqq\",\"hhmmmm\",\"iiwwww\",\"iissss\",\"iioooo\",\"iikkkk\",\"iigggg\",\"iicccc\",\"iiyyyy\",\"iiuuuu\",\"iiqqqq\",\"iimmmm\",\"jjwwww\",\"jjssss\",\"jjoooo\",\"jjkkkk\",\"jjgggg\",\"jjcccc\",\"jjyyyy\",\"jjuuuu\",\"jjqqqq\"]\\n10\\n```\\nis constructed in such a way that the initial minmax set has 21 words at the same distance from one another. After the first guess, you reduce your candidates to this group:\\n```\\n\"aazyxw\",\"aayxwv\",\"aaxwvu\",\"aawvut\",\"aavuts\",\"aautsr\",\"aatsrq\",\"aasrqp\",\"aarqpo\",\"aaqpon\",\"aaponm\",\"aaonml\",\"aanmlk\",\"aamlkj\",\"aalkji\",\"aakjih\",\"aajihg\",\"aaihgf\",\"aahgfe\",\"aagfed\",\"aafedc\"\\n```\\nBut since each word in this set is at equal distance, if you only use guesses from within that set, you can eliminate at most one word for each guess. \\n\\nThe trick is that you should continue to use the complete word list to generate guesses. I.e. take words from outside of your current reduced set of potential guesses, and use them to calculate the minmax that would best partition the guess set . That way you can reduce the guess set signifcantly.\\n\\nFor example, if your second guess is \"aazyxw\", you eliminate only 1 word, but if you use an outside word like \"ccwwww\", you can eliminate 4 words (\"aazyxw\",\"aayxwv\",\"aaxwvu\",\"aawvut\"), etc.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    int dist(const string& a, const string &b) \\n    {\\n        // Maybe this can be memoized if too slow.\\n        int dist = 0;\\n        for (int idx = 0; idx < a.size(); ++idx) {\\n            dist += a[idx] == b[idx];\\n        }\\n        return dist;\\n    }\\n    \\n    int maxEquidistantSetSize(const string& word, const unordered_set<string>& guessSet) \\n    {\\n        vector<int> hist(word.size() + 1, 0);    \\n        for (auto& guess : guessSet) {\\n            ++hist[dist(word, guess)];\\n        }\\n        return *max_element(hist.cbegin(), hist.cend());\\n    }\\n    \\n    string maxPartitioningGuess(const vector<string>& wordlist, const unordered_set<string>& guessSet)\\n    {\\n        auto maxGuessIt = wordlist.cend();\\n        int minMax = wordlist.size();\\n        for (auto it = wordlist.cbegin(); it != wordlist.cend(); ++it) {\\n            int curMax = maxEquidistantSetSize(*it, guessSet);\\n            if (curMax < minMax) {\\n                minMax = curMax;\\n                maxGuessIt = it;\\n            }\\n        }\\n        return *maxGuessIt;\\n    }\\n    \\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) \\n    {\\n        // Start guessing\\n        unordered_set<string> guessSet(wordlist.cbegin(), wordlist.cend());\\n        while (guessSet.size() > 1) {\\n            // Calculate max partitioning elem taken from full word list\\n            string guessWord = maxPartitioningGuess(wordlist, guessSet);\\n        \\n            // Try the guess\\n            int d = master.guess(guessWord);\\n            if (d == guessWord.size()) return; // Got lucky!\\n\\n            // Eliminate words whose distance != d\\n            for (auto it = guessSet.begin(); it != guessSet.end();) {\\n                if (dist(guessWord, *it) != d) {\\n                    it = guessSet.erase(it);\\n                } else {\\n                    ++it;\\n                }\\n            }\\n        }\\n        if (!guessSet.empty()) {\\n            master.guess(*guessSet.cbegin());\\n        }\\n    }\\n};\\n```\n```\\n\"aaponm\"\\n[\"aazyxw\",\"aayxwv\",\"aaxwvu\",\"aawvut\",\"aavuts\",\"aautsr\",\"aatsrq\",\"aasrqp\",\"aarqpo\",\"aaqpon\",\"aaponm\",\"aaonml\",\"aanmlk\",\"aamlkj\",\"aalkji\",\"aakjih\",\"aajihg\",\"aaihgf\",\"aahgfe\",\"aagfed\",\"aafedc\",\"ccwwww\",\"ccssss\",\"ccoooo\",\"cckkkk\",\"ccgggg\",\"cccccc\",\"ccyyyy\",\"ccuuuu\",\"ccqqqq\",\"ccmmmm\",\"ddwwww\",\"ddssss\",\"ddoooo\",\"ddkkkk\",\"ddgggg\",\"ddcccc\",\"ddyyyy\",\"dduuuu\",\"ddqqqq\",\"ddmmmm\",\"eewwww\",\"eessss\",\"eeoooo\",\"eekkkk\",\"eegggg\",\"eecccc\",\"eeyyyy\",\"eeuuuu\",\"eeqqqq\",\"eemmmm\",\"ffwwww\",\"ffssss\",\"ffoooo\",\"ffkkkk\",\"ffgggg\",\"ffcccc\",\"ffyyyy\",\"ffuuuu\",\"ffqqqq\",\"ffmmmm\",\"ggwwww\",\"ggssss\",\"ggoooo\",\"ggkkkk\",\"gggggg\",\"ggcccc\",\"ggyyyy\",\"gguuuu\",\"ggqqqq\",\"ggmmmm\",\"hhwwww\",\"hhssss\",\"hhoooo\",\"hhkkkk\",\"hhgggg\",\"hhcccc\",\"hhyyyy\",\"hhuuuu\",\"hhqqqq\",\"hhmmmm\",\"iiwwww\",\"iissss\",\"iioooo\",\"iikkkk\",\"iigggg\",\"iicccc\",\"iiyyyy\",\"iiuuuu\",\"iiqqqq\",\"iimmmm\",\"jjwwww\",\"jjssss\",\"jjoooo\",\"jjkkkk\",\"jjgggg\",\"jjcccc\",\"jjyyyy\",\"jjuuuu\",\"jjqqqq\"]\\n10\\n```\n```\\n\"aiaaaa\"\\n[\"azbbbb\",\"aybbbb\",\"axcccc\",\"awcccc\",\"avaaaa\",\"auaaaa\",\"ataaaa\",\"asaaaa\",\"araaaa\",\"aqaaaa\",\"agaaaa\",\"ahaaaa\",\"aiaaaa\",\"ajaaaa\",\"akaaaa\",\"alaaaa\",\"amaaaa\",\"anaaaa\",\"aoaaaa\",\"apaaaa\",\"afaaaa\",\"aeaaaa\",\"cxcccc\",\"cwcccc\",\"cvcccc\",\"cucccc\",\"ctcccc\",\"cscccc\",\"crcccc\",\"cqcccc\",\"dzdddd\",\"dydddd\",\"dxdddd\",\"dwdddd\",\"dvdddd\",\"dudddd\",\"dtdddd\",\"dsdddd\",\"drdddd\",\"dqdddd\",\"ezeeee\",\"eyeeee\",\"exeeee\",\"eweeee\",\"eveeee\",\"eueeee\",\"eteeee\",\"eseeee\",\"ereeee\",\"eqeeee\",\"fzffff\",\"fyffff\",\"fxffff\",\"fwffff\",\"fvffff\",\"fuffff\",\"ftffff\",\"fsffff\",\"frffff\",\"fqffff\",\"gzgggg\",\"gygggg\",\"gxgggg\",\"gwgggg\",\"gvgggg\",\"gugggg\",\"gtgggg\",\"gsgggg\",\"grgggg\",\"gqgggg\",\"hzhhhh\",\"hyhhhh\",\"hxhhhh\",\"hwhhhh\",\"hvhhhh\",\"huhhhh\",\"hthhhh\",\"hshhhh\",\"hrhhhh\",\"hqhhhh\",\"iziiii\",\"iyiiii\",\"ixiiii\",\"iwiiii\",\"iviiii\",\"iuiiii\",\"itiiii\",\"isiiii\",\"iriiii\",\"iqiiii\",\"jzjjjj\",\"jyjjjj\",\"jxjjjj\",\"jwjjjj\",\"jvjjjj\",\"jujjjj\",\"jtjjjj\",\"jsjjjj\",\"jrjjjj\",\"jqjjjj\"]\\n10\\n\\n\"azaaaa\"\\n[\"azaaaa\",\"ayaaaa\",\"axaaaa\",\"awaaaa\",\"avaaaa\",\"auaaaa\",\"ataaaa\",\"asaaaa\",\"araaaa\",\"aqaaaa\",\"bzbbbb\",\"bybbbb\",\"bxbbbb\",\"bwbbbb\",\"bvbbbb\",\"bubbbb\",\"btbbbb\",\"bsbbbb\",\"brbbbb\",\"apaaaa\",\"czcccc\",\"cycccc\",\"cxcccc\",\"cwcccc\",\"cvcccc\",\"cucccc\",\"ctcccc\",\"cscccc\",\"crcccc\",\"cqcccc\",\"dzdddd\",\"dydddd\",\"dxdddd\",\"dwdddd\",\"dvdddd\",\"dudddd\",\"dtdddd\",\"dsdddd\",\"drdddd\",\"dqdddd\",\"ezeeee\",\"eyeeee\",\"exeeee\",\"eweeee\",\"eveeee\",\"eueeee\",\"eteeee\",\"eseeee\",\"ereeee\",\"eqeeee\",\"fzffff\",\"fyffff\",\"fxffff\",\"fwffff\",\"fvffff\",\"fuffff\",\"ftffff\",\"fsffff\",\"frffff\",\"fqffff\",\"gzgggg\",\"gygggg\",\"gxgggg\",\"gwgggg\",\"gvgggg\",\"gugggg\",\"gtgggg\",\"gsgggg\",\"grgggg\",\"gqgggg\",\"hzhhhh\",\"hyhhhh\",\"hxhhhh\",\"hwhhhh\",\"hvhhhh\",\"huhhhh\",\"hthhhh\",\"hshhhh\",\"hrhhhh\",\"hqhhhh\",\"iziiii\",\"iyiiii\",\"ixiiii\",\"iwiiii\",\"iviiii\",\"iuiiii\",\"itiiii\",\"isiiii\",\"iriiii\",\"iqiiii\",\"jzjjjj\",\"jyjjjj\",\"jxjjjj\",\"jwjjjj\",\"jvjjjj\",\"jujjjj\",\"jtjjjj\",\"jsjjjj\",\"jrjjjj\",\"jqjjjj\"]\\n10\\n\\n\"apaaaa\"\\n[\"azbbbb\",\"aybbbb\",\"axcccc\",\"awcccc\",\"avdddd\",\"audddd\",\"ateeee\",\"aseeee\",\"arffff\",\"aqffff\",\"bzbbbb\",\"bybbbb\",\"bxbbbb\",\"bwbbbb\",\"akaaaa\",\"alaaaa\",\"amaaaa\",\"anaaaa\",\"aoaaaa\",\"apaaaa\",\"czcccc\",\"cycccc\",\"cxcccc\",\"cwcccc\",\"cvcccc\",\"cucccc\",\"ctcccc\",\"cscccc\",\"crcccc\",\"cqcccc\",\"dzdddd\",\"dydddd\",\"dxdddd\",\"dwdddd\",\"dvdddd\",\"dudddd\",\"dtdddd\",\"dsdddd\",\"drdddd\",\"dqdddd\",\"ezeeee\",\"eyeeee\",\"exeeee\",\"eweeee\",\"eveeee\",\"eueeee\",\"eteeee\",\"eseeee\",\"ereeee\",\"eqeeee\",\"fzffff\",\"fyffff\",\"fxffff\",\"fwffff\",\"fvffff\",\"fuffff\",\"ftffff\",\"fsffff\",\"frffff\",\"fqffff\",\"gzgggg\",\"gygggg\",\"gxgggg\",\"gwgggg\",\"gvgggg\",\"gugggg\",\"gtgggg\",\"gsgggg\",\"grgggg\",\"gqgggg\",\"hzhhhh\",\"hyhhhh\",\"hxhhhh\",\"hwhhhh\",\"hvhhhh\",\"huhhhh\",\"hthhhh\",\"hshhhh\",\"hrhhhh\",\"hqhhhh\",\"iziiii\",\"iyiiii\",\"ixiiii\",\"iwiiii\",\"iviiii\",\"iuiiii\",\"itiiii\",\"isiiii\",\"iriiii\",\"iqiiii\",\"jzjjjj\",\"jyjjjj\",\"jxjjjj\",\"jwjjjj\",\"jvjjjj\",\"jujjjj\",\"jtjjjj\",\"jsjjjj\",\"jrjjjj\",\"jqjjjj\"]\\n10\\n```\n```\\n\"aaponm\"\\n[\"aazyxw\",\"aayxwv\",\"aaxwvu\",\"aawvut\",\"aavuts\",\"aautsr\",\"aatsrq\",\"aasrqp\",\"aarqpo\",\"aaqpon\",\"aaponm\",\"aaonml\",\"aanmlk\",\"aamlkj\",\"aalkji\",\"aakjih\",\"aajihg\",\"aaihgf\",\"aahgfe\",\"aagfed\",\"aafedc\",\"ccwwww\",\"ccssss\",\"ccoooo\",\"cckkkk\",\"ccgggg\",\"cccccc\",\"ccyyyy\",\"ccuuuu\",\"ccqqqq\",\"ccmmmm\",\"ddwwww\",\"ddssss\",\"ddoooo\",\"ddkkkk\",\"ddgggg\",\"ddcccc\",\"ddyyyy\",\"dduuuu\",\"ddqqqq\",\"ddmmmm\",\"eewwww\",\"eessss\",\"eeoooo\",\"eekkkk\",\"eegggg\",\"eecccc\",\"eeyyyy\",\"eeuuuu\",\"eeqqqq\",\"eemmmm\",\"ffwwww\",\"ffssss\",\"ffoooo\",\"ffkkkk\",\"ffgggg\",\"ffcccc\",\"ffyyyy\",\"ffuuuu\",\"ffqqqq\",\"ffmmmm\",\"ggwwww\",\"ggssss\",\"ggoooo\",\"ggkkkk\",\"gggggg\",\"ggcccc\",\"ggyyyy\",\"gguuuu\",\"ggqqqq\",\"ggmmmm\",\"hhwwww\",\"hhssss\",\"hhoooo\",\"hhkkkk\",\"hhgggg\",\"hhcccc\",\"hhyyyy\",\"hhuuuu\",\"hhqqqq\",\"hhmmmm\",\"iiwwww\",\"iissss\",\"iioooo\",\"iikkkk\",\"iigggg\",\"iicccc\",\"iiyyyy\",\"iiuuuu\",\"iiqqqq\",\"iimmmm\",\"jjwwww\",\"jjssss\",\"jjoooo\",\"jjkkkk\",\"jjgggg\",\"jjcccc\",\"jjyyyy\",\"jjuuuu\",\"jjqqqq\"]\\n10\\n```\n```\\n\"aazyxw\",\"aayxwv\",\"aaxwvu\",\"aawvut\",\"aavuts\",\"aautsr\",\"aatsrq\",\"aasrqp\",\"aarqpo\",\"aaqpon\",\"aaponm\",\"aaonml\",\"aanmlk\",\"aamlkj\",\"aalkji\",\"aakjih\",\"aajihg\",\"aaihgf\",\"aahgfe\",\"aagfed\",\"aafedc\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318789,
                "title": "careful-explanation-of-two-ideas-that-allow-you-to-solve-this-problem-in-a-few-lines",
                "content": "The solution to this problem depends on two observations.\\n\\n**1. If word has score x > 0, only those words that share exactly x characters with word can be the solution.**\\n\\n e.g. suppose guess(\"xyz\") = 1.\\n\\n  - \"abc\" cannot be the solution because it shares 0 letters with \"xyz\". \"xyz\" has a score of 1 so \"abc\" must have at least 1 letter wrong, so cannot be  the solution.\\n\\n  - \"zxy\" cannot be the solution because it shares 0 letters (in the right  place) with \"xyz\", so it must have at least one letter wrong.\\n\\n  - \"ayz\" cannot be the solution because it shares 2 letters with \"xyz\". If   \"ayz\" were the solution then \"xyz\" would have a score of 2.\\n\\n  - \"abz\" can be the solution because it shares 1 letter with \"xyz\"\\n\\n We can use this idea to quickly filter the word list:\\n \\n ```\\n class Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \"Master\") -> None:\\n        while wordlist:\\n            word = wordlist.pop()\\n            matches = master.guess(word)\\n            # only those words that share exactly x characters with word can be\\n            # the solution.\\n            wordlist = [\\n                other\\n                for other in wordlist\\n                if matches == sum(w == o for w, o in zip(word, other))\\n            ]\\n```\\n\\nBut this on its own is not sufficient. We need to shrink the list faster for the big test cases. Which requires the second observation.\\n\\n**2. We eliminate more words by choosing words that are more similar to the rest of the wordlist**\\n\\nIf `guess(\"xyz\") > 0` then we can eliminate words that are dissimilar to \"xyz\" (see above). But we can elminate words that are _similar_ to \"xyz\" if `guess(\"xyz\") is == 0`. For large wordlists, the overwhelming fraction of words in wordlist will have a score of 0. (Fun problem: compute this fraction for a randomly generated wordlist of size N.)\\n \\n Given `guess()` returns 0 most of the time for large wordlists, we can, on average eliminate more words per guess by choosing words that are more similar to the rest of\\n the corpus.\\n\\nWe can do this by sorting the words in order of \"similarity to the rest of the corpus\". You can do this pretty much any reasonable way and pass the LeetCode testcases. But just as an example, here\\'s a solution in which we assign each letter at each position a \"weight\" equal to the number of times that letter occurs at that position across entire wordlist. Each word\\'s similarity to the rest of the corpus is then the sum of these weights for its letters.\\n\\n```\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \"Master\") -> None:\\n        # e.g. if wordlist = [\"xy\", \"ab\", \"xz\"]\\n        # then weights = [{x: 2, a: 1}, {b: 1, y:1, z:1}]\\n        weights = [Counter(word[i] for word in wordlist) for i in range(6)]\\n\\n        # sort wordlist, least similar to rest of corpus first\\n        wordlist.sort(key=lambda word: sum(weights[i][c] for i, c in enumerate(word)))\\n\\n        while wordlist:\\n            # get the word most similar to the rest of the corpus by popping\\n            # from the *end* of wordlist\\n            word = wordlist.pop()\\n            matches = master.guess(word)\\n            # only those words that share exactly x characters with word can be\\n            # the solution.\\n            wordlist = [\\n                other\\n                for other in wordlist\\n                if matches == sum(w == o for w, o in zip(word, other))\\n            ]\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n class Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \"Master\") -> None:\\n        while wordlist:\\n            word = wordlist.pop()\\n            matches = master.guess(word)\\n            # only those words that share exactly x characters with word can be\\n            # the solution.\\n            wordlist = [\\n                other\\n                for other in wordlist\\n                if matches == sum(w == o for w, o in zip(word, other))\\n            ]\\n```\n```\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \"Master\") -> None:\\n        # e.g. if wordlist = [\"xy\", \"ab\", \"xz\"]\\n        # then weights = [{x: 2, a: 1}, {b: 1, y:1, z:1}]\\n        weights = [Counter(word[i] for word in wordlist) for i in range(6)]\\n\\n        # sort wordlist, least similar to rest of corpus first\\n        wordlist.sort(key=lambda word: sum(weights[i][c] for i, c in enumerate(word)))\\n\\n        while wordlist:\\n            # get the word most similar to the rest of the corpus by popping\\n            # from the *end* of wordlist\\n            word = wordlist.pop()\\n            matches = master.guess(word)\\n            # only those words that share exactly x characters with word can be\\n            # the solution.\\n            wordlist = [\\n                other\\n                for other in wordlist\\n                if matches == sum(w == o for w, o in zip(word, other))\\n            ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697664,
                "title": "big-brain-time",
                "content": "```\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        master.guess(master._Master__secret)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        master.guess(master._Master__secret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164744,
                "title": "logical-thinking-exclude-the-impossible",
                "content": "If there are exact `numMatch` matches between the guess word and the secret word\\n- candidates for the secret word must share exact `numMatch` matches with the guess word \\n- those words do not share `numMatch` exact matches with the guess word are impossible to be the secret word. \\n \\nWe exclude words recursively until we guess the secret.\\n\\n\\n### Python\\n```\\n\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        for i in range(0, 10):\\n            n = len(wordlist)\\n            guess_word = wordlist[random.randint(0, n - 1)]\\n            num_exact_match = master.guess(guess_word)\\n            \\n            wordlist = self.filter_word_list(\\n                word_list=wordlist,\\n                target_exact_match=num_exact_match,\\n                target_word=guess_word\\n            )\\n\\n            \\n    def filter_word_list(self, word_list: List[str], target_exact_match: int, target_word: str) -> List[str]:\\n        def count_exact_match(word):\\n            num_exact_match = 0\\n            for i in range(0, 6):\\n                if word[i] == target_word[i]:\\n                    num_exact_match += 1\\n            return num_exact_match\\n        \\n        filtered_word_list = []\\n        for word in word_list:\\n            if count_exact_match(word) == target_exact_match:\\n                filtered_word_list.append(word)\\n        \\n        return filtered_word_list\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        for i in range(0, 10):\\n            n = len(wordlist)\\n            guess_word = wordlist[random.randint(0, n - 1)]\\n            num_exact_match = master.guess(guess_word)\\n            \\n            wordlist = self.filter_word_list(\\n                word_list=wordlist,\\n                target_exact_match=num_exact_match,\\n                target_word=guess_word\\n            )\\n\\n            \\n    def filter_word_list(self, word_list: List[str], target_exact_match: int, target_word: str) -> List[str]:\\n        def count_exact_match(word):\\n            num_exact_match = 0\\n            for i in range(0, 6):\\n                if word[i] == target_word[i]:\\n                    num_exact_match += 1\\n            return num_exact_match\\n        \\n        filtered_word_list = []\\n        for word in word_list:\\n            if count_exact_match(word) == target_exact_match:\\n                filtered_word_list.append(word)\\n        \\n        return filtered_word_list\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 425068,
                "title": "python-beats-99",
                "content": "I think this \"interactive\" problem may be over my head, but I found a lot of other solutions poorly explained or too theoretical, so here\\'s my take.\\n\\nObservations:\\n1) If `master.guess(guess_word)` returns 0 matches then any other word in `wordlist`that matches even 1 character with `guess_word` can be eliminated.\\n2) If `master.guess(guess_word)` returns 6, then obviously we have our answer.\\n3) If `master.guess(guess_word)` returns 1-5, then all remaining candidate need to match `guess_word` *exactly* that many times because the `secret` word is in the `wordlist` and matches the `guess_word` *exactly* that many times.\\n\\nApproach:\\nTreat the `wordlist` as the candidate set.  On each guess we can eliminate candidate words based on the guess. \\n\\nIf `master.guess(guess_word)` returns 0, it is better if `guess_word` was **not** very unique.  Then it eliminates many similar words.  \\n\\nIf `master.guess(guess_word)` returns 1-5, it is better if `guess_word` was very unique.  Then it eliminates many unsimilar words.\\n\\nTo emphasize, if `master.guess(guess_word)` returns 0 and `guess_word = \"zzzzzz\"` but **no** other words in `wordlist` use the letter `\"z\"` then you cannot eliminate any other words! \\n\\nBut, if `master.guess(\"zzzzzz\")` returned 4, and few other words in `wordlist` contained 4 `\"z\"`\\'s, then you would eliminate many words.\\n\\nHere, I sort `wordlist` by uniqueness and change the end of the `wordlist` I am choosing `guess_word` from based on `matches`.\\n\\n```\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        place_counts = collections.defaultdict(int)\\n        for word in wordlist:\\n            for i, char in enumerate(word):\\n                place_counts[str(i)+char] += 1\\n        \\n        def word_uniqueness(word):\\n            score = 0\\n            for i, char in enumerate(word):\\n                score += place_counts[str(i)+char]\\n            return score\\n        \\n        # wordlist will be sorted from most to least unique.\\n        wordlist.sort(key=word_uniqueness)\\n        \\n        def word_is_possible(guess_word, word, matches):\\n            if guess_word == word:\\n                return False\\n            match_count = 0\\n            for a, b in zip(guess_word, word):\\n                if a == b:\\n                    match_count += 1\\n            return match_count == matches\\n        \\n        end = -1\\n        for _ in range(10):\\n            guess_word = wordlist[end]\\n            matches = master.guess(guess_word)\\n            if matches == 6:\\n                break\\n            elif matches == 0:\\n                wordlist = [w for w in wordlist if not any(a==b for a, b in zip(guess_word, w))]\\n                if end == 0:\\n                    end = -1\\n            else:\\n                wordlist = [w for w in wordlist if word_is_possible(guess_word, w, matches)]\\n                if end == -1:\\n                    end = 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        place_counts = collections.defaultdict(int)\\n        for word in wordlist:\\n            for i, char in enumerate(word):\\n                place_counts[str(i)+char] += 1\\n        \\n        def word_uniqueness(word):\\n            score = 0\\n            for i, char in enumerate(word):\\n                score += place_counts[str(i)+char]\\n            return score\\n        \\n        # wordlist will be sorted from most to least unique.\\n        wordlist.sort(key=word_uniqueness)\\n        \\n        def word_is_possible(guess_word, word, matches):\\n            if guess_word == word:\\n                return False\\n            match_count = 0\\n            for a, b in zip(guess_word, word):\\n                if a == b:\\n                    match_count += 1\\n            return match_count == matches\\n        \\n        end = -1\\n        for _ in range(10):\\n            guess_word = wordlist[end]\\n            matches = master.guess(guess_word)\\n            if matches == 6:\\n                break\\n            elif matches == 0:\\n                wordlist = [w for w in wordlist if not any(a==b for a, b in zip(guess_word, w))]\\n                if end == 0:\\n                    end = -1\\n            else:\\n                wordlist = [w for w in wordlist if word_is_possible(guess_word, w, matches)]\\n                if end == -1:\\n                    end = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394280,
                "title": "java-minimax-solution-explained-in-depth",
                "content": "Alright, first, let us clarify something first.\\n\\n**The point of this question is not really to solve it in 10 guesses or less. The idea is to solve it in as few guesses as possible. It is important to make this clarification in an interview. Certain  test-cases will never work if you only have 10 guesses.  Ex. {\"aaaaaa\",\"bbbbbb\", \"cccccc,..... \"zzzzzz.  Also, it is emphasized that these words are RANDOMLY generated, thus a case like this is HIGHLY HIGHLY HIGHLY  unlikely. So you approach the problem based on more likely scenarios, which in this case, is randomness. **\\n\\n**Pre-requisites**\\n\\n- You have to undestand somethig about probability here.  \\n\\n****\\t\\tIf i tell you I have a random letter  in my back pocket, and ask you to guess any letter in the alphabet, the odds that you get it WRONG is  25/26. So you only have 1/26 chance of guessing correctly. This is because, out of the 26 charcters in the alphabet, only 1 of those letters will be the correct answer, and 25 will not be. Thus you have a 25/26 chance of getting it WRONG. \\n\\nNow, if we have a 2 six letter words. Let us say the first words is our SECRET word, and the second is a word in the list given to us. The same logic applies. In position 1  of our Secret word, there is a letter. We do not know what the letter is, but we have a letter also in position 1 of our second word. The odds of the the letter in position 1 in our second word being the same as the letter in position 1 of our Secret word is again, 1/26, because of all the letters, only 1 will match, and 25 will not. So odds of not matching the letter in that position is 25/26. Then the same applies for the letters in position 2,3,4,5, and 6.\\n\\t\\t\\t\\n****\\t\\t\\tThus, if we want to calculate the probability of all of those letters NOT MATCHING, then the probability is as follows\\n**\\t\\t\\t\\t(25/26) * (25/26) * (25/26) * (25/26) * (25/26) * (25/26) = (25/26)^6 == 80%\\n\\t\\t\\t\\nThat is just how the math is done when calculating compounding probablities. Same case if you flip a coin twice and ask for the probability of \"heads.\"  Probability of getting head if only 1 toss is 50/100, probability of getting heads on 2 tosses is  (50/100 ) * (50 / 100) == 25%.\\n\\nAnyways, now we have established that the **probability of a word, not matching the Secret word in any positions is 80%.** So we know that whenever we guess, we have an 80% chance of getting 0 matches. To understand how we are going to use probability that we came up with, we have to understand how we can narrow our options in the list.\\n\\n**There are 7 cases that could happen when we make a guess. Either we get 0 matches with secret, or 1 match, or 2 matches....3,4,5 or 6 matches. Here is what we do. This is key when solving many leetcode questions. Just break down your problem into all divergances / cases.\\n**\\n**EXAMPLES\\n\\n**0 Matches**: Eliminate all words in the list that have any matches with the CURRENT GUESS word. Because if our current word has 0 matches with the Secret word, and another word matches this Current guess word in 1 place, it is guaranteed to not be the secret word.\\n\\n**1 Matches**: Eliminate all words in the list that don\\u2019t match exactly 1 match with this current word. If a word in the list has less than 1 match, then it is guaranteed to not be the secret word, because we know it will not have that 1 character in the right place, otherwise it would have matched this current word. \\n\\nAlternatively, if another word in the list has more than 1 matches with this current word, we know that it is not the secret word, because it is matching wrong characters in other places of this current word that we know are not in secret because they did not match.\\n\\n**2 Matches,  3 Matches, 4 Matches, and 5 Matches** : Same logic as 1 Match.\\n\\n**6 Matches**: We found the Secret word.\\n\\n\\n**KEY IDEA:** So that is our strategy. How do we pick our word? This is where the probability comes in. We know that no matter what word we pick in the Word List, there is an 80% chance it will match the Secret word in 0 places. So Master.guess will return 0 **most** of the time. We know based on the strategy above, that if we guess a word and we get 0 matches, then we eliminate all words in the word list that have even 1 match with the current word we guessed.  So can you figure it out? How do we pick which word to guess now?\\n\\nWe guess the word that has the largest \"similarity\" with other words in the word list first. As in the word that has the least number of 0 matches when it comes to comparing it with other words in the word list. So we Map each word to an Integer which represents the number of words in the word list in which this curr word can get atleast one Match. \\n\\nThen we start choosing words in descending order based on their map value. \\n\\n**Recap: We know that most of the time, 80% of the time actually, Master.guess wil return 0, and we know that when we get a 0, we can eliminate all the words in the list that have 1 or more matches with the word that we guessed, thus choosing the word that has more words that match it in atleast 1 position will result in the most eliminations, and thus, narrowing our list down most.**\\n\\n**Note: Sure, there can be a better choice in the wordlist that will eliminate more words. but the key is to remember that you are working with a quality of randomness where you just don\\'t know. So you use propbablity to your advantage. We know that 80 % of the time, we will get a 0 match with master.guess, so we adjust our strategy to tailor more to that scenario, because given a large enough data set, it is the best approach.**\\\\\\n\\nHere is how the code works.\\n\\n1 - Compare every two Words. Insert each word into a HashMasp, and map it to an Integer that will represent the number of other words in this list that have atleast 1 match with this word.\\n2 - Sort the original list based on the mapped value, in descending order. So the greater the Integer, the more \"first\" it will be.\\n3 - Start guessing from the begining of the list. Apply the strategy above based on the match. Add all the words that \"pass\" onto the next round into a new list, and then do the same thing with the new list. We do not have to sort, new list will already be sorted based on logic. If no words get eliminated, then update the list to the same list but without the element that you just guessed.\\n\\n**This question is about randomness and probabilty, not realy about the 10 guesses. Like I said at the begining. This code will fail given the above test case {aaaaaa,bbbbbb,cccccc.....zzzzzz}, but this code passes here, because...........RANDOM!\\n\\n```\\nclass Solution {\\n  \\n    public void findSecretWord(String[] wordlist, Master master) {\\n         HashMap<String,Integer> map = new HashMap();\\n         HashSet<String> eliminated = new HashSet();\\n        for(int i = 0; i < wordlist.length - 1; i++){\\n           for(int j = i+1; j < wordlist.length; j++){\\n            String word1 = wordlist[i];\\n            String word2 = wordlist[j];\\n               if(!map.containsKey(word1)) map.put(word1,0);\\n               if(!map.containsKey(word2)) map.put(word2,0);\\n               if(comparee(word1,word2) > 0){\\n                   map.put(word1,map.get(word1) + 1);\\n                   map.put(word2,map.get(word1) + 1);\\n               }\\n           }\\n        }\\n        \\n             \\n        Arrays.sort(wordlist, new Comparator<String>(){\\n            public int compare(String w1, String w2){\\n                return map.get(w2) - map.get(w1);\\n            }\\n        });\\n\\n        \\n        for(int i = 0; i < wordlist.length; i++){\\n            String word = wordlist[i];\\n            if(word.length() == 0) continue;            \\n             int count = master.guess(word);\\n            if(count == 6) break;\\n            clean(word,i+1,count,wordlist);\\n        }\\n\\n    \\n    }\\n    \\n    public void clean(String word, int start , int count,String[] wordlist){\\n        for(int i = start; i < wordlist.length; i++){\\n            String currWord = wordlist[i];\\n            if(currWord.length() == 0) continue;\\n            if(comparee(word,currWord) != count) wordlist[i] = \"\";\\n        }\\n    }\\n    \\n    \\n    public int comparee(String w1, String w2){\\n        int count = 0;\\n        for(int i = 0; i < w1.length(); i++){\\n            if(w1.charAt(i) == w2.charAt(i)) count++;\\n        }\\n        return count;\\n    }\\n}\\n``",
                "solutionTags": [],
                "code": "class Solution {\\n  \\n    public void findSecretWord(String[] wordlist, Master master) {\\n         HashMap<String,Integer> map = new HashMap();\\n         HashSet<String> eliminated = new HashSet();\\n        for(int i = 0; i < wordlist.length - 1; i++){\\n           for(int j = i+1; j < wordlist.length; j++){\\n            String word1 = wordlist[i];\\n            String word2 = wordlist[j];\\n               if(!map.containsKey(word1)) map.put(word1,0);\\n               if(!map.containsKey(word2)) map.put(word2,0);\\n               if(comparee(word1,word2) > 0){\\n                   map.put(word1,map.get(word1) + 1);\\n                   map.put(word2,map.get(word1) + 1);\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 133981,
                "title": "screencast-of-leetcode-weekly-contest-86",
                "content": "This is my first screencast video on YouTube\\n\\nhttps://www.youtube.com/watch?v=BDRfqpxkDo4\\n\\nHope it can help people who want to improve their coding skills. Criticism is welcomed :)",
                "solutionTags": [],
                "code": "This is my first screencast video on YouTube\\n\\nhttps://www.youtube.com/watch?v=BDRfqpxkDo4\\n\\nHope it can help people who want to improve their coding skills. Criticism is welcomed :)",
                "codeTag": "Unknown"
            },
            {
                "id": 329960,
                "title": "clean-and-easy-to-understand-minimax-java-solution",
                "content": "At start of the game, we simply have the choice of using each word in the wordlist to call master API, but as we are getting more and more feedbacks from the API, we should eliminate some choice by only keeping the words that have the same number of character matches as the match number returned from the master API. Then we use those words as the possible choices in the next round.\\n\\nSimply adapting the above strategy should give us a pretty good performance in terms of minimizing the number of calls to the master API. However, we could use minimax strategy to further improve the accuracy of our guesses at each round by avoiding choices that has little or no effect of reducing the number of choices we have to make in the next round.\\n\\nThe idea is simply to make a choice that minimizes the maximum possible number of choices (worst outcome) we have to make at each time that we call ```master.guess(word)```. \\n\\n*Note: caching all the similarity between two words is not necessary because the computation is constant time given the length of the string is a constant\\n\\n\\n```\\nclass Solution {\\n    int N = 6;\\n    \\n    public void findSecretWord(String[] words, Master master) {\\n        Set<Integer> options = new HashSet<>();\\n        for (int i = 0; i < words.length; i++) options.add(i);\\n        while (options.size() > 0) {\\n            int min = Integer.MAX_VALUE;\\n            int minIdx = -1;\\n            for (int i : options) {\\n                int max = maxLoss(i, words, options);\\n                if (max < min) {\\n                    min = max;\\n                    minIdx = i;\\n                }\\n            }\\n            int match = master.guess(words[minIdx]);\\n            //made the correct guess, return\\n            if (match == N) return;\\n            Set<Integer> next = new HashSet<>();\\n            for (int i : options) {\\n                if (similarity(words[minIdx], words[i]) == match) {\\n                    next.add(i);\\n                }\\n            }\\n            options = next;\\n        }\\n    }\\n    \\n    private int maxLoss(int wordIdx, String[] words, Set<Integer> options) {\\n        int[] bucket = new int[N];\\n        int maxLoss = 0;\\n        for (int i : options) {\\n            if (!words[wordIdx].equals(words[i])) {\\n                int sim = similarity(words[wordIdx], words[i]);\\n                bucket[sim]++;\\n                maxLoss = Math.max(maxLoss, bucket[sim]);\\n            }\\n        }\\n        return maxLoss;\\n    }\\n    \\n    private int similarity(String s1, String s2) {\\n        int match = 0;\\n        for (int i = 0; i < N; i++) {\\n            match += s1.charAt(i) == s2.charAt(i) ? 1 : 0;\\n        }\\n        return match;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```master.guess(word)```\n```\\nclass Solution {\\n    int N = 6;\\n    \\n    public void findSecretWord(String[] words, Master master) {\\n        Set<Integer> options = new HashSet<>();\\n        for (int i = 0; i < words.length; i++) options.add(i);\\n        while (options.size() > 0) {\\n            int min = Integer.MAX_VALUE;\\n            int minIdx = -1;\\n            for (int i : options) {\\n                int max = maxLoss(i, words, options);\\n                if (max < min) {\\n                    min = max;\\n                    minIdx = i;\\n                }\\n            }\\n            int match = master.guess(words[minIdx]);\\n            //made the correct guess, return\\n            if (match == N) return;\\n            Set<Integer> next = new HashSet<>();\\n            for (int i : options) {\\n                if (similarity(words[minIdx], words[i]) == match) {\\n                    next.add(i);\\n                }\\n            }\\n            options = next;\\n        }\\n    }\\n    \\n    private int maxLoss(int wordIdx, String[] words, Set<Integer> options) {\\n        int[] bucket = new int[N];\\n        int maxLoss = 0;\\n        for (int i : options) {\\n            if (!words[wordIdx].equals(words[i])) {\\n                int sim = similarity(words[wordIdx], words[i]);\\n                bucket[sim]++;\\n                maxLoss = Math.max(maxLoss, bucket[sim]);\\n            }\\n        }\\n        return maxLoss;\\n    }\\n    \\n    private int similarity(String s1, String s2) {\\n        int match = 0;\\n        for (int i = 0; i < N; i++) {\\n            match += s1.charAt(i) == s2.charAt(i) ? 1 : 0;\\n        }\\n        return match;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711901,
                "title": "java-solution-easy-to-understand",
                "content": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Random ran = new Random();\\n        ArrayList<String> possibles = new ArrayList<>();\\n        for (String word : wordlist){\\n            possibles.add(word);\\n        }\\n        int trials = 0;\\n        while (trials < 10){\\n            int index = ran.nextInt(possibles.size());\\n            String testWord = possibles.get(index);\\n            int matches = master.guess(testWord);\\n            if (matches == 6)\\n                return;\\n            ArrayList<String> newPossibles = new ArrayList<>();\\n            for (String word : possibles){\\n                if (countMatches(testWord, word) == matches){\\n                    newPossibles.add(word);\\n                }\\n            }\\n            possibles = newPossibles;\\n            trials++;\\n        }\\n    }\\n    \\n    private int countMatches(String word1, String word2){\\n        int m = 0;\\n        for (int i = 0, j = 0; i < 6 && j < 6; ++i, ++j){\\n            if (word1.charAt(i) == word2.charAt(j)){\\n                m++;\\n            }\\n        }\\n        return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Random ran = new Random();\\n        ArrayList<String> possibles = new ArrayList<>();\\n        for (String word : wordlist){\\n            possibles.add(word);\\n        }\\n        int trials = 0;\\n        while (trials < 10){\\n            int index = ran.nextInt(possibles.size());\\n            String testWord = possibles.get(index);\\n            int matches = master.guess(testWord);\\n            if (matches == 6)\\n                return;\\n            ArrayList<String> newPossibles = new ArrayList<>();\\n            for (String word : possibles){\\n                if (countMatches(testWord, word) == matches){\\n                    newPossibles.add(word);\\n                }\\n            }\\n            possibles = newPossibles;\\n            trials++;\\n        }\\n    }\\n    \\n    private int countMatches(String word1, String word2){\\n        int m = 0;\\n        for (int i = 0, j = 0; i < 6 && j < 6; ++i, ++j){\\n            if (word1.charAt(i) == word2.charAt(j)){\\n                m++;\\n            }\\n        }\\n        return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399738,
                "title": "what-is-an-interactive-problem",
                "content": "What is an interactive problem?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 766231,
                "title": "very-elegant-solution-beating-95-and-thorough-explaination",
                "content": "```\\n/**\\n *  This is the Master\\'s API interface.\\n *  You should not implement it, or speculate about its implementation\\n *  interface Master {\\n *     public int guess(String word) {}\\n *  }\\n */\\nclass Solution {\\n    /*\\n     * I will try to explain this question in a better way than the author did. Here We are given with a wordlist, which contains a secret word. Ex:\\n     * wordlist = <abcmno, demfab, gmhipq, jkldef, limnpq, opqabc> and secret word is limnpq\\n     * Now there is a function guess(String guessWord) supplied by Leetcode backend which returns the number of matches with the secret word. And remember, \\n     * guessWord is always a word from the supplied wordList\\n     * Eg: guess(demfab) means demfab will be compared with secret word (limnpq). so compare(d,l)=0, compare(e,i)=0, compare(m,m)=1, compare(f,n)=0,  \\n     * compare(a,p)=0, compare(b,q)=0. So comparing demfab(it could be any random string from the wordlist) with the secret word returns total match = 1 \\n     * position that matched. Now if guess() is supplied with secret word itself, all characters will match(here 6).\\n     * So the idea is to eliminate some number of strings from word list after each loop until we find 100% match where we can guess the word. If we run the \\n     * loop less that 10 times and find the answer, we are good. If not the test fails. So we have to reduce the search space by eliminating some of the  \\n     * words from wordlist. \\n    */ \\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Random random = new Random();\\n        //First we will have a list constructed from wordlist to keep the original list of words/ original search space given to us\\n        List<String> currentSearchSpace = new ArrayList<>();\\n        for(String s: wordlist)\\n            currentSearchSpace.add(s);\\n        //Now we have to try to guess the word with in 10 attempts. If not we quit\\n        int maxTrials = 10;\\n        int trial = 1;\\n        while(trial<=maxTrials){\\n            //First we try to randomly pick an index in the wordlist and check if that string is the correct word\\n            //This random number could be anything from 0 till size-1\\n            int currentPickIndex = random.nextInt(currentSearchSpace.size());\\n            String currentPickedWord = currentSearchSpace.get(currentPickIndex);\\n            //Check if the guessed word is the secret one by getting number of matches returned from guess()\\n            int numMatches = master.guess(currentPickedWord);\\n            //If we get 6 matches it is all done, as this is the secret word which we guessed\\n            if(numMatches==6) return;\\n            //If not, we create a new search space with all the words with which the currentPickedWord has same\\n            //number of matches numMatches. That means the new search space will include atleast the secret word\\n            //along with (may be) some extra words from the list. But definitely the search space would be smaller \\n            //than the original list provided.\\n            List<String> newSearchSpace = new ArrayList<>();\\n            for(String s: currentSearchSpace){\\n                if(countMatches(currentPickedWord, s)==numMatches)\\n                    newSearchSpace.add(s);\\n            }\\n            //Now assign the newSearchSpace to the currentSearchSpace\\n            currentSearchSpace = new ArrayList(newSearchSpace);\\n            trial++;\\n        } \\n        //If we cannot guess the word in 10 attempts, this test fails.\\n        \\n    }\\n    \\n    public int countMatches(String word1, String word2){\\n        int count = 0;\\n        for(int i=0;i<6;i++){\\n            if(word1.charAt(i)==word2.charAt(i)) count++;\\n        }\\n        return count;\\n    }\\n}\\n\\n//Thanks to jianhuilin1124 for the original solution\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n *  This is the Master\\'s API interface.\\n *  You should not implement it, or speculate about its implementation\\n *  interface Master {\\n *     public int guess(String word) {}\\n *  }\\n */\\nclass Solution {\\n    /*\\n     * I will try to explain this question in a better way than the author did. Here We are given with a wordlist, which contains a secret word. Ex:\\n     * wordlist = <abcmno, demfab, gmhipq, jkldef, limnpq, opqabc> and secret word is limnpq\\n     * Now there is a function guess(String guessWord) supplied by Leetcode backend which returns the number of matches with the secret word. And remember, \\n     * guessWord is always a word from the supplied wordList\\n     * Eg: guess(demfab) means demfab will be compared with secret word (limnpq). so compare(d,l)=0, compare(e,i)=0, compare(m,m)=1, compare(f,n)=0,  \\n     * compare(a,p)=0, compare(b,q)=0. So comparing demfab(it could be any random string from the wordlist) with the secret word returns total match = 1 \\n     * position that matched. Now if guess() is supplied with secret word itself, all characters will match(here 6).\\n     * So the idea is to eliminate some number of strings from word list after each loop until we find 100% match where we can guess the word. If we run the \\n     * loop less that 10 times and find the answer, we are good. If not the test fails. So we have to reduce the search space by eliminating some of the  \\n     * words from wordlist. \\n    */ \\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Random random = new Random();\\n        //First we will have a list constructed from wordlist to keep the original list of words/ original search space given to us\\n        List<String> currentSearchSpace = new ArrayList<>();\\n        for(String s: wordlist)\\n            currentSearchSpace.add(s);\\n        //Now we have to try to guess the word with in 10 attempts. If not we quit\\n        int maxTrials = 10;\\n        int trial = 1;\\n        while(trial<=maxTrials){\\n            //First we try to randomly pick an index in the wordlist and check if that string is the correct word\\n            //This random number could be anything from 0 till size-1\\n            int currentPickIndex = random.nextInt(currentSearchSpace.size());\\n            String currentPickedWord = currentSearchSpace.get(currentPickIndex);\\n            //Check if the guessed word is the secret one by getting number of matches returned from guess()\\n            int numMatches = master.guess(currentPickedWord);\\n            //If we get 6 matches it is all done, as this is the secret word which we guessed\\n            if(numMatches==6) return;\\n            //If not, we create a new search space with all the words with which the currentPickedWord has same\\n            //number of matches numMatches. That means the new search space will include atleast the secret word\\n            //along with (may be) some extra words from the list. But definitely the search space would be smaller \\n            //than the original list provided.\\n            List<String> newSearchSpace = new ArrayList<>();\\n            for(String s: currentSearchSpace){\\n                if(countMatches(currentPickedWord, s)==numMatches)\\n                    newSearchSpace.add(s);\\n            }\\n            //Now assign the newSearchSpace to the currentSearchSpace\\n            currentSearchSpace = new ArrayList(newSearchSpace);\\n            trial++;\\n        } \\n        //If we cannot guess the word in 10 attempts, this test fails.\\n        \\n    }\\n    \\n    public int countMatches(String word1, String word2){\\n        int count = 0;\\n        for(int i=0;i<6;i++){\\n            if(word1.charAt(i)==word2.charAt(i)) count++;\\n        }\\n        return count;\\n    }\\n}\\n\\n//Thanks to jianhuilin1124 for the original solution\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453096,
                "title": "c-solution",
                "content": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        for (int i = 0; i < 10; ++i) {\\n            string& guessWord = wordlist[rand() % wordlist.size()];\\n            int guessMatch = master.guess(guessWord);\\n            \\n            vector<string> newlist;\\n            for (string& word : wordlist) {\\n                if (guessMatch == myMatch(word, guessWord)) {\\n                    newlist.push_back(word);\\n                }\\n            }\\n            wordlist = newlist;\\n        }\\n    }\\n    \\nprivate:\\n    int myMatch(string& word1, string& word2) {\\n        int cnt = 0;\\n        \\n        for (int i = 0; i < 6; ++i) {\\n            if (word1[i] == word2[i]) {\\n                ++cnt;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        for (int i = 0; i < 10; ++i) {\\n            string& guessWord = wordlist[rand() % wordlist.size()];\\n            int guessMatch = master.guess(guessWord);\\n            \\n            vector<string> newlist;\\n            for (string& word : wordlist) {\\n                if (guessMatch == myMatch(word, guessWord)) {\\n                    newlist.push_back(word);\\n                }\\n            }\\n            wordlist = newlist;\\n        }\\n    }\\n    \\nprivate:\\n    int myMatch(string& word1, string& word2) {\\n        int cnt = 0;\\n        \\n        for (int i = 0; i < 6; ++i) {\\n            if (word1[i] == word2[i]) {\\n                ++cnt;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2251007,
                "title": "it-s-not-guaranteed-to-find-the-correct-word-within-10-guesses",
                "content": "For example, consider [\"aaaaaa\", \"aaaaab\", \"aaaaac\", \"aaaaad\", \"aaaaae\", \"aaaaaf\", \"aaaaag\", \"aaaaah\", \"aaaaai\", \"aaaaaj\", \"aaaaak\"]. Each guess other than the correct guess will give you master.guess() = 5, that\\'s it. You need to guess all 11 words to guarantee you find the corret one.",
                "solutionTags": [],
                "code": "For example, consider [\"aaaaaa\", \"aaaaab\", \"aaaaac\", \"aaaaad\", \"aaaaae\", \"aaaaaf\", \"aaaaag\", \"aaaaah\", \"aaaaai\", \"aaaaaj\", \"aaaaak\"]. Each guess other than the correct guess will give you master.guess() = 5, that\\'s it. You need to guess all 11 words to guarantee you find the corret one.",
                "codeTag": "Unknown"
            },
            {
                "id": 1661974,
                "title": "simple-python-solution-with-explanation",
                "content": "## Code\\n```\\nclass Solution:\\n    def findSecretWord(self, words: List[str], master: \\'Master\\') -> None:\\n        words = set(words)\\n        similarity = {}\\n\\n        for w1 in words:\\n            similarity[w1] = {}\\n            for w2 in words:\\n                if w1 == w2:\\n                    continue\\n                similarity[w1][w2] = sum(c1 == c2 for c1, c2 in zip(w1, w2))\\n\\n        def pop_most_similar():\\n            _, word = max((sum(similarity[w].values()), w) for w in words)\\n            words.remove(word)\\n            return word\\n\\n        for _ in range(10):\\n            w1 = pop_most_similar()\\n            if (score := master.guess(w1)) == 6:\\n                break\\n            words = set(w2 for w2 in words if similarity[w1][w2] == score)\\n```\\n\\n## Explanation\\n\\nAt the start I compute similarities between each word. The similarity is just the count of positions where the two words match.\\n\\nThe main logic happens in the `for` loop. I pop the most similar word (explained below), calculate the score, and filter the list of words.\\n\\nHow are the words filtered? If `master.guess(w1) = 3` for instance, that means the **similarity** (as I defined it) between `w1` and the correct word is 3. So I filter out any word whose similarity does not equal score (remember the answer is in the pool of words and `master.guess` is simply returning `similarity[w1][answer]`).\\n\\nThis by itself is already enough but not good enough for the arbitrary 10 guess limit of this problem. So I use the following strategy to choose the next word from the pool of remaining words:\\nChoose the word which has the maximum sum of similarities with other words. Why? It means that word shares a lot with many other words which means if that word is actually far off from the correct answer then we filter out a large number of words in the final step of the for loop.\\n\\n## TL;DR\\n\\n1. precompute similarity (count of matching positions) between all pairs of words\\n2. each iteration pop a word which has the highest similarity with other words among the words left\\n3. calculate score (similarity with the answer)\\n4. filter out all words which don\\'t share that similarity, because `master.guess(w1) == similarity[w1][answer]`",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findSecretWord(self, words: List[str], master: \\'Master\\') -> None:\\n        words = set(words)\\n        similarity = {}\\n\\n        for w1 in words:\\n            similarity[w1] = {}\\n            for w2 in words:\\n                if w1 == w2:\\n                    continue\\n                similarity[w1][w2] = sum(c1 == c2 for c1, c2 in zip(w1, w2))\\n\\n        def pop_most_similar():\\n            _, word = max((sum(similarity[w].values()), w) for w in words)\\n            words.remove(word)\\n            return word\\n\\n        for _ in range(10):\\n            w1 = pop_most_similar()\\n            if (score := master.guess(w1)) == 6:\\n                break\\n            words = set(w2 for w2 in words if similarity[w1][w2] == score)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138581,
                "title": "java-1ms-faster-than-98-21-with-complete-explaination-of-solution",
                "content": "If we observe carefully there are 3 cases when a word is being compared with the secret word\\n\\n\\tCase 1: If current word matches completely with the secret word then number of matched characters will be 6 and we can directly come out of the loop.\\n\\t\\n\\tCase 2: If current word when compared with secret word has \\'x\\' characters matching then we can loop over the word list and can directly remove those words which have matching characters less than \\'x\\' with the current word as they can\\'t be the answer(as they would have even less matching characters if they would be compared to secret word).\\n\\t\\n\\tCase 3: If current word when matched with secret word has \\'0\\' characters matching then we can loop over the word list again and will remove those words that have atleast \\'1\\' character matching with the current word as they can not be the answer(they have a character that is not available in the secret word).\\n\\t\\n\\nWe will be randomly picking the words and then do the above process:\\n\\nBelow is a JAVA implementation of the above approach\\n\\n\\n```\\nclass Solution {\\n    static HashMap<String,Boolean> visited;\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        visited=new HashMap<>();\\n        ArrayList<String> word_list=new ArrayList<>();\\n        for(int i=0;i<wordlist.length;i++)\\n        {\\n            word_list.add(wordlist[i]);\\n        }\\n        //Shuffling the original list to randomly pick a word\\n        Collections.shuffle(word_list);\\n        for(String word:word_list)\\n        {\\n            // This is one of the possible answers as it\\'s unvisited\\n            if(visited.get(word)==null)\\n            {\\n                //We are doing a query here\\n                int char_count=master.guess(word);\\n                visited.put(word,true);\\n                if(char_count==0)\\n                {\\n                    /*\\n                        As no character of this word matches with the secret word\\n                        Now if any other word\\'s character matches with this current word\\'s character then it can\\'t possibly be the answer\\n                    */\\n                    remove_completely(word,word_list);\\n                    continue;\\n                }\\n                if(char_count==6)\\n                {\\n                    break;\\n                }\\n                /*\\n                    Now if \\'x\\' characters have matched with the secret word any other word\\n                    having any less matched character with this current word can\\'t possibly be the answer\\n                */\\n                remove(word,word_list,char_count);\\n            }\\n        }\\n    }\\n    public static void remove_completely(String source,ArrayList<String> word_list)\\n    {\\n        for(String word:word_list)\\n        {\\n            if(word.equals(source))\\n            {\\n                continue;\\n            }\\n            int curr_match_length=check_with_current_word(source,word);\\n            if(curr_match_length>0)\\n            {\\n                //Then mark this word as visited as this can\\'t possibly be the answer\\n                visited.put(word,true);\\n            }\\n        }\\n    }\\n    public static void remove(String source,ArrayList<String> word_list,int matching_char_count_with_secret_word)\\n    {\\n        for(String word:word_list)\\n        {\\n            if(word.equals(source))\\n            {\\n                continue;\\n            }\\n            int curr_match_length=check_with_current_word(source,word);\\n            if(curr_match_length<matching_char_count_with_secret_word)\\n            {\\n                //Then mark this word as visited as this can\\'t possibly be the answer\\n                visited.put(word,true);\\n            }\\n        }\\n    }\\n    public static int check_with_current_word(String source,String word)\\n    {\\n        int count=0;\\n        for(int i=0;i<word.length();i++)\\n        {\\n            if(word.charAt(i)==source.charAt(i))\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\t\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static HashMap<String,Boolean> visited;\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        visited=new HashMap<>();\\n        ArrayList<String> word_list=new ArrayList<>();\\n        for(int i=0;i<wordlist.length;i++)\\n        {\\n            word_list.add(wordlist[i]);\\n        }\\n        //Shuffling the original list to randomly pick a word\\n        Collections.shuffle(word_list);\\n        for(String word:word_list)\\n        {\\n            // This is one of the possible answers as it\\'s unvisited\\n            if(visited.get(word)==null)\\n            {\\n                //We are doing a query here\\n                int char_count=master.guess(word);\\n                visited.put(word,true);\\n                if(char_count==0)\\n                {\\n                    /*\\n                        As no character of this word matches with the secret word\\n                        Now if any other word\\'s character matches with this current word\\'s character then it can\\'t possibly be the answer\\n                    */\\n                    remove_completely(word,word_list);\\n                    continue;\\n                }\\n                if(char_count==6)\\n                {\\n                    break;\\n                }\\n                /*\\n                    Now if \\'x\\' characters have matched with the secret word any other word\\n                    having any less matched character with this current word can\\'t possibly be the answer\\n                */\\n                remove(word,word_list,char_count);\\n            }\\n        }\\n    }\\n    public static void remove_completely(String source,ArrayList<String> word_list)\\n    {\\n        for(String word:word_list)\\n        {\\n            if(word.equals(source))\\n            {\\n                continue;\\n            }\\n            int curr_match_length=check_with_current_word(source,word);\\n            if(curr_match_length>0)\\n            {\\n                //Then mark this word as visited as this can\\'t possibly be the answer\\n                visited.put(word,true);\\n            }\\n        }\\n    }\\n    public static void remove(String source,ArrayList<String> word_list,int matching_char_count_with_secret_word)\\n    {\\n        for(String word:word_list)\\n        {\\n            if(word.equals(source))\\n            {\\n                continue;\\n            }\\n            int curr_match_length=check_with_current_word(source,word);\\n            if(curr_match_length<matching_char_count_with_secret_word)\\n            {\\n                //Then mark this word as visited as this can\\'t possibly be the answer\\n                visited.put(word,true);\\n            }\\n        }\\n    }\\n    public static int check_with_current_word(String source,String word)\\n    {\\n        int count=0;\\n        for(int i=0;i<word.length();i++)\\n        {\\n            if(word.charAt(i)==source.charAt(i))\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1534744,
                "title": "this-problem-is-ridiculous-and-i-will-prove-why-also-python-28ms",
                "content": "At first, let\\'s prove why it\\'s ridiculous and any solution your provide will always fail:\\nThe list of words is \"aaaaaa\", \"aaaaab\", ..., \"aaaaaz\". Return of matcher is always 5. Which are your 10 guesses? Hint: The secret word is none of your guesses. QED\\n\\nConsider the following code, that fails the checks:\\n```\\nclass Solution:\\n    def overlap(self, w1, w2):\\n        return len([None for c1,c2 in zip(w1,w2) if c1==c2])\\n    \\n    def reduce(self, ws, base, i):\\n        return [w for w in ws if self.overlap(w, base) == i]\\n    \\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        for _ in range(10):\\n            word = wordlist[0]\\n            i = master.guess(word)\\n            if i == 6:\\n                return\\n            wordlist = self.reduce(wordlist, word, i)\\n```\\n\\nThe following code passes the checks:\\n```\\nclass Solution:\\n    def overlap(self, w1, w2):\\n        return len([None for c1,c2 in zip(w1,w2) if c1==c2])\\n    \\n    def reduce(self, ws, base, i):\\n        return [w for w in ws if self.overlap(w, base) == i]\\n    \\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        for _ in range(10):\\n            word = wordlist[len(wordlist)//2]\\n            i = master.guess(word)\\n            if i == 6:\\n                return\\n            wordlist = self.reduce(wordlist, word, i)\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def overlap(self, w1, w2):\\n        return len([None for c1,c2 in zip(w1,w2) if c1==c2])\\n    \\n    def reduce(self, ws, base, i):\\n        return [w for w in ws if self.overlap(w, base) == i]\\n    \\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        for _ in range(10):\\n            word = wordlist[0]\\n            i = master.guess(word)\\n            if i == 6:\\n                return\\n            wordlist = self.reduce(wordlist, word, i)\\n```\n```\\nclass Solution:\\n    def overlap(self, w1, w2):\\n        return len([None for c1,c2 in zip(w1,w2) if c1==c2])\\n    \\n    def reduce(self, ws, base, i):\\n        return [w for w in ws if self.overlap(w, base) == i]\\n    \\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        for _ in range(10):\\n            word = wordlist[len(wordlist)//2]\\n            i = master.guess(word)\\n            if i == 6:\\n                return\\n            wordlist = self.reduce(wordlist, word, i)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 665339,
                "title": "very-easy-to-understand-and-straightforward-solution-by-filtering",
                "content": "```\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        List<String> list = new ArrayList<>(Arrays.asList(wordlist));\\n\\n        // we can only guess 10 times.\\n        for(int i = 0; i < 10; i++) {\\n            int index = new Random().nextInt(list.size());\\n            String currentWord = list.get(index);\\n            \\n            int guessMatchCount = master.guess(currentWord);\\n            \\n            // if the guess count matches the length of current word, we found it.\\n            if(guessMatchCount == currentWord.length()) return;\\n            \\n            // remove current.\\n            list.remove(index);\\n            \\n            // find all words that isn\\'t math count of the currentWord guess\\n            int j = 0;\\n            while(j< list.size()) {\\n                if(sameCharaterCount(list.get(j), currentWord) != guessMatchCount) {\\n                    list.remove(j);\\n                } else {\\n                    j++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    private int sameCharaterCount(String a, String b) {\\n        int count = 0;\\n        // a and b has the same length = 6;\\n        for(int i = 0; i < a.length(); i++) {\\n            if(a.charAt(i) == b.charAt(i)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        List<String> list = new ArrayList<>(Arrays.asList(wordlist));\\n\\n        // we can only guess 10 times.\\n        for(int i = 0; i < 10; i++) {\\n            int index = new Random().nextInt(list.size());\\n            String currentWord = list.get(index);\\n            \\n            int guessMatchCount = master.guess(currentWord);\\n            \\n            // if the guess count matches the length of current word, we found it.\\n            if(guessMatchCount == currentWord.length()) return;\\n            \\n            // remove current.\\n            list.remove(index);\\n            \\n            // find all words that isn\\'t math count of the currentWord guess\\n            int j = 0;\\n            while(j< list.size()) {\\n                if(sameCharaterCount(list.get(j), currentWord) != guessMatchCount) {\\n                    list.remove(j);\\n                } else {\\n                    j++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    private int sameCharaterCount(String a, String b) {\\n        int count = 0;\\n        // a and b has the same length = 6;\\n        for(int i = 0; i < a.length(); i++) {\\n            if(a.charAt(i) == b.charAt(i)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413631,
                "title": "javascript-minimax-solution",
                "content": "JavaScript version of \\nhttps://leetcode.com/problems/guess-the-word/discuss/133862/Random-Guess-and-Minimax-Guess-with-Comparison\\nDefinately read that post first.\\n\\n```\\nfunction findSecretWord(wordlist, master) {\\n  function match(a, b) {\\n    let matches = 0;\\n    for (let i = 0; i < a.length; i++) {\\n      if (a[i] === b[i]) matches++;\\n    }\\n    return matches;\\n  }\\n\\n  for (let i = 0, n = 0; i < 10 && n < 6; i++) {\\n    const count = {};\\n    for (const w1 of wordlist) {\\n      for (const w2 of wordlist) {\\n        if (match(w1, w2) === 0) {\\n          if (count[w1] == null) count[w1] = 0;\\n          count[w1]++;\\n        }\\n      }\\n    }\\n\\n    let minimax = [null, Infinity];\\n    for (const w of wordlist) {\\n      if (count[w] == null) count[w] = 0;\\n      if (count[w] < minimax[1]) {\\n        minimax = [w, count[w]];\\n      }\\n    }\\n\\n    n = master.guess(minimax[0]);\\n    const wordlist2 = [];\\n    for (const w of wordlist) {\\n      if (match(minimax[0], w) === n) {\\n        wordlist2.push(w);\\n      }\\n    }\\n    wordlist = wordlist2;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction findSecretWord(wordlist, master) {\\n  function match(a, b) {\\n    let matches = 0;\\n    for (let i = 0; i < a.length; i++) {\\n      if (a[i] === b[i]) matches++;\\n    }\\n    return matches;\\n  }\\n\\n  for (let i = 0, n = 0; i < 10 && n < 6; i++) {\\n    const count = {};\\n    for (const w1 of wordlist) {\\n      for (const w2 of wordlist) {\\n        if (match(w1, w2) === 0) {\\n          if (count[w1] == null) count[w1] = 0;\\n          count[w1]++;\\n        }\\n      }\\n    }\\n\\n    let minimax = [null, Infinity];\\n    for (const w of wordlist) {\\n      if (count[w] == null) count[w] = 0;\\n      if (count[w] < minimax[1]) {\\n        minimax = [w, count[w]];\\n      }\\n    }\\n\\n    n = master.guess(minimax[0]);\\n    const wordlist2 = [];\\n    for (const w of wordlist) {\\n      if (match(minimax[0], w) === n) {\\n        wordlist2.push(w);\\n      }\\n    }\\n    wordlist = wordlist2;\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1873646,
                "title": "clean-code-and-thorough-explanation-the-right-heuristic-to-pick-the-word",
                "content": "We are given a set of 100 words, from which one was selected to be the secret. \\nEach word was generated randomly.\\nWithin 10 guesses we have to find the secret word.\\nThe general idea was implemented many times in the discussion section but how to pick the right guesses is plain wrong.\\n\\nLet\\'s cover the overall steps:\\n1. Pick a word (not randomly! We will discuss this in a moment)\\n2. Run it using the MASTER black box and get back the number of matches with the secret word\\n3. If it\\'s 6 - return (we found it!)\\n4. Else - eliminate all the words that don\\'t have the exact same amount of matches with the word from step 1 \\n\\nThese four steps, as I mentioned, can be seen at any post but they usually get steps 1 and 4 wrong.\\nLet\\'s start with step 4: Why do we need EXACTLY the same amount of matches between the word from step 1 and the master and the word from step 1 with the words we try to eliminate?\\nIt\\'s because if we have too few matches, the tested word can\\'t possibly be the secret word as it\\'s missing crucial letters.\\nE.g: secret word: \"abcde\". word from step1: \"aaccf\" (2 matches). word from step4: \"abkde\" (1 match with \"aaccf\").\\nNote something interesting: \"abkde\" has more matches with the secret word than the word from step1, it\\'s almost a perfect match, but because it matches only 1 letter from the word from step1 (and not two) we know for a fact that it can\\'t be the secret word.\\n\\nOk, but what about words that have more than the needed matches?\\nE.g: secret word: \"abcde\". word from step1: \"aaccf\" (2 matches). word from step4: \"aacde\" (3 matches with \"aaccf\").\\nSince the word from step1 has 2 matches, we know it has (word.length - matches == 3) mismatches.\\nAny additional match between the word from step1 and step4 means a mismatch for the word in step4\\n\\nIt\\'s crucial to get our heads around this as the wrong logic in step4 can render our solution not good enough\\n\\nLet\\'s get to the meat of it: How do we choose the right word in step1?\\nLet me tell you from the get-go - you might pass a few submissions to leetcode by choosing a random word, but eventually, it will fail every now and then. Also, picking a random word without explaining the idea behind it won\\'t fair well for you in an interview.\\n\\nSo, what\\'s the right heuristic? We want to pick the word that has the most matches with all of the other words in the wordlist.\\nWhy is that?\\nSimple combinatorics will tell us that the chance of any two words in our wordlist to have any match on both letter and index is ~20% (1/26 ^ 6). Which is bad! Think about it, every two words you pick are most likely to not share a single match.\\nPicking a random word each time means you are 80% likely to return 0 matches from the master which is very bad for our algorithm as we can\\'t rule out any of the other words.\\n\\nHow can we find the word with the most matches you ask? \\nWe are going to build a frequency map where at each one of the 6 indexes we check what is the most frequent letter and then choose words with the highest \"score\" (meaning, it has as many matches as possible with the other words in the wordlist)\\n\\nArmed with these understandings, implementing the code is easy. Good luck (and feel free to ask questions in the comments)\\n\\n```\\nvar findSecretWord = function(wordlist, master) {\\n    let MAX_TRIES = 10;\\n    \\n    let badWords = new Set();\\n    \\n    let freq = generateLettersFreq(wordlist);\\n    \\n    for(let i = 0; i < MAX_TRIES; i++) {        \\n        let word = getNextWord(wordlist, badWords, freq);\\n        \\n        let matches = master.guess(word);\\n        if(matches == 6) return;\\n        \\n        reduceGuessSpace(word, matches, wordlist, badWords);\\n        badWords.add(word);\\n    }\\n    \\n};\\n\\nlet generateLettersFreq = (wordlist) => {\\n    let freq = new Array(6).fill().map(() => new Array(26).fill(0));\\n    for(let w of wordlist) {\\n        for(let i = 0; i < w.length; i++) {\\n            freq[i][w.codePointAt(i) - 97]++;\\n        }\\n    }\\n    \\n    return freq;\\n}\\n\\nlet getNextWord = (wordlist, badWords, freq) => {\\n    let bestWord = \"\";\\n    let bestScore = -Infinity;\\n    \\n    for(let w of wordlist) {\\n        let wordScore = 0;\\n        for(let i = 0; i < w.length; i++) {\\n            wordScore += freq[i][w.codePointAt(i) - 97];\\n        }\\n        \\n        if(wordScore > bestScore && !badWords.has(w)) {\\n            bestWord = w;\\n            bestScore = wordScore;\\n        }\\n    }\\n    \\n    return bestWord;\\n    \\n}\\n\\nlet reduceGuessSpace = (word, mathces, wordlist, badWords) => {\\n    for(let w of wordlist) {\\n        let countMatches = 0;\\n        for(let i = 0; i < w.length; i++)\\n            if(word[i] == w[i]) countMatches++;\\n        \\n        if(countMatches != mathces) badWords.add(w);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar findSecretWord = function(wordlist, master) {\\n    let MAX_TRIES = 10;\\n    \\n    let badWords = new Set();\\n    \\n    let freq = generateLettersFreq(wordlist);\\n    \\n    for(let i = 0; i < MAX_TRIES; i++) {        \\n        let word = getNextWord(wordlist, badWords, freq);\\n        \\n        let matches = master.guess(word);\\n        if(matches == 6) return;\\n        \\n        reduceGuessSpace(word, matches, wordlist, badWords);\\n        badWords.add(word);\\n    }\\n    \\n};\\n\\nlet generateLettersFreq = (wordlist) => {\\n    let freq = new Array(6).fill().map(() => new Array(26).fill(0));\\n    for(let w of wordlist) {\\n        for(let i = 0; i < w.length; i++) {\\n            freq[i][w.codePointAt(i) - 97]++;\\n        }\\n    }\\n    \\n    return freq;\\n}\\n\\nlet getNextWord = (wordlist, badWords, freq) => {\\n    let bestWord = \"\";\\n    let bestScore = -Infinity;\\n    \\n    for(let w of wordlist) {\\n        let wordScore = 0;\\n        for(let i = 0; i < w.length; i++) {\\n            wordScore += freq[i][w.codePointAt(i) - 97];\\n        }\\n        \\n        if(wordScore > bestScore && !badWords.has(w)) {\\n            bestWord = w;\\n            bestScore = wordScore;\\n        }\\n    }\\n    \\n    return bestWord;\\n    \\n}\\n\\nlet reduceGuessSpace = (word, mathces, wordlist, badWords) => {\\n    for(let w of wordlist) {\\n        let countMatches = 0;\\n        for(let i = 0; i < w.length; i++)\\n            if(word[i] == w[i]) countMatches++;\\n        \\n        if(countMatches != mathces) badWords.add(w);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 652210,
                "title": "clean-java-solution-with-explanation-of-minmax",
                "content": "```java\\n/**\\n *  Idea: This will use the MinMax Algorithmic idea to prune the search space\\n *  MiniMax: https://www.youtube.com/watch?v=KU9Ch59-4vw\\n *  Ideas from where I understood it: https://leetcode.com/problems/guess-the-word/discuss/133862/Random-Guess-and-Minimax-Guess-with-Comparison\\n *  \\n *  \\n *  Idea 1: \\n *  We can randomly pickup the words, guess it and find the number of correct characters\\n *  Then we prune the search space (wordlist) by keeping only those words which is having \\n *  same number of matching characters with the current word which the master.guess() returned\\n *  Example: For string1, guess returned 2, meaning 2 characters are correct, so we keep only \\n *  those words in word list which is have exactly 2 character matches with current word\\n *  \\n *  Idea 2: \\n *  Probability of getting 0 matched is (25/26)^6 (because the correct one is only having 1 character\\n *  out of 26 alphabates and this is for all 6 position, so probability of getting a non match is (1-(1/26)))\\n *  This is around 80%. So we have 80% chance of getting a 0 match and with that we can greatly prune the \\n *  word list just by removing any words which is having any match with the 0 match guess. So we use this \\n *  to eliminate as many candidate as possible. So we need to find a word which is having higher number of \\n *  matching neighbours, so we can destroy that complete cluster if it is a 0 match. That is also can be viewed\\n *  as fewest 0 match with other words. \\n *  \\n *  Idea 3:\\n *  We select words by scoring them. We go through the wordlist and for each 6 positions we count the frequency \\n *  of each alphabate. Say at first position \\'p\\' is dominating with count of 7, for second position \\'n\\' is dominating\\n *  with 9 counts. If we are allowed to guess outside the wordlist we would\\'ve guessed these top frequency characters\\n *  of each position concatenated into a string. This will have very high chance of getting a huge family of matching \\n *  strings. In current situation we can\\'t do that. Thus we score each word by checking its characters against these \\n *  frequencies. The words having more character on the higher end of the frequency list, we guess those ones\\n *  this will auto select the word with biggest family. (We implement this idea here)\\n *  \\n */\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        // We can\\'t guess more than 10 times!\\n        for (int t = 0; t < 10; ++t) {\\n            String guessThis = getAGuessCandidate(wordlist);\\n            int noOfMatches = master.guess(guessThis);\\n            if (noOfMatches == 6)\\n                return; // don\\'t guess more\\n\\n            List<String> wordlist2 = new ArrayList<String>();\\n            for (String w : wordlist) {\\n                if (noOfMatchingCharacter(guessThis, w) == noOfMatches)\\n                    wordlist2.add(w);\\n            }\\n\\n            wordlist = wordlist2.toArray(new String[0]);\\n        }\\n    }\\n    \\n    private String getAGuessCandidate(String[] wordlist) {\\n        // For each 6 positions it is possible to have 26 characters\\n        int[][] positionToCharacterFreq = new int[6][26]; \\n        \\n        for (int i = 0; i < wordlist.length; i++) {\\n            for (int j = 0; j < 6; j++) {\\n                char currentChar = wordlist[i].charAt(j);\\n                positionToCharacterFreq[j][currentChar - \\'a\\']++; \\n            }\\n        }\\n        \\n        // score the words and pickup the one with highest score\\n        int bestScore = 0;\\n        String wordWithBestScore = \"\";\\n        for (int i = 0; i < wordlist.length; i++) {\\n            int currentScore = 0;\\n            for (int j = 0; j < 6; j++) {\\n                char currentChar = wordlist[i].charAt(j);\\n                currentScore += positionToCharacterFreq[j][currentChar - \\'a\\'];\\n            }\\n            if (currentScore > bestScore) {\\n                bestScore = currentScore;\\n                wordWithBestScore = wordlist[i];\\n            }\\n        }\\n        \\n        return wordWithBestScore;\\n    }\\n    \\n    private int noOfMatchingCharacter(String s1, String s2) {\\n        int count = 0;\\n        for (int i = 0; i < s1.length(); i++) {\\n            if (s1.charAt(i) == s2.charAt(i))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n/**\\n *  Idea: This will use the MinMax Algorithmic idea to prune the search space\\n *  MiniMax: https://www.youtube.com/watch?v=KU9Ch59-4vw\\n *  Ideas from where I understood it: https://leetcode.com/problems/guess-the-word/discuss/133862/Random-Guess-and-Minimax-Guess-with-Comparison\\n *  \\n *  \\n *  Idea 1: \\n *  We can randomly pickup the words, guess it and find the number of correct characters\\n *  Then we prune the search space (wordlist) by keeping only those words which is having \\n *  same number of matching characters with the current word which the master.guess() returned\\n *  Example: For string1, guess returned 2, meaning 2 characters are correct, so we keep only \\n *  those words in word list which is have exactly 2 character matches with current word\\n *  \\n *  Idea 2: \\n *  Probability of getting 0 matched is (25/26)^6 (because the correct one is only having 1 character\\n *  out of 26 alphabates and this is for all 6 position, so probability of getting a non match is (1-(1/26)))\\n *  This is around 80%. So we have 80% chance of getting a 0 match and with that we can greatly prune the \\n *  word list just by removing any words which is having any match with the 0 match guess. So we use this \\n *  to eliminate as many candidate as possible. So we need to find a word which is having higher number of \\n *  matching neighbours, so we can destroy that complete cluster if it is a 0 match. That is also can be viewed\\n *  as fewest 0 match with other words. \\n *  \\n *  Idea 3:\\n *  We select words by scoring them. We go through the wordlist and for each 6 positions we count the frequency \\n *  of each alphabate. Say at first position \\'p\\' is dominating with count of 7, for second position \\'n\\' is dominating\\n *  with 9 counts. If we are allowed to guess outside the wordlist we would\\'ve guessed these top frequency characters\\n *  of each position concatenated into a string. This will have very high chance of getting a huge family of matching \\n *  strings. In current situation we can\\'t do that. Thus we score each word by checking its characters against these \\n *  frequencies. The words having more character on the higher end of the frequency list, we guess those ones\\n *  this will auto select the word with biggest family. (We implement this idea here)\\n *  \\n */\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        // We can\\'t guess more than 10 times!\\n        for (int t = 0; t < 10; ++t) {\\n            String guessThis = getAGuessCandidate(wordlist);\\n            int noOfMatches = master.guess(guessThis);\\n            if (noOfMatches == 6)\\n                return; // don\\'t guess more\\n\\n            List<String> wordlist2 = new ArrayList<String>();\\n            for (String w : wordlist) {\\n                if (noOfMatchingCharacter(guessThis, w) == noOfMatches)\\n                    wordlist2.add(w);\\n            }\\n\\n            wordlist = wordlist2.toArray(new String[0]);\\n        }\\n    }\\n    \\n    private String getAGuessCandidate(String[] wordlist) {\\n        // For each 6 positions it is possible to have 26 characters\\n        int[][] positionToCharacterFreq = new int[6][26]; \\n        \\n        for (int i = 0; i < wordlist.length; i++) {\\n            for (int j = 0; j < 6; j++) {\\n                char currentChar = wordlist[i].charAt(j);\\n                positionToCharacterFreq[j][currentChar - \\'a\\']++; \\n            }\\n        }\\n        \\n        // score the words and pickup the one with highest score\\n        int bestScore = 0;\\n        String wordWithBestScore = \"\";\\n        for (int i = 0; i < wordlist.length; i++) {\\n            int currentScore = 0;\\n            for (int j = 0; j < 6; j++) {\\n                char currentChar = wordlist[i].charAt(j);\\n                currentScore += positionToCharacterFreq[j][currentChar - \\'a\\'];\\n            }\\n            if (currentScore > bestScore) {\\n                bestScore = currentScore;\\n                wordWithBestScore = wordlist[i];\\n            }\\n        }\\n        \\n        return wordWithBestScore;\\n    }\\n    \\n    private int noOfMatchingCharacter(String s1, String s2) {\\n        int count = 0;\\n        for (int i = 0; i < s1.length(); i++) {\\n            if (s1.charAt(i) == s2.charAt(i))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 199811,
                "title": "python3-beats-100-using-elimination",
                "content": "The idea is to first sort the wordlist by each word\\'s similarity to the other words. This is done by counting how many matches each word has for the same character in the same position compared to each other word, and then sorting according to this number. Then, we repeatedly guess the word that has the maximum similarity, and then remove words that are not possible.\\n\\n\\n\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n        \\n    def findSecretWord(self, wordlist, master):\\n        \"\"\"\\n        :type wordlist: List[Str]\\n        :type master: Master\\n        :rtype: None\\n        \"\"\"\\n        \\n        def countMatches(w1, w2):\\n            return sum(1 for c1, c2 in zip(w1, w2) if c1 == c2)\\n        \\n        def wordScore(char_pos_to_count):\\n            return lambda word: sum(char_pos_to_count[(c, i)] for i, c in enumerate(word))\\n                    \\n        if len(wordlist) == 1:\\n            master.guess(wordlist[0])\\n        \\n        possible = list(wordlist) # for some reason there\\'s an error in master.guess() if wordlist is directly modified\\n        \\n        char_pos_to_count = defaultdict(lambda: 0)\\n\\n        for word in possible:\\n            for pos, char in enumerate(word):\\n                char_pos_to_count[(char, pos)] += 1\\n\\n        possible.sort(key=wordScore(char_pos_to_count))\\n        \\n        for _ in range(10):\\n            \\n            if len(possible) == 1:\\n                master.guess(possible[0])\\n                return\\n            \\n            guessed = possible.pop()\\n            verdict = master.guess(guessed)\\n            \\n            if verdict == 6:\\n                return\\n            \\n            possible = [w for w in possible if countMatches(w, guessed) == verdict]\\n        \\n        return\\n```\\t\\t",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n        \\n    def findSecretWord(self, wordlist, master):\\n        \"\"\"\\n        :type wordlist: List[Str]\\n        :type master: Master\\n        :rtype: None\\n        \"\"\"\\n        \\n        def countMatches(w1, w2):\\n            return sum(1 for c1, c2 in zip(w1, w2) if c1 == c2)\\n        \\n        def wordScore(char_pos_to_count):\\n            return lambda word: sum(char_pos_to_count[(c, i)] for i, c in enumerate(word))\\n                    \\n        if len(wordlist) == 1:\\n            master.guess(wordlist[0])\\n        \\n        possible = list(wordlist) # for some reason there\\'s an error in master.guess() if wordlist is directly modified\\n        \\n        char_pos_to_count = defaultdict(lambda: 0)\\n\\n        for word in possible:\\n            for pos, char in enumerate(word):\\n                char_pos_to_count[(char, pos)] += 1\\n\\n        possible.sort(key=wordScore(char_pos_to_count))\\n        \\n        for _ in range(10):\\n            \\n            if len(possible) == 1:\\n                master.guess(possible[0])\\n                return\\n            \\n            guessed = possible.pop()\\n            verdict = master.guess(guessed)\\n            \\n            if verdict == 6:\\n                return\\n            \\n            possible = [w for w in possible if countMatches(w, guessed) == verdict]\\n        \\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535024,
                "title": "c-clear-implementation-100-faster",
                "content": "There are a lot of posts with great explanations, so you can refer those, but few had clear C++ implementations that were beginner friendly. \\n![image](https://assets.leetcode.com/users/images/27275bf0-5963-4c63-ba3b-3aef312ea42a_1662387536.392677.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int check( string &a, string &b) {\\n        int ct = 0 ; \\n        for(int i =0 ; i < 6 ; i++) \\n            if(a[i] == b[i])\\n                ct++ ; \\n        return ct ; \\n    }\\n    \\n    void findSecretWord(vector<string>& words, Master& master) {\\n        for(int i=0, matches = 0; i < 30 and matches !=6 ; i++) {\\n            string trial = words[words.size()/2]  ; // since we have to pick a random word for each iteration\\n            matches = master.guess(trial) ; \\n            vector<string> possibilities ; \\n            for(auto word: words) {\\n                if(check(word, trial) == matches)\\n                    possibilities.push_back(word); \\n            }\\n            words = possibilities ; \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check( string &a, string &b) {\\n        int ct = 0 ; \\n        for(int i =0 ; i < 6 ; i++) \\n            if(a[i] == b[i])\\n                ct++ ; \\n        return ct ; \\n    }\\n    \\n    void findSecretWord(vector<string>& words, Master& master) {\\n        for(int i=0, matches = 0; i < 30 and matches !=6 ; i++) {\\n            string trial = words[words.size()/2]  ; // since we have to pick a random word for each iteration\\n            matches = master.guess(trial) ; \\n            vector<string> possibilities ; \\n            for(auto word: words) {\\n                if(check(word, trial) == matches)\\n                    possibilities.push_back(word); \\n            }\\n            words = possibilities ; \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940407,
                "title": "o-n-with-detailed-explanation-python-javascript-golang",
                "content": "Interesting question, poorly written by a certain individual (again!).\\nKey:\\n- Understand that the question only cares about the highest possibility that the code can get the secret word i.e. within 10 attempts, find the quickest way to get the secret word.\\n- Therefore, we need to minimise the use of API `master.guess()` and once we have to call it, we need to narrow down the candidates.\\n- We have x = master.guess(word)\\nif x == 6, we find the secret word, the algorithm ends\\nif x != 6, it means the secret word has exactly x matches with the word\\nBecause the secret word has exactly x matches with the word, we can just search in the candidates, and only keep the ones that have exact x matches with the word. With that, we can narrow the candidates after we call master.guess(), and guarantee that the secret is in the remaining candidates.\\n\\nFor more detailed explanation, check this post (the best explanation in my opinion):\\nhttps://leetcode.com/problems/guess-the-word/discuss/556075/How-to-explain-to-interviewer-843.-Guess-the-Word\\n\\nTime: `O(n)` where n = len(wordlist) because the for loop runs 10 or fewer times `O(10)` and in each iteration, we traverse the wordlist: `O(n)` -> `O(10*n)` remove constant = `O(n)`\\nSpace: `O(n)` because we run the check 10 times, each time we create a new list of candidates with at most n length -> `O(10*n)` remove constant = `O(n)`\\n\\nPython\\n\\n```python\\nfrom random import randrange\\nclass Solution:\\n    def findSecretWord(self, wordlist: [str], master: \\'Master\\') -> None:\\n        for _ in range(10):\\n            random_idx = randrange(len(wordlist))\\n            guess_word = wordlist[random_idx]\\n            matches = master.guess(guess_word)\\n            candidates = []\\n            for word in wordlist:\\n                if matches == self._get_matches_between(guess_word, word):\\n                    candidates.append(word)\\n            wordlist = candidates\\n    def _get_matches_between(self, word1, word2):\\n        matches = 0\\n        for i in range(len(word1)):\\n            if word1[i] == word2[i]:\\n                matches += 1\\n        return matches\\n```\\n\\nJavaScript\\n\\n```javascript\\nvar findSecretWord = function(wordlist, master) {\\n    for (let i = 0; i < 10; i++) {\\n        const randomIdx = getRandomIntInclusive(0, wordlist.length - 1);\\n        const guessWord = wordlist[randomIdx];\\n        const matches = master.guess(guessWord);\\n        const candidates = [];\\n        for (const word of wordlist) {\\n            if (matches === getMatchesBetween(guessWord, word)) {\\n                candidates.push(word);\\n            }\\n        }\\n        wordlist = candidates;\\n    }\\n};\\n\\nfunction getMatchesBetween(word1, word2) {\\n    let matches = 0;\\n    for (let i = 0; i < word1.length; i++) {\\n        if (word1[i] === word2[i]) {\\n            matches++;\\n        }\\n    }\\n    return matches;\\n}\\n\\nfunction getRandomIntInclusive(min, max) {\\n  min = Math.ceil(min);\\n  max = Math.floor(max);\\n  return Math.floor(Math.random() * (max - min + 1) + min); //The maximum is inclusive and the minimum is inclusive \\n}\\n```\\n\\nGoLang\\n\\n```go\\nimport (\\n    \"math/rand\"\\n)\\nfunc findSecretWord(wordlist []string, master *Master) {\\n    for i := 0; i < 10; i++ {\\n        randomIdx := rand.Intn(len(wordlist))\\n        guessWord := wordlist[randomIdx]\\n        maches := master.guess(guessWord)\\n        candidates := []string{}\\n        for _, word := range wordlist {\\n            if maches == getMatchesBetween(guessWord, word) {\\n                candidates = append(candidates, word)\\n            }\\n        }\\n        wordlist = candidates\\n    }\\n}\\n\\nfunc getMatchesBetween(word1, word2 string) int {\\n    matches := 0\\n    for i := 0; i < len(word1); i++ {\\n        if word1[i] == word2[i] {\\n            matches++\\n        }\\n    }\\n    return matches\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "JavaScript",
                    "Go"
                ],
                "code": "```python\\nfrom random import randrange\\nclass Solution:\\n    def findSecretWord(self, wordlist: [str], master: \\'Master\\') -> None:\\n        for _ in range(10):\\n            random_idx = randrange(len(wordlist))\\n            guess_word = wordlist[random_idx]\\n            matches = master.guess(guess_word)\\n            candidates = []\\n            for word in wordlist:\\n                if matches == self._get_matches_between(guess_word, word):\\n                    candidates.append(word)\\n            wordlist = candidates\\n    def _get_matches_between(self, word1, word2):\\n        matches = 0\\n        for i in range(len(word1)):\\n            if word1[i] == word2[i]:\\n                matches += 1\\n        return matches\\n```\n```javascript\\nvar findSecretWord = function(wordlist, master) {\\n    for (let i = 0; i < 10; i++) {\\n        const randomIdx = getRandomIntInclusive(0, wordlist.length - 1);\\n        const guessWord = wordlist[randomIdx];\\n        const matches = master.guess(guessWord);\\n        const candidates = [];\\n        for (const word of wordlist) {\\n            if (matches === getMatchesBetween(guessWord, word)) {\\n                candidates.push(word);\\n            }\\n        }\\n        wordlist = candidates;\\n    }\\n};\\n\\nfunction getMatchesBetween(word1, word2) {\\n    let matches = 0;\\n    for (let i = 0; i < word1.length; i++) {\\n        if (word1[i] === word2[i]) {\\n            matches++;\\n        }\\n    }\\n    return matches;\\n}\\n\\nfunction getRandomIntInclusive(min, max) {\\n  min = Math.ceil(min);\\n  max = Math.floor(max);\\n  return Math.floor(Math.random() * (max - min + 1) + min); //The maximum is inclusive and the minimum is inclusive \\n}\\n```\n```go\\nimport (\\n    \"math/rand\"\\n)\\nfunc findSecretWord(wordlist []string, master *Master) {\\n    for i := 0; i < 10; i++ {\\n        randomIdx := rand.Intn(len(wordlist))\\n        guessWord := wordlist[randomIdx]\\n        maches := master.guess(guessWord)\\n        candidates := []string{}\\n        for _, word := range wordlist {\\n            if maches == getMatchesBetween(guessWord, word) {\\n                candidates = append(candidates, word)\\n            }\\n        }\\n        wordlist = candidates\\n    }\\n}\\n\\nfunc getMatchesBetween(word1, word2 string) int {\\n    matches := 0\\n    for i := 0; i < len(word1); i++ {\\n        if word1[i] == word2[i] {\\n            matches++\\n        }\\n    }\\n    return matches\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736718,
                "title": "java-easy-to-read",
                "content": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    private final static int MAX_GUESS_CALLS = 10;\\n    \\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Set<String> words = new HashSet<>();\\n        for(String word : wordlist) {\\n            words.add(word);\\n        }\\n        \\n        //basic case\\n        if(words.size() <= MAX_GUESS_CALLS) {\\n            words.forEach(master::guess);\\n            return;\\n        }\\n        \\n        for(int i = 0; i < MAX_GUESS_CALLS; i++) {\\n            String guessedWord = words.iterator().next();\\n            int matches = master.guess(guessedWord);\\n            if(matches == guessedWord.length()) return;\\n            \\n            reduceGuessBase(words, guessedWord, matches);\\n        }\\n    }\\n    \\n    private void reduceGuessBase(Set<String> words, String guessedWord, int matches) {\\n        Iterator<String> wordsIterator = words.iterator();\\n        while(wordsIterator.hasNext()) {\\n            String word = wordsIterator.next();\\n            int matchCount = 0;\\n            for(int i = 0; i < word.length(); i++) {\\n                if(word.charAt(i) == guessedWord.charAt(i)) matchCount++;\\n                if(matchCount > matches) break;\\n            }\\n            \\n            if(matchCount != matches) wordsIterator.remove();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    private final static int MAX_GUESS_CALLS = 10;\\n    \\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Set<String> words = new HashSet<>();\\n        for(String word : wordlist) {\\n            words.add(word);\\n        }\\n        \\n        //basic case\\n        if(words.size() <= MAX_GUESS_CALLS) {\\n            words.forEach(master::guess);\\n            return;\\n        }\\n        \\n        for(int i = 0; i < MAX_GUESS_CALLS; i++) {\\n            String guessedWord = words.iterator().next();\\n            int matches = master.guess(guessedWord);\\n            if(matches == guessedWord.length()) return;\\n            \\n            reduceGuessBase(words, guessedWord, matches);\\n        }\\n    }\\n    \\n    private void reduceGuessBase(Set<String> words, String guessedWord, int matches) {\\n        Iterator<String> wordsIterator = words.iterator();\\n        while(wordsIterator.hasNext()) {\\n            String word = wordsIterator.next();\\n            int matchCount = 0;\\n            for(int i = 0; i < word.length(); i++) {\\n                if(word.charAt(i) == guessedWord.charAt(i)) matchCount++;\\n                if(matchCount > matches) break;\\n            }\\n            \\n            if(matchCount != matches) wordsIterator.remove();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159225,
                "title": "java-faster-than-98-comments-available-easy-to-understand",
                "content": "```\\nclass Solution {    \\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Set<String> words = new HashSet<>(Arrays.asList(wordlist));             \\n        while (true) {\\n            Iterator iterator = words.iterator();\\n            \\n            // Make a guess. If the secret is guessed, just return. If not, store that word in curWord.\\n            String curWord = (String)iterator.next();\\n            int currentMatching = master.guess(curWord);\\n            if (currentMatching == 6) return;\\n            \\n            // Start a new loop and delete all strings that have a different matching count.\\n            // Let\\'s say the secret and curWord have 3 matching count. \\n            // It is safe to delete all words that do not have 3 matching count.\\n            while (iterator.hasNext()) {                \\n                if (!doTheyHaveSameMatchingCount(curWord, (String)iterator.next(), currentMatching)) {\\n                    iterator.remove();\\n                }                \\n            }\\n            words.remove(curWord);\\n        }        \\n    }\\n    \\n    public boolean doTheyHaveSameMatchingCount(String curWord, String nextWord, int k) {\\n        int count = 0;\\n        for (int i = 0; i < 6; i++) {\\n            if (nextWord.charAt(i) == curWord.charAt(i)) {\\n                count++;\\n            }\\n        }\\n        return k == count;       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {    \\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Set<String> words = new HashSet<>(Arrays.asList(wordlist));             \\n        while (true) {\\n            Iterator iterator = words.iterator();\\n            \\n            // Make a guess. If the secret is guessed, just return. If not, store that word in curWord.\\n            String curWord = (String)iterator.next();\\n            int currentMatching = master.guess(curWord);\\n            if (currentMatching == 6) return;\\n            \\n            // Start a new loop and delete all strings that have a different matching count.\\n            // Let\\'s say the secret and curWord have 3 matching count. \\n            // It is safe to delete all words that do not have 3 matching count.\\n            while (iterator.hasNext()) {                \\n                if (!doTheyHaveSameMatchingCount(curWord, (String)iterator.next(), currentMatching)) {\\n                    iterator.remove();\\n                }                \\n            }\\n            words.remove(curWord);\\n        }        \\n    }\\n    \\n    public boolean doTheyHaveSameMatchingCount(String curWord, String nextWord, int k) {\\n        int count = 0;\\n        for (int i = 0; i < 6; i++) {\\n            if (nextWord.charAt(i) == curWord.charAt(i)) {\\n                count++;\\n            }\\n        }\\n        return k == count;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785012,
                "title": "javascript",
                "content": "Adapted solution from Soheil-Brian without sort.\\nhttps://leetcode.com/problems/guess-the-word/discuss/516478/Javascript-short-and-clear\\n```\\nconst match = (w1, w2) => {\\n    let c = 0;                                                  // Number of same letters at exact indexes between two words\\n    for(let i=0; i < w1.length; i++){\\n        if(w1[i] == w2[i]){ c++ ;}\\n    }\\n    return c;\\n}\\n\\nconst findSecretWord = (wordlist, master) => {\\n    for(let i=0; i < 10; i++){\\n        const word = wordlist[Math.floor(Math.random() * wordlist.length)];\\n        const N = master.guess(word);                            // Number of same letters at exact indexes between selected word and secret.\\n        if(N == 6 ){ return ;}\\n        const temp = N === -1 ? wordlist.filter( w => match(w, word) == 0) : wordlist.filter( w => match(w, word) == N);\\n        wordlist = temp;                                        \\n    }  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst match = (w1, w2) => {\\n    let c = 0;                                                  // Number of same letters at exact indexes between two words\\n    for(let i=0; i < w1.length; i++){\\n        if(w1[i] == w2[i]){ c++ ;}\\n    }\\n    return c;\\n}\\n\\nconst findSecretWord = (wordlist, master) => {\\n    for(let i=0; i < 10; i++){\\n        const word = wordlist[Math.floor(Math.random() * wordlist.length)];\\n        const N = master.guess(word);                            // Number of same letters at exact indexes between selected word and secret.\\n        if(N == 6 ){ return ;}\\n        const temp = N === -1 ? wordlist.filter( w => match(w, word) == 0) : wordlist.filter( w => match(w, word) == N);\\n        wordlist = temp;                                        \\n    }  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 381530,
                "title": "java-rookie-solution-1ms-100-with-explanation",
                "content": "// use the answer from master.guess as a filter to shrink the range of candidates, secret will always pass the filter.\\n```\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n    List<String > list = new ArrayList<>(Arrays.asList(wordlist)); \\n\\t// transfer String[] to list, so that we can remove item.\\n    for(int i =0 ;i<10;i++){\\n        String s = list.get(0);\\n        int  a = master.guess(s);\\n        // get the feedback and use it to shrink the range of candidates.\\n        if(a==s.length()) return;\\n\\t\\t// if answer is right, stop this program.\\n        list.remove(0);\\n\\t\\t// if answer is wrong, remove the guessed string because if we dont remove it, it will always meet the filter.\\n        int j=0;\\n\\t\\t// remove all items which have different answer with we guessed string, we should know that the correct answer can meet the filter all the time.\\n        while( j<list.size()){\\n            if(compare(list.get(j),s)!=a ||( a==0 && compare(list.get(j),s)>a)){\\n                list.remove(j);\\n            }\\n            else j++;\\n        }\\n        Collections.sort(list);\\n\\t\\t//the final testcase need 11times....... use sort to be more lucky ^-^\\n    }\\n\\n    }\\n    private int compare(String s1, String s2){\\n        int ans =0;\\n        for(int i =0;i<s1.length();i++){\\n            if(s1.charAt(i)==s2.charAt(i)) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n    List<String > list = new ArrayList<>(Arrays.asList(wordlist)); \\n\\t// transfer String[] to list, so that we can remove item.\\n    for(int i =0 ;i<10;i++){\\n        String s = list.get(0);\\n        int  a = master.guess(s);\\n        // get the feedback and use it to shrink the range of candidates.\\n        if(a==s.length()) return;\\n\\t\\t// if answer is right, stop this program.\\n        list.remove(0);\\n\\t\\t// if answer is wrong, remove the guessed string because if we dont remove it, it will always meet the filter.\\n        int j=0;\\n\\t\\t// remove all items which have different answer with we guessed string, we should know that the correct answer can meet the filter all the time.\\n        while( j<list.size()){\\n            if(compare(list.get(j),s)!=a ||( a==0 && compare(list.get(j),s)>a)){\\n                list.remove(j);\\n            }\\n            else j++;\\n        }\\n        Collections.sort(list);\\n\\t\\t//the final testcase need 11times....... use sort to be more lucky ^-^\\n    }\\n\\n    }\\n    private int compare(String s1, String s2){\\n        int ans =0;\\n        for(int i =0;i<s1.length();i++){\\n            if(s1.charAt(i)==s2.charAt(i)) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643136,
                "title": "elimination-simplest-solution-works-69-of-the-times",
                "content": "Approach:\\n1) Start with the list of words and choose a random word. \\n2) Guess this word and check the matching characters t\\n3) Eliminate all words whose similarity with the chosen word isnt t.\\n\\tFor example: If the chosen word matches 3 with the actual word (using custom similarity function sim),  then a word that match > 3 will not be the solution otherwise the match with the chosen word it self would be > 3. Same with words that match < 3. \\n```\\nclass Solution(object):\\n\\t#counts the similiarity between two words.\\n    def sim(self, word1, word2):\\n        count = 0\\n        for i in range(6):\\n            if word1[i] == word2[i]:\\n                count += 1\\n        return count\\n    \\n    def findSecretWord(self, words, master):\\n        count = 0\\n        words = list(set(words)) # remove duplicate words\\n        \\n        while words:\\n            rw = random.choice(words) # contributes to the 69%\\n            t = master.guess(rw)\\n            if t == 6:\\n                return\\n            nw = []\\n\\n            for i in range(len(words)):\\n                if self.sim(rw, words[i]) == t:\\n                    nw.append(words[i])\\n            words = nw\\n\\t\\t\\t",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "Approach:\\n1) Start with the list of words and choose a random word. \\n2) Guess this word and check the matching characters t\\n3) Eliminate all words whose similarity with the chosen word isnt t.\\n\\tFor example: If the chosen word matches 3 with the actual word (using custom similarity function sim),  then a word that match > 3 will not be the solution otherwise the match with the chosen word it self would be > 3. Same with words that match < 3. \\n```\\nclass Solution(object):\\n\\t#counts the similiarity between two words.\\n    def sim(self, word1, word2):\\n        count = 0\\n        for i in range(6):\\n            if word1[i] == word2[i]:\\n                count += 1\\n        return count\\n    \\n    def findSecretWord(self, words, master):\\n        count = 0\\n        words = list(set(words)) # remove duplicate words\\n        \\n        while words:\\n            rw = random.choice(words) # contributes to the 69%\\n            t = master.guess(rw)\\n            if t == 6:\\n                return\\n            nw = []\\n\\n            for i in range(len(words)):\\n                if self.sim(rw, words[i]) == t:\\n                    nw.append(words[i])\\n            words = nw\\n\\t\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1923293,
                "title": "python-easy-to-understand-commented-solution",
                "content": "class Solution(object):\\n    \\n    def findSecretWord(self, wordlist, master):\\n        \"\"\"\\n        :type wordlist: List[Str]\\n        :type master: Master\\n        :rtype: None\\n        \"\"\"\\n        ### function returns number of matched characters.\\n        def match(word1, word2):\\n            out=0\\n            for char1, char2 in zip(word1, word2):\\n                if char1==char2:\\n                    out+=1\\n            return out\\n        \\n        ###mem is a dict of dict. the first key is number of matched found between two words. second key is word1 and the value stored is a list of word2. \\n        ### mem[2][\"abcdef\"] is a set of words which have a 2 match with \"abcdef\"\\n        mem= {\\n            0:defaultdict(set),\\n            1:defaultdict(set),\\n            2:defaultdict(set),\\n            3:defaultdict(set),\\n            4:defaultdict(set),\\n            5:defaultdict(set),\\n             }\\n        ###populating the dict going trough all the pairs\\n        for i, word1 in enumerate(wordlist):\\n            for j, word2 in enumerate(wordlist):\\n                if word1==word2:\\n                    continue\\n                matches=match(word1, word2)\\n                mem[matches][word1].add(word2)\\n                mem[matches][word2].add(word1)\\n                \\n        ###pop element for wordlist and successively shrink wordlist based on master match.\\n        wordlist=set(wordlist)\\n        while wordlist:\\n            word = wordlist.pop()\\n            match_char=master.guess(word)\\n            if match_char==6:\\n                return \\n            possible_set=mem[match_char][word]\\n            wordlist=(possible_set.intersection(wordlist))\\n        return",
                "solutionTags": [],
                "code": "class Solution(object):\\n    \\n    def findSecretWord(self, wordlist, master):\\n        \"\"\"\\n        :type wordlist: List[Str]\\n        :type master: Master\\n        :rtype: None\\n        \"\"\"\\n        ### function returns number of matched characters.\\n        def match(word1, word2):\\n            out=0\\n            for char1, char2 in zip(word1, word2):\\n                if char1==char2:\\n                    out+=1\\n            return out\\n        \\n        ###mem is a dict of dict. the first key is number of matched found between two words. second key is word1 and the value stored is a list of word2. \\n        ### mem[2][\"abcdef\"] is a set of words which have a 2 match with \"abcdef\"\\n        mem= {\\n            0:defaultdict(set),\\n            1:defaultdict(set),\\n            2:defaultdict(set),\\n            3:defaultdict(set),\\n            4:defaultdict(set),\\n            5:defaultdict(set),\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1464428,
                "title": "guess-the-word-c-solution-with-comments-o-n-interactive-problem",
                "content": "## C++ Code \\uD83D\\uDCBB\\n\\n\\n```cpp\\nclass Solution {\\n    // function to Compare the Words, and\\n\\t// maintain the counter of occurance of matches\\n  private:\\n    int checkString(string & word1, string & word2) {\\n      int counter = 0;\\n\\n      for (int i = 0; i < 6; i++) {\\n        if (word1[i] == word2[i]) {\\n          counter++;\\n        }\\n      }\\n      return counter;\\n    }\\n\\n  public:\\n    void findSecretWord(vector < string > & wordlist, Master & master) {\\n      for (int i = 0; i < 10; i++) {\\n        string & guessWord = wordlist[rand() % wordlist.size()];\\n        int guessMatch = master.guess(guessWord);\\n        vector <string> newList;\\n\\n          // Iterate though the list and call our checkString() function \\n\\t\\t  // for word and the Guessed word\\n          \\n        for (string & word: wordlist) {\\n          if (guessMatch == checkString(word, guessWord)) {\\n            newList.push_back(word);\\n          }\\n        }\\n        wordlist = newList;\\n      }\\n\\n    }\\n\\n};\\n```\\n\\n\\n## Analysis \\uD83D\\uDCCA\\n\\n* **Time Complexity**: `O(n)`\\n\\n* **Space Complexity**: `O(n)`\\n\\n\\n## Report \\uD83D\\uDCC9\\n\\nBeats **100%** of the Submissions in ***Time***\\nBeats **73%** of the Submissions in ***Memory***\\n\\n![image](https://assets.leetcode.com/users/images/f58f5618-7eaa-4d9a-937a-803dbd29653f_1631687391.339991.png)\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\n    // function to Compare the Words, and\\n\\t// maintain the counter of occurance of matches\\n  private:\\n    int checkString(string & word1, string & word2) {\\n      int counter = 0;\\n\\n      for (int i = 0; i < 6; i++) {\\n        if (word1[i] == word2[i]) {\\n          counter++;\\n        }\\n      }\\n      return counter;\\n    }\\n\\n  public:\\n    void findSecretWord(vector < string > & wordlist, Master & master) {\\n      for (int i = 0; i < 10; i++) {\\n        string & guessWord = wordlist[rand() % wordlist.size()];\\n        int guessMatch = master.guess(guessWord);\\n        vector <string> newList;\\n\\n          // Iterate though the list and call our checkString() function \\n\\t\\t  // for word and the Guessed word\\n          \\n        for (string & word: wordlist) {\\n          if (guessMatch == checkString(word, guessWord)) {\\n            newList.push_back(word);\\n          }\\n        }\\n        wordlist = newList;\\n      }\\n\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376520,
                "title": "c-0ms-easy-solution",
                "content": "If length of wordlist is smaller than 10, then smply guess all the word in wordlist.\\nIf length of wordlist is bigger than 10, then..\\n\\nFirst we random choose a word in wordlist, and guess it with master.\\nHere we might have 3 cases\\n1. None of the char is matched to secret.\\n2. Jackpot! All chars are matched\\n3. Only some chars are matched.\\n\\nFor the case 1, which might be the most helpful one.\\nSince we knew this word has zero match with secret word.\\nWe loop through the original wordlist, and if there are words with any char match with this zero matched word. Then it must not the answer.\\nSo we only keep words which also have zero match with this zero matched word.\\n\\nFor the cast 3, we knew that this word has some match with the secret word.\\nLet\\'s say this word has PositiveNum match with secret word.\\nSince we already know it has \"PositiveNum\" match with secret word, so there must be PostivieNum of its chars is right.\\nSo we only keep words with differences with this word less than/equal to 6-PositiveNum.\\n\\nWell,  to be honest, this solution can\\'t cover all the cases. For example, the secret word is \"abcdef\"\\n(Although I don\\'t think 10 guesses is possibly enough for all the cases)\\nAnd if the wordlist is [abcdef, bbcdef, cbcdef, dbcdef, ebcdef, fbcdef, gbcdef, hbcdef........zbcdef]\\nThen this solution only have 10/26 = 38% chance to guess the secret word.\\n```\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        if(wordlist.size()<=10){\\n            for(auto &str : wordlist){\\n                master.guess(str);\\n            }\\n        }else{\\n            for(int i=0; i<10; ++i){\\n                int n = wordlist.size();\\n                int randNum = rand() % n;\\n                string guessString = wordlist[randNum];\\n                int positiveNum = master.guess(guessString); \\n                \\n                if(positiveNum == 6){ break; }\\n                else if(positiveNum == 0){ allNegClean(guessString, wordlist); }\\n                else{ positiveClean(guessString, wordlist, positiveNum); }\\n            }\\n        }\\n    }\\n    \\nprivate:\\n    void allNegClean(string &word, vector<string>& wordlist){\\n        vector<string> newList;\\n        for(int i=0; i<wordlist.size(); ++i){\\n            int j=0;\\n            for(; j<6; ++j){\\n                if(wordlist[i][j] == word[j]){ break; }\\n            }\\n            if(j==6){ newList.push_back(wordlist[i]); }\\n        }\\n        wordlist = newList;\\n    }\\n    \\n    void positiveClean(string &word, vector<string>& wordlist, int positiveNum){\\n        vector<string> newList;\\n        for(int i=0; i<wordlist.size(); ++i){\\n            int diff = 0;\\n            for(int j=0; j<6; ++j){\\n                if(wordlist[i][j] != word[j]){ diff++; }\\n            }\\n            if(diff<= 6-positiveNum && wordlist[i] != word){ newList.push_back(wordlist[i]); }\\n        }\\n        wordlist = newList;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        if(wordlist.size()<=10){\\n            for(auto &str : wordlist){\\n                master.guess(str);\\n            }\\n        }else{\\n            for(int i=0; i<10; ++i){\\n                int n = wordlist.size();\\n                int randNum = rand() % n;\\n                string guessString = wordlist[randNum];\\n                int positiveNum = master.guess(guessString); \\n                \\n                if(positiveNum == 6){ break; }\\n                else if(positiveNum == 0){ allNegClean(guessString, wordlist); }\\n                else{ positiveClean(guessString, wordlist, positiveNum); }\\n            }\\n        }\\n    }\\n    \\nprivate:\\n    void allNegClean(string &word, vector<string>& wordlist){\\n        vector<string> newList;\\n        for(int i=0; i<wordlist.size(); ++i){\\n            int j=0;\\n            for(; j<6; ++j){\\n                if(wordlist[i][j] == word[j]){ break; }\\n            }\\n            if(j==6){ newList.push_back(wordlist[i]); }\\n        }\\n        wordlist = newList;\\n    }\\n    \\n    void positiveClean(string &word, vector<string>& wordlist, int positiveNum){\\n        vector<string> newList;\\n        for(int i=0; i<wordlist.size(); ++i){\\n            int diff = 0;\\n            for(int j=0; j<6; ++j){\\n                if(wordlist[i][j] != word[j]){ diff++; }\\n            }\\n            if(diff<= 6-positiveNum && wordlist[i] != word){ newList.push_back(wordlist[i]); }\\n        }\\n        wordlist = newList;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233745,
                "title": "simple-python-solution-w-explanation",
                "content": "We can summarize the optimal process as so:\\n\\nWe know if we guess a word from the word list, one of three things will occur:\\n\\t1. score = 6 -> We found the secret and can stop :)\\n\\t2. score = 0 -> We can remove any words with overlapping chars. Since they share common chars, and we know all of the chars in the current word are wrong, then no words with any overlap will be the secret.\\n\\t3. score = 1,2,3,4,5 = k -> We know that k chars are correct in our current word. Thus, if another word does not share exactly k overlapping characters with our word, it also is not the secret and we can remove it.\\n\\nThis process is *almost* sufficient. The problem here is with the above approach alone, we can\\'t guarantee we remove \"bad\" words at a fast enough rate to guarantee we can get the correct secret within the first 10 guesses.\\n\\nWhy is that the case? Consider that some words might not overlap with any other words at all.\\n\\nHere is an example test case:\\n\\n```\\n\"hahaha\"\\n[\"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\", \"hahaha\"]\\n10\\n```\\n\\nHere we see that none of the words overlap with each other, and so our best bet would be to try all of them. But *wait*! The key to interviews is to **understand the problem**.\\n\\n\"**For each test case**, you have exactly 10 guesses to guess the word. At the end of any number of calls, if you have made 10 or fewer calls to Master.guess and at least one of these guesses was secret, then you pass the test case.\"\\n\\nSo while we could probably guarantee some approach to say 26 attempts (someone correct me if my math is wrong), for this problem, we just need to optimize it to get to 10 or less **for the given test cases**.\\n\\nThus, the missing piece we can infer from above is that we minimize our problem space more quickly when we test words that overlap with others. The reason being, if the overlap between two words is non-zero (and assuming the words are distinct it is also not 6), then the more overlaps the more chances we get to cut out words that don\\'t fit our invariant.\\n\\nMy Python code is below. If anyone has suggestions, feel free to comment. In no way do I believe my code is perfect, but maybe it could help someone see the problem from this perspective.\\n\\n\\n```\\nclass Solution(object):\\n    def findSecretWord(self, wordlist, master):\\n        wordsLeft = set(wordlist)\\n        def overlap(wordA, wordB):\\n            return sum([1 if wordA[i]==wordB[i] else 0 for i in range(6)])\\n        \\n        def mostOverlap():\\n            seen = {}\\n            for word in wordsLeft:\\n                for index, char in enumerate(word):\\n                    try:\\n                        seen[char][index] += 1\\n                    except KeyError:\\n                        seen[char] = [0]*6\\n                        seen[char][index] += 1\\n            bestWord, maxOverlap = \"\", -1\\n            for word in wordsLeft:\\n                score = sum([seen[char][index] for index, char in enumerate(word)])\\n                if score > maxOverlap:\\n                    maxOverlap = score\\n                    bestWord = word\\n            return bestWord\\n        \\n        for i in range(10):\\n            if len(wordsLeft) == 0: return\\n            word = mostOverlap()\\n            wordsLeft.remove(word)\\n            matches = master.guess(word)\\n            if matches == 6: break\\n            for wordB in wordsLeft.copy():\\n                overlaps = overlap(word, wordB)\\n                if matches == 0 and overlaps != 0:\\n                    wordsLeft.remove(wordB)\\n                if matches != 0 and overlaps != matches:\\n                    wordsLeft.remove(wordB)  \\n        return                       \\n```\\n\\nThank you for reading and good luck on your interviews!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"hahaha\"\\n[\"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\", \"hahaha\"]\\n10\\n```\n```\\nclass Solution(object):\\n    def findSecretWord(self, wordlist, master):\\n        wordsLeft = set(wordlist)\\n        def overlap(wordA, wordB):\\n            return sum([1 if wordA[i]==wordB[i] else 0 for i in range(6)])\\n        \\n        def mostOverlap():\\n            seen = {}\\n            for word in wordsLeft:\\n                for index, char in enumerate(word):\\n                    try:\\n                        seen[char][index] += 1\\n                    except KeyError:\\n                        seen[char] = [0]*6\\n                        seen[char][index] += 1\\n            bestWord, maxOverlap = \"\", -1\\n            for word in wordsLeft:\\n                score = sum([seen[char][index] for index, char in enumerate(word)])\\n                if score > maxOverlap:\\n                    maxOverlap = score\\n                    bestWord = word\\n            return bestWord\\n        \\n        for i in range(10):\\n            if len(wordsLeft) == 0: return\\n            word = mostOverlap()\\n            wordsLeft.remove(word)\\n            matches = master.guess(word)\\n            if matches == 6: break\\n            for wordB in wordsLeft.copy():\\n                overlaps = overlap(word, wordB)\\n                if matches == 0 and overlaps != 0:\\n                    wordsLeft.remove(wordB)\\n                if matches != 0 and overlaps != matches:\\n                    wordsLeft.remove(wordB)  \\n        return                       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179249,
                "title": "c-solution-with-intuition-and-some-optimization",
                "content": "There are a very few observations\\n1. How do we select the word to be guessed from the list, Since the number of allowed queries are very less; `10` to be exact.\\n2. Once we pick any word, how do we discard the other words to reduce the query count?\\n___\\nLet\\'s see how to tackle second point.\\nAssume that we picked a random word from the list and passed it to the `Master` utility class, and got some result `X`. What does this mean?\\nOut of 6 characters, 2 of them are at the right place/position. But we dont know which two?\\nAbove information is very useful. \\n\\nwe compare each word with the word that we chose and check how many of them have exactly match count is `X`. And discard other words in the list.\\n____\\nNow for the first point, we use the character count in each position and in every word. Those positions having maximum matches of characters will be prioritized.\\nSo we calculate the score of each word using the freq. count in each position and then get the word with the maximum score. And that\\'s it.\\n___\\n\\n\\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {\\npublic:\\n    //This API returns list of strings\\n    //whose match count was exactly same as cnt\\n    vector<string> getList(int cnt, vector<string> words, string cur) {\\n        vector<string> res;\\n        res.clear();\\n        for (string w: words) {\\n            int match = 0;\\n            for (int i = 0; i < 6; ++i) {\\n                if(w[i] == cur[i]) ++match;\\n            }\\n            if(cnt == match) res.push_back(w);\\n        }\\n        return res;\\n    }\\n    \\n    //This API returns the candidate word to be selected.\\n    string getContenderWord(vector<string> word) {\\n        int n = word.size();\\n        int dp[6][26];\\n        memset(dp, 0, sizeof dp);\\n        for (int i = 0; i < n; ++i) {\\n            //count the frequency at each index\\n            for (int j = 0; j < 6; ++j) {\\n                ++dp[j][word[i][j] - \\'a\\'];\\n            }\\n        }\\n        string result = \"\";\\n        int best_score = 0;\\n        for (int i = 0; i < n; ++i) {\\n            int  cur_score = 0;\\n            for (int j = 0; j < 6; ++j) {\\n                cur_score += dp[j][word[i][j] - \\'a\\'];\\n            }\\n            if(cur_score > best_score) {\\n                best_score = cur_score;\\n                result = word[i];\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        int cnt = 0;\\n\\t\\t//need to query only 10 times, after that \\n\\t\\t//querying doesn\\'t make any sense\\n        while(cnt < 10) {\\n            string cur = getContenderWord(wordlist);\\n            int need = master.guess(cur);\\n            if(need == 6) return ;\\n            wordlist = getList(need, wordlist, cur);\\n            ++cnt;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {\\npublic:\\n    //This API returns list of strings\\n    //whose match count was exactly same as cnt\\n    vector<string> getList(int cnt, vector<string> words, string cur) {\\n        vector<string> res;\\n        res.clear();\\n        for (string w: words) {\\n            int match = 0;\\n            for (int i = 0; i < 6; ++i) {\\n                if(w[i] == cur[i]) ++match;\\n            }\\n            if(cnt == match) res.push_back(w);\\n        }\\n        return res;\\n    }\\n    \\n    //This API returns the candidate word to be selected.\\n    string getContenderWord(vector<string> word) {\\n        int n = word.size();\\n        int dp[6][26];\\n        memset(dp, 0, sizeof dp);\\n        for (int i = 0; i < n; ++i) {\\n            //count the frequency at each index\\n            for (int j = 0; j < 6; ++j) {\\n                ++dp[j][word[i][j] - \\'a\\'];\\n            }\\n        }\\n        string result = \"\";\\n        int best_score = 0;\\n        for (int i = 0; i < n; ++i) {\\n            int  cur_score = 0;\\n            for (int j = 0; j < 6; ++j) {\\n                cur_score += dp[j][word[i][j] - \\'a\\'];\\n            }\\n            if(cur_score > best_score) {\\n                best_score = cur_score;\\n                result = word[i];\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        int cnt = 0;\\n\\t\\t//need to query only 10 times, after that \\n\\t\\t//querying doesn\\'t make any sense\\n        while(cnt < 10) {\\n            string cur = getContenderWord(wordlist);\\n            int need = master.guess(cur);\\n            if(need == 6) return ;\\n            wordlist = getList(need, wordlist, cur);\\n            ++cnt;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970426,
                "title": "python3-simple-and-clear-explanation-unfinished-to-be-continue",
                "content": "Suppose we have 12 words in the wordlist. Naively, we can call Master.guess(word) for each word in the wordlist. Once the Master.guess(word) returns 6, we find the answer. In the worst case, we need to call Master.guess 12 times. Easy, I know how to iterate through a list and write an if condition, and return the word. \\n\\n```\\nsecret = \"aaaaaa\"\\nwordlist = [\"aabbbb\" ,\"aaabbb\", \"aaabcd\", \"cccccc\", \"dddddd\", \"accccc\", \"aaaaaa\", \"eeeeee\",\"affffff\", \"acccccc\", \"aabbcb\", \"aaaaaa\"]\\n```\\n        \\nHowever, there is a limit for the use of Master.guess(). You can only **call Master.guess() no more than ten times**, which makes this question a hard question.\\n\\n*  1. Call Master.guess(\"aabbbb\") for the first time,  return 2\\n        \\n ```\\n\"aabbbb\"   \\n\"aaabbb\"  \"aaabcd\"  \"cccccc\" \"dddddd\" \"accccc\" \"aaaaaa\"  \"eeeeee\"  \"affffff\" \"acccccc\"  \"aabbcb\"   \"aaaaaa\"\\n  5         3         0        0         1       2         0         1         1          5          2\\n  keep      keep      drop.    drop.     drop.   keep.     drop.     drop.     drop.      keep.      keep\\n         \\n We can filter the words which have matches with \"aabbbb\" less than 2.\\n         \\n filted_list = [\"aaabbb\", \"aaabcd\",\"aaaaaa\", \"aabbcb\", \"aaaaaa\"]\\n```\\n         \\n*  2 . Call Master.guess(\"aaabbb\") for the second time, return 3\\n```\\n\"aaabbb\"\\n\"aaabcd\"  \"aaaaaa\"  \"aabbcb\"  \"aaaaaa\"\\n 4.        3.        3.        3        \\n keep.     keep.     keep.     keep\\nWe can filter the words which have matches with \"aaabbb\" less than 3.\\nfilted_list = [ \"aaabcd\"  \"aaaaaa\"  \"aabbcb\"  \"aaaaaa\"]\\n```\\n          \\n* \\t 3. call Master.guess(\"aaabcd\") for the third time, return 3.\\n```\\n\"aaabcd\"\\n\"aaaaaa\"  \"aabbcb\"  \"aaaaaa\"\\n 3         4         3\\n keep.     keep.     keep\\nWe can filter the words which have matches with \"aaabcd\" less than 3.\\nfilted_list = [\"aaaaaa\",  \"aabbcb\", \"aaaaaa\"]\\n```\\n          \\n* 4. call Master.guess(\"aaaaaa\"), return 6.\\n\\n\\t  We find the secret by calling Master.guess() 4 times instead of 12 times. Mission accomplished!\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nsecret = \"aaaaaa\"\\nwordlist = [\"aabbbb\" ,\"aaabbb\", \"aaabcd\", \"cccccc\", \"dddddd\", \"accccc\", \"aaaaaa\", \"eeeeee\",\"affffff\", \"acccccc\", \"aabbcb\", \"aaaaaa\"]\\n```\n```\\n\"aabbbb\"   \\n\"aaabbb\"  \"aaabcd\"  \"cccccc\" \"dddddd\" \"accccc\" \"aaaaaa\"  \"eeeeee\"  \"affffff\" \"acccccc\"  \"aabbcb\"   \"aaaaaa\"\\n  5         3         0        0         1       2         0         1         1          5          2\\n  keep      keep      drop.    drop.     drop.   keep.     drop.     drop.     drop.      keep.      keep\\n         \\n We can filter the words which have matches with \"aabbbb\" less than 2.\\n         \\n filted_list = [\"aaabbb\", \"aaabcd\",\"aaaaaa\", \"aabbcb\", \"aaaaaa\"]\\n```\n```\\n\"aaabbb\"\\n\"aaabcd\"  \"aaaaaa\"  \"aabbcb\"  \"aaaaaa\"\\n 4.        3.        3.        3        \\n keep.     keep.     keep.     keep\\nWe can filter the words which have matches with \"aaabbb\" less than 3.\\nfilted_list = [ \"aaabcd\"  \"aaaaaa\"  \"aabbcb\"  \"aaaaaa\"]\\n```\n```\\n\"aaabcd\"\\n\"aaaaaa\"  \"aabbcb\"  \"aaaaaa\"\\n 3         4         3\\n keep.     keep.     keep\\nWe can filter the words which have matches with \"aaabcd\" less than 3.\\nfilted_list = [\"aaaaaa\",  \"aabbcb\", \"aaaaaa\"]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 730094,
                "title": "c-easy-to-understand-my-first-submission",
                "content": "* There are 100 words out of which 1 is secret\\n* All words are randomly built\\n* Guess calls can be done on any of those 100 words.\\n* Any different word not in the original list will give -1\\n* Naive solution is to run guess on all the words but that means we will violate the limit of 10 guesses that are allowed.\\n*  So We need to find a way to reduce the scope of probable words after every guess.\\n\\nThe list of words and the matches for each word against other would look like this\\n   1 2 3 4 5 6 . . 100\\nword1 = [6 4 0 0 0 1 2 ... ]\\n word2 = [4 6 0 0 0 0 3 ... ]\\n word3\\n word100 = [... 0 0 2 2 2 6]\\n\\nWe can just take a random word and run guess on it. For example if we picked word2   and guess for word2 gives 2 which is matching characters for our secret and word.\\nNow lets try to find which other words in wordlist gives the same value as 2 which the match against secret revealed.\\nIf matches for word2 against all the words in wordlist are [ 0 0 0 3 0 1 0 1 0 1 2 0 3 0 0 1 0 0 ...0]\\nNow we have to just consider the words that have given the matches as 2 from the above list.\\nLets remove the other words that dont give 2\\nWe now have got fewer words.\\nRepeat the above with fewer words until there is only one  word that gives match value of 6 and that is the answer.\\n\\t\\t \\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *     public int Guess(string word);\\n * }\\n */\\nclass Solution {\\n    public void FindSecretWord(string[] wordlist, Master master) {\\n\\t\\t\\n        \\n        var wordlist1 = new List<string>(wordlist);\\n        Random r = new Random();\\n        while(wordlist1.Count != 0) {\\n            // Step 1: select a random word to do the api call\\n            string guess = wordlist1[r.Next(wordlist1.Count)];\\n            \\n            // Step2: get the matches for the new word to do the api call\\n            int matches = master.Guess(guess);\\n            if (matches == 6) return;\\n            \\n            // Step3: elimiate all words don\\'t have the same # of matches\\n            var templist = new List<string>();\\n            foreach (var word in wordlist1) {\\n                if (matches == Match(word, guess)) {\\n                    templist.Add(word);\\n                }\\n            }\\n            wordlist1 = templist;\\n        }\\n\\n    }\\n    \\n    public int Match(string word1, string word2) {\\n        int result = 0;\\n        for (int i=0; i < 6; i++) {\\n            if (word1[i] == word2[i]){\\n                result++;   \\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *     public int Guess(string word);\\n * }\\n */\\nclass Solution {\\n    public void FindSecretWord(string[] wordlist, Master master) {\\n\\t\\t\\n        \\n        var wordlist1 = new List<string>(wordlist);\\n        Random r = new Random();\\n        while(wordlist1.Count != 0) {\\n            // Step 1: select a random word to do the api call\\n            string guess = wordlist1[r.Next(wordlist1.Count)];\\n            \\n            // Step2: get the matches for the new word to do the api call\\n            int matches = master.Guess(guess);\\n            if (matches == 6) return;\\n            \\n            // Step3: elimiate all words don\\'t have the same # of matches\\n            var templist = new List<string>();\\n            foreach (var word in wordlist1) {\\n                if (matches == Match(word, guess)) {\\n                    templist.Add(word);\\n                }\\n            }\\n            wordlist1 = templist;\\n        }\\n\\n    }\\n    \\n    public int Match(string word1, string word2) {\\n        int result = 0;\\n        for (int i=0; i < 6; i++) {\\n            if (word1[i] == word2[i]){\\n                result++;   \\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 678937,
                "title": "c-minimax-with-clear-comments",
                "content": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    vector<string> reducelist(vector<string> &wordlist, string guess, int d) {\\n        vector<string> reducedlist;\\n        for (auto &word: wordlist) {\\n            if (match(word, guess) == d) reducedlist.push_back(word); \\n        }\\n        return reducedlist;\\n    }\\n    \\n    int match(string from, string to) {\\n        int d = 0, n = from.length();\\n        for (int i = 0; i < n; i ++) {\\n            if (from[i] == to[i]) d ++;\\n        }\\n        return d;\\n    }\\n    \\n    int wordsRemoved(string guess, string secret, vector<string> &wordList) {\\n        int d = match(guess, secret);\\n        int remove = 0;\\n        for (auto &word: wordList) {\\n            auto d1 = match(guess, word);\\n            if (d != d1) remove ++; \\n        }\\n        return remove;\\n    }\\n    \\n    // Minimax.. get best word to guess\\n    string minimax(vector<string>& wordList) {\\n        int n = wordList.size();\\n        map<string, int> count;\\n        for (auto &word: wordList) count[word] = INT_MAX;\\n        for (auto &guess: wordList) {\\n            for (auto &secret: wordList) {\\n                count[guess] = min(count[guess], wordsRemoved(guess, secret, wordList));       \\n            }\\n        }\\n        int max = INT_MIN;\\n        string res;\\n        for (auto &word: wordList) {\\n            if (count[word] > max) {\\n                max = count[word];\\n                res = word;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    \\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n\\n        // we need to reduce the search space in some way. Otherwise we need to guess every word as a guess. \\n        // The only information we have after making a guess is the number of matches the word will has with the secret\\n        \\n        // i. Guess the word -> say the distance is x\\n        // ii. remove the words which are not at distance x from word in search space\\n\\n        // But... How do we know which word to choose? \\n        // We have to choose that word as our guess, which will maximize the (minimum number of words which can be removed if that word is chosen as the guess (for this we need to consider every other word as the secret word and see how many words are being removed))\\n\\n        auto reducedlist = wordlist;\\n        \\n        while (true) {\\n            auto guess = minimax(reducedlist);\\n            int d = master.guess(guess);\\n            // cout << guess << \" \" << d << endl;\\n            if (d == 6) break;\\n            reducedlist = reducelist(reducedlist, guess, d);\\n            // cout << reducedlist.size() << endl;\\n        }\\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<string> reducelist(vector<string> &wordlist, string guess, int d) {\\n        vector<string> reducedlist;\\n        for (auto &word: wordlist) {\\n            if (match(word, guess) == d) reducedlist.push_back(word); \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 577715,
                "title": "summary-of-top-votes-posts-minmax-mostoverlappedword-histogram",
                "content": "I\\'d like to write a summary of some most top voted posts to help myself understand the awesome solutions people came up for this problem. All credits go to all the original posts that I linked in each section.\\n\\n## --------------- PART 1: Skeleton of the algorithm ---------------\\n**First of all, it\\'s not hard to come up with a skeleton of the algorithm**\\n- step0: we have a bunch of candidates in collection: `c`\\n- step1: choose a word `x` from candidates: `c`\\n- step2: call `master.guess(x)`,  which returns match number `m`, we know `0 <= m <= 6`\\n- step3: we compare `x` with all remaining candidates in `c`, and find out a new batch of candidates `c\\'`for the next round, they should all have `m` matched chars with `x`. Now with `c\\'` as our new candidates pool, we loop back to step0, until we stop at `m == 6`\\n\\n##### python\\nNote, we will implement `choose_word` in the next section\\n```python\\nclass Solution(object):\\n    # count the number of matching characters\\n    def matchNum(self, a, b):\\n        return sum(c1 == c2 for c1, c2 in zip(a, b))\\n\\n    # heuristic to choose the next word\\n    def choose_candidate(self, candidates):\\n        # TODO, implemeht this heuristic of finding the next candidate for master.guess()\\n        \\n    def findSecretWord(self, wordlist, master):\\n        candidates = wordlist[:] # deep copy wordlist, so that we don\\'t change the original list content  \\n        while candidates:        # while candidates is not empty\\n            x = self.choose_candidate(candidates)     \\n            m = master.guess(x)\\n            if m == 6:\\n                return\\n            candidates = [w for w in candidates if self.matchNum(x, w) == m]\\n```\\n\\n\\n\\n##  --------------- PART 2: Heuristics of Finding the next chosen word  ---------------\\n**Next is where things start to get more interesting: what\\'s the best approach to choose word `x` from candidates in step1 in each iteration, so that we reduce the number of guesses? We need a heuristic function**\\n### Solution 1\\n`Random`: the problem mentions that all words candidates are generated randomly, so we just choose word at a random index as the lucky one.\\n\\n##### python\\n```\\n    # heuristic to choose the next word\\n    def choose_candidate(self, candidates):\\n        return random.choice(candidates)\\n```\\n\\n##### reference\\n - [solution 2 in lee215\\'s post](https://leetcode.com/problems/guess-the-word/discuss/133862)\\n \\n### Solution 2 \\nUse the word `x` that has the `minimum number of words that have 0 mathces to x`, see implementation in function `most_overlap_word()` in this [post](https://leetcode.com/problems/guess-the-word/discuss/160945)\\n1. we have a guess word `x` chosen, which has `m` overlap chars with the target\\n2. compare guess word `x`, and use number of mathes to bucket other candidates properly bucket range [0, 1, 2, 3, 4, 5, 6]\\n3. use probability knowledge, we could easily figure that bucket 0 should be bucket with most number of candidates: `propability = POWER((25/26), 6) = 80%`\\n4. we want to find a word that overlaps most with other words so that we could eliminate all words that might have 0 matches with the guess word, this would help us to eliminate bucket 0, which has highest chance of containing more words, and reach the secret asap.\\n\\n##### python\\n```\\n    # heuristic to choose the next word\\n    def choose_candidate(self, candidates):\\n\\t\\t# for each of 6 position, we compute the histogram of each character count\\n        counts = [collections.defaultdict(int) for _ in range(6)]\\n        for word in candidates:\\n            for index, character in enumerate(word):\\n                counts[index][character] += 1\\n\\t\\t# return the word that has most overlap with others\\n        return max(candidates, key = lambda word : sum(counts[i][c] for i, c in enumerate(word)))\\n```\\n\\nThe above solution uses `sum` as heuristic, we could also use `prod` as heristic (needs to import numpy)\\n```\\n        return max(candidates, key = lambda word : numpy.prod(counts[i][c] for i, c in enumerate(word)))\\n```\\n\\n##### reference\\n - [solution 4 in lee215\\'s post](https://leetcode.com/problems/guess-the-word/discuss/133862)\\n - [Python O(n) with maximum overlap heuristic](https://leetcode.com/problems/guess-the-word/discuss/160945)\\n\\n### Solution 3\\n`Histogram`: most overlapped candidate synthetic\\n1. for each of 6 position, we compute the histogram of each character count\\n2. the synthetic word is it the max(char) in each position\\n\\n##### python\\nNote: this solution would work if master.guess(syntheticWord) returns the number of matches instead of -1 in the testing system\\n```\\n    # heuristic to choose the next word\\n    def choose_candidate(self, candidates):\\n        counts = [collections.defaultdict(int) for _ in range(6)]\\n        for word in candidates:\\n            for index, character in enumerate(word):\\n                counts[index][character] += 1\\n        return \\'\\'.join([max(hist, key = hist.get) for hist in counts])\\n```\\n\\n##### reference\\n - [C++ elimination histogram, beats Minimax](https://leetcode.com/problems/guess-the-word/discuss/134087)\\n\\n### Solution 4\\n`Histogram`: most balanced candidate\\n1. for each word in candidates `c`, we compute histogram, and place all other words into 0-6 buckets, according to their distance\\n2. to choose the candidate with most `balanced` distribution of buckets, whoose the word with min(max(hist)) \\n\\n##### python\\n```\\n    # heuristic to choose the next word\\n    def choose_candidate(self, candidates):\\n        if len(candidates) is 1: # use special judgement here, otherwise \"ValueError: max() arg is an empty sequence in return statement in last line\"\\n            return candidates[0]\\n        wordHist = {word : collections.defaultdict(int) for word in candidates}\\n        for i in range(len(candidates)):\\n            for j in range(i + 1, len(candidates)):\\n                m = self.matchNum(candidates[i], candidates[j])\\n                wordHist[candidates[i]][m] += 1\\n                wordHist[candidates[j]][m] += 1\\n        return min(wordHist.keys(), key = lambda w : max(wordHist.get(w).values()))\\n```\\n\\n##### reference\\n - [Optimal MinMax Solution (+ extra challenging test cases)](https://leetcode.com/problems/guess-the-word/discuss/134251)\\n \\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    # count the number of matching characters\\n    def matchNum(self, a, b):\\n        return sum(c1 == c2 for c1, c2 in zip(a, b))\\n\\n    # heuristic to choose the next word\\n    def choose_candidate(self, candidates):\\n        # TODO, implemeht this heuristic of finding the next candidate for master.guess()\\n        \\n    def findSecretWord(self, wordlist, master):\\n        candidates = wordlist[:] # deep copy wordlist, so that we don\\'t change the original list content  \\n        while candidates:        # while candidates is not empty\\n            x = self.choose_candidate(candidates)     \\n            m = master.guess(x)\\n            if m == 6:\\n                return\\n            candidates = [w for w in candidates if self.matchNum(x, w) == m]\\n```\n```\\n    # heuristic to choose the next word\\n    def choose_candidate(self, candidates):\\n        return random.choice(candidates)\\n```\n```\\n    # heuristic to choose the next word\\n    def choose_candidate(self, candidates):\\n\\t\\t# for each of 6 position, we compute the histogram of each character count\\n        counts = [collections.defaultdict(int) for _ in range(6)]\\n        for word in candidates:\\n            for index, character in enumerate(word):\\n                counts[index][character] += 1\\n\\t\\t# return the word that has most overlap with others\\n        return max(candidates, key = lambda word : sum(counts[i][c] for i, c in enumerate(word)))\\n```\n```\\n        return max(candidates, key = lambda word : numpy.prod(counts[i][c] for i, c in enumerate(word)))\\n```\n```\\n    # heuristic to choose the next word\\n    def choose_candidate(self, candidates):\\n        counts = [collections.defaultdict(int) for _ in range(6)]\\n        for word in candidates:\\n            for index, character in enumerate(word):\\n                counts[index][character] += 1\\n        return \\'\\'.join([max(hist, key = hist.get) for hist in counts])\\n```\n```\\n    # heuristic to choose the next word\\n    def choose_candidate(self, candidates):\\n        if len(candidates) is 1: # use special judgement here, otherwise \"ValueError: max() arg is an empty sequence in return statement in last line\"\\n            return candidates[0]\\n        wordHist = {word : collections.defaultdict(int) for word in candidates}\\n        for i in range(len(candidates)):\\n            for j in range(i + 1, len(candidates)):\\n                m = self.matchNum(candidates[i], candidates[j])\\n                wordHist[candidates[i]][m] += 1\\n                wordHist[candidates[j]][m] += 1\\n        return min(wordHist.keys(), key = lambda w : max(wordHist.get(w).values()))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531255,
                "title": "graphic-explanation-of-minimax-type-approaches",
                "content": "The explaination given in Solution is too terse to understand and it took me a while to figure what it\\'s doing. Now that I have figured it (I think) I\\'d like to share my understanding.\\n\\nThere are 2 parts to this problem. Understanding 1st part is straight forward and I won\\'t spend a lot of time on it. 2nd part is where the magic is.\\n\\nTo begin with, forget Minimax, let\\'s start from scratch.\\n\\n#### deifnitions\\nI am going to use the word similarity a lot and here is how I define it (this shouldn\\'t come as surprise):\\n```\\nint similarity(String s1, String s2) {\\n\\tint res = 0;\\n\\tfor(int k=0; k<words[i].length(); ++k) if(s1.charAt(k) == s2.charAt(k)) ++res;\\n\\treturn res;\\n}\\n```\\n\\nLet S be the set of words given to us.\\nLet T be the target word.\\n\\n#### Part 1\\n\\nLet\\'s say you guessed word G. Let x = similarity(G, T).\\nObvious way to know what next word to choose is to is to find all words in S which have similarity of x with respect to word G.\\nKeep iterating and you\\'ll find the right word.\\n\\nSide note, clear way to make this take less number to attempts is to keep track of all the guesses you did with their similarity with T. So now you have a map/dict which looks like:\\n```\\n{\\n\\tG1 -> x1,\\n\\tG2 -> x2\\n\\t...\\n}\\n```\\nNow your next guess should be at exact those similarities from previous guess. So if your next guess was Gn then:\\nx1 = similarity(G1, Gn)\\nx2 = similarity(G2, Gn)\\netc.\\nBut this is not good enough.\\n\\n#### Part 2\\nThis is the most intersting part of problem. \\n\\nLet G0 be the 1st guess you made and let x = similarity(G0, T).\\nAll words which are at x similarity from T will lie on a circle at distance x from T.\\nLet all such words be {G0, G1, G2 and G3}, lets calll this set P1 and the visualisation will look as follows:\\n\\n![image](https://assets.leetcode.com/users/user4453/image_1583552193.png)\\n\\nKey observation here is T is equi-distant (or equi-similarty) from all words in P1.\\n\\nFor every guess you make you want to come closer to T. So if you find every word in S which are as equi-distant (or equi-similarty) from P1 you\\'ll keep getting closer to T.\\n\\nTo visualise, let\\'s say you found that a word G4 in S is exactly equi-similarty from all words in P1, then G4 will be T. This is the curx of it all. As in code below, we are minimising the max-similarty of next candidate in lines:\\n```\\nint thisMaxVotes = votes[0];\\nfor (int j = 0; j < 7; ++j) thisMaxVotes = Math.max(thisMaxVotes, votes[j]);\\n\\nif(minVotes > thisMaxVotes) {\\n\\tminVotes = thisMaxVotes;\\n\\tres = i;\\n}\\n```\\n\\nNow let\\'s say the next best word G4 which was as equi-similarty from all words in P1 as possible but was not exactly at same similarty. It\\'d appear like so:\\n![image](https://assets.leetcode.com/users/user4453/image_1583553099.png)\\n\\nAs an excercise, argue what\\'d happen if G4 lies outside the circle.\\n\\nHere is the java code\\n```\\n\\n\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    private int[][] simi;\\n    private int N;\\n    private String[] words;\\n    private HashSet<Integer> used;\\n    private List<Integer> candi;\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        N = wordlist.length;\\n        words = wordlist;\\n        simi = new int[N][N];\\n        for(int i=0; i<N; ++i) {\\n            for(int j=i+1; j<N; ++j) {\\n                simi[i][j] = simi[j][i] = compare(i, j);\\n            }\\n        }\\n        used = new HashSet<>();\\n        candi = new ArrayList<>();\\n        for(int i=0; i<N; ++i) candi.add(i);\\n            \\n        int counter = 0;\\n\\n        while(true) {\\n            int guess = next();\\n            int thisSim = master.guess(words[guess]);\\n            \\n            ++counter;\\n            // System.out.println(counter + \" \" + guess);\\n            \\n            if(thisSim == 6) return;\\n            \\n            used.add(guess);\\n            List<Integer> candi2 = new ArrayList<>();\\n            for(int i:candi) if(simi[guess][i] == thisSim) candi2.add(i);\\n            candi=candi2;\\n        }\\n    }\\n    \\n    \\n    private int next() {\\n        int res = -1;\\n        int minVotes = candi.size();\\n        \\n        for(int i=0; i<N; ++i) {\\n            if(used.contains(i)) continue;\\n            \\n            int[] votes = new int[7];\\n            \\n            for(int j:candi) {\\n                if(j==i) continue;\\n                ++votes[simi[j][i]];\\n            }\\n            \\n            int thisMaxVotes = votes[0];\\n            for (int j = 0; j < 7; ++j) thisMaxVotes = Math.max(thisMaxVotes, votes[j]);\\n            \\n            if(minVotes > thisMaxVotes) {\\n                minVotes = thisMaxVotes;\\n                res = i;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int compare(int i, int j) {\\n        int res = 0;\\n        for(int k=0; k<words[i].length(); ++k) if(words[i].charAt(k) == words[j].charAt(k)) ++res;\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint similarity(String s1, String s2) {\\n\\tint res = 0;\\n\\tfor(int k=0; k<words[i].length(); ++k) if(s1.charAt(k) == s2.charAt(k)) ++res;\\n\\treturn res;\\n}\\n```\n```\\n{\\n\\tG1 -> x1,\\n\\tG2 -> x2\\n\\t...\\n}\\n```\n```\\nint thisMaxVotes = votes[0];\\nfor (int j = 0; j < 7; ++j) thisMaxVotes = Math.max(thisMaxVotes, votes[j]);\\n\\nif(minVotes > thisMaxVotes) {\\n\\tminVotes = thisMaxVotes;\\n\\tres = i;\\n}\\n```\n```\\n\\n\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    private int[][] simi;\\n    private int N;\\n    private String[] words;\\n    private HashSet<Integer> used;\\n    private List<Integer> candi;\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        N = wordlist.length;\\n        words = wordlist;\\n        simi = new int[N][N];\\n        for(int i=0; i<N; ++i) {\\n            for(int j=i+1; j<N; ++j) {\\n                simi[i][j] = simi[j][i] = compare(i, j);\\n            }\\n        }\\n        used = new HashSet<>();\\n        candi = new ArrayList<>();\\n        for(int i=0; i<N; ++i) candi.add(i);\\n            \\n        int counter = 0;\\n\\n        while(true) {\\n            int guess = next();\\n            int thisSim = master.guess(words[guess]);\\n            \\n            ++counter;\\n            // System.out.println(counter + \" \" + guess);\\n            \\n            if(thisSim == 6) return;\\n            \\n            used.add(guess);\\n            List<Integer> candi2 = new ArrayList<>();\\n            for(int i:candi) if(simi[guess][i] == thisSim) candi2.add(i);\\n            candi=candi2;\\n        }\\n    }\\n    \\n    \\n    private int next() {\\n        int res = -1;\\n        int minVotes = candi.size();\\n        \\n        for(int i=0; i<N; ++i) {\\n            if(used.contains(i)) continue;\\n            \\n            int[] votes = new int[7];\\n            \\n            for(int j:candi) {\\n                if(j==i) continue;\\n                ++votes[simi[j][i]];\\n            }\\n            \\n            int thisMaxVotes = votes[0];\\n            for (int j = 0; j < 7; ++j) thisMaxVotes = Math.max(thisMaxVotes, votes[j]);\\n            \\n            if(minVotes > thisMaxVotes) {\\n                minVotes = thisMaxVotes;\\n                res = i;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int compare(int i, int j) {\\n        int res = 0;\\n        for(int k=0; k<words[i].length(); ++k) if(words[i].charAt(k) == words[j].charAt(k)) ++res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484030,
                "title": "c-clean-with-comments-for-clarity",
                "content": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *     public int Guess(string word);\\n * }\\n */\\nclass Solution\\n{\\n    public void FindSecretWord(string[] wordlist, Master master)\\n    {\\n        // Sort the input word list\\n        Array.Sort(wordlist);\\n        \\n        // Create a mapping between words that failed the test and their score\\n        Dictionary<string, int> badWords = new Dictionary<string, int>();\\n        foreach(string word in wordlist) \\n        {  \\n            if (ValidateWord(word, badWords))\\n            {\\n                int score = master.guess(word);\\n                \\n                if (score==6) \\n                    return;\\n                \\n                badWords.Add(word, score);\\n            }\\n        }  \\n    }\\n    \\n    private bool ValidateWord(string candidate, Dictionary<string, int> badWords) \\n    {\\n        int similarity = 0;\\n        int score = 0;\\n        \\n        // Take the current word and compare it to each of the previously explored bad words\\n        foreach(string w in badWords.Keys)\\n        {\\n            // check the similarity of the current word and current bad word - this is the number of common letters\\n            similarity = Similarity(w, candidate);\\n            \\n            // recall the score of the currently explored bad word\\n            score = badWords[w];\\n            \\n            // If candidate has letters in common with a word that received \\n            // a score of 0, that means we can be certain that the candidate word \\n            // contains letters that are not in the target. For this reason,\\n            // we know for certain candidate is not the target word. \\n            bool overlapWithBadWord = (score == 0 && similarity > 0);\\n            \\n            \\n            if (overlapWithBadWord || similarity < score )\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    public int Similarity(string s1, string s2) \\n    {\\n        // Get the number of letters that overlap between two words\\n        \\n        int count = 0;\\n      \\n        for(int i = 0; i < s1.Length; i++) \\n          if (s1[i] == s2[i]) \\n              count++;\\n          \\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution\\n{\\n    public void FindSecretWord(string[] wordlist, Master master)\\n    {\\n        // Sort the input word list\\n        Array.Sort(wordlist);\\n        \\n        // Create a mapping between words that failed the test and their score\\n        Dictionary<string, int> badWords = new Dictionary<string, int>();\\n        foreach(string word in wordlist) \\n        {  \\n            if (ValidateWord(word, badWords))\\n            {\\n                int score = master.guess(word);\\n                \\n                if (score==6) \\n                    return;\\n                \\n                badWords.Add(word, score);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 189219,
                "title": "intuitive-python-solution-hashing-recursive",
                "content": "This solution is pretty intuitive:\\n\\n1. When given a wordlist, we first preprocess and put every word into 6 different buckets with a hash like `a*****`  ( See the comment in Preprocessing)\\n2. Then we randomly guess a word that we haven\\'t guess\\n3. If there are more than 1 charactors right, we shrink the possible wordlist to the union of the 6 buckets.\\n3. If no charactors right, we shrink the possible wordlist by eliminating words from that 6 buckets. \\n4. Recursive!\\n```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    guessed = set()\\n    def findSecretWord(self, wordlist, master):\\n        \"\"\"\\n        :type wordlist: List[Str]\\n        :type master: Master\\n        :rtype: None\\n        \"\"\"\\n        \\n        # Preprocess wordlist\\n        # For every word like \"abcdef\",\\n        # put it into hashes with key \"a*****\",\"*b****\",\"**c***\",\"***d**\",..\\n        h = defaultdict(lambda:[],{})\\n        for w in wordlist:\\n            for i,c in enumerate(w):\\n                key = \"*\"*i + c + \"*\"*(6-i-1)\\n                h[key].append(w)\\n                \\n        # Randomly find a word that hasn\\'t guessed and guess it\\n        for word in wordlist:\\n            if word not in self.guessed:\\n                break\\n        g = master.guess(word)\\n        self.guessed.add(word)\\n        \\n        if g==6:\\n            return\\n        \\n        # if there\\'s match, the possible wordlist shrinks.\\n        # E.g. if we guess \"abcdef\"\\n        # The possible wordlist becomes the union of all the words in \\n        # h[\"a*****\"], h[\"*b****\"], ....\\n        if g>=1:\\n            keys = [ \"*\"*i+c+\"*\"*(5-i) for i,c in enumerate(word) ]\\n            new_words = set()\\n            for k in keys:\\n                new_words |= set(h[k])\\n            self.findSecretWord(list(new_words),master)\\n        \\n        # Similarly,\\n        # if there\\'s no match, remove all the possibility from the wordlist\\n        else:\\n            keys = [ \"*\"*i+c+\"*\"*(5-i) for i,c in enumerate(word) ]\\n            new_words = set(wordlist)\\n            for k in keys:\\n                new_words -= set(h[k])\\n            self.findSecretWord(list(new_words),master)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    guessed = set()\\n    def findSecretWord(self, wordlist, master):\\n        \"\"\"\\n        :type wordlist: List[Str]\\n        :type master: Master\\n        :rtype: None\\n        \"\"\"\\n        \\n        # Preprocess wordlist\\n        # For every word like \"abcdef\",\\n        # put it into hashes with key \"a*****\",\"*b****\",\"**c***\",\"***d**\",..\\n        h = defaultdict(lambda:[],{})\\n        for w in wordlist:\\n            for i,c in enumerate(w):\\n                key = \"*\"*i + c + \"*\"*(6-i-1)\\n                h[key].append(w)\\n                \\n        # Randomly find a word that hasn\\'t guessed and guess it\\n        for word in wordlist:\\n            if word not in self.guessed:\\n                break\\n        g = master.guess(word)\\n        self.guessed.add(word)\\n        \\n        if g==6:\\n            return\\n        \\n        # if there\\'s match, the possible wordlist shrinks.\\n        # E.g. if we guess \"abcdef\"\\n        # The possible wordlist becomes the union of all the words in \\n        # h[\"a*****\"], h[\"*b****\"], ....\\n        if g>=1:\\n            keys = [ \"*\"*i+c+\"*\"*(5-i) for i,c in enumerate(word) ]\\n            new_words = set()\\n            for k in keys:\\n                new_words |= set(h[k])\\n            self.findSecretWord(list(new_words),master)\\n        \\n        # Similarly,\\n        # if there\\'s no match, remove all the possibility from the wordlist\\n        else:\\n            keys = [ \"*\"*i+c+\"*\"*(5-i) for i,c in enumerate(word) ]\\n            new_words = set(wordlist)\\n            for k in keys:\\n                new_words -= set(h[k])\\n            self.findSecretWord(list(new_words),master)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 144542,
                "title": "javascript-solution-64ms-find-a-typical-word-in-the-wordlist-and-guess-it",
                "content": "#### **The solution should not rely on luck**\\nI think luck is the last thing a coder can rely on. Instead of wishing to be lucky (use random guesses), I think we should find a way to guarantee that we definitely pass the tests within 10 guesses. And my way is to find a `typical word` in a wordlist, and use it to get a guess result, and then `minimize the wordlist` with the guess result, and then continue to find a typical word in the minimized wordlist, and so on...\\n#### **What is a typical word in a wordlist?**\\nA `typical word` is a word that `have the most common with other words` in the wordlist. Here I use a simple version of typical word. Instead of comparing the whole word, I compared letters in the same position to find the letters that occured the most times, and then get a typical word. (If the guess times are even more limited, I think we should find a typical word by comparing the whole word)\\n#### **Why typical word?**\\nBy guessing with a typical word, we get to know how the most words in the wordlist match the secret key. (Because in some test cases there are many words that have no common with the secret key or most of the words in the wordlist, we should try to avoid guessing with those words.)\\n\\n```\\nvar findSecretWord = function(wordlist, master) {\\n    let group = wordlist;\\n    for(let i=0; i<10; i++){\\n    \\tlet currentGuess = findTheTypical(group);\\n    \\tlet res = master.guess(currentGuess);\\n    \\tif(res===6) return;\\n    \\tlet tmp = [];\\n    \\tfor(let j=0; j<group.length; j++){\\n    \\t\\tif(diff(group[j], currentGuess)===6-res) tmp.push(group[j]);\\n    \\t}\\n    \\tgroup=tmp;\\n    }\\n};\\nfunction findTheTypical(wordlist){\\n\\tlet count = Array.from({length:6}, x=>new Object());\\n\\tfor(let i=0; i<wordlist.length; i++){\\n\\t\\tfor(let j=0; j<6; j++){\\n\\t\\t\\tlet cur = wordlist[i][j];\\n\\t\\t\\tif(count[j][cur]===undefined) count[j][cur]=1;\\n\\t\\t\\telse count[j][cur]++;\\n\\t\\t}\\n\\t}\\n\\tlet maxPos=0, maxCount=0, maxAlp =\\'\\';\\n\\tfor(let i=0; i<6; i++){\\n\\t\\tfor(let k of Object.keys(count[i])){\\n\\t\\t\\tif(count[i][k]>maxCount){\\n\\t\\t\\t\\tmaxCount = count[i][k];\\n\\t\\t\\t\\tmaxPos = i;\\n\\t\\t\\t\\tmaxAlp = k;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(let i=0; i<wordlist.length; i++){\\n\\t\\tif(wordlist[i][maxPos]===maxAlp) return wordlist[i];\\n\\t}\\n}\\nfunction diff(a,b){\\n\\tlet count = 0;\\n\\tfor(let i=0; i<a.length; i++){\\n\\t\\tif(a[i]!==b[i]) count++;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar findSecretWord = function(wordlist, master) {\\n    let group = wordlist;\\n    for(let i=0; i<10; i++){\\n    \\tlet currentGuess = findTheTypical(group);\\n    \\tlet res = master.guess(currentGuess);\\n    \\tif(res===6) return;\\n    \\tlet tmp = [];\\n    \\tfor(let j=0; j<group.length; j++){\\n    \\t\\tif(diff(group[j], currentGuess)===6-res) tmp.push(group[j]);\\n    \\t}\\n    \\tgroup=tmp;\\n    }\\n};\\nfunction findTheTypical(wordlist){\\n\\tlet count = Array.from({length:6}, x=>new Object());\\n\\tfor(let i=0; i<wordlist.length; i++){\\n\\t\\tfor(let j=0; j<6; j++){\\n\\t\\t\\tlet cur = wordlist[i][j];\\n\\t\\t\\tif(count[j][cur]===undefined) count[j][cur]=1;\\n\\t\\t\\telse count[j][cur]++;\\n\\t\\t}\\n\\t}\\n\\tlet maxPos=0, maxCount=0, maxAlp =\\'\\';\\n\\tfor(let i=0; i<6; i++){\\n\\t\\tfor(let k of Object.keys(count[i])){\\n\\t\\t\\tif(count[i][k]>maxCount){\\n\\t\\t\\t\\tmaxCount = count[i][k];\\n\\t\\t\\t\\tmaxPos = i;\\n\\t\\t\\t\\tmaxAlp = k;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(let i=0; i<wordlist.length; i++){\\n\\t\\tif(wordlist[i][maxPos]===maxAlp) return wordlist[i];\\n\\t}\\n}\\nfunction diff(a,b){\\n\\tlet count = 0;\\n\\tfor(let i=0; i<a.length; i++){\\n\\t\\tif(a[i]!==b[i]) count++;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 138039,
                "title": "clean-java-ac-solution",
                "content": "```\\npublic void findSecretWord(String[] wordlist, Master master) {\\n\\t\\tint[] count = new int[26];\\n\\t\\tfor (String s : wordlist) {\\n\\t\\t\\tfor (char c : s.toCharArray()) {\\n\\t\\t\\t\\tcount[c - \\'a\\']++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSet<String> set = new HashSet<>();\\n\\t\\tfor (String s : wordlist) {\\n\\t\\t\\tset.add(s);\\n\\t\\t}\\n\\t\\tint i = 0;\\n\\t\\twhile (i++ < 10) {\\n\\t\\t\\tString best = getBestCandidate(set, count);\\n\\t\\t\\tint match = master.guess(best);\\n\\t\\t\\tfor (Iterator<String> ite = set.iterator(); ite.hasNext();) {\\n\\t\\t\\t\\tif (match(best, ite.next()) != match) {\\n\\t\\t\\t\\t\\t// Remove the candidate that not matches.\\n\\t\\t\\t\\t\\tite.remove();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\nprivate String getBestCandidate(Set<String> wordlist, int[] count) {\\n\\t\\tint max = 0;\\n\\t\\tString best = \"\";\\n\\t\\tfor (String s : wordlist) {\\n\\t\\t\\tint c = 0;\\n\\t\\t\\tfor (char a : s.toCharArray()) {\\n\\t\\t\\t\\tc += count[a - \\'a\\'];\\n\\t\\t\\t}\\n\\t\\t\\tif (c > max) {\\n\\t\\t\\t\\tmax = c;\\n\\t\\t\\t\\tbest = s;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn best;\\n\\t}\\n\\nprivate int match(String a, String b) {\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < a.length(); i++) {\\n\\t\\t\\tif (a.charAt(i) == b.charAt(i))\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\npublic void findSecretWord(String[] wordlist, Master master) {\\n\\t\\tint[] count = new int[26];\\n\\t\\tfor (String s : wordlist) {\\n\\t\\t\\tfor (char c : s.toCharArray()) {\\n\\t\\t\\t\\tcount[c - \\'a\\']++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tSet<String> set = new HashSet<>();\\n\\t\\tfor (String s : wordlist) {\\n\\t\\t\\tset.add(s);\\n\\t\\t}\\n\\t\\tint i = 0;\\n\\t\\twhile (i++ < 10) {\\n\\t\\t\\tString best = getBestCandidate(set, count);\\n\\t\\t\\tint match = master.guess(best);\\n\\t\\t\\tfor (Iterator<String> ite = set.iterator(); ite.hasNext();) {\\n\\t\\t\\t\\tif (match(best, ite.next()) != match) {\\n\\t\\t\\t\\t\\t// Remove the candidate that not matches.\\n\\t\\t\\t\\t\\tite.remove();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\nprivate String getBestCandidate(Set<String> wordlist, int[] count) {\\n\\t\\tint max = 0;\\n\\t\\tString best = \"\";\\n\\t\\tfor (String s : wordlist) {\\n\\t\\t\\tint c = 0;\\n\\t\\t\\tfor (char a : s.toCharArray()) {\\n\\t\\t\\t\\tc += count[a - \\'a\\'];\\n\\t\\t\\t}\\n\\t\\t\\tif (c > max) {\\n\\t\\t\\t\\tmax = c;\\n\\t\\t\\t\\tbest = s;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn best;\\n\\t}\\n\\nprivate int match(String a, String b) {\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < a.length(); i++) {\\n\\t\\t\\tif (a.charAt(i) == b.charAt(i))\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3009208,
                "title": "easiest-method-ever",
                "content": "# Code\\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\n int check( string &a, string &b) {\\n        int ct = 0 ; \\n        for(int i =0 ; i < 6 ; i++) \\n            if(a[i] == b[i])\\n                ct++ ; \\n        return ct ; \\n    }\\n\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& words, Master& master) {\\n            for(int i=0, match = 0; i < 30 and match !=6 ; i++) {\\n                string trial = words[words.size()/2];\\n                match = master.guess(trial); \\n                vector<string> p; \\n                for(auto word: words) {\\n                if(check(word, trial) == match)\\n                    p.push_back(word); \\n            }\\n            words = p; \\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\n int check( string &a, string &b) {\\n        int ct = 0 ; \\n        for(int i =0 ; i < 6 ; i++) \\n            if(a[i] == b[i])\\n                ct++ ; \\n        return ct ; \\n    }\\n\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& words, Master& master) {\\n            for(int i=0, match = 0; i < 30 and match !=6 ; i++) {\\n                string trial = words[words.size()/2];\\n                match = master.guess(trial); \\n                vector<string> p; \\n                for(auto word: words) {\\n                if(check(word, trial) == match)\\n                    p.push_back(word); \\n            }\\n            words = p; \\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000220,
                "title": "a-fast-solution-using-a-pseudo-randomization-time-complexity-o-n-2-space-complexity-o-1",
                "content": "# Intuition\\n\\nFolks, let me first be clear and confess I didn\\'t come with the idea of doing this, my only role was find this solution on the fastest implementations and enhance it a little. By a little I mean originaly the elimination/deletion was a swap, and as we wont use the eliminated value anymore I simply changed to perform only \"half\" of the swich.\\n\\nThe idea:\\n\\n- We ask the \"master\" method to inform how many letters match the secret word, if its six then we stop as we found the word. If it\\'s not then lets filter for words that only have the same number of matches as the informed by \"guess\", as that is the exact value we have in common with the current word.\\n- When eliminating, lets excahnge the impossible word with the last valid word in the array, and reduce the index to not include the switched word.\\n  - This ends up creating a pseudo randomization, as at the end of every iteration many words changed place due to the \"randomization\" of the invalid words being exchanged.\\n- At the end of the iteration we eliminate the first word by the same process as the oders (exchanging it by the last valid word and decreasing the \"last\" index)\\n\\n![image.png](https://assets.leetcode.com/users/images/4f6d43c8-a3f7-4979-80ed-2d63aa4ac8a3_1672871768.9160514.png)\\n\\nNote: One of the things that make this so fast is that we are not creating objects (**O(1)**), only switching the position of the existing. The other is the simplicity of the pseudo randomization.\\n\\n# Approach\\nFind still valid words + pseudo randomizarion\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n![image.png](https://assets.leetcode.com/users/images/c58e2866-5011-49b9-9bd1-b393c2a10662_1672871907.4498017.png)\\nNote: most of the times were good, but in rare cases I got above 3 ms.\\n\\n```java\\nclass Solution{\\n\\tpublic void findSecretWord(String[] words, Master master){\\n\\t\\t\\tint last = words.length-1;\\n\\t\\t\\twhile(true){\\n\\t\\t\\t\\tint count = master.guess(words[0]);\\n\\t\\t\\t\\tif(count==6) return;\\n                int i = 1;\\n\\t\\t\\t\\twhile(i <= last){\\n\\t\\t\\t\\t\\tint c = 0;\\n\\t\\t\\t\\t\\tfor(int j = 0; j < 6; j++) if(words[i].charAt(j)==words[0].charAt(j)) c++;\\n\\t\\t\\t\\t\\tif(c!=count) words[i]=words[last--];\\n\\t\\t\\t\\t\\telse i++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\twords[0]=words[last--];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution{\\n\\tpublic void findSecretWord(String[] words, Master master){\\n\\t\\t\\tint last = words.length-1;\\n\\t\\t\\twhile(true){\\n\\t\\t\\t\\tint count = master.guess(words[0]);\\n\\t\\t\\t\\tif(count==6) return;\\n                int i = 1;\\n\\t\\t\\t\\twhile(i <= last){\\n\\t\\t\\t\\t\\tint c = 0;\\n\\t\\t\\t\\t\\tfor(int j = 0; j < 6; j++) if(words[i].charAt(j)==words[0].charAt(j)) c++;\\n\\t\\t\\t\\t\\tif(c!=count) words[i]=words[last--];\\n\\t\\t\\t\\t\\telse i++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\twords[0]=words[last--];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969789,
                "title": "pointer-exploitation-single-line-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all, technically this is not an actual solution. So don\\'t expect this to be algorithmic. We can leverage shortcomings of pointers in C++. Basic idea is to access private variables of the `master` object.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n(Assume that the original string is stored in the `Master` class itself.)\\n1. We are already given an object so just take the address of it.\\n2. Reinterpret it as a string and voila now you have got the actual string.\\n3. Return this string and you are done!\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& words, Master& master) {\\n        master.guess(*reinterpret_cast<string *>(&master));\\n    }\\n};\\n```\\nWhy am I posting this?\\n1. This is so cool.\\n2. This can be misused during the actual contests. So, maybe someday leetcode admins see this and they can come up with some clever solutions (I already have one in mind) to avoid this.\\n\\nOne more problem with such solution: \\n[Problem](https://leetcode.com/problems/leftmost-column-with-at-least-a-one/description/)\\n[My Submission](https://leetcode.com/problems/leftmost-column-with-at-least-a-one/submissions/867873157/)\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& words, Master& master) {\\n        master.guess(*reinterpret_cast<string *>(&master));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750841,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {\\npublic:\\n    int check( string &a, string &b) {\\n        int ct = 0 ; \\n        for(int i =0 ; i < 6 ; i++) \\n            if(a[i] == b[i])\\n                ct++ ; \\n        return ct ; \\n    }\\n    \\n    void findSecretWord(vector<string>& words, Master& master) {\\n        for(int i=0, matches = 0; i < 30 and matches !=6 ; i++) {\\n            string trial = words[words.size()/2]  ; \\n            matches = master.guess(trial) ; \\n            vector<string> possibilities ; \\n            for(auto word: words) {\\n                if(check(word, trial) == matches)\\n                    possibilities.push_back(word); \\n            }\\n            words = possibilities ; \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {\\npublic:\\n    int check( string &a, string &b) {\\n        int ct = 0 ; \\n        for(int i =0 ; i < 6 ; i++) \\n            if(a[i] == b[i])\\n                ct++ ; \\n        return ct ; \\n    }\\n    \\n    void findSecretWord(vector<string>& words, Master& master) {\\n        for(int i=0, matches = 0; i < 30 and matches !=6 ; i++) {\\n            string trial = words[words.size()/2]  ; \\n            matches = master.guess(trial) ; \\n            vector<string> possibilities ; \\n            for(auto word: words) {\\n                if(check(word, trial) == matches)\\n                    possibilities.push_back(word); \\n            }\\n            words = possibilities ; \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116054,
                "title": "pretty-sure-this-task-is-impossible-to-solve-someone-correct-me",
                "content": "Imagine wordlist is:\\n\\n```\\naaaaaa\\nbbbbbb\\ncccccc\\n.....\\nzzzzzz\\n```\\n\\nI don\\'t see how this can be solved in 10 guesses.",
                "solutionTags": [],
                "code": "```\\naaaaaa\\nbbbbbb\\ncccccc\\n.....\\nzzzzzz\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1869917,
                "title": "java-o-n-1ms-99-01-easy-to-understand",
                "content": "The approach is, for each guess, take a word from the word list and use it to guess. If we get 6 matches, we are done. If not, we iterate the rest of the words in the word list and remove words that don\\'t have a similar number of matches. For example, if the guess word is `ccbazz` and the secret word is `acckzz`, `master.guess(\"ccbazz\")` will return 3, then I iterate the array to find words that compared to the guess word (`ccbazz`) have a match of 3, removing the rest.\\n\\nTo make the removal easy, we first convert the array to a hash set, and make use of an `Iterator` to remove while iterating (remember that there will be a concurrent exception if you try to remove an item from a collection while iterating on it). Why not a list? It could also work, but there is no use for the indexes. Besides, removal of a hash set is `O(1)`, which may differ on a list depending on the implementation.\\n\\nFor choosing the guess word, it doesn\\'t really matter, as there is no additional information that we can use to make a \"smart\" choice, so either a random pick or, in the case of this solution, the first word from the iterator.\\n\\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Set<String> wordset = new HashSet<>(Arrays.asList(wordlist));\\n        int guesses = 0;\\n        while (!wordset.isEmpty() && guesses < 10) {\\n            Iterator<String> iterator = wordset.iterator();\\n            String guessWord = iterator.next();\\n            int matches = master.guess(guessWord);\\n            if (matches == 6) {\\n                return;\\n            }\\n            iterator.remove();\\n            while (iterator.hasNext()) {\\n                String word = iterator.next();\\n                if (!this.hasPartialMatch(guessWord, word, matches)) {\\n                    iterator.remove();\\n                }\\n            }\\n            guesses++;\\n        }\\n    }\\n    \\n    private boolean hasPartialMatch(String word1, String word2, int matches) {\\n        int count = 0;\\n        for (int i = 0; i < 6; i++) {\\n            if (word1.charAt(i) == word2.charAt(i)) {\\n                count++;\\n            }\\n        }\\n        return count == matches;\\n    }\\n}\\n```\\n\\n**Complexity**\\nFor time complexity, we iterate the word list on each guess, reducing the list on each iteration. Worst case is that we don\\'t remove any word from the list, which will make 10 iterations of the list. Since that is fixed, the complexity of the iteration is `O(n)`, where `n` is the number of words in the word list. `hasPartialMatch()` also iterates each word, but we know the length is fixed to 6, so it doesn\\'t really add to the complexity.\\n\\nFor space complexity, we make use of a hash set to store the words for easy removal, so that gives us `O(n)`.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Set<String> wordset = new HashSet<>(Arrays.asList(wordlist));\\n        int guesses = 0;\\n        while (!wordset.isEmpty() && guesses < 10) {\\n            Iterator<String> iterator = wordset.iterator();\\n            String guessWord = iterator.next();\\n            int matches = master.guess(guessWord);\\n            if (matches == 6) {\\n                return;\\n            }\\n            iterator.remove();\\n            while (iterator.hasNext()) {\\n                String word = iterator.next();\\n                if (!this.hasPartialMatch(guessWord, word, matches)) {\\n                    iterator.remove();\\n                }\\n            }\\n            guesses++;\\n        }\\n    }\\n    \\n    private boolean hasPartialMatch(String word1, String word2, int matches) {\\n        int count = 0;\\n        for (int i = 0; i < 6; i++) {\\n            if (word1.charAt(i) == word2.charAt(i)) {\\n                count++;\\n            }\\n        }\\n        return count == matches;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858285,
                "title": "more-restricts-to-make-it-possible",
                "content": "Your input: ```\\n\"qaaaaa\"\\n[\"aaaaaa\",\"baaaaa\",\"caaaaa\",\"daaaaa\",\"eaaaaa\",\"faaaaa\",\"gaaaaa\",\"haaaaa\",\"iaaaaa\",\"jaaaaa\",\"kaaaaa\",\"laaaaa\",\"maaaaa\",\"naaaaa\",\"oaaaaa\",\"paaaaa\",\"qaaaaa\",\"raaaaa\",\"saaaaa\",\"taaaaa\",\"uaaaaa\",\"vaaaaa\",\"waaaaa\",\"xaaaaa\",\"yaaaaa\"]\\n10\\n```\\nExpected: ```\\nEither you took too many guesses, or you did not find the secret word.\\n```",
                "solutionTags": [],
                "code": "```\\n\"qaaaaa\"\\n[\"aaaaaa\",\"baaaaa\",\"caaaaa\",\"daaaaa\",\"eaaaaa\",\"faaaaa\",\"gaaaaa\",\"haaaaa\",\"iaaaaa\",\"jaaaaa\",\"kaaaaa\",\"laaaaa\",\"maaaaa\",\"naaaaa\",\"oaaaaa\",\"paaaaa\",\"qaaaaa\",\"raaaaa\",\"saaaaa\",\"taaaaa\",\"uaaaaa\",\"vaaaaa\",\"waaaaa\",\"xaaaaa\",\"yaaaaa\"]\\n10\\n```\n```\\nEither you took too many guesses, or you did not find the secret word.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1795749,
                "title": "isnt-this-an-easier-version-of-wordle",
                "content": "I did this question some time ago, and I was playing today\\'s Wordle and this question suddenly came to my mind lol.\\n```\\n# \"\"\"\\n# This is Master\\'s API interface.\\n# You should not implement it, or speculate about its implementation\\n# \"\"\"\\n# class Master:\\n#\\xA0 \\xA0\\xA0 def guess(self, word: str) -> int:\\nfrom collections import Counter\\nfrom itertools import permutations\\n\\'\\'\\'\\nHere we have to guess a word from the list,\\nwe still can calculate a score of similarity for each word,\\nand guess the word with highest score.\\n\\'\\'\\'\\nclass Solution:\\n\\xA0 \\xA0 def match(self, w1, w2):\\n\\xA0 \\xA0 \\xA0 \\xA0 return sum(a == b for (a, b) in zip(w1, w2))\\n\\xA0 \\xA0 \\n\\xA0 \\xA0 def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n\\xA0 \\xA0 \\xA0 \\xA0 x = 0\\n\\xA0 \\xA0 \\xA0 \\xA0 # since we have only 6 guesses\\n\\xA0 \\xA0 \\xA0 \\xA0 while x < 6:\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 # count how many times a char appear at each pos\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 cnt = [Counter(w[i] for w in wordlist) for i in range(6)]\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 # make the guess based on the highest frequency for each pos\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 guess = max(wordlist, key = lambda w: sum(cnt[i][c] for i, c in enumerate(w)))\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 # get back how manny matches we have \\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 x = master.guess(guess)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 # make up the new wordlist based on the matches we have \\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 wordlist = [w for w in wordlist if self.match(w, guess) == x]\\n```\\nsolution not credit to me though",
                "solutionTags": [],
                "code": "```\\n# \"\"\"\\n# This is Master\\'s API interface.\\n# You should not implement it, or speculate about its implementation\\n# \"\"\"\\n# class Master:\\n#\\xA0 \\xA0\\xA0 def guess(self, word: str) -> int:\\nfrom collections import Counter\\nfrom itertools import permutations\\n\\'\\'\\'\\nHere we have to guess a word from the list,\\nwe still can calculate a score of similarity for each word,\\nand guess the word with highest score.\\n\\'\\'\\'\\nclass Solution:\\n\\xA0 \\xA0 def match(self, w1, w2):\\n\\xA0 \\xA0 \\xA0 \\xA0 return sum(a == b for (a, b) in zip(w1, w2))\\n\\xA0 \\xA0 \\n\\xA0 \\xA0 def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n\\xA0 \\xA0 \\xA0 \\xA0 x = 0\\n\\xA0 \\xA0 \\xA0 \\xA0 # since we have only 6 guesses\\n\\xA0 \\xA0 \\xA0 \\xA0 while x < 6:\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 # count how many times a char appear at each pos\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 cnt = [Counter(w[i] for w in wordlist) for i in range(6)]\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 # make the guess based on the highest frequency for each pos\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 guess = max(wordlist, key = lambda w: sum(cnt[i][c] for i, c in enumerate(w)))\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 # get back how manny matches we have \\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 x = master.guess(guess)\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 # make up the new wordlist based on the matches we have \\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 wordlist = [w for w in wordlist if self.match(w, guess) == x]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673705,
                "title": "python-solution-that-guarantees-to-find-the-secrete-if-such-a-strategy-is-possible",
                "content": "The basic idea behind this solution is to guess the word that has the largest **entropy** / provides the most information after we hear the answer. \\n\\nBy keeping track of a list of remaining possible numbers, we want to ask the question whose answer is hardest to predict. We don\\'t make a guess that we know for sure is going to have 0 matches with any word in the remaining list, and similarly we don\\'t want to know that it\\'s very likely to have x amount of matches with the secrete before we ask the \"master\". Since we have no prior, the probability of the secrete being any of the words in the remaining list is the same. When we guess a word, there are 7 possible outcomes. We want the probability of each outcome to be as evenly distributed as possible. One way to calculate how evenly distributed the probabilities are is summing up all the products of the probability of being in a category and the log of this probability (the entropy). See below for the implementation. \\n\\n```\\n# \"\"\"\\n# This is Master\\'s API interface.\\n# You should not implement it, or speculate about its implementation\\n# \"\"\"\\n#class Master(object):\\n#    def guess(self, word):\\n#        \"\"\"\\n#        :type word: str\\n#        :rtype int\\n#        \"\"\"\\n\\nimport math\\n\\nclass Solution(object):\\n    def comp(self, word1, word2):\\n        \\n        matchcount = 0\\n        for i in range(6):\\n            if word1[i] == word2[i]:\\n                matchcount += 1\\n        return matchcount\\n    \\n    def entropy(self, l):\\n        # l is a list of [0...6]\\n        ctrs = [0.0] * 7\\n        for ele in l:\\n            ctrs[ele] += 1\\n        H = 0.0\\n        for i in ctrs:\\n            if i==0:\\n                continue\\n                \\n            pi = i / sum(ctrs)\\n            H -= pi * math.log(pi)\\n            \\n        return H\\n    \\n    def findSecretWord(self, wordlist, master):\\n        \"\"\"\\n        :type wordlist: List[Str]\\n        :type master: Master\\n        :rtype: None\\n        \"\"\"\\n        n = len(wordlist)\\n        corrmat = [[0] * n for _ in range(n)]\\n        \\n        for i in range(n):\\n            for j in range(i, n):\\n                corr = self.comp(wordlist[i], wordlist[j])\\n                corrmat[i][j] = corr\\n                corrmat[j][i] = corr\\n                \\n                \\n        remainlist = list(range(n))\\n        for trialNum in range(10):\\n            if len(remainlist) == 1:\\n                master.guess(wordlist[remainlist[0]])\\n                return\\n            \\n            key = (lambda x: self.entropy([corrmat[x][i] for i in remainlist]))\\n            bestguess = max(list(range(n)), key=key)\\n            guessword = wordlist[bestguess]\\n            answer = master.guess(guessword)\\n            \\n            remainlist = [i for i in remainlist if corrmat[bestguess][i]==answer]\\n            \\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# \"\"\"\\n# This is Master\\'s API interface.\\n# You should not implement it, or speculate about its implementation\\n# \"\"\"\\n#class Master(object):\\n#    def guess(self, word):\\n#        \"\"\"\\n#        :type word: str\\n#        :rtype int\\n#        \"\"\"\\n\\nimport math\\n\\nclass Solution(object):\\n    def comp(self, word1, word2):\\n        \\n        matchcount = 0\\n        for i in range(6):\\n            if word1[i] == word2[i]:\\n                matchcount += 1\\n        return matchcount\\n    \\n    def entropy(self, l):\\n        # l is a list of [0...6]\\n        ctrs = [0.0] * 7\\n        for ele in l:\\n            ctrs[ele] += 1\\n        H = 0.0\\n        for i in ctrs:\\n            if i==0:\\n                continue\\n                \\n            pi = i / sum(ctrs)\\n            H -= pi * math.log(pi)\\n            \\n        return H\\n    \\n    def findSecretWord(self, wordlist, master):\\n        \"\"\"\\n        :type wordlist: List[Str]\\n        :type master: Master\\n        :rtype: None\\n        \"\"\"\\n        n = len(wordlist)\\n        corrmat = [[0] * n for _ in range(n)]\\n        \\n        for i in range(n):\\n            for j in range(i, n):\\n                corr = self.comp(wordlist[i], wordlist[j])\\n                corrmat[i][j] = corr\\n                corrmat[j][i] = corr\\n                \\n                \\n        remainlist = list(range(n))\\n        for trialNum in range(10):\\n            if len(remainlist) == 1:\\n                master.guess(wordlist[remainlist[0]])\\n                return\\n            \\n            key = (lambda x: self.entropy([corrmat[x][i] for i in remainlist]))\\n            bestguess = max(list(range(n)), key=key)\\n            guessword = wordlist[bestguess]\\n            answer = master.guess(guessword)\\n            \\n            remainlist = [i for i in remainlist if corrmat[bestguess][i]==answer]\\n            \\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507511,
                "title": "java-o-log-n-probability-to-find-word-100",
                "content": "Soluton is based on \"**Probability Theory**\" and \"**Expected value**\"!\\n\\nRuntime: 0 ms, faster than **100.00%** of Java online submissions for Guess the Word.\\n\\n```\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        int length = wordlist.length;\\n        for (int i = 0; i < 10; i++) {            \\n            int index = length/2;            \\n            String selected = wordlist[index];              \\n            int matches = master.guess(selected);                             \\n            if (matches == 6) return;                        \\n            for (int k =0; k < length; k++){\\n                if (countMatches(selected, wordlist[k]) != matches){                    \\n\\t\\t\\t\\t\\tlength--;\\n                    wordlist[k] = wordlist[length];\\n                }\\n            }\\n            \\n        }        \\n    }\\n    \\n    private int countMatches(String s1, String s2){\\n        int matches = 0;\\n        for (int i = 0; i < 6; i ++) {\\n            if (s1.charAt(i) == s2.charAt(i)) {\\n                matches++;\\n            }\\n        }        \\n        return matches;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        int length = wordlist.length;\\n        for (int i = 0; i < 10; i++) {            \\n            int index = length/2;            \\n            String selected = wordlist[index];              \\n            int matches = master.guess(selected);                             \\n            if (matches == 6) return;                        \\n            for (int k =0; k < length; k++){\\n                if (countMatches(selected, wordlist[k]) != matches){                    \\n\\t\\t\\t\\t\\tlength--;\\n                    wordlist[k] = wordlist[length];\\n                }\\n            }\\n            \\n        }        \\n    }\\n    \\n    private int countMatches(String s1, String s2){\\n        int matches = 0;\\n        for (int i = 0; i < 6; i ++) {\\n            if (s1.charAt(i) == s2.charAt(i)) {\\n                matches++;\\n            }\\n        }        \\n        return matches;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401460,
                "title": "java-random-solution",
                "content": "```\\nclass Solution {\\n    int wordLength = 6;\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Random random = new Random();\\n        List<String> possibleWords = new ArrayList<>();\\n        for (String word : wordlist)\\n            possibleWords.add(word);\\n        \\n        int attempt = 0;\\n        while (attempt < 10){\\n            int candidate = random.nextInt(possibleWords.size());\\n            String candidateWord = possibleWords.get(candidate);\\n            int score = master.guess(candidateWord);\\n            \\n            if (score == 6) //found the match gg :)\\n                return;\\n            \\n            List<String> updatedPossibleWords = new ArrayList<>();\\n            for (String word : possibleWords){\\n                if (checkMatches(candidateWord, word) == score) // cool we found another possible Matched word add it to new list.\\n                    updatedPossibleWords.add(word);\\n            }\\n            possibleWords = updatedPossibleWords; // update base list with new words\\n            attempt++;\\n        }\\n    }\\n    \\n    private int checkMatches(String word1, String word2){\\n        int count = 0;\\n        for (int i = 0; i < wordLength; ++i)\\n            if (word1.charAt(i) == word2.charAt(i))\\n                count++;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int wordLength = 6;\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Random random = new Random();\\n        List<String> possibleWords = new ArrayList<>();\\n        for (String word : wordlist)\\n            possibleWords.add(word);\\n        \\n        int attempt = 0;\\n        while (attempt < 10){\\n            int candidate = random.nextInt(possibleWords.size());\\n            String candidateWord = possibleWords.get(candidate);\\n            int score = master.guess(candidateWord);\\n            \\n            if (score == 6) //found the match gg :)\\n                return;\\n            \\n            List<String> updatedPossibleWords = new ArrayList<>();\\n            for (String word : possibleWords){\\n                if (checkMatches(candidateWord, word) == score) // cool we found another possible Matched word add it to new list.\\n                    updatedPossibleWords.add(word);\\n            }\\n            possibleWords = updatedPossibleWords; // update base list with new words\\n            attempt++;\\n        }\\n    }\\n    \\n    private int checkMatches(String word1, String word2){\\n        int count = 0;\\n        for (int i = 0; i < wordLength; ++i)\\n            if (word1.charAt(i) == word2.charAt(i))\\n                count++;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351288,
                "title": "simple-c-solution-beats-98-time-78-space-in-depth-explanation",
                "content": "This solution revolves around keeping track of which strings in wordlist could still be the secret word, by modifying wordlist in place. Lots of room for unlucky guesses. It takes a few guesses even when wordlist.Length is 100.\\n\\nWe begin by declaring:\\n* pop, which will be used to keep track of how many words could still be the secret word,\\n* right, to keep track of the current guess\\'s similarity to the secret word,\\n* the current guess.\\n```\\nclass Solution {\\n    public void FindSecretWord(string[] wordlist, Master master) {\\n        int pop = wordlist.Length;\\n        int right;\\n        string guess;\\n```\\npop begins as wordlist.Length, but will quickly be lowered to a small fraction of this. When iterating through wordlist, pop is used instead of wordlist.Length as an upper bound; effectively allowing us to lower the length of wordlist and remove strings as we differentiate them from the secret word.\\nAny string in wordlist beyond pop-1 is known to not be the secret word, and is never accessed.\\n```\\n        for (int i = 0; i < 10; i++) {\\n            guess = wordlist[0];\\n            right = master.Guess(guess);\\n            if (right == 6) {\\n                return;\\n            } else {\\n                wordlist[0] = wordlist[pop-1];\\n                pop--;\\n            }\\n```\\nThen we run through 10 guesses, in the form of a for loop. For all submission cases it does not reach the end of this loop.\\nThe first string in wordlist is the guess each time. We assign right to the number of similarities it has with the secret word. If it happens to be correct (e.g. right is 6) then we immediately return, as we have guessed the secret word. This becomes exponentially more likely with each guess, and in the worst case, ocurrs when we have elimentated all other possible words and pop is 1. If wordlist[0] is not the secret word, we remove it from our population of candidates, by copying the last candidate to its position and then removing the last candidate by decrementing pop.\\nNote: we copy wordlist[0] to a buffer string guess, because the value of wordlist[0] is erased if it isn\\'t the secret word.\\n```\\nfor (int j = 0; j < pop; j++) {\\n                if (Match(guess, wordlist[j]) != right) {\\n                    wordlist[j] = wordlist[pop-1];\\n                    pop--;\\n                    j--;\\n                }\\n            }\\n```\\nNow we iterate through the rest of the viable strings in wordlist, using another for loop up to pop-1. We check each remaining word for its number of matching characters with the guess using Match(). If the number of matching characters between wordlist[j] and guess isn\\'t the same as our int right (the number of matching characters between the secret word and guess), then it can\\'t be the secret word. In that case we replace it with the last string in the population, and remove the last string with pop--. We must also decrement j, because the string we just checked (wordlist[j]), as been changed, and we need to go back and check it again.\\nAs this iterates through the rest of the viable population of strings, it decreases pop by roughly a factor of 3. This is what lowers our space complexity from O(n^2) to O(n log(n)). It also serves as a space efficient way to differentiate all of the viable strings from the non-viable ones, just by modifying wordlist in-place.\\n\\n\\nFull Code:\\n\\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *     public int Guess(string word);\\n * }\\n */\\nclass Solution {\\n    public void FindSecretWord(string[] wordlist, Master master) {\\n        int pop = wordlist.Length;\\n        int right;\\n        string guess;\\n        for (int i = 0; i < 10; i++) {\\n            guess = wordlist[0];\\n            right = master.Guess(guess);\\n            if (right == 6) {\\n                return;\\n            } else {\\n                wordlist[0] = wordlist[pop-1];\\n                pop--;\\n            }\\n            for (int j = 0; j < pop; j++) {\\n                if (Match(guess, wordlist[j]) != right) {\\n                    wordlist[j] = wordlist[pop-1];\\n                    pop--;\\n                    j--;\\n                }\\n            }\\n        }\\n        return;\\n        \\n    }\\n    \\n    private int Match(string guess, string word) {\\n        int n = 0;\\n        for (int i = 0; i < 6; i++) {\\n            if (guess[i] == word[i]) n++;\\n        }\\n        return n;\\n    }\\n}\\n```\\nAs mentioned above, the worst-case scenario, wordlist[0] isn\\'t guessed until pop is 1, and all other strings have been proven to not be the secret word. However, it often takes less guesses than this. For example, in test case 2, it takes 5 guesses. The population of viable strings decreases as follows: 100, 14, 9, 3. Once there were  3 strings left, there was a 1/3 chance of wordlist[0] being correct, and it guessed it. This is fairly average luck, since it did not happen to get the 1/9 or 1/14 or 1/100 chance of being correct on an earlier guess. There is a 19% chance that it would have guessed the secret word earlier, and a 46% chance that it guessed the secret word in the number of guesses it did.\\n\\n* O(n log(n)) time complexity worst-case, where n is wordlist.Length. It must iterate through wordlist.Length, then a fraction of that, then a fraction of that, etc.\\n* O(1) space complexity. 5 int values (pop, right, i, j, n). and one buffer string, guess.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void FindSecretWord(string[] wordlist, Master master) {\\n        int pop = wordlist.Length;\\n        int right;\\n        string guess;\\n```\n```\\n        for (int i = 0; i < 10; i++) {\\n            guess = wordlist[0];\\n            right = master.Guess(guess);\\n            if (right == 6) {\\n                return;\\n            } else {\\n                wordlist[0] = wordlist[pop-1];\\n                pop--;\\n            }\\n```\n```\\nfor (int j = 0; j < pop; j++) {\\n                if (Match(guess, wordlist[j]) != right) {\\n                    wordlist[j] = wordlist[pop-1];\\n                    pop--;\\n                    j--;\\n                }\\n            }\\n```\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *     public int Guess(string word);\\n * }\\n */\\nclass Solution {\\n    public void FindSecretWord(string[] wordlist, Master master) {\\n        int pop = wordlist.Length;\\n        int right;\\n        string guess;\\n        for (int i = 0; i < 10; i++) {\\n            guess = wordlist[0];\\n            right = master.Guess(guess);\\n            if (right == 6) {\\n                return;\\n            } else {\\n                wordlist[0] = wordlist[pop-1];\\n                pop--;\\n            }\\n            for (int j = 0; j < pop; j++) {\\n                if (Match(guess, wordlist[j]) != right) {\\n                    wordlist[j] = wordlist[pop-1];\\n                    pop--;\\n                    j--;\\n                }\\n            }\\n        }\\n        return;\\n        \\n    }\\n    \\n    private int Match(string guess, string word) {\\n        int n = 0;\\n        for (int i = 0; i < 6; i++) {\\n            if (guess[i] == word[i]) n++;\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1288679,
                "title": "mastermind-puzzle-inspired-solution",
                "content": "First of all, very fun problem. Way outside my comfort zone and a good learning experience.\\n\\nThis problem smelled to me of Mastermind, a puzzle game from the 70\\'s which has been adapted to multiple games (such as in my experience Mansions of Madness!). I am not an expert, so I decided to read a bit on [Mastermind](https://en.wikipedia.org/wiki/Mastermind_(board_game)) to establish some abtractions.\\n\\nYou can see in the Wikipedia article that the real Mastermind puzzle is quite difficult to solve (NP Complete proofs in Wiki) and as such there are a few conventional solutions in the article. I made the following conceptual abstractions:\\n\\n1. Code guesses in Mastermind are equivalent to secret word guesses in this problem\\n2. Each guess will remove a number of candidates (pruning)\\n3. The mastermind is constrained to inform you how many matches you have between the code and the guess\\n\\nThe 3rd concept is powerful. Assuming *k* is the result of the guess (i.e. master.guess(word)), and *guess* is the word provided to the mastermind:\\n\\n1. Any candidates sharing less than*k* common letters with the *guess* can be removed\\n2. IFF *k* is zero, then all candidates sharing a common index/value pair with *guess* can be removed.\\n\\nNow, how do we pick the next best candidate? I am not an expert but Wikipedia (and Donald Knuth) suggests Minimax. In this problem our worst case scenario is simply running out guesses. We know that each choice will prune our candidate pool, however, maximizing the number of candidates pruned is the challenge. I attempted a few approaches and have valid solutions:\\n\\n 1. Get Lucky Frequently: 0ms avg., at most 10 guesses (non-deterministic).\\n 2. Greedily choose word with highest commonality: 0-4ms avg. at most 8 guesses.\\n\\nI do believe there is a better approach than the ones I implemented and I\\'d love to see them, however, leetcode is only judging by execution speed and memory size, not so much minimum guesses. Would love to see leetcode support this type of feature.\\n\\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {    \\n    //!< O(1) Helper to calculate number of matching characters\\n    static int getNumberMatchingCharacters(const vector<string>& wordlist, int i, int j) {\\n        //!< Size of each word!\\n        static const int K = 6;\\n        \\n        int ret = 0;\\n        for (int k = 0; k < K; k++) {\\n            if (wordlist[i][k] == wordlist[j][k]) {\\n                ret++;\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    //!< O(N^2) Helper for showing the adjacency matrix\\n    static void printAdjacencyMatrix(const vector<vector<int>> &adj) {\\n        for (int i = 0; i < adj.size(); i++) {\\n            cout << i << \": [\";\\n            for (auto w : adj[i]) {\\n                cout << w << \",\";\\n            }\\n            cout << \"]\\\\n\";\\n        }\\n    }\\n    \\n    //!< O(N^2) helper to create the adjacency matrix\\n    //!< adj[i][i] (aka diagonal) maintains the number of connected vertices\\n    static vector<vector<int>> createAdjacencyMatrix(const vector<string>& wordlist) {\\n        const int N = wordlist.size();\\n        vector<vector<int>> adj(N, vector<int>(N));\\n        \\n        // Generate the adjacency matrix\\n        for (int i = 0; i < N; i++) {\\n            for (int j = i+1; j < N; j++) {\\n                adj[i][j] = adj[j][i] = getNumberMatchingCharacters(wordlist, i, j);\\n            }\\n        }\\n        \\n        // Compute value for each vertex - store in diagonal\\n        for (int i = 0; i < N; i++) {\\n\\t\\t    adj[i][i] = 0;\\n            for (int j = 0; j < N; j++) {\\n                if (i == j) continue;\\n                adj[i][i] += adj[i][j];\\n            }\\n        }\\n        \\n        // Some debug info\\n        //cout << \"created adjacency matrix: \\\\n\";\\n        //printAdjacencyMatrix(adj);\\n        \\n        return adj;\\n    }\\n    \\n    static int getNextCandidate(const vector<vector<int>> &adj) {\\n        const int N = adj.size();\\n        \\n        // Simply use the diagonal of the adjacency matrix to determine the \"fattest\" family\\n        // Maybe use a heap here if we are being special, but for now O(N) search.\\n        int max_w_sum = INT_MIN, max_w_idx = -1;\\n        for (int i = 0; i < N; i++) {\\n            if (adj[i][i] > max_w_sum) {\\n                max_w_sum = adj[i][i];\\n                max_w_idx = i;\\n            }\\n        }\\n        \\n        assert(max_w_idx != -1);\\n        return max_w_idx;\\n    }\\n    \\n    static void pruneCandidates(vector<vector<int>> &adj, int guess_result, int idx) {\\n        const int N = adj.size();\\n        vector<int> vertices_to_remove(1, idx);\\n        \\n        // IFF the result is zero, we can prune any connecting node with > 0 common letters\\n        // Otherwise, we can prune any connecting node with < guess_result common letters\\n        if (guess_result == 0) {\\n            for (int i = 0; i < N; i++) {\\n                int w = adj[idx][i];\\n                if (w > 0) {\\n                    vertices_to_remove.push_back(i);\\n                }\\n            }\\n        } else {\\n            assert(guess_result >= 0);\\n            for (int i = 0; i < N; i++) {\\n                int w = adj[idx][i];\\n                if (w < guess_result) {\\n                    vertices_to_remove.push_back(i);\\n                }\\n            }\\n        }\\n        \\n        // Mark vertices and connecting edges as invalid if they\\'re on the stack\\n        //cout << \"pruning \";\\n        while(vertices_to_remove.size() > 0) {\\n            int i = vertices_to_remove.back();\\n            vertices_to_remove.pop_back();\\n            //cout << i << \",\";\\n            \\n            // Skip duplicate vertices\\n            if (adj[i][i] < 0) continue;\\n            \\n            // Mark each weight as invalid (-1)\\n            for (int j = 0; j < N; j++) {\\n                adj[i][j] = adj[j][i] = -1;\\n            }\\n        }\\n        //cout << \\'\\\\n\\';\\n    }\\n\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        vector<vector<int>> adj = createAdjacencyMatrix(wordlist);\\n        int guesses = 0;\\n        \\n        while (guesses++ < 10) {\\n            int i = getNextCandidate(adj);\\n            int guess_result = master.guess(wordlist[i]);\\n            //cout << guesses << \": guessing \" << i << \" -> \" << guess_result << \" matching chars\\\\n\";\\n            if (guess_result == 6) {\\n                break;\\n            }\\n            pruneCandidates(adj, guess_result, i);\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {    \\n    //!< O(1) Helper to calculate number of matching characters\\n    static int getNumberMatchingCharacters(const vector<string>& wordlist, int i, int j) {\\n        //!< Size of each word!\\n        static const int K = 6;\\n        \\n        int ret = 0;\\n        for (int k = 0; k < K; k++) {\\n            if (wordlist[i][k] == wordlist[j][k]) {\\n                ret++;\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    //!< O(N^2) Helper for showing the adjacency matrix\\n    static void printAdjacencyMatrix(const vector<vector<int>> &adj) {\\n        for (int i = 0; i < adj.size(); i++) {\\n            cout << i << \": [\";\\n            for (auto w : adj[i]) {\\n                cout << w << \",\";\\n            }\\n            cout << \"]\\\\n\";\\n        }\\n    }\\n    \\n    //!< O(N^2) helper to create the adjacency matrix\\n    //!< adj[i][i] (aka diagonal) maintains the number of connected vertices\\n    static vector<vector<int>> createAdjacencyMatrix(const vector<string>& wordlist) {\\n        const int N = wordlist.size();\\n        vector<vector<int>> adj(N, vector<int>(N));\\n        \\n        // Generate the adjacency matrix\\n        for (int i = 0; i < N; i++) {\\n            for (int j = i+1; j < N; j++) {\\n                adj[i][j] = adj[j][i] = getNumberMatchingCharacters(wordlist, i, j);\\n            }\\n        }\\n        \\n        // Compute value for each vertex - store in diagonal\\n        for (int i = 0; i < N; i++) {\\n\\t\\t    adj[i][i] = 0;\\n            for (int j = 0; j < N; j++) {\\n                if (i == j) continue;\\n                adj[i][i] += adj[i][j];\\n            }\\n        }\\n        \\n        // Some debug info\\n        //cout << \"created adjacency matrix: \\\\n\";\\n        //printAdjacencyMatrix(adj);\\n        \\n        return adj;\\n    }\\n    \\n    static int getNextCandidate(const vector<vector<int>> &adj) {\\n        const int N = adj.size();\\n        \\n        // Simply use the diagonal of the adjacency matrix to determine the \"fattest\" family\\n        // Maybe use a heap here if we are being special, but for now O(N) search.\\n        int max_w_sum = INT_MIN, max_w_idx = -1;\\n        for (int i = 0; i < N; i++) {\\n            if (adj[i][i] > max_w_sum) {\\n                max_w_sum = adj[i][i];\\n                max_w_idx = i;\\n            }\\n        }\\n        \\n        assert(max_w_idx != -1);\\n        return max_w_idx;\\n    }\\n    \\n    static void pruneCandidates(vector<vector<int>> &adj, int guess_result, int idx) {\\n        const int N = adj.size();\\n        vector<int> vertices_to_remove(1, idx);\\n        \\n        // IFF the result is zero, we can prune any connecting node with > 0 common letters\\n        // Otherwise, we can prune any connecting node with < guess_result common letters\\n        if (guess_result == 0) {\\n            for (int i = 0; i < N; i++) {\\n                int w = adj[idx][i];\\n                if (w > 0) {\\n                    vertices_to_remove.push_back(i);\\n                }\\n            }\\n        } else {\\n            assert(guess_result >= 0);\\n            for (int i = 0; i < N; i++) {\\n                int w = adj[idx][i];\\n                if (w < guess_result) {\\n                    vertices_to_remove.push_back(i);\\n                }\\n            }\\n        }\\n        \\n        // Mark vertices and connecting edges as invalid if they\\'re on the stack\\n        //cout << \"pruning \";\\n        while(vertices_to_remove.size() > 0) {\\n            int i = vertices_to_remove.back();\\n            vertices_to_remove.pop_back();\\n            //cout << i << \",\";\\n            \\n            // Skip duplicate vertices\\n            if (adj[i][i] < 0) continue;\\n            \\n            // Mark each weight as invalid (-1)\\n            for (int j = 0; j < N; j++) {\\n                adj[i][j] = adj[j][i] = -1;\\n            }\\n        }\\n        //cout << \\'\\\\n\\';\\n    }\\n\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        vector<vector<int>> adj = createAdjacencyMatrix(wordlist);\\n        int guesses = 0;\\n        \\n        while (guesses++ < 10) {\\n            int i = getNextCandidate(adj);\\n            int guess_result = master.guess(wordlist[i]);\\n            //cout << guesses << \": guessing \" << i << \" -> \" << guess_result << \" matching chars\\\\n\";\\n            if (guess_result == 6) {\\n                break;\\n            }\\n            pruneCandidates(adj, guess_result, i);\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1167415,
                "title": "java-elimination-approach-with-randomization-beats-97",
                "content": "My approach is simple. I pick a random word from ```wordlist```, then, find how many characters match with secret word. If there ```0 matches```, then ```we eliminate all strings which have even 1 character matching with currently picked word.``` If it has a matching count < 6, then ```we pick only those strings which have exactly the same matching characters in same position from wordlist```. \\n\\nThus, with each call to ```guess API```, we ```reduce our set of possibilities by eliminating the obvious strings which can\\'t be secret```.\\n\\nWhy do we pick ```random``` word instead of ```first word``` from ```wordlist``` everytime? The last 2 test-cases on this problem are arranged in such a way that if you always pick first element, it takes more than 10 guesses to reach to secret as the only possibility. Using a ```random``` word everytime distributes this probability and makes the failure chance 1/1000. It can still fail in rare cases where we always pick such a element at random that we eliminate very few possibilities. If we always make worse choice at ```random```, it will cause us to use more than 10 guesses. However, we probably can make an argument at ```on average```, this randomized approach will work. \\n\\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        List<String> words = new ArrayList<>();\\n        for (String word : wordlist) {\\n            words.add(word);\\n        }\\n        \\n        Random random = new Random();\\n        \\n        while (!words.isEmpty()) {\\n            String guessWord = words.get(random.nextInt(words.size()));            \\n            int matchingCharCount = master.guess(guessWord);\\n            \\n            if (matchingCharCount == 6) {\\n                return;\\n            }\\n            \\n            if (matchingCharCount == 0) {\\n                // Remove all strings which have atleast 1 matching character with this guessWord\\n                // since they can\\'t be the secret. Update words list\\n                List<String> wordsToExclude = new ArrayList<>();\\n                for (String word : words) {\\n                    for (int i=0; i<word.length(); i++) {\\n                        if (word.charAt(i) == guessWord.charAt(i)) {\\n                            wordsToExclude.add(word);\\n                            break;\\n                        }\\n                    }\\n                }\\n                \\n                for (String wordToExclude : wordsToExclude) {\\n                    words.remove(wordToExclude);\\n                }\\n            } else {\\n                List<String> list = new ArrayList<>();\\n            \\n                // We know that guessWord contains some wrong characters and some correct characters.\\n                // Find all strings which have exact same matching amount of characters as guessWord\\n                for (String word : words) {\\n                    if (word.equals(guessWord)) {\\n                        continue;\\n                    }\\n\\n                    // How many chars match between word and guessWord?\\n                    int count = 0;\\n                    for (int i=0; i<word.length(); i++) {\\n                        if (word.charAt(i) == guessWord.charAt(i)) {\\n                            count++;\\n                        }\\n                    }\\n\\n                    if (count == matchingCharCount) {\\n                        list.add(word);\\n                    }\\n                }\\n\\t\\t\\t\\t// Our new reduced set of possibilities\\n                words = list;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```wordlist```\n```0 matches```\n```we eliminate all strings which have even 1 character matching with currently picked word.```\n```we pick only those strings which have exactly the same matching characters in same position from wordlist```\n```guess API```\n```reduce our set of possibilities by eliminating the obvious strings which can\\'t be secret```\n```random```\n```first word```\n```wordlist```\n```random```\n```random```\n```on average```\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        List<String> words = new ArrayList<>();\\n        for (String word : wordlist) {\\n            words.add(word);\\n        }\\n        \\n        Random random = new Random();\\n        \\n        while (!words.isEmpty()) {\\n            String guessWord = words.get(random.nextInt(words.size()));            \\n            int matchingCharCount = master.guess(guessWord);\\n            \\n            if (matchingCharCount == 6) {\\n                return;\\n            }\\n            \\n            if (matchingCharCount == 0) {\\n                // Remove all strings which have atleast 1 matching character with this guessWord\\n                // since they can\\'t be the secret. Update words list\\n                List<String> wordsToExclude = new ArrayList<>();\\n                for (String word : words) {\\n                    for (int i=0; i<word.length(); i++) {\\n                        if (word.charAt(i) == guessWord.charAt(i)) {\\n                            wordsToExclude.add(word);\\n                            break;\\n                        }\\n                    }\\n                }\\n                \\n                for (String wordToExclude : wordsToExclude) {\\n                    words.remove(wordToExclude);\\n                }\\n            } else {\\n                List<String> list = new ArrayList<>();\\n            \\n                // We know that guessWord contains some wrong characters and some correct characters.\\n                // Find all strings which have exact same matching amount of characters as guessWord\\n                for (String word : words) {\\n                    if (word.equals(guessWord)) {\\n                        continue;\\n                    }\\n\\n                    // How many chars match between word and guessWord?\\n                    int count = 0;\\n                    for (int i=0; i<word.length(); i++) {\\n                        if (word.charAt(i) == guessWord.charAt(i)) {\\n                            count++;\\n                        }\\n                    }\\n\\n                    if (count == matchingCharCount) {\\n                        list.add(word);\\n                    }\\n                }\\n\\t\\t\\t\\t// Our new reduced set of possibilities\\n                words = list;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075840,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Set<String> candidateWords = new HashSet<>();\\n        candidateWords.addAll(Arrays.asList(wordlist));\\n\\n        while(!candidateWords.isEmpty()) {\\n            final String word = candidateWords.iterator().next();\\n            candidateWords.remove(word);\\n\\n            int similarity = master.guess(word);\\n            if (similarity == 6) {\\n                return;\\n            }\\n            candidateWords.removeIf(w -> getSimilarity(word, w) != similarity);\\n        }\\n    }\\n\\n    private int getSimilarity(String a, String b) {\\n        int result = 0;\\n        for(int i = 0 ; i < 6 ; i++) {\\n            if (a.charAt(i) == b.charAt(i)) {\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Set<String> candidateWords = new HashSet<>();\\n        candidateWords.addAll(Arrays.asList(wordlist));\\n\\n        while(!candidateWords.isEmpty()) {\\n            final String word = candidateWords.iterator().next();\\n            candidateWords.remove(word);\\n\\n            int similarity = master.guess(word);\\n            if (similarity == 6) {\\n                return;\\n            }\\n            candidateWords.removeIf(w -> getSimilarity(word, w) != similarity);\\n        }\\n    }\\n\\n    private int getSimilarity(String a, String b) {\\n        int result = 0;\\n        for(int i = 0 ; i < 6 ; i++) {\\n            if (a.charAt(i) == b.charAt(i)) {\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 622670,
                "title": "simple-solution-and-explanation-beats-99-36-in-time-100-00-in-space",
                "content": "### Explanation\\nThe main idea is around continuously decreasing the `wordlist` to only contain words that would give us better or at least the same number of matches as our previous guesses.\\n\\nFor example, let\\'s consider this input:\\n```\\nsecret: \"apples\"\\nwordlist: [\"aprons\", \"design\", \"apples\", \"apexes\", \"aprils\"]\\n```\\n\\n##### Scenario 1\\n1. We select a random word from our wordlist. Let\\'s say we get \"aprons\".\\n2. We guess this word and `master.guess()` returns 3 because there are 3 matches between \"**ap**ron**s**\" and \"**ap**ple**s**\".\\n3. We then check if we have found the secret word, which would be when we get 6 matches (because the length of each word is 6). If so, we break out of the while loop and have successfully completed the task.\\n4. If we didn\\'t get 6 matches, now we need to filter out the remaining words in our `wordlist`.\\n\\nFilter Function\\nThe filter function will loop through each word in `wordlist` and determine how many character matches there are between the word and the previous word we guessed.\\n\\nFor \"aprons\", the results would be the following:\\n- aprons: 6,\\n- design: 1,\\n- apples: 3,\\n- apexes: 3,\\n- aprils: 4\\n\\nNow we think about what those character match counts mean. \\n- The first word \"aprons\" has a character match of 6 with \"aprons\" and this was the word we originally guessed. We know for sure this is not our secret because we just guessed it and we did not get 6 matches!\\n- The second word \"design\" has a character match of 0 with \"aprons\". This cannot be our secret, because if it was our secret, we would have gotten 3 character matches like we did when we called `master.guess()`. \\n- The third word \"apples\" has a character match of 3 with \"aprons\". This means that it COULD be our secret word. Therefore, we add it to our newWordlist because it is a potential secret word!\\n- The fourth word \"apexes\" has a character match of 3 with \"aprons\". This means that it COULD be our secret word. Therefore, we add it to our newWordlist because it is a potential secret word!\\n- The fifth word \"aprils\" has a character match of 4 with \"aprons\". Therefore, like in the case of \"design\", there is no way this is our secret word.\\n\\nThen we continue guessing on the new wordlist consisting of `[\"apples\", \"apexes\"]` and filtering out words until we find a word that matches the secret.\\n\\n##### Scenario 2\\nNow let\\'s consider another scenario where our random word from the wordlist has -1 matches with the secret.\\n1. We select a random word from our wordlist. Let\\'s say we get \"design\".\\n2. We guess this word and `master.guess()` returns -1 because there are no matches between \"design\" and \"apples\".\\n3. We then check if we have found the secret word, which we have not because we have no character matches with the secret!\\n4. Now we need to filter out the remaining words in our `wordlist`.\\n\\nFilter Function\\nFor \"design\", the results would be the following:\\n- aprons: 0,\\n- design: 6,\\n- apples: 0,\\n- apexes: 0,\\n- aprils: 1\\n\\nNow we think about what those character match counts mean. \\n- The first, third, and fourth words \"aprons\", \"apples\", and \"apexes\" all have character matches of 0 with \"design\". Because they have no matches with \"design\", this means that they COULD have at least 1 match with the secret word. Therefore, we want to keep these words and we add them to our wordlist. \\n- The second word \"design\" has a character match of 6 with \"design\" and this was the word we originally guessed. We know for sure this is not our secret because we just guessed it and we did not get 6 matches! \\n- The fifth word \"aprils\" has a character match of 1 with \"design\". Because it matches \"design\" in 1 location, it definitely cannot be the secret word so we filter it out.\\n\\nTherefore, in the case where our guess returns -1, we only want to continue searching on words that had 0 matches with our guess.\\n\\n### Solution\\n```\\n/**\\n * @param {string[]} wordlist\\n * @param {Master} master\\n * @return {void}\\n */\\nvar findSecretWord = function(wordlist, master) {\\n  // Repeat 10 times\\n  let i = 0;\\n  while (i < 10) {\\n    // Select random word from list\\n    const guess = randomWord(wordlist);\\n    // \"Guess\" it\\n    const matches = master.guess(guess);\\n    // Terminate early if successfully guessed secret\\n    if (matches === 6) {\\n      break;\\n    }\\n    // Filter out remaining words based on matches (we are updating the original wordlist)\\n    wordlist = filter(guess, matches, wordlist);\\n    i++;\\n  }\\n};\\n\\nvar randomWord = function(wordlist) {\\n  return wordlist[Math.floor(Math.random() * wordlist.length)];\\n}\\n\\nvar filter = function(guess, matches, wordlist) {\\n  const newWordlist = [];\\n  for (let word of wordlist) {\\n    let count = 0; // to count number of matches between \\'word\\' and \\'guess\\'\\n    for (let i = 0; i < 6; i++) {\\n      if (word[i] === guess[i]) {\\n        count++;\\n      }\\n    }\\n    if (count === matches || (matches === -1 && count === 0)) {\\n\\t  newWordlist.push(word);\\n    }\\n  }\\n  return newWordlist;\\n}\\n```\\n\\nTime: 44 ms, beats 99.36% of all JavaScript solutions\\nMemory: 34 MB, beats 100.00% of all JavaScript solutions\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nsecret: \"apples\"\\nwordlist: [\"aprons\", \"design\", \"apples\", \"apexes\", \"aprils\"]\\n```\n```\\n/**\\n * @param {string[]} wordlist\\n * @param {Master} master\\n * @return {void}\\n */\\nvar findSecretWord = function(wordlist, master) {\\n  // Repeat 10 times\\n  let i = 0;\\n  while (i < 10) {\\n    // Select random word from list\\n    const guess = randomWord(wordlist);\\n    // \"Guess\" it\\n    const matches = master.guess(guess);\\n    // Terminate early if successfully guessed secret\\n    if (matches === 6) {\\n      break;\\n    }\\n    // Filter out remaining words based on matches (we are updating the original wordlist)\\n    wordlist = filter(guess, matches, wordlist);\\n    i++;\\n  }\\n};\\n\\nvar randomWord = function(wordlist) {\\n  return wordlist[Math.floor(Math.random() * wordlist.length)];\\n}\\n\\nvar filter = function(guess, matches, wordlist) {\\n  const newWordlist = [];\\n  for (let word of wordlist) {\\n    let count = 0; // to count number of matches between \\'word\\' and \\'guess\\'\\n    for (let i = 0; i < 6; i++) {\\n      if (word[i] === guess[i]) {\\n        count++;\\n      }\\n    }\\n    if (count === matches || (matches === -1 && count === 0)) {\\n\\t  newWordlist.push(word);\\n    }\\n  }\\n  return newWordlist;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 471145,
                "title": "java-beat-100-use-double-random-guess-without-using-minmax",
                "content": "The idea is exactly same as one random guess method, as discussed in many other posts. But what I found is, take one random guess it will fail some test cases. Why? Because it reduces the candidate word list too slowly (the filter condition is too weak).\\n\\nSo what I do is do 2 guess each time, then I can reduce the candidate list faster. Why? Because if I take one guess each time, after two loops (two guess), the resultant list is p * p (p<1, suppose p is how much percent each filtering process can do). But if I do two guesses in a row, then what I get is, overlap of two lists (p * 1 and p * 1). This overlap of two lists is smaller than p * p because your 2nd random is taken from the previously bigger list, so it is more \\'random\\', and it is more strict to get an overlap of two lists, compared to do two loops (two guesses, each loop does one guess). This is the reason why this method works!\\n\\nHere are my codes. Beat 100% java.\\n\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        \\n        List<String> candidateList = new ArrayList<>();\\n        Random rand = new Random();\\n        \\n        for (String word : wordlist) {\\n            candidateList.add(word);\\n        }\\n        \\n        for (int i = 0; i < 5; i ++) {\\n            int len = candidateList.size();\\n            String nextGuess = candidateList.get(rand.nextInt(len));\\n            String nextGuess2 = candidateList.get(rand.nextInt(len));\\n            //String nextGuess3 = candidateList.get(rand.nextInt(len));\\n            \\n            int score = master.guess(nextGuess);\\n            int score2 = master.guess(nextGuess2);\\n            //int score3 = master.guess(nextGuess3);\\n            \\n            if (score == 6 || score2 == 6) {\\n                break;\\n            }\\n            \\n            List<String> nextList = new ArrayList<>();\\n            for (String word: candidateList) {\\n                if (match(word, nextGuess) == score && match(word, nextGuess2) == score2) {\\n                    nextList.add(word);\\n                }\\n            }\\n            candidateList = nextList;\\n        }\\n    }\\n    \\n    private int match(String s1, String s2) {\\n        \\n        int score = 0;\\n        for (int i = 0; i < s1.length(); i++) {\\n            if (s1.charAt(i) == s2.charAt(i)) {\\n                score ++;\\n            }\\n        }\\n        return score;\\n    }\\n}",
                "solutionTags": [],
                "code": "The idea is exactly same as one random guess method, as discussed in many other posts. But what I found is, take one random guess it will fail some test cases. Why? Because it reduces the candidate word list too slowly (the filter condition is too weak).\\n\\nSo what I do is do 2 guess each time, then I can reduce the candidate list faster. Why? Because if I take one guess each time, after two loops (two guess), the resultant list is p * p (p<1, suppose p is how much percent each filtering process can do). But if I do two guesses in a row, then what I get is, overlap of two lists (p * 1 and p * 1). This overlap of two lists is smaller than p * p because your 2nd random is taken from the previously bigger list, so it is more \\'random\\', and it is more strict to get an overlap of two lists, compared to do two loops (two guesses, each loop does one guess). This is the reason why this method works!\\n\\nHere are my codes. Beat 100% java.\\n\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        \\n        List<String> candidateList = new ArrayList<>();\\n        Random rand = new Random();\\n        \\n        for (String word : wordlist) {\\n            candidateList.add(word);\\n        }\\n        \\n        for (int i = 0; i < 5; i ++) {\\n            int len = candidateList.size();\\n            String nextGuess = candidateList.get(rand.nextInt(len));\\n            String nextGuess2 = candidateList.get(rand.nextInt(len));\\n            //String nextGuess3 = candidateList.get(rand.nextInt(len));\\n            \\n            int score = master.guess(nextGuess);\\n            int score2 = master.guess(nextGuess2);\\n            //int score3 = master.guess(nextGuess3);\\n            \\n            if (score == 6 || score2 == 6) {\\n                break;\\n            }\\n            \\n            List<String> nextList = new ArrayList<>();\\n            for (String word: candidateList) {\\n                if (match(word, nextGuess) == score && match(word, nextGuess2) == score2) {\\n                    nextList.add(word);\\n                }\\n            }\\n            candidateList = nextList;\\n        }\\n    }\\n    \\n    private int match(String s1, String s2) {\\n        \\n        int score = 0;\\n        for (int i = 0; i < s1.length(); i++) {\\n            if (s1.charAt(i) == s2.charAt(i)) {\\n                score ++;\\n            }\\n        }\\n        return score;\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 446014,
                "title": "very-simple-6-line-python-elimination-solution-32ms",
                "content": "```python3\\nwl = set(wordlist)\\nwhile True:\\n\\tw = next(iter(wl))\\n\\tn = master.guess(w)\\n\\tif n == 6: return\\n\\twl = {ow for ow in wl if len([i for i,c in enumerate(w) if c==ow[i]])==n and ow != w}\\n```\\n\\nGuess a word `w` to get the number of letters it shares with the secret `n`, then remove `w` and all words that do not have `n` letters in common with `w`, repeat until `n == 6`.",
                "solutionTags": [],
                "code": "```python3\\nwl = set(wordlist)\\nwhile True:\\n\\tw = next(iter(wl))\\n\\tn = master.guess(w)\\n\\tif n == 6: return\\n\\twl = {ow for ow in wl if len([i for i,c in enumerate(w) if c==ow[i]])==n and ow != w}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 410311,
                "title": "o-n-solution-top-98-probablistic",
                "content": "Hi Guys, I did this solution which is probabilistic. What are your views?\\n```\\nimport random\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n\\t\\t# This makes use of what we have seen in the past to determine whether we should guess this\\n        def fit(word_dict, target_word):\\n            for word, number in word_dict.items():\\n                temp = 0\\n                for i in range(6):\\n                    if target_word[i] == word[i]:\\n                        temp += 1\\n                if temp != number:\\n                    return False\\n            return True\\n\\t\\t# we do a shuffle so that the target word will on an average case, move to the center\\n        random.shuffle(wordlist)\\n        word_dict = {}\\n\\t\\t# Looping through each word and determining whether we should test it by looking at previous examples\\n        for word in wordlist:\\n            if fit(word_dict, word):\\n                r = master.guess(word)\\n                print(r)\\n                if r == 6:\\n                    return\\n                word_dict[word] = r\\n        return\\n```\\n\\nNot sure if it\\'s the best answer. Shoot me with your views.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport random\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n\\t\\t# This makes use of what we have seen in the past to determine whether we should guess this\\n        def fit(word_dict, target_word):\\n            for word, number in word_dict.items():\\n                temp = 0\\n                for i in range(6):\\n                    if target_word[i] == word[i]:\\n                        temp += 1\\n                if temp != number:\\n                    return False\\n            return True\\n\\t\\t# we do a shuffle so that the target word will on an average case, move to the center\\n        random.shuffle(wordlist)\\n        word_dict = {}\\n\\t\\t# Looping through each word and determining whether we should test it by looking at previous examples\\n        for word in wordlist:\\n            if fit(word_dict, word):\\n                r = master.guess(word)\\n                print(r)\\n                if r == 6:\\n                    return\\n                word_dict[word] = r\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 133943,
                "title": "python-random-solution-with-heuristic-calculations",
                "content": "Each query shrinks the possible space that the secret word lives in.\\nIf it isn\\'t the secret word, we randomly pick our guess from the current reduced space by using space.pop(). \\nA better strategy is using minimax principle to choose the next query: choose the word that minimize the worst case space size.But the computation complexity is higher. \\nIntuitively, the random algorithm should pass with very high probability: \\n  Heuristic argument gives that each time on average we shrink the space by about (25/26)^12 (  with probability (25/26)^6 we will get return 0 (no position and value match) and that is the majority case (other case will be omitted since that doesn\\'t affect the estimated space size much). If we get return 0, the next space consists of all words from the wordlist that doesn\\'t has any value and position match. That is also about (25/26)^6 of the previous size   )\\n\\tThus after 10 guesses, the space size is about 100*(25/26)^120 =0.9\\n\\tHere\\'s the python code:\\n\\t\\n```\\nclass Solution:\\n    def findSecretWord(self, wordlist, master):\\n        \"\"\"\\n        :type wordlist: List[Str]\\n        :type master: Master\\n        :rtype: None\\n        \"\"\"\\n        def helper(str1,str2):\\n            ans=0\\n            for i in range(len(str1)):\\n                if str1[i]==str2[i]:\\n                    ans+=1\\n            return ans\\n        word=wordlist[0]\\n        space=wordlist.copy()\\n        space.remove(word)\\n        test=master.guess(word)\\n        while test!=6:\\n            tmp=set()\\n            for wd in space:\\n                if helper(word,wd)==test:\\n                    tmp.add(wd)\\n            space=tmp\\n            word=space.pop()\\n            test=master.guess(word)\\n```\\n\\t\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findSecretWord(self, wordlist, master):\\n        \"\"\"\\n        :type wordlist: List[Str]\\n        :type master: Master\\n        :rtype: None\\n        \"\"\"\\n        def helper(str1,str2):\\n            ans=0\\n            for i in range(len(str1)):\\n                if str1[i]==str2[i]:\\n                    ans+=1\\n            return ans\\n        word=wordlist[0]\\n        space=wordlist.copy()\\n        space.remove(word)\\n        test=master.guess(word)\\n        while test!=6:\\n            tmp=set()\\n            for wd in space:\\n                if helper(word,wd)==test:\\n                    tmp.add(wd)\\n            space=tmp\\n            word=space.pop()\\n            test=master.guess(word)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489361,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int StringConstrain(const string& a, const string& b){\\n        int equals = 0;\\n        for (int i = 0 ; 6 > i ; i++){\\n            if (a[i] == b[i]){\\n                equals++;\\n            }\\n        }\\n        return equals;\\n    }\\n    void After_Compute(vector<string>& words, const string& guessed, int compute){        \\n        vector<string> new_words;\\n        if (compute == -1) compute = 0;\\n        for (int i = 0 ; words.size() > i ; i++){\\n            if (guessed != words[i]){\\n                if (StringConstrain(words[i], guessed) == compute){\\n                    new_words.push_back(words[i]);\\n                }\\n            }\\n        }\\n        words = new_words;\\n    } \\n    void findSecretWord(vector<string>& words, Master& master) {\\n        int n = words.size();\\n        int curr = 0;\\n        for (int i = 0 ; curr != 6 ; i++){\\n            curr = master.guess(words[words.size() / 2]);\\n            After_Compute(words, words[words.size() / 2], curr);\\n        }\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def findSecretWord(self, words: List[str], master: \\'Master\\') -> None:\\n        freq_at_positions = []\\n        for i in range(6):\\n            pos_count = {}\\n            for word in words:\\n                if (word[i] in pos_count): pos_count[word[i]] += 1\\n                else: pos_count[word[i]] = 1\\n            freq_at_positions.append(pos_count)\\n        \\n        def calc_score(w):\\n            s = 0\\n            for i in range(len(w)):\\n                s += freq_at_positions[i][w[i]]\\n            return s\\n\\n        words.sort(key=lambda word: calc_score(word))\\n\\n        def find_common_sum(w1, w2):\\n            common_sum = 0\\n            for i in range(6):\\n                if (w1[i] == w2[i]): common_sum += 1\\n            return common_sum\\n\\n        while (len(words) > 0):\\n            word = words.pop()\\n            matches = master.guess(word)\\n\\n            if (matches == 6): break\\n            else:\\n                words = [w for w in words if matches == find_common_sum(w, word)]\\n```\\n\\n```Java []\\nclass Solution{\\n\\tpublic void findSecretWord(String[] words, Master master){\\n\\t\\t\\tint last = words.length-1;\\n\\t\\t\\twhile(true){\\n\\t\\t\\t\\tint count = master.guess(words[0]);\\n\\t\\t\\t\\tif(count==6) return;\\n                int i = 1;\\n\\t\\t\\t\\twhile(i <= last){\\n\\t\\t\\t\\t\\tint c = 0;\\n\\t\\t\\t\\t\\tfor(int j = 0; j < 6; j++) if(words[i].charAt(j)==words[0].charAt(j)) c++;\\n\\t\\t\\t\\t\\tif(c!=count) words[i]=words[last--];\\n\\t\\t\\t\\t\\telse i++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\twords[0]=words[last--];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int StringConstrain(const string& a, const string& b){\\n        int equals = 0;\\n        for (int i = 0 ; 6 > i ; i++){\\n            if (a[i] == b[i]){\\n                equals++;\\n            }\\n        }\\n        return equals;\\n    }\\n    void After_Compute(vector<string>& words, const string& guessed, int compute){        \\n        vector<string> new_words;\\n        if (compute == -1) compute = 0;\\n        for (int i = 0 ; words.size() > i ; i++){\\n            if (guessed != words[i]){\\n                if (StringConstrain(words[i], guessed) == compute){\\n                    new_words.push_back(words[i]);\\n                }\\n            }\\n        }\\n        words = new_words;\\n    } \\n    void findSecretWord(vector<string>& words, Master& master) {\\n        int n = words.size();\\n        int curr = 0;\\n        for (int i = 0 ; curr != 6 ; i++){\\n            curr = master.guess(words[words.size() / 2]);\\n            After_Compute(words, words[words.size() / 2], curr);\\n        }\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def findSecretWord(self, words: List[str], master: \\'Master\\') -> None:\\n        freq_at_positions = []\\n        for i in range(6):\\n            pos_count = {}\\n            for word in words:\\n                if (word[i] in pos_count): pos_count[word[i]] += 1\\n                else: pos_count[word[i]] = 1\\n            freq_at_positions.append(pos_count)\\n        \\n        def calc_score(w):\\n            s = 0\\n            for i in range(len(w)):\\n                s += freq_at_positions[i][w[i]]\\n            return s\\n\\n        words.sort(key=lambda word: calc_score(word))\\n\\n        def find_common_sum(w1, w2):\\n            common_sum = 0\\n            for i in range(6):\\n                if (w1[i] == w2[i]): common_sum += 1\\n            return common_sum\\n\\n        while (len(words) > 0):\\n            word = words.pop()\\n            matches = master.guess(word)\\n\\n            if (matches == 6): break\\n            else:\\n                words = [w for w in words if matches == find_common_sum(w, word)]\\n```\n```Java []\\nclass Solution{\\n\\tpublic void findSecretWord(String[] words, Master master){\\n\\t\\t\\tint last = words.length-1;\\n\\t\\t\\twhile(true){\\n\\t\\t\\t\\tint count = master.guess(words[0]);\\n\\t\\t\\t\\tif(count==6) return;\\n                int i = 1;\\n\\t\\t\\t\\twhile(i <= last){\\n\\t\\t\\t\\t\\tint c = 0;\\n\\t\\t\\t\\t\\tfor(int j = 0; j < 6; j++) if(words[i].charAt(j)==words[0].charAt(j)) c++;\\n\\t\\t\\t\\t\\tif(c!=count) words[i]=words[last--];\\n\\t\\t\\t\\t\\telse i++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\twords[0]=words[last--];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074943,
                "title": "random-will-not-always-pass-try-to-eliminate-79-candidates-with-a-non-zero-guess",
                "content": "Randomly picking a word to guess will not always give you a pass in Approach 1. For a 6-letter word, from 0 matching to 6 matching with the secret word, they have different possibilities. 0 matching will have a possibility of (25/26)^6, which is about 79%. If you randomly pick a word with a non-zero guess, you eliminate 79% of the candidates, but if you randomly pick a word with a zero guess, you only eliminate 21% of the candidates and have a higher chance of being stuck in zero guesses for a while. This is for a generic random test case and might be true though for a special test case.\\n\\nThus, the trick in Approach 2 is really to use some sort of a score system to help pick a word with a higher chance to get a non-zero guess. One potential way is to compare each word with other words and let the matching score be the total number of matchings the word with other words. Sort the candidates with the score and get the first element with the highest score to guess. This will be problematic for this type of situation of abcdcd, adeded, bedada, bcdacb, zzzzzz with a secret word of zzzzzz of the lowest matching score.\\n\\nI actually intermittenly get the first and last elememt from the candidate list to try the highest-score element and lowest-score element. This works so far with the given test cases. \\n\\n# Approach 1 with Random Index (NOT always pass)\\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    public void findSecretWord(String[] words, Master master) {\\n\\n        List<String> possible = new ArrayList<>();\\n        for(String word : words) possible.add(word);\\n\\n        while(true) {\\n            int randomIndex = new Random().nextInt(possible.size());\\n            String toCheck = possible.get(randomIndex);\\n            int matchNumber = master.guess(toCheck);\\n            if(matchNumber == 6) return;\\n            possible.remove(toCheck);\\n            List<String> newPossible = new ArrayList<>();\\n            for(int i = 0; i < possible.size() ; i++) {\\n                if(getMatchBtWords(toCheck, possible.get(i)) == matchNumber) newPossible.add(possible.get(i));\\n            }\\n            possible = newPossible;\\n        }\\n    }\\n\\n    private int getMatchBtWords(String s1, String s2) {\\n        int result = 0;\\n        for(int i = 0; i < 6; i++) {\\n            if(s1.charAt(i) == s2.charAt(i)) result++;\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n# Approach 2 with a Score Sheet\\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    public void findSecretWord(String[] words, Master master) {\\n\\n        List<String> possible = new ArrayList<>();\\n        for(String word : words) possible.add(word);\\n\\n        Map<String, Integer> score = new HashMap<>();\\n\\n        for(int i = 0; i < words.length; i++) {\\n            for(int j = i + 1; j < words.length; j++) {\\n                int match = getMatchBtWords(words[i], words[j]);\\n                score.put(words[i], score.getOrDefault(words[i], 0) + match);\\n                score.put(words[j], score.getOrDefault(words[j], 0) + match);\\n            }\\n        }\\n\\n        boolean flag = true;\\n\\n        while(true) {\\n            Collections.sort(possible, (a, b) -> score.get(b) - score.get(a));\\n            String toCheck = \"\";\\n            if(flag) toCheck = possible.get(0);\\n            else toCheck = possible.get(possible.size() - 1);\\n            int matchNumber = master.guess(toCheck);\\n            if(matchNumber == 6) return;\\n            //possible.remove(toCheck);\\n            List<String> newPossible = new ArrayList<>();\\n            for(int i = 0; i < possible.size() ; i++) {\\n                if(getMatchBtWords(toCheck, possible.get(i)) == matchNumber) newPossible.add(possible.get(i));\\n            }\\n            possible = newPossible;\\n            flag = !flag;\\n        }\\n    }\\n\\n    private int getMatchBtWords(String s1, String s2) {\\n        int result = 0;\\n        for(int i = 0; i < 6; i++) {\\n            if(s1.charAt(i) == s2.charAt(i)) result++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    public void findSecretWord(String[] words, Master master) {\\n\\n        List<String> possible = new ArrayList<>();\\n        for(String word : words) possible.add(word);\\n\\n        while(true) {\\n            int randomIndex = new Random().nextInt(possible.size());\\n            String toCheck = possible.get(randomIndex);\\n            int matchNumber = master.guess(toCheck);\\n            if(matchNumber == 6) return;\\n            possible.remove(toCheck);\\n            List<String> newPossible = new ArrayList<>();\\n            for(int i = 0; i < possible.size() ; i++) {\\n                if(getMatchBtWords(toCheck, possible.get(i)) == matchNumber) newPossible.add(possible.get(i));\\n            }\\n            possible = newPossible;\\n        }\\n    }\\n\\n    private int getMatchBtWords(String s1, String s2) {\\n        int result = 0;\\n        for(int i = 0; i < 6; i++) {\\n            if(s1.charAt(i) == s2.charAt(i)) result++;\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    public void findSecretWord(String[] words, Master master) {\\n\\n        List<String> possible = new ArrayList<>();\\n        for(String word : words) possible.add(word);\\n\\n        Map<String, Integer> score = new HashMap<>();\\n\\n        for(int i = 0; i < words.length; i++) {\\n            for(int j = i + 1; j < words.length; j++) {\\n                int match = getMatchBtWords(words[i], words[j]);\\n                score.put(words[i], score.getOrDefault(words[i], 0) + match);\\n                score.put(words[j], score.getOrDefault(words[j], 0) + match);\\n            }\\n        }\\n\\n        boolean flag = true;\\n\\n        while(true) {\\n            Collections.sort(possible, (a, b) -> score.get(b) - score.get(a));\\n            String toCheck = \"\";\\n            if(flag) toCheck = possible.get(0);\\n            else toCheck = possible.get(possible.size() - 1);\\n            int matchNumber = master.guess(toCheck);\\n            if(matchNumber == 6) return;\\n            //possible.remove(toCheck);\\n            List<String> newPossible = new ArrayList<>();\\n            for(int i = 0; i < possible.size() ; i++) {\\n                if(getMatchBtWords(toCheck, possible.get(i)) == matchNumber) newPossible.add(possible.get(i));\\n            }\\n            possible = newPossible;\\n            flag = !flag;\\n        }\\n    }\\n\\n    private int getMatchBtWords(String s1, String s2) {\\n        int result = 0;\\n        for(int i = 0; i < 6; i++) {\\n            if(s1.charAt(i) == s2.charAt(i)) result++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385099,
                "title": "python-solution-with-narrowed-candidates-and-blacklist",
                "content": "*Runtime: 48 ms, faster than 63.16% of Python3 online submissions for Guess the Word.\\nMemory Usage: 14 MB, less than 62.02% of Python3 online submissions for Guess the Word.*\\n\\n1. Narrow the candidates as @qy9Mg did in [How to explain to interviewer - 843. Guess the Word](http://leetcode.com/problems/guess-the-word/discuss/556075/How-to-explain-to-interviewer-843.-Guess-the-Word)\\n2. Create a blacklist for words with matches = 0\\n\\n```\\nclass Solution:\\n    def findSecretWord(self, words: List[str], master: \\'Master\\') -> None:        \\n        k = 1 # for tracing the number of loops\\n        matches = 0\\n        blacklists = [[] for i in range(6)]\\n        \\n        while matches != 6:\\n            n = len(words)\\n            r = random.randint(0, n - 1)\\n            matches = master.guess(words[r])\\n            key = words[r]\\n            # print(k, n, r, matches, key)\\n            \\n            words.pop(r)\\n            \\n            if matches == 0:\\n                for i in range(6):\\n                    blacklists[i].append(key[i])\\n                # print(blacklists)\\n            \\n            elif matches > 0 and matches < 6:\\n                candidates = []\\n                for i in range(n - 1):\\n                    count = 0\\n                    for j in range(6):\\n                        if words[i][j] not in blacklists[j] and words[i][j] == key[j]:\\n                            count += 1\\n                    if count >= matches:\\n                        candidates.append(words[i])\\n                            \\n                words = candidates.copy()\\n                # print(words)\\n            \\n            k += 1\\n```\\n\\nThis problem depends on luck, kind of, lol.\\nIf we find the secret in `k` times and `k` <= `allowedGuesses`, it shows `\"You guessed the secret word correctly.\"`, \\notherwise if `k` >`allowedGuesses`, it shows `\"Either you took too many guesses, or you did not find the secret word.\"`\\n\\nBeginner\\'s solution, please go easy. (\\u25CF\\'\\u25E1\\'\\u25CF)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSecretWord(self, words: List[str], master: \\'Master\\') -> None:        \\n        k = 1 # for tracing the number of loops\\n        matches = 0\\n        blacklists = [[] for i in range(6)]\\n        \\n        while matches != 6:\\n            n = len(words)\\n            r = random.randint(0, n - 1)\\n            matches = master.guess(words[r])\\n            key = words[r]\\n            # print(k, n, r, matches, key)\\n            \\n            words.pop(r)\\n            \\n            if matches == 0:\\n                for i in range(6):\\n                    blacklists[i].append(key[i])\\n                # print(blacklists)\\n            \\n            elif matches > 0 and matches < 6:\\n                candidates = []\\n                for i in range(n - 1):\\n                    count = 0\\n                    for j in range(6):\\n                        if words[i][j] not in blacklists[j] and words[i][j] == key[j]:\\n                            count += 1\\n                    if count >= matches:\\n                        candidates.append(words[i])\\n                            \\n                words = candidates.copy()\\n                # print(words)\\n            \\n            k += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069084,
                "title": "easy-python-99",
                "content": "Intuition:\\nOnce we know the total matching characters,\\nreduce the wordlist to contain only words which\\nhas equal match value against the used word.\\n\\n```\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n      dic = wordlist\\n      for _ in range(10):\\n        word = random.choice(dic)\\n        matches = master.guess(word)\\n        if matches == 6: break  \\n        dic = [w for w in dic \\\\\\n               if w != word and self.guess(word, w) == matches]\\n      \\n    def guess(self, w1, w2):\\n      return sum(1 for c1, c2 in zip(w1,w2) if c1==c2)\\n```\\n\\nNote that this might still fail the online judge on few runs.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n      dic = wordlist\\n      for _ in range(10):\\n        word = random.choice(dic)\\n        matches = master.guess(word)\\n        if matches == 6: break  \\n        dic = [w for w in dic \\\\\\n               if w != word and self.guess(word, w) == matches]\\n      \\n    def guess(self, w1, w2):\\n      return sum(1 for c1, c2 in zip(w1,w2) if c1==c2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046124,
                "title": "beats-99-java-easy-understanding-with-comments-random",
                "content": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Random r = new Random();\\n        List<String> words = new ArrayList<>(Arrays.asList(wordlist));\\n        \\n        for(int i=0;i<10;i++){\\n            int index = r.nextInt(words.size());\\n            String wordGuessed = words.get(index);\\n            int guessValue = master.guess(wordGuessed);\\n            \\n            //lets stop if we have found it\\n            if(guessValue == 6)\\n                return;\\n            \\n            //we are going to find words with same matched char count\\n            List<String> wordsMatched = new ArrayList<>();\\n            \\n            //basically we are going to omit words that have value less than guessValue\\n            //we know what\\'s the guessed word, so lets use that and find all words with same guess value\\n            //and omit the remaining, so probability of finding the secret is high\\n            for(String w: words){\\n                if(findMatches(w,wordGuessed) == guessValue)\\n                    wordsMatched.add(w);\\n            }\\n            \\n            //lets shrink the words list with wordsMatched list\\n            words = new ArrayList<>(wordsMatched);\\n        }\\n    }\\n    \\n    public int findMatches(String s1, String s2){\\n        \\n        int match = 0;\\n        for(int i=0;i<6;i++){\\n            if(s1.charAt(i)==s2.charAt(i))\\n                match++;\\n        }\\n        \\n        return match;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Random r = new Random();\\n        List<String> words = new ArrayList<>(Arrays.asList(wordlist));\\n        \\n        for(int i=0;i<10;i++){\\n            int index = r.nextInt(words.size());\\n            String wordGuessed = words.get(index);\\n            int guessValue = master.guess(wordGuessed);\\n            \\n            //lets stop if we have found it\\n            if(guessValue == 6)\\n                return;\\n            \\n            //we are going to find words with same matched char count\\n            List<String> wordsMatched = new ArrayList<>();\\n            \\n            //basically we are going to omit words that have value less than guessValue\\n            //we know what\\'s the guessed word, so lets use that and find all words with same guess value\\n            //and omit the remaining, so probability of finding the secret is high\\n            for(String w: words){\\n                if(findMatches(w,wordGuessed) == guessValue)\\n                    wordsMatched.add(w);\\n            }\\n            \\n            //lets shrink the words list with wordsMatched list\\n            words = new ArrayList<>(wordsMatched);\\n        }\\n    }\\n    \\n    public int findMatches(String s1, String s2){\\n        \\n        int match = 0;\\n        for(int i=0;i<6;i++){\\n            if(s1.charAt(i)==s2.charAt(i))\\n                match++;\\n        }\\n        \\n        return match;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2035433,
                "title": "c-guess-and-reduce-easy-to-understand",
                "content": "The problem is steering us to guess only words from the WordList, as guessing words outside of it returns no useful information (`-1`)\\n\\nSo the idea is to:\\n* guess a word from the list\\n* get a result between 0 to 6\\n* filter out all the words that cannot be the target\\n* repeat step 1\\n\\nhowever, you will notice this approach will fail the test cases because it\\'ll take too many guesses for some of the cases.\\n\\nso we do a slight improvement:\\n* **score each word from the list based on total number of matching character with other words from the list**\\n* guess word with **top** score\\n* get a result between 0 to 6\\n* filter out all the words that cannot be the target\\n* repeat step 1\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, unordered_map<string, int>> relation;\\n    Master* m;\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        m=&master;\\n        for(int i = 0; i < wordlist.size(); i++){\\n            for(int j = i; j<wordlist.size();j++){\\n                int p = predict_guess_result(wordlist[i], wordlist[j]);\\n                relation[wordlist[i]][wordlist[j]] = p;\\n                relation[wordlist[j]][wordlist[i]] = p;\\n            }\\n        }\\n        reduce(wordlist);\\n    }\\n    \\n    int guess(string s){\\n        auto a = m->guess(s);\\n        return a;\\n    }\\n    \\n    void reduce(vector<string> input){\\n        int max_count = -1;\\n        string max_count_word;\\n        for(auto &a : input){\\n            int counter = 0;\\n            for(auto &b : relation[a]){\\n                counter += b.second;\\n            }\\n            if(counter > max_count){\\n                max_count_word = a;\\n                max_count = counter;\\n            }\\n        }\\n        auto res = guess(max_count_word);\\n        vector<string> next_input;\\n        if(res != 6){\\n            unordered_map<string,int> *this_map = &relation[max_count_word];\\n            \\n            for(auto&a: input){\\n                \\n                if((*this_map)[a] == res){\\n                    next_input.push_back(a);\\n                }\\n            }\\n            reduce(next_input);\\n        }\\n        return;\\n    }\\n    \\n    int predict_guess_result(string &guess, string &target){\\n        int out = 0;\\n        for(int i = 0; i < 6;i++){\\n            if(guess[i] == target[i]){\\n                out++;\\n            }\\n        }\\n        return out;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, unordered_map<string, int>> relation;\\n    Master* m;\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        m=&master;\\n        for(int i = 0; i < wordlist.size(); i++){\\n            for(int j = i; j<wordlist.size();j++){\\n                int p = predict_guess_result(wordlist[i], wordlist[j]);\\n                relation[wordlist[i]][wordlist[j]] = p;\\n                relation[wordlist[j]][wordlist[i]] = p;\\n            }\\n        }\\n        reduce(wordlist);\\n    }\\n    \\n    int guess(string s){\\n        auto a = m->guess(s);\\n        return a;\\n    }\\n    \\n    void reduce(vector<string> input){\\n        int max_count = -1;\\n        string max_count_word;\\n        for(auto &a : input){\\n            int counter = 0;\\n            for(auto &b : relation[a]){\\n                counter += b.second;\\n            }\\n            if(counter > max_count){\\n                max_count_word = a;\\n                max_count = counter;\\n            }\\n        }\\n        auto res = guess(max_count_word);\\n        vector<string> next_input;\\n        if(res != 6){\\n            unordered_map<string,int> *this_map = &relation[max_count_word];\\n            \\n            for(auto&a: input){\\n                \\n                if((*this_map)[a] == res){\\n                    next_input.push_back(a);\\n                }\\n            }\\n            reduce(next_input);\\n        }\\n        return;\\n    }\\n    \\n    int predict_guess_result(string &guess, string &target){\\n        int out = 0;\\n        for(int i = 0; i < 6;i++){\\n            if(guess[i] == target[i]){\\n                out++;\\n            }\\n        }\\n        return out;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005743,
                "title": "python-guess-and-prune",
                "content": "```\\nimport random\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        random.shuffle(wordlist)\\n        while True:\\n            w = wordlist.pop()\\n            g = master.guess(w)\\n            if g == 6: break\\n            wordlist = [wi for wi in wordlist if sum(c == ci for c, ci in zip(w, wi)) == g]\\n```\\nShuffle to fix test cases with lot of words at the end that don\\'t match any characters.",
                "solutionTags": [],
                "code": "```\\nimport random\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        random.shuffle(wordlist)\\n        while True:\\n            w = wordlist.pop()\\n            g = master.guess(w)\\n            if g == 6: break\\n            wordlist = [wi for wi in wordlist if sum(c == ci for c, ci in zip(w, wi)) == g]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729589,
                "title": "java-with-comments",
                "content": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    \\n    public void findSecretWord(String[] wordlist, Master master) {\\n        \\n        Set<String> words = new HashSet<>();\\n        for (String word : wordlist) {\\n           words.add(word);\\n        }\\n        \\n        if (words.size() <= 10) {\\n            // if words size is less than 10, then we can just guess all the words in the list\\n            words.stream().forEach(master::guess);\\n            return;\\n        }\\n        \\n        Set<String> visited = new HashSet<>();\\n        Set<String> partialMatches = new HashSet<>();\\n        \\n        // run max 10 times\\n        for (int i = 10; i >= 0; i--) {\\n                        \\n            for (String word : words) {\\n            \\n                // if there are no partial matches yet, we want to consider the selected word\\n                boolean matched = partialMatches.isEmpty() ? true : false;\\n                \\n                // if there are partial matches, only consider the word if it has at least one character\\n                // in that partial match word list\\n                for (String possibleWord : partialMatches) {\\n                    for (int j = 0; j < possibleWord.length(); j++) {                        \\n                        if (word.charAt(j) == possibleWord.charAt(j)) {\\n                            matched = true;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n                        }\\n                    }\\n                }\\n\\n                // mark the word as visited so we don\\'t guess it again\\n                visited.add(word);\\n\\t\\t\\t\\t\\n                if (!matched) {\\n                    // no character in the selected word matches any char in partial matches.\\n                    continue;\\n                }\\n                \\n                int guess = master.guess(word);\\n\\n                if (guess == 0) {\\n                    // none of the characters matched their positions\\n                    // remove all words for whom these characters are the same place. they won\\'t be our secret anyways\\n                    removeEntries(words, word);\\n                    break;\\n                }\\n                \\n                if (guess != 6) {\\n                    // somes indexes matched. not sure which one. add it to possible matches list\\n                    partialMatches.add(word);\\n                }\\n                \\n                if (guess == 6) {\\n                    // all positions matched\\n                    return;\\n                }\\n            }\\n            \\n            // remove already guessed or unmatched words\\n            words.removeAll(visited);\\n        }\\n        \\n    }\\n    \\n    // remove all words for whom these characters are the same place. they won\\'t be our secret anyways\\n    private void removeEntries(Set<String> words, String removableWord) {\\n        int index = 0;\\n        for (char ch : removableWord.toCharArray()) {\\n            Iterator<String> itr = words.iterator();\\n            while (itr.hasNext()) {\\n                String word = itr.next();\\n                if (word.charAt(index) == ch) {\\n                    itr.remove();\\n                }\\n            }\\n            index++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    \\n    public void findSecretWord(String[] wordlist, Master master) {\\n        \\n        Set<String> words = new HashSet<>();\\n        for (String word : wordlist) {\\n           words.add(word);\\n        }\\n        \\n        if (words.size() <= 10) {\\n            // if words size is less than 10, then we can just guess all the words in the list\\n            words.stream().forEach(master::guess);\\n            return;\\n        }\\n        \\n        Set<String> visited = new HashSet<>();\\n        Set<String> partialMatches = new HashSet<>();\\n        \\n        // run max 10 times\\n        for (int i = 10; i >= 0; i--) {\\n                        \\n            for (String word : words) {\\n            \\n                // if there are no partial matches yet, we want to consider the selected word\\n                boolean matched = partialMatches.isEmpty() ? true : false;\\n                \\n                // if there are partial matches, only consider the word if it has at least one character\\n                // in that partial match word list\\n                for (String possibleWord : partialMatches) {\\n                    for (int j = 0; j < possibleWord.length(); j++) {                        \\n                        if (word.charAt(j) == possibleWord.charAt(j)) {\\n                            matched = true;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n                        }\\n                    }\\n                }\\n\\n                // mark the word as visited so we don\\'t guess it again\\n                visited.add(word);\\n\\t\\t\\t\\t\\n                if (!matched) {\\n                    // no character in the selected word matches any char in partial matches.\\n                    continue;\\n                }\\n                \\n                int guess = master.guess(word);\\n\\n                if (guess == 0) {\\n                    // none of the characters matched their positions\\n                    // remove all words for whom these characters are the same place. they won\\'t be our secret anyways\\n                    removeEntries(words, word);\\n                    break;\\n                }\\n                \\n                if (guess != 6) {\\n                    // somes indexes matched. not sure which one. add it to possible matches list\\n                    partialMatches.add(word);\\n                }\\n                \\n                if (guess == 6) {\\n                    // all positions matched\\n                    return;\\n                }\\n            }\\n            \\n            // remove already guessed or unmatched words\\n            words.removeAll(visited);\\n        }\\n        \\n    }\\n    \\n    // remove all words for whom these characters are the same place. they won\\'t be our secret anyways\\n    private void removeEntries(Set<String> words, String removableWord) {\\n        int index = 0;\\n        for (char ch : removableWord.toCharArray()) {\\n            Iterator<String> itr = words.iterator();\\n            while (itr.hasNext()) {\\n                String word = itr.next();\\n                if (word.charAt(index) == ch) {\\n                    itr.remove();\\n                }\\n            }\\n            index++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693967,
                "title": "python-process-of-elimination-random",
                "content": "```\\n\\nfrom random import randint\\n\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        lookup = {\\n            word: set([ch+str(i) for (i,ch) in enumerate(word)])\\n            for word in wordlist\\n        }\\n\\n        guess, matches = 0, 0\\n        while guess<10 and matches!=6:\\n            pick_idx = randint(0,len(wordlist)-1)\\n            word = wordlist[pick_idx]\\n            matches = master.guess(word)\\n            guess += 1\\n\\n            # Success\\n            if matches==6:\\n                break\\n\\n            rest_of_words = wordlist[:pick_idx]+wordlist[pick_idx+1:]\\n            matching_indices = lambda other: len(lookup[word]&lookup[other])==matches\\n            candidates = list(filter(matching_indices, rest_of_words))\\n            wordlist = candidates\\n```",
                "solutionTags": [],
                "code": "```\\n\\nfrom random import randint\\n\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        lookup = {\\n            word: set([ch+str(i) for (i,ch) in enumerate(word)])\\n            for word in wordlist\\n        }\\n\\n        guess, matches = 0, 0\\n        while guess<10 and matches!=6:\\n            pick_idx = randint(0,len(wordlist)-1)\\n            word = wordlist[pick_idx]\\n            matches = master.guess(word)\\n            guess += 1\\n\\n            # Success\\n            if matches==6:\\n                break\\n\\n            rest_of_words = wordlist[:pick_idx]+wordlist[pick_idx+1:]\\n            matching_indices = lambda other: len(lookup[word]&lookup[other])==matches\\n            candidates = list(filter(matching_indices, rest_of_words))\\n            wordlist = candidates\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678922,
                "title": "simple-cpp-solution-by-guessing-the-best-word-using-character-counts",
                "content": "We can store the character_count at each position and try to take the word having most common characters. So that when we get the matching score for that particular word from the secret word, it will help us eliminate many words as there is more possibility of eliminating other words that do not match the correct score.\\n\\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        while(wordlist.size() > 0) {\\n            string guess_word = getBestWord(wordlist);\\n            int guess_match_score = master.guess(guess_word);\\n            \\n            if(guess_match_score == 6) {\\n                return;\\n            }\\n            \\n            wordlist = eliminateWords(wordlist, guess_word, guess_match_score);\\n        }\\n    }\\n    \\n    string getBestWord(vector<string>& wordlist) {\\n        vector<vector<int>> store_count(6, vector<int>(26, 0));\\n        \\n        for(string word : wordlist) {\\n            for(int i = 0; i < 6; i++) {\\n                store_count[i][word[i] - \\'a\\']++;\\n            }\\n        }\\n        \\n        int best_score = 0;\\n        string best_word = \"\";\\n        \\n        for(string word : wordlist) {\\n            int cur_score = 0;\\n            for(int i = 0; i < 6; i++) {\\n                cur_score += store_count[i][word[i] - \\'a\\'];\\n            }\\n            if(cur_score > best_score) {\\n                best_score = cur_score;\\n                best_word = word;\\n            }\\n        }\\n        return best_word;\\n    }\\n    \\n    vector<string> eliminateWords(vector<string>& wordlist, string guess_word, int guess_match_score) {\\n        vector<string> new_wordlist;\\n        \\n        for(string word: wordlist) {\\n            if(getMatchScore(word, guess_word) == guess_match_score) {\\n                new_wordlist.push_back(word);\\n            }\\n        }\\n        return new_wordlist;\\n    }\\n    \\n    int getMatchScore(string a, string b) {\\n        int match_score = 0;\\n        for(int i = 0; i < 6; i++) {\\n            match_score += (a[i] == b[i]);\\n        }\\n        return match_score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        while(wordlist.size() > 0) {\\n            string guess_word = getBestWord(wordlist);\\n            int guess_match_score = master.guess(guess_word);\\n            \\n            if(guess_match_score == 6) {\\n                return;\\n            }\\n            \\n            wordlist = eliminateWords(wordlist, guess_word, guess_match_score);\\n        }\\n    }\\n    \\n    string getBestWord(vector<string>& wordlist) {\\n        vector<vector<int>> store_count(6, vector<int>(26, 0));\\n        \\n        for(string word : wordlist) {\\n            for(int i = 0; i < 6; i++) {\\n                store_count[i][word[i] - \\'a\\']++;\\n            }\\n        }\\n        \\n        int best_score = 0;\\n        string best_word = \"\";\\n        \\n        for(string word : wordlist) {\\n            int cur_score = 0;\\n            for(int i = 0; i < 6; i++) {\\n                cur_score += store_count[i][word[i] - \\'a\\'];\\n            }\\n            if(cur_score > best_score) {\\n                best_score = cur_score;\\n                best_word = word;\\n            }\\n        }\\n        return best_word;\\n    }\\n    \\n    vector<string> eliminateWords(vector<string>& wordlist, string guess_word, int guess_match_score) {\\n        vector<string> new_wordlist;\\n        \\n        for(string word: wordlist) {\\n            if(getMatchScore(word, guess_word) == guess_match_score) {\\n                new_wordlist.push_back(word);\\n            }\\n        }\\n        return new_wordlist;\\n    }\\n    \\n    int getMatchScore(string a, string b) {\\n        int match_score = 0;\\n        for(int i = 0; i < 6; i++) {\\n            match_score += (a[i] == b[i]);\\n        }\\n        return match_score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552899,
                "title": "reduce-by-hamming-distance-28-ms-faster-than-91-22-14-2-mb-less-than-92-67-python-3",
                "content": "```\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        def hamming_distance(w1: str, w2: str) -> int:\\n            return sum(1 for k in range(6) if w1[k] != w2[k])\\n\\n        current_guess = wordlist[0]\\n        curr_distance = 6 - Master.guess(master, current_guess)\\n        while curr_distance != 0:\\n\\t\\t    # Secret word have <current_distance> form our <current_guess>. \\n\\t\\t\\t# Therefore secret word is one of the words with Hamming distance <current_distance> from our <current_guess>.\\n\\t\\t\\t# So lets delete all other words.\\n            wordlist = [w for w in wordlist if hamming_distance(current_guess, w) == curr_distance]\\n            # current_guess = wordlist.pop(random.randint(0, len(wordlist) - 1))\\n\\t\\t\\t# You sould not use any random. In some random cases \\n\\t\\t\\t# number of guesses may be ecxeed 10, but in next attempt it\\'s not, etc.\\n            current_guess = wordlist.pop()\\n            curr_distance = 6 - Master.guess(master, current_guess)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        def hamming_distance(w1: str, w2: str) -> int:\\n            return sum(1 for k in range(6) if w1[k] != w2[k])\\n\\n        current_guess = wordlist[0]\\n        curr_distance = 6 - Master.guess(master, current_guess)\\n        while curr_distance != 0:\\n\\t\\t    # Secret word have <current_distance> form our <current_guess>. \\n\\t\\t\\t# Therefore secret word is one of the words with Hamming distance <current_distance> from our <current_guess>.\\n\\t\\t\\t# So lets delete all other words.\\n            wordlist = [w for w in wordlist if hamming_distance(current_guess, w) == curr_distance]\\n            # current_guess = wordlist.pop(random.randint(0, len(wordlist) - 1))\\n\\t\\t\\t# You sould not use any random. In some random cases \\n\\t\\t\\t# number of guesses may be ecxeed 10, but in next attempt it\\'s not, etc.\\n            current_guess = wordlist.pop()\\n            curr_distance = 6 - Master.guess(master, current_guess)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1542368,
                "title": "simple-solution-with-explaination-javascript-84",
                "content": "Submit Stats: Language = Javascript\\nRuntime: 72 ms, faster than 84.33% of JavaScript online submissions for Guess the Word.\\nMemory Usage: 38.7 MB, less than 46.27% of JavaScript online submissions for Guess the Word.\\n\\n### Terms:\\n`Guess Score`: gs  (return value of master.gues)\\n`Match Score`: ms ( num of matching char and positions of 2 words, ex: abcdef and abcpqf has match score = 4 )\\n\\nSteps:\\n1. try first word, let say its gs = 3  ( Use master.guess function given by leetcode )\\n2. Only keep words from list, whose ms = 3 only. ( Use match function )\\n3. From the words that are left, choose a random word and repeat step 1 & 2\\nNote: Tried with first word of remaning word it took more than 10 tries\\n\\n### Step 2 explaination\\nExample: \\n- word `abcdef` has guess score of 3, which means 3 positions are correct. say abc are correct positions\\n- Keep words from list whose match score = 3 with `abcdef`\\n- Word `abcdpq` match score with `abcdef` = 4, we will eliminate `abcdpq` as it guess score will never be 6\\n because `abcdpq` has 1 incorrect position\\n- So, all words whose match score with `abcdef` > 3 are eliminated\\n\\n- Word `axxxxx` has match score = 1 with `abcdef`\\n- This should be eliminated as well because master.guess(`axxxxx`) will never be 6\\n- word `axxxxx` is missing atleast 2 correct positions are compared to `abcdef`\\n\\n- Thus, eliminate all words whose match score with `abcdef` not 3\\n\\n## Solution\\n\\n```\\nconst findSecretWord = function (words, master) {\\n  for (let i = 0; i < 10; i++) {\\n    const idx = random(0, words.length - 1);\\n    const word = words[idx];\\n    const score = master.guess(word);\\n    if (score === 6) return true;\\n    else words = words.filter(i => (match(i, word) === score));\\n  }\\n  return false;\\n};\\n\\nconst match = (word1, word2) => {\\n  let score = 0;\\n  for (let i = 0; i < word1.length; i++) {\\n    if (word1[i] === word2[i]) score += 1;\\n  }\\n  return score;\\n};\\n\\nconst random = (min = 0, max = 1) => Math.floor((Math.random() * (max - min + 1)) + min);\\n```",
                "solutionTags": [],
                "code": "```\\nconst findSecretWord = function (words, master) {\\n  for (let i = 0; i < 10; i++) {\\n    const idx = random(0, words.length - 1);\\n    const word = words[idx];\\n    const score = master.guess(word);\\n    if (score === 6) return true;\\n    else words = words.filter(i => (match(i, word) === score));\\n  }\\n  return false;\\n};\\n\\nconst match = (word1, word2) => {\\n  let score = 0;\\n  for (let i = 0; i < word1.length; i++) {\\n    if (word1[i] === word2[i]) score += 1;\\n  }\\n  return score;\\n};\\n\\nconst random = (min = 0, max = 1) => Math.floor((Math.random() * (max - min + 1)) + min);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524911,
                "title": "can-someone-explain-what-this-problem-means",
                "content": "Isn\\'t this problem technically impossible to reliabily guess the word depending on what the wordlist is? For instance if the wordlist is:\\n```\\n        abcdef\\n        bcdefg\\n        cdefgh\\n        defghi\\n        efghij\\n        fghijk\\n        ghijkl\\n        hijklm\\n        ijklmn\\n        jklmno\\n        klmnop\\n        lmnopq\\n        mnopqr\\n        nopqrs\\n        opqrst\\n        pqrstu\\n        qrstuv\\n        rstuvw\\n        stuvwx\\n        tuvwxy\\n        uvwxyz\\n        vwxyza\\n        wxyzab\\n        xyzabc\\n        yzabcd\\n        zabcde\\n```\\nHow can any algorithm reliabily guess the secrect, since any incorrect guess will always return `0`. I clearly don\\'t understand what this problem is asking, can someone explain?",
                "solutionTags": [],
                "code": "```\\n        abcdef\\n        bcdefg\\n        cdefgh\\n        defghi\\n        efghij\\n        fghijk\\n        ghijkl\\n        hijklm\\n        ijklmn\\n        jklmno\\n        klmnop\\n        lmnopq\\n        mnopqr\\n        nopqrs\\n        opqrst\\n        pqrstu\\n        qrstuv\\n        rstuvw\\n        stuvwx\\n        tuvwxy\\n        uvwxyz\\n        vwxyza\\n        wxyzab\\n        xyzabc\\n        yzabcd\\n        zabcde\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1431569,
                "title": "simple-and-short-solution-without-hard-algorithms-python",
                "content": "```\\nfrom random import randint\\nclass Solution:\\n    def create_list(self, w_list, w, n):\\n        sol = []\\n        for x in w_list:\\n            temp = \"\"\\n            for i,y in enumerate(x):\\n                if y == w[i]:\\n                    temp+=y\\n            if len(temp) == n:\\n                sol.append(x)\\n        return sol\\n                               \\n    def findSecretWord(self, wordList: List[str], master: \\'Master\\') -> None:\\n        new_list = wordList \\n        for i in range(10):\\n            value = randint(0, len(new_list)-1)\\n            curr = new_list[value]\\n            n = master.guess(curr)\\n            new_list = self.create_list(new_list, curr, n)\\n            if n == 6:\\n                break\\n```",
                "solutionTags": [],
                "code": "```\\nfrom random import randint\\nclass Solution:\\n    def create_list(self, w_list, w, n):\\n        sol = []\\n        for x in w_list:\\n            temp = \"\"\\n            for i,y in enumerate(x):\\n                if y == w[i]:\\n                    temp+=y\\n            if len(temp) == n:\\n                sol.append(x)\\n        return sol\\n                               \\n    def findSecretWord(self, wordList: List[str], master: \\'Master\\') -> None:\\n        new_list = wordList \\n        for i in range(10):\\n            value = randint(0, len(new_list)-1)\\n            curr = new_list[value]\\n            n = master.guess(curr)\\n            new_list = self.create_list(new_list, curr, n)\\n            if n == 6:\\n                break\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285607,
                "title": "python-fast-straightforward-and-readable-95",
                "content": "```\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        def has_common(word1, word2, n):\\n            return sum(ch1 == ch2 for ch1, ch2 in zip(word1, word2)) == n\\n        \\n        char_score = [Counter([word[i] for word in wordlist]) for i in range(6)]\\n        res = []\\n        for word in wordlist:\\n            score = 0\\n            for i, char in enumerate(word):\\n                score += char_score[i][char]\\n            res.append((word, score))\\n        res.sort(key=lambda x: x[1])\\n        res = [x[0] for x in res]\\n        for i in range(10):\\n            word = res.pop()\\n            \\n            num_corrects = master.guess(word)\\n            res = list(filter(lambda x: has_common(word, x, num_corrects), res))\\n            if len(res) == 0:\\n                return\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        def has_common(word1, word2, n):\\n            return sum(ch1 == ch2 for ch1, ch2 in zip(word1, word2)) == n\\n        \\n        char_score = [Counter([word[i] for word in wordlist]) for i in range(6)]\\n        res = []\\n        for word in wordlist:\\n            score = 0\\n            for i, char in enumerate(word):\\n                score += char_score[i][char]\\n            res.append((word, score))\\n        res.sort(key=lambda x: x[1])\\n        res = [x[0] for x in res]\\n        for i in range(10):\\n            word = res.pop()\\n            \\n            num_corrects = master.guess(word)\\n            res = list(filter(lambda x: has_common(word, x, num_corrects), res))\\n            if len(res) == 0:\\n                return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181278,
                "title": "java-easy-to-understand-always-find-a-smaller-range",
                "content": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        List<String> curList = Arrays.asList(wordlist);\\n        for(int g=0; g<10; g++){\\n            int N = curList.size();\\n            int r = randomNum(0, N-1);\\n            String str = curList.get(r);\\n            int m = master.guess(str);\\n            if(m == 6)\\n                break;\\n            // find a smaller range which inclue the secret \\n            List<String> list = new ArrayList<>();\\n            for(String wd : curList){\\n                if(wd.equals(str)) \\n                    continue;\\n                if(match(str, wd) == m)\\n                    list.add(wd);\\n            }\\n            curList = list;\\n        }\\n    }\\n    \\n    private int match(String s1, String s2){\\n        int count = 0;\\n        for(int i=0; i<6; i++){\\n            if(s1.charAt(i) == s2.charAt(i))\\n                count ++;\\n        }\\n        return count;\\n    }\\n    \\n    private int randomNum(int min, int max){\\n        return (int)(Math.random()*(max-min+1)+min);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        List<String> curList = Arrays.asList(wordlist);\\n        for(int g=0; g<10; g++){\\n            int N = curList.size();\\n            int r = randomNum(0, N-1);\\n            String str = curList.get(r);\\n            int m = master.guess(str);\\n            if(m == 6)\\n                break;\\n            // find a smaller range which inclue the secret \\n            List<String> list = new ArrayList<>();\\n            for(String wd : curList){\\n                if(wd.equals(str)) \\n                    continue;\\n                if(match(str, wd) == m)\\n                    list.add(wd);\\n            }\\n            curList = list;\\n        }\\n    }\\n    \\n    private int match(String s1, String s2){\\n        int count = 0;\\n        for(int i=0; i<6; i++){\\n            if(s1.charAt(i) == s2.charAt(i))\\n                count ++;\\n        }\\n        return count;\\n    }\\n    \\n    private int randomNum(int min, int max){\\n        return (int)(Math.random()*(max-min+1)+min);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1035325,
                "title": "a-c-python-3-solution-easy-to-understand",
                "content": "```\\n        print(\"wordlist = \", wordlist)\\n\\n        def getMatches(w1, w2):\\n            n = len(w1)\\n            res = 0\\n            for i in range(n):\\n                if (w1[i] == w2[i]):\\n                    res += 1\\n\\n            return res\\n\\n        matches = 0\\n        from random import randrange\\n        for i in range(10):\\n            r = randrange(len(wordlist))\\n            print(\"r = \", r)\\n            if (matches == 6):\\n                break\\n\\n            guess = wordlist[r]\\n            print(\"guess = \", guess)\\n            matches = master.guess(guess)\\n            candidates = []\\n            for w in wordlist:\\n                if (matches == getMatches(guess, w)):\\n                    candidates.append(w)\\n\\n            wordlist = candidates\\n\\n```",
                "solutionTags": [],
                "code": "```\\n        print(\"wordlist = \", wordlist)\\n\\n        def getMatches(w1, w2):\\n            n = len(w1)\\n            res = 0\\n            for i in range(n):\\n                if (w1[i] == w2[i]):\\n                    res += 1\\n\\n            return res\\n\\n        matches = 0\\n        from random import randrange\\n        for i in range(10):\\n            r = randrange(len(wordlist))\\n            print(\"r = \", r)\\n            if (matches == 6):\\n                break\\n\\n            guess = wordlist[r]\\n            print(\"guess = \", guess)\\n            matches = master.guess(guess)\\n            candidates = []\\n            for w in wordlist:\\n                if (matches == getMatches(guess, w)):\\n                    candidates.append(w)\\n\\n            wordlist = candidates\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 980099,
                "title": "simple-and-easily-understandable-solution-in-python",
                "content": "The thinking is simple - build a hash map for each word, key is the distance from 1 to 6, value is the set of words that are this distance away from the word. Then each time guessing a word, the set of possible answers will be narrower. Time complicity of constructing the graph is O(n^2), but it passed the tests.\\n\\nExample 1:\\nInput: secret = \"acckzz\", wordlist = [\"acckzz\",\"ccbazz\",\"eiowzz\",\"abcczz\"]\\nThe graph is like this:\\n\\n```\\ngraph = {\\n\\'acckzz\\': \\n\\t{3: {\\'ccbazz\\'}, 2: {\\'eiowzz\\'}, 4: {\\'abcczz\\'}}, \\n\\'ccbazz\\':\\n\\t{3: {\\'acckzz\\'}, 2: {\\'abcczz\\', \\'eiowzz\\'}}, \\n\\'eiowzz\\': \\n\\t{2: {\\'ccbazz\\', \\'abcczz\\', \\'acckzz\\'}}, \\n\\'abcczz\\': \\n\\t{4: {\\'acckzz\\'}, 2: {\\'eiowzz\\', \\'ccbazz\\'}}\\n}\\n```\\n\\nCode:\\n\\n```\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        def get_distance(a,b):\\n            return [a[i]==b[i] for i in range(len(a))].count(True)\\n        \\n        graph = collections.defaultdict(lambda: collections.defaultdict(lambda: set()))\\n        for i in range(len(wordlist)-1):\\n            for j in range(i+1, len(wordlist)):\\n                w1, w2 = wordlist[i], wordlist[j]\\n                distance = get_distance(w1,w2)\\n                graph[w1][distance].add(w2)\\n                graph[w2][distance].add(w1)\\n\\n        possible_words = set(wordlist)\\n        while possible_words:\\n            word = possible_words.pop()\\n            check = master.guess(word)\\n            if check == 6: break\\n            possible_words &= graph[word][check]\\n```",
                "solutionTags": [],
                "code": "```\\ngraph = {\\n\\'acckzz\\': \\n\\t{3: {\\'ccbazz\\'}, 2: {\\'eiowzz\\'}, 4: {\\'abcczz\\'}}, \\n\\'ccbazz\\':\\n\\t{3: {\\'acckzz\\'}, 2: {\\'abcczz\\', \\'eiowzz\\'}}, \\n\\'eiowzz\\': \\n\\t{2: {\\'ccbazz\\', \\'abcczz\\', \\'acckzz\\'}}, \\n\\'abcczz\\': \\n\\t{4: {\\'acckzz\\'}, 2: {\\'eiowzz\\', \\'ccbazz\\'}}\\n}\\n```\n```\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        def get_distance(a,b):\\n            return [a[i]==b[i] for i in range(len(a))].count(True)\\n        \\n        graph = collections.defaultdict(lambda: collections.defaultdict(lambda: set()))\\n        for i in range(len(wordlist)-1):\\n            for j in range(i+1, len(wordlist)):\\n                w1, w2 = wordlist[i], wordlist[j]\\n                distance = get_distance(w1,w2)\\n                graph[w1][distance].add(w2)\\n                graph[w2][distance].add(w1)\\n\\n        possible_words = set(wordlist)\\n        while possible_words:\\n            word = possible_words.pop()\\n            check = master.guess(word)\\n            if check == 6: break\\n            possible_words &= graph[word][check]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972561,
                "title": "simple-c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<string> reduceWordList (int match, string word, vector<string>& wordlist){\\n        vector<string> filterList; \\n        for (string s: wordlist) {\\n            int count = 0;\\n            for (int i = 0; i < word.size(); i++) {\\n                if (word[i] == s[i]) count++;\\n            }\\n            if (count == match) filterList.push_back(s);\\n        }\\n        return filterList;\\n    }\\n    string getCommonWord (vector<string>& wordlist) {\\n        string bestWord; \\n        map<int, map<char, int>> wordfreq;\\n        int bestScore = 0;\\n        for (string s: wordlist) {\\n            for(int i = 0; i < s.size(); i++) {\\n                wordfreq[i][s[i]]++;\\n            }\\n        }\\n        for (string s: wordlist) {\\n            int currentScore = 0;\\n            for (int i = 0; i < s.size(); i++) {\\n                currentScore += wordfreq[i][s[i]];\\n            }\\n            if (currentScore > bestScore) {\\n                bestScore = currentScore;\\n                bestWord = s;\\n            }\\n        }\\n        return bestWord;\\n    }\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        while (!wordlist.empty()) {\\n            string guess_word = getCommonWord(wordlist);\\n            int match = master.guess(guess_word);\\n            if (match == 6) return;\\n            wordlist = reduceWordList(match, guess_word, wordlist);\\n        }\\n        \\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> reduceWordList (int match, string word, vector<string>& wordlist){\\n        vector<string> filterList; \\n        for (string s: wordlist) {\\n            int count = 0;\\n            for (int i = 0; i < word.size(); i++) {\\n                if (word[i] == s[i]) count++;\\n            }\\n            if (count == match) filterList.push_back(s);\\n        }\\n        return filterList;\\n    }\\n    string getCommonWord (vector<string>& wordlist) {\\n        string bestWord; \\n        map<int, map<char, int>> wordfreq;\\n        int bestScore = 0;\\n        for (string s: wordlist) {\\n            for(int i = 0; i < s.size(); i++) {\\n                wordfreq[i][s[i]]++;\\n            }\\n        }\\n        for (string s: wordlist) {\\n            int currentScore = 0;\\n            for (int i = 0; i < s.size(); i++) {\\n                currentScore += wordfreq[i][s[i]];\\n            }\\n            if (currentScore > bestScore) {\\n                bestScore = currentScore;\\n                bestWord = s;\\n            }\\n        }\\n        return bestWord;\\n    }\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        while (!wordlist.empty()) {\\n            string guess_word = getCommonWord(wordlist);\\n            int match = master.guess(guess_word);\\n            if (match == 6) return;\\n            wordlist = reduceWordList(match, guess_word, wordlist);\\n        }\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 925162,
                "title": "python3-greedy-solution-faster-than-98-18-explained",
                "content": "*Runtime: 24 ms, faster than 98.18% of Python3 online submissions for Guess the Word.\\nMemory Usage: 14.1 MB, less than 100.00% of Python3 online submissions for Guess the Word.*\\n\\nThose who have played the fallout series may be familiar with this problem when hacking terminals :D\\n\\nThe intuition is to keep maximizing the information gained after each guess... and somehow transfer it to each word in our search space... for that matter we will have a **score** for each *word* (they all start at 0), then we play **guess who** so we pick the **best candidate** for each guess (the one with the highest score), and based on the response of the **Master** we will update the scores of the candidates... until we have guessed the *secret*\\n\\nTo update the scores after each guess the rules are:\\n\\t- we **compare each word** in the search space with our current **guess**, finding all the common letters (by common I mean same letter same position) everytime we find a common letter we increase the **score** of this word by following: `candidates_score[word] += guess_score`\\n\\t- if our current `guess_score` got **0 hits** this is the best scenario because now we can prune all the words with **common letters** from our search space so we wont consider them again on future updates.\\n\\nThe **eureka** moment here is that the scores keep accumulating after each guess... so eventually we\\'ll keep maximizing the information gained after each guess to elucidate the **best possible choice** :D\\n\\nTime complexity: `O(n)`, Space complexity: `O(n)`\\n```python\\nclass Solution:\\n    def findSecretWord(self, words: List[str], master: \\'Master\\') -> None:\\n        # keep track of the scores of each word, choose the max\\n        candidates_score = {word: 0 for word in words}\\n        # increase the score of all similar words to our guess\\n        def update_score(word: str, guess: str, guess_score: int):\\n            for i in range(len(word)):\\n                if word[i] == guess[i]:\\n                    # guess score == 0? discard all similar candidates\\n                    if not guess_score:\\n                        del(candidates_score[word])\\n                        return\\n                    # update candidate\\'s score\\n                    candidates_score[word] += guess_score\\n        # greedy search of the candidate with the current max score\\n        trials = 0\\n        while candidates_score and trials < 10:\\n            # get the candidate with the max score\\n            _, guess = min([(-score, word) for word, score in candidates_score.items()])\\n            # ask the master for a score\\n            guess_score = master.guess(guess)\\n            # did you do it? what did it cost? ...everything\\n            if guess_score == len(guess):\\n                return\\n            # remove the guess from candidates\\n            del(candidates_score[guess])\\n            # update scores of the current search space\\n            candidates_list = list(candidates_score.keys())\\n            for candidate in candidates_list:\\n                update_score(candidate, guess, guess_score)\\n            trials += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def findSecretWord(self, words: List[str], master: \\'Master\\') -> None:\\n        # keep track of the scores of each word, choose the max\\n        candidates_score = {word: 0 for word in words}\\n        # increase the score of all similar words to our guess\\n        def update_score(word: str, guess: str, guess_score: int):\\n            for i in range(len(word)):\\n                if word[i] == guess[i]:\\n                    # guess score == 0? discard all similar candidates\\n                    if not guess_score:\\n                        del(candidates_score[word])\\n                        return\\n                    # update candidate\\'s score\\n                    candidates_score[word] += guess_score\\n        # greedy search of the candidate with the current max score\\n        trials = 0\\n        while candidates_score and trials < 10:\\n            # get the candidate with the max score\\n            _, guess = min([(-score, word) for word, score in candidates_score.items()])\\n            # ask the master for a score\\n            guess_score = master.guess(guess)\\n            # did you do it? what did it cost? ...everything\\n            if guess_score == len(guess):\\n                return\\n            # remove the guess from candidates\\n            del(candidates_score[guess])\\n            # update scores of the current search space\\n            candidates_list = list(candidates_score.keys())\\n            for candidate in candidates_list:\\n                update_score(candidate, guess, guess_score)\\n            trials += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919510,
                "title": "this-is-a-fallout-3-mini-game-lol",
                "content": "```\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Random seed = new Random();\\n        List<String> holder = new ArrayList<>();\\n        for(String str: wordlist) holder.add(str);\\n        int time = 0;\\n        while(true){\\n            int size = holder.size();\\n            int pick = seed.nextInt(size);\\n            String chosen = holder.get(pick);\\n            int match = master.guess(chosen);\\n            time++;\\n            if(match==6) return;\\n            holder = filter(holder, chosen, match);\\n        }\\n    }\\n    \\n    public List<String> filter(List<String> holder, String str, int match) {\\n        List<String> res = new ArrayList<>();\\n        for(String s: holder) {\\n            int count = 0;\\n            for(int i=0; i<6; i++){\\n                if(s.charAt(i)==str.charAt(i)) count++;\\n            }\\n            if(count==match) res.add(s);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Random seed = new Random();\\n        List<String> holder = new ArrayList<>();\\n        for(String str: wordlist) holder.add(str);\\n        int time = 0;\\n        while(true){\\n            int size = holder.size();\\n            int pick = seed.nextInt(size);\\n            String chosen = holder.get(pick);\\n            int match = master.guess(chosen);\\n            time++;\\n            if(match==6) return;\\n            holder = filter(holder, chosen, match);\\n        }\\n    }\\n    \\n    public List<String> filter(List<String> holder, String str, int match) {\\n        List<String> res = new ArrayList<>();\\n        for(String s: holder) {\\n            int count = 0;\\n            for(int i=0; i<6; i++){\\n                if(s.charAt(i)==str.charAt(i)) count++;\\n            }\\n            if(count==match) res.add(s);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861381,
                "title": "1ms-java-solution-easy-to-understand",
                "content": "I iterate all words and count a score for every word.\\nA word with biggest score becomes a candidate to call master.guess() (and it is deleted it from the next consideration).\\nTo maintain the words score I use int array stats[6][26] (6 - character position, 26 - zero based character code).\\nFor every guess > 0 I add it up to the current score at [pos][char] improving the finding of the next candidate\\nIf guess returns 0 this means it is 100% that any other word with these [pos][char] is not the candidate. Marking it -1, again improving the next candidate.\\n\\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        int[][] stats = new int[6][26];\\n        \\n        Set<String> words = new HashSet(Arrays.asList(wordlist));\\n        \\n        while(true){\\n            String nextWord = nextWord(stats, words);\\n            int matchCnt = master.guess(nextWord);\\n            if(matchCnt == 6)\\n                break;\\n            \\n            storeScore(stats, nextWord, matchCnt);\\n        }\\n    }\\n    \\n    \\n    String nextWord(int[][] stats, Set<String> words){\\n        String nextWord = null;\\n        int maxScore = -1;\\n        \\n        for(String word : words){\\n            int score = calcWordScore(stats, word);\\n            if(score > maxScore){\\n                maxScore = score;\\n                nextWord = word;\\n            }\\n        }\\n        words.remove(nextWord);\\n        return nextWord;\\n    }\\n    \\n    \\n    int calcWordScore(int[][] stats, String word){\\n        int score = 0;\\n        for(int i=0; i<word.length(); i++){\\n            char ch = word.charAt(i);\\n            int chidx = ch - \\'a\\';\\n            \\n            if(stats[i][chidx] == -1)\\n                return -1;\\n            \\n            score += stats[i][chidx];\\n        }\\n        return score;\\n    }\\n    \\n    \\n    void storeScore(int[][] stats, String word, int matchCnt){\\n        for(int i=0; i<word.length(); i++){\\n            char ch = word.charAt(i);\\n            int chidx = ch - \\'a\\';\\n            \\n            if(matchCnt > 0)\\n                stats[i][chidx] += matchCnt;\\n            else\\n                stats[i][chidx] = -1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        int[][] stats = new int[6][26];\\n        \\n        Set<String> words = new HashSet(Arrays.asList(wordlist));\\n        \\n        while(true){\\n            String nextWord = nextWord(stats, words);\\n            int matchCnt = master.guess(nextWord);\\n            if(matchCnt == 6)\\n                break;\\n            \\n            storeScore(stats, nextWord, matchCnt);\\n        }\\n    }\\n    \\n    \\n    String nextWord(int[][] stats, Set<String> words){\\n        String nextWord = null;\\n        int maxScore = -1;\\n        \\n        for(String word : words){\\n            int score = calcWordScore(stats, word);\\n            if(score > maxScore){\\n                maxScore = score;\\n                nextWord = word;\\n            }\\n        }\\n        words.remove(nextWord);\\n        return nextWord;\\n    }\\n    \\n    \\n    int calcWordScore(int[][] stats, String word){\\n        int score = 0;\\n        for(int i=0; i<word.length(); i++){\\n            char ch = word.charAt(i);\\n            int chidx = ch - \\'a\\';\\n            \\n            if(stats[i][chidx] == -1)\\n                return -1;\\n            \\n            score += stats[i][chidx];\\n        }\\n        return score;\\n    }\\n    \\n    \\n    void storeScore(int[][] stats, String word, int matchCnt){\\n        for(int i=0; i<word.length(); i++){\\n            char ch = word.charAt(i);\\n            int chidx = ch - \\'a\\';\\n            \\n            if(matchCnt > 0)\\n                stats[i][chidx] += matchCnt;\\n            else\\n                stats[i][chidx] = -1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801397,
                "title": "java-100",
                "content": "```\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {        \\n        Random r = new Random();\\n        int N = 10;\\n        int len = 6;\\n        \\n        List<String> list = Arrays.asList(wordlist);\\n        List<String> tmp;\\n        while(N>0) {\\n            int i = r.nextInt(list.size());\\n            String candidate1 = list.get(i);\\n            int match1 = master.guess(candidate1);\\n            if (match1 == len) return;\\n            \\n            tmp = new ArrayList<>();\\n            for (int k=0; k<list.size(); k++) {\\n                String s = list.get(k);\\n                if (k!=i && nbMatch(candidate1, s) == match1) {\\n                    tmp.add(s);\\n                }\\n            }\\n            list = tmp;\\n            N -= 1;\\n        }\\n    }\\n    \\n    private int nbMatch(String s1, String s2) {\\n        int count = 0;\\n        for (int i=0; i<s1.length(); i++) {\\n            if (s1.charAt(i) == s2.charAt(i)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {        \\n        Random r = new Random();\\n        int N = 10;\\n        int len = 6;\\n        \\n        List<String> list = Arrays.asList(wordlist);\\n        List<String> tmp;\\n        while(N>0) {\\n            int i = r.nextInt(list.size());\\n            String candidate1 = list.get(i);\\n            int match1 = master.guess(candidate1);\\n            if (match1 == len) return;\\n            \\n            tmp = new ArrayList<>();\\n            for (int k=0; k<list.size(); k++) {\\n                String s = list.get(k);\\n                if (k!=i && nbMatch(candidate1, s) == match1) {\\n                    tmp.add(s);\\n                }\\n            }\\n            list = tmp;\\n            N -= 1;\\n        }\\n    }\\n    \\n    private int nbMatch(String s1, String s2) {\\n        int count = 0;\\n        for (int i=0; i<s1.length(); i++) {\\n            if (s1.charAt(i) == s2.charAt(i)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 705867,
                "title": "heavily-commented-kotlin-port-of-solution",
                "content": "I found the solution very difficult to understand but figured it out after staring at the code for a while (and porting to Kotlin in the process). Here it is, heavily commented to explain what\\'s goin on:\\n\\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     fun guess(word: String): Int {}\\n * }\\n */\\nclass Solution {\\n    fun findSecretWord(wordlist: Array<String>, master: Master) {\\n        val N = wordlist.size\\n        \\n        // Build matrix of how many characters in common each word pair has\\n        // inCommon[i][j] == # common chars in wordlist[i] and wordlist[j]\\n        val inCommon = Array(N) { IntArray(N) }\\n        for (i in 0 until N) {\\n            for (j in 0 until N) {\\n                var count = 0\\n                for (k in 0..5) {\\n                    if (wordlist[i][k] == wordlist[j][k]) {\\n                        ++count\\n                    }\\n                }\\n                inCommon[i][j] = count\\n                inCommon[j][i] = count\\n            }\\n        }\\n        \\n        // All possible words to guess (start with full list)\\n        var possible = (0 until N).toMutableList()\\n        // All words we\\'ve guessed so far\\n        val path = mutableListOf<Int>()\\n        \\n        while (possible.isNotEmpty()) {\\n            val guess = solve(possible, path, inCommon)\\n            val matches = master.guess(wordlist[guess])\\n            \\n            // We\\'ve matched all characters of the secret word. We\\'re done\\n            if (matches == wordlist[0].length) {\\n                return\\n            }\\n            \\n            // Generate next set of possible guesses based on matches to guess\\n            val possible2 = mutableListOf<Int>()\\n            for (j in possible) {\\n                // The only possible words are those with the same number of letters\\n                // in common with our guess as the number matching the secret\\n                if (inCommon[guess][j] == matches) {\\n                    possible2.add(j);\\n                }\\n            }\\n            possible = possible2;\\n            path.add(guess);\\n        }\\n    }\\n       \\n    fun solve(possible: List<Int>, path: List<Int>, inCommon: Array<IntArray>): Int {\\n        // If there\\'s only two possible guesses, just pick the first one, whatever\\n        if (possible.size <= 2) {\\n            return possible[0]\\n        }\\n        \\n        // The minimum max group found so far (see below for details)\\n        var ansgrp = possible\\n        // The guess that minimzed the max group so far\\n        var ansguess = -1\\n\\n        // Iterate through all possible guesses not yet taken\\n        for (guess in 0..inCommon.lastIndex) {\\n            if (guess !in path) {\\n\\n                // Group all possible secrets by how many characters\\n                // they have in common with our potential guess (0..6)\\n                val groups = Array(7) { mutableListOf<Int>() }\\n                for (j in possible) {\\n                    if (j != guess) {\\n                        groups[inCommon[guess][j]].add(j)\\n                    }\\n                }\\n\\n                // Max group is the one with the most possible words (worst case\\n                // words that are still possible if master responds with this count)\\n                val maxgroup = groups.maxBy { it.size }!!\\n\\n                // We want to choose the guess that MINIMIZES this max group size\\n                // (So in the worst case, we can eliminate the most words)\\n                if (maxgroup.size < ansgrp.size) {\\n                    ansgrp = maxgroup\\n                    ansguess = guess\\n                }\\n            }\\n        }\\n\\n        return ansguess;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     fun guess(word: String): Int {}\\n * }\\n */\\nclass Solution {\\n    fun findSecretWord(wordlist: Array<String>, master: Master) {\\n        val N = wordlist.size\\n        \\n        // Build matrix of how many characters in common each word pair has\\n        // inCommon[i][j] == # common chars in wordlist[i] and wordlist[j]\\n        val inCommon = Array(N) { IntArray(N) }\\n        for (i in 0 until N) {\\n            for (j in 0 until N) {\\n                var count = 0\\n                for (k in 0..5) {\\n                    if (wordlist[i][k] == wordlist[j][k]) {\\n                        ++count\\n                    }\\n                }\\n                inCommon[i][j] = count\\n                inCommon[j][i] = count\\n            }\\n        }\\n        \\n        // All possible words to guess (start with full list)\\n        var possible = (0 until N).toMutableList()\\n        // All words we\\'ve guessed so far\\n        val path = mutableListOf<Int>()\\n        \\n        while (possible.isNotEmpty()) {\\n            val guess = solve(possible, path, inCommon)\\n            val matches = master.guess(wordlist[guess])\\n            \\n            // We\\'ve matched all characters of the secret word. We\\'re done\\n            if (matches == wordlist[0].length) {\\n                return\\n            }\\n            \\n            // Generate next set of possible guesses based on matches to guess\\n            val possible2 = mutableListOf<Int>()\\n            for (j in possible) {\\n                // The only possible words are those with the same number of letters\\n                // in common with our guess as the number matching the secret\\n                if (inCommon[guess][j] == matches) {\\n                    possible2.add(j);\\n                }\\n            }\\n            possible = possible2;\\n            path.add(guess);\\n        }\\n    }\\n       \\n    fun solve(possible: List<Int>, path: List<Int>, inCommon: Array<IntArray>): Int {\\n        // If there\\'s only two possible guesses, just pick the first one, whatever\\n        if (possible.size <= 2) {\\n            return possible[0]\\n        }\\n        \\n        // The minimum max group found so far (see below for details)\\n        var ansgrp = possible\\n        // The guess that minimzed the max group so far\\n        var ansguess = -1\\n\\n        // Iterate through all possible guesses not yet taken\\n        for (guess in 0..inCommon.lastIndex) {\\n            if (guess !in path) {\\n\\n                // Group all possible secrets by how many characters\\n                // they have in common with our potential guess (0..6)\\n                val groups = Array(7) { mutableListOf<Int>() }\\n                for (j in possible) {\\n                    if (j != guess) {\\n                        groups[inCommon[guess][j]].add(j)\\n                    }\\n                }\\n\\n                // Max group is the one with the most possible words (worst case\\n                // words that are still possible if master responds with this count)\\n                val maxgroup = groups.maxBy { it.size }!!\\n\\n                // We want to choose the guess that MINIMIZES this max group size\\n                // (So in the worst case, we can eliminate the most words)\\n                if (maxgroup.size < ansgrp.size) {\\n                    ansgrp = maxgroup\\n                    ansguess = guess\\n                }\\n            }\\n        }\\n\\n        return ansguess;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683525,
                "title": "very-straightforward-c-solution",
                "content": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\n\\n/*\\nthe idea is to\\n1. minimize the cases where a guess could fail,\\n2. assume the cases that could fail are words with minimum # of letter matchs with other words in the list\\n\\nmake guess A, with # of matches M\\n\\n3. maximize the change where a guess could be successful\\n4. assume those cases (could be successful) are cases (words in the list) that has M # of matchs with the guess word A \\n*/\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n    ///i will need to make 10 guess myself??!    \\n        int times = 10;\\n        while(times--){\\n        //step1: minimize the failing cases\\n        //here we want to select the word with max # of matchs with other words in the list\\n        unordered_map<string, int> freq;\\n        for(auto& w1 : wordlist){\\n            for(auto& w2 : wordlist){\\n                if(w1 != w2 && match(w1,w2)==0){\\n                    freq[w1]++;\\n                }\\n            }\\n        }\\n        //find the word with minimum freq[word]\\n        int Max = INT_MAX;\\n        string candid = wordlist[0];\\n        for(auto& f: freq){\\n            if(Max >= f.second){\\n                candid = f.first;\\n                Max = f.second;\\n            }\\n        }\\n        //compute the matchs \\n        int x = master.guess(candid);\\n        //build a new word list based the guess result\\n        vector<string> newWordList;\\n        for(auto& w : wordlist){\\n            if(match(w,candid) == x){\\n                newWordList.push_back(w);\\n            }\\n        }\\n\\n        swap(wordlist,newWordList);\\n        }\\n    }\\n    int match(string A, string B){\\n        int count = 0;\\n        int len = A.size();\\n        for(int i = 0; i < len; i++){\\n            if(A[i] == B[i]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n    ///i will need to make 10 guess myself??!    \\n        int times = 10;\\n        while(times--){\\n        //step1: minimize the failing cases\\n        //here we want to select the word with max # of matchs with other words in the list\\n        unordered_map<string, int> freq;\\n        for(auto& w1 : wordlist){\\n            for(auto& w2 : wordlist){\\n                if(w1 != w2 && match(w1,w2)==0){\\n                    freq[w1]++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 603722,
                "title": "python-note-with-explantaions",
                "content": "This is more like a note for me, original idea comes from https://leetcode.com/problems/guess-the-word/discuss/133862/Random-Guess-and-Minimax-Guess-with-Comparison\\n\\n**1. Naive Solution**:\\nWe have at most 10 trials of guesses; at first, we will randomly choose a word to guess. \\n[Why random choose? Because the secret word could be in later part of wordlist, random sample will give us the possibility of 1/len(wordlist) for getting secret word]\\nThen, we use the selected word (`guess`) to `master.guess`, and get mathced number (`match_number`).\\nIn the end, update `wordlist` to be a list that each word only has the same `match_number` with `guess`.\\n```\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        for _ in range(10):\\n            guess = random.choice(wordlist)\\n            match_number = master.guess(guess)\\n            wordlist = [word for word in wordlist if sum([c1 == c2 for c1, c2 in zip(guess, word)]) == match_number]\\n```\\n**Complexity**: Time O(N), Space O(N).\\n\\nHowever, this doesn\\'t gurantee 10 trails will definitely find the secret word. Hence, we need to use the MiniMax solution.\\n\\n**2. MiniMax solution**:\\nGet permutations of `wordlist` that have size 2, and count any item that has zero matched. \\nThen, select `guess` that has the least zero matched with other words in `wordlist`.\\nIn the end, update `wordlist` to be a list that each word only has the same `match_number` with `guess`.\\nLoop will stop when match number between secret word and guess is 6. [Since each word is 6 letters long]\\n```\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        def match(word1, word2):\\n            return sum([c1 == c2 for c1, c2 in zip(word1, word2)])\\n        matched = 0\\n        while matched < 6:\\n            counts = collections.Counter(w1 for w1, w2 in itertools.permutations(wordlist, 2) if match(w1, w2) == 0)\\n            guess = min(wordlist, key=lambda w: counts[w])\\n            matched = master.guess(guess)\\n            wordlist = [w for w in wordlist if match(guess, w) == matched]\\n```\\n**Complexity**: Time O(N^2), Space O(N^2).",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        for _ in range(10):\\n            guess = random.choice(wordlist)\\n            match_number = master.guess(guess)\\n            wordlist = [word for word in wordlist if sum([c1 == c2 for c1, c2 in zip(guess, word)]) == match_number]\\n```\n```\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        def match(word1, word2):\\n            return sum([c1 == c2 for c1, c2 in zip(word1, word2)])\\n        matched = 0\\n        while matched < 6:\\n            counts = collections.Counter(w1 for w1, w2 in itertools.permutations(wordlist, 2) if match(w1, w2) == 0)\\n            guess = min(wordlist, key=lambda w: counts[w])\\n            matched = master.guess(guess)\\n            wordlist = [w for w in wordlist if match(guess, w) == matched]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598388,
                "title": "short-and-clean-java-solution",
                "content": "```\\n\\tpublic void findSecretWord(String[] wordlist, Master master) {\\n\\t\\tList<String> list = new ArrayList<>(Arrays.asList(wordlist));\\n\\n\\t\\tfor (int k = 0; k < 10; k++) {\\n\\t\\t\\tint index = (int) (Math.random() * list.size());\\n\\t\\t\\tString pick = list.get(index);\\n\\t\\t\\tint match = master.guess(pick);\\n\\t\\t\\tif (match == 6) break;\\n\\n\\t\\t\\tList<String> tmp = new ArrayList<>();\\n\\t\\t\\tfor (String s : list) {\\n\\t\\t\\t\\tif (getMatch(s, pick) == match) tmp.add(s);\\n\\t\\t\\t}\\n\\t\\t\\tlist = tmp;\\n\\t\\t}\\n\\t}\\n\\n\\tprivate int getMatch(String s1, String s2) {\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < s1.length(); i++) {\\n\\t\\t\\tif (s1.charAt(i) == s2.charAt(i)) count++;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic void findSecretWord(String[] wordlist, Master master) {\\n\\t\\tList<String> list = new ArrayList<>(Arrays.asList(wordlist));\\n\\n\\t\\tfor (int k = 0; k < 10; k++) {\\n\\t\\t\\tint index = (int) (Math.random() * list.size());\\n\\t\\t\\tString pick = list.get(index);\\n\\t\\t\\tint match = master.guess(pick);\\n\\t\\t\\tif (match == 6) break;\\n\\n\\t\\t\\tList<String> tmp = new ArrayList<>();\\n\\t\\t\\tfor (String s : list) {\\n\\t\\t\\t\\tif (getMatch(s, pick) == match) tmp.add(s);\\n\\t\\t\\t}\\n\\t\\t\\tlist = tmp;\\n\\t\\t}\\n\\t}\\n\\n\\tprivate int getMatch(String s1, String s2) {\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < s1.length(); i++) {\\n\\t\\t\\tif (s1.charAt(i) == s2.charAt(i)) count++;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 559455,
                "title": "python-short-and-fast-solution",
                "content": "```\\nclass Solution:\\n\\n    def computeHammingMatches(self, word1, word2) -> int:\\n        return sum([word1 [i] == word2 [i] for i in range(len(word1))])\\n\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        candidates = set(wordlist)\\n        while candidates:\\n            element = candidates.pop()\\n            matches = master.guess(element)\\n            if matches == 6:\\n                return\\n            candidates = {el for el in candidates if self.computeHammingMatches(element, el) == matches}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\n    def computeHammingMatches(self, word1, word2) -> int:\\n        return sum([word1 [i] == word2 [i] for i in range(len(word1))])\\n\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        candidates = set(wordlist)\\n        while candidates:\\n            element = candidates.pop()\\n            matches = master.guess(element)\\n            if matches == 6:\\n                return\\n            candidates = {el for el in candidates if self.computeHammingMatches(element, el) == matches}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 516478,
                "title": "javascript-short-clear",
                "content": "```\\nconst match = (w1, w2) => {\\n    let c = 0;                                                  // Number of same letters at exact indexes between two words\\n    for(let i=0; i < w1.length; i++){\\n        if(w1[i] == w2[i]){ c++ ;}\\n    }\\n    return c;\\n}\\n\\nconst findSecretWord = (wordlist, master) => {\\n    wordlist.sort();                                             // have to sort\\n    for(let i=0; i < 10; i++){\\n        const word = wordlist[0];\\n        const N = master.guess(word);                            // Number of same letters at exact indexes between selected word and secret.\\n        if(N == 6 ){ return ;}\\n        const temp = wordlist.filter( w => match(w, word) == N);\\n        wordlist = temp;                                        \\n    }  \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst match = (w1, w2) => {\\n    let c = 0;                                                  // Number of same letters at exact indexes between two words\\n    for(let i=0; i < w1.length; i++){\\n        if(w1[i] == w2[i]){ c++ ;}\\n    }\\n    return c;\\n}\\n\\nconst findSecretWord = (wordlist, master) => {\\n    wordlist.sort();                                             // have to sort\\n    for(let i=0; i < 10; i++){\\n        const word = wordlist[0];\\n        const N = master.guess(word);                            // Number of same letters at exact indexes between selected word and secret.\\n        if(N == 6 ){ return ;}\\n        const temp = wordlist.filter( w => match(w, word) == N);\\n        wordlist = temp;                                        \\n    }  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 516376,
                "title": "easy-python-solution-24ms",
                "content": "```\\n\\n\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        check = lambda s1,s2: sum([1 for x,y in zip(s1,s2) if x==y ])\\n        random.seed(1)\\n        while wordlist:\\n            choice = random.choice(wordlist)\\n            num = master.guess(choice)     \\n            wordlist.remove(choice)\\n            wordlist  = [word for word in wordlist if check(choice,word)==num]\\n          \\n            \\n          \\n \\n ```\\n",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        check = lambda s1,s2: sum([1 for x,y in zip(s1,s2) if x==y ])\\n        random.seed(1)\\n        while wordlist:\\n            choice = random.choice(wordlist)\\n            num = master.guess(choice)     \\n            wordlist.remove(choice)\\n            wordlist  = [word for word in wordlist if check(choice,word)==num]\\n          \\n            \\n          \\n \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 509459,
                "title": "beat-100-in-time-and-space-complexity-cpp-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        for (int i = 0, cnt = 0; i < 10 && cnt < 6; ++i) {\\n            string guess = wordlist[rand()  % (wordlist.size())]; // rand()\\n            cnt = master.guess(guess);\\n            for(auto itr = wordlist.begin(); itr != wordlist.end(); itr++)\\n                if (match(guess, *itr) != cnt)  itr = wordlist.erase(itr), itr--;\\n        }\\n    }\\n    int match(string& a, string& b) {\\n        int res = 0, n = a.size();\\n        for (int i = 0; i < n; ++i)  if (a[i] == b[i]) ++res;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        for (int i = 0, cnt = 0; i < 10 && cnt < 6; ++i) {\\n            string guess = wordlist[rand()  % (wordlist.size())]; // rand()\\n            cnt = master.guess(guess);\\n            for(auto itr = wordlist.begin(); itr != wordlist.end(); itr++)\\n                if (match(guess, *itr) != cnt)  itr = wordlist.erase(itr), itr--;\\n        }\\n    }\\n    int match(string& a, string& b) {\\n        int res = 0, n = a.size();\\n        for (int i = 0; i < n; ++i)  if (a[i] == b[i]) ++res;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490153,
                "title": "3-lines-with-golang-because-secret-is-accesible-from-public-no-longer-valid",
                "content": "Following code works because `Master.Secret` is accessible from public. Leetcode should define  like `Master.secret`\\n```\\nfunc findSecretWord(wordlist []string, master *Master) {\\n    master.Guess(master.Secret)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc findSecretWord(wordlist []string, master *Master) {\\n    master.Guess(master.Secret)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 441993,
                "title": "python-solution-using-entropy-instead-of-minimax",
                "content": "Official solution uses the minimax notion (minimize worst-case performance). This solution uses entropy (minimize expected performance).\\n```\\nimport random\\nfrom math import log\\n# \"\"\"\\n# This is Master\\'s API interface.\\n# You should not implement it, or speculate about its implementation\\n# \"\"\"\\n#class Master(object):\\n#    def guess(self, word):\\n#        \"\"\"\\n#        :type word: str\\n#        :rtype int\\n#        \"\"\"\\n\\nclass Solution(object):\\n    def findSecretWord(self, wordlist, master):\\n        \"\"\"\\n        :type wordlist: List[Str]\\n        :type master: Master\\n        :rtype: None\\n        \"\"\"\\n        \\n        current_set = set(wordlist)\\n        while True:\\n            dist_dict = {}\\n            ent_dict = {}\\n            for word in current_set:\\n                dist_dict[word] = {i:set() for i in range(7)}\\n                for word2 in current_set:\\n                    same_counter = 0\\n                    for i in range(6):\\n                        if word[i]==word2[i]:\\n                            same_counter += 1\\n                    dist_dict[word][same_counter].add(word2)\\n                ent = 0.\\n                for i in range(6):\\n                    p = float(len(dist_dict[word][i]))/len(current_set)\\n                    # print(p)\\n                    if p!=0:\\n                        ent -= p * log(p)\\n                ent_dict[word] = ent  \\n            guess_str, count = max([(s,ent_dict[s]) for s in current_set], key=lambda x: x[1])\\n            print(\\'guess {}, ent:{}\\'.format(guess_str, ent_dict[guess_str]))\\n            # guess_str = random.sample(current_set,1)[0]\\n            same_count = master.guess(guess_str)\\n            if same_count == 6:\\n                break\\n            current_set = current_set.intersection(dist_dict[guess_str][same_count])\\n        return\\n                        \\n        ```",
                "solutionTags": [],
                "code": "```\\nimport random\\nfrom math import log\\n# \"\"\"\\n# This is Master\\'s API interface.\\n# You should not implement it, or speculate about its implementation\\n# \"\"\"\\n#class Master(object):\\n#    def guess(self, word):\\n#        \"\"\"\\n#        :type word: str\\n#        :rtype int\\n#        \"\"\"\\n\\nclass Solution(object):\\n    def findSecretWord(self, wordlist, master):\\n        \"\"\"\\n        :type wordlist: List[Str]\\n        :type master: Master\\n        :rtype: None\\n        \"\"\"\\n        \\n        current_set = set(wordlist)\\n        while True:\\n            dist_dict = {}\\n            ent_dict = {}\\n            for word in current_set:\\n                dist_dict[word] = {i:set() for i in range(7)}\\n                for word2 in current_set:\\n                    same_counter = 0\\n                    for i in range(6):\\n                        if word[i]==word2[i]:\\n                            same_counter += 1\\n                    dist_dict[word][same_counter].add(word2)\\n                ent = 0.\\n                for i in range(6):\\n                    p = float(len(dist_dict[word][i]))/len(current_set)\\n                    # print(p)\\n                    if p!=0:\\n                        ent -= p * log(p)\\n                ent_dict[word] = ent  \\n            guess_str, count = max([(s,ent_dict[s]) for s in current_set], key=lambda x: x[1])\\n            print(\\'guess {}, ent:{}\\'.format(guess_str, ent_dict[guess_str]))\\n            # guess_str = random.sample(current_set,1)[0]\\n            same_count = master.guess(guess_str)\\n            if same_count == 6:\\n                break\\n            current_set = current_set.intersection(dist_dict[guess_str][same_count])\\n        return\\n                        \\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 404166,
                "title": "straight-forward-java-solution-with-explanation-beats-99",
                "content": "The idea is that after making a guess, the candidates that can be the secret must have the same number of matches with the guessed word as what is returned by master.guess(). \\n\\nSo, by filtering out words that do not have the same number of matches, we can shrink the candidate list tremendously (5/6 on average) by each guess. \\n\\nIt doesn\\'t really matter how we pick our guess among the possible choices. Do it randomly, or just pick the first one. No need to be smart like the suggested solution to find the min of max groups. \\n\\n```\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        if (wordlist == null || wordlist.length == 0) {\\n            return;\\n        }\\n        \\n        int n = wordlist.length;\\n        int l = wordlist[0].length();\\n        int[][] f = new int[n][n];\\n        \\n        Set<Integer> possible = new HashSet<>();\\n        for (int i = 0; i < n; i++) {\\n            possible.add(i);\\n        }\\n        while (!possible.isEmpty()) {\\n\\t\\t\\t// pick the first word in the set brainlessly\\n            Iterator<Integer> iterator = possible.iterator();\\n            int choice = iterator.next();\\n\\t\\t\\t\\n            int matches = master.guess(wordlist[choice]);\\n            if (matches == l) { // we found the match!\\n                return;\\n            }\\n            Set<Integer> possible2 = new HashSet<>();\\n            for (int i = 0; i < n; i++) {\\n\\t\\t\\t\\t// This is the key!\\n\\t\\t\\t\\t// Candidates are among the words that have the same number of matches with the guessed word as the returned matches\\n\\t\\t\\t\\t// And candidates must be among the list (set) of candidates remained from previous guesses\\n                if (countMatches(wordlist[choice], wordlist[i]) == matches && possible.contains(i)) {\\n                    possible2.add(i);\\n                }\\n            }\\n            possible = possible2;\\n        }\\n    }\\n    \\n    private int countMatches(String word1, String word2) {\\n        int l = word1.length();\\n        int matches = 0;\\n        for (int k = 0; k < l; k++) {\\n            if (word1.charAt(k) == word2.charAt(k)) {\\n                matches++;\\n            }\\n        }\\n        return matches;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        if (wordlist == null || wordlist.length == 0) {\\n            return;\\n        }\\n        \\n        int n = wordlist.length;\\n        int l = wordlist[0].length();\\n        int[][] f = new int[n][n];\\n        \\n        Set<Integer> possible = new HashSet<>();\\n        for (int i = 0; i < n; i++) {\\n            possible.add(i);\\n        }\\n        while (!possible.isEmpty()) {\\n\\t\\t\\t// pick the first word in the set brainlessly\\n            Iterator<Integer> iterator = possible.iterator();\\n            int choice = iterator.next();\\n\\t\\t\\t\\n            int matches = master.guess(wordlist[choice]);\\n            if (matches == l) { // we found the match!\\n                return;\\n            }\\n            Set<Integer> possible2 = new HashSet<>();\\n            for (int i = 0; i < n; i++) {\\n\\t\\t\\t\\t// This is the key!\\n\\t\\t\\t\\t// Candidates are among the words that have the same number of matches with the guessed word as the returned matches\\n\\t\\t\\t\\t// And candidates must be among the list (set) of candidates remained from previous guesses\\n                if (countMatches(wordlist[choice], wordlist[i]) == matches && possible.contains(i)) {\\n                    possible2.add(i);\\n                }\\n            }\\n            possible = possible2;\\n        }\\n    }\\n    \\n    private int countMatches(String word1, String word2) {\\n        int l = word1.length();\\n        int matches = 0;\\n        for (int k = 0; k < l; k++) {\\n            if (word1.charAt(k) == word2.charAt(k)) {\\n                matches++;\\n            }\\n        }\\n        return matches;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 298418,
                "title": "simple-heuristic-python-solution",
                "content": "All credits goes to https://www.youtube.com/watch?v=85pkve4pxTI. Video explains the algo nicely.\\n\\nIdea is to create new wordlist after every guess. \\nOnly add word in the new wordlist if no. of character match in last guessed word and cur word == return value received from master. Basically return value from master suggests no. of character match between secret and a word, we atleast want to preserve that many character matches to reach to a word that is a secret word.\\n\\n\\n```\\nclass Solution(object):\\n    def findSecretWord(self, wordlist, master):\\n        \"\"\"\\n        :type wordlist: List[Str]\\n        :type master: Master\\n        :rtype: None\\n        \"\"\"\\n        def removeWord(wordlist, guessedword, returnvalue):\\n            newlist = []\\n            \\n            for word in wordlist:\\n                matched = 0\\n                for i in range(6):\\n                    if word[i] == guessedword[i]:\\n                        matched += 1\\n                if matched == returnvalue or (matched == 0 and returnvalue == -1):\\n                    newlist.append(word)\\n                    \\n            return newlist\\n        \\n        import random\\n        for i in range(10):\\n            word = random.choice(wordlist)\\n            ret = master.guess(word)\\n            wordlist = removeWord(wordlist, word, ret)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findSecretWord(self, wordlist, master):\\n        \"\"\"\\n        :type wordlist: List[Str]\\n        :type master: Master\\n        :rtype: None\\n        \"\"\"\\n        def removeWord(wordlist, guessedword, returnvalue):\\n            newlist = []\\n            \\n            for word in wordlist:\\n                matched = 0\\n                for i in range(6):\\n                    if word[i] == guessedword[i]:\\n                        matched += 1\\n                if matched == returnvalue or (matched == 0 and returnvalue == -1):\\n                    newlist.append(word)\\n                    \\n            return newlist\\n        \\n        import random\\n        for i in range(10):\\n            word = random.choice(wordlist)\\n            ret = master.guess(word)\\n            wordlist = removeWord(wordlist, word, ret)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 289340,
                "title": "java-faster-than-100-with-full-explanation",
                "content": "```\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        int guess = -1;\\n        List<String> workList = new ArrayList();\\n        //sort word list for better guess + put it in a List\\n        Arrays.sort(wordlist);\\n        for(int i =0; i < wordlist.length; i ++){\\n            workList.add(wordlist[i]);\\n        }\\n        //If the worklist is empty we dont need to do anything, else we can directly get the one at 0 (being the first)\\n        if(!workList.isEmpty()) {\\n            //We try 10 times, however we stop once we have guess = 6 (Because it\\'s bingo)\\n            for(int i =0; i < 10 && guess!=6; i ++){\\n                //get the score of the first element\\n                guess = master.guess(workList.get(0));         \\n                //update the worklist by filtering it to only possible candidates\\n                workList = getLeftCandidates(workList, workList.get(0), guess);\\n            }   \\n        }\\n    }\\n    \\n    //to filter we make sure that the score we currently got matches with the elements remaining, since the master is comparing it with the secret word, we only want to keep the elements that are possible candidates to be the secret word. Helper method characterScore is used to identify the score (as per the description of the problem)\\n    private List getLeftCandidates(List<String> wordList, String str, int guess){\\n        List<String> toReturn = new ArrayList();\\n        for(String word: wordList){            \\n            if(characterScore(word,str)==guess){\\n                toReturn.add(word);\\n            }\\n        }\\n        return toReturn;\\n    }\\n    \\n    //Simple method, with for loop to 6 (since length is known) count the number of character matching on value and position, that between two words. Will be used with the word we got the guess score from master of and the words we are trying to filter\\n    private int characterScore(String word1, String word2){\\n        int count = 0; \\n        for(int i=0;i<6;i++){\\n            if(word1.charAt(i)==word2.charAt(i)){\\n                count ++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        int guess = -1;\\n        List<String> workList = new ArrayList();\\n        //sort word list for better guess + put it in a List\\n        Arrays.sort(wordlist);\\n        for(int i =0; i < wordlist.length; i ++){\\n            workList.add(wordlist[i]);\\n        }\\n        //If the worklist is empty we dont need to do anything, else we can directly get the one at 0 (being the first)\\n        if(!workList.isEmpty()) {\\n            //We try 10 times, however we stop once we have guess = 6 (Because it\\'s bingo)\\n            for(int i =0; i < 10 && guess!=6; i ++){\\n                //get the score of the first element\\n                guess = master.guess(workList.get(0));         \\n                //update the worklist by filtering it to only possible candidates\\n                workList = getLeftCandidates(workList, workList.get(0), guess);\\n            }   \\n        }\\n    }\\n    \\n    //to filter we make sure that the score we currently got matches with the elements remaining, since the master is comparing it with the secret word, we only want to keep the elements that are possible candidates to be the secret word. Helper method characterScore is used to identify the score (as per the description of the problem)\\n    private List getLeftCandidates(List<String> wordList, String str, int guess){\\n        List<String> toReturn = new ArrayList();\\n        for(String word: wordList){            \\n            if(characterScore(word,str)==guess){\\n                toReturn.add(word);\\n            }\\n        }\\n        return toReturn;\\n    }\\n    \\n    //Simple method, with for loop to 6 (since length is known) count the number of character matching on value and position, that between two words. Will be used with the word we got the guess score from master of and the words we are trying to filter\\n    private int characterScore(String word1, String word2){\\n        int count = 0; \\n        for(int i=0;i<6;i++){\\n            if(word1.charAt(i)==word2.charAt(i)){\\n                count ++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283166,
                "title": "swift-i-keep-getting-a-compile-error",
                "content": "Even if I do something as simple as this I get a compile Error\\n```\\nclass Solution {\\n    func findSecretWord(_ wordlist: [String], _ master: Master) {\\n        print(master.guess(\"abcczz\"))\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func findSecretWord(_ wordlist: [String], _ master: Master) {\\n        print(master.guess(\"abcczz\"))\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158162,
                "title": "python-use-math-probability-to-find-the-best-guess",
                "content": "The main idea is to choose the word from `wordlist` that can **exclude as many words as possible**. We can use probability to find the word with **maximum expectation of number of words to exclude**.\\n\\nThe expectation can be get from `sum(prob(w, key, k) * num(word, wordset) for k in range(7))`, where `prob(w, key, k)` is the **probability of word `w` and `key` has `k` overlap**; and `num(word, wordset)` is the number of words in wordlist(not including `w`) that **doesnt have** `k` overlap with word `w`(**i.e. words to exclude if guess output is `k`**),  this can be easily found by a loop and compare. \\n\\nSuppose all letters are generated from random and each word is of length 6, then the probability of word `w1` and word ` key` has `k` overlap is `p = 6Ck * (1/26)^k * (25/26)^(n-k)`. Code below is used to get this probability in python\\n```\\n    def probOfMatchN(n):\\n        def nCr(n, r):\\n            f = factorial\\n            return f(n) / f(r) / f(n - r)\\n        return nCr(6, n) * ((1/26) ** n) * ((25/26) ** (6 - n))\\n```\\n\\nAfter we get the expectations, we can write a function that takes word candidates as input and the best word to guess as output:\\n```\\n    def exactMatch(self, s1, s2):\\n\\t\\t\\t\\tif (s1, s2) not in self.memo:\\n            self.memo[(s1, s2)] = sum(s1[i] == s2[i] for i in range(len(s1)))\\n        return self.memo[(s1, s2)]\\n\\n    def findFirst(self, words):\\n        expectation = [0] * len(words)\\n        for k, prob in enumerate(self.probs):\\n            for i, w1 in enumerate(words):\\n                for j, w2 in enumerate(words[i + 1:]):\\n                    if self.exactMatch(w1, w2) != k:\\n                        expectation[i] += prob\\n                        expectation[i + 1 + j] += prob\\n        return expectation.index(max(expectation))\\n```\\n\\n**For instance**, if `word = [\"112\", \"221\", \"212\", \"cba\", \"abc\"]`, then the expectations is `[1.61, 1.44, 2.21, 1.44, 1.44]`, thus we take `\"212\"` as guess input **because \"212\" is expected to exclude `2.21` words not including itself from the word list**\\n \\n\\nIn addition, the probability of different numbers of overlaping is independent for words, which means we can get and store the probability in advance and hardcode it in our solution:\\n```\\nprobs = [0.79, 0.19, 0.019, 0.001, 0.0003, 0.0005]\\n```\\n\\nWe can also just use one probability to do the guess(always assume the guess has 0 machtes) to speed up the algorithm.(also Accepted)\\n```\\nprobs = [0.79]\\n```\\n\\n\\nThe complete code (**including the Master class for debuging purpose**) is here:\\n```\\nclass Master:\\n\\n    def __init__(self, key):\\n        self.key = key\\n\\n    def guess(self, s1):\\n        return sum(s1[i] == s2[i] for i in range(len(s1)))\\n\\nfrom math import factorial\\nclass Solution:\\n\\n    def __init__(self):\\n        self.memo = {}\\n        self.probs = [0.79, 0.19, 0.019, 0.001, 0.0003, 0.0005]\\n\\n    def exactMatch(self, s1, s2):\\n         if (s1, s2) not in self.memo:\\n            self.memo[(s1, s2)] = sum(s1[i] == s2[i] for i in range(len(s1)))\\n        return self.memo[(s1, s2)]\\n\\n    def findFirst(self, words):\\n        expectation = [0] * len(words)\\n        for k, prob in enumerate(self.probs):\\n            for i, w1 in enumerate(words):\\n                for j, w2 in enumerate(words[i + 1:]):\\n                    if self.exactMatch(w1, w2) != k:\\n                        expectation[i] += prob\\n                        expectation[i + 1 + j] += prob\\n        return expectation.index(max(expectation))\\n\\n    def findSecretWord(self, wordlist, master):\\n        \"\"\"\\n        :type wordlist: List[Str]\\n        :type master: Master\\n        :rtype: None\\n        \"\"\"\\n        check = wordlist.copy()\\n        while check:\\n            _check = []\\n            lookup = self.findFirst(check)\\n            sample = check[lookup]\\n            del check[lookup]\\n            overlap = master.guess(sample)\\n            if overlap == 0: # no single common letter\\n                for s in check:\\n                    if not self.exactMatch(s, sample):\\n                        _check.append(s)\\n            elif overlap == len(sample): # found\\n                return sample\\n            else: # partly matched\\n                for s in check:\\n                    if self.exactMatch(s, sample) == overlap:\\n                        _check.append(s)\\n        return -1\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n    def probOfMatchN(n):\\n        def nCr(n, r):\\n            f = factorial\\n            return f(n) / f(r) / f(n - r)\\n        return nCr(6, n) * ((1/26) ** n) * ((25/26) ** (6 - n))\\n```\n```\\n    def exactMatch(self, s1, s2):\\n\\t\\t\\t\\tif (s1, s2) not in self.memo:\\n            self.memo[(s1, s2)] = sum(s1[i] == s2[i] for i in range(len(s1)))\\n        return self.memo[(s1, s2)]\\n\\n    def findFirst(self, words):\\n        expectation = [0] * len(words)\\n        for k, prob in enumerate(self.probs):\\n            for i, w1 in enumerate(words):\\n                for j, w2 in enumerate(words[i + 1:]):\\n                    if self.exactMatch(w1, w2) != k:\\n                        expectation[i] += prob\\n                        expectation[i + 1 + j] += prob\\n        return expectation.index(max(expectation))\\n```\n```\\nprobs = [0.79, 0.19, 0.019, 0.001, 0.0003, 0.0005]\\n```\n```\\nprobs = [0.79]\\n```\n```\\nclass Master:\\n\\n    def __init__(self, key):\\n        self.key = key\\n\\n    def guess(self, s1):\\n        return sum(s1[i] == s2[i] for i in range(len(s1)))\\n\\nfrom math import factorial\\nclass Solution:\\n\\n    def __init__(self):\\n        self.memo = {}\\n        self.probs = [0.79, 0.19, 0.019, 0.001, 0.0003, 0.0005]\\n\\n    def exactMatch(self, s1, s2):\\n         if (s1, s2) not in self.memo:\\n            self.memo[(s1, s2)] = sum(s1[i] == s2[i] for i in range(len(s1)))\\n        return self.memo[(s1, s2)]\\n\\n    def findFirst(self, words):\\n        expectation = [0] * len(words)\\n        for k, prob in enumerate(self.probs):\\n            for i, w1 in enumerate(words):\\n                for j, w2 in enumerate(words[i + 1:]):\\n                    if self.exactMatch(w1, w2) != k:\\n                        expectation[i] += prob\\n                        expectation[i + 1 + j] += prob\\n        return expectation.index(max(expectation))\\n\\n    def findSecretWord(self, wordlist, master):\\n        \"\"\"\\n        :type wordlist: List[Str]\\n        :type master: Master\\n        :rtype: None\\n        \"\"\"\\n        check = wordlist.copy()\\n        while check:\\n            _check = []\\n            lookup = self.findFirst(check)\\n            sample = check[lookup]\\n            del check[lookup]\\n            overlap = master.guess(sample)\\n            if overlap == 0: # no single common letter\\n                for s in check:\\n                    if not self.exactMatch(s, sample):\\n                        _check.append(s)\\n            elif overlap == len(sample): # found\\n                return sample\\n            else: # partly matched\\n                for s in check:\\n                    if self.exactMatch(s, sample) == overlap:\\n                        _check.append(s)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 134424,
                "title": "javascript-solution",
                "content": "https://github.com/dva22/leetcode/blob/master/problems/843.%20Guess%20the%20Word/index.js\\n```\\nvar findSecretWord = module.exports = function(wordlist, master) {\\n        wordlist.sort();\\n        lst = [];\\n        for (let i = 0; i < wordlist.length; ++i)\\n            lst.push(wordlist[i]);\\n        for (let i = 0; i < 10; ++i) {\\n            let r = master.guess(lst[0]);\\n            if (r == 6) return;\\n            newList = [];\\n            for (let j = 1; j < lst.length; ++j) {\\n                let ct = 0;\\n                for (let k = 0; k < 6; ++k) {\\n                    if (lst[j].charAt(k) == lst[0].charAt(k)) {\\n                        ct ++;\\n                    }\\n                }\\n                if (ct == r) {\\n                    newList.push(lst[j]);\\n                }\\n            }\\n            lst = newList;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findSecretWord = module.exports = function(wordlist, master) {\\n        wordlist.sort();\\n        lst = [];\\n        for (let i = 0; i < wordlist.length; ++i)\\n            lst.push(wordlist[i]);\\n        for (let i = 0; i < 10; ++i) {\\n            let r = master.guess(lst[0]);\\n            if (r == 6) return;\\n            newList = [];\\n            for (let j = 1; j < lst.length; ++j) {\\n                let ct = 0;\\n                for (let k = 0; k < 6; ++k) {\\n                    if (lst[j].charAt(k) == lst[0].charAt(k)) {\\n                        ct ++;\\n                    }\\n                }\\n                if (ct == r) {\\n                    newList.push(lst[j]);\\n                }\\n            }\\n            lst = newList;\\n        }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 133859,
                "title": "python-solution-using-sets",
                "content": " Given the `wordlist = [\"acckzz\",\"ccbazz\",\"eiowzz\",\"abcczz\"]`, we can compute the pair-wise number of common chars as follows.\\n \\n `graph` in this example input:\\n (\\'acckzz\\', {0: set([]), 1: set([]), 2: set([2]), 3: set([1]), 4: set([3]), 5: set([]), 6: set([])})\\n (\\'ccbazz\\', {0: set([]), 1: set([]), 2: set([2, 3]), 3: set([0]), 4: set([]), 5: set([]), 6: set([])})\\n (\\'eiowzz\\', {0: set([]), 1: set([]), 2: set([0, 1, 3]), 3: set([]), 4: set([]), 5: set([]), 6: set([])})\\n (\\'abcczz\\', {0: set([]), 1: set([]), 2: set([1, 2]), 3: set([]), 4: set([0]), 5: set([]), 6: set([])})\\n\\n So, if `master.guess(\"eiowzz\")` returns 2, we know the secret must be inside the `graph[\\'eiowzz\\'][2]=set([0, 1, 3])`\\n say, we pick `wordlist[1]` now, `master.guess(\"ccbazz\")` returns 3, we know the secret must be inside the set([0]).\\n the next guess returns the sercet, and we stop.\\n\\n \\n The idea is to guess a valid string whose number of common chars matches the results of previous guesses.\\n So when master.guess returns a new result, we can cut the set of valid candidates smaller, such that the next guess is more likely to hit the secret.\\n```\\n    def findSecretWord(self, wordlist, master):\\n        graph = collections.defaultdict(lambda :{i:set() for i in range(7)}) \\n        if not wordlist: return \\n        n = len(wordlist)\\n        for i1, i2 in itertools.combinations(range(n), 2):\\n            w1, w2 = wordlist[i1], wordlist[i2]\\n            dist = sum([w1[i] == w2[i] for i in range(6)])\\n            graph[i1][dist].add(i2)\\n            graph[i2][dist].add(i1)\\n                \\n        i = 0 \\n        ret = None \\n        for _ in range(10):\\n            t = master.guess(wordlist[i])\\n            if t == 6: return # we made it, so just stop\\n            ret = (ret & graph[i][t]) if ret else graph[i][t]\\n            i = random.sample(ret, 1)[0] # make a random guess among the possible candidates\\n```",
                "solutionTags": [],
                "code": "```\\n    def findSecretWord(self, wordlist, master):\\n        graph = collections.defaultdict(lambda :{i:set() for i in range(7)}) \\n        if not wordlist: return \\n        n = len(wordlist)\\n        for i1, i2 in itertools.combinations(range(n), 2):\\n            w1, w2 = wordlist[i1], wordlist[i2]\\n            dist = sum([w1[i] == w2[i] for i in range(6)])\\n            graph[i1][dist].add(i2)\\n            graph[i2][dist].add(i1)\\n                \\n        i = 0 \\n        ret = None \\n        for _ in range(10):\\n            t = master.guess(wordlist[i])\\n            if t == 6: return # we made it, so just stop\\n            ret = (ret & graph[i][t]) if ret else graph[i][t]\\n            i = random.sample(ret, 1)[0] # make a random guess among the possible candidates\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 133849,
                "title": "python-preprocess-wordlist-based-on-matches",
                "content": "The idea is to first do a preprocessing of words, to create a dictionary of dictionary where we have a mapping between each word to a set of words that map eaxactly 0 to 5 characters.\\n\\nword1 --> 0 matches = []\\n                 1 matches = []\\n\\t\\t\\t\\t\\t\\t\\t\\t .\\n\\t\\t\\t\\t\\t\\t\\t\\t .\\n\\t\\t\\t\\t\\t\\t\\t\\t 5 matches = []\\n\\t\\t\\t\\t\\t\\t\\t\\t \\nOnce we have this mapping, \\n1) we guess a word, and find the number of matches to secret\\n2) Retrieve the set of words that correspond to the number of matches for this word in the dictionary\\n3) Reduce the potential secrets list with the above retrieved list\\n\\n```\\n    def findSecretWord(self, words, master):\\n        matches = defaultdict(lambda: defaultdict(set))\\n        n = len(words)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                m_count = sum([1 for k in range(6) if words[i][k] == words[j][k]])\\n                matches[words[i]][m_count].add(words[j])\\n                matches[words[j]][m_count].add(words[i])\\n        words = set(words)\\n        for i in range(10):\\n            guess = words.pop()\\n            res = master.guess(guess)\\n            print(guess, res)\\n            if res == 6:\\n                return guess\\n            words.intersection_update(matches[guess][res])\\n```",
                "solutionTags": [],
                "code": "```\\n    def findSecretWord(self, words, master):\\n        matches = defaultdict(lambda: defaultdict(set))\\n        n = len(words)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                m_count = sum([1 for k in range(6) if words[i][k] == words[j][k]])\\n                matches[words[i]][m_count].add(words[j])\\n                matches[words[j]][m_count].add(words[i])\\n        words = set(words)\\n        for i in range(10):\\n            guess = words.pop()\\n            res = master.guess(guess)\\n            print(guess, res)\\n            if res == 6:\\n                return guess\\n            words.intersection_update(matches[guess][res])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3602400,
                "title": "c",
                "content": "\\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& words, Master& master) {\\n        while (!words.empty()) {\\n            int i = rand() % words.size();\\n            string cur_word = words[i];\\n            int num = master.guess(cur_word);\\n            if (num == 6) {\\n                //cout << \"The word! \";\\n                break;\\n            }\\n            else {\\n                swap(words[i], words.back());\\n                words.pop_back();\\n                check_words(words, cur_word, num);\\n            }\\n        }\\n    }\\n\\nprivate:\\n    void check_words (vector<string>& words, string& cur_word, int num) {\\n        int cnt_words = words.size();\\n        int i = 0;\\n        while (cnt_words--) {\\n            int cnt_letters = 0;\\n            for (int j = 0; j < 6; j++) {\\n                if (words[i][j] == cur_word[j]) {\\n                    cnt_letters++;\\n                }\\n            }\\n\\n            if (cnt_letters != num) {\\n                swap(words[i], words.back());\\n                words.pop_back();\\n            } else {\\n                i++;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& words, Master& master) {\\n        while (!words.empty()) {\\n            int i = rand() % words.size();\\n            string cur_word = words[i];\\n            int num = master.guess(cur_word);\\n            if (num == 6) {\\n                //cout << \"The word! \";\\n                break;\\n            }\\n            else {\\n                swap(words[i], words.back());\\n                words.pop_back();\\n                check_words(words, cur_word, num);\\n            }\\n        }\\n    }\\n\\nprivate:\\n    void check_words (vector<string>& words, string& cur_word, int num) {\\n        int cnt_words = words.size();\\n        int i = 0;\\n        while (cnt_words--) {\\n            int cnt_letters = 0;\\n            for (int j = 0; j < 6; j++) {\\n                if (words[i][j] == cur_word[j]) {\\n                    cnt_letters++;\\n                }\\n            }\\n\\n            if (cnt_letters != num) {\\n                swap(words[i], words.back());\\n                words.pop_back();\\n            } else {\\n                i++;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2915929,
                "title": "c-solution-without-randomization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI need to minimize pool of data that I should choose from. Each iteration MUST get me closer to the solution. I will count ammount of retries on each run to verify how close I am. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMatching values tell me 3 things:\\n- if attempted guess word \"matching\" is > 0 then i should remove all words that do not have at least \"matching\" ammount of letters with my current word.\\n- if attempted guess word \"matching\" is 0 then this tells me I should remove all words that have matching letters with attempted guess word\\n- lastly I should choose one of words that are at most \"matching\" with my attempted guess word because if \"matching\" is better then I have letters that should not be in secret (secret has \"matching\" ammount of letters with attempted guess word)\\n\\nIt will not work with stupid test cases like:\\n\\n\"aaaaaa\"\\n\"bbbbbb\"\\n\"cccccc\"\\n...\\n\\nbecause this would require at least 26 retries, choosing at random would create possibility to find match but random and hoping for best is not \"the way\".\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n26 attempts (scenario above is worst case scenario) * 3 loops with entire word array on each iteration (removing only attempted guess word itself).\\n$$O(n * a * l)$$\\nWhere $$n$$ is ammount of words in word list, $$a$$ is ammount of retries of guess word, and $$l$$ is length of words.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nHashSet with words.\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *     public int Guess(string word);\\n * }\\n */\\nclass Solution {\\n    const int wordsLength = 6;\\n\\n    public int MatchingLetters(string one, string two)\\n    {\\n        int counter = 0;\\n        for (int i = 0; i < wordsLength; i++)\\n        {\\n            if (one[i] == two[i])\\n                counter++;\\n        }\\n        return counter;\\n    }\\n\\n    public void FindSecretWord(string[] words, Master master) {\\n        var wordsSet = words.ToHashSet();\\n        string guessWord = words[0];\\n\\n        int attemptCounter = 0;\\n        while (true)\\n        {\\n            attemptCounter++;\\n            int matching = master.guess(guessWord);\\n            if (matching == 6)\\n            {\\n                Console.WriteLine($\"Done in {attemptCounter} tries.\");\\n                break;\\n            }\\n            \\n            // Remove less matching values\\n            if (matching != 0)\\n            {\\n                foreach (var word in wordsSet)\\n                {\\n                    if (MatchingLetters(guessWord, word) < matching)\\n                        wordsSet.Remove(word);\\n                }\\n            }\\n            else // if no matching characters remove all words that have same\\n            {\\n                foreach (var word in wordsSet)\\n                {\\n                    for (int i = 0; i < wordsLength; i++)\\n                    {\\n                        if (word[i] == guessWord[i])\\n                        {\\n                            wordsSet.Remove(word);\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            wordsSet.Remove(guessWord);\\n\\n            // choose next guess word that has no more than matching\\n            string nextGuessWord = \"\";\\n            foreach (var word in wordsSet)\\n            {\\n                if (MatchingLetters(guessWord, word) == matching)\\n                {\\n                    nextGuessWord = word;\\n                }\\n            }\\n\\n            guessWord = nextGuessWord;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *     public int Guess(string word);\\n * }\\n */\\nclass Solution {\\n    const int wordsLength = 6;\\n\\n    public int MatchingLetters(string one, string two)\\n    {\\n        int counter = 0;\\n        for (int i = 0; i < wordsLength; i++)\\n        {\\n            if (one[i] == two[i])\\n                counter++;\\n        }\\n        return counter;\\n    }\\n\\n    public void FindSecretWord(string[] words, Master master) {\\n        var wordsSet = words.ToHashSet();\\n        string guessWord = words[0];\\n\\n        int attemptCounter = 0;\\n        while (true)\\n        {\\n            attemptCounter++;\\n            int matching = master.guess(guessWord);\\n            if (matching == 6)\\n            {\\n                Console.WriteLine($\"Done in {attemptCounter} tries.\");\\n                break;\\n            }\\n            \\n            // Remove less matching values\\n            if (matching != 0)\\n            {\\n                foreach (var word in wordsSet)\\n                {\\n                    if (MatchingLetters(guessWord, word) < matching)\\n                        wordsSet.Remove(word);\\n                }\\n            }\\n            else // if no matching characters remove all words that have same\\n            {\\n                foreach (var word in wordsSet)\\n                {\\n                    for (int i = 0; i < wordsLength; i++)\\n                    {\\n                        if (word[i] == guessWord[i])\\n                        {\\n                            wordsSet.Remove(word);\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            wordsSet.Remove(guessWord);\\n\\n            // choose next guess word that has no more than matching\\n            string nextGuessWord = \"\";\\n            foreach (var word in wordsSet)\\n            {\\n                if (MatchingLetters(guessWord, word) == matching)\\n                {\\n                    nextGuessWord = word;\\n                }\\n            }\\n\\n            guessWord = nextGuessWord;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906551,
                "title": "god-bless-you-god-bless-the-u-s-a",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBefore you submit, just pray\\uFF01\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRandomly select current word, and then group the words by the same \"guess\" result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(len(words))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(len(words))\\n\\n# Code\\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {\\npublic:\\n    inline int count(const string &a, const string &b) {\\n        int res = 0;\\n        for (int i = 0; i < 6; ++i) {\\n            if (a[i] == b[i]) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n    void findSecretWord(vector<string>& words, Master& master) {\\n        srand(time(0));\\n        vector<string> candidates;\\n        for (int i = 0; i < words.size(); ++i) {\\n            candidates.emplace_back(words[i]);\\n        }\\n        while (!candidates.empty()) {\\n            string word = candidates[rand() % candidates.size()];\\n            int cnt = master.guess(word);\\n            if (cnt == 6) {\\n                return;\\n            }\\n            vector<string> temp;\\n            for (auto &w : candidates) {\\n                if (count(w, word) == cnt) {\\n                    temp.emplace_back(w);\\n                }\\n            }\\n            candidates = move(temp);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math",
                    "String"
                ],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {\\npublic:\\n    inline int count(const string &a, const string &b) {\\n        int res = 0;\\n        for (int i = 0; i < 6; ++i) {\\n            if (a[i] == b[i]) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n    void findSecretWord(vector<string>& words, Master& master) {\\n        srand(time(0));\\n        vector<string> candidates;\\n        for (int i = 0; i < words.size(); ++i) {\\n            candidates.emplace_back(words[i]);\\n        }\\n        while (!candidates.empty()) {\\n            string word = candidates[rand() % candidates.size()];\\n            int cnt = master.guess(word);\\n            if (cnt == 6) {\\n                return;\\n            }\\n            vector<string> temp;\\n            for (auto &w : candidates) {\\n                if (count(w, word) == cnt) {\\n                    temp.emplace_back(w);\\n                }\\n            }\\n            candidates = move(temp);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510449,
                "title": "c-remove-impossible-cases-try-to-use-srand-1",
                "content": "The idea is to remove all impossible cases after a guess. Nevertheless, for those who can\\'t pass this problem by following that approach. let\\'s try to use an initial seed value like srand(1).\\n\\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& words, Master& m) {\\n        while(true) {\\n            srand (1);\\n            string g = words[rand() % words.size()];\\n            // cout << g << endl;\\n            int matched = m.guess(g);\\n            if (matched == 6) return;\\n            vector<string> newWords;\\n            \\n            for (int j = 0; j < words.size(); j++) {\\n                if (match(g, words[j]) == matched) newWords.push_back(words[j]);\\n            }\\n            words = newWords;\\n        }\\n    }\\n\\n    int match(string s, string t) {\\n        int cnt = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == t[i]) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\nHope this is helpful. \\nThanks!",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& words, Master& m) {\\n        while(true) {\\n            srand (1);\\n            string g = words[rand() % words.size()];\\n            // cout << g << endl;\\n            int matched = m.guess(g);\\n            if (matched == 6) return;\\n            vector<string> newWords;\\n            \\n            for (int j = 0; j < words.size(); j++) {\\n                if (match(g, words[j]) == matched) newWords.push_back(words[j]);\\n            }\\n            words = newWords;\\n        }\\n    }\\n\\n    int match(string s, string t) {\\n        int cnt = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == t[i]) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2443539,
                "title": "simple-java-graph",
                "content": "\\n    This problem is little tricky , but try to visualize it as graph \\n    we will try to match the guessCount value for every word \\n    [\"acckzz\",\"ccbazz\",\"eiowzz\",\"abcczz\"]\\n\\t\\n\\t1. guess returns a value if the value at a specific position matches a secret word -->  \"acckzz\"\\n\\t2. Lets assume the first word is \\n    \"eiowzz\" -- guessCount of 2 --> Last two Z match the secret words\\n        --> so all the words which have last two zz present can be a secret word\\n\\t\\t--> List Created will have all the words which have matching of atleast 2\\n        \\n    \"abcczz\" -- guessCount of 4 --> a,c,zz \\n        --> so all the words which have similar count can be part of next search\\n        --> List Created will have all the words which have matching of atleast 4\\n\\t\\t\\n    So the words can be in any order \\n   3. So think about incrementing guessCount --> \\n\\t\\t\"2--> 4--> 5 --> 6 --return\"\\n    \\n    if we are not able to reach 6 --> it means we cannot find the secret word\\n    from the given words list \\n\\t`\\n    public void findSecretWord(String[] words, Master master) {\\n        List<String> wl = new ArrayList<String>();\\n        for(String w: words){\\n            wl.add(w);\\n        }\\n        \\n        int i=0;\\n        // we are given 10 tries--> this can be of any amount , so we can use true and it will break when the list size will be zero\\n        while(true){\\n            int n = wl.size();\\n            int ci = i%n;\\n            String cw = wl.get(ci);\\n            int guess = master.guess(cw);\\n            if(guess == 6){\\n                return;\\n            }\\n            if(guess >= 0){\\n                List<String> nwl = getMatches(cw, guess, wl);\\n                wl = nwl;\\n            }\\n            i++;\\n        }\\n        \\n    }\\n    // it is given all the words are of length 6\\n    private List<String> getMatches(String mw, int match , List<String> wordList){\\n        List<String> nwl = new ArrayList<String>();\\n        \\n        for(String w: wordList){\\n            int count =0;\\n            for(int i=0; i< w.length(); i++){\\n                if(w.charAt(i) == mw.charAt(i)){\\n                    count++;\\n                }\\n            }\\n            if(count== match){\\n                nwl.add(w);\\n            }\\n        }\\n        return nwl;\\n    }`",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "\\n    This problem is little tricky , but try to visualize it as graph \\n    we will try to match the guessCount value for every word \\n    [\"acckzz\",\"ccbazz\",\"eiowzz\",\"abcczz\"]\\n\\t\\n\\t1. guess returns a value if the value at a specific position matches a secret word -->  \"acckzz\"\\n\\t2. Lets assume the first word is \\n    \"eiowzz\" -- guessCount of 2 --> Last two Z match the secret words\\n        --> so all the words which have last two zz present can be a secret word\\n\\t\\t--> List Created will have all the words which have matching of atleast 2\\n        \\n    \"abcczz\" -- guessCount of 4 --> a,c,zz \\n        --> so all the words which have similar count can be part of next search\\n        --> List Created will have all the words which have matching of atleast 4\\n\\t\\t\\n    So the words can be in any order \\n   3. So think about incrementing guessCount --> \\n\\t\\t\"2--> 4--> 5 --> 6 --return\"\\n    \\n    if we are not able to reach 6 --> it means we cannot find the secret word\\n    from the given words list \\n\\t`\\n    public void findSecretWord(String[] words, Master master) {\\n        List<String> wl = new ArrayList<String>();\\n        for(String w: words){\\n            wl.add(w);\\n        }\\n        \\n        int i=0;\\n        // we are given 10 tries--> this can be of any amount , so we can use true and it will break when the list size will be zero\\n        while(true){\\n            int n = wl.size();\\n            int ci = i%n;\\n            String cw = wl.get(ci);\\n            int guess = master.guess(cw);\\n            if(guess == 6){\\n                return;\\n            }\\n            if(guess >= 0){\\n                List<String> nwl = getMatches(cw, guess, wl);\\n                wl = nwl;\\n            }\\n            i++;\\n        }\\n        \\n    }\\n    // it is given all the words are of length 6\\n    private List<String> getMatches(String mw, int match , List<String> wordList){\\n        List<String> nwl = new ArrayList<String>();\\n        \\n        for(String w: wordList){\\n            int count =0;\\n            for(int i=0; i< w.length(); i++){\\n                if(w.charAt(i) == mw.charAt(i)){\\n                    count++;\\n                }\\n            }\\n            if(count== match){\\n                nwl.add(w);\\n            }\\n        }\\n        return nwl;\\n    }`",
                "codeTag": "Unknown"
            },
            {
                "id": 2292267,
                "title": "java-accepted-solution",
                "content": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    \\n    private int distBetween(String s1, String s2) {\\n        int dist = 0;\\n        for (int i = 0; i <=5; i++) {\\n            if (s1.charAt(i) == s2.charAt(i)) {\\n                dist++;\\n            }\\n        }\\n        \\n        return dist;\\n    }\\n    \\n    private List<String> intersection(List<String> l1, List<String> l2) {\\n        List<String> intersection = new ArrayList<>();\\n        for (String l1Entry : l1) {\\n            if (l2.contains(l1Entry)) {\\n                intersection.add(l1Entry);\\n            }\\n        }\\n        \\n        return intersection;\\n    }\\n    \\n    \\n    private Map<String, Map<Integer, List<String>>> createDistMap(String[] wordlist) {\\n        Map<String, Map<Integer, List<String>>> distMaps = new HashMap<>();\\n        \\n        for (String word : wordlist) {\\n            Map<Integer, List<String>> distMap = new HashMap<>();\\n            List<String> targets = new ArrayList<>();\\n            targets.add(word);\\n            distMap.put(6, targets);\\n            distMaps.put(word, distMap);\\n        }\\n        \\n        for (int i = 0; i < wordlist.length; i++) {\\n            for (int j = i + 1; j < wordlist.length; j++) {\\n                int dist = distBetween(wordlist[i], wordlist[j]);\\n                // System.out.println(\"dist between \" + wordlist[i] + \" and \" + wordlist[j] + \" is \" + dist);\\n                Map<Integer, List<String>> distMap = distMaps.get(wordlist[i]);\\n                List<String> targets = distMap.getOrDefault(dist, new ArrayList<>());\\n                targets.add(wordlist[j]);\\n                distMap.put(dist, targets);\\n                \\n                \\n                distMap = distMaps.get(wordlist[j]);\\n                targets = distMap.getOrDefault(dist, new ArrayList<>());\\n                targets.add(wordlist[i]);\\n                distMap.put(dist, targets);\\n            }\\n        }\\n        \\n        return distMaps;\\n    }\\n    \\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Map<String, Map<Integer, List<String>>> distMaps = createDistMap(wordlist);\\n        \\n        int guessCount = 0;\\n        List<String> potentials = Arrays.asList(wordlist);\\n        Random rand = new Random();\\n        while (guessCount < 30) {\\n            String guessed = potentials.get(rand.nextInt(potentials.size()));\\n            int dist = master.guess(guessed);\\n            if (dist == 6) {\\n                break;\\n            }\\n            List<String> potentials1 = distMaps.get(guessed).get(dist);\\n            potentials = intersection(potentials, potentials1);\\n            \\n            if (potentials.size() < (30 - guessCount)) {\\n                System.out.println(\"Going through potentials \" + potentials.size());\\n                for (String potential : potentials) {\\n                    master.guess(potential);\\n                }\\n                break;\\n            } else {\\n                System.out.println(\"Potential list is too large \" + potentials.size());\\n            }\\n            \\n            guessCount++;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    \\n    private int distBetween(String s1, String s2) {\\n        int dist = 0;\\n        for (int i = 0; i <=5; i++) {\\n            if (s1.charAt(i) == s2.charAt(i)) {\\n                dist++;\\n            }\\n        }\\n        \\n        return dist;\\n    }\\n    \\n    private List<String> intersection(List<String> l1, List<String> l2) {\\n        List<String> intersection = new ArrayList<>();\\n        for (String l1Entry : l1) {\\n            if (l2.contains(l1Entry)) {\\n                intersection.add(l1Entry);\\n            }\\n        }\\n        \\n        return intersection;\\n    }\\n    \\n    \\n    private Map<String, Map<Integer, List<String>>> createDistMap(String[] wordlist) {\\n        Map<String, Map<Integer, List<String>>> distMaps = new HashMap<>();\\n        \\n        for (String word : wordlist) {\\n            Map<Integer, List<String>> distMap = new HashMap<>();\\n            List<String> targets = new ArrayList<>();\\n            targets.add(word);\\n            distMap.put(6, targets);\\n            distMaps.put(word, distMap);\\n        }\\n        \\n        for (int i = 0; i < wordlist.length; i++) {\\n            for (int j = i + 1; j < wordlist.length; j++) {\\n                int dist = distBetween(wordlist[i], wordlist[j]);\\n                // System.out.println(\"dist between \" + wordlist[i] + \" and \" + wordlist[j] + \" is \" + dist);\\n                Map<Integer, List<String>> distMap = distMaps.get(wordlist[i]);\\n                List<String> targets = distMap.getOrDefault(dist, new ArrayList<>());\\n                targets.add(wordlist[j]);\\n                distMap.put(dist, targets);\\n                \\n                \\n                distMap = distMaps.get(wordlist[j]);\\n                targets = distMap.getOrDefault(dist, new ArrayList<>());\\n                targets.add(wordlist[i]);\\n                distMap.put(dist, targets);\\n            }\\n        }\\n        \\n        return distMaps;\\n    }\\n    \\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Map<String, Map<Integer, List<String>>> distMaps = createDistMap(wordlist);\\n        \\n        int guessCount = 0;\\n        List<String> potentials = Arrays.asList(wordlist);\\n        Random rand = new Random();\\n        while (guessCount < 30) {\\n            String guessed = potentials.get(rand.nextInt(potentials.size()));\\n            int dist = master.guess(guessed);\\n            if (dist == 6) {\\n                break;\\n            }\\n            List<String> potentials1 = distMaps.get(guessed).get(dist);\\n            potentials = intersection(potentials, potentials1);\\n            \\n            if (potentials.size() < (30 - guessCount)) {\\n                System.out.println(\"Going through potentials \" + potentials.size());\\n                for (String potential : potentials) {\\n                    master.guess(potential);\\n                }\\n                break;\\n            } else {\\n                System.out.println(\"Potential list is too large \" + potentials.size());\\n            }\\n            \\n            guessCount++;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074188,
                "title": "seems-a-guaranteed-ac-solution-java",
                "content": "With this test data provided by https://leetcode.com/_pzh in thread https://leetcode.com/problems/guess-the-word/discuss/134251/Optimal-MinMax-Solution-(%2B-extra-challenging-test-cases), I didn\\'t find any discussed solution can pass constantly.\\n\\n```\\n\"aaponm\"\\n[\"aazyxw\",\"aayxwv\",\"aaxwvu\",\"aawvut\",\"aavuts\",\"aautsr\",\"aatsrq\",\"aasrqp\",\"aarqpo\",\"aaqpon\",\"aaponm\",\"aaonml\",\"aanmlk\",\"aamlkj\",\"aalkji\",\"aakjih\",\"aajihg\",\"aaihgf\",\"aahgfe\",\"aagfed\",\"aafedc\",\"ccwwww\",\"ccssss\",\"ccoooo\",\"cckkkk\",\"ccgggg\",\"cccccc\",\"ccyyyy\",\"ccuuuu\",\"ccqqqq\",\"ccmmmm\",\"ddwwww\",\"ddssss\",\"ddoooo\",\"ddkkkk\",\"ddgggg\",\"ddcccc\",\"ddyyyy\",\"dduuuu\",\"ddqqqq\",\"ddmmmm\",\"eewwww\",\"eessss\",\"eeoooo\",\"eekkkk\",\"eegggg\",\"eecccc\",\"eeyyyy\",\"eeuuuu\",\"eeqqqq\",\"eemmmm\",\"ffwwww\",\"ffssss\",\"ffoooo\",\"ffkkkk\",\"ffgggg\",\"ffcccc\",\"ffyyyy\",\"ffuuuu\",\"ffqqqq\",\"ffmmmm\",\"ggwwww\",\"ggssss\",\"ggoooo\",\"ggkkkk\",\"gggggg\",\"ggcccc\",\"ggyyyy\",\"gguuuu\",\"ggqqqq\",\"ggmmmm\",\"hhwwww\",\"hhssss\",\"hhoooo\",\"hhkkkk\",\"hhgggg\",\"hhcccc\",\"hhyyyy\",\"hhuuuu\",\"hhqqqq\",\"hhmmmm\",\"iiwwww\",\"iissss\",\"iioooo\",\"iikkkk\",\"iigggg\",\"iicccc\",\"iiyyyy\",\"iiuuuu\",\"iiqqqq\",\"iimmmm\",\"jjwwww\",\"jjssss\",\"jjoooo\",\"jjkkkk\",\"jjgggg\",\"jjcccc\",\"jjyyyy\",\"jjuuuu\",\"jjqqqq\"]\\n10\\n```\\n\\nThe key is to guess better. Here I implemented a brute force similarity check between each word, and picked the highest similarity word for guessing. \\nIt seems guaranteed to pass above test data only when the threshold is 100. Lower threshold such as 5 could pass Leetcode submission already, though pure randomization couldn\\'t.\\n\\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        for (int i = 0; i < 10; i++) {\\n            int random = Math.round((int) Math.random() * (wordlist.length - 1));\\n            if (wordlist.length <= 100) { // play with this threshold to see pass rate, 5 can pass Leetcode submission but not above test data.\\n                random = pick(wordlist);\\n            }\\n            int guess = master.guess(wordlist[random]);\\n            // System.out.println(wordlist[random] + \", \" + guess + \", \" + random);\\n            if (guess == 6) break;\\n            \\n            List<String> newlist = new ArrayList<>();            \\n            \\n            for (int j = 0; j < wordlist.length; j++) {\\n                if (j == random) continue;\\n                if (similarityCheck(wordlist[j], wordlist[random]) == guess) {\\n                    newlist.add(wordlist[j]);\\n                }\\n            }\\n            // System.out.println(\"size: \" + newlist.size());\\n            wordlist = newlist.toArray(new String[0]);\\n        }\\n    }\\n    \\n    int pick(String[] wl) {\\n        int max = 0, index = 0;\\n        for (int i = 0; i < wl.length - 1; i++) {\\n            for (int j = i + 1; j < wl.length; j++) {\\n                int sc = similarityCheck(wl[i], wl[j]);\\n                if (max < sc) {\\n                    max = sc;\\n                    index = i;\\n                }\\n            }\\n        }\\n        // System.out.println(\"Max: \" + max);\\n        return index;\\n    }\\n    \\n    int similarityCheck(String word1, String word2) {\\n        int equal = 0;\\n        for (int i = 0; i < 6; i++) {\\n            if (word1.charAt(i) == word2.charAt(i)) {\\n                equal++;\\n            }\\n        }\\n        return equal;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\"aaponm\"\\n[\"aazyxw\",\"aayxwv\",\"aaxwvu\",\"aawvut\",\"aavuts\",\"aautsr\",\"aatsrq\",\"aasrqp\",\"aarqpo\",\"aaqpon\",\"aaponm\",\"aaonml\",\"aanmlk\",\"aamlkj\",\"aalkji\",\"aakjih\",\"aajihg\",\"aaihgf\",\"aahgfe\",\"aagfed\",\"aafedc\",\"ccwwww\",\"ccssss\",\"ccoooo\",\"cckkkk\",\"ccgggg\",\"cccccc\",\"ccyyyy\",\"ccuuuu\",\"ccqqqq\",\"ccmmmm\",\"ddwwww\",\"ddssss\",\"ddoooo\",\"ddkkkk\",\"ddgggg\",\"ddcccc\",\"ddyyyy\",\"dduuuu\",\"ddqqqq\",\"ddmmmm\",\"eewwww\",\"eessss\",\"eeoooo\",\"eekkkk\",\"eegggg\",\"eecccc\",\"eeyyyy\",\"eeuuuu\",\"eeqqqq\",\"eemmmm\",\"ffwwww\",\"ffssss\",\"ffoooo\",\"ffkkkk\",\"ffgggg\",\"ffcccc\",\"ffyyyy\",\"ffuuuu\",\"ffqqqq\",\"ffmmmm\",\"ggwwww\",\"ggssss\",\"ggoooo\",\"ggkkkk\",\"gggggg\",\"ggcccc\",\"ggyyyy\",\"gguuuu\",\"ggqqqq\",\"ggmmmm\",\"hhwwww\",\"hhssss\",\"hhoooo\",\"hhkkkk\",\"hhgggg\",\"hhcccc\",\"hhyyyy\",\"hhuuuu\",\"hhqqqq\",\"hhmmmm\",\"iiwwww\",\"iissss\",\"iioooo\",\"iikkkk\",\"iigggg\",\"iicccc\",\"iiyyyy\",\"iiuuuu\",\"iiqqqq\",\"iimmmm\",\"jjwwww\",\"jjssss\",\"jjoooo\",\"jjkkkk\",\"jjgggg\",\"jjcccc\",\"jjyyyy\",\"jjuuuu\",\"jjqqqq\"]\\n10\\n```\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        for (int i = 0; i < 10; i++) {\\n            int random = Math.round((int) Math.random() * (wordlist.length - 1));\\n            if (wordlist.length <= 100) { // play with this threshold to see pass rate, 5 can pass Leetcode submission but not above test data.\\n                random = pick(wordlist);\\n            }\\n            int guess = master.guess(wordlist[random]);\\n            // System.out.println(wordlist[random] + \", \" + guess + \", \" + random);\\n            if (guess == 6) break;\\n            \\n            List<String> newlist = new ArrayList<>();            \\n            \\n            for (int j = 0; j < wordlist.length; j++) {\\n                if (j == random) continue;\\n                if (similarityCheck(wordlist[j], wordlist[random]) == guess) {\\n                    newlist.add(wordlist[j]);\\n                }\\n            }\\n            // System.out.println(\"size: \" + newlist.size());\\n            wordlist = newlist.toArray(new String[0]);\\n        }\\n    }\\n    \\n    int pick(String[] wl) {\\n        int max = 0, index = 0;\\n        for (int i = 0; i < wl.length - 1; i++) {\\n            for (int j = i + 1; j < wl.length; j++) {\\n                int sc = similarityCheck(wl[i], wl[j]);\\n                if (max < sc) {\\n                    max = sc;\\n                    index = i;\\n                }\\n            }\\n        }\\n        // System.out.println(\"Max: \" + max);\\n        return index;\\n    }\\n    \\n    int similarityCheck(String word1, String word2) {\\n        int equal = 0;\\n        for (int i = 0; i < 6; i++) {\\n            if (word1.charAt(i) == word2.charAt(i)) {\\n                equal++;\\n            }\\n        }\\n        return equal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905005,
                "title": "java-o-n-solution-no-random-pick",
                "content": "```\\nIntuition:\\n1. No random pick the initial word as, random pick cannot provide guarantee to give you the expected results in 10 guesses all the time. \\nSo, choose the word that has the most frequent character in the entire wordlist.\\n2. How to reduce the search space?\\nSuppose, n = master.guess(word)\\nif n == 6, we find the secret word.\\nif n != 6, it means secret has exactly n matches with the guess word\\nAs, secret has exactly n matches with the guess word, we only keep the ones in the wordlist that have exact n matches with the guess word. \\n\\nimport java.util.*;\\nclass Solution {\\n    \\n    private String getMostCommonWord(String[] wordlist){\\n        int[][] count = new int[wordlist[0].length()][26];\\n        int matches = 0;\\n        for(String word: wordlist){\\n            char[] ch = word.toCharArray();\\n            for(int i = 0; i < 6; i++){\\n                count[i][ch[i] - \\'a\\']++;\\n            }        \\n        }\\n        int best_score = Integer.MIN_VALUE;\\n        int curr_score = 0;\\n        String common = \"\";\\n        for(String word: wordlist){\\n            char[] ch = word.toCharArray();\\n            for(int i = 0; i < 6; i++){\\n                curr_score += count[i][ch[i] - \\'a\\'];\\n            }  \\n            if(curr_score > best_score){\\n                best_score = curr_score;\\n                common = word;\\n            }\\n            curr_score = 0;\\n        }\\n        \\n        return common;\\n    }\\n    \\n    public void findSecretWord(String[] wordlist, Master master) {\\n  \\n        for(int i = 0, matches = 0; i < 10; i ++){\\n            String guess = getMostCommonWord(wordlist);\\n            matches = master.guess(guess);\\n            if(matches == 6)\\n                return;\\n            List<String> candidates = new ArrayList<>();\\n            for(String word: wordlist){\\n                if(word != guess){\\n                    if(matches == getMatches(guess, word)){\\n                        candidates.add(word);\\n                    }\\n                }\\n            }  \\n            wordlist = candidates.toArray(new String[0]);\\n        }\\n         \\n    }\\n    \\n    private int getMatches(String word1, String word2){\\n        int matches = 0;\\n        for(int i = 0; i < word1.length(); i ++){\\n            if(word1.charAt(i) == word2.charAt(i)){\\n                matches ++;\\n            }\\n        }\\n        \\n        return matches;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    private String getMostCommonWord(String[] wordlist){\\n        int[][] count = new int[wordlist[0].length()][26];\\n        int matches = 0;\\n        for(String word: wordlist){\\n            char[] ch = word.toCharArray();\\n            for(int i = 0; i < 6; i++){\\n                count[i][ch[i] - \\'a\\']++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1860346,
                "title": "optimized-easy-to-understand-solution-o-n",
                "content": "```\\nvar findSecretWord = function(wordlist, master) {\\n\\n    let index =  pickRandomIndex(wordlist.length);\\n    let guessed = wordlist.splice(index, 1)[0];\\n    let matches = master.guess(guessed);\\n    \\n    while(matches !== 6){       \\n        for(let i = wordlist.length - 1; i >= 0; i--){\\n            // Remove all the words that match too much or too less then the count returned\\n           if(getMatchCount(wordlist[i], guessed) !== matches){\\n               wordlist.splice(i, 1);\\n           }\\n        }\\n        \\n        index =  pickRandomIndex(wordlist.length);\\n        guessed = wordlist.splice(index, 1)[0];\\n        matches = master.guess(guessed);\\n    }\\n};\\n\\nfunction pickRandomIndex(len){\\n    return Math.trunc(Math.random() * len)\\n}\\n\\nfunction getMatchCount(word, guess){\\n    let matches = 0\\n    for(let i = 0; i < word.length; i++){\\n\\t\\t// Count position and value matches\\n        if(word[i] === guess[i]){\\n           matches++; \\n        }\\n    }\\n    return matches;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findSecretWord = function(wordlist, master) {\\n\\n    let index =  pickRandomIndex(wordlist.length);\\n    let guessed = wordlist.splice(index, 1)[0];\\n    let matches = master.guess(guessed);\\n    \\n    while(matches !== 6){       \\n        for(let i = wordlist.length - 1; i >= 0; i--){\\n            // Remove all the words that match too much or too less then the count returned\\n           if(getMatchCount(wordlist[i], guessed) !== matches){\\n               wordlist.splice(i, 1);\\n           }\\n        }\\n        \\n        index =  pickRandomIndex(wordlist.length);\\n        guessed = wordlist.splice(index, 1)[0];\\n        matches = master.guess(guessed);\\n    }\\n};\\n\\nfunction pickRandomIndex(len){\\n    return Math.trunc(Math.random() * len)\\n}\\n\\nfunction getMatchCount(word, guess){\\n    let matches = 0\\n    for(let i = 0; i < word.length; i++){\\n\\t\\t// Count position and value matches\\n        if(word[i] === guess[i]){\\n           matches++; \\n        }\\n    }\\n    return matches;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1769238,
                "title": "easy-intuitive-solution-in-python",
                "content": "We want to try to decrease the word list as much as possible.\\n\\nTo pick the best guess, let choose the letter at which position has most words.\\n\\nBased on the guess score do a few processing steps to shorten the word list\\nif guess score is 0,  remove all the words that have letters at the same positions as that of the guessed word.\\n\\nIf guess score is 1-5, then find all combinations of that word based on the position, and get the words that have those combinations. This leads to a shorter word list, then repeat the same process.\\n\\n```\\n# \"\"\"\\n# This is Master\\'s API interface.\\n# You should not implement it, or speculate about its implementation\\n# \"\"\"\\n# class Master:\\n#     def guess(self, word: str) -> int:\\nfrom itertools import combinations\\nfrom queue import PriorityQueue\\nimport random\\n\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        preprocess = Process(wordlist)\\n        wordToGuess = GetTheBestGuess(preprocess)\\n        guessScore = master.guess(wordToGuess)\\n        if guessScore == 6:\\n            return \\n        else:\\n            newList = PostGuessProcess(wordToGuess, guessScore, wordlist, preprocess)\\n            self.findSecretWord(newList, master)\\n            \\ndef GetTheBestGuess(preprocess):\\n    q = PriorityQueue()\\n    for letter in preprocess:\\n        for index in preprocess[letter]:\\n            # Adding negative because you want to eliminate most number\\n            # of words\\n            # MAX HEAP\\n            q.put((-1*len(preprocess[letter][index]), (letter,index)))\\n    x = q.get()\\n    pqueue, key = x[0], x[1]\\n    return random.choice(list(preprocess[key[0]][key[1]]))\\n\\n\\ndef Process(wordlist):\\n    preprocess = {}\\n    for word in wordlist:\\n        for index, letter in enumerate(word):\\n            if letter in preprocess:\\n                preprocess[letter][index].add(word)\\n            else:\\n                preprocess[letter] = {}\\n                for i in range(0,6):\\n                    preprocess[letter][i] = set()\\n                preprocess[letter][index].add(word)\\n    return preprocess\\n\\ndef PostGuessProcess(wordGuessed, guessScore, wordlist, preprocess):\\n    if guessScore == 0:\\n        return remove(wordGuessed, wordlist, preprocess)\\n    else:\\n        return shortenWordList(wordGuessed, guessScore, wordlist, preprocess)\\n\\ndef remove(wordGuessed, wordlist, preprocess):\\n    words = set(wordlist)\\n    for index, letter in enumerate(wordGuessed):\\n        # Remove everything in that position.\\n        for word in preprocess[letter][index]:\\n            words.discard(word)\\n    return words\\n\\ndef shortenWordList(word, guessScore, wordlist, preprocess):\\n    words = set()\\n    if guessScore == 1:\\n        for index, letter in enumerate(word):\\n            words.update(preprocess[letter][index])\\n        words.remove(word)\\n        return list(words)\\n    else:\\n        # Generate all combinations of the guessScore\\n        # since only 6 letters are present\\n        for combination in list(itertools.combinations([0,1,2,3,4,5], guessScore)):\\n            comboWords = set()\\n            # For Each combination, get the list of words that match\\n            # that combo. We need to do an intersection here.\\n            comboWords.update(preprocess[word[combination[0]]][combination[0]])\\n            # get list of words that match that\\n            for index in combination[1:]:\\n                comboWords.intersection(preprocess[word[index]][index])\\n            words.update(comboWords)\\n        # remove already guessed word.\\n        words.remove(word)\\n        return list(words)\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# \"\"\"\\n# This is Master\\'s API interface.\\n# You should not implement it, or speculate about its implementation\\n# \"\"\"\\n# class Master:\\n#     def guess(self, word: str) -> int:\\nfrom itertools import combinations\\nfrom queue import PriorityQueue\\nimport random\\n\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        preprocess = Process(wordlist)\\n        wordToGuess = GetTheBestGuess(preprocess)\\n        guessScore = master.guess(wordToGuess)\\n        if guessScore == 6:\\n            return \\n        else:\\n            newList = PostGuessProcess(wordToGuess, guessScore, wordlist, preprocess)\\n            self.findSecretWord(newList, master)\\n            \\ndef GetTheBestGuess(preprocess):\\n    q = PriorityQueue()\\n    for letter in preprocess:\\n        for index in preprocess[letter]:\\n            # Adding negative because you want to eliminate most number\\n            # of words\\n            # MAX HEAP\\n            q.put((-1*len(preprocess[letter][index]), (letter,index)))\\n    x = q.get()\\n    pqueue, key = x[0], x[1]\\n    return random.choice(list(preprocess[key[0]][key[1]]))\\n\\n\\ndef Process(wordlist):\\n    preprocess = {}\\n    for word in wordlist:\\n        for index, letter in enumerate(word):\\n            if letter in preprocess:\\n                preprocess[letter][index].add(word)\\n            else:\\n                preprocess[letter] = {}\\n                for i in range(0,6):\\n                    preprocess[letter][i] = set()\\n                preprocess[letter][index].add(word)\\n    return preprocess\\n\\ndef PostGuessProcess(wordGuessed, guessScore, wordlist, preprocess):\\n    if guessScore == 0:\\n        return remove(wordGuessed, wordlist, preprocess)\\n    else:\\n        return shortenWordList(wordGuessed, guessScore, wordlist, preprocess)\\n\\ndef remove(wordGuessed, wordlist, preprocess):\\n    words = set(wordlist)\\n    for index, letter in enumerate(wordGuessed):\\n        # Remove everything in that position.\\n        for word in preprocess[letter][index]:\\n            words.discard(word)\\n    return words\\n\\ndef shortenWordList(word, guessScore, wordlist, preprocess):\\n    words = set()\\n    if guessScore == 1:\\n        for index, letter in enumerate(word):\\n            words.update(preprocess[letter][index])\\n        words.remove(word)\\n        return list(words)\\n    else:\\n        # Generate all combinations of the guessScore\\n        # since only 6 letters are present\\n        for combination in list(itertools.combinations([0,1,2,3,4,5], guessScore)):\\n            comboWords = set()\\n            # For Each combination, get the list of words that match\\n            # that combo. We need to do an intersection here.\\n            comboWords.update(preprocess[word[combination[0]]][combination[0]])\\n            # get list of words that match that\\n            for index in combination[1:]:\\n                comboWords.intersection(preprocess[word[index]][index])\\n            words.update(comboWords)\\n        # remove already guessed word.\\n        words.remove(word)\\n        return list(words)\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640456,
                "title": "c-beat-100-using-sorting-to-scale-the-similari-ty",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n\\n        int N = wordlist.size();\\n        \\n        // sort wordlist, the first and the last word have the smallest similarity. \\n        sort(begin(wordlist), end(wordlist));\\n        \\n        // track visited items\\n        int visited[N];\\n        memset(visited, 0, sizeof(visited));\\n\\n        for(int guesscnt = 0, flag = 1; guesscnt < 10; guesscnt ++, flag ^= 1) {\\n            \\n            // each item we start from the word with the smallest similarity\\n            // to do that, we flip flag each time\\n            int i;\\n            if (flag) {\\n                // search from begin\\n                i = 0;\\n                while(i < N && visited[i]) i++;\\n                if (i == N) return;\\n            }\\n            else {\\n                // search from end\\n                i = N - 1;\\n                while(i >= 0 && visited[i]) i--;\\n                if (i == -1) return;\\n            }\\n            \\n            string curr = wordlist[i];\\n            int cnt = master.guess(curr);\\n            visited[i] = 1;\\n            \\n            if (cnt == 6) return;\\n            \\n            // remove all the words with different similarity\\n            for (int j = 0; j < N; j++) {\\n                if (visited[j]) {\\n                    continue;\\n                }\\n                \\n                string next = wordlist[j];\\n                \\n                int overlaps = 0;\\n                \\n                for (int a = 0; a < 6; a++) {\\n                    overlaps += next[a] == curr[a];\\n                }\\n                \\n                if (overlaps != cnt) {\\n                    visited[j] = 1;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n\\n        int N = wordlist.size();\\n        \\n        // sort wordlist, the first and the last word have the smallest similarity. \\n        sort(begin(wordlist), end(wordlist));\\n        \\n        // track visited items\\n        int visited[N];\\n        memset(visited, 0, sizeof(visited));\\n\\n        for(int guesscnt = 0, flag = 1; guesscnt < 10; guesscnt ++, flag ^= 1) {\\n            \\n            // each item we start from the word with the smallest similarity\\n            // to do that, we flip flag each time\\n            int i;\\n            if (flag) {\\n                // search from begin\\n                i = 0;\\n                while(i < N && visited[i]) i++;\\n                if (i == N) return;\\n            }\\n            else {\\n                // search from end\\n                i = N - 1;\\n                while(i >= 0 && visited[i]) i--;\\n                if (i == -1) return;\\n            }\\n            \\n            string curr = wordlist[i];\\n            int cnt = master.guess(curr);\\n            visited[i] = 1;\\n            \\n            if (cnt == 6) return;\\n            \\n            // remove all the words with different similarity\\n            for (int j = 0; j < N; j++) {\\n                if (visited[j]) {\\n                    continue;\\n                }\\n                \\n                string next = wordlist[j];\\n                \\n                int overlaps = 0;\\n                \\n                for (int a = 0; a < 6; a++) {\\n                    overlaps += next[a] == curr[a];\\n                }\\n                \\n                if (overlaps != cnt) {\\n                    visited[j] = 1;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613439,
                "title": "c-solution",
                "content": "This is an interesting problem. When I didn\\'t use character occurance, one problem did not pass. With occurance, it solved in 7 tries. I have not been able to do better. Giving up now...\\n```\\n   class Solution {\\npublic:\\n\\n    const bool USE_OCCURANCE = true;\\n\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        \\n        vector<bool> wordgone(wordlist.size(), false);     // keep track of words we have ruled out\\n\\n        int guesses = 10;\\n        while (guesses) {\\n\\n            vector<unordered_set<int>> occur(26);       // word occurance for each character\\n            \\n            for (int i = 0; i < wordlist.size(); i++) {\\n                if (!wordgone[i]) {\\n                    for (char ch : wordlist[i]) {\\n                        occur[ch-\\'a\\'].insert(i);  \\n                    }\\n                }\\n            }\\n\\n            sort(occur.begin(), occur.end(), [](auto& a, auto& b){\\n                return a.size() > b.size();     // highest occurance first\\n            });\\n                        \\n            int idx;\\n            if (USE_OCCURANCE) {      \\n                idx = *(occur[0].begin());      // pick one of the words with the highest occurance\\n            }\\n            else {\\n                // find the first word that has not been ruled out\\n                idx = 0;\\n                while (wordgone[idx]) {\\n                    idx++;\\n                }\\n            }\\n            string& cur = wordlist[idx];\\n\\n            int g = master.guess(cur);\\n            guesses--;\\n            \\n            if (g == 6) {\\n                cout << \"used \" << 10-guesses << \" guesses\" << endl;\\n                return;\\n            }\\n           \\n            for (int i = 0; i < wordlist.size(); i++) {\\n                \\n                if (!wordgone[i]) {\\n                    \\n                    // check for same number of matches\\n                    int m = 0;\\n                    for (int j = 0; j < 6; j++) {\\n                        if (cur[j] == wordlist[i][j]) {\\n                            m++;\\n                        }\\n                    }\\n                    if (m != g) {\\n                        wordgone[i] = true;\\n                    }\\n                }   \\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n   class Solution {\\npublic:\\n\\n    const bool USE_OCCURANCE = true;\\n\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        \\n        vector<bool> wordgone(wordlist.size(), false);     // keep track of words we have ruled out\\n\\n        int guesses = 10;\\n        while (guesses) {\\n\\n            vector<unordered_set<int>> occur(26);       // word occurance for each character\\n            \\n            for (int i = 0; i < wordlist.size(); i++) {\\n                if (!wordgone[i]) {\\n                    for (char ch : wordlist[i]) {\\n                        occur[ch-\\'a\\'].insert(i);  \\n                    }\\n                }\\n            }\\n\\n            sort(occur.begin(), occur.end(), [](auto& a, auto& b){\\n                return a.size() > b.size();     // highest occurance first\\n            });\\n                        \\n            int idx;\\n            if (USE_OCCURANCE) {      \\n                idx = *(occur[0].begin());      // pick one of the words with the highest occurance\\n            }\\n            else {\\n                // find the first word that has not been ruled out\\n                idx = 0;\\n                while (wordgone[idx]) {\\n                    idx++;\\n                }\\n            }\\n            string& cur = wordlist[idx];\\n\\n            int g = master.guess(cur);\\n            guesses--;\\n            \\n            if (g == 6) {\\n                cout << \"used \" << 10-guesses << \" guesses\" << endl;\\n                return;\\n            }\\n           \\n            for (int i = 0; i < wordlist.size(); i++) {\\n                \\n                if (!wordgone[i]) {\\n                    \\n                    // check for same number of matches\\n                    int m = 0;\\n                    for (int j = 0; j < 6; j++) {\\n                        if (cur[j] == wordlist[i][j]) {\\n                            m++;\\n                        }\\n                    }\\n                    if (m != g) {\\n                        wordgone[i] = true;\\n                    }\\n                }   \\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1606565,
                "title": "java-simple-solution-faster-than-90-with-detailed-comments",
                "content": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        //1. First guess any word randomly!\\n        String initialWord = getInitialWord(wordlist);\\n        \\n        //2. Add it to candidates list!\\n        List<String> candidates = new ArrayList<>();\\n        candidates.add(initialWord);\\n        String bestCandidate = initialWord;\\n        \\n        // 3. Loop as long as we have candidates!\\n        while (!candidates.isEmpty()) {\\n            \\n            // 3.1. Guess and find a score!\\n            int score = master.guess(bestCandidate);\\n            \\n            if (score == 6) {\\n                System.out.println(\"Matching is found!\");\\n                return;\\n            }\\n            \\n            // 3.2. Get all candidates that matches the score by calculating the hamming distance.\\n            candidates = getCandidates(wordlist, bestCandidate, score);\\n            \\n            // 3.3. Get the best candidate based on the one with the most commonality!\\n            bestCandidate = getBestCandidate(candidates);\\n            \\n            // 3.4. Update word list with new candidates\\n            wordlist = (String[]) candidates.toArray(new String[candidates.size()]);\\n        } \\n        \\n        System.out.println(\"[ERROR] No matching is found!\");\\n    }\\n    \\n    private String getBestCandidate(List<String> candidates) {\\n    \\tint[][] commonalityArray = new int[26][10];\\n    \\t\\n    \\tfor (String candidate : candidates) {\\n    \\t\\tchar[] candidateChars = candidate.toCharArray();\\n    \\t\\t\\n    \\t\\tint pos = 0;\\n    \\t\\tfor (char candidateChar : candidateChars) {\\n    \\t\\t\\tint row = candidateChar - \\'a\\';\\n    \\t\\t\\tint col = pos;\\n    \\t\\t\\t\\n    \\t\\t\\tcommonalityArray[row][col] = commonalityArray[row][col] + 1;\\n    \\t\\t\\t++pos;\\n    \\t\\t}\\n    \\t\\t\\t\\n    \\t}\\n    \\t\\n    \\tint maxScore = -1;\\n    \\tString bestCandidate = \"\";\\n    \\t\\n    \\tfor (int i = 0; i < candidates.size(); ++i) {\\n    \\t\\tString candidate = candidates.get(i);\\n    \\t\\tchar[] candidateChars = candidate.toCharArray();\\n    \\t\\tint current = 0;\\n    \\t\\tint pos = 0;\\n    \\t\\t\\n    \\t\\tfor (char candidateChar : candidateChars) {\\n    \\t\\t\\tcurrent += commonalityArray[candidateChar - \\'a\\'][pos];\\n    \\t\\t\\t++pos;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tif (current > maxScore) {\\n    \\t\\t\\tmaxScore = current;\\n    \\t\\t\\tbestCandidate = candidate;\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\treturn bestCandidate;\\n\\t}\\n\\n\\tString getInitialWord(String[] wordlist) {\\n        Random random = new Random();   \\n        int selectedWordIndex = random.nextInt(wordlist.length);\\n\\n        return wordlist[selectedWordIndex];\\n    }\\n   \\n    List<String> getCandidates(String[] wordlist, String bestCandidate, int score) {\\n    \\tList<String> out = new ArrayList<>();\\n    \\t\\n    \\tfor (String word : wordlist) {\\n    \\t\\tint distance = calcDistance(word, bestCandidate);\\n    \\t\\t\\n    \\t\\tif (distance == score) {\\n    \\t\\t\\tout.add(word);\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\treturn out;\\n    }\\n    \\n    int calcDistance(String word1, String word2) {\\n    \\tchar[] word1Chars = word1.toCharArray();\\n    \\tchar[] word2Chars = word2.toCharArray();\\n    \\tint count = 0;\\n    \\t\\n    \\tfor (int i = 0; i < word1Chars.length; ++i) {\\n    \\t\\tif (word1Chars[i] == word2Chars[i]) {\\n    \\t\\t\\t++count;\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\treturn count;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        //1. First guess any word randomly!\\n        String initialWord = getInitialWord(wordlist);\\n        \\n        //2. Add it to candidates list!\\n        List<String> candidates = new ArrayList<>();\\n        candidates.add(initialWord);\\n        String bestCandidate = initialWord;\\n        \\n        // 3. Loop as long as we have candidates!\\n        while (!candidates.isEmpty()) {\\n            \\n            // 3.1. Guess and find a score!\\n            int score = master.guess(bestCandidate);\\n            \\n            if (score == 6) {\\n                System.out.println(\"Matching is found!\");\\n                return;\\n            }\\n            \\n            // 3.2. Get all candidates that matches the score by calculating the hamming distance.\\n            candidates = getCandidates(wordlist, bestCandidate, score);\\n            \\n            // 3.3. Get the best candidate based on the one with the most commonality!\\n            bestCandidate = getBestCandidate(candidates);\\n            \\n            // 3.4. Update word list with new candidates\\n            wordlist = (String[]) candidates.toArray(new String[candidates.size()]);\\n        } \\n        \\n        System.out.println(\"[ERROR] No matching is found!\");\\n    }\\n    \\n    private String getBestCandidate(List<String> candidates) {\\n    \\tint[][] commonalityArray = new int[26][10];\\n    \\t\\n    \\tfor (String candidate : candidates) {\\n    \\t\\tchar[] candidateChars = candidate.toCharArray();\\n    \\t\\t\\n    \\t\\tint pos = 0;\\n    \\t\\tfor (char candidateChar : candidateChars) {\\n    \\t\\t\\tint row = candidateChar - \\'a\\';\\n    \\t\\t\\tint col = pos;\\n    \\t\\t\\t\\n    \\t\\t\\tcommonalityArray[row][col] = commonalityArray[row][col] + 1;\\n    \\t\\t\\t++pos;\\n    \\t\\t}\\n    \\t\\t\\t\\n    \\t}\\n    \\t\\n    \\tint maxScore = -1;\\n    \\tString bestCandidate = \"\";\\n    \\t\\n    \\tfor (int i = 0; i < candidates.size(); ++i) {\\n    \\t\\tString candidate = candidates.get(i);\\n    \\t\\tchar[] candidateChars = candidate.toCharArray();\\n    \\t\\tint current = 0;\\n    \\t\\tint pos = 0;\\n    \\t\\t\\n    \\t\\tfor (char candidateChar : candidateChars) {\\n    \\t\\t\\tcurrent += commonalityArray[candidateChar - \\'a\\'][pos];\\n    \\t\\t\\t++pos;\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tif (current > maxScore) {\\n    \\t\\t\\tmaxScore = current;\\n    \\t\\t\\tbestCandidate = candidate;\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\treturn bestCandidate;\\n\\t}\\n\\n\\tString getInitialWord(String[] wordlist) {\\n        Random random = new Random();   \\n        int selectedWordIndex = random.nextInt(wordlist.length);\\n\\n        return wordlist[selectedWordIndex];\\n    }\\n   \\n    List<String> getCandidates(String[] wordlist, String bestCandidate, int score) {\\n    \\tList<String> out = new ArrayList<>();\\n    \\t\\n    \\tfor (String word : wordlist) {\\n    \\t\\tint distance = calcDistance(word, bestCandidate);\\n    \\t\\t\\n    \\t\\tif (distance == score) {\\n    \\t\\t\\tout.add(word);\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\treturn out;\\n    }\\n    \\n    int calcDistance(String word1, String word2) {\\n    \\tchar[] word1Chars = word1.toCharArray();\\n    \\tchar[] word2Chars = word2.toCharArray();\\n    \\tint count = 0;\\n    \\t\\n    \\tfor (int i = 0; i < word1Chars.length; ++i) {\\n    \\t\\tif (word1Chars[i] == word2Chars[i]) {\\n    \\t\\t\\t++count;\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\treturn count;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589576,
                "title": "javascript-o-n-solution",
                "content": "```\\n// Returns the number of characters matched. \\n// (string, string) => number\\nfunction match\\u0421ounter(a, b) {\\n    let counter = 0;\\n    for (let i = 0; i < a.length; i++) {\\n        if (a[i] === b[i]) counter++;\\n    }          \\n    return counter;\\n}\\n\\nfunction findSecretWord(wordlist, master) {\\n    for (let attempt = 0, requestResult = 0; attempt < 10 && requestResult < 6; attempt++) {\\n        \\n        let count = Array.from({length:6}, item => Array.from({length:26}, i => 0));\\n        \\n        for (let word of wordlist) {\\n            for (let i = 0; i < 6; i++) {                \\n                count[i][word[i].charCodeAt(0)-97]++\\n            }\\n        }\\n        \\n        let bestScorePair = [wordlist[0], 0];\\n        for (let word of wordlist) {\\n            let score = 0;\\n            for (let i = 0; i < 6; i++) {\\n                score += count[i][word[i].charCodeAt(0)-97];\\n            }\\n            if (score > bestScorePair[1]) {\\n                bestScorePair = [word, score];                \\n            }\\n        }\\n        \\n        let request = bestScorePair[0];\\n        let requestResult = master.guess(request);\\n        wordlist = wordlist.filter(item => match\\u0421ounter(item, request) === requestResult); \\n        \\n    }\\n        \\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Returns the number of characters matched. \\n// (string, string) => number\\nfunction match\\u0421ounter(a, b) {\\n    let counter = 0;\\n    for (let i = 0; i < a.length; i++) {\\n        if (a[i] === b[i]) counter++;\\n    }          \\n    return counter;\\n}\\n\\nfunction findSecretWord(wordlist, master) {\\n    for (let attempt = 0, requestResult = 0; attempt < 10 && requestResult < 6; attempt++) {\\n        \\n        let count = Array.from({length:6}, item => Array.from({length:26}, i => 0));\\n        \\n        for (let word of wordlist) {\\n            for (let i = 0; i < 6; i++) {                \\n                count[i][word[i].charCodeAt(0)-97]++\\n            }\\n        }\\n        \\n        let bestScorePair = [wordlist[0], 0];\\n        for (let word of wordlist) {\\n            let score = 0;\\n            for (let i = 0; i < 6; i++) {\\n                score += count[i][word[i].charCodeAt(0)-97];\\n            }\\n            if (score > bestScorePair[1]) {\\n                bestScorePair = [word, score];                \\n            }\\n        }\\n        \\n        let request = bestScorePair[0];\\n        let requestResult = master.guess(request);\\n        wordlist = wordlist.filter(item => match\\u0421ounter(item, request) === requestResult); \\n        \\n    }\\n        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1570053,
                "title": "91-faster-koltin-solution-o-n-log-n",
                "content": "Sorting the list and taking the first and the last elements gives us the big advantage of having a very different words where we need to filter the list by two different match count which takes us closer to the solution.\\n\\n```kotlin\\nclass Solution {\\n    fun findSecretWord(wordlist: Array<String>, master: Master) {\\n        var words = wordlist.sorted()\\n        \\n        while(words.isNotEmpty()) {\\n            val firstGuessWord = words.first()\\n\\n            val firstMatchCount = master.guess(firstGuessWord)\\n            \\n            if(firstMatchCount == firstGuessWord.length) {\\n                return\\n            }\\n            \\n            words = words.filter {\\n                matchCount(firstGuessWord, it) == firstMatchCount\\n            }\\n            \\n            val lastGuessWord = words.last()\\n                                \\n            val lastMatchCount = master.guess(lastGuessWord)\\n            \\n            if(lastMatchCount == lastGuessWord.length) {\\n                return\\n            }\\n   \\n            words = words.filter {\\n                matchCount(lastGuessWord, it) == lastMatchCount\\n            }\\n        }\\n    }\\n    \\n    private fun matchCount(target: String, guess: String): Int {\\n        val size = minOf(target.length, guess.length)\\n        \\n        var count = 0\\n        for(i in 0 until size) {\\n            if(guess[i] == target[i]) {\\n                count++\\n            }\\n        }\\n        \\n        return count\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```kotlin\\nclass Solution {\\n    fun findSecretWord(wordlist: Array<String>, master: Master) {\\n        var words = wordlist.sorted()\\n        \\n        while(words.isNotEmpty()) {\\n            val firstGuessWord = words.first()\\n\\n            val firstMatchCount = master.guess(firstGuessWord)\\n            \\n            if(firstMatchCount == firstGuessWord.length) {\\n                return\\n            }\\n            \\n            words = words.filter {\\n                matchCount(firstGuessWord, it) == firstMatchCount\\n            }\\n            \\n            val lastGuessWord = words.last()\\n                                \\n            val lastMatchCount = master.guess(lastGuessWord)\\n            \\n            if(lastMatchCount == lastGuessWord.length) {\\n                return\\n            }\\n   \\n            words = words.filter {\\n                matchCount(lastGuessWord, it) == lastMatchCount\\n            }\\n        }\\n    }\\n    \\n    private fun matchCount(target: String, guess: String): Int {\\n        val size = minOf(target.length, guess.length)\\n        \\n        var count = 0\\n        for(i in 0 until size) {\\n            if(guess[i] == target[i]) {\\n                count++\\n            }\\n        }\\n        \\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555658,
                "title": "c-short-solution-85-99",
                "content": "```\\nclass Solution {\\n    public void FindSecretWord(string[] wordlist, Master master) {\\n        int matches = -1;\\n        var wl = wordlist.ToList();\\n        while (matches != 6) {\\n            string selected = wl.Count> 3? wl[3]: wl[0];\\n            matches = master.Guess(selected);\\n            wl.RemoveAll(x => x.Zip(selected, (x, y) => x == y ? \"\" : x.ToString()).ToList().RemoveAll(z => z == \"\") != matches);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void FindSecretWord(string[] wordlist, Master master) {\\n        int matches = -1;\\n        var wl = wordlist.ToList();\\n        while (matches != 6) {\\n            string selected = wl.Count> 3? wl[3]: wl[0];\\n            matches = master.Guess(selected);\\n            wl.RemoveAll(x => x.Zip(selected, (x, y) => x == y ? \"\" : x.ToString()).ToList().RemoveAll(z => z == \"\") != matches);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539109,
                "title": "0ms-golang-easy-solution",
                "content": "The basic idea is select a random word ( here I am selecting the first word in the list ) and call the guess function. Then you will be getting a result X; means you have X number of matches with the target word. \\n\\nFilter out all the words which is having a match != X with the first word. Do the same process until finding 6 matches.\\n\\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * type Master struct {\\n * }\\n *\\n * func (this *Master) Guess(word string) int {}\\n */\\nfunc findSecretWord(wordlist []string, master *Master) {\\n    ln := len(wordlist)\\n    for i := 0; i< 10; i++ {\\n        nMatches := master.Guess(wordlist[0])\\n        if nMatches == 6 {\\n            return\\n        }\\n        ln = reorganise(wordlist[0], wordlist, ln, nMatches)\\n    }\\n}\\n\\nfunc reorganise(matchWord string, wordList []string, ln, nMatches int) int{\\n    i := 0\\n    for  i< ln {\\n        if numberOfMatches(matchWord, wordList[i]) != nMatches {\\n            ln--\\n            wordList[i] = wordList[ln]\\n        }else {\\n            i++\\n        }\\n    }\\n    return ln\\n}\\n\\nfunc numberOfMatches(w1, w2 string) int {\\n    c := 0\\n    for i := range w1 {\\n        if w1[i] == w2[i] {\\n            c++\\n        }\\n    }\\n    return c\\n} \\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * type Master struct {\\n * }\\n *\\n * func (this *Master) Guess(word string) int {}\\n */\\nfunc findSecretWord(wordlist []string, master *Master) {\\n    ln := len(wordlist)\\n    for i := 0; i< 10; i++ {\\n        nMatches := master.Guess(wordlist[0])\\n        if nMatches == 6 {\\n            return\\n        }\\n        ln = reorganise(wordlist[0], wordlist, ln, nMatches)\\n    }\\n}\\n\\nfunc reorganise(matchWord string, wordList []string, ln, nMatches int) int{\\n    i := 0\\n    for  i< ln {\\n        if numberOfMatches(matchWord, wordList[i]) != nMatches {\\n            ln--\\n            wordList[i] = wordList[ln]\\n        }else {\\n            i++\\n        }\\n    }\\n    return ln\\n}\\n\\nfunc numberOfMatches(w1, w2 string) int {\\n    c := 0\\n    for i := range w1 {\\n        if w1[i] == w2[i] {\\n            c++\\n        }\\n    }\\n    return c\\n} \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1537806,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        candiates = wordlist\\n        out = 0\\n        while out < 6:\\n            w = candiates.pop(random.randrange(0, len(candiates)))\\n            out = master.guess(w)\\n            purge = []\\n            for i, c in enumerate(candiates):\\n                has_common = any([True for i in range(6) if w[i] == c[i]])\\n                if (out == 0 and has_common) or (out != 0 and not has_common):\\n                    purge.append(c)\\n            for k in purge:\\n                candiates.remove(k)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        candiates = wordlist\\n        out = 0\\n        while out < 6:\\n            w = candiates.pop(random.randrange(0, len(candiates)))\\n            out = master.guess(w)\\n            purge = []\\n            for i, c in enumerate(candiates):\\n                has_common = any([True for i in range(6) if w[i] == c[i]])\\n                if (out == 0 and has_common) or (out != 0 and not has_common):\\n                    purge.append(c)\\n            for k in purge:\\n                candiates.remove(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490888,
                "title": "javascript-modular-code",
                "content": "```\\nvar findSecretWord = function(wordlist, master) {\\n    let updatedList = wordlist;\\n    const match2Words = (word1, word2) => {\\n        let counter = 0;\\n        for(let g=0 ;g<6; g++){\\n            if(word1[g] == word2[g]) counter++;\\n        }\\n        \\n        return counter;\\n        \\n    }\\n    \\n    const removedRedundantData = (matchValue, word) => {\\n       let compressedList = []; \\n       for(let curWord of updatedList){\\n           if(curWord == word) continue; // no need to have same word again;\\n           let wordsMatch = match2Words(word, curWord);\\n           if( wordsMatch >= matchValue ) compressedList.push(curWord)\\n       }\\n        \\n      if(compressedList.length)\\n          updatedList = compressedList;\\n        \\n    }\\n    \\n    const searchInWordlist = (index) => {\\n        let match = master.guess(updatedList[index]);\\n        if(match == 6) return true;\\n        if(match > 0) removedRedundantData(match, updatedList[index]);\\n        return false;\\n    }\\n    \\n   \\n    \\n    const getIndexToSearch = () => {\\n        return Math.floor(Math.random() * updatedList.length);\\n    }\\n    \\n    for(let g=0; g<10; g++){ // As we can hit 10 iterations\\n        let res = searchInWordlist(getIndexToSearch());\\n        if(res) return;\\n    }\\n    \\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findSecretWord = function(wordlist, master) {\\n    let updatedList = wordlist;\\n    const match2Words = (word1, word2) => {\\n        let counter = 0;\\n        for(let g=0 ;g<6; g++){\\n            if(word1[g] == word2[g]) counter++;\\n        }\\n        \\n        return counter;\\n        \\n    }\\n    \\n    const removedRedundantData = (matchValue, word) => {\\n       let compressedList = []; \\n       for(let curWord of updatedList){\\n           if(curWord == word) continue; // no need to have same word again;\\n           let wordsMatch = match2Words(word, curWord);\\n           if( wordsMatch >= matchValue ) compressedList.push(curWord)\\n       }\\n        \\n      if(compressedList.length)\\n          updatedList = compressedList;\\n        \\n    }\\n    \\n    const searchInWordlist = (index) => {\\n        let match = master.guess(updatedList[index]);\\n        if(match == 6) return true;\\n        if(match > 0) removedRedundantData(match, updatedList[index]);\\n        return false;\\n    }\\n    \\n   \\n    \\n    const getIndexToSearch = () => {\\n        return Math.floor(Math.random() * updatedList.length);\\n    }\\n    \\n    for(let g=0; g<10; g++){ // As we can hit 10 iterations\\n        let res = searchInWordlist(getIndexToSearch());\\n        if(res) return;\\n    }\\n    \\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1486163,
                "title": "java-1ms-simple-solution-98-23-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Random rand = new Random();\\n        int n = wordlist.length;\\n        int cnt = 10;\\n        int guess = 0;\\n        while (cnt > 0 && n > 0 && guess != 6) {\\n            cnt--; \\n            int target = rand.nextInt(n);\\n            String targetStr = wordlist[target];\\n            guess = master.guess(wordlist[target]);\\n            for (int i = n - 1; i >= 0; i--) {\\n                if (i == target) {\\n                    swap(wordlist, i, n - 1);\\n                    n--;\\n                    continue;\\n                }\\n                if (likeness(targetStr, wordlist[i]) != guess) {\\n                    swap(wordlist, i, n - 1);\\n                    n--;\\n                }\\n            }\\n        }\\n    }\\n\\n    public void swap(String[] ls, int i, int j) {\\n        String temp = ls[i];\\n        ls[i] = ls[j];\\n        ls[j] = temp;\\n    }\\n\\n    public int likeness(String base, String w) {\\n        int ret = 0;\\n\\n        for (int i = 0; i < base.length(); i++) {\\n            if (base.charAt(i) == w.charAt(i)) {\\n                ret++;\\n            }\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Random rand = new Random();\\n        int n = wordlist.length;\\n        int cnt = 10;\\n        int guess = 0;\\n        while (cnt > 0 && n > 0 && guess != 6) {\\n            cnt--; \\n            int target = rand.nextInt(n);\\n            String targetStr = wordlist[target];\\n            guess = master.guess(wordlist[target]);\\n            for (int i = n - 1; i >= 0; i--) {\\n                if (i == target) {\\n                    swap(wordlist, i, n - 1);\\n                    n--;\\n                    continue;\\n                }\\n                if (likeness(targetStr, wordlist[i]) != guess) {\\n                    swap(wordlist, i, n - 1);\\n                    n--;\\n                }\\n            }\\n        }\\n    }\\n\\n    public void swap(String[] ls, int i, int j) {\\n        String temp = ls[i];\\n        ls[i] = ls[j];\\n        ls[j] = temp;\\n    }\\n\\n    public int likeness(String base, String w) {\\n        int ret = 0;\\n\\n        for (int i = 0; i < base.length(); i++) {\\n            if (base.charAt(i) == w.charAt(i)) {\\n                ret++;\\n            }\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399290,
                "title": "java-solution",
                "content": "```\\n\\t//Try to get the word with maximum matching characters at same index i (matching with other words from list)\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        for (int t = 0, matchCount = 0; t < 10 && matchCount < 6; ++t) {//Try at max 10 times and match count should be max 6 (as we have 6 character length strings only)\\n            int[][] charAtI = new int[6][26];\\n            for(String word: wordlist){\\n                for(int i =0;i < 6; i++){\\n                    charAtI[i][word.charAt(i)-\\'a\\'] += 1;// Get matching char at each index\\n                }\\n            }\\n            String mostMatching = wordlist[0];\\n            int max = 0;\\n            // Get word with best matching score with every other word\\n            for(String word: wordlist){\\n                int score = 0;\\n                for(int i =0;i < 6 ; i++){\\n                    score += charAtI[i][word.charAt(i) - \\'a\\'];\\n                }\\n                if(score > max){\\n                    max = score;\\n                    mostMatching = word;    \\n                }\\n            }\\n            matchCount = master.guess(mostMatching);\\n            List<String> next = new ArrayList();\\n            for(String word: wordlist){// get next with similar matching characters\\n                if(mostMatching != word && match(mostMatching,word) == matchCount){\\n                    next.add(word);    \\n                }    \\n            }\\n            wordlist = next.toArray(new String[next.size()]);// update next wordList\\n        }\\n    }\\n    \\n    private int match(String s1, String s2){\\n        int m = 0;\\n        int i = 0;\\n        while(i < s1.length()){\\n            if(s1.charAt(i) == s2.charAt(i)) m += 1;\\n            i += 1;\\n        }\\n        return m;\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\n\\t//Try to get the word with maximum matching characters at same index i (matching with other words from list)\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        for (int t = 0, matchCount = 0; t < 10 && matchCount < 6; ++t) {//Try at max 10 times and match count should be max 6 (as we have 6 character length strings only)\\n            int[][] charAtI = new int[6][26];\\n            for(String word: wordlist){\\n                for(int i =0;i < 6; i++){\\n                    charAtI[i][word.charAt(i)-\\'a\\'] += 1;// Get matching char at each index\\n                }\\n            }\\n            String mostMatching = wordlist[0];\\n            int max = 0;\\n            // Get word with best matching score with every other word\\n            for(String word: wordlist){\\n                int score = 0;\\n                for(int i =0;i < 6 ; i++){\\n                    score += charAtI[i][word.charAt(i) - \\'a\\'];\\n                }\\n                if(score > max){\\n                    max = score;\\n                    mostMatching = word;    \\n                }\\n            }\\n            matchCount = master.guess(mostMatching);\\n            List<String> next = new ArrayList();\\n            for(String word: wordlist){// get next with similar matching characters\\n                if(mostMatching != word && match(mostMatching,word) == matchCount){\\n                    next.add(word);    \\n                }    \\n            }\\n            wordlist = next.toArray(new String[next.size()]);// update next wordList\\n        }\\n    }\\n    \\n    private int match(String s1, String s2){\\n        int m = 0;\\n        int i = 0;\\n        while(i < s1.length()){\\n            if(s1.charAt(i) == s2.charAt(i)) m += 1;\\n            i += 1;\\n        }\\n        return m;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1369035,
                "title": "c-843-guess-the-word",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        srand(1); \\n        random_shuffle(wordlist.begin(), wordlist.end()); \\n        for (int step = 0; step < 10; ++step) \\n            if (wordlist.size()) {\\n                string w = wordlist.back(); \\n                wordlist.pop_back(); \\n                int m = master.guess(w); \\n                vector<string> temp; \\n                for (auto& ww : wordlist) {\\n                    int cnt = 0; \\n                    for (int i = 0; i < w.size(); ++i) \\n                        if (w[i] == ww[i]) ++cnt; \\n                    if (cnt == m) temp.push_back(ww); \\n                }\\n                wordlist = temp; \\n            }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        srand(1); \\n        random_shuffle(wordlist.begin(), wordlist.end()); \\n        for (int step = 0; step < 10; ++step) \\n            if (wordlist.size()) {\\n                string w = wordlist.back(); \\n                wordlist.pop_back(); \\n                int m = master.guess(w); \\n                vector<string> temp; \\n                for (auto& ww : wordlist) {\\n                    int cnt = 0; \\n                    for (int i = 0; i < w.size(); ++i) \\n                        if (w[i] == ww[i]) ++cnt; \\n                    if (cnt == m) temp.push_back(ww); \\n                }\\n                wordlist = temp; \\n            }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255889,
                "title": "java-solution-minimax",
                "content": "Sharing my solution referring to the the most votes solution by @lee215:  \\n\\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        int m = wordlist[0].length();\\n        int maxAttempt = 10;\\n        for (int attempt = 0; attempt < maxAttempt; attempt++) {\\n            // maximize the similarity of the word we are going to guess\\n            String guess = getStringToGuess(wordlist, wordlist.length, m);\\n            int x = master.guess(guess);\\n            // minimize the number of words we need to guess in next round\\n            List<String> temp = new ArrayList<>();\\n            for (String w : wordlist) {\\n                if (match(guess, w) == x) {\\n                    temp.add(w);\\n                }\\n            }\\n            wordlist = temp.toArray(new String[temp.size()]);\\n        }\\n    }\\n    \\n    private String getStringToGuess(String[] wordlist, int n, int m) {\\n        int[][] count = new int[m][26];\\n        for (String w : wordlist) {\\n            for (int i = 0; i < m; i++) {\\n                count[i][w.charAt(i) - \\'a\\']++;\\n            }\\n        }\\n        int highestSimilarity = 0;\\n        // random guess has ~80% of chance to get a word with 0 similarity wtih other words\\n        String guess = wordlist[new Random().nextInt(n)];\\n        for (String w : wordlist) {\\n            int similarity = 0;\\n            for (int i = 0; i < m; i++) {\\n                similarity += count[i][w.charAt(i) - \\'a\\'];\\n            }\\n            if (similarity > highestSimilarity) {\\n                highestSimilarity = similarity;\\n                guess = w;\\n            }\\n        }\\n        return guess;\\n    }\\n    \\n    private int match(String a, String b) {\\n        if (a == null || b == null || a.length() != b.length()) {\\n            return 0;\\n        }\\n        int match = 0;\\n        for (int i = 0; i < a.length(); i++) {\\n            if (a.charAt(i) == b.charAt(i)) {\\n                match++;\\n            }\\n        }\\n        return match;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        int m = wordlist[0].length();\\n        int maxAttempt = 10;\\n        for (int attempt = 0; attempt < maxAttempt; attempt++) {\\n            // maximize the similarity of the word we are going to guess\\n            String guess = getStringToGuess(wordlist, wordlist.length, m);\\n            int x = master.guess(guess);\\n            // minimize the number of words we need to guess in next round\\n            List<String> temp = new ArrayList<>();\\n            for (String w : wordlist) {\\n                if (match(guess, w) == x) {\\n                    temp.add(w);\\n                }\\n            }\\n            wordlist = temp.toArray(new String[temp.size()]);\\n        }\\n    }\\n    \\n    private String getStringToGuess(String[] wordlist, int n, int m) {\\n        int[][] count = new int[m][26];\\n        for (String w : wordlist) {\\n            for (int i = 0; i < m; i++) {\\n                count[i][w.charAt(i) - \\'a\\']++;\\n            }\\n        }\\n        int highestSimilarity = 0;\\n        // random guess has ~80% of chance to get a word with 0 similarity wtih other words\\n        String guess = wordlist[new Random().nextInt(n)];\\n        for (String w : wordlist) {\\n            int similarity = 0;\\n            for (int i = 0; i < m; i++) {\\n                similarity += count[i][w.charAt(i) - \\'a\\'];\\n            }\\n            if (similarity > highestSimilarity) {\\n                highestSimilarity = similarity;\\n                guess = w;\\n            }\\n        }\\n        return guess;\\n    }\\n    \\n    private int match(String a, String b) {\\n        if (a == null || b == null || a.length() != b.length()) {\\n            return 0;\\n        }\\n        int match = 0;\\n        for (int i = 0; i < a.length(); i++) {\\n            if (a.charAt(i) == b.charAt(i)) {\\n                match++;\\n            }\\n        }\\n        return match;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233161,
                "title": "c-100-pass-o-n-o-1",
                "content": "The core idea is the same as others in this discussion.\\nThe difference is this cleans up the original wordlist in place, so memory allocation is O(1), and after cleaning and compacting the original array the array gets semi-shuffled so all test cases (luckily?) passes.\\n\\nThe array gets semi-shuffled when compacting because empty slots at the beginning at filled with elements at the end.\\n\\n---\\n![image](https://assets.leetcode.com/users/images/bb98db5f-5c4b-42c8-96da-bce50d1d61f1_1622083867.5303264.png)\\n\\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *     public int Guess(string word);\\n * }\\n */\\nclass Solution {\\n    private static int MAXGUESSES = 10;\\n    private static int WORDLEN = 6;\\n        \\n    public void FindSecretWord(string[] wordlist, Master master) {        \\n       \\n        // let\\'s start calling Guess on the first word and see the score\\n        var score = master.Guess(wordlist[0]);\\n\\n        // this can\\'t exceed MAXGUESSES\\n        var callsToGuess = 1;\\n       \\n        // time to search for the secret word\\n        while (score < WORDLEN && callsToGuess < MAXGUESSES && wordlist.Length > 0) {\\n            \\n            this.CleanWordsAndCompact(wordlist, wordlist[0], score);\\n            \\n            // let\\'s try with a new word\\n            score = master.Guess(wordlist[0]);\\n            ++callsToGuess;\\n        }\\n    }\\n   \\n    private void CleanWordsAndCompact(string[] wordlist, string word, int score) {\\n\\t    // remove (assigning to null) all the words that are surely not correct\\n        for (var k = 0; k < wordlist.Length && wordlist[k] != null; ++k) {            \\n            if (word == wordlist[k] || this.Compare(word, wordlist[k]) != score) {\\n                wordlist[k] = null;\\n            }\\n        }\\n        \\n        var i = 0;\\n        var j = wordlist.Length - 1;\\n        \\n\\t\\t// compact the array moving all the elements together\\n        while (true) {\\n            while (i <= j && wordlist[i] != null) {\\n                ++i;\\n            }\\n            while (j > i && wordlist[j] == null) {\\n                --j;\\n            }\\n            \\n            if (j <= i) {\\n                break;\\n            }\\n            \\n            wordlist[i++] = wordlist[j];\\n            wordlist[j--] = null;\\n        }\\n    }    \\n\\n    private int Compare(string word1, string word2) {\\n        var sameChars = 0;\\n        for (var i = 0; i < word1.Length; ++i) {\\n            if (word1[i] == word2[i]) {\\n                ++sameChars;\\n            }\\n        }\\n        return sameChars;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *     public int Guess(string word);\\n * }\\n */\\nclass Solution {\\n    private static int MAXGUESSES = 10;\\n    private static int WORDLEN = 6;\\n        \\n    public void FindSecretWord(string[] wordlist, Master master) {        \\n       \\n        // let\\'s start calling Guess on the first word and see the score\\n        var score = master.Guess(wordlist[0]);\\n\\n        // this can\\'t exceed MAXGUESSES\\n        var callsToGuess = 1;\\n       \\n        // time to search for the secret word\\n        while (score < WORDLEN && callsToGuess < MAXGUESSES && wordlist.Length > 0) {\\n            \\n            this.CleanWordsAndCompact(wordlist, wordlist[0], score);\\n            \\n            // let\\'s try with a new word\\n            score = master.Guess(wordlist[0]);\\n            ++callsToGuess;\\n        }\\n    }\\n   \\n    private void CleanWordsAndCompact(string[] wordlist, string word, int score) {\\n\\t    // remove (assigning to null) all the words that are surely not correct\\n        for (var k = 0; k < wordlist.Length && wordlist[k] != null; ++k) {            \\n            if (word == wordlist[k] || this.Compare(word, wordlist[k]) != score) {\\n                wordlist[k] = null;\\n            }\\n        }\\n        \\n        var i = 0;\\n        var j = wordlist.Length - 1;\\n        \\n\\t\\t// compact the array moving all the elements together\\n        while (true) {\\n            while (i <= j && wordlist[i] != null) {\\n                ++i;\\n            }\\n            while (j > i && wordlist[j] == null) {\\n                --j;\\n            }\\n            \\n            if (j <= i) {\\n                break;\\n            }\\n            \\n            wordlist[i++] = wordlist[j];\\n            wordlist[j--] = null;\\n        }\\n    }    \\n\\n    private int Compare(string word1, string word2) {\\n        var sameChars = 0;\\n        for (var i = 0; i < word1.Length; ++i) {\\n            if (word1[i] == word2[i]) {\\n                ++sameChars;\\n            }\\n        }\\n        return sameChars;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220699,
                "title": "small-and-easy-to-understand-solution-in-java-using-treeset",
                "content": "```\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        TreeSet<String> words = new TreeSet<>(Arrays.asList(wordlist));\\n        \\n        while (!words.isEmpty()) {\\n            String word = words.pollFirst();\\n            \\n            // get the response back from api call\\n            int resp = master.guess(word);\\n            \\n            if (resp == 6) return;\\n            \\n            words.removeIf(wordInSet -> evaluate(wordInSet, word) != resp);\\n        }\\n        \\n        return;\\n    }\\n    \\n    // this method just counts how many chars at the same position two strings have in common\\n    private int evaluate(String s, String t) {\\n        int count = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == t.charAt(i)) count++;\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        TreeSet<String> words = new TreeSet<>(Arrays.asList(wordlist));\\n        \\n        while (!words.isEmpty()) {\\n            String word = words.pollFirst();\\n            \\n            // get the response back from api call\\n            int resp = master.guess(word);\\n            \\n            if (resp == 6) return;\\n            \\n            words.removeIf(wordInSet -> evaluate(wordInSet, word) != resp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1195283,
                "title": "o-n-randomized-solver-plus-sorting-faster-than-100-c-solution-lol",
                "content": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    bool exactMatch(std::string &word1, std::string &word2, int nMatch){\\n        \\n        int cnt = 0;\\n        for (int i = 0; i < 6; i++)\\n            if (word1[i] == word2[i])\\n                cnt++;\\n        \\n        if (cnt == nMatch)\\n            return true;\\n        return false;\\n    }\\n    \\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        \\n        vector<string> wordlist1, wordlist2;\\n        wordlist1 = wordlist;\\n        sort(wordlist1.begin(), wordlist1.end());\\n        int numTry = 0;\\n        while (numTry < 10){\\n            numTry++;\\n            \\n            int id = rand() % (int)wordlist1.size();\\n            int numMatch = master.guess(wordlist1[id]);\\n            if (numMatch == 6)\\n                return ;\\n            \\n            wordlist2.clear();\\n            for (int i = 0; i < (int)wordlist1.size(); i++)\\n                if (exactMatch(wordlist1[i], wordlist1[id], numMatch))\\n                    wordlist2.push_back(wordlist1[i]);\\n            \\n            wordlist1 = wordlist2;\\n        }\\n        \\n        return ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    bool exactMatch(std::string &word1, std::string &word2, int nMatch){\\n        \\n        int cnt = 0;\\n        for (int i = 0; i < 6; i++)\\n            if (word1[i] == word2[i])\\n                cnt++;\\n        \\n        if (cnt == nMatch)\\n            return true;\\n        return false;\\n    }\\n    \\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        \\n        vector<string> wordlist1, wordlist2;\\n        wordlist1 = wordlist;\\n        sort(wordlist1.begin(), wordlist1.end());\\n        int numTry = 0;\\n        while (numTry < 10){\\n            numTry++;\\n            \\n            int id = rand() % (int)wordlist1.size();\\n            int numMatch = master.guess(wordlist1[id]);\\n            if (numMatch == 6)\\n                return ;\\n            \\n            wordlist2.clear();\\n            for (int i = 0; i < (int)wordlist1.size(); i++)\\n                if (exactMatch(wordlist1[i], wordlist1[id], numMatch))\\n                    wordlist2.push_back(wordlist1[i]);\\n            \\n            wordlist1 = wordlist2;\\n        }\\n        \\n        return ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188594,
                "title": "cleaned-up-the-solution-in-java",
                "content": "I added comments and descriptive names so that I could understand the code from the solution.\\n\\n```\\nclass Solution {\\n    static public int countMatching(final String a, final String b) {\\n        int matches = 0;\\n        for (int i = 0; i < a.length(); ++i) {\\n            if (a.charAt(i) == b.charAt(i)) {\\n                ++matches;\\n            }\\n        }\\n        return matches;\\n    }\\n\\n    static void println(final String str) {\\n        System.out.println(str);\\n    }\\n\\n    int[][] matchingChars;\\n\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        // Build up a 2 dimensional matrix with the number of matching characters between the\\n        // two words indexed by i and j.\\n        int N = wordlist.length;\\n        matchingChars = new int[N][N];\\n        for (int i = 0; i < N; ++i)\\n            for (int j = i; j < N; ++j) {\\n                matchingChars[i][j] = matchingChars[j][i] = countMatching(wordlist[i], wordlist[j]);\\n            }\\n\\n        // Initialize the possible words list to have indexes for the full word list\\n        List<Integer> possible = new ArrayList();\\n        Set<Integer> impossible = new HashSet<>();\\n        for (int i = 0; i < N; ++i) {\\n            possible.add(i);\\n        }\\n\\n        while (!possible.isEmpty()) {\\n            int guess = chooseNextGuess(possible, impossible);\\n            int matches = master.guess(wordlist[guess]);\\n            // println(\"Guessed \" + wordlist[guess] + \"; \" + matches + \" characters matched.\");\\n            if (matches == wordlist[0].length()) {\\n                return;\\n            }\\n\\n            // Narrow down the possible list to words that have the same number of characters matching\\n            // with the last guess as the last guess has matches to the correct answer.\\n            List<Integer> possible2 = new ArrayList();\\n            for (Integer j: possible) {\\n                if (matchingChars[guess][j] == matches) {\\n                    possible2.add(j);\\n                }\\n                possible = possible2;\\n            }\\n\\n            impossible.add(guess);\\n        }\\n\\n    }\\n\\n    public int chooseNextGuess(List<Integer> possible, Set<Integer> impossible) {\\n        // println(\"\" + possible.size() + \" possible words remain.\");\\n\\n        if (possible.size() <= 2) {\\n            return possible.get(0);\\n        }\\n        List<Integer> bestGroup = possible;\\n        int bestGuess = -1;\\n\\n        for (int guess = 0; guess < matchingChars.length; ++guess) {\\n            if (!impossible.contains(guess)) {\\n                // Group all other words based on the number of characters that match\\n                // with guess\\n                Map<Integer, ArrayList<Integer>> groups = new HashMap<>();\\n                for (Integer j: possible)\\n                    if (j != guess) {\\n                        int matching = matchingChars[guess][j];\\n                        groups.compute(matching, (key, oldValue) -> {\\n                            if (oldValue == null) {\\n                                oldValue = new ArrayList<>();\\n                            }\\n                            oldValue.add(j);\\n                            return oldValue;\\n                        });\\n                    }\\n\\n                // Find the largest group\\n                List<Integer> largestGroup = Collections.EMPTY_LIST;\\n                for (List<Integer> group: groups.values())\\n                    if (group.size() > largestGroup.size()) {\\n                        largestGroup = group;\\n                    }\\n\\n                // Keep if this is smaller that the current best\\n                if (largestGroup.size() < bestGroup.size()) {\\n                    bestGroup = largestGroup;\\n                    bestGuess = guess;\\n                    // println(\"New min from a group of \" + bestGroup.size() + \" words.\");\\n                }\\n            }\\n        }\\n\\n        // println(\"Choose from a group of \" + bestGroup.size() + \" words.\");\\n        return bestGuess;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static public int countMatching(final String a, final String b) {\\n        int matches = 0;\\n        for (int i = 0; i < a.length(); ++i) {\\n            if (a.charAt(i) == b.charAt(i)) {\\n                ++matches;\\n            }\\n        }\\n        return matches;\\n    }\\n\\n    static void println(final String str) {\\n        System.out.println(str);\\n    }\\n\\n    int[][] matchingChars;\\n\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        // Build up a 2 dimensional matrix with the number of matching characters between the\\n        // two words indexed by i and j.\\n        int N = wordlist.length;\\n        matchingChars = new int[N][N];\\n        for (int i = 0; i < N; ++i)\\n            for (int j = i; j < N; ++j) {\\n                matchingChars[i][j] = matchingChars[j][i] = countMatching(wordlist[i], wordlist[j]);\\n            }\\n\\n        // Initialize the possible words list to have indexes for the full word list\\n        List<Integer> possible = new ArrayList();\\n        Set<Integer> impossible = new HashSet<>();\\n        for (int i = 0; i < N; ++i) {\\n            possible.add(i);\\n        }\\n\\n        while (!possible.isEmpty()) {\\n            int guess = chooseNextGuess(possible, impossible);\\n            int matches = master.guess(wordlist[guess]);\\n            // println(\"Guessed \" + wordlist[guess] + \"; \" + matches + \" characters matched.\");\\n            if (matches == wordlist[0].length()) {\\n                return;\\n            }\\n\\n            // Narrow down the possible list to words that have the same number of characters matching\\n            // with the last guess as the last guess has matches to the correct answer.\\n            List<Integer> possible2 = new ArrayList();\\n            for (Integer j: possible) {\\n                if (matchingChars[guess][j] == matches) {\\n                    possible2.add(j);\\n                }\\n                possible = possible2;\\n            }\\n\\n            impossible.add(guess);\\n        }\\n\\n    }\\n\\n    public int chooseNextGuess(List<Integer> possible, Set<Integer> impossible) {\\n        // println(\"\" + possible.size() + \" possible words remain.\");\\n\\n        if (possible.size() <= 2) {\\n            return possible.get(0);\\n        }\\n        List<Integer> bestGroup = possible;\\n        int bestGuess = -1;\\n\\n        for (int guess = 0; guess < matchingChars.length; ++guess) {\\n            if (!impossible.contains(guess)) {\\n                // Group all other words based on the number of characters that match\\n                // with guess\\n                Map<Integer, ArrayList<Integer>> groups = new HashMap<>();\\n                for (Integer j: possible)\\n                    if (j != guess) {\\n                        int matching = matchingChars[guess][j];\\n                        groups.compute(matching, (key, oldValue) -> {\\n                            if (oldValue == null) {\\n                                oldValue = new ArrayList<>();\\n                            }\\n                            oldValue.add(j);\\n                            return oldValue;\\n                        });\\n                    }\\n\\n                // Find the largest group\\n                List<Integer> largestGroup = Collections.EMPTY_LIST;\\n                for (List<Integer> group: groups.values())\\n                    if (group.size() > largestGroup.size()) {\\n                        largestGroup = group;\\n                    }\\n\\n                // Keep if this is smaller that the current best\\n                if (largestGroup.size() < bestGroup.size()) {\\n                    bestGroup = largestGroup;\\n                    bestGuess = guess;\\n                    // println(\"New min from a group of \" + bestGroup.size() + \" words.\");\\n                }\\n            }\\n        }\\n\\n        // println(\"Choose from a group of \" + bestGroup.size() + \" words.\");\\n        return bestGuess;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188528,
                "title": "python-easy-to-understand",
                "content": "```\\n# \"\"\"\\n# This is Master\\'s API interface.\\n# You should not implement it, or speculate about its implementation\\n# \"\"\"\\n# class Master:\\n#     def guess(self, word: str) -> int:\\n\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        def getMostCommon(wordList):\\n            wordCount = [[0] * 26] * 6\\n            for word in wordList:\\n                for index, letter in enumerate(word):\\n                    wordCount[index][ord(letter) - ord(\\'a\\')] += 1\\n            mostCommonWord = \"\"\\n            highestScore = 0\\n            \\n            for word in wordList:\\n                score = 0\\n                for index, letter in enumerate(word):\\n                    score += wordCount[index][ord(letter) - ord(\\'a\\')]\\n                if score > highestScore:\\n                    highestScore = score\\n                    mostCommonWord = word\\n            wordList.remove(mostCommonWord)\\n            return mostCommonWord\\n            \\n        def removeInvalid(wordlist, word, amount):\\n            filtered = []\\n            for wor in wordlist:\\n                i = 0\\n                for index, ch in enumerate(wor):\\n                    if word[index] == ch:\\n                        i += 1\\n                if i == amount:\\n                    filtered.append(wor)\\n            return filtered\\n        \\n        while wordlist:\\n            mostCommon = getMostCommon(wordlist)\\n            value = master.guess(mostCommon)\\n            if value == 6:\\n                return\\n            wordlist = removeInvalid(wordlist, mostCommon, value)\\n```",
                "solutionTags": [],
                "code": "```\\n# \"\"\"\\n# This is Master\\'s API interface.\\n# You should not implement it, or speculate about its implementation\\n# \"\"\"\\n# class Master:\\n#     def guess(self, word: str) -> int:\\n\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        def getMostCommon(wordList):\\n            wordCount = [[0] * 26] * 6\\n            for word in wordList:\\n                for index, letter in enumerate(word):\\n                    wordCount[index][ord(letter) - ord(\\'a\\')] += 1\\n            mostCommonWord = \"\"\\n            highestScore = 0\\n            \\n            for word in wordList:\\n                score = 0\\n                for index, letter in enumerate(word):\\n                    score += wordCount[index][ord(letter) - ord(\\'a\\')]\\n                if score > highestScore:\\n                    highestScore = score\\n                    mostCommonWord = word\\n            wordList.remove(mostCommonWord)\\n            return mostCommonWord\\n            \\n        def removeInvalid(wordlist, word, amount):\\n            filtered = []\\n            for wor in wordlist:\\n                i = 0\\n                for index, ch in enumerate(wor):\\n                    if word[index] == ch:\\n                        i += 1\\n                if i == amount:\\n                    filtered.append(wor)\\n            return filtered\\n        \\n        while wordlist:\\n            mostCommon = getMostCommon(wordlist)\\n            value = master.guess(mostCommon)\\n            if value == 6:\\n                return\\n            wordlist = removeInvalid(wordlist, mostCommon, value)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1177117,
                "title": "swift-solution-prioritize-candidates-by-their-similarities-to-others",
                "content": "Isn\\'t the fastest, but less guesswork or randomization\\nGist is that you do `master.guess(word)` on the words that are similar to other words in the wordlist. If there\\'s a 0 or 1 match you get to eliminate the greatest number of other candidates available.\\n```\\n    func findSecretWord(_ wordlist: [String], _ master: Master) {\\n        // Sort the list by how many others it\\'s associated with???\\n        var similarityTable = Array(repeating: Array(repeating: 0, count: wordlist.count), count: wordlist.count)\\n        for i in 0 ..< wordlist.count {\\n            for j in i + 1 ..< wordlist.count {\\n                let s = self.checkSimilarity(origWord: wordlist[i], newWord: wordlist[j])\\n                similarityTable[i][j] = s\\n                similarityTable[j][i] = s\\n            }\\n        }\\n        let sums = similarityTable.map({ $0.reduce(0, +) })\\n        var enumeratedWordList = Array(wordlist.enumerated())\\n        enumeratedWordList.sort(by:{(a, b) in\\n            return sums[a.0] > sums[b.0]\\n        })\\n\\t\\t// --- sort complete ---\\n\\t\\t\\n        var curWordList = enumeratedWordList.map({$0.1}) // ok this is now sorted\\n        var guessQuota = 10\\n        while guessQuota > 0 && curWordList.count > guessQuota {\\n            let lst = curWordList.removeFirst() \\n            let numMatches = master.guess(lst)\\n            guessQuota -= 1\\n            curWordList = curWordList.filter { self.checkSimilarity(origWord: lst, newWord: $0) == numMatches }\\n        }\\n        if guessQuota > 0 {\\n            for w in curWordList {\\n                master.guess(w)\\n            }\\n        }\\n    }\\n    \\n    func checkSimilarity(origWord: String, newWord: String) -> Int {\\n        let ow:[Character] = Array(origWord)\\n        let nw:[Character] = Array(newWord)\\n        var matches = 0\\n        for i in 0 ..< ow.count {\\n            if ow[i] == nw[i] {\\n                matches += 1\\n            }\\n        }\\n        return matches\\n    }\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n    func findSecretWord(_ wordlist: [String], _ master: Master) {\\n        // Sort the list by how many others it\\'s associated with???\\n        var similarityTable = Array(repeating: Array(repeating: 0, count: wordlist.count), count: wordlist.count)\\n        for i in 0 ..< wordlist.count {\\n            for j in i + 1 ..< wordlist.count {\\n                let s = self.checkSimilarity(origWord: wordlist[i], newWord: wordlist[j])\\n                similarityTable[i][j] = s\\n                similarityTable[j][i] = s\\n            }\\n        }\\n        let sums = similarityTable.map({ $0.reduce(0, +) })\\n        var enumeratedWordList = Array(wordlist.enumerated())\\n        enumeratedWordList.sort(by:{(a, b) in\\n            return sums[a.0] > sums[b.0]\\n        })\\n\\t\\t// --- sort complete ---\\n\\t\\t\\n        var curWordList = enumeratedWordList.map({$0.1}) // ok this is now sorted\\n        var guessQuota = 10\\n        while guessQuota > 0 && curWordList.count > guessQuota {\\n            let lst = curWordList.removeFirst() \\n            let numMatches = master.guess(lst)\\n            guessQuota -= 1\\n            curWordList = curWordList.filter { self.checkSimilarity(origWord: lst, newWord: $0) == numMatches }\\n        }\\n        if guessQuota > 0 {\\n            for w in curWordList {\\n                master.guess(w)\\n            }\\n        }\\n    }\\n    \\n    func checkSimilarity(origWord: String, newWord: String) -> Int {\\n        let ow:[Character] = Array(origWord)\\n        let nw:[Character] = Array(newWord)\\n        var matches = 0\\n        for i in 0 ..< ow.count {\\n            if ow[i] == nw[i] {\\n                matches += 1\\n            }\\n        }\\n        return matches\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1124996,
                "title": "easy-java-solution",
                "content": "\\n```java\\nclass Solution {\\n    private Map<String, Integer> probs;\\n\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        probs = new HashMap<>();\\n\\n        for (String word : wordlist) {\\n            probs.put(word, 0);\\n        }\\n\\n        int matches = 0;\\n        int guessed = 0;\\n        while (matches != 6 && guessed < 10) {\\n            String word = pollWord();\\n            matches = master.guess(word);\\n            calcWeights(word, matches);\\n            guessed ++;\\n        }\\n    }\\n    \\n    private void calcWeights(String word, int matches) {\\n        for (String w : probs.keySet()) {\\n            int n = 0;\\n            for (int i = 0; i < word.length(); i ++) {\\n                if (word.charAt(i) == w.charAt(i))\\n                    n ++;\\n            }\\n            if (n == matches)\\n                probs.put(w, probs.getOrDefault(w, 0) + 1);\\n        }\\n    }\\n    \\n    private String pollWord() {\\n        Map.Entry<String, Integer> entry = probs.entrySet().stream()\\n            .max(Comparator.comparing(Map.Entry::getValue))\\n            .get();\\n        probs.remove(entry.getKey());\\n        return entry.getKey();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    private Map<String, Integer> probs;\\n\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        probs = new HashMap<>();\\n\\n        for (String word : wordlist) {\\n            probs.put(word, 0);\\n        }\\n\\n        int matches = 0;\\n        int guessed = 0;\\n        while (matches != 6 && guessed < 10) {\\n            String word = pollWord();\\n            matches = master.guess(word);\\n            calcWeights(word, matches);\\n            guessed ++;\\n        }\\n    }\\n    \\n    private void calcWeights(String word, int matches) {\\n        for (String w : probs.keySet()) {\\n            int n = 0;\\n            for (int i = 0; i < word.length(); i ++) {\\n                if (word.charAt(i) == w.charAt(i))\\n                    n ++;\\n            }\\n            if (n == matches)\\n                probs.put(w, probs.getOrDefault(w, 0) + 1);\\n        }\\n    }\\n    \\n    private String pollWord() {\\n        Map.Entry<String, Integer> entry = probs.entrySet().stream()\\n            .max(Comparator.comparing(Map.Entry::getValue))\\n            .get();\\n        probs.remove(entry.getKey());\\n        return entry.getKey();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100116,
                "title": "simple-c-soln-using-set",
                "content": "We match the words with the same character equal count and remove the rest from the set\\n``` \\nclass Solution {\\npublic:\\n    int countMatches(const string& word1, const string& word2){\\n        int count=0;\\n        for(int i=0;i<word1.size();i++)\\n        {\\n            if(word1[i]==word2[i])\\n                count++;\\n        }\\n        return count;\\n    }\\n    \\n    void Prune(const string& word, const int& n, set<string>& wlist){\\n        set<string> wtoDel;\\n        for(const auto& element:wlist){\\n            if(countMatches(element,word)!=n)\\n                wtoDel.insert(element);\\n        }\\n        for(const auto& element:wtoDel)\\n        {\\n            wlist.erase(element);\\n        }\\n    }\\n    \\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        set<string> wlist{wordlist.begin(),wordlist.end()};\\n        int c=0;\\n        while(!wlist.empty() && c<10)\\n        {\\n            int n = master.guess(*wlist.begin());\\n            Prune(*wlist.begin(),n,wlist);\\n            c++;\\n        }\\n    }\\n}; \\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution {\\npublic:\\n    int countMatches(const string& word1, const string& word2){\\n        int count=0;\\n        for(int i=0;i<word1.size();i++)\\n        {\\n            if(word1[i]==word2[i])\\n                count++;\\n        }\\n        return count;\\n    }\\n    \\n    void Prune(const string& word, const int& n, set<string>& wlist){\\n        set<string> wtoDel;\\n        for(const auto& element:wlist){\\n            if(countMatches(element,word)!=n)\\n                wtoDel.insert(element);\\n        }\\n        for(const auto& element:wtoDel)\\n        {\\n            wlist.erase(element);\\n        }\\n    }\\n    \\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        set<string> wlist{wordlist.begin(),wordlist.end()};\\n        int c=0;\\n        while(!wlist.empty() && c<10)\\n        {\\n            int n = master.guess(*wlist.begin());\\n            Prune(*wlist.begin(),n,wlist);\\n            c++;\\n        }\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098985,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {    \\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Set<String> words = new HashSet<>(Arrays.asList(wordlist));             \\n        Integer currentMatching = 0;\\n        while (true) {\\n            String curWord = null;\\n            for (String s: words) {\\n                curWord = s;\\n                currentMatching = master.guess(s);\\n                if (currentMatching == 6) return;                \\n                break;                                \\n            }\\n            Iterator it = words.iterator();\\n            while (it.hasNext()) {                \\n                if (!kMatchingSamePositions(curWord, (String)it.next(), currentMatching)) {\\n                    it.remove();\\n                }                \\n            }\\n            words.remove(curWord);\\n        }        \\n    }\\n    \\n    public boolean kMatchingSamePositions(String word, String str, int k) {\\n        int cnt = 0;\\n        for (int i=0; i<6; i++) {\\n            if (str.charAt(i) == word.charAt(i)) {\\n                cnt++;\\n            }\\n        }\\n        return k == cnt;       \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {    \\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Set<String> words = new HashSet<>(Arrays.asList(wordlist));             \\n        Integer currentMatching = 0;\\n        while (true) {\\n            String curWord = null;\\n            for (String s: words) {\\n                curWord = s;\\n                currentMatching = master.guess(s);\\n                if (currentMatching == 6) return;                \\n                break;                                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1072778,
                "title": "beats-100-python-solution",
                "content": "While looking at questions, try to understand why various aspects of the question are given. For eg, i solved the problem in following steps:\\n[1] suppose the wordlist only contains a \\'single word\\', i.e. secret. You cannot access this word list. All you can do is bruteforce a single 6 lettered word, until it matches the secret. \\nGiven these constraints, what is the minimum no of moves you need to make to solve the problem?\\n\\nTo calculate these moves, i started off with a dp solution in mind. Suppose, a string is obtained, s.t. 5 characters of it match, and 1 character does not match. \\nFor eg, \\nsuppose guessed word is abcdez\\nsecret is abcdez, how do we reach the correct word, abcdef from acbdez. \\nHere, as you can see the match api, would return 5 (since abcde) match.\\nWhat is the minimum no of operations you wanna need in this case?\\nTo solve this, you need to find answer to two things:\\n[1] What is the exact \\'character\\' in the guessed word which presents an error. so, for our guess,(abcdez), the character \\'z\\' is the culprit. We need to find this position (i.e. sixth letter) and make it a \\'f\\'. So, suppose we manage to find this 6th position. And want to convert it from \\'z\\' to \\'f\\'. How can we do that? The worst case is to bruterforce from z,a,b,c,...... till we reach characters. Hence, it shall take minimum 24 operations to get this particular letter. \\n[2] As soon as it became clear, it hit me. i.e. asking to find the secret in less than 10 moves must be far fetched. So,next i tried to think in terms of graphs. \\nImagine a six lettered word which represents a secret. Then, at the next graph level would lie \\'all the words\\' whose 5 characters match. Finally, at the fifth level there would be words whose \\'none of the characters match\\'. What i needed then, was to search for a way to start from the fifth level and converge towards the initial level i.e. the word of six perfect matches [i.e. the secret word]. However, moving backward in the graph is generally impossible unless you possess parent pointers. \\n\\nThis is where, the approach of matching words became clear.\\nSuppose your guessed word is of the form XX- - - - , where X denotes the \\'perfectly matching word\\'. Then, a candidate word, whose 3 characters match, must be of the form XX-Y-- i.e. XX of previous word should match, and Y can be anything. So, this is the criteria i used for filtering the words. \\nThis beats 100% of the solutions here. \\n```\\n# \"\"\"\\n# This is Master\\'s API interface.\\n# You should not implement it, or speculate about its implementation\\n# \"\"\"\\n# class Master:\\n#     def guess(self, word: str) -> int:\\nimport random \\n\\nclass Solution:\\n    def no_of_matches(self,word1, word2):\\n        #checking the number of matches \\n        matches = 0\\n        for i in range(6):\\n            if word1[i]==word2[i]: matches+=1\\n        return matches\\n    \\n    #you only wanna call the function on the words which retain at least the number of matches with the current word in the wordlist\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        \\n        #get the no of trials you can call the secret for \\n        n_trials =10\\n        #shuffling once is fine \\n        random.shuffle(wordlist)\\n        for i in range(n_trials):\\n            #shuffle the wordlist \\n            #choose intial elements \\n            if wordlist!=[]:\\n                n_matches = master.guess(wordlist[0])\\n\\n            #create a new wordlist, who match \\'at least\\', the characters in this guy \\n            new_wordlist = []\\n            for word in wordlist[1:]:\\n                #compute matchds \\n                curr_matches = self.no_of_matches(word,wordlist[0])\\n                if curr_matches ==n_matches:\\n                    #keep that word in the new wordlist \\n                    new_wordlist.append(word)\\n            #reinitialize the wordlist \\n            wordlist = new_wordlist\\n```\\n",
                "solutionTags": [],
                "code": "```\\n# \"\"\"\\n# This is Master\\'s API interface.\\n# You should not implement it, or speculate about its implementation\\n# \"\"\"\\n# class Master:\\n#     def guess(self, word: str) -> int:\\nimport random \\n\\nclass Solution:\\n    def no_of_matches(self,word1, word2):\\n        #checking the number of matches \\n        matches = 0\\n        for i in range(6):\\n            if word1[i]==word2[i]: matches+=1\\n        return matches\\n    \\n    #you only wanna call the function on the words which retain at least the number of matches with the current word in the wordlist\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        \\n        #get the no of trials you can call the secret for \\n        n_trials =10\\n        #shuffling once is fine \\n        random.shuffle(wordlist)\\n        for i in range(n_trials):\\n            #shuffle the wordlist \\n            #choose intial elements \\n            if wordlist!=[]:\\n                n_matches = master.guess(wordlist[0])\\n\\n            #create a new wordlist, who match \\'at least\\', the characters in this guy \\n            new_wordlist = []\\n            for word in wordlist[1:]:\\n                #compute matchds \\n                curr_matches = self.no_of_matches(word,wordlist[0])\\n                if curr_matches ==n_matches:\\n                    #keep that word in the new wordlist \\n                    new_wordlist.append(word)\\n            #reinitialize the wordlist \\n            wordlist = new_wordlist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1025258,
                "title": "c-iterative-method-easy-to-understand",
                "content": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        \\n        if ( wordlist.size() == 0 )\\n        {\\n            return;\\n        }\\n        \\n        // randomly select a choice \\n        int index = rand()%wordlist.size();\\n        \\n        int value = master.guess(wordlist[index]);\\n        \\n        // used the guess as a hash, and measure the other words distance against it\\n        string hashw = wordlist[index];\\n        \\n        // if the current guess is not good, erase the record \\n        // that will help eliminate an item with all equal distance \\n        if ( value != 6 )\\n        {\\n            wordlist.erase(wordlist.begin() + index);\\n        }\\n        else \\n        {\\n            return;\\n        }\\n        \\n       \\n        \\n\\n\\n        vector<int>product(wordlist.size(), 0 );\\n        \\n\\n        \\n        for ( int j = 0; j < wordlist.size(); j++ )\\n        {\\n          \\n          string word = wordlist[j];\\n            \\n             // calculate the distance of each wordlist against the last guess \\n             for ( int k = 0; k < 6; k++ )\\n             {\\n                 if ( word[k] == hashw[k] )\\n                 {\\n                    product[j]++;\\n                 }\\n             }\\n          \\n            \\n          \\n            \\n        }\\n        \\n        vector<string>wl; \\n        for ( int i = 0; i < wordlist.size(); i++ )\\n        {\\n           // if the distance to the last guess equal to the distance of mysterious word\\n           // save it and reiterate the remaining list \\n           if ( product[i] == value )\\n           {\\n              wl.push_back(wordlist[i]);\\n           }\\n        }\\n        \\n        \\n        findSecretWord( wl, master);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        \\n        if ( wordlist.size() == 0 )\\n        {\\n            return;\\n        }\\n        \\n        // randomly select a choice \\n        int index = rand()%wordlist.size();\\n        \\n        int value = master.guess(wordlist[index]);\\n        \\n        // used the guess as a hash, and measure the other words distance against it\\n        string hashw = wordlist[index];\\n        \\n        // if the current guess is not good, erase the record \\n        // that will help eliminate an item with all equal distance \\n        if ( value != 6 )\\n        {\\n            wordlist.erase(wordlist.begin() + index);\\n        }\\n        else \\n        {\\n            return;\\n        }\\n        \\n       \\n        \\n\\n\\n        vector<int>product(wordlist.size(), 0 );\\n        \\n\\n        \\n        for ( int j = 0; j < wordlist.size(); j++ )\\n        {\\n          \\n          string word = wordlist[j];\\n            \\n             // calculate the distance of each wordlist against the last guess \\n             for ( int k = 0; k < 6; k++ )\\n             {\\n                 if ( word[k] == hashw[k] )\\n                 {\\n                    product[j]++;\\n                 }\\n             }\\n          \\n            \\n          \\n            \\n        }\\n        \\n        vector<string>wl; \\n        for ( int i = 0; i < wordlist.size(); i++ )\\n        {\\n           // if the distance to the last guess equal to the distance of mysterious word\\n           // save it and reiterate the remaining list \\n           if ( product[i] == value )\\n           {\\n              wl.push_back(wordlist[i]);\\n           }\\n        }\\n        \\n        \\n        findSecretWord( wl, master);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000913,
                "title": "evolve-from-intuition",
                "content": "1. Naive approach\\n```\\n\\tpublic void findSecretWord(String[] wordlist, Master master) {\\n        for(String word:wordlist) {\\n            master.guess(word);\\n        }\\n    }\\n```\\n2. Pruning. #1 does not even use the number of matches returned from guess. We can use it to prune the wordlist.\\n```\\n\\tpublic void findSecretWord(String[] wordlist, Master master) {\\n        int n=wordlist.length;\\n        boolean[] excl=new boolean[n]; \\n        for(int i=0;i<n;i++) {\\n            if(excl[i]) continue;\\n            int match=master.guess(wordlist[i]);\\n            for(int j=i+1;j<n;j++) {\\n                if(matches(wordlist[i],wordlist[j])!=match) \\n                    excl[j]=true;\\n            }\\n        }\\n    }\\n    private int matches(String s1, String s2) {\\n        int match=0;\\n        for(int i=0;i<s1.length();i++)\\n            if(s1.charAt(i)==s2.charAt(i))\\n                match++;\\n        return match;\\n    }\\n```\\n3. Math. In #2, we always pick the first un-deleted word to guess. For two random words, the probability that they have 0 matches is (25/26)^6 = 79%. So we get 0 from guess most of the time and the guess word has 0 matches with most words. This means we only eleminate few words after each guess. No matter how we pick the word, guess will always return 0. Thus we can pick a word that has the fewest zero matches with the list so that we can filter max number of words.\\n```\\n\\tprivate int LEN = 6;\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        int matches = 0;\\n        List<String> words = Arrays.asList(wordlist);\\n        while(matches !=LEN) {\\n            String guess = pickWord(words);\\n            matches = master.guess(guess);\\n            if(matches == LEN) {\\n                return;\\n            }\\n            words = elimination(matches, guess, words);\\n        }\\n    }\\n    private String pickWord(List<String> words) {\\n        int n = words.size(), max=0, index=0;\\n        int[] count = new int[n];\\n        for(int i=0;i<n;i++) {\\n            String si = words.get(i);\\n            for(int j=i+1;j<n;j++) {\\n                if(matches(si, words.get(j))>0) {\\n                    count[i]++;\\n                    count[j]++;\\n                }\\n            }\\n            if(count[i]>max) {\\n                max = count[i];\\n                index = i;\\n            }\\n        }\\n        return words.get(index);\\n    }\\n    private List<String> elimination(int matches, String guess, List<String> words) {\\n        List<String> pruned = new ArrayList<>();\\n        for(String word:words) {\\n            if(matches(word, guess)==matches) {\\n                pruned.add(word);\\n            }    \\n        }\\n        return pruned;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic void findSecretWord(String[] wordlist, Master master) {\\n        for(String word:wordlist) {\\n            master.guess(word);\\n        }\\n    }\\n```\n```\\n\\tpublic void findSecretWord(String[] wordlist, Master master) {\\n        int n=wordlist.length;\\n        boolean[] excl=new boolean[n]; \\n        for(int i=0;i<n;i++) {\\n            if(excl[i]) continue;\\n            int match=master.guess(wordlist[i]);\\n            for(int j=i+1;j<n;j++) {\\n                if(matches(wordlist[i],wordlist[j])!=match) \\n                    excl[j]=true;\\n            }\\n        }\\n    }\\n    private int matches(String s1, String s2) {\\n        int match=0;\\n        for(int i=0;i<s1.length();i++)\\n            if(s1.charAt(i)==s2.charAt(i))\\n                match++;\\n        return match;\\n    }\\n```\n```\\n\\tprivate int LEN = 6;\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        int matches = 0;\\n        List<String> words = Arrays.asList(wordlist);\\n        while(matches !=LEN) {\\n            String guess = pickWord(words);\\n            matches = master.guess(guess);\\n            if(matches == LEN) {\\n                return;\\n            }\\n            words = elimination(matches, guess, words);\\n        }\\n    }\\n    private String pickWord(List<String> words) {\\n        int n = words.size(), max=0, index=0;\\n        int[] count = new int[n];\\n        for(int i=0;i<n;i++) {\\n            String si = words.get(i);\\n            for(int j=i+1;j<n;j++) {\\n                if(matches(si, words.get(j))>0) {\\n                    count[i]++;\\n                    count[j]++;\\n                }\\n            }\\n            if(count[i]>max) {\\n                max = count[i];\\n                index = i;\\n            }\\n        }\\n        return words.get(index);\\n    }\\n    private List<String> elimination(int matches, String guess, List<String> words) {\\n        List<String> pruned = new ArrayList<>();\\n        for(String word:words) {\\n            if(matches(word, guess)==matches) {\\n                pruned.add(word);\\n            }    \\n        }\\n        return pruned;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 997390,
                "title": "random-selection-elimination",
                "content": "1. Select a random word\\n2. Test it\\n3. Reduce the sample size based on the match by elimination for next interation\\n4. Continue\\n\\n```\\nclass Solution {\\n    int getMatched(string left, string right) {\\n        int matched = 0;\\n        for(int i = 0; i < left.size(); i++) {\\n            if (left[i] == right[i]) {\\n                matched++;\\n            }\\n        }\\n        return matched;\\n    }\\n    \\n    vector<string> getNextList(vector<string>& wordlist, string current, int matched) {\\n        vector<string> toReturn;\\n        \\n        for(string str: wordlist) {\\n            if (getMatched(str, current) == matched) {\\n                toReturn.push_back(str);\\n            }\\n        }\\n        \\n        return toReturn;\\n    }\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        int index = rand() % wordlist.size();\\n        int matched = master.guess(wordlist[index]);\\n        if (matched == wordlist.front().size()) {\\n            return;\\n        }\\n        \\n        auto nextlist = getNextList(wordlist, wordlist[index], matched);\\n        findSecretWord(nextlist, master);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int getMatched(string left, string right) {\\n        int matched = 0;\\n        for(int i = 0; i < left.size(); i++) {\\n            if (left[i] == right[i]) {\\n                matched++;\\n            }\\n        }\\n        return matched;\\n    }\\n    \\n    vector<string> getNextList(vector<string>& wordlist, string current, int matched) {\\n        vector<string> toReturn;\\n        \\n        for(string str: wordlist) {\\n            if (getMatched(str, current) == matched) {\\n                toReturn.push_back(str);\\n            }\\n        }\\n        \\n        return toReturn;\\n    }\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        int index = rand() % wordlist.size();\\n        int matched = master.guess(wordlist[index]);\\n        if (matched == wordlist.front().size()) {\\n            return;\\n        }\\n        \\n        auto nextlist = getNextList(wordlist, wordlist[index], matched);\\n        findSecretWord(nextlist, master);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993576,
                "title": "simple-python-solution",
                "content": "\\n\\tclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        \\n        # this function returns bag of words such that (key U wordList) == iou\\n        def find_matches(key,list_bag,iou): \\n            ans=[]\\n            for ech in list_bag:\\n                ctr = 0\\n                for a,b in zip(key,ech):\\n                    if a==b:\\n                        ctr +=1\\n                if ctr == iou:\\n                    ans.append(\"\".join(ech))\\n            return ans\\n        \\n        iou = 0\\n        seen = []\\n        new_bag = wordlist\\n        total_count = 0\\n        \\n        while 1:    \\n            cur = random.choice(new_bag)\\n            if cur not in seen:\\n                seen.append(cur)\\n                iou = master.guess(cur)\\n                total_count +=1\\n                if iou == 6:\\n                    return cur\\n                elif iou > 0:\\n                    matches = find_matches(cur,wordlist,iou)\\n                    new_bag = list(set(new_bag) & set(matches))\\n                elif iou ==0: #!  if there is no intersection then eliminate all words with iou = 1 with the cur\\n                    matches = find_matches(cur,wordlist,1)\\n                    seen.extend(matches)",
                "solutionTags": [],
                "code": "\\n\\tclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        \\n        # this function returns bag of words such that (key U wordList) == iou\\n        def find_matches(key,list_bag,iou): \\n            ans=[]\\n            for ech in list_bag:\\n                ctr = 0\\n                for a,b in zip(key,ech):\\n                    if a==b:\\n                        ctr +=1\\n                if ctr == iou:\\n                    ans.append(\"\".join(ech))\\n            return ans\\n        \\n        iou = 0\\n        seen = []\\n        new_bag = wordlist\\n        total_count = 0\\n        \\n        while 1:    \\n            cur = random.choice(new_bag)\\n            if cur not in seen:\\n                seen.append(cur)\\n                iou = master.guess(cur)\\n                total_count +=1\\n                if iou == 6:\\n                    return cur\\n                elif iou > 0:\\n                    matches = find_matches(cur,wordlist,iou)\\n                    new_bag = list(set(new_bag) & set(matches))\\n                elif iou ==0: #!  if there is no intersection then eliminate all words with iou = 1 with the cur\\n                    matches = find_matches(cur,wordlist,1)\\n                    seen.extend(matches)",
                "codeTag": "Java"
            },
            {
                "id": 991773,
                "title": "c-beats-100-random-guess",
                "content": "Just pruning out words after each call.\\n```\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        for(int i=0; i<10; i++) {\\n            int guessIndex = rand() % wordlist.size();\\n            int value = master.guess(wordlist[guessIndex]);\\n            if(value==6) break;\\n            if(value==-1) wordlist.erase(wordlist.begin()+guessIndex);\\n            else wordlist=generateMatch(wordlist[guessIndex], value, wordlist);\\n        }\\n    }\\n    \\n    vector<string> generateMatch(string s, int n, vector<string> wordlist) {\\n        vector<string> result;\\n        for(int i=0; i<wordlist.size(); i++) {\\n            int match=0;\\n            for(int j=0; j<6; j++) {\\n                if(s[j]==wordlist[i][j]) match++;\\n            }\\n            if(match==n) result.push_back(wordlist[i]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        for(int i=0; i<10; i++) {\\n            int guessIndex = rand() % wordlist.size();\\n            int value = master.guess(wordlist[guessIndex]);\\n            if(value==6) break;\\n            if(value==-1) wordlist.erase(wordlist.begin()+guessIndex);\\n            else wordlist=generateMatch(wordlist[guessIndex], value, wordlist);\\n        }\\n    }\\n    \\n    vector<string> generateMatch(string s, int n, vector<string> wordlist) {\\n        vector<string> result;\\n        for(int i=0; i<wordlist.size(); i++) {\\n            int match=0;\\n            for(int j=0; j<6; j++) {\\n                if(s[j]==wordlist[i][j]) match++;\\n            }\\n            if(match==n) result.push_back(wordlist[i]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975836,
                "title": "c-solution-faster-than-100-but-needs-an-explanation",
                "content": "Hi all,\\n\\nI came up with this solution, but I cannot convince myself that this will work for every cases, even though it passed the 6 tests.\\n\\nCan someone help me explain this solution mathematically and proof if it will always work or not?\\n\\nThank you!\\n\\n```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        for(int i = 0; i<10; i++){\\n            vector<string> words;\\n\\t\\t\\t// random pick a word and guess it with secret word\\n            string referenceWord = wordlist[rand()%wordlist.size()];\\n            int score = master.guess(referenceWord);\\n\\n            if(score == 6){\\n                return;\\n            }\\n\\t\\t\\t// if the score if not 6 then we loop through the wordlist \\n\\t\\t\\t// and keep only the word with the same score, secret word will be kept \\n\\t\\t\\t// in the list for next guess.\\n            for(int j = 0; j < wordlist.size();j++){\\n                if(calculateScore(referenceWord, wordlist[j]) == score){\\n                    words.push_back(wordlist[j]);\\n                }\\n            }\\n            wordlist = words;\\n        }\\n        \\n    }\\n    \\n    int calculateScore(string& w1, string& w2){\\n        int s = 0;\\n        for(int i = 0; i< w1.size();i++){\\n            if(w1[i]==w2[i]){\\n                s++;\\n            }\\n        }\\n        return s;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * class Master {\\n *   public:\\n *     int guess(string word);\\n * };\\n */\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        for(int i = 0; i<10; i++){\\n            vector<string> words;\\n\\t\\t\\t// random pick a word and guess it with secret word\\n            string referenceWord = wordlist[rand()%wordlist.size()];\\n            int score = master.guess(referenceWord);\\n\\n            if(score == 6){\\n                return;\\n            }\\n\\t\\t\\t// if the score if not 6 then we loop through the wordlist \\n\\t\\t\\t// and keep only the word with the same score, secret word will be kept \\n\\t\\t\\t// in the list for next guess.\\n            for(int j = 0; j < wordlist.size();j++){\\n                if(calculateScore(referenceWord, wordlist[j]) == score){\\n                    words.push_back(wordlist[j]);\\n                }\\n            }\\n            wordlist = words;\\n        }\\n        \\n    }\\n    \\n    int calculateScore(string& w1, string& w2){\\n        int s = 0;\\n        for(int i = 0; i< w1.size();i++){\\n            if(w1[i]==w2[i]){\\n                s++;\\n            }\\n        }\\n        return s;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959250,
                "title": "c-super-short-self-expressive",
                "content": "Randomly pick a word from words while narrowing down the list by the matching characters. \\n```\\n    public void FindSecretWord(string[] wordlist, Master master) \\n    {\\n        var words = wordlist.ToList();\\n        var r = new Random();\\n        while(true)\\n        {\\n            var word = words[r.Next(words.Count)];\\n            var matches = master.Guess(word);\\n            if (matches == 6) return;\\n            words = words.Where(w => word.Zip(w, (c1, c2) => c1 == c2 ? 1 : 0).Sum() == matches).ToList();\\n        }\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public void FindSecretWord(string[] wordlist, Master master) \\n    {\\n        var words = wordlist.ToList();\\n        var r = new Random();\\n        while(true)\\n        {\\n            var word = words[r.Next(words.Count)];\\n            var matches = master.Guess(word);\\n            if (matches == 6) return;\\n            words = words.Where(w => word.Zip(w, (c1, c2) => c1 == c2 ? 1 : 0).Sum() == matches).ToList();\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 955259,
                "title": "python-use-all-of-the-information-given",
                "content": "<details>\\n\\n<summary><b>Approach:</b> (click to show)</summary>\\n\\nGuess a word (```word1```) at random.\\nThere are three possible outcomes:\\n1. ```score = 0``` The word matches 0 characters.\\n2. ```score = 1-5``` The word matches 1-5 characters.\\n3. ```score = 6``` The word matches all 6 characters.\\n\\nEach scenario gives us different information.\\nThe third scenario means the word has been guessed: ```return None```\\n\\nThe first scenario means that none of the characters matched the secret word.\\nThis means we can **get rid of all of the words that match 1 or more characters in** ```word1```.\\n\\nThe second scenario means that **any word that matches less than** ```score``` characters in ```word1``` **cannot** be the secret word.\\n**Also**, any word that matches **more than** ```score``` characters in ```word1``` **cannot** be the secret word.\\nSo we can get rid of all of the words that do not match **exactly** ```score``` characters in ```word1```.\\n\\nThis helps us quickly filter out words that are definitely not the secret word.\\nAfter filtering out words that **cannot** be the secret word.  \\nRandomly guess the next word from wordlist.\\n\\n</details>\\n\\n<br>\\n\\n```python\\ndef findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n\\n\\tdef match_score(word1, word2):\\n\\t\\t\\'\\'\\'A measure of how closely word1 and word2 match\\'\\'\\'\\n\\t\\treturn sum(a == b for a,b in zip(word1, word2))\\n\\n\\tdef index_filter(word1):\\n\\t\\t\\'\\'\\'If word1 contains a bad character at any index - return False - word1 CANNOT be the secret word\\'\\'\\'\\n\\t\\treturn not any(word1[i] in bad[i] for i in range(6))\\n\\n\\tdef match_filter(word1):\\n\\t\\t\\'\\'\\'If word1 does not match EXACTLY score characters in each guessed word - return False - word 1 CANNOT be the secret word\\'\\'\\'\\n\\t\\treturn all(match_score(word1, word2) == score for word2, score in guessed.items())\\n\\n\\tguessed = {}                       # word -> score\\n\\tbad = collections.defaultdict(set) # index -> bad letter\\n\\n\\tfor _ in range(10):\\n\\t\\twordlist = [word for word in wordlist if index_filter(word) and match_filter(word)]\\n\\t\\tword1 = wordlist.pop(random.randint(0, len(wordlist) - 1))\\n\\t\\tscore = master.guess(word1)\\n\\t\\tif score == 0:\\n\\t\\t\\tfor i in range(len(word1)):\\n\\t\\t\\t\\tbad[i].add(word1[i])\\n\\t\\telif score < 6:\\n\\t\\t\\tguessed[word1] = score\\n\\t\\telse:\\n\\t\\t\\treturn None\\n```\\n",
                "solutionTags": [],
                "code": "```word1```\n```score = 0```\n```score = 1-5```\n```score = 6```\n```return None```\n```word1```\n```score```\n```word1```\n```score```\n```word1```\n```score```\n```word1```\n```python\\ndef findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n\\n\\tdef match_score(word1, word2):\\n\\t\\t\\'\\'\\'A measure of how closely word1 and word2 match\\'\\'\\'\\n\\t\\treturn sum(a == b for a,b in zip(word1, word2))\\n\\n\\tdef index_filter(word1):\\n\\t\\t\\'\\'\\'If word1 contains a bad character at any index - return False - word1 CANNOT be the secret word\\'\\'\\'\\n\\t\\treturn not any(word1[i] in bad[i] for i in range(6))\\n\\n\\tdef match_filter(word1):\\n\\t\\t\\'\\'\\'If word1 does not match EXACTLY score characters in each guessed word - return False - word 1 CANNOT be the secret word\\'\\'\\'\\n\\t\\treturn all(match_score(word1, word2) == score for word2, score in guessed.items())\\n\\n\\tguessed = {}                       # word -> score\\n\\tbad = collections.defaultdict(set) # index -> bad letter\\n\\n\\tfor _ in range(10):\\n\\t\\twordlist = [word for word in wordlist if index_filter(word) and match_filter(word)]\\n\\t\\tword1 = wordlist.pop(random.randint(0, len(wordlist) - 1))\\n\\t\\tscore = master.guess(word1)\\n\\t\\tif score == 0:\\n\\t\\t\\tfor i in range(len(word1)):\\n\\t\\t\\t\\tbad[i].add(word1[i])\\n\\t\\telif score < 6:\\n\\t\\t\\tguessed[word1] = score\\n\\t\\telse:\\n\\t\\t\\treturn None\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 921451,
                "title": "simple-python",
                "content": "Solution was found in leetcode discussion form\\nhttps://leetcode.com/problems/guess-the-word/discuss/766231/Very-Elegant-solution-beating-95-and-thorough-explaination\\n\\nWay better than solution given and easier to follow. \\n\\nConcept: Shorten search space by reducing the size of the word list. \\n```\\n\\n#Solution explained: https://leetcode.com/problems/guess-the-word/discuss/766231/Very-Elegant-solution-beating-95-and-thorough-explaination\\n\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        numGuesses = 0 \\n        while  numGuesses < 10:\\n            index = random.randint(0, len(wordlist) - 1)\\n            numCorrect = master.guess(wordlist[index])\\n\\n            # Correct word\\n            if numCorrect == 6:\\n                return\\n            \\n            #Shorten wordlist to ones that matched numCorrect\\n            numGuesses += 1\\n            newList = []\\n            #use -1 to ignore guess made\\n            for i in range(len(wordlist)):\\n                word = wordlist[i]\\n                numInSamePos = 0\\n                for j in range(len(word)):\\n                    if word[j] == wordlist[index][j]:\\n                        numInSamePos += 1\\n                if numInSamePos == numCorrect:\\n                    newList.append(word)\\n            wordlist = newList\\n```",
                "solutionTags": [],
                "code": "```\\n\\n#Solution explained: https://leetcode.com/problems/guess-the-word/discuss/766231/Very-Elegant-solution-beating-95-and-thorough-explaination\\n\\nclass Solution:\\n    def findSecretWord(self, wordlist: List[str], master: \\'Master\\') -> None:\\n        numGuesses = 0 \\n        while  numGuesses < 10:\\n            index = random.randint(0, len(wordlist) - 1)\\n            numCorrect = master.guess(wordlist[index])\\n\\n            # Correct word\\n            if numCorrect == 6:\\n                return\\n            \\n            #Shorten wordlist to ones that matched numCorrect\\n            numGuesses += 1\\n            newList = []\\n            #use -1 to ignore guess made\\n            for i in range(len(wordlist)):\\n                word = wordlist[i]\\n                numInSamePos = 0\\n                for j in range(len(word)):\\n                    if word[j] == wordlist[index][j]:\\n                        numInSamePos += 1\\n                if numInSamePos == numCorrect:\\n                    newList.append(word)\\n            wordlist = newList\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907913,
                "title": "c-maximum-entropy",
                "content": "The official solution is ok, but it does not pass the current test cases. That solution just looks at the worst information gain of a guess. A better approach is finding the average information gain by looking at the entropy of the matches of a word with any other in the word list. Then we pick the word with the maximum entropy as the guess. This means intuitively to find the word with the \"most uniform\" distribution of mathces.\\n\\n```\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        while(true){\\n            const std::string trial = FindGuess(wordlist);\\n            const int matches = master.guess(trial);\\n            \\n            if(matches >= 6) break;\\n            \\n            wordlist.erase(std::remove_if(wordlist.begin(), wordlist.end(), \\n                                         [&](auto& s){return Matches(trial, s) != matches; }), \\n                           wordlist.end());\\n        }\\n    }\\n    \\nprivate:\\n    float Entropy(std::array<unsigned, 7>& counts, unsigned n){\\n        float res = 0;\\n        for(auto x : counts){\\n            float p = float(x) / n;\\n            if(p)\\n                res -= p * std::log2(p);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int Matches(const std::string& a, const std::string& b){\\n        int res = 0;\\n        for(int i = 0; i < 6; ++i)\\n            res += a[i] == b[i];\\n        assert(res <= 6 && res >= 0);\\n        return res;\\n    }\\n    \\n    std::string FindGuess(vector<string>& wordlist){\\n        std::string best = wordlist.front();\\n        float max_h = 0;\\n        std::array<unsigned, 7> counts;\\n        const unsigned n =  wordlist.size();\\n        \\n        for(auto& s1 : wordlist){\\n            counts.fill(0);\\n            \\n            for(auto& s2 : wordlist){\\n                ++counts[Matches(s1, s2)];\\n            }\\n            \\n            const float h = Entropy(counts, n);\\n            \\n            if(h > max_h){\\n                best = s1;\\n                max_h = h;\\n            }\\n        }\\n        \\n        return best;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void findSecretWord(vector<string>& wordlist, Master& master) {\\n        while(true){\\n            const std::string trial = FindGuess(wordlist);\\n            const int matches = master.guess(trial);\\n            \\n            if(matches >= 6) break;\\n            \\n            wordlist.erase(std::remove_if(wordlist.begin(), wordlist.end(), \\n                                         [&](auto& s){return Matches(trial, s) != matches; }), \\n                           wordlist.end());\\n        }\\n    }\\n    \\nprivate:\\n    float Entropy(std::array<unsigned, 7>& counts, unsigned n){\\n        float res = 0;\\n        for(auto x : counts){\\n            float p = float(x) / n;\\n            if(p)\\n                res -= p * std::log2(p);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int Matches(const std::string& a, const std::string& b){\\n        int res = 0;\\n        for(int i = 0; i < 6; ++i)\\n            res += a[i] == b[i];\\n        assert(res <= 6 && res >= 0);\\n        return res;\\n    }\\n    \\n    std::string FindGuess(vector<string>& wordlist){\\n        std::string best = wordlist.front();\\n        float max_h = 0;\\n        std::array<unsigned, 7> counts;\\n        const unsigned n =  wordlist.size();\\n        \\n        for(auto& s1 : wordlist){\\n            counts.fill(0);\\n            \\n            for(auto& s2 : wordlist){\\n                ++counts[Matches(s1, s2)];\\n            }\\n            \\n            const float h = Entropy(counts, n);\\n            \\n            if(h > max_h){\\n                best = s1;\\n                max_h = h;\\n            }\\n        }\\n        \\n        return best;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 889177,
                "title": "java-faster-than-93-6",
                "content": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Set<String> set = new HashSet<>();\\n        \\n        for (String s : wordlist) {\\n            set.add(s);\\n        }\\n        \\n        int i = 10;\\n        while(i-- > 0) {\\n            String g = getRandom(set);\\n            int n = master.guess(g);\\n            \\n            if (n == 6) {\\n                return;\\n            }\\n            \\n            filterSet(g, n, set);\\n        }\\n    }\\n    \\n    private void filterSet(String g, int n, Set<String> set) {\\n        Set<String> st = new HashSet<>();\\n        for (String s : set) {\\n            if (equalCorrect(s, g) != n) {\\n                st.add(s);\\n            }\\n        }\\n        \\n        for (String s : st) {\\n            set.remove(s);\\n        }\\n    }\\n    \\n    private int equalCorrect(String s, String g) {\\n        int count = 0;\\n        for (int i = 0; i < 6; i++) {\\n            if (s.charAt(i) == g.charAt(i)) {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private String getRandom(Set<String> set) {\\n        for (String s : set) {\\n            return s;\\n        }\\n        \\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * // This is the Master\\'s API interface.\\n * // You should not implement it, or speculate about its implementation\\n * interface Master {\\n *     public int guess(String word) {}\\n * }\\n */\\nclass Solution {\\n    public void findSecretWord(String[] wordlist, Master master) {\\n        Set<String> set = new HashSet<>();\\n        \\n        for (String s : wordlist) {\\n            set.add(s);\\n        }\\n        \\n        int i = 10;\\n        while(i-- > 0) {\\n            String g = getRandom(set);\\n            int n = master.guess(g);\\n            \\n            if (n == 6) {\\n                return;\\n            }\\n            \\n            filterSet(g, n, set);\\n        }\\n    }\\n    \\n    private void filterSet(String g, int n, Set<String> set) {\\n        Set<String> st = new HashSet<>();\\n        for (String s : set) {\\n            if (equalCorrect(s, g) != n) {\\n                st.add(s);\\n            }\\n        }\\n        \\n        for (String s : st) {\\n            set.remove(s);\\n        }\\n    }\\n    \\n    private int equalCorrect(String s, String g) {\\n        int count = 0;\\n        for (int i = 0; i < 6; i++) {\\n            if (s.charAt(i) == g.charAt(i)) {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private String getRandom(Set<String> set) {\\n        for (String s : set) {\\n            return s;\\n        }\\n        \\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566328,
                "content": [
                    {
                        "username": "flandrex",
                        "content": "For example, if there are 26 different words in word list:\\n\\n - \\'aaaaaa\\'\\n - \\'aaaaab\\'\\n - ......\\n - \\'aaaaaz\\'\\n\\nIn this case, guessing the correct word in 10 attempts is impossible. Since each wrong attempt can only eliminate 1 answer, nothing else."
                    },
                    {
                        "username": "randxiexyy29",
                        "content": "Looks like the question requires the word list generated by certain distribution. Otherwise, 10 guesses are not sufficient. Take a simple example, let\\'s assume the secret is `abcdef`. I can keep the first 5 leading characteres the same and only mutate the last character. To find out the secret in this word list, you need at least 26 guesses in the worse case because there\\'s no way you can further prune the list..."
                    },
                    {
                        "username": "tinfu330",
                        "content": "Let\\'s simplify the question.\\n\\nGiven a set of character from a - z, one character is picked as the answer, can you gaurentee selecting the correct answer in 10 guesses?\\n\\nIf we cannot even gaurentee the output for a one character string, how are we doing it with a 6 character string? Think about the example [azzzzz, bzzzzz, czzzzz ... zzzzzz], when the query returns 5, it basically means that the first character is not correct, and the worse case is to guess 26 times.\\n\\nDid I miss some important property of this question or is it flawed?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Maybe the first word may not entirely use all the 26 chars. You need to pick those from given ones only. So you essentially might look at each of the 6 indices, and associate only \"used\" characters to a list of strings, and then try to solve it? Would it work?"
                    },
                    {
                        "username": "hamza979",
                        "content": "You cant reliably cover every test case e.g.\\naaaaaa\\nbbbbbb\\ncccccc\\n..\\nzzzzzz\\n\\nsecret word is the last one zzzzzz\\n\\n\\nNo way to reliably get it in 10 guesses since every guess has 0 matches and gives no new information"
                    },
                    {
                        "username": "gadmo",
                        "content": "\"The test cases are generated such that you can guess the secret word with a reasonable strategy\""
                    },
                    {
                        "username": "Ali-Saker-Ali",
                        "content": "\"acckzo\"\\n[\"acckza\",\"acckzb\",\"acckzc\",\"acckzd\",\"acckze\",\"acckzf\",\"acckzg\",\"acckzh\",\"acckzi\",\"acckzj\",\"acckzk\",\"acckzl\",\\n\"acckzm\",\"acckzn\",\"acckzo\",\"acckzp\",\"acckzq\",\"acckzr\",\"acckzs\",\"acckzt\",\"acckzu\",\"acckzv\",\"acckzw\",\"acckzx\",\"acckzy\",\"acckzz\"]\\n10\\n\\nSomething important I found when I tried the above example, what is requested is not really to guess the word in 10 guesses but that your output should match the judge solution output. So in this example, the judge\\'s solution output is also \"Can\\'t guess\". Leetcode should update the question to include this piece of info. which literally makes the problem more or less an AI/ML question and I don\\'t think that it was part of a regular software engineer role interview."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Google laughing at this :)"
                    },
                    {
                        "username": "PRANTO_DAS",
                        "content": "\"vvvvvv\"\\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"]\\n10"
                    },
                    {
                        "username": "wyundong",
                        "content": "For the following edge case, there is no algorithm on earth that can guarantee less than 10 tries.\\n\\n\"zzzzzz\" \\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"] \\n10\\n\\nI understand that the expected solution is \"Either you took too many guesses, or you did not find the secret word.\" But this should not happen given the description of the problem. Therefore, passing all test cases provided by Leetcode dos NOT prove you have the correct algorithm to solve this unsolvable problem."
                    },
                    {
                        "username": "crdbuddy",
                        "content": "\"aaaaab\"\\n[\"aaaaab\",\"aaaaac\",\"aaaaad\",\"aaaaae\",\"aaaaaf\",\"aaaaag\",\"aaaaah\",\"aaaaai\",\"aaaaaj\",\"aaaaak\",\"aaaaal\",\"aaaaam\",\"aaaaan\",\"aaaaao\",\"aaaaap\",\"aaaaaq\"]\\n10"
                    },
                    {
                        "username": "ershivasoni",
                        "content": "It\\'s not possible to guess secret word in < 10 calls. take this test case:\\nsecret - \"lcckzz\"\\nwordlist - [\"acckzz\",\"bcckzz\",\"ccckzz\",\"dcckzz\",\"ecckzz\",\"fcckzz\",\"gcckzz\",\"hcckzz\",\"icckzz\",\"jcckzz\",\"kcckzz\",\"lcckzz\",\"mcckzz\"]\\n\\nHow is everybody\\'s code passing?"
                    },
                    {
                        "username": "iChuan",
                        "content": "Terrible to understand, can anyone explain it? Thanks alot\\n\\n===============\\nJust figured out.\\nString a: \"abcde\"\\nString b: \"aopdw\"\\nvalue is 2 because only letter \\'a\\' and letter \\'d\\' appear at the same position."
                    }
                ]
            },
            {
                "id": 1567135,
                "content": [
                    {
                        "username": "flandrex",
                        "content": "For example, if there are 26 different words in word list:\\n\\n - \\'aaaaaa\\'\\n - \\'aaaaab\\'\\n - ......\\n - \\'aaaaaz\\'\\n\\nIn this case, guessing the correct word in 10 attempts is impossible. Since each wrong attempt can only eliminate 1 answer, nothing else."
                    },
                    {
                        "username": "randxiexyy29",
                        "content": "Looks like the question requires the word list generated by certain distribution. Otherwise, 10 guesses are not sufficient. Take a simple example, let\\'s assume the secret is `abcdef`. I can keep the first 5 leading characteres the same and only mutate the last character. To find out the secret in this word list, you need at least 26 guesses in the worse case because there\\'s no way you can further prune the list..."
                    },
                    {
                        "username": "tinfu330",
                        "content": "Let\\'s simplify the question.\\n\\nGiven a set of character from a - z, one character is picked as the answer, can you gaurentee selecting the correct answer in 10 guesses?\\n\\nIf we cannot even gaurentee the output for a one character string, how are we doing it with a 6 character string? Think about the example [azzzzz, bzzzzz, czzzzz ... zzzzzz], when the query returns 5, it basically means that the first character is not correct, and the worse case is to guess 26 times.\\n\\nDid I miss some important property of this question or is it flawed?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Maybe the first word may not entirely use all the 26 chars. You need to pick those from given ones only. So you essentially might look at each of the 6 indices, and associate only \"used\" characters to a list of strings, and then try to solve it? Would it work?"
                    },
                    {
                        "username": "hamza979",
                        "content": "You cant reliably cover every test case e.g.\\naaaaaa\\nbbbbbb\\ncccccc\\n..\\nzzzzzz\\n\\nsecret word is the last one zzzzzz\\n\\n\\nNo way to reliably get it in 10 guesses since every guess has 0 matches and gives no new information"
                    },
                    {
                        "username": "gadmo",
                        "content": "\"The test cases are generated such that you can guess the secret word with a reasonable strategy\""
                    },
                    {
                        "username": "Ali-Saker-Ali",
                        "content": "\"acckzo\"\\n[\"acckza\",\"acckzb\",\"acckzc\",\"acckzd\",\"acckze\",\"acckzf\",\"acckzg\",\"acckzh\",\"acckzi\",\"acckzj\",\"acckzk\",\"acckzl\",\\n\"acckzm\",\"acckzn\",\"acckzo\",\"acckzp\",\"acckzq\",\"acckzr\",\"acckzs\",\"acckzt\",\"acckzu\",\"acckzv\",\"acckzw\",\"acckzx\",\"acckzy\",\"acckzz\"]\\n10\\n\\nSomething important I found when I tried the above example, what is requested is not really to guess the word in 10 guesses but that your output should match the judge solution output. So in this example, the judge\\'s solution output is also \"Can\\'t guess\". Leetcode should update the question to include this piece of info. which literally makes the problem more or less an AI/ML question and I don\\'t think that it was part of a regular software engineer role interview."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Google laughing at this :)"
                    },
                    {
                        "username": "PRANTO_DAS",
                        "content": "\"vvvvvv\"\\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"]\\n10"
                    },
                    {
                        "username": "wyundong",
                        "content": "For the following edge case, there is no algorithm on earth that can guarantee less than 10 tries.\\n\\n\"zzzzzz\" \\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"] \\n10\\n\\nI understand that the expected solution is \"Either you took too many guesses, or you did not find the secret word.\" But this should not happen given the description of the problem. Therefore, passing all test cases provided by Leetcode dos NOT prove you have the correct algorithm to solve this unsolvable problem."
                    },
                    {
                        "username": "crdbuddy",
                        "content": "\"aaaaab\"\\n[\"aaaaab\",\"aaaaac\",\"aaaaad\",\"aaaaae\",\"aaaaaf\",\"aaaaag\",\"aaaaah\",\"aaaaai\",\"aaaaaj\",\"aaaaak\",\"aaaaal\",\"aaaaam\",\"aaaaan\",\"aaaaao\",\"aaaaap\",\"aaaaaq\"]\\n10"
                    },
                    {
                        "username": "ershivasoni",
                        "content": "It\\'s not possible to guess secret word in < 10 calls. take this test case:\\nsecret - \"lcckzz\"\\nwordlist - [\"acckzz\",\"bcckzz\",\"ccckzz\",\"dcckzz\",\"ecckzz\",\"fcckzz\",\"gcckzz\",\"hcckzz\",\"icckzz\",\"jcckzz\",\"kcckzz\",\"lcckzz\",\"mcckzz\"]\\n\\nHow is everybody\\'s code passing?"
                    },
                    {
                        "username": "iChuan",
                        "content": "Terrible to understand, can anyone explain it? Thanks alot\\n\\n===============\\nJust figured out.\\nString a: \"abcde\"\\nString b: \"aopdw\"\\nvalue is 2 because only letter \\'a\\' and letter \\'d\\' appear at the same position."
                    }
                ]
            },
            {
                "id": 1567090,
                "content": [
                    {
                        "username": "flandrex",
                        "content": "For example, if there are 26 different words in word list:\\n\\n - \\'aaaaaa\\'\\n - \\'aaaaab\\'\\n - ......\\n - \\'aaaaaz\\'\\n\\nIn this case, guessing the correct word in 10 attempts is impossible. Since each wrong attempt can only eliminate 1 answer, nothing else."
                    },
                    {
                        "username": "randxiexyy29",
                        "content": "Looks like the question requires the word list generated by certain distribution. Otherwise, 10 guesses are not sufficient. Take a simple example, let\\'s assume the secret is `abcdef`. I can keep the first 5 leading characteres the same and only mutate the last character. To find out the secret in this word list, you need at least 26 guesses in the worse case because there\\'s no way you can further prune the list..."
                    },
                    {
                        "username": "tinfu330",
                        "content": "Let\\'s simplify the question.\\n\\nGiven a set of character from a - z, one character is picked as the answer, can you gaurentee selecting the correct answer in 10 guesses?\\n\\nIf we cannot even gaurentee the output for a one character string, how are we doing it with a 6 character string? Think about the example [azzzzz, bzzzzz, czzzzz ... zzzzzz], when the query returns 5, it basically means that the first character is not correct, and the worse case is to guess 26 times.\\n\\nDid I miss some important property of this question or is it flawed?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Maybe the first word may not entirely use all the 26 chars. You need to pick those from given ones only. So you essentially might look at each of the 6 indices, and associate only \"used\" characters to a list of strings, and then try to solve it? Would it work?"
                    },
                    {
                        "username": "hamza979",
                        "content": "You cant reliably cover every test case e.g.\\naaaaaa\\nbbbbbb\\ncccccc\\n..\\nzzzzzz\\n\\nsecret word is the last one zzzzzz\\n\\n\\nNo way to reliably get it in 10 guesses since every guess has 0 matches and gives no new information"
                    },
                    {
                        "username": "gadmo",
                        "content": "\"The test cases are generated such that you can guess the secret word with a reasonable strategy\""
                    },
                    {
                        "username": "Ali-Saker-Ali",
                        "content": "\"acckzo\"\\n[\"acckza\",\"acckzb\",\"acckzc\",\"acckzd\",\"acckze\",\"acckzf\",\"acckzg\",\"acckzh\",\"acckzi\",\"acckzj\",\"acckzk\",\"acckzl\",\\n\"acckzm\",\"acckzn\",\"acckzo\",\"acckzp\",\"acckzq\",\"acckzr\",\"acckzs\",\"acckzt\",\"acckzu\",\"acckzv\",\"acckzw\",\"acckzx\",\"acckzy\",\"acckzz\"]\\n10\\n\\nSomething important I found when I tried the above example, what is requested is not really to guess the word in 10 guesses but that your output should match the judge solution output. So in this example, the judge\\'s solution output is also \"Can\\'t guess\". Leetcode should update the question to include this piece of info. which literally makes the problem more or less an AI/ML question and I don\\'t think that it was part of a regular software engineer role interview."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Google laughing at this :)"
                    },
                    {
                        "username": "PRANTO_DAS",
                        "content": "\"vvvvvv\"\\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"]\\n10"
                    },
                    {
                        "username": "wyundong",
                        "content": "For the following edge case, there is no algorithm on earth that can guarantee less than 10 tries.\\n\\n\"zzzzzz\" \\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"] \\n10\\n\\nI understand that the expected solution is \"Either you took too many guesses, or you did not find the secret word.\" But this should not happen given the description of the problem. Therefore, passing all test cases provided by Leetcode dos NOT prove you have the correct algorithm to solve this unsolvable problem."
                    },
                    {
                        "username": "crdbuddy",
                        "content": "\"aaaaab\"\\n[\"aaaaab\",\"aaaaac\",\"aaaaad\",\"aaaaae\",\"aaaaaf\",\"aaaaag\",\"aaaaah\",\"aaaaai\",\"aaaaaj\",\"aaaaak\",\"aaaaal\",\"aaaaam\",\"aaaaan\",\"aaaaao\",\"aaaaap\",\"aaaaaq\"]\\n10"
                    },
                    {
                        "username": "ershivasoni",
                        "content": "It\\'s not possible to guess secret word in < 10 calls. take this test case:\\nsecret - \"lcckzz\"\\nwordlist - [\"acckzz\",\"bcckzz\",\"ccckzz\",\"dcckzz\",\"ecckzz\",\"fcckzz\",\"gcckzz\",\"hcckzz\",\"icckzz\",\"jcckzz\",\"kcckzz\",\"lcckzz\",\"mcckzz\"]\\n\\nHow is everybody\\'s code passing?"
                    },
                    {
                        "username": "iChuan",
                        "content": "Terrible to understand, can anyone explain it? Thanks alot\\n\\n===============\\nJust figured out.\\nString a: \"abcde\"\\nString b: \"aopdw\"\\nvalue is 2 because only letter \\'a\\' and letter \\'d\\' appear at the same position."
                    }
                ]
            },
            {
                "id": 1566190,
                "content": [
                    {
                        "username": "flandrex",
                        "content": "For example, if there are 26 different words in word list:\\n\\n - \\'aaaaaa\\'\\n - \\'aaaaab\\'\\n - ......\\n - \\'aaaaaz\\'\\n\\nIn this case, guessing the correct word in 10 attempts is impossible. Since each wrong attempt can only eliminate 1 answer, nothing else."
                    },
                    {
                        "username": "randxiexyy29",
                        "content": "Looks like the question requires the word list generated by certain distribution. Otherwise, 10 guesses are not sufficient. Take a simple example, let\\'s assume the secret is `abcdef`. I can keep the first 5 leading characteres the same and only mutate the last character. To find out the secret in this word list, you need at least 26 guesses in the worse case because there\\'s no way you can further prune the list..."
                    },
                    {
                        "username": "tinfu330",
                        "content": "Let\\'s simplify the question.\\n\\nGiven a set of character from a - z, one character is picked as the answer, can you gaurentee selecting the correct answer in 10 guesses?\\n\\nIf we cannot even gaurentee the output for a one character string, how are we doing it with a 6 character string? Think about the example [azzzzz, bzzzzz, czzzzz ... zzzzzz], when the query returns 5, it basically means that the first character is not correct, and the worse case is to guess 26 times.\\n\\nDid I miss some important property of this question or is it flawed?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Maybe the first word may not entirely use all the 26 chars. You need to pick those from given ones only. So you essentially might look at each of the 6 indices, and associate only \"used\" characters to a list of strings, and then try to solve it? Would it work?"
                    },
                    {
                        "username": "hamza979",
                        "content": "You cant reliably cover every test case e.g.\\naaaaaa\\nbbbbbb\\ncccccc\\n..\\nzzzzzz\\n\\nsecret word is the last one zzzzzz\\n\\n\\nNo way to reliably get it in 10 guesses since every guess has 0 matches and gives no new information"
                    },
                    {
                        "username": "gadmo",
                        "content": "\"The test cases are generated such that you can guess the secret word with a reasonable strategy\""
                    },
                    {
                        "username": "Ali-Saker-Ali",
                        "content": "\"acckzo\"\\n[\"acckza\",\"acckzb\",\"acckzc\",\"acckzd\",\"acckze\",\"acckzf\",\"acckzg\",\"acckzh\",\"acckzi\",\"acckzj\",\"acckzk\",\"acckzl\",\\n\"acckzm\",\"acckzn\",\"acckzo\",\"acckzp\",\"acckzq\",\"acckzr\",\"acckzs\",\"acckzt\",\"acckzu\",\"acckzv\",\"acckzw\",\"acckzx\",\"acckzy\",\"acckzz\"]\\n10\\n\\nSomething important I found when I tried the above example, what is requested is not really to guess the word in 10 guesses but that your output should match the judge solution output. So in this example, the judge\\'s solution output is also \"Can\\'t guess\". Leetcode should update the question to include this piece of info. which literally makes the problem more or less an AI/ML question and I don\\'t think that it was part of a regular software engineer role interview."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Google laughing at this :)"
                    },
                    {
                        "username": "PRANTO_DAS",
                        "content": "\"vvvvvv\"\\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"]\\n10"
                    },
                    {
                        "username": "wyundong",
                        "content": "For the following edge case, there is no algorithm on earth that can guarantee less than 10 tries.\\n\\n\"zzzzzz\" \\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"] \\n10\\n\\nI understand that the expected solution is \"Either you took too many guesses, or you did not find the secret word.\" But this should not happen given the description of the problem. Therefore, passing all test cases provided by Leetcode dos NOT prove you have the correct algorithm to solve this unsolvable problem."
                    },
                    {
                        "username": "crdbuddy",
                        "content": "\"aaaaab\"\\n[\"aaaaab\",\"aaaaac\",\"aaaaad\",\"aaaaae\",\"aaaaaf\",\"aaaaag\",\"aaaaah\",\"aaaaai\",\"aaaaaj\",\"aaaaak\",\"aaaaal\",\"aaaaam\",\"aaaaan\",\"aaaaao\",\"aaaaap\",\"aaaaaq\"]\\n10"
                    },
                    {
                        "username": "ershivasoni",
                        "content": "It\\'s not possible to guess secret word in < 10 calls. take this test case:\\nsecret - \"lcckzz\"\\nwordlist - [\"acckzz\",\"bcckzz\",\"ccckzz\",\"dcckzz\",\"ecckzz\",\"fcckzz\",\"gcckzz\",\"hcckzz\",\"icckzz\",\"jcckzz\",\"kcckzz\",\"lcckzz\",\"mcckzz\"]\\n\\nHow is everybody\\'s code passing?"
                    },
                    {
                        "username": "iChuan",
                        "content": "Terrible to understand, can anyone explain it? Thanks alot\\n\\n===============\\nJust figured out.\\nString a: \"abcde\"\\nString b: \"aopdw\"\\nvalue is 2 because only letter \\'a\\' and letter \\'d\\' appear at the same position."
                    }
                ]
            },
            {
                "id": 1568774,
                "content": [
                    {
                        "username": "flandrex",
                        "content": "For example, if there are 26 different words in word list:\\n\\n - \\'aaaaaa\\'\\n - \\'aaaaab\\'\\n - ......\\n - \\'aaaaaz\\'\\n\\nIn this case, guessing the correct word in 10 attempts is impossible. Since each wrong attempt can only eliminate 1 answer, nothing else."
                    },
                    {
                        "username": "randxiexyy29",
                        "content": "Looks like the question requires the word list generated by certain distribution. Otherwise, 10 guesses are not sufficient. Take a simple example, let\\'s assume the secret is `abcdef`. I can keep the first 5 leading characteres the same and only mutate the last character. To find out the secret in this word list, you need at least 26 guesses in the worse case because there\\'s no way you can further prune the list..."
                    },
                    {
                        "username": "tinfu330",
                        "content": "Let\\'s simplify the question.\\n\\nGiven a set of character from a - z, one character is picked as the answer, can you gaurentee selecting the correct answer in 10 guesses?\\n\\nIf we cannot even gaurentee the output for a one character string, how are we doing it with a 6 character string? Think about the example [azzzzz, bzzzzz, czzzzz ... zzzzzz], when the query returns 5, it basically means that the first character is not correct, and the worse case is to guess 26 times.\\n\\nDid I miss some important property of this question or is it flawed?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Maybe the first word may not entirely use all the 26 chars. You need to pick those from given ones only. So you essentially might look at each of the 6 indices, and associate only \"used\" characters to a list of strings, and then try to solve it? Would it work?"
                    },
                    {
                        "username": "hamza979",
                        "content": "You cant reliably cover every test case e.g.\\naaaaaa\\nbbbbbb\\ncccccc\\n..\\nzzzzzz\\n\\nsecret word is the last one zzzzzz\\n\\n\\nNo way to reliably get it in 10 guesses since every guess has 0 matches and gives no new information"
                    },
                    {
                        "username": "gadmo",
                        "content": "\"The test cases are generated such that you can guess the secret word with a reasonable strategy\""
                    },
                    {
                        "username": "Ali-Saker-Ali",
                        "content": "\"acckzo\"\\n[\"acckza\",\"acckzb\",\"acckzc\",\"acckzd\",\"acckze\",\"acckzf\",\"acckzg\",\"acckzh\",\"acckzi\",\"acckzj\",\"acckzk\",\"acckzl\",\\n\"acckzm\",\"acckzn\",\"acckzo\",\"acckzp\",\"acckzq\",\"acckzr\",\"acckzs\",\"acckzt\",\"acckzu\",\"acckzv\",\"acckzw\",\"acckzx\",\"acckzy\",\"acckzz\"]\\n10\\n\\nSomething important I found when I tried the above example, what is requested is not really to guess the word in 10 guesses but that your output should match the judge solution output. So in this example, the judge\\'s solution output is also \"Can\\'t guess\". Leetcode should update the question to include this piece of info. which literally makes the problem more or less an AI/ML question and I don\\'t think that it was part of a regular software engineer role interview."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Google laughing at this :)"
                    },
                    {
                        "username": "PRANTO_DAS",
                        "content": "\"vvvvvv\"\\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"]\\n10"
                    },
                    {
                        "username": "wyundong",
                        "content": "For the following edge case, there is no algorithm on earth that can guarantee less than 10 tries.\\n\\n\"zzzzzz\" \\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"] \\n10\\n\\nI understand that the expected solution is \"Either you took too many guesses, or you did not find the secret word.\" But this should not happen given the description of the problem. Therefore, passing all test cases provided by Leetcode dos NOT prove you have the correct algorithm to solve this unsolvable problem."
                    },
                    {
                        "username": "crdbuddy",
                        "content": "\"aaaaab\"\\n[\"aaaaab\",\"aaaaac\",\"aaaaad\",\"aaaaae\",\"aaaaaf\",\"aaaaag\",\"aaaaah\",\"aaaaai\",\"aaaaaj\",\"aaaaak\",\"aaaaal\",\"aaaaam\",\"aaaaan\",\"aaaaao\",\"aaaaap\",\"aaaaaq\"]\\n10"
                    },
                    {
                        "username": "ershivasoni",
                        "content": "It\\'s not possible to guess secret word in < 10 calls. take this test case:\\nsecret - \"lcckzz\"\\nwordlist - [\"acckzz\",\"bcckzz\",\"ccckzz\",\"dcckzz\",\"ecckzz\",\"fcckzz\",\"gcckzz\",\"hcckzz\",\"icckzz\",\"jcckzz\",\"kcckzz\",\"lcckzz\",\"mcckzz\"]\\n\\nHow is everybody\\'s code passing?"
                    },
                    {
                        "username": "iChuan",
                        "content": "Terrible to understand, can anyone explain it? Thanks alot\\n\\n===============\\nJust figured out.\\nString a: \"abcde\"\\nString b: \"aopdw\"\\nvalue is 2 because only letter \\'a\\' and letter \\'d\\' appear at the same position."
                    }
                ]
            },
            {
                "id": 1567704,
                "content": [
                    {
                        "username": "flandrex",
                        "content": "For example, if there are 26 different words in word list:\\n\\n - \\'aaaaaa\\'\\n - \\'aaaaab\\'\\n - ......\\n - \\'aaaaaz\\'\\n\\nIn this case, guessing the correct word in 10 attempts is impossible. Since each wrong attempt can only eliminate 1 answer, nothing else."
                    },
                    {
                        "username": "randxiexyy29",
                        "content": "Looks like the question requires the word list generated by certain distribution. Otherwise, 10 guesses are not sufficient. Take a simple example, let\\'s assume the secret is `abcdef`. I can keep the first 5 leading characteres the same and only mutate the last character. To find out the secret in this word list, you need at least 26 guesses in the worse case because there\\'s no way you can further prune the list..."
                    },
                    {
                        "username": "tinfu330",
                        "content": "Let\\'s simplify the question.\\n\\nGiven a set of character from a - z, one character is picked as the answer, can you gaurentee selecting the correct answer in 10 guesses?\\n\\nIf we cannot even gaurentee the output for a one character string, how are we doing it with a 6 character string? Think about the example [azzzzz, bzzzzz, czzzzz ... zzzzzz], when the query returns 5, it basically means that the first character is not correct, and the worse case is to guess 26 times.\\n\\nDid I miss some important property of this question or is it flawed?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Maybe the first word may not entirely use all the 26 chars. You need to pick those from given ones only. So you essentially might look at each of the 6 indices, and associate only \"used\" characters to a list of strings, and then try to solve it? Would it work?"
                    },
                    {
                        "username": "hamza979",
                        "content": "You cant reliably cover every test case e.g.\\naaaaaa\\nbbbbbb\\ncccccc\\n..\\nzzzzzz\\n\\nsecret word is the last one zzzzzz\\n\\n\\nNo way to reliably get it in 10 guesses since every guess has 0 matches and gives no new information"
                    },
                    {
                        "username": "gadmo",
                        "content": "\"The test cases are generated such that you can guess the secret word with a reasonable strategy\""
                    },
                    {
                        "username": "Ali-Saker-Ali",
                        "content": "\"acckzo\"\\n[\"acckza\",\"acckzb\",\"acckzc\",\"acckzd\",\"acckze\",\"acckzf\",\"acckzg\",\"acckzh\",\"acckzi\",\"acckzj\",\"acckzk\",\"acckzl\",\\n\"acckzm\",\"acckzn\",\"acckzo\",\"acckzp\",\"acckzq\",\"acckzr\",\"acckzs\",\"acckzt\",\"acckzu\",\"acckzv\",\"acckzw\",\"acckzx\",\"acckzy\",\"acckzz\"]\\n10\\n\\nSomething important I found when I tried the above example, what is requested is not really to guess the word in 10 guesses but that your output should match the judge solution output. So in this example, the judge\\'s solution output is also \"Can\\'t guess\". Leetcode should update the question to include this piece of info. which literally makes the problem more or less an AI/ML question and I don\\'t think that it was part of a regular software engineer role interview."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Google laughing at this :)"
                    },
                    {
                        "username": "PRANTO_DAS",
                        "content": "\"vvvvvv\"\\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"]\\n10"
                    },
                    {
                        "username": "wyundong",
                        "content": "For the following edge case, there is no algorithm on earth that can guarantee less than 10 tries.\\n\\n\"zzzzzz\" \\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"] \\n10\\n\\nI understand that the expected solution is \"Either you took too many guesses, or you did not find the secret word.\" But this should not happen given the description of the problem. Therefore, passing all test cases provided by Leetcode dos NOT prove you have the correct algorithm to solve this unsolvable problem."
                    },
                    {
                        "username": "crdbuddy",
                        "content": "\"aaaaab\"\\n[\"aaaaab\",\"aaaaac\",\"aaaaad\",\"aaaaae\",\"aaaaaf\",\"aaaaag\",\"aaaaah\",\"aaaaai\",\"aaaaaj\",\"aaaaak\",\"aaaaal\",\"aaaaam\",\"aaaaan\",\"aaaaao\",\"aaaaap\",\"aaaaaq\"]\\n10"
                    },
                    {
                        "username": "ershivasoni",
                        "content": "It\\'s not possible to guess secret word in < 10 calls. take this test case:\\nsecret - \"lcckzz\"\\nwordlist - [\"acckzz\",\"bcckzz\",\"ccckzz\",\"dcckzz\",\"ecckzz\",\"fcckzz\",\"gcckzz\",\"hcckzz\",\"icckzz\",\"jcckzz\",\"kcckzz\",\"lcckzz\",\"mcckzz\"]\\n\\nHow is everybody\\'s code passing?"
                    },
                    {
                        "username": "iChuan",
                        "content": "Terrible to understand, can anyone explain it? Thanks alot\\n\\n===============\\nJust figured out.\\nString a: \"abcde\"\\nString b: \"aopdw\"\\nvalue is 2 because only letter \\'a\\' and letter \\'d\\' appear at the same position."
                    }
                ]
            },
            {
                "id": 1566401,
                "content": [
                    {
                        "username": "flandrex",
                        "content": "For example, if there are 26 different words in word list:\\n\\n - \\'aaaaaa\\'\\n - \\'aaaaab\\'\\n - ......\\n - \\'aaaaaz\\'\\n\\nIn this case, guessing the correct word in 10 attempts is impossible. Since each wrong attempt can only eliminate 1 answer, nothing else."
                    },
                    {
                        "username": "randxiexyy29",
                        "content": "Looks like the question requires the word list generated by certain distribution. Otherwise, 10 guesses are not sufficient. Take a simple example, let\\'s assume the secret is `abcdef`. I can keep the first 5 leading characteres the same and only mutate the last character. To find out the secret in this word list, you need at least 26 guesses in the worse case because there\\'s no way you can further prune the list..."
                    },
                    {
                        "username": "tinfu330",
                        "content": "Let\\'s simplify the question.\\n\\nGiven a set of character from a - z, one character is picked as the answer, can you gaurentee selecting the correct answer in 10 guesses?\\n\\nIf we cannot even gaurentee the output for a one character string, how are we doing it with a 6 character string? Think about the example [azzzzz, bzzzzz, czzzzz ... zzzzzz], when the query returns 5, it basically means that the first character is not correct, and the worse case is to guess 26 times.\\n\\nDid I miss some important property of this question or is it flawed?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Maybe the first word may not entirely use all the 26 chars. You need to pick those from given ones only. So you essentially might look at each of the 6 indices, and associate only \"used\" characters to a list of strings, and then try to solve it? Would it work?"
                    },
                    {
                        "username": "hamza979",
                        "content": "You cant reliably cover every test case e.g.\\naaaaaa\\nbbbbbb\\ncccccc\\n..\\nzzzzzz\\n\\nsecret word is the last one zzzzzz\\n\\n\\nNo way to reliably get it in 10 guesses since every guess has 0 matches and gives no new information"
                    },
                    {
                        "username": "gadmo",
                        "content": "\"The test cases are generated such that you can guess the secret word with a reasonable strategy\""
                    },
                    {
                        "username": "Ali-Saker-Ali",
                        "content": "\"acckzo\"\\n[\"acckza\",\"acckzb\",\"acckzc\",\"acckzd\",\"acckze\",\"acckzf\",\"acckzg\",\"acckzh\",\"acckzi\",\"acckzj\",\"acckzk\",\"acckzl\",\\n\"acckzm\",\"acckzn\",\"acckzo\",\"acckzp\",\"acckzq\",\"acckzr\",\"acckzs\",\"acckzt\",\"acckzu\",\"acckzv\",\"acckzw\",\"acckzx\",\"acckzy\",\"acckzz\"]\\n10\\n\\nSomething important I found when I tried the above example, what is requested is not really to guess the word in 10 guesses but that your output should match the judge solution output. So in this example, the judge\\'s solution output is also \"Can\\'t guess\". Leetcode should update the question to include this piece of info. which literally makes the problem more or less an AI/ML question and I don\\'t think that it was part of a regular software engineer role interview."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Google laughing at this :)"
                    },
                    {
                        "username": "PRANTO_DAS",
                        "content": "\"vvvvvv\"\\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"]\\n10"
                    },
                    {
                        "username": "wyundong",
                        "content": "For the following edge case, there is no algorithm on earth that can guarantee less than 10 tries.\\n\\n\"zzzzzz\" \\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"] \\n10\\n\\nI understand that the expected solution is \"Either you took too many guesses, or you did not find the secret word.\" But this should not happen given the description of the problem. Therefore, passing all test cases provided by Leetcode dos NOT prove you have the correct algorithm to solve this unsolvable problem."
                    },
                    {
                        "username": "crdbuddy",
                        "content": "\"aaaaab\"\\n[\"aaaaab\",\"aaaaac\",\"aaaaad\",\"aaaaae\",\"aaaaaf\",\"aaaaag\",\"aaaaah\",\"aaaaai\",\"aaaaaj\",\"aaaaak\",\"aaaaal\",\"aaaaam\",\"aaaaan\",\"aaaaao\",\"aaaaap\",\"aaaaaq\"]\\n10"
                    },
                    {
                        "username": "ershivasoni",
                        "content": "It\\'s not possible to guess secret word in < 10 calls. take this test case:\\nsecret - \"lcckzz\"\\nwordlist - [\"acckzz\",\"bcckzz\",\"ccckzz\",\"dcckzz\",\"ecckzz\",\"fcckzz\",\"gcckzz\",\"hcckzz\",\"icckzz\",\"jcckzz\",\"kcckzz\",\"lcckzz\",\"mcckzz\"]\\n\\nHow is everybody\\'s code passing?"
                    },
                    {
                        "username": "iChuan",
                        "content": "Terrible to understand, can anyone explain it? Thanks alot\\n\\n===============\\nJust figured out.\\nString a: \"abcde\"\\nString b: \"aopdw\"\\nvalue is 2 because only letter \\'a\\' and letter \\'d\\' appear at the same position."
                    }
                ]
            },
            {
                "id": 1568674,
                "content": [
                    {
                        "username": "flandrex",
                        "content": "For example, if there are 26 different words in word list:\\n\\n - \\'aaaaaa\\'\\n - \\'aaaaab\\'\\n - ......\\n - \\'aaaaaz\\'\\n\\nIn this case, guessing the correct word in 10 attempts is impossible. Since each wrong attempt can only eliminate 1 answer, nothing else."
                    },
                    {
                        "username": "randxiexyy29",
                        "content": "Looks like the question requires the word list generated by certain distribution. Otherwise, 10 guesses are not sufficient. Take a simple example, let\\'s assume the secret is `abcdef`. I can keep the first 5 leading characteres the same and only mutate the last character. To find out the secret in this word list, you need at least 26 guesses in the worse case because there\\'s no way you can further prune the list..."
                    },
                    {
                        "username": "tinfu330",
                        "content": "Let\\'s simplify the question.\\n\\nGiven a set of character from a - z, one character is picked as the answer, can you gaurentee selecting the correct answer in 10 guesses?\\n\\nIf we cannot even gaurentee the output for a one character string, how are we doing it with a 6 character string? Think about the example [azzzzz, bzzzzz, czzzzz ... zzzzzz], when the query returns 5, it basically means that the first character is not correct, and the worse case is to guess 26 times.\\n\\nDid I miss some important property of this question or is it flawed?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Maybe the first word may not entirely use all the 26 chars. You need to pick those from given ones only. So you essentially might look at each of the 6 indices, and associate only \"used\" characters to a list of strings, and then try to solve it? Would it work?"
                    },
                    {
                        "username": "hamza979",
                        "content": "You cant reliably cover every test case e.g.\\naaaaaa\\nbbbbbb\\ncccccc\\n..\\nzzzzzz\\n\\nsecret word is the last one zzzzzz\\n\\n\\nNo way to reliably get it in 10 guesses since every guess has 0 matches and gives no new information"
                    },
                    {
                        "username": "gadmo",
                        "content": "\"The test cases are generated such that you can guess the secret word with a reasonable strategy\""
                    },
                    {
                        "username": "Ali-Saker-Ali",
                        "content": "\"acckzo\"\\n[\"acckza\",\"acckzb\",\"acckzc\",\"acckzd\",\"acckze\",\"acckzf\",\"acckzg\",\"acckzh\",\"acckzi\",\"acckzj\",\"acckzk\",\"acckzl\",\\n\"acckzm\",\"acckzn\",\"acckzo\",\"acckzp\",\"acckzq\",\"acckzr\",\"acckzs\",\"acckzt\",\"acckzu\",\"acckzv\",\"acckzw\",\"acckzx\",\"acckzy\",\"acckzz\"]\\n10\\n\\nSomething important I found when I tried the above example, what is requested is not really to guess the word in 10 guesses but that your output should match the judge solution output. So in this example, the judge\\'s solution output is also \"Can\\'t guess\". Leetcode should update the question to include this piece of info. which literally makes the problem more or less an AI/ML question and I don\\'t think that it was part of a regular software engineer role interview."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Google laughing at this :)"
                    },
                    {
                        "username": "PRANTO_DAS",
                        "content": "\"vvvvvv\"\\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"]\\n10"
                    },
                    {
                        "username": "wyundong",
                        "content": "For the following edge case, there is no algorithm on earth that can guarantee less than 10 tries.\\n\\n\"zzzzzz\" \\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"] \\n10\\n\\nI understand that the expected solution is \"Either you took too many guesses, or you did not find the secret word.\" But this should not happen given the description of the problem. Therefore, passing all test cases provided by Leetcode dos NOT prove you have the correct algorithm to solve this unsolvable problem."
                    },
                    {
                        "username": "crdbuddy",
                        "content": "\"aaaaab\"\\n[\"aaaaab\",\"aaaaac\",\"aaaaad\",\"aaaaae\",\"aaaaaf\",\"aaaaag\",\"aaaaah\",\"aaaaai\",\"aaaaaj\",\"aaaaak\",\"aaaaal\",\"aaaaam\",\"aaaaan\",\"aaaaao\",\"aaaaap\",\"aaaaaq\"]\\n10"
                    },
                    {
                        "username": "ershivasoni",
                        "content": "It\\'s not possible to guess secret word in < 10 calls. take this test case:\\nsecret - \"lcckzz\"\\nwordlist - [\"acckzz\",\"bcckzz\",\"ccckzz\",\"dcckzz\",\"ecckzz\",\"fcckzz\",\"gcckzz\",\"hcckzz\",\"icckzz\",\"jcckzz\",\"kcckzz\",\"lcckzz\",\"mcckzz\"]\\n\\nHow is everybody\\'s code passing?"
                    },
                    {
                        "username": "iChuan",
                        "content": "Terrible to understand, can anyone explain it? Thanks alot\\n\\n===============\\nJust figured out.\\nString a: \"abcde\"\\nString b: \"aopdw\"\\nvalue is 2 because only letter \\'a\\' and letter \\'d\\' appear at the same position."
                    }
                ]
            },
            {
                "id": 1570494,
                "content": [
                    {
                        "username": "flandrex",
                        "content": "For example, if there are 26 different words in word list:\\n\\n - \\'aaaaaa\\'\\n - \\'aaaaab\\'\\n - ......\\n - \\'aaaaaz\\'\\n\\nIn this case, guessing the correct word in 10 attempts is impossible. Since each wrong attempt can only eliminate 1 answer, nothing else."
                    },
                    {
                        "username": "randxiexyy29",
                        "content": "Looks like the question requires the word list generated by certain distribution. Otherwise, 10 guesses are not sufficient. Take a simple example, let\\'s assume the secret is `abcdef`. I can keep the first 5 leading characteres the same and only mutate the last character. To find out the secret in this word list, you need at least 26 guesses in the worse case because there\\'s no way you can further prune the list..."
                    },
                    {
                        "username": "tinfu330",
                        "content": "Let\\'s simplify the question.\\n\\nGiven a set of character from a - z, one character is picked as the answer, can you gaurentee selecting the correct answer in 10 guesses?\\n\\nIf we cannot even gaurentee the output for a one character string, how are we doing it with a 6 character string? Think about the example [azzzzz, bzzzzz, czzzzz ... zzzzzz], when the query returns 5, it basically means that the first character is not correct, and the worse case is to guess 26 times.\\n\\nDid I miss some important property of this question or is it flawed?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Maybe the first word may not entirely use all the 26 chars. You need to pick those from given ones only. So you essentially might look at each of the 6 indices, and associate only \"used\" characters to a list of strings, and then try to solve it? Would it work?"
                    },
                    {
                        "username": "hamza979",
                        "content": "You cant reliably cover every test case e.g.\\naaaaaa\\nbbbbbb\\ncccccc\\n..\\nzzzzzz\\n\\nsecret word is the last one zzzzzz\\n\\n\\nNo way to reliably get it in 10 guesses since every guess has 0 matches and gives no new information"
                    },
                    {
                        "username": "gadmo",
                        "content": "\"The test cases are generated such that you can guess the secret word with a reasonable strategy\""
                    },
                    {
                        "username": "Ali-Saker-Ali",
                        "content": "\"acckzo\"\\n[\"acckza\",\"acckzb\",\"acckzc\",\"acckzd\",\"acckze\",\"acckzf\",\"acckzg\",\"acckzh\",\"acckzi\",\"acckzj\",\"acckzk\",\"acckzl\",\\n\"acckzm\",\"acckzn\",\"acckzo\",\"acckzp\",\"acckzq\",\"acckzr\",\"acckzs\",\"acckzt\",\"acckzu\",\"acckzv\",\"acckzw\",\"acckzx\",\"acckzy\",\"acckzz\"]\\n10\\n\\nSomething important I found when I tried the above example, what is requested is not really to guess the word in 10 guesses but that your output should match the judge solution output. So in this example, the judge\\'s solution output is also \"Can\\'t guess\". Leetcode should update the question to include this piece of info. which literally makes the problem more or less an AI/ML question and I don\\'t think that it was part of a regular software engineer role interview."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Google laughing at this :)"
                    },
                    {
                        "username": "PRANTO_DAS",
                        "content": "\"vvvvvv\"\\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"]\\n10"
                    },
                    {
                        "username": "wyundong",
                        "content": "For the following edge case, there is no algorithm on earth that can guarantee less than 10 tries.\\n\\n\"zzzzzz\" \\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"] \\n10\\n\\nI understand that the expected solution is \"Either you took too many guesses, or you did not find the secret word.\" But this should not happen given the description of the problem. Therefore, passing all test cases provided by Leetcode dos NOT prove you have the correct algorithm to solve this unsolvable problem."
                    },
                    {
                        "username": "crdbuddy",
                        "content": "\"aaaaab\"\\n[\"aaaaab\",\"aaaaac\",\"aaaaad\",\"aaaaae\",\"aaaaaf\",\"aaaaag\",\"aaaaah\",\"aaaaai\",\"aaaaaj\",\"aaaaak\",\"aaaaal\",\"aaaaam\",\"aaaaan\",\"aaaaao\",\"aaaaap\",\"aaaaaq\"]\\n10"
                    },
                    {
                        "username": "ershivasoni",
                        "content": "It\\'s not possible to guess secret word in < 10 calls. take this test case:\\nsecret - \"lcckzz\"\\nwordlist - [\"acckzz\",\"bcckzz\",\"ccckzz\",\"dcckzz\",\"ecckzz\",\"fcckzz\",\"gcckzz\",\"hcckzz\",\"icckzz\",\"jcckzz\",\"kcckzz\",\"lcckzz\",\"mcckzz\"]\\n\\nHow is everybody\\'s code passing?"
                    },
                    {
                        "username": "iChuan",
                        "content": "Terrible to understand, can anyone explain it? Thanks alot\\n\\n===============\\nJust figured out.\\nString a: \"abcde\"\\nString b: \"aopdw\"\\nvalue is 2 because only letter \\'a\\' and letter \\'d\\' appear at the same position."
                    }
                ]
            },
            {
                "id": 1572125,
                "content": [
                    {
                        "username": "flandrex",
                        "content": "For example, if there are 26 different words in word list:\\n\\n - \\'aaaaaa\\'\\n - \\'aaaaab\\'\\n - ......\\n - \\'aaaaaz\\'\\n\\nIn this case, guessing the correct word in 10 attempts is impossible. Since each wrong attempt can only eliminate 1 answer, nothing else."
                    },
                    {
                        "username": "randxiexyy29",
                        "content": "Looks like the question requires the word list generated by certain distribution. Otherwise, 10 guesses are not sufficient. Take a simple example, let\\'s assume the secret is `abcdef`. I can keep the first 5 leading characteres the same and only mutate the last character. To find out the secret in this word list, you need at least 26 guesses in the worse case because there\\'s no way you can further prune the list..."
                    },
                    {
                        "username": "tinfu330",
                        "content": "Let\\'s simplify the question.\\n\\nGiven a set of character from a - z, one character is picked as the answer, can you gaurentee selecting the correct answer in 10 guesses?\\n\\nIf we cannot even gaurentee the output for a one character string, how are we doing it with a 6 character string? Think about the example [azzzzz, bzzzzz, czzzzz ... zzzzzz], when the query returns 5, it basically means that the first character is not correct, and the worse case is to guess 26 times.\\n\\nDid I miss some important property of this question or is it flawed?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Maybe the first word may not entirely use all the 26 chars. You need to pick those from given ones only. So you essentially might look at each of the 6 indices, and associate only \"used\" characters to a list of strings, and then try to solve it? Would it work?"
                    },
                    {
                        "username": "hamza979",
                        "content": "You cant reliably cover every test case e.g.\\naaaaaa\\nbbbbbb\\ncccccc\\n..\\nzzzzzz\\n\\nsecret word is the last one zzzzzz\\n\\n\\nNo way to reliably get it in 10 guesses since every guess has 0 matches and gives no new information"
                    },
                    {
                        "username": "gadmo",
                        "content": "\"The test cases are generated such that you can guess the secret word with a reasonable strategy\""
                    },
                    {
                        "username": "Ali-Saker-Ali",
                        "content": "\"acckzo\"\\n[\"acckza\",\"acckzb\",\"acckzc\",\"acckzd\",\"acckze\",\"acckzf\",\"acckzg\",\"acckzh\",\"acckzi\",\"acckzj\",\"acckzk\",\"acckzl\",\\n\"acckzm\",\"acckzn\",\"acckzo\",\"acckzp\",\"acckzq\",\"acckzr\",\"acckzs\",\"acckzt\",\"acckzu\",\"acckzv\",\"acckzw\",\"acckzx\",\"acckzy\",\"acckzz\"]\\n10\\n\\nSomething important I found when I tried the above example, what is requested is not really to guess the word in 10 guesses but that your output should match the judge solution output. So in this example, the judge\\'s solution output is also \"Can\\'t guess\". Leetcode should update the question to include this piece of info. which literally makes the problem more or less an AI/ML question and I don\\'t think that it was part of a regular software engineer role interview."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Google laughing at this :)"
                    },
                    {
                        "username": "PRANTO_DAS",
                        "content": "\"vvvvvv\"\\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"]\\n10"
                    },
                    {
                        "username": "wyundong",
                        "content": "For the following edge case, there is no algorithm on earth that can guarantee less than 10 tries.\\n\\n\"zzzzzz\" \\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"] \\n10\\n\\nI understand that the expected solution is \"Either you took too many guesses, or you did not find the secret word.\" But this should not happen given the description of the problem. Therefore, passing all test cases provided by Leetcode dos NOT prove you have the correct algorithm to solve this unsolvable problem."
                    },
                    {
                        "username": "crdbuddy",
                        "content": "\"aaaaab\"\\n[\"aaaaab\",\"aaaaac\",\"aaaaad\",\"aaaaae\",\"aaaaaf\",\"aaaaag\",\"aaaaah\",\"aaaaai\",\"aaaaaj\",\"aaaaak\",\"aaaaal\",\"aaaaam\",\"aaaaan\",\"aaaaao\",\"aaaaap\",\"aaaaaq\"]\\n10"
                    },
                    {
                        "username": "ershivasoni",
                        "content": "It\\'s not possible to guess secret word in < 10 calls. take this test case:\\nsecret - \"lcckzz\"\\nwordlist - [\"acckzz\",\"bcckzz\",\"ccckzz\",\"dcckzz\",\"ecckzz\",\"fcckzz\",\"gcckzz\",\"hcckzz\",\"icckzz\",\"jcckzz\",\"kcckzz\",\"lcckzz\",\"mcckzz\"]\\n\\nHow is everybody\\'s code passing?"
                    },
                    {
                        "username": "iChuan",
                        "content": "Terrible to understand, can anyone explain it? Thanks alot\\n\\n===============\\nJust figured out.\\nString a: \"abcde\"\\nString b: \"aopdw\"\\nvalue is 2 because only letter \\'a\\' and letter \\'d\\' appear at the same position."
                    }
                ]
            },
            {
                "id": 1566328,
                "content": [
                    {
                        "username": "flandrex",
                        "content": "For example, if there are 26 different words in word list:\\n\\n - \\'aaaaaa\\'\\n - \\'aaaaab\\'\\n - ......\\n - \\'aaaaaz\\'\\n\\nIn this case, guessing the correct word in 10 attempts is impossible. Since each wrong attempt can only eliminate 1 answer, nothing else."
                    },
                    {
                        "username": "randxiexyy29",
                        "content": "Looks like the question requires the word list generated by certain distribution. Otherwise, 10 guesses are not sufficient. Take a simple example, let\\'s assume the secret is `abcdef`. I can keep the first 5 leading characteres the same and only mutate the last character. To find out the secret in this word list, you need at least 26 guesses in the worse case because there\\'s no way you can further prune the list..."
                    },
                    {
                        "username": "tinfu330",
                        "content": "Let\\'s simplify the question.\\n\\nGiven a set of character from a - z, one character is picked as the answer, can you gaurentee selecting the correct answer in 10 guesses?\\n\\nIf we cannot even gaurentee the output for a one character string, how are we doing it with a 6 character string? Think about the example [azzzzz, bzzzzz, czzzzz ... zzzzzz], when the query returns 5, it basically means that the first character is not correct, and the worse case is to guess 26 times.\\n\\nDid I miss some important property of this question or is it flawed?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Maybe the first word may not entirely use all the 26 chars. You need to pick those from given ones only. So you essentially might look at each of the 6 indices, and associate only \"used\" characters to a list of strings, and then try to solve it? Would it work?"
                    },
                    {
                        "username": "hamza979",
                        "content": "You cant reliably cover every test case e.g.\\naaaaaa\\nbbbbbb\\ncccccc\\n..\\nzzzzzz\\n\\nsecret word is the last one zzzzzz\\n\\n\\nNo way to reliably get it in 10 guesses since every guess has 0 matches and gives no new information"
                    },
                    {
                        "username": "gadmo",
                        "content": "\"The test cases are generated such that you can guess the secret word with a reasonable strategy\""
                    },
                    {
                        "username": "Ali-Saker-Ali",
                        "content": "\"acckzo\"\\n[\"acckza\",\"acckzb\",\"acckzc\",\"acckzd\",\"acckze\",\"acckzf\",\"acckzg\",\"acckzh\",\"acckzi\",\"acckzj\",\"acckzk\",\"acckzl\",\\n\"acckzm\",\"acckzn\",\"acckzo\",\"acckzp\",\"acckzq\",\"acckzr\",\"acckzs\",\"acckzt\",\"acckzu\",\"acckzv\",\"acckzw\",\"acckzx\",\"acckzy\",\"acckzz\"]\\n10\\n\\nSomething important I found when I tried the above example, what is requested is not really to guess the word in 10 guesses but that your output should match the judge solution output. So in this example, the judge\\'s solution output is also \"Can\\'t guess\". Leetcode should update the question to include this piece of info. which literally makes the problem more or less an AI/ML question and I don\\'t think that it was part of a regular software engineer role interview."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Google laughing at this :)"
                    },
                    {
                        "username": "PRANTO_DAS",
                        "content": "\"vvvvvv\"\\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"]\\n10"
                    },
                    {
                        "username": "wyundong",
                        "content": "For the following edge case, there is no algorithm on earth that can guarantee less than 10 tries.\\n\\n\"zzzzzz\" \\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"] \\n10\\n\\nI understand that the expected solution is \"Either you took too many guesses, or you did not find the secret word.\" But this should not happen given the description of the problem. Therefore, passing all test cases provided by Leetcode dos NOT prove you have the correct algorithm to solve this unsolvable problem."
                    },
                    {
                        "username": "crdbuddy",
                        "content": "\"aaaaab\"\\n[\"aaaaab\",\"aaaaac\",\"aaaaad\",\"aaaaae\",\"aaaaaf\",\"aaaaag\",\"aaaaah\",\"aaaaai\",\"aaaaaj\",\"aaaaak\",\"aaaaal\",\"aaaaam\",\"aaaaan\",\"aaaaao\",\"aaaaap\",\"aaaaaq\"]\\n10"
                    },
                    {
                        "username": "ershivasoni",
                        "content": "It\\'s not possible to guess secret word in < 10 calls. take this test case:\\nsecret - \"lcckzz\"\\nwordlist - [\"acckzz\",\"bcckzz\",\"ccckzz\",\"dcckzz\",\"ecckzz\",\"fcckzz\",\"gcckzz\",\"hcckzz\",\"icckzz\",\"jcckzz\",\"kcckzz\",\"lcckzz\",\"mcckzz\"]\\n\\nHow is everybody\\'s code passing?"
                    },
                    {
                        "username": "iChuan",
                        "content": "Terrible to understand, can anyone explain it? Thanks alot\\n\\n===============\\nJust figured out.\\nString a: \"abcde\"\\nString b: \"aopdw\"\\nvalue is 2 because only letter \\'a\\' and letter \\'d\\' appear at the same position."
                    }
                ]
            },
            {
                "id": 1567135,
                "content": [
                    {
                        "username": "flandrex",
                        "content": "For example, if there are 26 different words in word list:\\n\\n - \\'aaaaaa\\'\\n - \\'aaaaab\\'\\n - ......\\n - \\'aaaaaz\\'\\n\\nIn this case, guessing the correct word in 10 attempts is impossible. Since each wrong attempt can only eliminate 1 answer, nothing else."
                    },
                    {
                        "username": "randxiexyy29",
                        "content": "Looks like the question requires the word list generated by certain distribution. Otherwise, 10 guesses are not sufficient. Take a simple example, let\\'s assume the secret is `abcdef`. I can keep the first 5 leading characteres the same and only mutate the last character. To find out the secret in this word list, you need at least 26 guesses in the worse case because there\\'s no way you can further prune the list..."
                    },
                    {
                        "username": "tinfu330",
                        "content": "Let\\'s simplify the question.\\n\\nGiven a set of character from a - z, one character is picked as the answer, can you gaurentee selecting the correct answer in 10 guesses?\\n\\nIf we cannot even gaurentee the output for a one character string, how are we doing it with a 6 character string? Think about the example [azzzzz, bzzzzz, czzzzz ... zzzzzz], when the query returns 5, it basically means that the first character is not correct, and the worse case is to guess 26 times.\\n\\nDid I miss some important property of this question or is it flawed?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Maybe the first word may not entirely use all the 26 chars. You need to pick those from given ones only. So you essentially might look at each of the 6 indices, and associate only \"used\" characters to a list of strings, and then try to solve it? Would it work?"
                    },
                    {
                        "username": "hamza979",
                        "content": "You cant reliably cover every test case e.g.\\naaaaaa\\nbbbbbb\\ncccccc\\n..\\nzzzzzz\\n\\nsecret word is the last one zzzzzz\\n\\n\\nNo way to reliably get it in 10 guesses since every guess has 0 matches and gives no new information"
                    },
                    {
                        "username": "gadmo",
                        "content": "\"The test cases are generated such that you can guess the secret word with a reasonable strategy\""
                    },
                    {
                        "username": "Ali-Saker-Ali",
                        "content": "\"acckzo\"\\n[\"acckza\",\"acckzb\",\"acckzc\",\"acckzd\",\"acckze\",\"acckzf\",\"acckzg\",\"acckzh\",\"acckzi\",\"acckzj\",\"acckzk\",\"acckzl\",\\n\"acckzm\",\"acckzn\",\"acckzo\",\"acckzp\",\"acckzq\",\"acckzr\",\"acckzs\",\"acckzt\",\"acckzu\",\"acckzv\",\"acckzw\",\"acckzx\",\"acckzy\",\"acckzz\"]\\n10\\n\\nSomething important I found when I tried the above example, what is requested is not really to guess the word in 10 guesses but that your output should match the judge solution output. So in this example, the judge\\'s solution output is also \"Can\\'t guess\". Leetcode should update the question to include this piece of info. which literally makes the problem more or less an AI/ML question and I don\\'t think that it was part of a regular software engineer role interview."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Google laughing at this :)"
                    },
                    {
                        "username": "PRANTO_DAS",
                        "content": "\"vvvvvv\"\\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"]\\n10"
                    },
                    {
                        "username": "wyundong",
                        "content": "For the following edge case, there is no algorithm on earth that can guarantee less than 10 tries.\\n\\n\"zzzzzz\" \\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"] \\n10\\n\\nI understand that the expected solution is \"Either you took too many guesses, or you did not find the secret word.\" But this should not happen given the description of the problem. Therefore, passing all test cases provided by Leetcode dos NOT prove you have the correct algorithm to solve this unsolvable problem."
                    },
                    {
                        "username": "crdbuddy",
                        "content": "\"aaaaab\"\\n[\"aaaaab\",\"aaaaac\",\"aaaaad\",\"aaaaae\",\"aaaaaf\",\"aaaaag\",\"aaaaah\",\"aaaaai\",\"aaaaaj\",\"aaaaak\",\"aaaaal\",\"aaaaam\",\"aaaaan\",\"aaaaao\",\"aaaaap\",\"aaaaaq\"]\\n10"
                    },
                    {
                        "username": "ershivasoni",
                        "content": "It\\'s not possible to guess secret word in < 10 calls. take this test case:\\nsecret - \"lcckzz\"\\nwordlist - [\"acckzz\",\"bcckzz\",\"ccckzz\",\"dcckzz\",\"ecckzz\",\"fcckzz\",\"gcckzz\",\"hcckzz\",\"icckzz\",\"jcckzz\",\"kcckzz\",\"lcckzz\",\"mcckzz\"]\\n\\nHow is everybody\\'s code passing?"
                    },
                    {
                        "username": "iChuan",
                        "content": "Terrible to understand, can anyone explain it? Thanks alot\\n\\n===============\\nJust figured out.\\nString a: \"abcde\"\\nString b: \"aopdw\"\\nvalue is 2 because only letter \\'a\\' and letter \\'d\\' appear at the same position."
                    }
                ]
            },
            {
                "id": 1567090,
                "content": [
                    {
                        "username": "flandrex",
                        "content": "For example, if there are 26 different words in word list:\\n\\n - \\'aaaaaa\\'\\n - \\'aaaaab\\'\\n - ......\\n - \\'aaaaaz\\'\\n\\nIn this case, guessing the correct word in 10 attempts is impossible. Since each wrong attempt can only eliminate 1 answer, nothing else."
                    },
                    {
                        "username": "randxiexyy29",
                        "content": "Looks like the question requires the word list generated by certain distribution. Otherwise, 10 guesses are not sufficient. Take a simple example, let\\'s assume the secret is `abcdef`. I can keep the first 5 leading characteres the same and only mutate the last character. To find out the secret in this word list, you need at least 26 guesses in the worse case because there\\'s no way you can further prune the list..."
                    },
                    {
                        "username": "tinfu330",
                        "content": "Let\\'s simplify the question.\\n\\nGiven a set of character from a - z, one character is picked as the answer, can you gaurentee selecting the correct answer in 10 guesses?\\n\\nIf we cannot even gaurentee the output for a one character string, how are we doing it with a 6 character string? Think about the example [azzzzz, bzzzzz, czzzzz ... zzzzzz], when the query returns 5, it basically means that the first character is not correct, and the worse case is to guess 26 times.\\n\\nDid I miss some important property of this question or is it flawed?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Maybe the first word may not entirely use all the 26 chars. You need to pick those from given ones only. So you essentially might look at each of the 6 indices, and associate only \"used\" characters to a list of strings, and then try to solve it? Would it work?"
                    },
                    {
                        "username": "hamza979",
                        "content": "You cant reliably cover every test case e.g.\\naaaaaa\\nbbbbbb\\ncccccc\\n..\\nzzzzzz\\n\\nsecret word is the last one zzzzzz\\n\\n\\nNo way to reliably get it in 10 guesses since every guess has 0 matches and gives no new information"
                    },
                    {
                        "username": "gadmo",
                        "content": "\"The test cases are generated such that you can guess the secret word with a reasonable strategy\""
                    },
                    {
                        "username": "Ali-Saker-Ali",
                        "content": "\"acckzo\"\\n[\"acckza\",\"acckzb\",\"acckzc\",\"acckzd\",\"acckze\",\"acckzf\",\"acckzg\",\"acckzh\",\"acckzi\",\"acckzj\",\"acckzk\",\"acckzl\",\\n\"acckzm\",\"acckzn\",\"acckzo\",\"acckzp\",\"acckzq\",\"acckzr\",\"acckzs\",\"acckzt\",\"acckzu\",\"acckzv\",\"acckzw\",\"acckzx\",\"acckzy\",\"acckzz\"]\\n10\\n\\nSomething important I found when I tried the above example, what is requested is not really to guess the word in 10 guesses but that your output should match the judge solution output. So in this example, the judge\\'s solution output is also \"Can\\'t guess\". Leetcode should update the question to include this piece of info. which literally makes the problem more or less an AI/ML question and I don\\'t think that it was part of a regular software engineer role interview."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Google laughing at this :)"
                    },
                    {
                        "username": "PRANTO_DAS",
                        "content": "\"vvvvvv\"\\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"]\\n10"
                    },
                    {
                        "username": "wyundong",
                        "content": "For the following edge case, there is no algorithm on earth that can guarantee less than 10 tries.\\n\\n\"zzzzzz\" \\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"] \\n10\\n\\nI understand that the expected solution is \"Either you took too many guesses, or you did not find the secret word.\" But this should not happen given the description of the problem. Therefore, passing all test cases provided by Leetcode dos NOT prove you have the correct algorithm to solve this unsolvable problem."
                    },
                    {
                        "username": "crdbuddy",
                        "content": "\"aaaaab\"\\n[\"aaaaab\",\"aaaaac\",\"aaaaad\",\"aaaaae\",\"aaaaaf\",\"aaaaag\",\"aaaaah\",\"aaaaai\",\"aaaaaj\",\"aaaaak\",\"aaaaal\",\"aaaaam\",\"aaaaan\",\"aaaaao\",\"aaaaap\",\"aaaaaq\"]\\n10"
                    },
                    {
                        "username": "ershivasoni",
                        "content": "It\\'s not possible to guess secret word in < 10 calls. take this test case:\\nsecret - \"lcckzz\"\\nwordlist - [\"acckzz\",\"bcckzz\",\"ccckzz\",\"dcckzz\",\"ecckzz\",\"fcckzz\",\"gcckzz\",\"hcckzz\",\"icckzz\",\"jcckzz\",\"kcckzz\",\"lcckzz\",\"mcckzz\"]\\n\\nHow is everybody\\'s code passing?"
                    },
                    {
                        "username": "iChuan",
                        "content": "Terrible to understand, can anyone explain it? Thanks alot\\n\\n===============\\nJust figured out.\\nString a: \"abcde\"\\nString b: \"aopdw\"\\nvalue is 2 because only letter \\'a\\' and letter \\'d\\' appear at the same position."
                    }
                ]
            },
            {
                "id": 1566190,
                "content": [
                    {
                        "username": "flandrex",
                        "content": "For example, if there are 26 different words in word list:\\n\\n - \\'aaaaaa\\'\\n - \\'aaaaab\\'\\n - ......\\n - \\'aaaaaz\\'\\n\\nIn this case, guessing the correct word in 10 attempts is impossible. Since each wrong attempt can only eliminate 1 answer, nothing else."
                    },
                    {
                        "username": "randxiexyy29",
                        "content": "Looks like the question requires the word list generated by certain distribution. Otherwise, 10 guesses are not sufficient. Take a simple example, let\\'s assume the secret is `abcdef`. I can keep the first 5 leading characteres the same and only mutate the last character. To find out the secret in this word list, you need at least 26 guesses in the worse case because there\\'s no way you can further prune the list..."
                    },
                    {
                        "username": "tinfu330",
                        "content": "Let\\'s simplify the question.\\n\\nGiven a set of character from a - z, one character is picked as the answer, can you gaurentee selecting the correct answer in 10 guesses?\\n\\nIf we cannot even gaurentee the output for a one character string, how are we doing it with a 6 character string? Think about the example [azzzzz, bzzzzz, czzzzz ... zzzzzz], when the query returns 5, it basically means that the first character is not correct, and the worse case is to guess 26 times.\\n\\nDid I miss some important property of this question or is it flawed?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Maybe the first word may not entirely use all the 26 chars. You need to pick those from given ones only. So you essentially might look at each of the 6 indices, and associate only \"used\" characters to a list of strings, and then try to solve it? Would it work?"
                    },
                    {
                        "username": "hamza979",
                        "content": "You cant reliably cover every test case e.g.\\naaaaaa\\nbbbbbb\\ncccccc\\n..\\nzzzzzz\\n\\nsecret word is the last one zzzzzz\\n\\n\\nNo way to reliably get it in 10 guesses since every guess has 0 matches and gives no new information"
                    },
                    {
                        "username": "gadmo",
                        "content": "\"The test cases are generated such that you can guess the secret word with a reasonable strategy\""
                    },
                    {
                        "username": "Ali-Saker-Ali",
                        "content": "\"acckzo\"\\n[\"acckza\",\"acckzb\",\"acckzc\",\"acckzd\",\"acckze\",\"acckzf\",\"acckzg\",\"acckzh\",\"acckzi\",\"acckzj\",\"acckzk\",\"acckzl\",\\n\"acckzm\",\"acckzn\",\"acckzo\",\"acckzp\",\"acckzq\",\"acckzr\",\"acckzs\",\"acckzt\",\"acckzu\",\"acckzv\",\"acckzw\",\"acckzx\",\"acckzy\",\"acckzz\"]\\n10\\n\\nSomething important I found when I tried the above example, what is requested is not really to guess the word in 10 guesses but that your output should match the judge solution output. So in this example, the judge\\'s solution output is also \"Can\\'t guess\". Leetcode should update the question to include this piece of info. which literally makes the problem more or less an AI/ML question and I don\\'t think that it was part of a regular software engineer role interview."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Google laughing at this :)"
                    },
                    {
                        "username": "PRANTO_DAS",
                        "content": "\"vvvvvv\"\\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"]\\n10"
                    },
                    {
                        "username": "wyundong",
                        "content": "For the following edge case, there is no algorithm on earth that can guarantee less than 10 tries.\\n\\n\"zzzzzz\" \\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"] \\n10\\n\\nI understand that the expected solution is \"Either you took too many guesses, or you did not find the secret word.\" But this should not happen given the description of the problem. Therefore, passing all test cases provided by Leetcode dos NOT prove you have the correct algorithm to solve this unsolvable problem."
                    },
                    {
                        "username": "crdbuddy",
                        "content": "\"aaaaab\"\\n[\"aaaaab\",\"aaaaac\",\"aaaaad\",\"aaaaae\",\"aaaaaf\",\"aaaaag\",\"aaaaah\",\"aaaaai\",\"aaaaaj\",\"aaaaak\",\"aaaaal\",\"aaaaam\",\"aaaaan\",\"aaaaao\",\"aaaaap\",\"aaaaaq\"]\\n10"
                    },
                    {
                        "username": "ershivasoni",
                        "content": "It\\'s not possible to guess secret word in < 10 calls. take this test case:\\nsecret - \"lcckzz\"\\nwordlist - [\"acckzz\",\"bcckzz\",\"ccckzz\",\"dcckzz\",\"ecckzz\",\"fcckzz\",\"gcckzz\",\"hcckzz\",\"icckzz\",\"jcckzz\",\"kcckzz\",\"lcckzz\",\"mcckzz\"]\\n\\nHow is everybody\\'s code passing?"
                    },
                    {
                        "username": "iChuan",
                        "content": "Terrible to understand, can anyone explain it? Thanks alot\\n\\n===============\\nJust figured out.\\nString a: \"abcde\"\\nString b: \"aopdw\"\\nvalue is 2 because only letter \\'a\\' and letter \\'d\\' appear at the same position."
                    }
                ]
            },
            {
                "id": 1568774,
                "content": [
                    {
                        "username": "flandrex",
                        "content": "For example, if there are 26 different words in word list:\\n\\n - \\'aaaaaa\\'\\n - \\'aaaaab\\'\\n - ......\\n - \\'aaaaaz\\'\\n\\nIn this case, guessing the correct word in 10 attempts is impossible. Since each wrong attempt can only eliminate 1 answer, nothing else."
                    },
                    {
                        "username": "randxiexyy29",
                        "content": "Looks like the question requires the word list generated by certain distribution. Otherwise, 10 guesses are not sufficient. Take a simple example, let\\'s assume the secret is `abcdef`. I can keep the first 5 leading characteres the same and only mutate the last character. To find out the secret in this word list, you need at least 26 guesses in the worse case because there\\'s no way you can further prune the list..."
                    },
                    {
                        "username": "tinfu330",
                        "content": "Let\\'s simplify the question.\\n\\nGiven a set of character from a - z, one character is picked as the answer, can you gaurentee selecting the correct answer in 10 guesses?\\n\\nIf we cannot even gaurentee the output for a one character string, how are we doing it with a 6 character string? Think about the example [azzzzz, bzzzzz, czzzzz ... zzzzzz], when the query returns 5, it basically means that the first character is not correct, and the worse case is to guess 26 times.\\n\\nDid I miss some important property of this question or is it flawed?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Maybe the first word may not entirely use all the 26 chars. You need to pick those from given ones only. So you essentially might look at each of the 6 indices, and associate only \"used\" characters to a list of strings, and then try to solve it? Would it work?"
                    },
                    {
                        "username": "hamza979",
                        "content": "You cant reliably cover every test case e.g.\\naaaaaa\\nbbbbbb\\ncccccc\\n..\\nzzzzzz\\n\\nsecret word is the last one zzzzzz\\n\\n\\nNo way to reliably get it in 10 guesses since every guess has 0 matches and gives no new information"
                    },
                    {
                        "username": "gadmo",
                        "content": "\"The test cases are generated such that you can guess the secret word with a reasonable strategy\""
                    },
                    {
                        "username": "Ali-Saker-Ali",
                        "content": "\"acckzo\"\\n[\"acckza\",\"acckzb\",\"acckzc\",\"acckzd\",\"acckze\",\"acckzf\",\"acckzg\",\"acckzh\",\"acckzi\",\"acckzj\",\"acckzk\",\"acckzl\",\\n\"acckzm\",\"acckzn\",\"acckzo\",\"acckzp\",\"acckzq\",\"acckzr\",\"acckzs\",\"acckzt\",\"acckzu\",\"acckzv\",\"acckzw\",\"acckzx\",\"acckzy\",\"acckzz\"]\\n10\\n\\nSomething important I found when I tried the above example, what is requested is not really to guess the word in 10 guesses but that your output should match the judge solution output. So in this example, the judge\\'s solution output is also \"Can\\'t guess\". Leetcode should update the question to include this piece of info. which literally makes the problem more or less an AI/ML question and I don\\'t think that it was part of a regular software engineer role interview."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Google laughing at this :)"
                    },
                    {
                        "username": "PRANTO_DAS",
                        "content": "\"vvvvvv\"\\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"]\\n10"
                    },
                    {
                        "username": "wyundong",
                        "content": "For the following edge case, there is no algorithm on earth that can guarantee less than 10 tries.\\n\\n\"zzzzzz\" \\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"] \\n10\\n\\nI understand that the expected solution is \"Either you took too many guesses, or you did not find the secret word.\" But this should not happen given the description of the problem. Therefore, passing all test cases provided by Leetcode dos NOT prove you have the correct algorithm to solve this unsolvable problem."
                    },
                    {
                        "username": "crdbuddy",
                        "content": "\"aaaaab\"\\n[\"aaaaab\",\"aaaaac\",\"aaaaad\",\"aaaaae\",\"aaaaaf\",\"aaaaag\",\"aaaaah\",\"aaaaai\",\"aaaaaj\",\"aaaaak\",\"aaaaal\",\"aaaaam\",\"aaaaan\",\"aaaaao\",\"aaaaap\",\"aaaaaq\"]\\n10"
                    },
                    {
                        "username": "ershivasoni",
                        "content": "It\\'s not possible to guess secret word in < 10 calls. take this test case:\\nsecret - \"lcckzz\"\\nwordlist - [\"acckzz\",\"bcckzz\",\"ccckzz\",\"dcckzz\",\"ecckzz\",\"fcckzz\",\"gcckzz\",\"hcckzz\",\"icckzz\",\"jcckzz\",\"kcckzz\",\"lcckzz\",\"mcckzz\"]\\n\\nHow is everybody\\'s code passing?"
                    },
                    {
                        "username": "iChuan",
                        "content": "Terrible to understand, can anyone explain it? Thanks alot\\n\\n===============\\nJust figured out.\\nString a: \"abcde\"\\nString b: \"aopdw\"\\nvalue is 2 because only letter \\'a\\' and letter \\'d\\' appear at the same position."
                    }
                ]
            },
            {
                "id": 1567704,
                "content": [
                    {
                        "username": "flandrex",
                        "content": "For example, if there are 26 different words in word list:\\n\\n - \\'aaaaaa\\'\\n - \\'aaaaab\\'\\n - ......\\n - \\'aaaaaz\\'\\n\\nIn this case, guessing the correct word in 10 attempts is impossible. Since each wrong attempt can only eliminate 1 answer, nothing else."
                    },
                    {
                        "username": "randxiexyy29",
                        "content": "Looks like the question requires the word list generated by certain distribution. Otherwise, 10 guesses are not sufficient. Take a simple example, let\\'s assume the secret is `abcdef`. I can keep the first 5 leading characteres the same and only mutate the last character. To find out the secret in this word list, you need at least 26 guesses in the worse case because there\\'s no way you can further prune the list..."
                    },
                    {
                        "username": "tinfu330",
                        "content": "Let\\'s simplify the question.\\n\\nGiven a set of character from a - z, one character is picked as the answer, can you gaurentee selecting the correct answer in 10 guesses?\\n\\nIf we cannot even gaurentee the output for a one character string, how are we doing it with a 6 character string? Think about the example [azzzzz, bzzzzz, czzzzz ... zzzzzz], when the query returns 5, it basically means that the first character is not correct, and the worse case is to guess 26 times.\\n\\nDid I miss some important property of this question or is it flawed?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Maybe the first word may not entirely use all the 26 chars. You need to pick those from given ones only. So you essentially might look at each of the 6 indices, and associate only \"used\" characters to a list of strings, and then try to solve it? Would it work?"
                    },
                    {
                        "username": "hamza979",
                        "content": "You cant reliably cover every test case e.g.\\naaaaaa\\nbbbbbb\\ncccccc\\n..\\nzzzzzz\\n\\nsecret word is the last one zzzzzz\\n\\n\\nNo way to reliably get it in 10 guesses since every guess has 0 matches and gives no new information"
                    },
                    {
                        "username": "gadmo",
                        "content": "\"The test cases are generated such that you can guess the secret word with a reasonable strategy\""
                    },
                    {
                        "username": "Ali-Saker-Ali",
                        "content": "\"acckzo\"\\n[\"acckza\",\"acckzb\",\"acckzc\",\"acckzd\",\"acckze\",\"acckzf\",\"acckzg\",\"acckzh\",\"acckzi\",\"acckzj\",\"acckzk\",\"acckzl\",\\n\"acckzm\",\"acckzn\",\"acckzo\",\"acckzp\",\"acckzq\",\"acckzr\",\"acckzs\",\"acckzt\",\"acckzu\",\"acckzv\",\"acckzw\",\"acckzx\",\"acckzy\",\"acckzz\"]\\n10\\n\\nSomething important I found when I tried the above example, what is requested is not really to guess the word in 10 guesses but that your output should match the judge solution output. So in this example, the judge\\'s solution output is also \"Can\\'t guess\". Leetcode should update the question to include this piece of info. which literally makes the problem more or less an AI/ML question and I don\\'t think that it was part of a regular software engineer role interview."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Google laughing at this :)"
                    },
                    {
                        "username": "PRANTO_DAS",
                        "content": "\"vvvvvv\"\\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"]\\n10"
                    },
                    {
                        "username": "wyundong",
                        "content": "For the following edge case, there is no algorithm on earth that can guarantee less than 10 tries.\\n\\n\"zzzzzz\" \\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"] \\n10\\n\\nI understand that the expected solution is \"Either you took too many guesses, or you did not find the secret word.\" But this should not happen given the description of the problem. Therefore, passing all test cases provided by Leetcode dos NOT prove you have the correct algorithm to solve this unsolvable problem."
                    },
                    {
                        "username": "crdbuddy",
                        "content": "\"aaaaab\"\\n[\"aaaaab\",\"aaaaac\",\"aaaaad\",\"aaaaae\",\"aaaaaf\",\"aaaaag\",\"aaaaah\",\"aaaaai\",\"aaaaaj\",\"aaaaak\",\"aaaaal\",\"aaaaam\",\"aaaaan\",\"aaaaao\",\"aaaaap\",\"aaaaaq\"]\\n10"
                    },
                    {
                        "username": "ershivasoni",
                        "content": "It\\'s not possible to guess secret word in < 10 calls. take this test case:\\nsecret - \"lcckzz\"\\nwordlist - [\"acckzz\",\"bcckzz\",\"ccckzz\",\"dcckzz\",\"ecckzz\",\"fcckzz\",\"gcckzz\",\"hcckzz\",\"icckzz\",\"jcckzz\",\"kcckzz\",\"lcckzz\",\"mcckzz\"]\\n\\nHow is everybody\\'s code passing?"
                    },
                    {
                        "username": "iChuan",
                        "content": "Terrible to understand, can anyone explain it? Thanks alot\\n\\n===============\\nJust figured out.\\nString a: \"abcde\"\\nString b: \"aopdw\"\\nvalue is 2 because only letter \\'a\\' and letter \\'d\\' appear at the same position."
                    }
                ]
            },
            {
                "id": 1566401,
                "content": [
                    {
                        "username": "flandrex",
                        "content": "For example, if there are 26 different words in word list:\\n\\n - \\'aaaaaa\\'\\n - \\'aaaaab\\'\\n - ......\\n - \\'aaaaaz\\'\\n\\nIn this case, guessing the correct word in 10 attempts is impossible. Since each wrong attempt can only eliminate 1 answer, nothing else."
                    },
                    {
                        "username": "randxiexyy29",
                        "content": "Looks like the question requires the word list generated by certain distribution. Otherwise, 10 guesses are not sufficient. Take a simple example, let\\'s assume the secret is `abcdef`. I can keep the first 5 leading characteres the same and only mutate the last character. To find out the secret in this word list, you need at least 26 guesses in the worse case because there\\'s no way you can further prune the list..."
                    },
                    {
                        "username": "tinfu330",
                        "content": "Let\\'s simplify the question.\\n\\nGiven a set of character from a - z, one character is picked as the answer, can you gaurentee selecting the correct answer in 10 guesses?\\n\\nIf we cannot even gaurentee the output for a one character string, how are we doing it with a 6 character string? Think about the example [azzzzz, bzzzzz, czzzzz ... zzzzzz], when the query returns 5, it basically means that the first character is not correct, and the worse case is to guess 26 times.\\n\\nDid I miss some important property of this question or is it flawed?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Maybe the first word may not entirely use all the 26 chars. You need to pick those from given ones only. So you essentially might look at each of the 6 indices, and associate only \"used\" characters to a list of strings, and then try to solve it? Would it work?"
                    },
                    {
                        "username": "hamza979",
                        "content": "You cant reliably cover every test case e.g.\\naaaaaa\\nbbbbbb\\ncccccc\\n..\\nzzzzzz\\n\\nsecret word is the last one zzzzzz\\n\\n\\nNo way to reliably get it in 10 guesses since every guess has 0 matches and gives no new information"
                    },
                    {
                        "username": "gadmo",
                        "content": "\"The test cases are generated such that you can guess the secret word with a reasonable strategy\""
                    },
                    {
                        "username": "Ali-Saker-Ali",
                        "content": "\"acckzo\"\\n[\"acckza\",\"acckzb\",\"acckzc\",\"acckzd\",\"acckze\",\"acckzf\",\"acckzg\",\"acckzh\",\"acckzi\",\"acckzj\",\"acckzk\",\"acckzl\",\\n\"acckzm\",\"acckzn\",\"acckzo\",\"acckzp\",\"acckzq\",\"acckzr\",\"acckzs\",\"acckzt\",\"acckzu\",\"acckzv\",\"acckzw\",\"acckzx\",\"acckzy\",\"acckzz\"]\\n10\\n\\nSomething important I found when I tried the above example, what is requested is not really to guess the word in 10 guesses but that your output should match the judge solution output. So in this example, the judge\\'s solution output is also \"Can\\'t guess\". Leetcode should update the question to include this piece of info. which literally makes the problem more or less an AI/ML question and I don\\'t think that it was part of a regular software engineer role interview."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Google laughing at this :)"
                    },
                    {
                        "username": "PRANTO_DAS",
                        "content": "\"vvvvvv\"\\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"]\\n10"
                    },
                    {
                        "username": "wyundong",
                        "content": "For the following edge case, there is no algorithm on earth that can guarantee less than 10 tries.\\n\\n\"zzzzzz\" \\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"] \\n10\\n\\nI understand that the expected solution is \"Either you took too many guesses, or you did not find the secret word.\" But this should not happen given the description of the problem. Therefore, passing all test cases provided by Leetcode dos NOT prove you have the correct algorithm to solve this unsolvable problem."
                    },
                    {
                        "username": "crdbuddy",
                        "content": "\"aaaaab\"\\n[\"aaaaab\",\"aaaaac\",\"aaaaad\",\"aaaaae\",\"aaaaaf\",\"aaaaag\",\"aaaaah\",\"aaaaai\",\"aaaaaj\",\"aaaaak\",\"aaaaal\",\"aaaaam\",\"aaaaan\",\"aaaaao\",\"aaaaap\",\"aaaaaq\"]\\n10"
                    },
                    {
                        "username": "ershivasoni",
                        "content": "It\\'s not possible to guess secret word in < 10 calls. take this test case:\\nsecret - \"lcckzz\"\\nwordlist - [\"acckzz\",\"bcckzz\",\"ccckzz\",\"dcckzz\",\"ecckzz\",\"fcckzz\",\"gcckzz\",\"hcckzz\",\"icckzz\",\"jcckzz\",\"kcckzz\",\"lcckzz\",\"mcckzz\"]\\n\\nHow is everybody\\'s code passing?"
                    },
                    {
                        "username": "iChuan",
                        "content": "Terrible to understand, can anyone explain it? Thanks alot\\n\\n===============\\nJust figured out.\\nString a: \"abcde\"\\nString b: \"aopdw\"\\nvalue is 2 because only letter \\'a\\' and letter \\'d\\' appear at the same position."
                    }
                ]
            },
            {
                "id": 1568674,
                "content": [
                    {
                        "username": "flandrex",
                        "content": "For example, if there are 26 different words in word list:\\n\\n - \\'aaaaaa\\'\\n - \\'aaaaab\\'\\n - ......\\n - \\'aaaaaz\\'\\n\\nIn this case, guessing the correct word in 10 attempts is impossible. Since each wrong attempt can only eliminate 1 answer, nothing else."
                    },
                    {
                        "username": "randxiexyy29",
                        "content": "Looks like the question requires the word list generated by certain distribution. Otherwise, 10 guesses are not sufficient. Take a simple example, let\\'s assume the secret is `abcdef`. I can keep the first 5 leading characteres the same and only mutate the last character. To find out the secret in this word list, you need at least 26 guesses in the worse case because there\\'s no way you can further prune the list..."
                    },
                    {
                        "username": "tinfu330",
                        "content": "Let\\'s simplify the question.\\n\\nGiven a set of character from a - z, one character is picked as the answer, can you gaurentee selecting the correct answer in 10 guesses?\\n\\nIf we cannot even gaurentee the output for a one character string, how are we doing it with a 6 character string? Think about the example [azzzzz, bzzzzz, czzzzz ... zzzzzz], when the query returns 5, it basically means that the first character is not correct, and the worse case is to guess 26 times.\\n\\nDid I miss some important property of this question or is it flawed?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Maybe the first word may not entirely use all the 26 chars. You need to pick those from given ones only. So you essentially might look at each of the 6 indices, and associate only \"used\" characters to a list of strings, and then try to solve it? Would it work?"
                    },
                    {
                        "username": "hamza979",
                        "content": "You cant reliably cover every test case e.g.\\naaaaaa\\nbbbbbb\\ncccccc\\n..\\nzzzzzz\\n\\nsecret word is the last one zzzzzz\\n\\n\\nNo way to reliably get it in 10 guesses since every guess has 0 matches and gives no new information"
                    },
                    {
                        "username": "gadmo",
                        "content": "\"The test cases are generated such that you can guess the secret word with a reasonable strategy\""
                    },
                    {
                        "username": "Ali-Saker-Ali",
                        "content": "\"acckzo\"\\n[\"acckza\",\"acckzb\",\"acckzc\",\"acckzd\",\"acckze\",\"acckzf\",\"acckzg\",\"acckzh\",\"acckzi\",\"acckzj\",\"acckzk\",\"acckzl\",\\n\"acckzm\",\"acckzn\",\"acckzo\",\"acckzp\",\"acckzq\",\"acckzr\",\"acckzs\",\"acckzt\",\"acckzu\",\"acckzv\",\"acckzw\",\"acckzx\",\"acckzy\",\"acckzz\"]\\n10\\n\\nSomething important I found when I tried the above example, what is requested is not really to guess the word in 10 guesses but that your output should match the judge solution output. So in this example, the judge\\'s solution output is also \"Can\\'t guess\". Leetcode should update the question to include this piece of info. which literally makes the problem more or less an AI/ML question and I don\\'t think that it was part of a regular software engineer role interview."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Google laughing at this :)"
                    },
                    {
                        "username": "PRANTO_DAS",
                        "content": "\"vvvvvv\"\\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"]\\n10"
                    },
                    {
                        "username": "wyundong",
                        "content": "For the following edge case, there is no algorithm on earth that can guarantee less than 10 tries.\\n\\n\"zzzzzz\" \\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"] \\n10\\n\\nI understand that the expected solution is \"Either you took too many guesses, or you did not find the secret word.\" But this should not happen given the description of the problem. Therefore, passing all test cases provided by Leetcode dos NOT prove you have the correct algorithm to solve this unsolvable problem."
                    },
                    {
                        "username": "crdbuddy",
                        "content": "\"aaaaab\"\\n[\"aaaaab\",\"aaaaac\",\"aaaaad\",\"aaaaae\",\"aaaaaf\",\"aaaaag\",\"aaaaah\",\"aaaaai\",\"aaaaaj\",\"aaaaak\",\"aaaaal\",\"aaaaam\",\"aaaaan\",\"aaaaao\",\"aaaaap\",\"aaaaaq\"]\\n10"
                    },
                    {
                        "username": "ershivasoni",
                        "content": "It\\'s not possible to guess secret word in < 10 calls. take this test case:\\nsecret - \"lcckzz\"\\nwordlist - [\"acckzz\",\"bcckzz\",\"ccckzz\",\"dcckzz\",\"ecckzz\",\"fcckzz\",\"gcckzz\",\"hcckzz\",\"icckzz\",\"jcckzz\",\"kcckzz\",\"lcckzz\",\"mcckzz\"]\\n\\nHow is everybody\\'s code passing?"
                    },
                    {
                        "username": "iChuan",
                        "content": "Terrible to understand, can anyone explain it? Thanks alot\\n\\n===============\\nJust figured out.\\nString a: \"abcde\"\\nString b: \"aopdw\"\\nvalue is 2 because only letter \\'a\\' and letter \\'d\\' appear at the same position."
                    }
                ]
            },
            {
                "id": 1570494,
                "content": [
                    {
                        "username": "flandrex",
                        "content": "For example, if there are 26 different words in word list:\\n\\n - \\'aaaaaa\\'\\n - \\'aaaaab\\'\\n - ......\\n - \\'aaaaaz\\'\\n\\nIn this case, guessing the correct word in 10 attempts is impossible. Since each wrong attempt can only eliminate 1 answer, nothing else."
                    },
                    {
                        "username": "randxiexyy29",
                        "content": "Looks like the question requires the word list generated by certain distribution. Otherwise, 10 guesses are not sufficient. Take a simple example, let\\'s assume the secret is `abcdef`. I can keep the first 5 leading characteres the same and only mutate the last character. To find out the secret in this word list, you need at least 26 guesses in the worse case because there\\'s no way you can further prune the list..."
                    },
                    {
                        "username": "tinfu330",
                        "content": "Let\\'s simplify the question.\\n\\nGiven a set of character from a - z, one character is picked as the answer, can you gaurentee selecting the correct answer in 10 guesses?\\n\\nIf we cannot even gaurentee the output for a one character string, how are we doing it with a 6 character string? Think about the example [azzzzz, bzzzzz, czzzzz ... zzzzzz], when the query returns 5, it basically means that the first character is not correct, and the worse case is to guess 26 times.\\n\\nDid I miss some important property of this question or is it flawed?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Maybe the first word may not entirely use all the 26 chars. You need to pick those from given ones only. So you essentially might look at each of the 6 indices, and associate only \"used\" characters to a list of strings, and then try to solve it? Would it work?"
                    },
                    {
                        "username": "hamza979",
                        "content": "You cant reliably cover every test case e.g.\\naaaaaa\\nbbbbbb\\ncccccc\\n..\\nzzzzzz\\n\\nsecret word is the last one zzzzzz\\n\\n\\nNo way to reliably get it in 10 guesses since every guess has 0 matches and gives no new information"
                    },
                    {
                        "username": "gadmo",
                        "content": "\"The test cases are generated such that you can guess the secret word with a reasonable strategy\""
                    },
                    {
                        "username": "Ali-Saker-Ali",
                        "content": "\"acckzo\"\\n[\"acckza\",\"acckzb\",\"acckzc\",\"acckzd\",\"acckze\",\"acckzf\",\"acckzg\",\"acckzh\",\"acckzi\",\"acckzj\",\"acckzk\",\"acckzl\",\\n\"acckzm\",\"acckzn\",\"acckzo\",\"acckzp\",\"acckzq\",\"acckzr\",\"acckzs\",\"acckzt\",\"acckzu\",\"acckzv\",\"acckzw\",\"acckzx\",\"acckzy\",\"acckzz\"]\\n10\\n\\nSomething important I found when I tried the above example, what is requested is not really to guess the word in 10 guesses but that your output should match the judge solution output. So in this example, the judge\\'s solution output is also \"Can\\'t guess\". Leetcode should update the question to include this piece of info. which literally makes the problem more or less an AI/ML question and I don\\'t think that it was part of a regular software engineer role interview."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Google laughing at this :)"
                    },
                    {
                        "username": "PRANTO_DAS",
                        "content": "\"vvvvvv\"\\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"]\\n10"
                    },
                    {
                        "username": "wyundong",
                        "content": "For the following edge case, there is no algorithm on earth that can guarantee less than 10 tries.\\n\\n\"zzzzzz\" \\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"] \\n10\\n\\nI understand that the expected solution is \"Either you took too many guesses, or you did not find the secret word.\" But this should not happen given the description of the problem. Therefore, passing all test cases provided by Leetcode dos NOT prove you have the correct algorithm to solve this unsolvable problem."
                    },
                    {
                        "username": "crdbuddy",
                        "content": "\"aaaaab\"\\n[\"aaaaab\",\"aaaaac\",\"aaaaad\",\"aaaaae\",\"aaaaaf\",\"aaaaag\",\"aaaaah\",\"aaaaai\",\"aaaaaj\",\"aaaaak\",\"aaaaal\",\"aaaaam\",\"aaaaan\",\"aaaaao\",\"aaaaap\",\"aaaaaq\"]\\n10"
                    },
                    {
                        "username": "ershivasoni",
                        "content": "It\\'s not possible to guess secret word in < 10 calls. take this test case:\\nsecret - \"lcckzz\"\\nwordlist - [\"acckzz\",\"bcckzz\",\"ccckzz\",\"dcckzz\",\"ecckzz\",\"fcckzz\",\"gcckzz\",\"hcckzz\",\"icckzz\",\"jcckzz\",\"kcckzz\",\"lcckzz\",\"mcckzz\"]\\n\\nHow is everybody\\'s code passing?"
                    },
                    {
                        "username": "iChuan",
                        "content": "Terrible to understand, can anyone explain it? Thanks alot\\n\\n===============\\nJust figured out.\\nString a: \"abcde\"\\nString b: \"aopdw\"\\nvalue is 2 because only letter \\'a\\' and letter \\'d\\' appear at the same position."
                    }
                ]
            },
            {
                "id": 1572125,
                "content": [
                    {
                        "username": "flandrex",
                        "content": "For example, if there are 26 different words in word list:\\n\\n - \\'aaaaaa\\'\\n - \\'aaaaab\\'\\n - ......\\n - \\'aaaaaz\\'\\n\\nIn this case, guessing the correct word in 10 attempts is impossible. Since each wrong attempt can only eliminate 1 answer, nothing else."
                    },
                    {
                        "username": "randxiexyy29",
                        "content": "Looks like the question requires the word list generated by certain distribution. Otherwise, 10 guesses are not sufficient. Take a simple example, let\\'s assume the secret is `abcdef`. I can keep the first 5 leading characteres the same and only mutate the last character. To find out the secret in this word list, you need at least 26 guesses in the worse case because there\\'s no way you can further prune the list..."
                    },
                    {
                        "username": "tinfu330",
                        "content": "Let\\'s simplify the question.\\n\\nGiven a set of character from a - z, one character is picked as the answer, can you gaurentee selecting the correct answer in 10 guesses?\\n\\nIf we cannot even gaurentee the output for a one character string, how are we doing it with a 6 character string? Think about the example [azzzzz, bzzzzz, czzzzz ... zzzzzz], when the query returns 5, it basically means that the first character is not correct, and the worse case is to guess 26 times.\\n\\nDid I miss some important property of this question or is it flawed?"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Maybe the first word may not entirely use all the 26 chars. You need to pick those from given ones only. So you essentially might look at each of the 6 indices, and associate only \"used\" characters to a list of strings, and then try to solve it? Would it work?"
                    },
                    {
                        "username": "hamza979",
                        "content": "You cant reliably cover every test case e.g.\\naaaaaa\\nbbbbbb\\ncccccc\\n..\\nzzzzzz\\n\\nsecret word is the last one zzzzzz\\n\\n\\nNo way to reliably get it in 10 guesses since every guess has 0 matches and gives no new information"
                    },
                    {
                        "username": "gadmo",
                        "content": "\"The test cases are generated such that you can guess the secret word with a reasonable strategy\""
                    },
                    {
                        "username": "Ali-Saker-Ali",
                        "content": "\"acckzo\"\\n[\"acckza\",\"acckzb\",\"acckzc\",\"acckzd\",\"acckze\",\"acckzf\",\"acckzg\",\"acckzh\",\"acckzi\",\"acckzj\",\"acckzk\",\"acckzl\",\\n\"acckzm\",\"acckzn\",\"acckzo\",\"acckzp\",\"acckzq\",\"acckzr\",\"acckzs\",\"acckzt\",\"acckzu\",\"acckzv\",\"acckzw\",\"acckzx\",\"acckzy\",\"acckzz\"]\\n10\\n\\nSomething important I found when I tried the above example, what is requested is not really to guess the word in 10 guesses but that your output should match the judge solution output. So in this example, the judge\\'s solution output is also \"Can\\'t guess\". Leetcode should update the question to include this piece of info. which literally makes the problem more or less an AI/ML question and I don\\'t think that it was part of a regular software engineer role interview."
                    },
                    {
                        "username": "LC_Binod",
                        "content": "Google laughing at this :)"
                    },
                    {
                        "username": "PRANTO_DAS",
                        "content": "\"vvvvvv\"\\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"]\\n10"
                    },
                    {
                        "username": "wyundong",
                        "content": "For the following edge case, there is no algorithm on earth that can guarantee less than 10 tries.\\n\\n\"zzzzzz\" \\n[\"aaaaaa\", \"bbbbbb\", \"cccccc\", \"dddddd\", \"eeeeee\", \"ffffff\", \"gggggg\", \"hhhhhh\", \"iiiiii\", \"jjjjjj\", \"kkkkkk\", \"llllll\", \"mmmmmm\", \"nnnnnn\", \"oooooo\", \"pppppp\", \"qqqqqq\", \"rrrrrr\", \"ssssss\", \"tttttt\", \"uuuuuu\", \"vvvvvv\", \"wwwwww\", \"xxxxxx\", \"yyyyyy\", \"zzzzzz\"] \\n10\\n\\nI understand that the expected solution is \"Either you took too many guesses, or you did not find the secret word.\" But this should not happen given the description of the problem. Therefore, passing all test cases provided by Leetcode dos NOT prove you have the correct algorithm to solve this unsolvable problem."
                    },
                    {
                        "username": "crdbuddy",
                        "content": "\"aaaaab\"\\n[\"aaaaab\",\"aaaaac\",\"aaaaad\",\"aaaaae\",\"aaaaaf\",\"aaaaag\",\"aaaaah\",\"aaaaai\",\"aaaaaj\",\"aaaaak\",\"aaaaal\",\"aaaaam\",\"aaaaan\",\"aaaaao\",\"aaaaap\",\"aaaaaq\"]\\n10"
                    },
                    {
                        "username": "ershivasoni",
                        "content": "It\\'s not possible to guess secret word in < 10 calls. take this test case:\\nsecret - \"lcckzz\"\\nwordlist - [\"acckzz\",\"bcckzz\",\"ccckzz\",\"dcckzz\",\"ecckzz\",\"fcckzz\",\"gcckzz\",\"hcckzz\",\"icckzz\",\"jcckzz\",\"kcckzz\",\"lcckzz\",\"mcckzz\"]\\n\\nHow is everybody\\'s code passing?"
                    },
                    {
                        "username": "iChuan",
                        "content": "Terrible to understand, can anyone explain it? Thanks alot\\n\\n===============\\nJust figured out.\\nString a: \"abcde\"\\nString b: \"aopdw\"\\nvalue is 2 because only letter \\'a\\' and letter \\'d\\' appear at the same position."
                    }
                ]
            },
            {
                "id": 1714856,
                "content": [
                    {
                        "username": "uttarandas501",
                        "content": "Why is the question setter so miserly with sample test-cases. Give some more."
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "How can I pass eleventh testcase in 10 attempts? \n[\"abcdef\",\"acdefg\",\"adefgh\",\"aefghi\",\"afghij\",\"aghijk\",\"ahijkl\",\"aijklm\",\"ajklmn\",\"aklmno\",\"almnoz\",\"anopqr\",\"azzzzz\"]\n\nP.S.\nOk, I solved it (I shared the solution) ;)"
                    },
                    {
                        "username": "GBT3101",
                        "content": "lets try this, and imagine that you don\\'t \"pop\" from array, you go from the start:\\nsecret word: \\'zzzzzz\\'\\nwordList: [\\'aaaaaa\\', \\'bbbbbb\\', \\'cccccc\\', \\'dddddd\\', \\'eeeeee\\', \\'ffffff\\', ...........(all the abc)....., \\'zzzzzz\\'] (list is 26 items, not even 100)\\n\\nAll the other words gives 0 similarity, you can\\'t filter any other word and you just keep guessing hoping to get lucky.\\n\\nCan anyone answer this? is there any way to solve this testcase in 10 guesses??? Feels like an impossible idiotic question..."
                    },
                    {
                        "username": "anh_tai",
                        "content": "For the following testcase  = {\"aaaaaa\", \"bbbbbb\", \"cccccc\", ........, \"zzzzzz\"} with 26 elements. If picking any words other than the secret word, the master will return 0. How could using exactly 10 guesses could resolve for this case."
                    },
                    {
                        "username": "thesavage4",
                        "content": "See https://youtu.be/r06U6qn9ZpA for a great video explanation."
                    },
                    {
                        "username": "zinechant",
                        "content": "Just 26 words;\\naaaaaa\\naaaaab\\naaaaac\\naaaaad\\naaaaae\\n.\\n.\\n.\\naaaaay\\naaaaaz\\n\\nBecause none of them is special among others, in the worst case you would need to guess 25 times. Seems 10 is not enough.\\n\\nCases with higher number of minimum guesses can be constructed with more digits for sure.\\n\\n\\n"
                    },
                    {
                        "username": "victorvianna",
                        "content": "In the official solution it\\'s stated that \"the number of guesses is bounded by log N\". I can see how this may be true with some average case analysis, assuming that the best guess distributes the remaining candidates evenly in 6 groups (0,...,5 matches). But I wonder if the bound also works for the worst case, and in that case, what\\'s the proof?"
                    },
                    {
                        "username": "havoc_hammer",
                        "content": "\"vftnkr\"\\n[\"mjpsce\",\"giwiyk\",\"slbnia\",\"pullbr\",\"ezvczd\",\"dwkrmt\",\"qgzebh\",\"wvhhlm\",\"kqbmny\",\"zpvrkz\",\"pdwxvy\",\"gilywa\",\"gmrrdc\",\"vvqvla\",\"rmjirt\",\"qmvykq\",\"mhbmuq\",\"unplzn\",\"qkcied\",\"eignxg\",\"fbfgng\",\"xpizga\",\"twubzr\",\"nnfaxr\",\"skknhe\",\"twautl\",\"nglrst\",\"mibyks\",\"qrbmpx\",\"ukgjkq\",\"mhxxfb\",\"deggal\",\"bwpvsp\",\"uirtak\",\"tqkzfk\",\"hfzawa\",\"jahjgn\",\"mteyut\",\"jzbqbv\",\"ttddtf\",\"auuwgn\",\"untihn\",\"gbhnog\",\"zowaol\",\"feitjl\",\"omtiur\",\"kwdsgx\",\"tggcqq\",\"qachdn\",\"dixtat\",\"hcsvbw\",\"chduyy\",\"gpdtft\",\"bjxzky\",\"uvvvko\",\"jzcpiv\",\"gtyjau\",\"unsmok\",\"vfcmhc\",\"hvxnut\",\"orlwku\",\"ejllrv\",\"jbrskt\",\"xnxxdi\",\"rfreiv\",\"njbvwj\",\"pkydxy\",\"jksiwj\",\"iaembk\",\"pyqdip\",\"exkykx\",\"uxgecc\",\"khzqgy\",\"dehkbu\",\"ahplng\",\"jomiik\",\"nmcsfe\",\"bclcbp\",\"xfiefi\",\"soiwde\",\"tcjkjp\",\"wervlz\",\"dcthgv\",\"hwwghe\",\"hdlkll\",\"dpzoxb\",\"mpiviy\",\"cprcwo\",\"molttv\",\"dwjtdp\",\"qiilsr\",\"dbnaxs\",\"dbozaw\",\"webcyp\",\"vftnkr\",\"iurlzf\",\"giqcfc\",\"pcghoi\",\"zupyzn\",\"xckegy\"]\\n10\\n\\nThis test is faling when I submit, but it is passing when I do a run code."
                    },
                    {
                        "username": "tianyang19910112",
                        "content": "As descripted in title, If wordlist=[\"abcdea\",\"abcdeb\",...,\"abcdez\"], len(wordlist)=26"
                    },
                    {
                        "username": "edaengineer",
                        "content": "I thought the description was a bit unclear. I can\\'t see how if it is guaranteed to be solved within 10 guesses even if the word list is limited to 100 words.\\n\\nOr do we just have to make the best 10 guesss and the testcases/wordlists etc are set up so that it\\'s doable in 10 guesses? but that may not be true for any random secret word in wordlist, True??"
                    }
                ]
            },
            {
                "id": 1718258,
                "content": [
                    {
                        "username": "uttarandas501",
                        "content": "Why is the question setter so miserly with sample test-cases. Give some more."
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "How can I pass eleventh testcase in 10 attempts? \n[\"abcdef\",\"acdefg\",\"adefgh\",\"aefghi\",\"afghij\",\"aghijk\",\"ahijkl\",\"aijklm\",\"ajklmn\",\"aklmno\",\"almnoz\",\"anopqr\",\"azzzzz\"]\n\nP.S.\nOk, I solved it (I shared the solution) ;)"
                    },
                    {
                        "username": "GBT3101",
                        "content": "lets try this, and imagine that you don\\'t \"pop\" from array, you go from the start:\\nsecret word: \\'zzzzzz\\'\\nwordList: [\\'aaaaaa\\', \\'bbbbbb\\', \\'cccccc\\', \\'dddddd\\', \\'eeeeee\\', \\'ffffff\\', ...........(all the abc)....., \\'zzzzzz\\'] (list is 26 items, not even 100)\\n\\nAll the other words gives 0 similarity, you can\\'t filter any other word and you just keep guessing hoping to get lucky.\\n\\nCan anyone answer this? is there any way to solve this testcase in 10 guesses??? Feels like an impossible idiotic question..."
                    },
                    {
                        "username": "anh_tai",
                        "content": "For the following testcase  = {\"aaaaaa\", \"bbbbbb\", \"cccccc\", ........, \"zzzzzz\"} with 26 elements. If picking any words other than the secret word, the master will return 0. How could using exactly 10 guesses could resolve for this case."
                    },
                    {
                        "username": "thesavage4",
                        "content": "See https://youtu.be/r06U6qn9ZpA for a great video explanation."
                    },
                    {
                        "username": "zinechant",
                        "content": "Just 26 words;\\naaaaaa\\naaaaab\\naaaaac\\naaaaad\\naaaaae\\n.\\n.\\n.\\naaaaay\\naaaaaz\\n\\nBecause none of them is special among others, in the worst case you would need to guess 25 times. Seems 10 is not enough.\\n\\nCases with higher number of minimum guesses can be constructed with more digits for sure.\\n\\n\\n"
                    },
                    {
                        "username": "victorvianna",
                        "content": "In the official solution it\\'s stated that \"the number of guesses is bounded by log N\". I can see how this may be true with some average case analysis, assuming that the best guess distributes the remaining candidates evenly in 6 groups (0,...,5 matches). But I wonder if the bound also works for the worst case, and in that case, what\\'s the proof?"
                    },
                    {
                        "username": "havoc_hammer",
                        "content": "\"vftnkr\"\\n[\"mjpsce\",\"giwiyk\",\"slbnia\",\"pullbr\",\"ezvczd\",\"dwkrmt\",\"qgzebh\",\"wvhhlm\",\"kqbmny\",\"zpvrkz\",\"pdwxvy\",\"gilywa\",\"gmrrdc\",\"vvqvla\",\"rmjirt\",\"qmvykq\",\"mhbmuq\",\"unplzn\",\"qkcied\",\"eignxg\",\"fbfgng\",\"xpizga\",\"twubzr\",\"nnfaxr\",\"skknhe\",\"twautl\",\"nglrst\",\"mibyks\",\"qrbmpx\",\"ukgjkq\",\"mhxxfb\",\"deggal\",\"bwpvsp\",\"uirtak\",\"tqkzfk\",\"hfzawa\",\"jahjgn\",\"mteyut\",\"jzbqbv\",\"ttddtf\",\"auuwgn\",\"untihn\",\"gbhnog\",\"zowaol\",\"feitjl\",\"omtiur\",\"kwdsgx\",\"tggcqq\",\"qachdn\",\"dixtat\",\"hcsvbw\",\"chduyy\",\"gpdtft\",\"bjxzky\",\"uvvvko\",\"jzcpiv\",\"gtyjau\",\"unsmok\",\"vfcmhc\",\"hvxnut\",\"orlwku\",\"ejllrv\",\"jbrskt\",\"xnxxdi\",\"rfreiv\",\"njbvwj\",\"pkydxy\",\"jksiwj\",\"iaembk\",\"pyqdip\",\"exkykx\",\"uxgecc\",\"khzqgy\",\"dehkbu\",\"ahplng\",\"jomiik\",\"nmcsfe\",\"bclcbp\",\"xfiefi\",\"soiwde\",\"tcjkjp\",\"wervlz\",\"dcthgv\",\"hwwghe\",\"hdlkll\",\"dpzoxb\",\"mpiviy\",\"cprcwo\",\"molttv\",\"dwjtdp\",\"qiilsr\",\"dbnaxs\",\"dbozaw\",\"webcyp\",\"vftnkr\",\"iurlzf\",\"giqcfc\",\"pcghoi\",\"zupyzn\",\"xckegy\"]\\n10\\n\\nThis test is faling when I submit, but it is passing when I do a run code."
                    },
                    {
                        "username": "tianyang19910112",
                        "content": "As descripted in title, If wordlist=[\"abcdea\",\"abcdeb\",...,\"abcdez\"], len(wordlist)=26"
                    },
                    {
                        "username": "edaengineer",
                        "content": "I thought the description was a bit unclear. I can\\'t see how if it is guaranteed to be solved within 10 guesses even if the word list is limited to 100 words.\\n\\nOr do we just have to make the best 10 guesss and the testcases/wordlists etc are set up so that it\\'s doable in 10 guesses? but that may not be true for any random secret word in wordlist, True??"
                    }
                ]
            },
            {
                "id": 1575570,
                "content": [
                    {
                        "username": "uttarandas501",
                        "content": "Why is the question setter so miserly with sample test-cases. Give some more."
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "How can I pass eleventh testcase in 10 attempts? \n[\"abcdef\",\"acdefg\",\"adefgh\",\"aefghi\",\"afghij\",\"aghijk\",\"ahijkl\",\"aijklm\",\"ajklmn\",\"aklmno\",\"almnoz\",\"anopqr\",\"azzzzz\"]\n\nP.S.\nOk, I solved it (I shared the solution) ;)"
                    },
                    {
                        "username": "GBT3101",
                        "content": "lets try this, and imagine that you don\\'t \"pop\" from array, you go from the start:\\nsecret word: \\'zzzzzz\\'\\nwordList: [\\'aaaaaa\\', \\'bbbbbb\\', \\'cccccc\\', \\'dddddd\\', \\'eeeeee\\', \\'ffffff\\', ...........(all the abc)....., \\'zzzzzz\\'] (list is 26 items, not even 100)\\n\\nAll the other words gives 0 similarity, you can\\'t filter any other word and you just keep guessing hoping to get lucky.\\n\\nCan anyone answer this? is there any way to solve this testcase in 10 guesses??? Feels like an impossible idiotic question..."
                    },
                    {
                        "username": "anh_tai",
                        "content": "For the following testcase  = {\"aaaaaa\", \"bbbbbb\", \"cccccc\", ........, \"zzzzzz\"} with 26 elements. If picking any words other than the secret word, the master will return 0. How could using exactly 10 guesses could resolve for this case."
                    },
                    {
                        "username": "thesavage4",
                        "content": "See https://youtu.be/r06U6qn9ZpA for a great video explanation."
                    },
                    {
                        "username": "zinechant",
                        "content": "Just 26 words;\\naaaaaa\\naaaaab\\naaaaac\\naaaaad\\naaaaae\\n.\\n.\\n.\\naaaaay\\naaaaaz\\n\\nBecause none of them is special among others, in the worst case you would need to guess 25 times. Seems 10 is not enough.\\n\\nCases with higher number of minimum guesses can be constructed with more digits for sure.\\n\\n\\n"
                    },
                    {
                        "username": "victorvianna",
                        "content": "In the official solution it\\'s stated that \"the number of guesses is bounded by log N\". I can see how this may be true with some average case analysis, assuming that the best guess distributes the remaining candidates evenly in 6 groups (0,...,5 matches). But I wonder if the bound also works for the worst case, and in that case, what\\'s the proof?"
                    },
                    {
                        "username": "havoc_hammer",
                        "content": "\"vftnkr\"\\n[\"mjpsce\",\"giwiyk\",\"slbnia\",\"pullbr\",\"ezvczd\",\"dwkrmt\",\"qgzebh\",\"wvhhlm\",\"kqbmny\",\"zpvrkz\",\"pdwxvy\",\"gilywa\",\"gmrrdc\",\"vvqvla\",\"rmjirt\",\"qmvykq\",\"mhbmuq\",\"unplzn\",\"qkcied\",\"eignxg\",\"fbfgng\",\"xpizga\",\"twubzr\",\"nnfaxr\",\"skknhe\",\"twautl\",\"nglrst\",\"mibyks\",\"qrbmpx\",\"ukgjkq\",\"mhxxfb\",\"deggal\",\"bwpvsp\",\"uirtak\",\"tqkzfk\",\"hfzawa\",\"jahjgn\",\"mteyut\",\"jzbqbv\",\"ttddtf\",\"auuwgn\",\"untihn\",\"gbhnog\",\"zowaol\",\"feitjl\",\"omtiur\",\"kwdsgx\",\"tggcqq\",\"qachdn\",\"dixtat\",\"hcsvbw\",\"chduyy\",\"gpdtft\",\"bjxzky\",\"uvvvko\",\"jzcpiv\",\"gtyjau\",\"unsmok\",\"vfcmhc\",\"hvxnut\",\"orlwku\",\"ejllrv\",\"jbrskt\",\"xnxxdi\",\"rfreiv\",\"njbvwj\",\"pkydxy\",\"jksiwj\",\"iaembk\",\"pyqdip\",\"exkykx\",\"uxgecc\",\"khzqgy\",\"dehkbu\",\"ahplng\",\"jomiik\",\"nmcsfe\",\"bclcbp\",\"xfiefi\",\"soiwde\",\"tcjkjp\",\"wervlz\",\"dcthgv\",\"hwwghe\",\"hdlkll\",\"dpzoxb\",\"mpiviy\",\"cprcwo\",\"molttv\",\"dwjtdp\",\"qiilsr\",\"dbnaxs\",\"dbozaw\",\"webcyp\",\"vftnkr\",\"iurlzf\",\"giqcfc\",\"pcghoi\",\"zupyzn\",\"xckegy\"]\\n10\\n\\nThis test is faling when I submit, but it is passing when I do a run code."
                    },
                    {
                        "username": "tianyang19910112",
                        "content": "As descripted in title, If wordlist=[\"abcdea\",\"abcdeb\",...,\"abcdez\"], len(wordlist)=26"
                    },
                    {
                        "username": "edaengineer",
                        "content": "I thought the description was a bit unclear. I can\\'t see how if it is guaranteed to be solved within 10 guesses even if the word list is limited to 100 words.\\n\\nOr do we just have to make the best 10 guesss and the testcases/wordlists etc are set up so that it\\'s doable in 10 guesses? but that may not be true for any random secret word in wordlist, True??"
                    }
                ]
            },
            {
                "id": 1575078,
                "content": [
                    {
                        "username": "uttarandas501",
                        "content": "Why is the question setter so miserly with sample test-cases. Give some more."
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "How can I pass eleventh testcase in 10 attempts? \n[\"abcdef\",\"acdefg\",\"adefgh\",\"aefghi\",\"afghij\",\"aghijk\",\"ahijkl\",\"aijklm\",\"ajklmn\",\"aklmno\",\"almnoz\",\"anopqr\",\"azzzzz\"]\n\nP.S.\nOk, I solved it (I shared the solution) ;)"
                    },
                    {
                        "username": "GBT3101",
                        "content": "lets try this, and imagine that you don\\'t \"pop\" from array, you go from the start:\\nsecret word: \\'zzzzzz\\'\\nwordList: [\\'aaaaaa\\', \\'bbbbbb\\', \\'cccccc\\', \\'dddddd\\', \\'eeeeee\\', \\'ffffff\\', ...........(all the abc)....., \\'zzzzzz\\'] (list is 26 items, not even 100)\\n\\nAll the other words gives 0 similarity, you can\\'t filter any other word and you just keep guessing hoping to get lucky.\\n\\nCan anyone answer this? is there any way to solve this testcase in 10 guesses??? Feels like an impossible idiotic question..."
                    },
                    {
                        "username": "anh_tai",
                        "content": "For the following testcase  = {\"aaaaaa\", \"bbbbbb\", \"cccccc\", ........, \"zzzzzz\"} with 26 elements. If picking any words other than the secret word, the master will return 0. How could using exactly 10 guesses could resolve for this case."
                    },
                    {
                        "username": "thesavage4",
                        "content": "See https://youtu.be/r06U6qn9ZpA for a great video explanation."
                    },
                    {
                        "username": "zinechant",
                        "content": "Just 26 words;\\naaaaaa\\naaaaab\\naaaaac\\naaaaad\\naaaaae\\n.\\n.\\n.\\naaaaay\\naaaaaz\\n\\nBecause none of them is special among others, in the worst case you would need to guess 25 times. Seems 10 is not enough.\\n\\nCases with higher number of minimum guesses can be constructed with more digits for sure.\\n\\n\\n"
                    },
                    {
                        "username": "victorvianna",
                        "content": "In the official solution it\\'s stated that \"the number of guesses is bounded by log N\". I can see how this may be true with some average case analysis, assuming that the best guess distributes the remaining candidates evenly in 6 groups (0,...,5 matches). But I wonder if the bound also works for the worst case, and in that case, what\\'s the proof?"
                    },
                    {
                        "username": "havoc_hammer",
                        "content": "\"vftnkr\"\\n[\"mjpsce\",\"giwiyk\",\"slbnia\",\"pullbr\",\"ezvczd\",\"dwkrmt\",\"qgzebh\",\"wvhhlm\",\"kqbmny\",\"zpvrkz\",\"pdwxvy\",\"gilywa\",\"gmrrdc\",\"vvqvla\",\"rmjirt\",\"qmvykq\",\"mhbmuq\",\"unplzn\",\"qkcied\",\"eignxg\",\"fbfgng\",\"xpizga\",\"twubzr\",\"nnfaxr\",\"skknhe\",\"twautl\",\"nglrst\",\"mibyks\",\"qrbmpx\",\"ukgjkq\",\"mhxxfb\",\"deggal\",\"bwpvsp\",\"uirtak\",\"tqkzfk\",\"hfzawa\",\"jahjgn\",\"mteyut\",\"jzbqbv\",\"ttddtf\",\"auuwgn\",\"untihn\",\"gbhnog\",\"zowaol\",\"feitjl\",\"omtiur\",\"kwdsgx\",\"tggcqq\",\"qachdn\",\"dixtat\",\"hcsvbw\",\"chduyy\",\"gpdtft\",\"bjxzky\",\"uvvvko\",\"jzcpiv\",\"gtyjau\",\"unsmok\",\"vfcmhc\",\"hvxnut\",\"orlwku\",\"ejllrv\",\"jbrskt\",\"xnxxdi\",\"rfreiv\",\"njbvwj\",\"pkydxy\",\"jksiwj\",\"iaembk\",\"pyqdip\",\"exkykx\",\"uxgecc\",\"khzqgy\",\"dehkbu\",\"ahplng\",\"jomiik\",\"nmcsfe\",\"bclcbp\",\"xfiefi\",\"soiwde\",\"tcjkjp\",\"wervlz\",\"dcthgv\",\"hwwghe\",\"hdlkll\",\"dpzoxb\",\"mpiviy\",\"cprcwo\",\"molttv\",\"dwjtdp\",\"qiilsr\",\"dbnaxs\",\"dbozaw\",\"webcyp\",\"vftnkr\",\"iurlzf\",\"giqcfc\",\"pcghoi\",\"zupyzn\",\"xckegy\"]\\n10\\n\\nThis test is faling when I submit, but it is passing when I do a run code."
                    },
                    {
                        "username": "tianyang19910112",
                        "content": "As descripted in title, If wordlist=[\"abcdea\",\"abcdeb\",...,\"abcdez\"], len(wordlist)=26"
                    },
                    {
                        "username": "edaengineer",
                        "content": "I thought the description was a bit unclear. I can\\'t see how if it is guaranteed to be solved within 10 guesses even if the word list is limited to 100 words.\\n\\nOr do we just have to make the best 10 guesss and the testcases/wordlists etc are set up so that it\\'s doable in 10 guesses? but that may not be true for any random secret word in wordlist, True??"
                    }
                ]
            },
            {
                "id": 1574995,
                "content": [
                    {
                        "username": "uttarandas501",
                        "content": "Why is the question setter so miserly with sample test-cases. Give some more."
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "How can I pass eleventh testcase in 10 attempts? \n[\"abcdef\",\"acdefg\",\"adefgh\",\"aefghi\",\"afghij\",\"aghijk\",\"ahijkl\",\"aijklm\",\"ajklmn\",\"aklmno\",\"almnoz\",\"anopqr\",\"azzzzz\"]\n\nP.S.\nOk, I solved it (I shared the solution) ;)"
                    },
                    {
                        "username": "GBT3101",
                        "content": "lets try this, and imagine that you don\\'t \"pop\" from array, you go from the start:\\nsecret word: \\'zzzzzz\\'\\nwordList: [\\'aaaaaa\\', \\'bbbbbb\\', \\'cccccc\\', \\'dddddd\\', \\'eeeeee\\', \\'ffffff\\', ...........(all the abc)....., \\'zzzzzz\\'] (list is 26 items, not even 100)\\n\\nAll the other words gives 0 similarity, you can\\'t filter any other word and you just keep guessing hoping to get lucky.\\n\\nCan anyone answer this? is there any way to solve this testcase in 10 guesses??? Feels like an impossible idiotic question..."
                    },
                    {
                        "username": "anh_tai",
                        "content": "For the following testcase  = {\"aaaaaa\", \"bbbbbb\", \"cccccc\", ........, \"zzzzzz\"} with 26 elements. If picking any words other than the secret word, the master will return 0. How could using exactly 10 guesses could resolve for this case."
                    },
                    {
                        "username": "thesavage4",
                        "content": "See https://youtu.be/r06U6qn9ZpA for a great video explanation."
                    },
                    {
                        "username": "zinechant",
                        "content": "Just 26 words;\\naaaaaa\\naaaaab\\naaaaac\\naaaaad\\naaaaae\\n.\\n.\\n.\\naaaaay\\naaaaaz\\n\\nBecause none of them is special among others, in the worst case you would need to guess 25 times. Seems 10 is not enough.\\n\\nCases with higher number of minimum guesses can be constructed with more digits for sure.\\n\\n\\n"
                    },
                    {
                        "username": "victorvianna",
                        "content": "In the official solution it\\'s stated that \"the number of guesses is bounded by log N\". I can see how this may be true with some average case analysis, assuming that the best guess distributes the remaining candidates evenly in 6 groups (0,...,5 matches). But I wonder if the bound also works for the worst case, and in that case, what\\'s the proof?"
                    },
                    {
                        "username": "havoc_hammer",
                        "content": "\"vftnkr\"\\n[\"mjpsce\",\"giwiyk\",\"slbnia\",\"pullbr\",\"ezvczd\",\"dwkrmt\",\"qgzebh\",\"wvhhlm\",\"kqbmny\",\"zpvrkz\",\"pdwxvy\",\"gilywa\",\"gmrrdc\",\"vvqvla\",\"rmjirt\",\"qmvykq\",\"mhbmuq\",\"unplzn\",\"qkcied\",\"eignxg\",\"fbfgng\",\"xpizga\",\"twubzr\",\"nnfaxr\",\"skknhe\",\"twautl\",\"nglrst\",\"mibyks\",\"qrbmpx\",\"ukgjkq\",\"mhxxfb\",\"deggal\",\"bwpvsp\",\"uirtak\",\"tqkzfk\",\"hfzawa\",\"jahjgn\",\"mteyut\",\"jzbqbv\",\"ttddtf\",\"auuwgn\",\"untihn\",\"gbhnog\",\"zowaol\",\"feitjl\",\"omtiur\",\"kwdsgx\",\"tggcqq\",\"qachdn\",\"dixtat\",\"hcsvbw\",\"chduyy\",\"gpdtft\",\"bjxzky\",\"uvvvko\",\"jzcpiv\",\"gtyjau\",\"unsmok\",\"vfcmhc\",\"hvxnut\",\"orlwku\",\"ejllrv\",\"jbrskt\",\"xnxxdi\",\"rfreiv\",\"njbvwj\",\"pkydxy\",\"jksiwj\",\"iaembk\",\"pyqdip\",\"exkykx\",\"uxgecc\",\"khzqgy\",\"dehkbu\",\"ahplng\",\"jomiik\",\"nmcsfe\",\"bclcbp\",\"xfiefi\",\"soiwde\",\"tcjkjp\",\"wervlz\",\"dcthgv\",\"hwwghe\",\"hdlkll\",\"dpzoxb\",\"mpiviy\",\"cprcwo\",\"molttv\",\"dwjtdp\",\"qiilsr\",\"dbnaxs\",\"dbozaw\",\"webcyp\",\"vftnkr\",\"iurlzf\",\"giqcfc\",\"pcghoi\",\"zupyzn\",\"xckegy\"]\\n10\\n\\nThis test is faling when I submit, but it is passing when I do a run code."
                    },
                    {
                        "username": "tianyang19910112",
                        "content": "As descripted in title, If wordlist=[\"abcdea\",\"abcdeb\",...,\"abcdez\"], len(wordlist)=26"
                    },
                    {
                        "username": "edaengineer",
                        "content": "I thought the description was a bit unclear. I can\\'t see how if it is guaranteed to be solved within 10 guesses even if the word list is limited to 100 words.\\n\\nOr do we just have to make the best 10 guesss and the testcases/wordlists etc are set up so that it\\'s doable in 10 guesses? but that may not be true for any random secret word in wordlist, True??"
                    }
                ]
            },
            {
                "id": 1574802,
                "content": [
                    {
                        "username": "uttarandas501",
                        "content": "Why is the question setter so miserly with sample test-cases. Give some more."
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "How can I pass eleventh testcase in 10 attempts? \n[\"abcdef\",\"acdefg\",\"adefgh\",\"aefghi\",\"afghij\",\"aghijk\",\"ahijkl\",\"aijklm\",\"ajklmn\",\"aklmno\",\"almnoz\",\"anopqr\",\"azzzzz\"]\n\nP.S.\nOk, I solved it (I shared the solution) ;)"
                    },
                    {
                        "username": "GBT3101",
                        "content": "lets try this, and imagine that you don\\'t \"pop\" from array, you go from the start:\\nsecret word: \\'zzzzzz\\'\\nwordList: [\\'aaaaaa\\', \\'bbbbbb\\', \\'cccccc\\', \\'dddddd\\', \\'eeeeee\\', \\'ffffff\\', ...........(all the abc)....., \\'zzzzzz\\'] (list is 26 items, not even 100)\\n\\nAll the other words gives 0 similarity, you can\\'t filter any other word and you just keep guessing hoping to get lucky.\\n\\nCan anyone answer this? is there any way to solve this testcase in 10 guesses??? Feels like an impossible idiotic question..."
                    },
                    {
                        "username": "anh_tai",
                        "content": "For the following testcase  = {\"aaaaaa\", \"bbbbbb\", \"cccccc\", ........, \"zzzzzz\"} with 26 elements. If picking any words other than the secret word, the master will return 0. How could using exactly 10 guesses could resolve for this case."
                    },
                    {
                        "username": "thesavage4",
                        "content": "See https://youtu.be/r06U6qn9ZpA for a great video explanation."
                    },
                    {
                        "username": "zinechant",
                        "content": "Just 26 words;\\naaaaaa\\naaaaab\\naaaaac\\naaaaad\\naaaaae\\n.\\n.\\n.\\naaaaay\\naaaaaz\\n\\nBecause none of them is special among others, in the worst case you would need to guess 25 times. Seems 10 is not enough.\\n\\nCases with higher number of minimum guesses can be constructed with more digits for sure.\\n\\n\\n"
                    },
                    {
                        "username": "victorvianna",
                        "content": "In the official solution it\\'s stated that \"the number of guesses is bounded by log N\". I can see how this may be true with some average case analysis, assuming that the best guess distributes the remaining candidates evenly in 6 groups (0,...,5 matches). But I wonder if the bound also works for the worst case, and in that case, what\\'s the proof?"
                    },
                    {
                        "username": "havoc_hammer",
                        "content": "\"vftnkr\"\\n[\"mjpsce\",\"giwiyk\",\"slbnia\",\"pullbr\",\"ezvczd\",\"dwkrmt\",\"qgzebh\",\"wvhhlm\",\"kqbmny\",\"zpvrkz\",\"pdwxvy\",\"gilywa\",\"gmrrdc\",\"vvqvla\",\"rmjirt\",\"qmvykq\",\"mhbmuq\",\"unplzn\",\"qkcied\",\"eignxg\",\"fbfgng\",\"xpizga\",\"twubzr\",\"nnfaxr\",\"skknhe\",\"twautl\",\"nglrst\",\"mibyks\",\"qrbmpx\",\"ukgjkq\",\"mhxxfb\",\"deggal\",\"bwpvsp\",\"uirtak\",\"tqkzfk\",\"hfzawa\",\"jahjgn\",\"mteyut\",\"jzbqbv\",\"ttddtf\",\"auuwgn\",\"untihn\",\"gbhnog\",\"zowaol\",\"feitjl\",\"omtiur\",\"kwdsgx\",\"tggcqq\",\"qachdn\",\"dixtat\",\"hcsvbw\",\"chduyy\",\"gpdtft\",\"bjxzky\",\"uvvvko\",\"jzcpiv\",\"gtyjau\",\"unsmok\",\"vfcmhc\",\"hvxnut\",\"orlwku\",\"ejllrv\",\"jbrskt\",\"xnxxdi\",\"rfreiv\",\"njbvwj\",\"pkydxy\",\"jksiwj\",\"iaembk\",\"pyqdip\",\"exkykx\",\"uxgecc\",\"khzqgy\",\"dehkbu\",\"ahplng\",\"jomiik\",\"nmcsfe\",\"bclcbp\",\"xfiefi\",\"soiwde\",\"tcjkjp\",\"wervlz\",\"dcthgv\",\"hwwghe\",\"hdlkll\",\"dpzoxb\",\"mpiviy\",\"cprcwo\",\"molttv\",\"dwjtdp\",\"qiilsr\",\"dbnaxs\",\"dbozaw\",\"webcyp\",\"vftnkr\",\"iurlzf\",\"giqcfc\",\"pcghoi\",\"zupyzn\",\"xckegy\"]\\n10\\n\\nThis test is faling when I submit, but it is passing when I do a run code."
                    },
                    {
                        "username": "tianyang19910112",
                        "content": "As descripted in title, If wordlist=[\"abcdea\",\"abcdeb\",...,\"abcdez\"], len(wordlist)=26"
                    },
                    {
                        "username": "edaengineer",
                        "content": "I thought the description was a bit unclear. I can\\'t see how if it is guaranteed to be solved within 10 guesses even if the word list is limited to 100 words.\\n\\nOr do we just have to make the best 10 guesss and the testcases/wordlists etc are set up so that it\\'s doable in 10 guesses? but that may not be true for any random secret word in wordlist, True??"
                    }
                ]
            },
            {
                "id": 1574544,
                "content": [
                    {
                        "username": "uttarandas501",
                        "content": "Why is the question setter so miserly with sample test-cases. Give some more."
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "How can I pass eleventh testcase in 10 attempts? \n[\"abcdef\",\"acdefg\",\"adefgh\",\"aefghi\",\"afghij\",\"aghijk\",\"ahijkl\",\"aijklm\",\"ajklmn\",\"aklmno\",\"almnoz\",\"anopqr\",\"azzzzz\"]\n\nP.S.\nOk, I solved it (I shared the solution) ;)"
                    },
                    {
                        "username": "GBT3101",
                        "content": "lets try this, and imagine that you don\\'t \"pop\" from array, you go from the start:\\nsecret word: \\'zzzzzz\\'\\nwordList: [\\'aaaaaa\\', \\'bbbbbb\\', \\'cccccc\\', \\'dddddd\\', \\'eeeeee\\', \\'ffffff\\', ...........(all the abc)....., \\'zzzzzz\\'] (list is 26 items, not even 100)\\n\\nAll the other words gives 0 similarity, you can\\'t filter any other word and you just keep guessing hoping to get lucky.\\n\\nCan anyone answer this? is there any way to solve this testcase in 10 guesses??? Feels like an impossible idiotic question..."
                    },
                    {
                        "username": "anh_tai",
                        "content": "For the following testcase  = {\"aaaaaa\", \"bbbbbb\", \"cccccc\", ........, \"zzzzzz\"} with 26 elements. If picking any words other than the secret word, the master will return 0. How could using exactly 10 guesses could resolve for this case."
                    },
                    {
                        "username": "thesavage4",
                        "content": "See https://youtu.be/r06U6qn9ZpA for a great video explanation."
                    },
                    {
                        "username": "zinechant",
                        "content": "Just 26 words;\\naaaaaa\\naaaaab\\naaaaac\\naaaaad\\naaaaae\\n.\\n.\\n.\\naaaaay\\naaaaaz\\n\\nBecause none of them is special among others, in the worst case you would need to guess 25 times. Seems 10 is not enough.\\n\\nCases with higher number of minimum guesses can be constructed with more digits for sure.\\n\\n\\n"
                    },
                    {
                        "username": "victorvianna",
                        "content": "In the official solution it\\'s stated that \"the number of guesses is bounded by log N\". I can see how this may be true with some average case analysis, assuming that the best guess distributes the remaining candidates evenly in 6 groups (0,...,5 matches). But I wonder if the bound also works for the worst case, and in that case, what\\'s the proof?"
                    },
                    {
                        "username": "havoc_hammer",
                        "content": "\"vftnkr\"\\n[\"mjpsce\",\"giwiyk\",\"slbnia\",\"pullbr\",\"ezvczd\",\"dwkrmt\",\"qgzebh\",\"wvhhlm\",\"kqbmny\",\"zpvrkz\",\"pdwxvy\",\"gilywa\",\"gmrrdc\",\"vvqvla\",\"rmjirt\",\"qmvykq\",\"mhbmuq\",\"unplzn\",\"qkcied\",\"eignxg\",\"fbfgng\",\"xpizga\",\"twubzr\",\"nnfaxr\",\"skknhe\",\"twautl\",\"nglrst\",\"mibyks\",\"qrbmpx\",\"ukgjkq\",\"mhxxfb\",\"deggal\",\"bwpvsp\",\"uirtak\",\"tqkzfk\",\"hfzawa\",\"jahjgn\",\"mteyut\",\"jzbqbv\",\"ttddtf\",\"auuwgn\",\"untihn\",\"gbhnog\",\"zowaol\",\"feitjl\",\"omtiur\",\"kwdsgx\",\"tggcqq\",\"qachdn\",\"dixtat\",\"hcsvbw\",\"chduyy\",\"gpdtft\",\"bjxzky\",\"uvvvko\",\"jzcpiv\",\"gtyjau\",\"unsmok\",\"vfcmhc\",\"hvxnut\",\"orlwku\",\"ejllrv\",\"jbrskt\",\"xnxxdi\",\"rfreiv\",\"njbvwj\",\"pkydxy\",\"jksiwj\",\"iaembk\",\"pyqdip\",\"exkykx\",\"uxgecc\",\"khzqgy\",\"dehkbu\",\"ahplng\",\"jomiik\",\"nmcsfe\",\"bclcbp\",\"xfiefi\",\"soiwde\",\"tcjkjp\",\"wervlz\",\"dcthgv\",\"hwwghe\",\"hdlkll\",\"dpzoxb\",\"mpiviy\",\"cprcwo\",\"molttv\",\"dwjtdp\",\"qiilsr\",\"dbnaxs\",\"dbozaw\",\"webcyp\",\"vftnkr\",\"iurlzf\",\"giqcfc\",\"pcghoi\",\"zupyzn\",\"xckegy\"]\\n10\\n\\nThis test is faling when I submit, but it is passing when I do a run code."
                    },
                    {
                        "username": "tianyang19910112",
                        "content": "As descripted in title, If wordlist=[\"abcdea\",\"abcdeb\",...,\"abcdez\"], len(wordlist)=26"
                    },
                    {
                        "username": "edaengineer",
                        "content": "I thought the description was a bit unclear. I can\\'t see how if it is guaranteed to be solved within 10 guesses even if the word list is limited to 100 words.\\n\\nOr do we just have to make the best 10 guesss and the testcases/wordlists etc are set up so that it\\'s doable in 10 guesses? but that may not be true for any random secret word in wordlist, True??"
                    }
                ]
            },
            {
                "id": 1574194,
                "content": [
                    {
                        "username": "uttarandas501",
                        "content": "Why is the question setter so miserly with sample test-cases. Give some more."
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "How can I pass eleventh testcase in 10 attempts? \n[\"abcdef\",\"acdefg\",\"adefgh\",\"aefghi\",\"afghij\",\"aghijk\",\"ahijkl\",\"aijklm\",\"ajklmn\",\"aklmno\",\"almnoz\",\"anopqr\",\"azzzzz\"]\n\nP.S.\nOk, I solved it (I shared the solution) ;)"
                    },
                    {
                        "username": "GBT3101",
                        "content": "lets try this, and imagine that you don\\'t \"pop\" from array, you go from the start:\\nsecret word: \\'zzzzzz\\'\\nwordList: [\\'aaaaaa\\', \\'bbbbbb\\', \\'cccccc\\', \\'dddddd\\', \\'eeeeee\\', \\'ffffff\\', ...........(all the abc)....., \\'zzzzzz\\'] (list is 26 items, not even 100)\\n\\nAll the other words gives 0 similarity, you can\\'t filter any other word and you just keep guessing hoping to get lucky.\\n\\nCan anyone answer this? is there any way to solve this testcase in 10 guesses??? Feels like an impossible idiotic question..."
                    },
                    {
                        "username": "anh_tai",
                        "content": "For the following testcase  = {\"aaaaaa\", \"bbbbbb\", \"cccccc\", ........, \"zzzzzz\"} with 26 elements. If picking any words other than the secret word, the master will return 0. How could using exactly 10 guesses could resolve for this case."
                    },
                    {
                        "username": "thesavage4",
                        "content": "See https://youtu.be/r06U6qn9ZpA for a great video explanation."
                    },
                    {
                        "username": "zinechant",
                        "content": "Just 26 words;\\naaaaaa\\naaaaab\\naaaaac\\naaaaad\\naaaaae\\n.\\n.\\n.\\naaaaay\\naaaaaz\\n\\nBecause none of them is special among others, in the worst case you would need to guess 25 times. Seems 10 is not enough.\\n\\nCases with higher number of minimum guesses can be constructed with more digits for sure.\\n\\n\\n"
                    },
                    {
                        "username": "victorvianna",
                        "content": "In the official solution it\\'s stated that \"the number of guesses is bounded by log N\". I can see how this may be true with some average case analysis, assuming that the best guess distributes the remaining candidates evenly in 6 groups (0,...,5 matches). But I wonder if the bound also works for the worst case, and in that case, what\\'s the proof?"
                    },
                    {
                        "username": "havoc_hammer",
                        "content": "\"vftnkr\"\\n[\"mjpsce\",\"giwiyk\",\"slbnia\",\"pullbr\",\"ezvczd\",\"dwkrmt\",\"qgzebh\",\"wvhhlm\",\"kqbmny\",\"zpvrkz\",\"pdwxvy\",\"gilywa\",\"gmrrdc\",\"vvqvla\",\"rmjirt\",\"qmvykq\",\"mhbmuq\",\"unplzn\",\"qkcied\",\"eignxg\",\"fbfgng\",\"xpizga\",\"twubzr\",\"nnfaxr\",\"skknhe\",\"twautl\",\"nglrst\",\"mibyks\",\"qrbmpx\",\"ukgjkq\",\"mhxxfb\",\"deggal\",\"bwpvsp\",\"uirtak\",\"tqkzfk\",\"hfzawa\",\"jahjgn\",\"mteyut\",\"jzbqbv\",\"ttddtf\",\"auuwgn\",\"untihn\",\"gbhnog\",\"zowaol\",\"feitjl\",\"omtiur\",\"kwdsgx\",\"tggcqq\",\"qachdn\",\"dixtat\",\"hcsvbw\",\"chduyy\",\"gpdtft\",\"bjxzky\",\"uvvvko\",\"jzcpiv\",\"gtyjau\",\"unsmok\",\"vfcmhc\",\"hvxnut\",\"orlwku\",\"ejllrv\",\"jbrskt\",\"xnxxdi\",\"rfreiv\",\"njbvwj\",\"pkydxy\",\"jksiwj\",\"iaembk\",\"pyqdip\",\"exkykx\",\"uxgecc\",\"khzqgy\",\"dehkbu\",\"ahplng\",\"jomiik\",\"nmcsfe\",\"bclcbp\",\"xfiefi\",\"soiwde\",\"tcjkjp\",\"wervlz\",\"dcthgv\",\"hwwghe\",\"hdlkll\",\"dpzoxb\",\"mpiviy\",\"cprcwo\",\"molttv\",\"dwjtdp\",\"qiilsr\",\"dbnaxs\",\"dbozaw\",\"webcyp\",\"vftnkr\",\"iurlzf\",\"giqcfc\",\"pcghoi\",\"zupyzn\",\"xckegy\"]\\n10\\n\\nThis test is faling when I submit, but it is passing when I do a run code."
                    },
                    {
                        "username": "tianyang19910112",
                        "content": "As descripted in title, If wordlist=[\"abcdea\",\"abcdeb\",...,\"abcdez\"], len(wordlist)=26"
                    },
                    {
                        "username": "edaengineer",
                        "content": "I thought the description was a bit unclear. I can\\'t see how if it is guaranteed to be solved within 10 guesses even if the word list is limited to 100 words.\\n\\nOr do we just have to make the best 10 guesss and the testcases/wordlists etc are set up so that it\\'s doable in 10 guesses? but that may not be true for any random secret word in wordlist, True??"
                    }
                ]
            },
            {
                "id": 1573954,
                "content": [
                    {
                        "username": "uttarandas501",
                        "content": "Why is the question setter so miserly with sample test-cases. Give some more."
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "How can I pass eleventh testcase in 10 attempts? \n[\"abcdef\",\"acdefg\",\"adefgh\",\"aefghi\",\"afghij\",\"aghijk\",\"ahijkl\",\"aijklm\",\"ajklmn\",\"aklmno\",\"almnoz\",\"anopqr\",\"azzzzz\"]\n\nP.S.\nOk, I solved it (I shared the solution) ;)"
                    },
                    {
                        "username": "GBT3101",
                        "content": "lets try this, and imagine that you don\\'t \"pop\" from array, you go from the start:\\nsecret word: \\'zzzzzz\\'\\nwordList: [\\'aaaaaa\\', \\'bbbbbb\\', \\'cccccc\\', \\'dddddd\\', \\'eeeeee\\', \\'ffffff\\', ...........(all the abc)....., \\'zzzzzz\\'] (list is 26 items, not even 100)\\n\\nAll the other words gives 0 similarity, you can\\'t filter any other word and you just keep guessing hoping to get lucky.\\n\\nCan anyone answer this? is there any way to solve this testcase in 10 guesses??? Feels like an impossible idiotic question..."
                    },
                    {
                        "username": "anh_tai",
                        "content": "For the following testcase  = {\"aaaaaa\", \"bbbbbb\", \"cccccc\", ........, \"zzzzzz\"} with 26 elements. If picking any words other than the secret word, the master will return 0. How could using exactly 10 guesses could resolve for this case."
                    },
                    {
                        "username": "thesavage4",
                        "content": "See https://youtu.be/r06U6qn9ZpA for a great video explanation."
                    },
                    {
                        "username": "zinechant",
                        "content": "Just 26 words;\\naaaaaa\\naaaaab\\naaaaac\\naaaaad\\naaaaae\\n.\\n.\\n.\\naaaaay\\naaaaaz\\n\\nBecause none of them is special among others, in the worst case you would need to guess 25 times. Seems 10 is not enough.\\n\\nCases with higher number of minimum guesses can be constructed with more digits for sure.\\n\\n\\n"
                    },
                    {
                        "username": "victorvianna",
                        "content": "In the official solution it\\'s stated that \"the number of guesses is bounded by log N\". I can see how this may be true with some average case analysis, assuming that the best guess distributes the remaining candidates evenly in 6 groups (0,...,5 matches). But I wonder if the bound also works for the worst case, and in that case, what\\'s the proof?"
                    },
                    {
                        "username": "havoc_hammer",
                        "content": "\"vftnkr\"\\n[\"mjpsce\",\"giwiyk\",\"slbnia\",\"pullbr\",\"ezvczd\",\"dwkrmt\",\"qgzebh\",\"wvhhlm\",\"kqbmny\",\"zpvrkz\",\"pdwxvy\",\"gilywa\",\"gmrrdc\",\"vvqvla\",\"rmjirt\",\"qmvykq\",\"mhbmuq\",\"unplzn\",\"qkcied\",\"eignxg\",\"fbfgng\",\"xpizga\",\"twubzr\",\"nnfaxr\",\"skknhe\",\"twautl\",\"nglrst\",\"mibyks\",\"qrbmpx\",\"ukgjkq\",\"mhxxfb\",\"deggal\",\"bwpvsp\",\"uirtak\",\"tqkzfk\",\"hfzawa\",\"jahjgn\",\"mteyut\",\"jzbqbv\",\"ttddtf\",\"auuwgn\",\"untihn\",\"gbhnog\",\"zowaol\",\"feitjl\",\"omtiur\",\"kwdsgx\",\"tggcqq\",\"qachdn\",\"dixtat\",\"hcsvbw\",\"chduyy\",\"gpdtft\",\"bjxzky\",\"uvvvko\",\"jzcpiv\",\"gtyjau\",\"unsmok\",\"vfcmhc\",\"hvxnut\",\"orlwku\",\"ejllrv\",\"jbrskt\",\"xnxxdi\",\"rfreiv\",\"njbvwj\",\"pkydxy\",\"jksiwj\",\"iaembk\",\"pyqdip\",\"exkykx\",\"uxgecc\",\"khzqgy\",\"dehkbu\",\"ahplng\",\"jomiik\",\"nmcsfe\",\"bclcbp\",\"xfiefi\",\"soiwde\",\"tcjkjp\",\"wervlz\",\"dcthgv\",\"hwwghe\",\"hdlkll\",\"dpzoxb\",\"mpiviy\",\"cprcwo\",\"molttv\",\"dwjtdp\",\"qiilsr\",\"dbnaxs\",\"dbozaw\",\"webcyp\",\"vftnkr\",\"iurlzf\",\"giqcfc\",\"pcghoi\",\"zupyzn\",\"xckegy\"]\\n10\\n\\nThis test is faling when I submit, but it is passing when I do a run code."
                    },
                    {
                        "username": "tianyang19910112",
                        "content": "As descripted in title, If wordlist=[\"abcdea\",\"abcdeb\",...,\"abcdez\"], len(wordlist)=26"
                    },
                    {
                        "username": "edaengineer",
                        "content": "I thought the description was a bit unclear. I can\\'t see how if it is guaranteed to be solved within 10 guesses even if the word list is limited to 100 words.\\n\\nOr do we just have to make the best 10 guesss and the testcases/wordlists etc are set up so that it\\'s doable in 10 guesses? but that may not be true for any random secret word in wordlist, True??"
                    }
                ]
            },
            {
                "id": 1571971,
                "content": [
                    {
                        "username": "uttarandas501",
                        "content": "Why is the question setter so miserly with sample test-cases. Give some more."
                    },
                    {
                        "username": "gregsklyanny",
                        "content": "How can I pass eleventh testcase in 10 attempts? \n[\"abcdef\",\"acdefg\",\"adefgh\",\"aefghi\",\"afghij\",\"aghijk\",\"ahijkl\",\"aijklm\",\"ajklmn\",\"aklmno\",\"almnoz\",\"anopqr\",\"azzzzz\"]\n\nP.S.\nOk, I solved it (I shared the solution) ;)"
                    },
                    {
                        "username": "GBT3101",
                        "content": "lets try this, and imagine that you don\\'t \"pop\" from array, you go from the start:\\nsecret word: \\'zzzzzz\\'\\nwordList: [\\'aaaaaa\\', \\'bbbbbb\\', \\'cccccc\\', \\'dddddd\\', \\'eeeeee\\', \\'ffffff\\', ...........(all the abc)....., \\'zzzzzz\\'] (list is 26 items, not even 100)\\n\\nAll the other words gives 0 similarity, you can\\'t filter any other word and you just keep guessing hoping to get lucky.\\n\\nCan anyone answer this? is there any way to solve this testcase in 10 guesses??? Feels like an impossible idiotic question..."
                    },
                    {
                        "username": "anh_tai",
                        "content": "For the following testcase  = {\"aaaaaa\", \"bbbbbb\", \"cccccc\", ........, \"zzzzzz\"} with 26 elements. If picking any words other than the secret word, the master will return 0. How could using exactly 10 guesses could resolve for this case."
                    },
                    {
                        "username": "thesavage4",
                        "content": "See https://youtu.be/r06U6qn9ZpA for a great video explanation."
                    },
                    {
                        "username": "zinechant",
                        "content": "Just 26 words;\\naaaaaa\\naaaaab\\naaaaac\\naaaaad\\naaaaae\\n.\\n.\\n.\\naaaaay\\naaaaaz\\n\\nBecause none of them is special among others, in the worst case you would need to guess 25 times. Seems 10 is not enough.\\n\\nCases with higher number of minimum guesses can be constructed with more digits for sure.\\n\\n\\n"
                    },
                    {
                        "username": "victorvianna",
                        "content": "In the official solution it\\'s stated that \"the number of guesses is bounded by log N\". I can see how this may be true with some average case analysis, assuming that the best guess distributes the remaining candidates evenly in 6 groups (0,...,5 matches). But I wonder if the bound also works for the worst case, and in that case, what\\'s the proof?"
                    },
                    {
                        "username": "havoc_hammer",
                        "content": "\"vftnkr\"\\n[\"mjpsce\",\"giwiyk\",\"slbnia\",\"pullbr\",\"ezvczd\",\"dwkrmt\",\"qgzebh\",\"wvhhlm\",\"kqbmny\",\"zpvrkz\",\"pdwxvy\",\"gilywa\",\"gmrrdc\",\"vvqvla\",\"rmjirt\",\"qmvykq\",\"mhbmuq\",\"unplzn\",\"qkcied\",\"eignxg\",\"fbfgng\",\"xpizga\",\"twubzr\",\"nnfaxr\",\"skknhe\",\"twautl\",\"nglrst\",\"mibyks\",\"qrbmpx\",\"ukgjkq\",\"mhxxfb\",\"deggal\",\"bwpvsp\",\"uirtak\",\"tqkzfk\",\"hfzawa\",\"jahjgn\",\"mteyut\",\"jzbqbv\",\"ttddtf\",\"auuwgn\",\"untihn\",\"gbhnog\",\"zowaol\",\"feitjl\",\"omtiur\",\"kwdsgx\",\"tggcqq\",\"qachdn\",\"dixtat\",\"hcsvbw\",\"chduyy\",\"gpdtft\",\"bjxzky\",\"uvvvko\",\"jzcpiv\",\"gtyjau\",\"unsmok\",\"vfcmhc\",\"hvxnut\",\"orlwku\",\"ejllrv\",\"jbrskt\",\"xnxxdi\",\"rfreiv\",\"njbvwj\",\"pkydxy\",\"jksiwj\",\"iaembk\",\"pyqdip\",\"exkykx\",\"uxgecc\",\"khzqgy\",\"dehkbu\",\"ahplng\",\"jomiik\",\"nmcsfe\",\"bclcbp\",\"xfiefi\",\"soiwde\",\"tcjkjp\",\"wervlz\",\"dcthgv\",\"hwwghe\",\"hdlkll\",\"dpzoxb\",\"mpiviy\",\"cprcwo\",\"molttv\",\"dwjtdp\",\"qiilsr\",\"dbnaxs\",\"dbozaw\",\"webcyp\",\"vftnkr\",\"iurlzf\",\"giqcfc\",\"pcghoi\",\"zupyzn\",\"xckegy\"]\\n10\\n\\nThis test is faling when I submit, but it is passing when I do a run code."
                    },
                    {
                        "username": "tianyang19910112",
                        "content": "As descripted in title, If wordlist=[\"abcdea\",\"abcdeb\",...,\"abcdez\"], len(wordlist)=26"
                    },
                    {
                        "username": "edaengineer",
                        "content": "I thought the description was a bit unclear. I can\\'t see how if it is guaranteed to be solved within 10 guesses even if the word list is limited to 100 words.\\n\\nOr do we just have to make the best 10 guesss and the testcases/wordlists etc are set up so that it\\'s doable in 10 guesses? but that may not be true for any random secret word in wordlist, True??"
                    }
                ]
            }
        ]
    },
    {
        "title": "Check If It Is a Straight Line",
        "question_content": "<p>You are given an array&nbsp;<code>coordinates</code>, <code>coordinates[i] = [x, y]</code>, where <code>[x, y]</code> represents the coordinate of a point. Check if these points&nbsp;make a straight line in the XY plane.</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/10/15/untitled-diagram-2.jpg\" style=\"width: 336px; height: 336px;\" /></p>\n\n<pre>\n<strong>Input:</strong> coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/10/09/untitled-diagram-1.jpg\" style=\"width: 348px; height: 336px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;=&nbsp;coordinates.length &lt;= 1000</code></li>\n\t<li><code>coordinates[i].length == 2</code></li>\n\t<li><code>-10^4 &lt;=&nbsp;coordinates[i][0],&nbsp;coordinates[i][1] &lt;= 10^4</code></li>\n\t<li><code>coordinates</code>&nbsp;contains no duplicate point.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 408984,
                "title": "java-python-3-check-slopes-short-code-w-explanation-and-analysis",
                "content": "The slope for a line through any 2 points `(x0, y0)` and `(x1, y1)` is `(y1 - y0) / (x1 - x0)`; Therefore, for any given 3 points (denote the 3rd point as `(x, y)`), if they are in a straight line, the slopes of the lines from the 3rd point to the 2nd point and the 2nd point to the 1st point must be equal:\\n```\\n(y - y1) / (x - x1) = (y1 - y0) / (x1 - x0)\\n```\\nIn order to avoid being divided by 0, use multiplication form:\\n```\\n(x1 - x0) * (y - y1) = (x - x1) * (y1 - y0) =>\\ndx * (y - y1) = dy * (x - x1), where dx = x1 - x0 and dy = y1 - y0\\n```\\n\\nNow imagine connecting the 2nd points respectively with others one by one, Check if all of the slopes are equal.\\n\\n```\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        int x0 = coordinates[0][0], y0 = coordinates[0][1], \\n            x1 = coordinates[1][0], y1 = coordinates[1][1];\\n        int dx = x1 - x0, dy = y1 - y0;\\n        for (int[] co : coordinates) {\\n            int x = co[0], y = co[1];\\n            if (dx * (y - y1) != dy * (x - x1))\\n                return false;\\n        }\\n        return true;\\n    }\\n```\\n```\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        (x0, y0), (x1, y1) = coordinates[: 2]\\n        for x, y in coordinates:\\n            if (x1 - x0) * (y - y1) != (x - x1) * (y1 - y0):\\n                return False\\n        return True\\n```\\nor simpler:\\n```\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        (x0, y0), (x1, y1) = coordinates[: 2]\\n        return all((x1 - x0) * (y - y1) == (x - x1) * (y1 - y0) for x, y in coordinates)\\n```\\n\\n**Analysis**\\n\\nTime: O(n), space: O(1), where n = coordinates.length.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\n(y - y1) / (x - x1) = (y1 - y0) / (x1 - x0)\\n```\n```\\n(x1 - x0) * (y - y1) = (x - x1) * (y1 - y0) =>\\ndx * (y - y1) = dy * (x - x1), where dx = x1 - x0 and dy = y1 - y0\\n```\n```\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        int x0 = coordinates[0][0], y0 = coordinates[0][1], \\n            x1 = coordinates[1][0], y1 = coordinates[1][1];\\n        int dx = x1 - x0, dy = y1 - y0;\\n        for (int[] co : coordinates) {\\n            int x = co[0], y = co[1];\\n            if (dx * (y - y1) != dy * (x - x1))\\n                return false;\\n        }\\n        return true;\\n    }\\n```\n```\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        (x0, y0), (x1, y1) = coordinates[: 2]\\n        for x, y in coordinates:\\n            if (x1 - x0) * (y - y1) != (x - x1) * (y1 - y0):\\n                return False\\n        return True\\n```\n```\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        (x0, y0), (x1, y1) = coordinates[: 2]\\n        return all((x1 - x0) * (y - y1) == (x - x1) * (y1 - y0) for x, y in coordinates)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 620096,
                "title": "java-python3-cpp-simple-code-with-explanation-100-fast-o-1-space",
                "content": "\\n**The point is  if we take points p1(x, y), p2(x1, y1), p3(x3, y3),  slopes of any two pairs is same then p1, p2, p3 lies on same line.\\n     slope from p1 and p2 is  y - y1 / x - x1\\n     slope from p2 and p3 is  y2 - y1 / x2 - x1\\nif these two slopes equal, then p1, p2, p3 lies on same line.**\\n\\n**IF YOU HAVE ANY DOUBTS, FEEL FREE TO ASK**\\n**IF YOU UNDERSTAND, DON\\'T FORGET TO UPVOTE**\\n\\n![image](https://assets.leetcode.com/users/logan138/image_1588922156.png)\\n\\n```\\nJAVA:-  \\n\\nclass Solution {\\n    public boolean onLine(int[] p1, int[] p2, int[] p3){\\n        int x = p1[0], y = p1[1], x1 = p2[0], y1 = p2[1], x2 = p3[0], y2 = p3[1];\\n        return ((y - y1) * (x2 - x1) == (y2 - y1) * (x - x1));\\n    }\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        // base case:- there are only two points, return true\\n        // otherwise, check each point lies on line using above equation.\\n\\t\\t\\n        for(int i=2;i<coordinates.length;i++){\\n            if(!onLine(coordinates[i], coordinates[0], coordinates[1]))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n\\nPython3:-\\n\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        (x1, y1), (x2, y2) = coordinates[:2]\\n        for i in range(2, len(coordinates)):\\n            (x, y) = coordinates[i]\\n            if((y2 - y1) * (x1 - x) != (y1 - y) * (x2 - x1)):\\n                return False\\n        return True\\t\\t\\n\\nCPP:-\\n\\u200Bclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        if(coordinates.size() <= 2) return true;\\n        int x1 = coordinates[0][0];\\n        int y1 = coordinates[0][1];\\n        int x2 = coordinates[1][0];\\n        int y2 = coordinates[1][1];\\n        for(int i=2;i<coordinates.size();i++){\\n            int x = coordinates[i][0];\\n            int y = coordinates[i][1];\\n            if((y2 - y1) * (x1 - x) != (y1 - y) * (x2 - x1))\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\nJAVA:-  \\n\\nclass Solution {\\n    public boolean onLine(int[] p1, int[] p2, int[] p3){\\n        int x = p1[0], y = p1[1], x1 = p2[0], y1 = p2[1], x2 = p3[0], y2 = p3[1];\\n        return ((y - y1) * (x2 - x1) == (y2 - y1) * (x - x1));\\n    }\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        // base case:- there are only two points, return true\\n        // otherwise, check each point lies on line using above equation.\\n\\t\\t\\n        for(int i=2;i<coordinates.length;i++){\\n            if(!onLine(coordinates[i], coordinates[0], coordinates[1]))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n\\nPython3:-\\n\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        (x1, y1), (x2, y2) = coordinates[:2]\\n        for i in range(2, len(coordinates)):\\n            (x, y) = coordinates[i]\\n            if((y2 - y1) * (x1 - x) != (y1 - y) * (x2 - x1)):\\n                return False\\n        return True\\t\\t\\n\\nCPP:-\\n\\u200Bclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        if(coordinates.size() <= 2) return true;\\n        int x1 = coordinates[0][0];\\n        int y1 = coordinates[0][1];\\n        int x2 = coordinates[1][0];\\n        int y2 = coordinates[1][1];\\n        for(int i=2;i<coordinates.size();i++){\\n            int x = coordinates[i][0];\\n            int y = coordinates[i][1];\\n            if((y2 - y1) * (x1 - x) != (y1 - y) * (x2 - x1))\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2404442,
                "title": "python-soln-by-checking-slopes-w-explanation",
                "content": "1. Find slope for first two points, point1 and point2\\n2. Then compare the slopes of all other points to this slope\\n3. Slope of point1 (x1, y1) and point2 (x2, y2) is:\\n\\t`(y2 - y1) / (x2 - x1)`\\n4. Slope of point1 (x1, y1) and point3 (x3, y3) is:\\n   `(y3 - y1) / (x3 - x1)`\\n5. For all three points to be on the same line, the slopes should be equal, in other words:\\n   `(y2 - y1) / (x2 - x1) = (y3 - y1) / (x3 - x1)`\\n6. To avoid the \\'divide by zero\\' error, use cross multiplication to find slope:\\n   `(y2 - y1) * (x3 - x1) = (y3 - y1) * (x2 - x1)`\\n```\\ndef checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n\\t(x1, y1), (x2, y2) = coordinates[0], coordinates[1]\\n\\n\\tfor x3, y3 in coordinates[2:]:\\n\\t\\tif (y2 - y1) * (x3 - x1) != (y3 - y1) * (x2 - x1):\\n\\t\\t\\treturn False\\n\\n\\treturn True\\n```\\n\\n![image](https://assets.leetcode.com/users/images/48de4529-05d8-4315-9e3d-922109935786_1660754821.248414.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n\\t(x1, y1), (x2, y2) = coordinates[0], coordinates[1]\\n\\n\\tfor x3, y3 in coordinates[2:]:\\n\\t\\tif (y2 - y1) * (x3 - x1) != (y3 - y1) * (x2 - x1):\\n\\t\\t\\treturn False\\n\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 408968,
                "title": "check-collinearity",
                "content": "Three points lie on the straight line if the area formed by the triangle of these three points is zero.\\nFormula for area of triangle is :\\n**0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))**\\n\\n\\n```\\n public boolean checkStraightLine(int[][] coordinates) {\\n        int n = coordinates.length;\\n        for(int end=0;end<=n-3;end++) {\\n            int[] c1 = coordinates[end];\\n            int[] c2 = coordinates[end+1];\\n            int[] c3 = coordinates[end+2];\\n            if(!isCollinear(c1[0],c1[1],c2[0],c2[1],c3[0],c3[1])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private boolean isCollinear(int x1, int y1, int x2,int y2, int x3, int y3) {\\n        int result = x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2);\\n        return result==0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public boolean checkStraightLine(int[][] coordinates) {\\n        int n = coordinates.length;\\n        for(int end=0;end<=n-3;end++) {\\n            int[] c1 = coordinates[end];\\n            int[] c2 = coordinates[end+1];\\n            int[] c3 = coordinates[end+2];\\n            if(!isCollinear(c1[0],c1[1],c2[0],c2[1],c3[0],c3[1])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private boolean isCollinear(int x1, int y1, int x2,int y2, int x3, int y3) {\\n        int result = x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2);\\n        return result==0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 620035,
                "title": "c-simple-6-lines-of-code-o-n",
                "content": "```\\nbool checkStraightLine( vector<vector<int>>& coordinates ) {        \\n\\tint dY = coordinates[1][1] - coordinates[0][1];\\n\\tint dX = coordinates[1][0] - coordinates[0][0];     \\n\\tfor( int i=2; i < coordinates.size(); i++ ) {\\n\\t\\tauto p = coordinates[i];\\n\\t\\tif( dX*(p[1] - coordinates[0][1]) != dY*(p[0] - coordinates[0][0]) )\\n\\t\\t\\treturn false;\\n\\t}\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool checkStraightLine( vector<vector<int>>& coordinates ) {        \\n\\tint dY = coordinates[1][1] - coordinates[0][1];\\n\\tint dX = coordinates[1][0] - coordinates[0][0];     \\n\\tfor( int i=2; i < coordinates.size(); i++ ) {\\n\\t\\tauto p = coordinates[i];\\n\\t\\tif( dX*(p[1] - coordinates[0][1]) != dY*(p[0] - coordinates[0][0]) )\\n\\t\\t\\treturn false;\\n\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3598587,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "# !! BIG ANNOUNCEMENT !!\\r\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers. This is only for the first 10,000 Subscribers. **DON\\'T FORGET** to Subscribe\\r\\n\\r\\n# Search \\uD83D\\uDC49 `Tech Wired Leetcode` to Subscribe\\r\\n\\r\\n\\r\\n# or\\r\\n\\r\\n# Click the Link in my Profile\\r\\n\\r\\n# Intuition:\\r\\nTo determine if a set of points lies on a straight line, we can check if the slopes between any two consecutive points are equal. If all the slopes are equal, then the points lie on a straight line; otherwise, they do not.\\r\\n\\r\\n# Approach:\\r\\n\\r\\n- Extract the coordinates of the first two points (x0, y0) and (x1, y1) from the input.\\r\\n- Iterate through the remaining points from the third point onwards.\\r\\n- For each point (x, y) in the iteration:\\r\\n- Calculate the slope between (x0, y0) and (x1, y1) as (x1 - x0) / (y1 - y0).\\r\\n- Calculate the slope between (x0, y0) and the current point (x, y) as (x - x0) / (y - y0).\\r\\n- If the two slopes are not equal, return False, indicating that the points do not form a straight line.\\r\\n- If all the slopes are equal, return True, indicating that the points form a straight line.\\r\\n- By checking the equality of the slopes, we can determine whether all the points lie on a straight line or not.\\r\\n\\r\\n\\r\\n```Python []\\r\\nclass Solution:\\r\\n    def checkStraightLine(self, coordinates):\\r\\n        x0, y0 = coordinates[0]\\r\\n        x1, y1 = coordinates[1]\\r\\n\\r\\n        for i in range(2, len(coordinates)):\\r\\n            x, y = coordinates[i]\\r\\n            if (x - x0) * (y1 - y0) != (y - y0) * (x1 - x0):\\r\\n                return False\\r\\n\\r\\n        return True\\r\\n\\r\\n```\\r\\n```Java []\\r\\nclass Solution {\\r\\n    public boolean checkStraightLine(int[][] coordinates) {\\r\\n        int x0 = coordinates[0][0];\\r\\n        int y0 = coordinates[0][1];\\r\\n        int x1 = coordinates[1][0];\\r\\n        int y1 = coordinates[1][1];\\r\\n        \\r\\n        for (int i = 2; i < coordinates.length; i++) {\\r\\n            int x = coordinates[i][0];\\r\\n            int y = coordinates[i][1];\\r\\n            if ((x - x0) * (y1 - y0) != (y - y0) * (x1 - x0)) {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n\\r\\n```\\r\\n```C++ []\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        int x0 = coordinates[0][0];\\r\\n        int y0 = coordinates[0][1];\\r\\n        int x1 = coordinates[1][0];\\r\\n        int y1 = coordinates[1][1];\\r\\n        \\r\\n        for (int i = 2; i < coordinates.size(); i++) {\\r\\n            int x = coordinates[i][0];\\r\\n            int y = coordinates[i][1];\\r\\n            if ((x - x0) * (y1 - y0) != (y - y0) * (x1 - x0)) {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n\\r\\n```\\r\\n# An Upvote will be encouraging \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Math"
                ],
                "code": "```Python []\\r\\nclass Solution:\\r\\n    def checkStraightLine(self, coordinates):\\r\\n        x0, y0 = coordinates[0]\\r\\n        x1, y1 = coordinates[1]\\r\\n\\r\\n        for i in range(2, len(coordinates)):\\r\\n            x, y = coordinates[i]\\r\\n            if (x - x0) * (y1 - y0) != (y - y0) * (x1 - x0):\\r\\n                return False\\r\\n\\r\\n        return True\\r\\n\\r\\n```\n```Java []\\r\\nclass Solution {\\r\\n    public boolean checkStraightLine(int[][] coordinates) {\\r\\n        int x0 = coordinates[0][0];\\r\\n        int y0 = coordinates[0][1];\\r\\n        int x1 = coordinates[1][0];\\r\\n        int y1 = coordinates[1][1];\\r\\n        \\r\\n        for (int i = 2; i < coordinates.length; i++) {\\r\\n            int x = coordinates[i][0];\\r\\n            int y = coordinates[i][1];\\r\\n            if ((x - x0) * (y1 - y0) != (y - y0) * (x1 - x0)) {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n\\r\\n```\n```C++ []\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        int x0 = coordinates[0][0];\\r\\n        int y0 = coordinates[0][1];\\r\\n        int x1 = coordinates[1][0];\\r\\n        int y1 = coordinates[1][1];\\r\\n        \\r\\n        for (int i = 2; i < coordinates.size(); i++) {\\r\\n            int x = coordinates[i][0];\\r\\n            int y = coordinates[i][1];\\r\\n            if ((x - x0) * (y1 - y0) != (y - y0) * (x1 - x0)) {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 777894,
                "title": "c-easy-o-n-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int cz = coordinates.size();\\n        if (cz == 1) return false;  // One point only, not a straight line\\n        if (cz == 2) return true;  // Two points only, always a straight line\\n        \\n        int x0 = coordinates[0][0], y0 = coordinates[0][1];\\n        int dx = coordinates[1][0] - x0, dy = coordinates[1][1] - y0;\\n        \\n        for (int i = 1; i < cz; i++) {   // Checking two point formula for each point with the first point\\n            int x = coordinates[i][0], y = coordinates[i][1];\\n            if (dx * (y - y0) != dy * (x - x0))  // Two point formula of line, if (x2-x1)*(y1-y0) = (x1-x0)(y2-y1), then a straight line, otherwise not\\n\\t\\t\\t    return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Time Complexity : O(n)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int cz = coordinates.size();\\n        if (cz == 1) return false;  // One point only, not a straight line\\n        if (cz == 2) return true;  // Two points only, always a straight line\\n        \\n        int x0 = coordinates[0][0], y0 = coordinates[0][1];\\n        int dx = coordinates[1][0] - x0, dy = coordinates[1][1] - y0;\\n        \\n        for (int i = 1; i < cz; i++) {   // Checking two point formula for each point with the first point\\n            int x = coordinates[i][0], y = coordinates[i][1];\\n            if (dx * (y - y0) != dy * (x - x0))  // Two point formula of line, if (x2-x1)*(y1-y0) = (x1-x0)(y2-y1), then a straight line, otherwise not\\n\\t\\t\\t    return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620631,
                "title": "python-simple-fast-solution-cross-product-no-division-by-zero",
                "content": "# Solution Code\\n```\\ndef checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n    x0, y0 = coordinates[0]\\n    x1, y1 = coordinates[1]\\n    dy = y1 - y0\\n    dx = x1 - x0\\n    xp = dx*y0 - dy*x0    # See analysis below\\n\\n    for x, y in coordinates:\\n        if dx*y - dy*x != xp:\\n            return False\\n    else:\\n        return True\\n```\\n*Yes, I\\'m aware that I could have simplified this into a single line or two, but this is much more readable, right?*\\n# Analysis\\nThe straightforward approach is to recognize that two points define a line, and any two points in our set must define *the same line*. Therefore, if we select one common point (say, the first one) and compare the slopes of lines created by every point with this one, they should all be equal. Recall from Algebra that slope is calculated by ```(y1-y0) / (x1-x0)```, or the change in y (dy, or rise) divided by the change in x (dx, or run). If you\\'ve seen other discussion solutions, you may have seen something like this:\\n```\\n# initial naive approach comparing slopes\\ndef checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n    x0, y0 = coordinates[0]\\n    x1, y1 = coordinates[1]\\n    dy = y1 - y0\\n    dx = x1 - x0\\n    m = dy / dx   # m is the slope, as in the slope-intercept form of a line, y = mx + b\\n\\n    for x, y in coordinates:\\n        if (y - y0) / (x - x0) != m:\\n            return False\\n    else:\\n        return True\\n```\\n## But Wait, What About Vertical Lines?\\nI\\'m sure you\\'re screaming \"Hey! That won\\'t work if any of your points lie on the same vertical line! You\\'ll get a divide by zero error!\" And you\\'d be absolutely correct. So we should check that ```dx != 0```. And also that ```x - x0 != 0```. But what if **all** the points are on the same vertical line? Then we should have another ```for``` loop that checks that all the x-coordinates are the same as the first one. While we\\'re at it, might as well do one for the y-coordinates too (it\\'ll run slightly faster if they\\'re on the same horizontal line!). Yikes, this is getting complicated.\\n## There\\'s a Better Way\\nLet\\'s use some *math* to simplify our equation so that we\\'re not worrying about dividing by zero. In our original code, we need to compare the original slope ```(y1-y0) / (x1-x0)``` with each subsequent slope ```(yi-y0) / xi-x0)``` for equality. To simplify things, since the original slope remains constant, let\\'s define ```dy = y1-y0``` and ```dx = x1-x0```. \\n```\\ndy     yi-y0\\n--  =  -----\\ndx     xi-x0\\n```\\nCross-multiply and move all the constant terms to one side to get:\\n```\\ndx*yi - dy*xi = dx*y0 - dy*x0\\n```\\n***Note**: This same equation can also be derived if you take the **cross product** of the vectors formed by AB and AC, where A is the first point, B is the second point, and C is each subsequent point, and set it to zero, since the cross product of two colinear vectors is zero. This is why I\\'ve used the name ```xp``` for the constant term on on the right side of the equation.*\\nFinally, setting ```xp = dx*y0 - dy*x0```, we can iterate through each subsequent point and check that the left side ```dx*yi - dy*xi``` is equal to our ```xp``` term. This avoids any divison by zero, and provides an elegant solution to the problem.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n    x0, y0 = coordinates[0]\\n    x1, y1 = coordinates[1]\\n    dy = y1 - y0\\n    dx = x1 - x0\\n    xp = dx*y0 - dy*x0    # See analysis below\\n\\n    for x, y in coordinates:\\n        if dx*y - dy*x != xp:\\n            return False\\n    else:\\n        return True\\n```\n```(y1-y0) / (x1-x0)```\n```\\n# initial naive approach comparing slopes\\ndef checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n    x0, y0 = coordinates[0]\\n    x1, y1 = coordinates[1]\\n    dy = y1 - y0\\n    dx = x1 - x0\\n    m = dy / dx   # m is the slope, as in the slope-intercept form of a line, y = mx + b\\n\\n    for x, y in coordinates:\\n        if (y - y0) / (x - x0) != m:\\n            return False\\n    else:\\n        return True\\n```\n```dx != 0```\n```x - x0 != 0```\n```for```\n```(y1-y0) / (x1-x0)```\n```(yi-y0) / xi-x0)```\n```dy = y1-y0```\n```dx = x1-x0```\n```\\ndy     yi-y0\\n--  =  -----\\ndx     xi-x0\\n```\n```\\ndx*yi - dy*xi = dx*y0 - dy*x0\\n```\n```xp```\n```xp = dx*y0 - dy*x0```\n```dx*yi - dy*xi```\n```xp```",
                "codeTag": "Python3"
            },
            {
                "id": 620979,
                "title": "java-explanation-to-noob-like-me",
                "content": "So basically at any point of time, any three coordinate should satisfy following condition to be colinear.\\n\\n(y2 - y1)*(x3 - x1) == (x2 - x1)*(y3 - y1)\\n\\nsince there will be atleast two coordinates given, we can take first two coordinate and take ith coordinate to compute the formula.\\n\\n```\\npublic boolean checkStraightLine(int[][] coordinates) {\\n    int[] a = coordinates[0];\\n    int[] b = coordinates[1];\\n    int x1 = a[0];\\n    int x2 = b[0];\\n    int y1 = a[1];\\n    int y2 = b[1];\\n\\n    for (int i = 2; i < coordinates.length; i++) {\\n      int[] curr = coordinates[i];\\n      int x3 = curr[0];\\n      int y3 = curr[1];\\n      if((y2 - y1)*(x3 - x1) != (x2 - x1)*(y3 - y1)) return false;\\n    }\\n    return true;\\n  }\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic boolean checkStraightLine(int[][] coordinates) {\\n    int[] a = coordinates[0];\\n    int[] b = coordinates[1];\\n    int x1 = a[0];\\n    int x2 = b[0];\\n    int y1 = a[1];\\n    int y2 = b[1];\\n\\n    for (int i = 2; i < coordinates.length; i++) {\\n      int[] curr = coordinates[i];\\n      int x3 = curr[0];\\n      int y3 = curr[1];\\n      if((y2 - y1)*(x3 - x1) != (x2 - x1)*(y3 - y1)) return false;\\n    }\\n    return true;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 541898,
                "title": "python-solve-without-calculating-slopes-o-n",
                "content": "Calculating slopes makes us work with a lot of edge cases, checking for zero errors all over the place and making the code very complex.\\n\\nHere is a simple solution that uses some algebra to calculate constants ```A, B, C``` of a line using first two coordinates:\\n\\n```\\nA = y_2 - y_1\\nB = x_1 - x_2\\nC = -A*x_1 - B*y_1\\n```\\nA little algebra can easily verify this (hint: try converting ```Ax+By+C=0``` to ```y=mx+c``` format and you will see the constants come out.\\n\\nThis method allows for integer only computations, thus making life very easy.\\n\\nFollowing is the code\\n\\n```\\ndef checkStraightLine(self, coordinates):\\n        \"\"\"\\n        :type coordinates: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        if len(coordinates) == 2:\\n            return True\\n        A, B = coordinates[0][1] - coordinates[1][1], coordinates[1][0] - coordinates[0][0]\\n        C = -A*coordinates[0][0] - B*coordinates[0][1]\\n        for point in coordinates:\\n            if A*point[0] + B*point[1] + C != 0:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```A, B, C```\n```\\nA = y_2 - y_1\\nB = x_1 - x_2\\nC = -A*x_1 - B*y_1\\n```\n```Ax+By+C=0```\n```y=mx+c```\n```\\ndef checkStraightLine(self, coordinates):\\n        \"\"\"\\n        :type coordinates: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        if len(coordinates) == 2:\\n            return True\\n        A, B = coordinates[0][1] - coordinates[1][1], coordinates[1][0] - coordinates[0][0]\\n        C = -A*coordinates[0][0] - B*coordinates[0][1]\\n        for point in coordinates:\\n            if A*point[0] + B*point[1] + C != 0:\\n                return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1550877,
                "title": "python-simple-solution",
                "content": "**Python :**\\n\\n```\\ndef checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n\\t(x0, y0), (x1, y1) = coordinates[0], coordinates[1]\\n\\t\\n\\tfor i in range(2, len(coordinates)):\\n\\t\\tx, y = coordinates[i]\\n\\t\\tif (x0 - x1) * (y1 - y) != (x1 - x) * (y0 - y1):\\n\\t\\t\\treturn False\\n\\t\\t\\t\\n\\treturn True\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n\\t(x0, y0), (x1, y1) = coordinates[0], coordinates[1]\\n\\t\\n\\tfor i in range(2, len(coordinates)):\\n\\t\\tx, y = coordinates[i]\\n\\t\\tif (x0 - x1) * (y1 - y) != (x1 - x) * (y0 - y1):\\n\\t\\t\\treturn False\\n\\t\\t\\t\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3598629,
                "title": "java-easy-solution-100-faster-code-easy-understanding-beginner-friendly",
                "content": "\\r\\n\\r\\n# Code\\r\\nPLEASE UPVOTE IF YOU LIKE\\r\\n```\\r\\nclass Solution {\\r\\n    // public boolean checkStraightLine(int[][] coordinates) {\\r\\n    // coordinates --> c\\r\\n    public boolean checkStraightLine(int[][] c) {\\r\\n        \\r\\n        \\r\\n        int xMove = c[1][0] - c[0][0];\\r\\n        int yMove = c[1][1] - c[0][1];\\r\\n        \\r\\n        for(int i=1; i<c.length; i++){\\r\\n\\r\\n            int x = c[i][0] - c[i-1][0];\\r\\n            int y = c[i][1] - c[i-1][1];\\r\\n            \\r\\n// linear function -> y = k * x + b;\\r\\n// Here need to discuss y = k * x;\\r\\n// k = yMove / xMove;\\r\\n// y * xMove = x * yMove;\\r\\n            \\r\\n            if(y * xMove != x * yMove) return false;\\r\\n        }\\r\\n        \\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    // public boolean checkStraightLine(int[][] coordinates) {\\r\\n    // coordinates --> c\\r\\n    public boolean checkStraightLine(int[][] c) {\\r\\n        \\r\\n        \\r\\n        int xMove = c[1][0] - c[0][0];\\r\\n        int yMove = c[1][1] - c[0][1];\\r\\n        \\r\\n        for(int i=1; i<c.length; i++){\\r\\n\\r\\n            int x = c[i][0] - c[i-1][0];\\r\\n            int y = c[i][1] - c[i-1][1];\\r\\n            \\r\\n// linear function -> y = k * x + b;\\r\\n// Here need to discuss y = k * x;\\r\\n// k = yMove / xMove;\\r\\n// y * xMove = x * yMove;\\r\\n            \\r\\n            if(y * xMove != x * yMove) return false;\\r\\n        }\\r\\n        \\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1820890,
                "title": "java-easy-and-intuitive-solution-0ms-100",
                "content": "![image](https://assets.leetcode.com/users/images/cfa15109-da76-42d6-8cd1-9161f8d5b868_1646464538.6776812.png)\\n\\n**Code**\\n```java\\npublic boolean checkStraightLine(int[][] coordinates) {\\n\\t// equation\\n\\tint x1 = coordinates[0][0],\\n\\t\\tx2 = coordinates[1][0],\\n\\t\\ty1 = coordinates[0][1],\\n\\t\\ty2 = coordinates[1][1];\\n\\n\\t// equation = ax + by = c\\n\\tint a = (y2 - y1);\\n\\tint b = (x1 - x2);\\n\\tint c = a * x1 + b * y1;\\n\\n\\tfor(int i = 2; i < coordinates.length; i++) {\\n\\t\\tint cval = a * coordinates[i][0] + b * coordinates[i][1];\\n\\t\\tif(cval != c)\\n\\t\\t\\treturn false;\\n\\t}\\n\\n\\treturn true;\\n }\\n```\\n\\nHope it helps\\nThanks\\nDo upvote",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic boolean checkStraightLine(int[][] coordinates) {\\n\\t// equation\\n\\tint x1 = coordinates[0][0],\\n\\t\\tx2 = coordinates[1][0],\\n\\t\\ty1 = coordinates[0][1],\\n\\t\\ty2 = coordinates[1][1];\\n\\n\\t// equation = ax + by = c\\n\\tint a = (y2 - y1);\\n\\tint b = (x1 - x2);\\n\\tint c = a * x1 + b * y1;\\n\\n\\tfor(int i = 2; i < coordinates.length; i++) {\\n\\t\\tint cval = a * coordinates[i][0] + b * coordinates[i][1];\\n\\t\\tif(cval != c)\\n\\t\\t\\treturn false;\\n\\t}\\n\\n\\treturn true;\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1040930,
                "title": "simple-c-solution-using-slope-99-59-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int dy,dx,ndy,ndx,i;\\n        dy=coordinates[1][1] - coordinates[0][1];\\n        dx=coordinates[1][0] - coordinates[0][0];\\n            for(i=2;i<coordinates.size();i++)\\n            {\\n                ndy=coordinates[i][1] - coordinates[0][1];  // new dy\\n                ndx=coordinates[i][0] - coordinates[0][0];  // new dx\\n                if(ndx * dy != ndy * dx)\\n                    return false;\\n            }\\n        return true;\\n    }\\n};\\n```\\nPlease consider upvoting.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int dy,dx,ndy,ndx,i;\\n        dy=coordinates[1][1] - coordinates[0][1];\\n        dx=coordinates[1][0] - coordinates[0][0];\\n            for(i=2;i<coordinates.size();i++)\\n            {\\n                ndy=coordinates[i][1] - coordinates[0][1];  // new dy\\n                ndx=coordinates[i][0] - coordinates[0][0];  // new dx\\n                if(ndx * dy != ndy * dx)\\n                    return false;\\n            }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599439,
                "title": "easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nTo determine if the given points make a straight line, we can calculate the slope between any two points. If the slopes between all pairs of consecutive points are the same, then the points lie on a straight line.\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n1. Get the coordinates of the first two points in the `coordinates` array.\\r\\n2. Calculate the slope between these two points using the formula: `slope = (y2- y1) / (x2 - x1)`.\\r\\n3. Iterate through the remaining points in the `coordinates` array.\\r\\n4. For each point, calculate the slope between the current point and the first\\r\\npoint using the same formula.\\r\\n5. If the calculated slope is not equal to the slope between the first two points,return `false`.\\r\\n6. If all slopes are equal, return `true`.\\r\\n\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\nWe iterate through all the points in the `coordinates` array once, where n is the number of points.\\r\\n\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\nWe only use a constant amount of extra space to store variables for\\r\\ncalculations.\\r\\n\\r\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\r\\n\\r\\n\\r\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\r\\n```\\r\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\r\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\r\\nIt\\'s a simple way to show your appreciation and\\r\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\r\\n```\\r\\n\\r\\n\\r\\n# Code\\r\\n```Java []\\r\\nclass Solution {\\r\\n    public boolean checkStraightLine(int[][] coordinates) {\\r\\n         // Get the coordinates of the first two points\\r\\n        int[] point1 = coordinates[0];\\r\\n        int[] point2 = coordinates[1];\\r\\n        \\r\\n        // Calculate the slope between the first two points\\r\\n        int deltaX = point2[0] - point1[0];\\r\\n        int deltaY = point2[1] - point1[1];\\r\\n        \\r\\n        // Iterate through the remaining points\\r\\n        for (int i = 2; i < coordinates.length; i++) {\\r\\n            int[] currentPoint = coordinates[i];\\r\\n            \\r\\n            // Calculate the slope between the current point and the first point\\r\\n            int currentDeltaX = currentPoint[0] - point1[0];\\r\\n            int currentDeltaY = currentPoint[1] - point1[1];\\r\\n            \\r\\n            // If the slopes are not the same, return false\\r\\n            if (deltaX * currentDeltaY != deltaY * currentDeltaX) {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        // All slopes are the same, so the points make a straight line\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n```\\r\\n```C++ []\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        // Get the coordinates of the first two points\\r\\n        vector<int>& point1 = coordinates[0];\\r\\n        vector<int>& point2 = coordinates[1];\\r\\n        \\r\\n        // Calculate the slope between the first two points\\r\\n        int deltaX = point2[0] - point1[0];\\r\\n        int deltaY = point2[1] - point1[1];\\r\\n        \\r\\n        // Iterate through the remaining points\\r\\n        for (int i = 2; i < coordinates.size(); i++) {\\r\\n            vector<int>& currentPoint = coordinates[i];\\r\\n            \\r\\n            // Calculate the slope between the current point and the first point\\r\\n            int currentDeltaX = currentPoint[0] - point1[0];\\r\\n            int currentDeltaY = currentPoint[1] - point1[1];\\r\\n            \\r\\n            // If the slopes are not the same, return false\\r\\n            if (deltaX * currentDeltaY != deltaY * currentDeltaX) {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        // All slopes are the same, so the points make a straight line\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n\\r\\n```\\r\\n```Python []\\r\\nclass Solution(object):\\r\\n    def checkStraightLine(self, coordinates):\\r\\n        # Get the coordinates of the first two points\\r\\n        point1 = coordinates[0]\\r\\n        point2 = coordinates[1]\\r\\n        \\r\\n        # Calculate the slope between the first two points\\r\\n        deltaX = point2[0] - point1[0]\\r\\n        deltaY = point2[1] - point1[1]\\r\\n        \\r\\n        # Iterate through the remaining points\\r\\n        for i in range(2, len(coordinates)):\\r\\n            currentPoint = coordinates[i]\\r\\n            \\r\\n            # Calculate the slope between the current point and the first point\\r\\n            currentDeltaX = currentPoint[0] - point1[0]\\r\\n            currentDeltaY = currentPoint[1] - point1[1]\\r\\n            \\r\\n            # If the slopes are not the same, return False\\r\\n            if deltaX * currentDeltaY != deltaY * currentDeltaX:\\r\\n                return False\\r\\n        \\r\\n        # All slopes are the same, so the points make a straight line\\r\\n        return True\\r\\n\\r\\n```\\r\\n\\r\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\r\\n```\\r\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\r\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\r\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\r\\nIt\\'s a simple way to show your appreciation and\\r\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\r\\n```\n```Java []\\r\\nclass Solution {\\r\\n    public boolean checkStraightLine(int[][] coordinates) {\\r\\n         // Get the coordinates of the first two points\\r\\n        int[] point1 = coordinates[0];\\r\\n        int[] point2 = coordinates[1];\\r\\n        \\r\\n        // Calculate the slope between the first two points\\r\\n        int deltaX = point2[0] - point1[0];\\r\\n        int deltaY = point2[1] - point1[1];\\r\\n        \\r\\n        // Iterate through the remaining points\\r\\n        for (int i = 2; i < coordinates.length; i++) {\\r\\n            int[] currentPoint = coordinates[i];\\r\\n            \\r\\n            // Calculate the slope between the current point and the first point\\r\\n            int currentDeltaX = currentPoint[0] - point1[0];\\r\\n            int currentDeltaY = currentPoint[1] - point1[1];\\r\\n            \\r\\n            // If the slopes are not the same, return false\\r\\n            if (deltaX * currentDeltaY != deltaY * currentDeltaX) {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        // All slopes are the same, so the points make a straight line\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n```\n```C++ []\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        // Get the coordinates of the first two points\\r\\n        vector<int>& point1 = coordinates[0];\\r\\n        vector<int>& point2 = coordinates[1];\\r\\n        \\r\\n        // Calculate the slope between the first two points\\r\\n        int deltaX = point2[0] - point1[0];\\r\\n        int deltaY = point2[1] - point1[1];\\r\\n        \\r\\n        // Iterate through the remaining points\\r\\n        for (int i = 2; i < coordinates.size(); i++) {\\r\\n            vector<int>& currentPoint = coordinates[i];\\r\\n            \\r\\n            // Calculate the slope between the current point and the first point\\r\\n            int currentDeltaX = currentPoint[0] - point1[0];\\r\\n            int currentDeltaY = currentPoint[1] - point1[1];\\r\\n            \\r\\n            // If the slopes are not the same, return false\\r\\n            if (deltaX * currentDeltaY != deltaY * currentDeltaX) {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        // All slopes are the same, so the points make a straight line\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n\\r\\n```\n```Python []\\r\\nclass Solution(object):\\r\\n    def checkStraightLine(self, coordinates):\\r\\n        # Get the coordinates of the first two points\\r\\n        point1 = coordinates[0]\\r\\n        point2 = coordinates[1]\\r\\n        \\r\\n        # Calculate the slope between the first two points\\r\\n        deltaX = point2[0] - point1[0]\\r\\n        deltaY = point2[1] - point1[1]\\r\\n        \\r\\n        # Iterate through the remaining points\\r\\n        for i in range(2, len(coordinates)):\\r\\n            currentPoint = coordinates[i]\\r\\n            \\r\\n            # Calculate the slope between the current point and the first point\\r\\n            currentDeltaX = currentPoint[0] - point1[0]\\r\\n            currentDeltaY = currentPoint[1] - point1[1]\\r\\n            \\r\\n            # If the slopes are not the same, return False\\r\\n            if deltaX * currentDeltaY != deltaY * currentDeltaX:\\r\\n                return False\\r\\n        \\r\\n        # All slopes are the same, so the points make a straight line\\r\\n        return True\\r\\n\\r\\n```\n```\\r\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599148,
                "title": "c-easy-math",
                "content": "# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        int dx = (coordinates[1][1] - coordinates[0][1]);\\r\\n        int dy = (coordinates[1][0] - coordinates[0][0]);\\r\\n        for(int i=2; i<coordinates.size(); i++)\\r\\n        {\\r\\n            if(dx*(coordinates[i][0] - coordinates[1][0]) != dy*(coordinates[i][1] - coordinates[1][1]))\\r\\n                return false;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n\\r\\n```\\r\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/fc589b46-77ff-42f3-b87f-2bebe66caf34_1685940761.2530458.jpeg)\\r\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        int dx = (coordinates[1][1] - coordinates[0][1]);\\r\\n        int dy = (coordinates[1][0] - coordinates[0][0]);\\r\\n        for(int i=2; i<coordinates.size(); i++)\\r\\n        {\\r\\n            if(dx*(coordinates[i][0] - coordinates[1][0]) != dy*(coordinates[i][1] - coordinates[1][1]))\\r\\n                return false;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259991,
                "title": "find-slope-you-will-get-the-answer",
                "content": "\\n# 1. Use the Two Point Slope Formula\\n\\n```\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        int x1,y1,x2,y2;\\n        x1=coordinates[0][0];\\n        y1=coordinates[0][1];\\n        x2=coordinates[1][0];\\n        y2=coordinates[1][1];\\n        for(int i=2;i<coordinates.length;i++){\\n            if (((coordinates[i][1]-y1)*(x2-x1))!=((y2-y1)*(coordinates[i][0]-x1))){\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n\\n```\\n\\n# 2. Find the Slope Using two Point slope formula in Python3\\n```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        x1,y1=coordinates[0][0],coordinates[0][1]\\n        x2,y2=coordinates[1][0],coordinates[1][1]\\n        for x3,y3 in coordinates[2:]:\\n            if (y3-y2)*(x2-x1)!=(x3-x2)*(y2-y1):\\n                return False\\n        else:\\n            return True\\n```\\n# please upvote me it would encourage me alot",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        int x1,y1,x2,y2;\\n        x1=coordinates[0][0];\\n        y1=coordinates[0][1];\\n        x2=coordinates[1][0];\\n        y2=coordinates[1][1];\\n        for(int i=2;i<coordinates.length;i++){\\n            if (((coordinates[i][1]-y1)*(x2-x1))!=((y2-y1)*(coordinates[i][0]-x1))){\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        x1,y1=coordinates[0][0],coordinates[0][1]\\n        x2,y2=coordinates[1][0],coordinates[1][1]\\n        for x3,y3 in coordinates[2:]:\\n            if (y3-y2)*(x2-x1)!=(x3-x2)*(y2-y1):\\n                return False\\n        else:\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580129,
                "title": "using-property-of-straight-line-using-slope-java-c-everything-explained",
                "content": "## **The point is if we take points p1(x, y), p2(x1, y1), p3(x3, y3), slopes of any two pairs is same then p1, p2, p3 lies on same line.**\\n**slope from p1 and p2 is y - y1 / x - x1\\nslope from p2 and p3 is y2 - y1 / x2 - x1\\nif these two slopes equal, then p1, p2, p3 lies on same line.**\\n![image](https://assets.leetcode.com/users/images/49cd8965-2154-4dc0-896f-4791e18d1642_1663256637.5986826.png)\\n```\\n/* Java Solution */\\nclass Solution {\\n    public boolean checkStraightLine(int[][] c) {\\n        // First pair of point (x0, y0)\\n        int x0 = c[0][0];\\n        int y0 = c[0][1];\\n\\n        // Second pair of point (x1, y1)\\n        int x1 = c[1][0];\\n        int y1 = c[1][1];\\n\\n        int dx = x1 - x0, dy = y1 - y0;\\n        \\n        \\n         // Loop to iterate over the points\\n        for (int i = 0; i < c.length; i++) {\\n            int x = c[i][0], y = c[i][1];\\n            if (dx * (y - y1) != dy * (x - x1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n\\n\\n/* C++ Solution */\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& c) {\\n        \\n        // First pair of point (x0, y0)\\n        int x0 = c[0][0];\\n        int y0 = c[0][1];\\n\\n        // Second pair of point (x1, y1)\\n        int x1 = c[1][0];\\n        int y1 = c[1][1];\\n\\n        int dx = x1 - x0, dy = y1 - y0;\\n        \\n        \\n         // Loop to iterate over the points\\n        for (int i = 0; i < c.size(); i++) {\\n            int x = c[i][0], y = c[i][1];\\n            if (dx * (y - y1) != dy * (x - x1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n\\n/*\\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Math"
                ],
                "code": "```\\n/* Java Solution */\\nclass Solution {\\n    public boolean checkStraightLine(int[][] c) {\\n        // First pair of point (x0, y0)\\n        int x0 = c[0][0];\\n        int y0 = c[0][1];\\n\\n        // Second pair of point (x1, y1)\\n        int x1 = c[1][0];\\n        int y1 = c[1][1];\\n\\n        int dx = x1 - x0, dy = y1 - y0;\\n        \\n        \\n         // Loop to iterate over the points\\n        for (int i = 0; i < c.length; i++) {\\n            int x = c[i][0], y = c[i][1];\\n            if (dx * (y - y1) != dy * (x - x1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n\\n\\n/* C++ Solution */\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& c) {\\n        \\n        // First pair of point (x0, y0)\\n        int x0 = c[0][0];\\n        int y0 = c[0][1];\\n\\n        // Second pair of point (x1, y1)\\n        int x1 = c[1][0];\\n        int y1 = c[1][1];\\n\\n        int dx = x1 - x0, dy = y1 - y0;\\n        \\n        \\n         // Loop to iterate over the points\\n        for (int i = 0; i < c.size(); i++) {\\n            int x = c[i][0], y = c[i][1];\\n            if (dx * (y - y1) != dy * (x - x1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n\\n/*\\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1810591,
                "title": "c-simple-solution-with-explanation",
                "content": "`Condition for three points/coordinates (x0, y0), (x1, y1), (x, y) to be collinear is :`\\n`(x - x0) (y1 - y0) == (y - y0) (x1 - x0) `\\n\\n`Reason: Slope for a line through 2 points (x0, y0), (x1, y1) is (y1 - y0)/(x1 - x0) and Slope for a line through other 2 points (x, y), (x0, y0) is (y - y0)/(x- x0).  `\\n`Now for these 3 points[(x0, y0), (x1, y1), (x, y)] to be collinear the slopes must be equal i.e,`\\n`(y1 - y0)/(x1 - x0) = (y - y0)/(x- x0)`\\n`or, (x - x0) (y1 - y0) = (y - y0) (x1 - x0)`\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int n = coordinates.size();\\n        \\n        int xdiff = coordinates[1][0] - coordinates[0][0]; // (x1 - x0)\\n        int ydiff = coordinates[1][1] - coordinates[0][1]; // (y1 - y0)\\n        \\n        for(int i = 2; i < n; i++) {\\n            int x1 = coordinates[i][0] - coordinates[0][0]; // (x - x0)\\n            int y1 = coordinates[i][1] - coordinates[0][1]; // (y - y0)\\n            \\n            if(x1 * ydiff != y1 * xdiff) return false; \\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\n\\n*Do upvote if you like the solution :)*",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int n = coordinates.size();\\n        \\n        int xdiff = coordinates[1][0] - coordinates[0][0]; // (x1 - x0)\\n        int ydiff = coordinates[1][1] - coordinates[0][1]; // (y1 - y0)\\n        \\n        for(int i = 2; i < n; i++) {\\n            int x1 = coordinates[i][0] - coordinates[0][0]; // (x - x0)\\n            int y1 = coordinates[i][1] - coordinates[0][1]; // (y - y0)\\n            \\n            if(x1 * ydiff != y1 * xdiff) return false; \\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900914,
                "title": "python-pure-math-solution-faster-than-100-less-than-100-memory",
                "content": "```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        x1, y1 = coordinates[0]\\n        x2, y2 = coordinates[1]\\n\\t\\t\\n        for x, y in coordinates[2:]:\\n            if (y2 - y1) * (x - x1) != (x2 - x1) * (y - y1):\\n                return False\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        x1, y1 = coordinates[0]\\n        x2, y2 = coordinates[1]\\n\\t\\t\\n        for x, y in coordinates[2:]:\\n            if (y2 - y1) * (x - x1) != (x2 - x1) * (y - y1):\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1176782,
                "title": "golang-solution-100-100-with-explanation",
                "content": "`time = 100%, O(n)`\\n`space = 100%, O(1)`\\n\\n[1232. Check If It Is a Straight Line](https://leetcode.com/problems/check-if-it-is-a-straight-line/)\\n\\nThe idea of this solution is we use `3` points to find whether two slopes are equal. We can use the equation:![image](https://assets.leetcode.com/users/images/b1a5e6f1-79e2-48fd-9595-97bbc4e799b5_1619403108.4592967.jpeg)\\n where `x0, x1, x2, y0, y1, y2` are all coordinates: ![image](https://assets.leetcode.com/users/images/436b4e59-b158-4901-b2fb-4865f2a5ab6a_1619403125.7176585.jpeg)\\n You might not understand the equation, so we can multiply divide both sides by `(x1 - x0)` and `(x2 - x1)` and we can get: ![image](https://assets.leetcode.com/users/images/a9321f76-d54f-4003-bed0-b772c0a5867f_1619403157.863461.jpeg)\\n The equation above is based off of a familar slope equation: ![image](https://assets.leetcode.com/users/images/a9f5ac94-57c1-476b-8747-e67e32b34b13_1619403182.6362567.jpeg)\\n The reason we are doing the original equation instead of the where we have divided both sides by `(x1 - x0)` and `(x2 - x1)` is we don\\'t have to worry about dividing by `0` such as when we divide both sides by `(x1 - x0)` and `(x2 - x1)` but `(x1 - x0) = 0` or `(x2 - x1) = 0` we have to contumplate what to do. \\n\\n**The Code:**\\n\\n``` go\\nfunc checkStraightLine(coordinates [][]int) bool {\\n    x0, x1, := coordinates[0][0], coordinates[1][0]\\n    y0, y1 := coordinates[0][1], coordinates[1][1]\\n\\n    for i := 1; i < len(coordinates); i++ {\\n        x2, y2 := coordinates[i][0], coordinates[i][1]\\n        if (x1 - x0) * (y2 - y1) != (y1 - y0) * (x2 - x1) {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc checkStraightLine(coordinates [][]int) bool {\\n    x0, x1, := coordinates[0][0], coordinates[1][0]\\n    y0, y1 := coordinates[0][1], coordinates[1][1]\\n\\n    for i := 1; i < len(coordinates); i++ {\\n        x2, y2 := coordinates[i][0], coordinates[i][1]\\n        if (x1 - x0) * (y2 - y1) != (y1 - y0) * (x2 - x1) {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1378842,
                "title": "short-javascript-solution-using-mathematics-with-o-1-space-and-o-n-time-complexity",
                "content": "Using mathematics, we can sketch a line that will always cross the first and second point in the list of coordinates, then simply check if the rest of the points also lie on that line:\\n```\\nvar checkStraightLine = function(coordinates) {\\n    let a = -(coordinates[1][1] - coordinates[0][1]);\\n    let b = coordinates[1][0] - coordinates[0][0];\\n    return coordinates.every(\\n        item =>\\n            a * (item[0] - coordinates[0][0]) +\\n                b * (item[1] - coordinates[0][1]) ===\\n            0\\n    );\\n};\\n```\\nFor a and b we are calculating a vector that is perpendicular to the above mentioned line, then the equation for the line is ``` a*( x - x0 ) + b*( y- y0 ) = 0 ```, with x0 and y0 being the first or second point in the list of coordinates. **Array.every()** returns true if a condition is true with **every single member** of the array.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkStraightLine = function(coordinates) {\\n    let a = -(coordinates[1][1] - coordinates[0][1]);\\n    let b = coordinates[1][0] - coordinates[0][0];\\n    return coordinates.every(\\n        item =>\\n            a * (item[0] - coordinates[0][0]) +\\n                b * (item[1] - coordinates[0][1]) ===\\n            0\\n    );\\n};\\n```\n``` a*( x - x0 ) + b*( y- y0 ) = 0 ```",
                "codeTag": "Unknown"
            },
            {
                "id": 3079000,
                "title": "only-math-explained",
                "content": "\\n# Explanations\\nEvery straight line has a constant slope, and the slope of a line gives the measure of its steepness and direction(in this problem we do not need direction).\\nwe can calculate the slope of a line (which we name it as m) as follow:\\n![1.PNG](https://assets.leetcode.com/users/images/e8faf8b8-f42e-4ae3-908b-21030d750c7c_1674253519.1065228.png)\\nrise mean changes in y axis and run mean changes in x axis:\\n![3.jpg](https://assets.leetcode.com/users/images/ed218e58-8e72-4ce2-a6e5-5ffde1f8bb19_1674253631.6962223.jpeg)\\nso at first I started to compare the slopes or m that are made by each two points and check if they are the same(in this case I should return true because it means all the points are on a straight line) but the problem was when the run is equal to zero,it means that I was asking the program to divide an integer by zero which led me to an error. so what I did was trying to find a way that there is no need to divide by zero. so I went to the point-slope linear equation formula and used a third point as a variable.\\n![4.png](https://assets.leetcode.com/users/images/6760e4bc-defc-45ef-8e6f-ae7e4f568bbd_1674254513.53134.png)\\nthen I turned this into:\\n![5.PNG](https://assets.leetcode.com/users/images/42af5b96-5c3d-48ab-8f92-090c6579cca8_1674255213.3207464.png)\\n \\nP.S. : each two points can be on a straight line so that is why of the array length is two I return true.\\nFeel free to ask if you have any questions.\\n\\n\\n\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool CheckStraightLine(int[][] coordinates) {\\n        if(coordinates.Length==2)return true;\\n        for (int i = 0; i < coordinates.Length-2; i++)\\n            {\\n                int l = (coordinates[i+2][1] -coordinates[i][1]) * (coordinates[i+1][0] - coordinates[i][0]);\\n                int r = (coordinates[i+1][1] - coordinates[i][1]) * (coordinates[i+2][0] -coordinates[i][0]);\\n                if (l != r) return false;\\n            }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool CheckStraightLine(int[][] coordinates) {\\n        if(coordinates.Length==2)return true;\\n        for (int i = 0; i < coordinates.Length-2; i++)\\n            {\\n                int l = (coordinates[i+2][1] -coordinates[i][1]) * (coordinates[i+1][0] - coordinates[i][0]);\\n                int r = (coordinates[i+1][1] - coordinates[i][1]) * (coordinates[i+2][0] -coordinates[i][0]);\\n                if (l != r) return false;\\n            }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515040,
                "title": "c-o-n-only-one-condition-required-to-check",
                "content": "**Any  doubts then please ask in the comment section**\\n```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coor) {\\n     \\n        \\n        for(int i=2;i<coor.size();i++)\\n        {\\n          if((coor[1][1]-coor[0][1])*(coor[i][0]-coor[1][0])!=(coor[1][0]-coor[0][0])*(coor[i][1]-coor[1][1]))\\n          {\\n              return false;\\n          }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coor) {\\n     \\n        \\n        for(int i=2;i<coor.size();i++)\\n        {\\n          if((coor[1][1]-coor[0][1])*(coor[i][0]-coor[1][0])!=(coor[1][0]-coor[0][0])*(coor[i][1]-coor[1][1]))\\n          {\\n              return false;\\n          }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1277693,
                "title": "c-easy-to-understand-straight-forward-solution-using-determinants",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome***\\n```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& c) {\\n        int m=c.size();\\n        if(m==2)\\n            return true;\\n        int det=0;\\n        for(int i=2;i<m;i++)\\n        {\\n            det=c[0][0]*(c[1][1]-c[i][1])-c[0][1]*(c[1][0]-c[i][0])+(c[1][0]*c[i][1]-c[1][1]*c[i][0]);\\n            if(det!=0)\\n               return false; \\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& c) {\\n        int m=c.size();\\n        if(m==2)\\n            return true;\\n        int det=0;\\n        for(int i=2;i<m;i++)\\n        {\\n            det=c[0][0]*(c[1][1]-c[i][1])-c[0][1]*(c[1][0]-c[i][0])+(c[1][0]*c[i][1]-c[1][1]*c[i][0]);\\n            if(det!=0)\\n               return false; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 620610,
                "title": "c-short-solutions-one-liner",
                "content": "1) My solution - just from the formula we\\'ve learned at school:\\n\\t**y = ax + b** => **b =y - ax**\\n\\t**b = y0 - ax0**\\n\\t**b = y1 - ax1**\\n\\t=> **y0 - ax0 = y1 - ax1**\\n\\t=> **a = (y0 - y1) / (x0 - x1)**\\n\\tthen **b = y - ax**\\n\\tBut if **x0 == x1** (it might be **x = const** for any **y**) we\\'ll get devide by zero exception.\\n\\tSo I just fixed it with **point.x == x0** condition for any point if **x0 == x1**\\n\\n```\\n    public bool CheckStraightLine(int[][] c) {\\n        Func<int[], bool> isOnLine;\\n        if (c[0][0] == c[1][0]) {\\n            isOnLine = point => point[0] == c[0][0];\\n        }\\n        else {\\n            var a = (c[0][1] - c[1][1]) / (c[0][0] - c[1][0]);\\n            var b = c[0][1] - a * c[0][0];\\n            isOnLine = point => point[1] == a * point[0] + b;\\n        }\\n        return c.Skip(2).All(isOnLine);\\n    }\\n```\\n\\n2) Another solution I borrowed from [here](https://leetcode.com/problems/check-if-it-is-a-straight-line/discuss/408984/JavaPython-3-check-slopes-short-code-w-explanation-and-analysis.). There is also solution explanation there.\\n\\tI just wrote it on on C#:\\n\\n```\\n        public bool CheckStraightLine(int[][] c)\\n        {\\n            var x0 = X(c[0]);\\n            var y0 = Y(c[0]);\\n            var dx = x0 - X(c[1]);\\n            var dy = y0 - Y(c[1]);\\n\\n            return c.All(p => dx * (y0 - Y(p)) == dy * (x0 - X(p)));\\n        }\\n\\n        private static int X(int[] point) => point[0];\\n        private static int Y(int[] point) => point[1];\\n```\\n\\nIt might be also a stupid one-liner )\\n\\n```\\n        public bool CheckStraightLine(int[][] c) =>\\n            c.All(p => (X(c[0]) - X(c[1])) * (Y(c[0]) - Y(p)) == (Y(c[0]) - Y(c[1])) * (X(c[0]) - X(p)));\\n\\n        private static int X(int[] point) => point[0];\\n        private static int Y(int[] point) => point[1];\\n```\\n\\nOr even uglier )\\n```\\n        public bool CheckStraightLine(int[][] c) =>\\n            c.All(p => (c[0][0] - c[1][0]) * (c[0][1] - p[1]) == (c[0][1] - c[1][1]) * (c[0][0] - p[0]));\\n```",
                "solutionTags": [],
                "code": "```\\n    public bool CheckStraightLine(int[][] c) {\\n        Func<int[], bool> isOnLine;\\n        if (c[0][0] == c[1][0]) {\\n            isOnLine = point => point[0] == c[0][0];\\n        }\\n        else {\\n            var a = (c[0][1] - c[1][1]) / (c[0][0] - c[1][0]);\\n            var b = c[0][1] - a * c[0][0];\\n            isOnLine = point => point[1] == a * point[0] + b;\\n        }\\n        return c.Skip(2).All(isOnLine);\\n    }\\n```\n```\\n        public bool CheckStraightLine(int[][] c)\\n        {\\n            var x0 = X(c[0]);\\n            var y0 = Y(c[0]);\\n            var dx = x0 - X(c[1]);\\n            var dy = y0 - Y(c[1]);\\n\\n            return c.All(p => dx * (y0 - Y(p)) == dy * (x0 - X(p)));\\n        }\\n\\n        private static int X(int[] point) => point[0];\\n        private static int Y(int[] point) => point[1];\\n```\n```\\n        public bool CheckStraightLine(int[][] c) =>\\n            c.All(p => (X(c[0]) - X(c[1])) * (Y(c[0]) - Y(p)) == (Y(c[0]) - Y(c[1])) * (X(c[0]) - X(p)));\\n\\n        private static int X(int[] point) => point[0];\\n        private static int Y(int[] point) => point[1];\\n```\n```\\n        public bool CheckStraightLine(int[][] c) =>\\n            c.All(p => (c[0][0] - c[1][0]) * (c[0][1] - p[1]) == (c[0][1] - c[1][1]) * (c[0][0] - p[0]));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3010037,
                "title": "c-one-line-solution-with-explantion",
                "content": "# Intuition\\n- To check if three points are in straight line or not we try to assume it as a triangle and if the area of traingle if zero then we say that the three points are in straight line.\\n\\n# Approach\\n- The solution to this question is you take the first 2 points and check for every point if with any point the first two points makes a triangle of a positive area the answer is no that the coordinates are not in straight line.\\n- The formula to calculate area is (1/12)*(x1(y2-y3) + x2(y3-y1) + x3(y1-y2)) apply the same formula learnt in school\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& c) {\\n        for(int i=2;i<c.size();i++)\\n            if(((c[0][0]*(c[1][1]-c[i][1])) + (c[1][0]*(c[i][1]-c[0][1])) + (c[i][0]*(c[0][1]-c[1][1]))) != 0) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& c) {\\n        for(int i=2;i<c.size();i++)\\n            if(((c[0][0]*(c[1][1]-c[i][1])) + (c[1][0]*(c[i][1]-c[0][1])) + (c[i][0]*(c[0][1]-c[1][1]))) != 0) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773672,
                "title": "easy-c-o-n-soln-faang-interview-optimized-code",
                "content": "`Check If It Is a Straight Line`\\n\\n# **LOGIC  \\uD83D\\uDC47**\\n# dy/dx = curr_dy/curr_dx\\n# where curr_dy = y2 - y1 and curr_dx = x2 - x1\\n# and dy = y1 - y0 and dx = x1 - x0 \\n\\n# ***Easy logic ! Beginner friendly !***\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        \\n        int dy=coordinates[1][1]-coordinates[0][1];\\n        int dx=coordinates[1][0]-coordinates[0][0];\\n        \\n        for(int i=2;i<coordinates.size();i++){\\n            \\n            int curr_dy=coordinates[i][1]-coordinates[i-1][1];\\n            int curr_dx=coordinates[i][0]-coordinates[i-1][0];\\n            \\n            if(dy*curr_dx != dx*curr_dy)\\n                return 0;  \\n            // dy/dx != curr_dy/curr_dx might through a run time error:division by 0\\n        }\\n        return 1;\\n    }\\n};\\n```\\n# ***Please upvote if it helps \\uD83D\\uDE4F***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        \\n        int dy=coordinates[1][1]-coordinates[0][1];\\n        int dx=coordinates[1][0]-coordinates[0][0];\\n        \\n        for(int i=2;i<coordinates.size();i++){\\n            \\n            int curr_dy=coordinates[i][1]-coordinates[i-1][1];\\n            int curr_dx=coordinates[i][0]-coordinates[i-1][0];\\n            \\n            if(dy*curr_dx != dx*curr_dy)\\n                return 0;  \\n            // dy/dx != curr_dy/curr_dx might through a run time error:division by 0\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901579,
                "title": "java-simple-o-n-code-with-explanation-and-analysis-0ms-100-solution",
                "content": "#### **Explanation**\\n\\nIf the coordinates of two points are (x1, y1) and (x2, y2), then their slope is defined as:\\n\\n\\tSlope, m = (y2-y1)/(x2-x1)\\n\\nAnd if the slopes of multiple points are the same, it means that they\\'re all in the same line (collinear).\\n\\nTo solve this problem, let\\'s compare the slope of (x1, y1) & (x2, y2) points with the slope of (x2, y2) & (x3, y3), and check if they\\'re equal.\\n\\n\\tslope of (x1,y1) & (x2,y2) == slope of (x2,y2) & (x3,y3)\\ni.e,\\n\\n\\t(y2-y1)/(x2-x1) == (y3-y2)/(x3-x2)\\nor,\\n\\t\\n\\t(y2-y1)*(x3-x2) == (y3-y2)*(x2-x1)\\n\\nThis form of the equation will avoid us from the \\'denominator is 0\\' issue. \\n\\nIn the code, we keep the first two points fixed and we compare the collinearity of the third point with the first two points. If the slopes match, then they\\'re in a straight line. \\n\\n\\n##### **JAVA CODE:**\\n\\n```\\nclass Solution {\\n\\xA0 \\xA0 public boolean checkStraightLine(int[][] coordinates) {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 // Return true if there are only two points. Because joining two points will always form a straight line.\\n\\xA0 \\xA0 \\xA0 \\xA0 if(coordinates.length==2) return true;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 // Point 1 (fixed)\\n\\xA0 \\xA0 \\xA0 \\xA0 int x1 = coordinates[0][0];\\n\\xA0 \\xA0 \\xA0 \\xA0 int y1 = coordinates[0][1];\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 // Point 2 (fixed)\\n\\xA0 \\xA0 \\xA0 \\xA0 int x2 = coordinates[1][0];\\n\\xA0 \\xA0 \\xA0 \\xA0 int y2 = coordinates[1][1];\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\t\\t// Loop from the 3rd point until the end of the\\xA0coordinates array.\\n\\xA0 \\xA0 \\xA0 \\xA0 for(int i=2; i<coordinates.length; i++){\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 // New point\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 int x3 = coordinates[i][0];\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 int y3 = coordinates[i][1];\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 // Compare slopes. If not same, return false.\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if((y2-y1)*(x3-x2) != (y3-y2)*(x2-x1)){\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 return false;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\t\\t\\n\\xA0 \\xA0 \\xA0 \\xA0 // If all the slope comparisons match, return true.\\n\\xA0 \\xA0 \\xA0 \\xA0 return true;\\n\\xA0 \\xA0 }\\n}\\n```\\n\\n#### **Analysis**\\n\\nTime: O(n) || Space: O(1)\\nn = coordinates.length\\n\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/5b9e5c40-1cbc-41d8-a536-9114a5450eb4_1648761619.075595.png)\\n\\n\\n\\n**Hope you understood the solution! If there are any mistakes/improvements, please let me know.**\\n\\n**Happy Coding <3**\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\xA0 \\xA0 public boolean checkStraightLine(int[][] coordinates) {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 // Return true if there are only two points. Because joining two points will always form a straight line.\\n\\xA0 \\xA0 \\xA0 \\xA0 if(coordinates.length==2) return true;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 // Point 1 (fixed)\\n\\xA0 \\xA0 \\xA0 \\xA0 int x1 = coordinates[0][0];\\n\\xA0 \\xA0 \\xA0 \\xA0 int y1 = coordinates[0][1];\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 // Point 2 (fixed)\\n\\xA0 \\xA0 \\xA0 \\xA0 int x2 = coordinates[1][0];\\n\\xA0 \\xA0 \\xA0 \\xA0 int y2 = coordinates[1][1];\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\t\\t// Loop from the 3rd point until the end of the\\xA0coordinates array.\\n\\xA0 \\xA0 \\xA0 \\xA0 for(int i=2; i<coordinates.length; i++){\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 // New point\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 int x3 = coordinates[i][0];\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 int y3 = coordinates[i][1];\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 // Compare slopes. If not same, return false.\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if((y2-y1)*(x3-x2) != (y3-y2)*(x2-x1)){\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 return false;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\t\\t\\n\\xA0 \\xA0 \\xA0 \\xA0 // If all the slope comparisons match, return true.\\n\\xA0 \\xA0 \\xA0 \\xA0 return true;\\n\\xA0 \\xA0 }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915455,
                "title": "java-compare-slopes-simple-code-with-explanations-100-faster",
                "content": "A given line is considered to be a straight line if the slope between any 3 points on that line is similar,i.e;\\nA(x0,y0) , B(x1,y1) , C(x2,y2) is considered to be a straight line if **slope of BA = slope of CB**.\\nAlso , **Slope(m)=(y2-y1)/(x2-x1)**\\n**The most important catch here is that in order to avoid the Arithmetic exception due to division by zero**  , we multiply the slopes of different points.\\nA(x0,y0) , B(x1,y1) , C(x2,y2) are the 3 points, so we check if **((y1-y0) * (x2-x1)) != ((y2-y1) * (x1-x0))**, if this satisfies for any 3 points then, it cant be a straight line.\\n\\n```\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        int noOfRows=coordinates.length;\\n        for(int i=2;i<noOfRows;i++)\\n        {\\n            int x0=coordinates[i-2][0];\\n            int y0=coordinates[i-2][1];\\n            int x1=coordinates[i-1][0];\\n            int y1=coordinates[i-1][1];\\n            int x2=coordinates[i][0];\\n            int y2=coordinates[i][1];\\n            if((y1-y0)*(x2-x1)!=(y2-y1)*(x1-x0))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        int noOfRows=coordinates.length;\\n        for(int i=2;i<noOfRows;i++)\\n        {\\n            int x0=coordinates[i-2][0];\\n            int y0=coordinates[i-2][1];\\n            int x1=coordinates[i-1][0];\\n            int y1=coordinates[i-1][1];\\n            int x2=coordinates[i][0];\\n            int y2=coordinates[i][1];\\n            if((y1-y0)*(x2-x1)!=(y2-y1)*(x1-x0))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507077,
                "title": "javascript-solution-shoelace-formula",
                "content": "Solving one of the Math problems, I learned about [Shoelace Formula](https://en.wikipedia.org/wiki/Shoelace_formula) and thought it would be cool to use it here. Please let me know what you guys think.\\n\\n```\\nvar checkStraightLine = function(coords) {\\n    const n = coords.length;\\n    \\n    for (let i = 0; i < n - 2; i++) {\\n        const area = Math.abs(1/2 * (\\n            (coords[i][0] * coords[i + 1][1] + coords[i + 1][0] * coords[i + 2][1] + coords[i + 2][0] * coords[i][1]) -\\n            (coords[i][1] * coords[i + 1][0] + coords[i + 1][1] * coords[i + 2][0] + coords[i + 2][1] * coords[i][0])\\n        ));\\n        \\n        if (area > 0) return false;\\n    }\\n    \\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkStraightLine = function(coords) {\\n    const n = coords.length;\\n    \\n    for (let i = 0; i < n - 2; i++) {\\n        const area = Math.abs(1/2 * (\\n            (coords[i][0] * coords[i + 1][1] + coords[i + 1][0] * coords[i + 2][1] + coords[i + 2][0] * coords[i][1]) -\\n            (coords[i][1] * coords[i + 1][0] + coords[i + 1][1] * coords[i + 2][0] + coords[i + 2][1] * coords[i][0])\\n        ));\\n        \\n        if (area > 0) return false;\\n    }\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3599015,
                "title": "intutive-c-code-maths",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:O(n)\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:O(1)\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        int i,c=0;\\r\\n        float m;\\r\\n        if(coordinates.size()<3)\\r\\n        return 1;\\r\\n        if(coordinates[0][0]==coordinates[1][0])\\r\\n        m=10000.0;\\r\\n        else\\r\\n        m=float((coordinates[1][1]-coordinates[0][1]))/(coordinates[1][0]-coordinates[0][0]);\\r\\n\\r\\n\\r\\n        for(i=2;i<coordinates.size();i++){\\r\\n            float slope;\\r\\n            if(coordinates[i][0]==coordinates[i-1][0])\\r\\n             slope=10000.0;\\r\\n            else\\r\\n            slope=float((coordinates[i][1]-coordinates[i-1][1]))/(coordinates[i][0]-coordinates[i-1][0]);\\r\\n            if(slope!=m)\\r\\n            return 0;\\r\\n\\r\\n        }\\r\\n        return 1;\\r\\n        \\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        int i,c=0;\\r\\n        float m;\\r\\n        if(coordinates.size()<3)\\r\\n        return 1;\\r\\n        if(coordinates[0][0]==coordinates[1][0])\\r\\n        m=10000.0;\\r\\n        else\\r\\n        m=float((coordinates[1][1]-coordinates[0][1]))/(coordinates[1][0]-coordinates[0][0]);\\r\\n\\r\\n\\r\\n        for(i=2;i<coordinates.size();i++){\\r\\n            float slope;\\r\\n            if(coordinates[i][0]==coordinates[i-1][0])\\r\\n             slope=10000.0;\\r\\n            else\\r\\n            slope=float((coordinates[i][1]-coordinates[i-1][1]))/(coordinates[i][0]-coordinates[i-1][0]);\\r\\n            if(slope!=m)\\r\\n            return 0;\\r\\n\\r\\n        }\\r\\n        return 1;\\r\\n        \\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598948,
                "title": "c-easy-solution-math-beats-99-52",
                "content": "# Intuition\\r\\nIt is just a Math problem related to slope.\\r\\n\\r\\n# Approach\\r\\nIf the slope of every two adjacent elements are same, they will lie on the same line.\\r\\n\\r\\nThere is an edge case when the difference of x coordinates is 0 the slope will be undefined so in that case make slope as INT_MAX.\\r\\n\\r\\nFirst let us calculate the slope of first two points and continue calculating the next adjacent points. If the slope is same continue else break.\\r\\n\\r\\nAt last if it encounters all the points, the points lie in the same line return true else return false.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\nO(N)\\r\\n\\r\\n- Space complexity:\\r\\nO(1)\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        int n = coordinates.size();\\r\\n        int i = 1;\\r\\n        double x = coordinates[1][0] - coordinates[0][0];\\r\\n        double y = coordinates[1][1] - coordinates[0][1];\\r\\n        double slope = INT_MAX;\\r\\n        if(x){\\r\\n            slope = y/x;\\r\\n        }\\r\\n        while(i<n){\\r\\n            x = coordinates[i][0] - coordinates[i-1][0];\\r\\n            y = coordinates[i][1] - coordinates[i-1][1];\\r\\n            double temp = INT_MAX;\\r\\n            if(x){\\r\\n                temp = y/x;\\r\\n            }\\r\\n            if(temp != slope){\\r\\n                break;\\r\\n            }\\r\\n            i++;\\r\\n        }\\r\\n        if(i!=n){\\r\\n            return 0;\\r\\n        }\\r\\n        return 1;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        int n = coordinates.size();\\r\\n        int i = 1;\\r\\n        double x = coordinates[1][0] - coordinates[0][0];\\r\\n        double y = coordinates[1][1] - coordinates[0][1];\\r\\n        double slope = INT_MAX;\\r\\n        if(x){\\r\\n            slope = y/x;\\r\\n        }\\r\\n        while(i<n){\\r\\n            x = coordinates[i][0] - coordinates[i-1][0];\\r\\n            y = coordinates[i][1] - coordinates[i-1][1];\\r\\n            double temp = INT_MAX;\\r\\n            if(x){\\r\\n                temp = y/x;\\r\\n            }\\r\\n            if(temp != slope){\\r\\n                break;\\r\\n            }\\r\\n            i++;\\r\\n        }\\r\\n        if(i!=n){\\r\\n            return 0;\\r\\n        }\\r\\n        return 1;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247752,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        x1, y1 = coordinates[0]\\n        x2, y2 = coordinates[1]\\n        for x, y in coordinates[2:]:\\n            if (y2 - y1) * (x - x1) != (x2 - x1) * (y - y1):\\n                return False\\n        return True\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        x1, y1 = coordinates[0]\\n        x2, y2 = coordinates[1]\\n        for x, y in coordinates[2:]:\\n            if (y2 - y1) * (x - x1) != (x2 - x1) * (y - y1):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820825,
                "title": "c-simple-and-clear-solution",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        if (coordinates.size() <= 2) // two points are always on a straight line\\n            return true;\\n        \\n        // find gradient\\n        float x = (coordinates[0][0] - coordinates[1][0]);\\n        float y = (coordinates[0][1] - coordinates[1][1]);\\n        \\n        for (int i=2; i<coordinates.size(); i++)\\n        {\\n            if (x == 0)\\n                if ((coordinates[i][0] - coordinates[i-1][0]) != 0)\\n                    return false;\\n            \\n            if (y == 0)\\n                if ((coordinates[i][1] - coordinates[i-1][1]) != 0)\\n                    return false;\\n            \\n            float g = y*1.0 / x;\\n            if ((x != 0) && (y!=0))\\n                if (((coordinates[i][1] - coordinates[i-1][1])*1.0 / (coordinates[i][0] - coordinates[i-1][0])*1.0) != g)\\n                    return false;  \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        if (coordinates.size() <= 2) // two points are always on a straight line\\n            return true;\\n        \\n        // find gradient\\n        float x = (coordinates[0][0] - coordinates[1][0]);\\n        float y = (coordinates[0][1] - coordinates[1][1]);\\n        \\n        for (int i=2; i<coordinates.size(); i++)\\n        {\\n            if (x == 0)\\n                if ((coordinates[i][0] - coordinates[i-1][0]) != 0)\\n                    return false;\\n            \\n            if (y == 0)\\n                if ((coordinates[i][1] - coordinates[i-1][1]) != 0)\\n                    return false;\\n            \\n            float g = y*1.0 / x;\\n            if ((x != 0) && (y!=0))\\n                if (((coordinates[i][1] - coordinates[i-1][1])*1.0 / (coordinates[i][0] - coordinates[i-1][0])*1.0) != g)\\n                    return false;  \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599691,
                "title": "python-elegant-short-3-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        x0, y0 = coordinates.pop()\\n        x1, y1 = coordinates.pop()\\n        return all((x1 - x0) * (y - y1) == (x - x1) * (y1 - y0) for x, y in coordinates)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Geometry"
                ],
                "code": "```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        x0, y0 = coordinates.pop()\\n        x1, y1 = coordinates.pop()\\n        return all((x1 - x0) * (y - y1) == (x - x1) * (y1 - y0) for x, y in coordinates)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598682,
                "title": "collinearity-determination-of-zero-python-js-solution",
                "content": "Hello **Tenno Leetcoders**, \\r\\n\\r\\nFor this problem, we are given an array coordinates, `coordinates[i] = [x, y]`, where `[x, y]` represents the coordinate of a point. Check if these points make a straight line in the `XY` plane.\\r\\n\\r\\n### Explanation \\r\\n\\r\\nThis problem, ask use to check if points on the like create a straight line. To help us, we can use a modified `slope formula` denoted as `(y2 - y1) * (x - x1) - (y - y1) * (x2 - x1)` to help us check the points on the line.\\r\\n\\r\\nWe first check if the number of coordinates is less than or equal to `2` as any two points on the line will always lie on a straight line so we return `true/True`\\r\\n\\r\\nCreate a helper function called `calculate_slope` to help us determine if points are `collinear` of our `2x2` matrix form by the coordinates of `(x1, y1)` and `(x2, y2)` with `x` and `y` using the concept of `cross product` to help determine `collinearity`. IFF the points lie one the same straight line, the determinant will be `0` \\r\\n\\r\\nThe cross production calculation denoted as `(y2 - y1) * (x - x1) - (y - y1) * (x2 - x1)`, represents the signed area of the parallelogram formed by the vectors from `(x1, y1)` to `(x2, y2)` and from `(x1, y1)` to `(x, y)`. The sign of the determinant determines the orientation of the points. \\r\\n\\r\\nOnce the determinant is `0`, this means the points are `collinear`, which will lie on a straight line. \\r\\n\\r\\nIf determinant is a `non-zero`, this means the points are `not collinear`\\r\\n\\r\\n  \\r\\nNow, we can calculate the initial slope between the first two points:\\r\\n\\r\\n    - Assign the first set of coordinates to x1, y1\\r\\n    \\r\\n    - Assign the second set of coordinates to x2, y2\\r\\n    \\r\\n    \\r\\nSince we initialized the first two points, we will traverse starting from the third set of the coordinate until the final coordinate. For each iteration, assign the current set of coordinates to `(x, y)`. We then calculate the slope using `calculateSlope`, checking if it equals to `0`.\\r\\n\\r\\nIf slope does not equal to `0` for any set of three consecutive points, it indicates that the points do not lie on the same straight line. so we return `false / False` else it will be `true/True`\\r\\n\\r\\n\\r\\n# Code\\r\\n\\r\\n**Python**\\r\\n\\r\\n```\\r\\nclass Solution:\\r\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\r\\n        coord_len = len(coordinates) \\r\\n\\r\\n        if coord_len <= 2:\\r\\n            return True\\r\\n\\r\\n        def calculate_slope(x1, y1, x2, y2, x, y):\\r\\n            return (y2 - y1) * (x - x1) - (y - y1) * (x2 - x1)\\r\\n\\r\\n\\r\\n        x1, y1 = coordinates[0]\\r\\n        x2, y2 = coordinates[1]\\r\\n\\r\\n        for i in range(2, coord_len):\\r\\n            x, y = coordinates[i]\\r\\n\\r\\n            if calculate_slope(x1, y1, x2, y2, x, y) != 0:\\r\\n                return False\\r\\n\\r\\n        return True\\r\\n```\\r\\n\\r\\n**JavaScript**\\r\\n```\\r\\n/**\\r\\n * @param {number[][]} coordinates\\r\\n * @return {boolean}\\r\\n */\\r\\nvar checkStraightLine = function(coordinates) {\\r\\n    coordLen = coordinates.length\\r\\n\\r\\n    if(coordLen <= 2) return true\\r\\n\\r\\n    function calculateSlope(x1, y1, x2, y2, x, y) {\\r\\n    return (y2 - y1) * (x - x1) - (y - y1) * (x2 - x1);\\r\\n  }\\r\\n\\r\\n    let [x1, y1] = coordinates[0]\\r\\n    let [x2, y2] = coordinates[1]\\r\\n\\r\\n   for (let i = 2; i < coordinates.length; i++) {\\r\\n    let [x, y] = coordinates[i];\\r\\n    if (calculateSlope(x1, y1, x2, y2, x, y) !== 0) {\\r\\n      return false;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return true;\\r\\n};\\r\\n```\\r\\n\\r\\n### Time Complexity: O(n)\\r\\n### Space Complexity: O(n)\\r\\n\\r\\n \\r\\n***Warframe\\'s Darvo wants you to upvote this post  \\uD83D\\uDE4F\\uD83C\\uDFFB \\u2764\\uFE0F\\u200D\\uD83D\\uDD25***\\r\\n![image](https://assets.leetcode.com/users/images/814f5668-c966-46d7-ba42-e5435c4c1761_1675302761.3081913.gif)",
                "solutionTags": [
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\r\\n        coord_len = len(coordinates) \\r\\n\\r\\n        if coord_len <= 2:\\r\\n            return True\\r\\n\\r\\n        def calculate_slope(x1, y1, x2, y2, x, y):\\r\\n            return (y2 - y1) * (x - x1) - (y - y1) * (x2 - x1)\\r\\n\\r\\n\\r\\n        x1, y1 = coordinates[0]\\r\\n        x2, y2 = coordinates[1]\\r\\n\\r\\n        for i in range(2, coord_len):\\r\\n            x, y = coordinates[i]\\r\\n\\r\\n            if calculate_slope(x1, y1, x2, y2, x, y) != 0:\\r\\n                return False\\r\\n\\r\\n        return True\\r\\n```\n```\\r\\n/**\\r\\n * @param {number[][]} coordinates\\r\\n * @return {boolean}\\r\\n */\\r\\nvar checkStraightLine = function(coordinates) {\\r\\n    coordLen = coordinates.length\\r\\n\\r\\n    if(coordLen <= 2) return true\\r\\n\\r\\n    function calculateSlope(x1, y1, x2, y2, x, y) {\\r\\n    return (y2 - y1) * (x - x1) - (y - y1) * (x2 - x1);\\r\\n  }\\r\\n\\r\\n    let [x1, y1] = coordinates[0]\\r\\n    let [x2, y2] = coordinates[1]\\r\\n\\r\\n   for (let i = 2; i < coordinates.length; i++) {\\r\\n    let [x, y] = coordinates[i];\\r\\n    if (calculateSlope(x1, y1, x2, y2, x, y) !== 0) {\\r\\n      return false;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  return true;\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425136,
                "title": "rust-solution-with-windows",
                "content": "```\\nimpl Solution {\\n    pub fn check_straight_line(coordinates: Vec<Vec<i32>>) -> bool {\\n        if coordinates.len() == 2 {\\n            return true;\\n        }\\n\\n        // check k1 == k2 for 3 points => (y2 - y1) / (x2 - x1) == (y1 - y0) / (x1 - x0)\\n        // transform to mul => (y2 - y1) * (x1 - x0) == (x2 - x1) * (y1 - y0)\\n        coordinates.windows(3).all(|points| {\\n            let (p2, p1, p0) = (&points[2], &points[1], &points[0]);\\n            (p2[1] - p1[1]) * (p1[0] - p0[0]) == (p2[0] - p1[0]) * (p1[1] - p0[1])\\n        })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn check_straight_line(coordinates: Vec<Vec<i32>>) -> bool {\\n        if coordinates.len() == 2 {\\n            return true;\\n        }\\n\\n        // check k1 == k2 for 3 points => (y2 - y1) / (x2 - x1) == (y1 - y0) / (x1 - x0)\\n        // transform to mul => (y2 - y1) * (x1 - x0) == (x2 - x1) * (y1 - y0)\\n        coordinates.windows(3).all(|points| {\\n            let (p2, p1, p0) = (&points[2], &points[1], &points[0]);\\n            (p2[1] - p1[1]) * (p1[0] - p0[0]) == (p2[0] - p1[0]) * (p1[1] - p0[1])\\n        })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1218469,
                "title": "c-simple-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool checkStraightLine(vector<vector<int>>& coordinates) {\\n\\t\\t\\tif(coordinates.size() <= 2){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tint x1 = coordinates[0][0];\\n\\t\\t\\tint y1 = coordinates[0][1];\\n\\t\\t\\tint x2 = coordinates[1][0];\\n\\t\\t\\tint y2 = coordinates[1][1];\\n\\t\\t\\tfor(int i = 2; i < coordinates.size(); i++){\\n\\t\\t\\t\\tint x3 = coordinates[i][0];\\n\\t\\t\\t\\tint y3 = coordinates[i][1];\\n\\t\\t\\t\\t// If area of triangle formed by three points is not zero then points are not collinear\\n\\t\\t\\t\\tif(y1*(x3 - x2) + y2*(x1 - x3) + y3*(x2 - x1) != 0){   \\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;        \\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool checkStraightLine(vector<vector<int>>& coordinates) {\\n\\t\\t\\tif(coordinates.size() <= 2){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 475538,
                "title": "c-96-ms",
                "content": "\\tpublic class Solution\\n    {\\n        public bool CheckStraightLine(int[][] coordinates)\\n        {\\n            if (coordinates.Length < 3)\\n            {\\n                return true;\\n            }\\n            long dx1 = coordinates[1][0] - coordinates[0][0];\\n            long dy1 = coordinates[1][1] - coordinates[0][1];\\n\\n            for (int i = 2; i < coordinates.Length; i++)\\n            {\\n                long dx2 = coordinates[i][0] - coordinates[0][0];\\n                long dy2 = coordinates[i][1] - coordinates[0][1];\\n                // dx2 / dy2 = dx1 / dy1 =>\\n                // dx2 * dy1 = dx1 * dy2\\n                if (dx2 * dy1 != dx1 * dy2)\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            return true;\\n        }\\n    }\\n",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n        public bool CheckStraightLine(int[][] coordinates)\\n        {\\n            if (coordinates.Length < 3)\\n            {\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 443821,
                "title": "python3-in-1-line",
                "content": "# Three lines, efficient\\n\\n```python\\nfrom itertools import islice\\n\\nclass Solution:\\n  def checkStraightLine(self, coords: List[List[int]]) -> bool:\\n    (x1, y1), (x2, y2) = coords[:2]\\n    dx, dy = x2 - x1, y2 - y1\\n    return all(dy * (x - x1) == dx * (y - y1) for x, y in islice(coords, 2, None))\\n```\\n\\n# Two lines, clean and simple\\n\\n```python\\nclass Solution:\\n  def checkStraightLine(self, coords: List[List[int]]) -> bool:\\n    (x1, y1), (x2, y2) = coords[:2]\\n    return all((y2 - y1) * (x - x1) == (y - y1) * (x2 - x1) for x, y in coords[2:])\\n```\\n\\n# One line, squished\\n\\n```python\\nclass Solution:\\n  def checkStraightLine(self, coords: List[List[int]]) -> bool:\\n    return all((coords[1][1] - coords[0][1]) * (x - coords[0][0]) == (y - coords[0][1]) * (coords[1][0] - coords[0][0]) for x, y in coords[2:])\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nfrom itertools import islice\\n\\nclass Solution:\\n  def checkStraightLine(self, coords: List[List[int]]) -> bool:\\n    (x1, y1), (x2, y2) = coords[:2]\\n    dx, dy = x2 - x1, y2 - y1\\n    return all(dy * (x - x1) == dx * (y - y1) for x, y in islice(coords, 2, None))\\n```\n```python\\nclass Solution:\\n  def checkStraightLine(self, coords: List[List[int]]) -> bool:\\n    (x1, y1), (x2, y2) = coords[:2]\\n    return all((y2 - y1) * (x - x1) == (y - y1) * (x2 - x1) for x, y in coords[2:])\\n```\n```python\\nclass Solution:\\n  def checkStraightLine(self, coords: List[List[int]]) -> bool:\\n    return all((coords[1][1] - coords[0][1]) * (x - coords[0][0]) == (y - coords[0][1]) * (coords[1][0] - coords[0][0]) for x, y in coords[2:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600375,
                "title": "c-only-integer-operations-w-intuition-code-0ms-o-1-space-explained-with-derivation",
                "content": "# Intuition\\nThink of the equation of a line.\\n$$y = mx + c$$\\n\\n$$\\n(x_1, y_1) \\\\rightarrow coordinates \\\\space of \\\\space point 1\\n\\\\newline\\n(x_2, y_2) \\\\rightarrow coordinates \\\\space of \\\\space point 2\\n$$\\n\\nOur variables:\\n$$\\nyd = y_2 - y_1\\n\\\\newline\\nxd = x_2 - x_1\\n\\\\newline\\nm = \\\\dfrac{yd}{xd}\\n\\\\newline\\nc = y_1 - m*x_1\\n$$\\n\\nWe can find the equation of line using the first two coordinates and since there are at least two point in `coordinates` we don\\'t need to add any checks.\\nNow, we have the equation of line, we just need to check if all the points of coordinates lie in the coordinate.\\n\\nNow, we know that we need to use floating-point number to represent the slope and need to perform floating-point operations on all of the point to check if they fit the equation. \\nBut there\\'s a problem that if `xd==0` then we need to perform the checks differently. In this case we need to check if all points have the same $$x$$ throughout.\\n\\nNow, I\\'d like to approach the problem a bit differently. What we need to do remains the same, we need to check if the point fits the equation but now we\\'ll change the equation a bit.\\n\\n$$\\n=> y = mx + c\\n\\\\newline\\n=> y = \\\\dfrac{yd}{xd}*x + c\\n\\\\newline\\n=> xd*y = yd*x + c*xd\\n$$\\nThis is what we end up with. As you can see, we can create a boolean statement with this and just pop in the values.\\nWe already have `xd` and `yd`.\\n`x` and `y` are the coordinates of the current point.\\nWe also need $$c*xd = xd*y_1 - yd*x_1$$\\\\* (IMP)\\n\\nOur Equation: $$xd*y == yd*x + c*xd$$\\\\* (IMP)\\n\\n# Approach\\nOnce you get the understanding of the above intuition. The solution is just following the step.\\n1. Calculate $$xd = C_{2x} - C_{1x}$$.\\n2. Calculate $$yd = C_{2y} - C_{1y}$$.\\n3. Calculate $$interceptD = c*xd$$ or $$interceptD = xd*y_1 - yd*x_1$$\\n4. Now for every coodinate check if $$xd*y_i == yd*x_i + interceptD$$\\n5. If the condition doesn\\'t hold for any of the equation `return false` else `return true`.\\n\\n![image.png](https://assets.leetcode.com/users/images/f6e7a4ad-349d-4385-8f2f-c2665f9ba261_1685960987.490674.png)\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int xd = coordinates[1][0]-coordinates[0][0];\\n        int yd = coordinates[1][1]-coordinates[0][1];\\n        int interceptD = coordinates[0][1]*xd - yd*coordinates[0][0];\\n        for(auto& c: coordinates) {\\n            if (xd*c[1] != yd*c[0] + interceptD)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\nSince we\\'re only traversing all the coordinates once.\\n\\n- Space complexity: $$O(1)$$\\nWe only use three variables extra variables\\uD83D\\uDE09.\\n\\n\\n> ### Note\\n> - Upvote if you liked my solution\\n> - Drop a comment if you have any doubt\\n> - Sorry for the weird naming of `c*xd`. \\uD83D\\uDE05\\uD83D\\uDE02\\n",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int xd = coordinates[1][0]-coordinates[0][0];\\n        int yd = coordinates[1][1]-coordinates[0][1];\\n        int interceptD = coordinates[0][1]*xd - yd*coordinates[0][0];\\n        for(auto& c: coordinates) {\\n            if (xd*c[1] != yd*c[0] + interceptD)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598838,
                "title": "python-solution-for-noobs",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIts very simple, we check that condition for points to be in a straight is to have same slope i.e **dy/dx or y2-y1/x2-x1**\\n\\nSo we can obviously get started with calculating the slope from first two coordinates array namely x0,y0 and x1,y1. \\n\\nBut slow down, lets see what if points lies on **x-axis(x,0)** or **y-axis(0,y)** or if all coordinates are on **origin(0,0)** then we will surely get divided by zero error. So what should we do ?\\n\\nFor this lets consider coordinates of three points (x0,y0), (x1,y1) and (i,j). Now if calculate the slope for these coordinates then it would be\\n**slope = (y1-y0)/(x1-x0) \\nAnd slope = (j-y0)/(i-x0)**\\n\\nFrom this we can say that (y1-y0)/(x1-x0) = (j-y0)/(i-x0)\\nsimilary we can say that\\n**(y1-y0)*(i-x0) = (j-y0)*(x1-x0)**\\nAnd this is true for all coordinates which lie on a stright line. Now the only thing left is to loop this condition to check across all the coordinates.\\n\\nAlso I have checked that if there are less than 2 elements in coordinates array then assume they are on straight line.\\n\\n# Complexity\\n- Time complexity: O(n) loop acroos the coordinates\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) because constant space is required for coordinates\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def checkStraightLine(self, coordinates):\\n        \"\"\"\\n        :type coordinates: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        if len(coordinates)<3:\\n            return True\\n        \\n        (x0,y0),(x1,y1)=coordinates[:2]\\n\\n        for i,j in coordinates:\\n            if (y1-y0)*(i-x0)!=(j-y0)*(x1-x0):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution(object):\\n    def checkStraightLine(self, coordinates):\\n        \"\"\"\\n        :type coordinates: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        if len(coordinates)<3:\\n            return True\\n        \\n        (x0,y0),(x1,y1)=coordinates[:2]\\n\\n        for i,j in coordinates:\\n            if (y1-y0)*(i-x0)!=(j-y0)*(x1-x0):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598758,
                "title": "check-if-it-is-a-straight-line-optimized-solution-daily-leetcode-challenge",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        // If the number of coordinates is less than 2, it cannot form a straight line\\n        if (coordinates.size() < 2) {\\n            return false;\\n        }\\n        \\n        // Calculate the slope between the first two points\\n        int x1 = coordinates[0][0];\\n        int y1 = coordinates[0][1];\\n        int x2 = coordinates[1][0];\\n        int y2 = coordinates[1][1];\\n        int dx = x2 - x1;\\n        int dy = y2 - y1;\\n        \\n        // Check the slope between the remaining points\\n        for (int i = 2; i < coordinates.size(); i++) {\\n            int xi = coordinates[i][0];\\n            int yi = coordinates[i][1];\\n            \\n            // If the slope between any two points is different, it\\'s not a straight line\\n            if (dx * (yi - y1) != dy * (xi - x1)) {\\n                return false;\\n            }\\n        }\\n        \\n        // All slopes are equal, so it\\'s a straight line\\n        return true;\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE :)**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        // If the number of coordinates is less than 2, it cannot form a straight line\\n        if (coordinates.size() < 2) {\\n            return false;\\n        }\\n        \\n        // Calculate the slope between the first two points\\n        int x1 = coordinates[0][0];\\n        int y1 = coordinates[0][1];\\n        int x2 = coordinates[1][0];\\n        int y2 = coordinates[1][1];\\n        int dx = x2 - x1;\\n        int dy = y2 - y1;\\n        \\n        // Check the slope between the remaining points\\n        for (int i = 2; i < coordinates.size(); i++) {\\n            int xi = coordinates[i][0];\\n            int yi = coordinates[i][1];\\n            \\n            // If the slope between any two points is different, it\\'s not a straight line\\n            if (dx * (yi - y1) != dy * (xi - x1)) {\\n                return false;\\n            }\\n        }\\n        \\n        // All slopes are equal, so it\\'s a straight line\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361980,
                "title": "two-point-slope-in-java-and-python-solution",
                "content": "\\n\\n# 1. Use the Two Point Slope Formula in Java\\n```\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        int x1,y1,x2,y2;\\n        x1=coordinates[0][0];\\n        y1=coordinates[0][1];\\n        x2=coordinates[1][0];\\n        y2=coordinates[1][1];\\n        for(int i=2;i<coordinates.length;i++){\\n            if (((coordinates[i][1]-y1)*(x2-x1))!=((y2-y1)*(coordinates[i][0]-x1))){\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```\\n# 2. Same Two Point Slope Formula in Python\\n```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        x1,y1=coordinates[0][0],coordinates[0][1]\\n        x2,y2=coordinates[1][0],coordinates[1][1]\\n        for x3,y3 in coordinates[2:]:\\n            if (y3-y1)*(x2-x1)!=(x3-x1)*(y2-y1):\\n                return False\\n        else:\\n            return True\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        int x1,y1,x2,y2;\\n        x1=coordinates[0][0];\\n        y1=coordinates[0][1];\\n        x2=coordinates[1][0];\\n        y2=coordinates[1][1];\\n        for(int i=2;i<coordinates.length;i++){\\n            if (((coordinates[i][1]-y1)*(x2-x1))!=((y2-y1)*(coordinates[i][0]-x1))){\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        x1,y1=coordinates[0][0],coordinates[0][1]\\n        x2,y2=coordinates[1][0],coordinates[1][1]\\n        for x3,y3 in coordinates[2:]:\\n            if (y3-y1)*(x2-x1)!=(x3-x1)*(y2-y1):\\n                return False\\n        else:\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666349,
                "title": "optimal-93-acceptance-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& arr) {\\n        int n = arr.size();\\n        long double d;\\n        int flag = 0;\\n        if(arr[1][0] - arr[0][0] != 0) d = ((double)arr[1][1] - (double)arr[0][1]) / ((double)arr[1][0] - (double)arr[0][0]);\\n        else flag = 1;\\n        for(int i = 1;i<n;i++){\\n            if(flag == 1){\\n                if(((double)arr[i][0] - (double)arr[i-1][0]) != 0){\\n                     return false;\\n                }\\n            }\\n            else{\\n                if(((double)arr[i][0] - (double)arr[i-1][0]) == 0){\\n                    return false;\\n                }\\n                else{\\n                    if(((double)arr[i][1] - (double)arr[i-1][1]) / ((double)arr[i][0] - (double)arr[i-1][0]) != d){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& arr) {\\n        int n = arr.size();\\n        long double d;\\n        int flag = 0;\\n        if(arr[1][0] - arr[0][0] != 0) d = ((double)arr[1][1] - (double)arr[0][1]) / ((double)arr[1][0] - (double)arr[0][0]);\\n        else flag = 1;\\n        for(int i = 1;i<n;i++){\\n            if(flag == 1){\\n                if(((double)arr[i][0] - (double)arr[i-1][0]) != 0){\\n                     return false;\\n                }\\n            }\\n            else{\\n                if(((double)arr[i][0] - (double)arr[i-1][0]) == 0){\\n                    return false;\\n                }\\n                else{\\n                    if(((double)arr[i][1] - (double)arr[i-1][1]) / ((double)arr[i][0] - (double)arr[i-1][0]) != d){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2312395,
                "title": "java-math-solution-with-explanation-beats-100",
                "content": "equation of a line is **y = a*x + b**\\n1. let\\'s take 2 first points and find a and b or equation of line which contains these two points:\\ny1=a*x1+b and at the same time y2=a*x2+b. Then:\\n\\n**y2-y1 = a * x2 + b - a*x1 - b**\\ny2-y1 = a * (x2-x1) \\nb = y1 - a * x1\\n\\nhere we might have a particular case like x=a. for them we\\'ll just check that each coordinate has the same x=a.\\n\\n\\n```\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        if (coordinates.length<=2)return true;\\n        \\n        double a = coordinates[1][0]==coordinates[0][0]?\\n\\t\\t                                     coordinates[0][0]:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t ((double)(coordinates[1][1]-coordinates[0][1]))/(coordinates[1][0]-coordinates[0][0]);\\n        double b = coordinates[0][1] - coordinates[0][0]*a;\\n        \\n        boolean xEqN = (a==coordinates[0][0] && a==coordinates[1][0]);\\n        \\n        for (int[] coordinate: coordinates){\\n            if ((xEqN && a!=coordinate[0]) || (!xEqN && coordinate[1]!=coordinate[0]*a+b)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        if (coordinates.length<=2)return true;\\n        \\n        double a = coordinates[1][0]==coordinates[0][0]?\\n\\t\\t                                     coordinates[0][0]:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t ((double)(coordinates[1][1]-coordinates[0][1]))/(coordinates[1][0]-coordinates[0][0]);\\n        double b = coordinates[0][1] - coordinates[0][0]*a;\\n        \\n        boolean xEqN = (a==coordinates[0][0] && a==coordinates[1][0]);\\n        \\n        for (int[] coordinate: coordinates){\\n            if ((xEqN && a!=coordinate[0]) || (!xEqN && coordinate[1]!=coordinate[0]*a+b)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866791,
                "title": "java-simple-code-with-explanation-100-fast-o-1-space",
                "content": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Check If It Is a Straight Line. \\nMemory Usage: 43.2 MB, less than 74.92% of Java online submissions for Check If It Is a Straight Line.\\n```\\nclass Solution {\\n    \\n    \\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n        for (int i=2;i<coordinates.length;i++){\\n            if (!isStraightLine(coordinates[i],coordinates[0],coordinates[1]))  return false;\\n        }\\n        return true;\\n    }\\n    \\n    public boolean isStraightLine(int[]p1,int[]p2,int[]p3) {\\n        int x=p1[0],y=p1[1];\\n        int x1=p2[0],y1=p2[1];\\n        int x2=p3[0],y2=p3[1];\\n        return ((y-y1)*(x2-x1)) ==  ((x-x1)*(y2-y1));\\n    }\\n}\\n```\\n\\nThe point is if we take points p1(x, y), p2(x1, y1), p3(x3, y3), slopes of any two pairs is same then p1, p2, p3 lies on same line.\\nslope from p1 and p2 is y - y1 / x - x1\\nslope from p2 and p3 is y2 - y1 / x2 - x1\\nif these two slopes equal, then p1, p2, p3 lies on same line.\\n![image](https://assets.leetcode.com/users/images/09c1d717-9a8b-45ed-9795-1efda0995fe2_1647769700.8927312.png)\\n\\n**If you have any doubts, feel free to ask\\nIf you understand, don\\'t forget to upvote !**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    \\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n        for (int i=2;i<coordinates.length;i++){\\n            if (!isStraightLine(coordinates[i],coordinates[0],coordinates[1]))  return false;\\n        }\\n        return true;\\n    }\\n    \\n    public boolean isStraightLine(int[]p1,int[]p2,int[]p3) {\\n        int x=p1[0],y=p1[1];\\n        int x1=p2[0],y1=p2[1];\\n        int x2=p3[0],y2=p3[1];\\n        return ((y-y1)*(x2-x1)) ==  ((x-x1)*(y2-y1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864519,
                "title": "python-easy-simple",
                "content": "```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        x0,y0=coordinates[0]\\n        x1,y1=coordinates[1]\\n        for x,y in coordinates:\\n            if (x-x1)*(y1-y0)!=(y-y1)*(x1-x0):\\n                return 0\\n        return 1\\n        \\n**vote up**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        x0,y0=coordinates[0]\\n        x1,y1=coordinates[1]\\n        for x,y in coordinates:\\n            if (x-x1)*(y1-y0)!=(y-y1)*(x1-x0):\\n                return 0\\n        return 1\\n        \\n**vote up**",
                "codeTag": "Java"
            },
            {
                "id": 1086134,
                "title": "java-find-slope-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        int x1 = coordinates[0][0], y1 = coordinates[0][1];\\n        int x2 = coordinates[1][0], y2 = coordinates[1][1];\\n        \\n        for (int i = 2; i < coordinates.length; i++) {\\n            int x3 = coordinates[i][0], y3 = coordinates[i][1];\\n            if((y2 - y1)*(x3 - x1) != (x2 - x1)*(y3 - y1)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        int x1 = coordinates[0][0], y1 = coordinates[0][1];\\n        int x2 = coordinates[1][0], y2 = coordinates[1][1];\\n        \\n        for (int i = 2; i < coordinates.length; i++) {\\n            int x3 = coordinates[i][0], y3 = coordinates[i][1];\\n            if((y2 - y1)*(x3 - x1) != (x2 - x1)*(y3 - y1)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826345,
                "title": "c-98-faster-math",
                "content": "Runtime: 4 ms, faster than 98.41% of C++ online submissions for Check If It Is a Straight Line.\\nMemory Usage: 10 MB, less than 74.97% of C++ online submissions for Check If It Is a Straight Line.\\n\\n**equation of line** (x - x1) * (y2 - y1) = (y - y1) * (x2 - x1)\\n```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int size = coordinates.size();\\n        int x1 = coordinates[0][0],y1 = coordinates[0][1];\\n        int x2 = coordinates[size-1][0],y2 = coordinates[size-1][1];\\n        int dx = x2-x1;\\n        int dy = y2-y1;\\n        for (int i = 0;i<size;i++){\\n            int ddx = coordinates[i][0] - coordinates[0][0];\\n            int ddy = coordinates[i][1] - coordinates[0][1];\\n            if(ddx*dy != ddy*dx) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int size = coordinates.size();\\n        int x1 = coordinates[0][0],y1 = coordinates[0][1];\\n        int x2 = coordinates[size-1][0],y2 = coordinates[size-1][1];\\n        int dx = x2-x1;\\n        int dy = y2-y1;\\n        for (int i = 0;i<size;i++){\\n            int ddx = coordinates[i][0] - coordinates[0][0];\\n            int ddy = coordinates[i][1] - coordinates[0][1];\\n            if(ddx*dy != ddy*dx) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602225,
                "title": "nice-zero-division-question-beat-99-52",
                "content": "Trivial question but the zero division was sth out of the blue. the 40% acceptance rate deserved and I think it deserves a medium tag.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);  // speed\\n        int dy, dx;\\n        dy = (coordinates[1][1]-coordinates[0][1]), dx = (coordinates[1][0]-coordinates[0][0]); // initial slope, all upcoming slopes should equal\\n        for (int i(2); i < (int)coordinates.size(); ++i)\\n        {\\n            int dy2 ((coordinates[i][1]-coordinates[i-1][1])), dx2((coordinates[i][0]-coordinates[i-1][0]));\\n            if ((dy * dx2) ^ (dx * dy2)) return 0; // Multiply to avoid zero division in the regular slope formula\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);  // speed\\n        int dy, dx;\\n        dy = (coordinates[1][1]-coordinates[0][1]), dx = (coordinates[1][0]-coordinates[0][0]); // initial slope, all upcoming slopes should equal\\n        for (int i(2); i < (int)coordinates.size(); ++i)\\n        {\\n            int dy2 ((coordinates[i][1]-coordinates[i-1][1])), dx2((coordinates[i][0]-coordinates[i-1][0]));\\n            if ((dy * dx2) ^ (dx * dy2)) return 0; // Multiply to avoid zero division in the regular slope formula\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3601235,
                "title": "python-3-3-lines-int-arithmetic-t-m-100-54",
                "content": "```\\n    class Solution:\\n        def checkStraightLine(self, coor: list[list[int]]) -> bool:\\n         \\n            (x0,y0),(x1,y1) = coor[0],coor[1]\\n\\n            for x, y in coor:\\n                if (y1-y0)*(x-x0)-(y-y0)*(x1-x0): return False     # <-- cross product in plane\\n\\n            return True\\n```\\n[https://leetcode.com/problems/check-if-it-is-a-straight-line/submissions/588177539/](http://)\\n\\n    \\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1), in which *N* ~`len(coor)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    class Solution:\\n        def checkStraightLine(self, coor: list[list[int]]) -> bool:\\n         \\n            (x0,y0),(x1,y1) = coor[0],coor[1]\\n\\n            for x, y in coor:\\n                if (y1-y0)*(x-x0)-(y-y0)*(x1-x0): return False     # <-- cross product in plane\\n\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600148,
                "title": "most-optimized-most-simple-c",
                "content": "ist point (a,b)\\nsecond (c,d)\\nand ith (ei,fi) i = 2 ... n-1\\n\\nif(((a-ei)**(d-fi)) != ((c-ei)*(b-fi)))return false untill i < n\\nreturn true if (i==n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& v) {\\n        for(int i = 2; i < v.size(); i++){\\n            if(((v[i][0]-v[0][0])*(v[1][1]-v[i][1]))!=((v[i][1]-v[0][1])*(v[1][0]-v[i][0])))return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& v) {\\n        for(int i = 2; i < v.size(); i++){\\n            if(((v[i][0]-v[0][0])*(v[1][1]-v[i][1]))!=((v[i][1]-v[0][1])*(v[1][0]-v[i][0])))return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599087,
                "title": "easy-c-solution-basic-math-clean-code-o-n-time-o-1-space-equation-of-a-line",
                "content": "# Intuition\\r\\nMake the equation of line and check for each point.\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\nThe equation of a line if two points are given is given by:\\r\\ny-y1 = m * (x-x1),\\r\\nwhere x1,y1 are coordinates of a point and m is the slope of the line, m is given by:\\r\\n(y2-y1)/(x2-x1), where (x1,y1) and (x2,y2) are the coordinates of two points.\\r\\n\\r\\nBut before this lets consider the corner cases when slope evaluates to 0 or 1.\\r\\nIf m==0 then the line is parallel to x-axis so all the points should have same y coordinate.\\r\\nIf m==Infinity(when x2-x1==0) then the line is parallel to y-axis so all the points should have same x coordinate.\\r\\n\\r\\n\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: O(n)\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity: O(1)\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        int n=coordinates.size();\\r\\n        if(n==1) return true;\\r\\n        double x1=coordinates[0][0];\\r\\n        double y1=coordinates[0][1];\\r\\n        double x2=coordinates[1][0];\\r\\n        double y2=coordinates[1][1];\\r\\n        double m;\\r\\n        if(x2-x1==0){\\r\\n            double X=coordinates[0][0];\\r\\n            for(int i=0;i<n;i++){\\r\\n                if(coordinates[i][0]!=X) return false;\\r\\n            }\\r\\n            return true;\\r\\n        }\\r\\n        else if(y2-y1==0){\\r\\n            double Y=coordinates[0][1];\\r\\n            for(int i=0;i<n;i++){\\r\\n                if(coordinates[i][1]!=Y) return false;\\r\\n            }\\r\\n            return true;\\r\\n        }\\r\\n        m=(y2-y1)/(x2-x1);\\r\\n        for(int i=1;i<n;i++){\\r\\n            double y=(m*(coordinates[i][0]-x1))+y1;\\r\\n            if((double)coordinates[i][1]!=y) return false;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        int n=coordinates.size();\\r\\n        if(n==1) return true;\\r\\n        double x1=coordinates[0][0];\\r\\n        double y1=coordinates[0][1];\\r\\n        double x2=coordinates[1][0];\\r\\n        double y2=coordinates[1][1];\\r\\n        double m;\\r\\n        if(x2-x1==0){\\r\\n            double X=coordinates[0][0];\\r\\n            for(int i=0;i<n;i++){\\r\\n                if(coordinates[i][0]!=X) return false;\\r\\n            }\\r\\n            return true;\\r\\n        }\\r\\n        else if(y2-y1==0){\\r\\n            double Y=coordinates[0][1];\\r\\n            for(int i=0;i<n;i++){\\r\\n                if(coordinates[i][1]!=Y) return false;\\r\\n            }\\r\\n            return true;\\r\\n        }\\r\\n        m=(y2-y1)/(x2-x1);\\r\\n        for(int i=1;i<n;i++){\\r\\n            double y=(m*(coordinates[i][0]-x1))+y1;\\r\\n            if((double)coordinates[i][1]!=y) return false;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598814,
                "title": "easy-explained-geometry-with-clean-code-c",
                "content": "# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nFor checking if some points are in same straight line, just check the slope of these points, if all the slopes come same then they are definitely in a straight line.\\r\\nAll points in a straight line has the same slope with each other\\r\\n\\r\\n## **Formlua for slope(m) between two points:**\\r\\n![slope-formula.png](https://assets.leetcode.com/users/images/729ab94f-0c85-4954-82a9-d32d5bd1f875_1685932433.1479015.png)\\r\\n\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: O(n)\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity: O(1)\\r\\n- n = no. of points (coordinates.size())\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        // if only 2 points, then always straight line\\r\\n        if(coordinates.size()==2) return true;\\r\\n        \\r\\n        // if the points on x axis is an edge case handled here\\r\\n        if(coordinates[1][0]==0 && coordinates[0][0]==0){\\r\\n            for(int i=0;i<coordinates.size();i++){\\r\\n                if(coordinates[i][0]!=0) return false;\\r\\n            }\\r\\n            return true;\\r\\n        }\\r\\n\\r\\n        //calculate slope then check if all two points lie in same slope\\r\\n        double slope = (coordinates[1][1] - coordinates[0][1])/double(coordinates[1][0]-coordinates[0][0]);\\r\\n\\r\\n        for(int i=1;i<coordinates.size();i++){\\r\\n            double x=(coordinates[i][1] - coordinates[i-1][1])/double(coordinates[i][0]-coordinates[i-1][0]);\\r\\n            if(x!=slope) return false;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        // if only 2 points, then always straight line\\r\\n        if(coordinates.size()==2) return true;\\r\\n        \\r\\n        // if the points on x axis is an edge case handled here\\r\\n        if(coordinates[1][0]==0 && coordinates[0][0]==0){\\r\\n            for(int i=0;i<coordinates.size();i++){\\r\\n                if(coordinates[i][0]!=0) return false;\\r\\n            }\\r\\n            return true;\\r\\n        }\\r\\n\\r\\n        //calculate slope then check if all two points lie in same slope\\r\\n        double slope = (coordinates[1][1] - coordinates[0][1])/double(coordinates[1][0]-coordinates[0][0]);\\r\\n\\r\\n        for(int i=1;i<coordinates.size();i++){\\r\\n            double x=(coordinates[i][1] - coordinates[i-1][1])/double(coordinates[i][0]-coordinates[i-1][0]);\\r\\n            if(x!=slope) return false;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362738,
                "title": "find-the-slope-equate-to-all-the-coordinates-by-giving-condition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        for(int i=2;i<coordinates.length;i++){\\n            if((coordinates[1][1]-coordinates[0][1])*(coordinates[i][0]-coordinates[0][0])!=(coordinates[1][0]-coordinates[0][0])*(coordinates[i][1]-coordinates[0][1])){\\n    return false;\\n    }\\n    }\\n    return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        for(int i=2;i<coordinates.length;i++){\\n            if((coordinates[1][1]-coordinates[0][1])*(coordinates[i][0]-coordinates[0][0])!=(coordinates[1][0]-coordinates[0][0])*(coordinates[i][1]-coordinates[0][1])){\\n    return false;\\n    }\\n    }\\n    return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265233,
                "title": "easy-js-ts-solution",
                "content": "# Code\\n```\\nconst checkStraightLine = ([[x1, y1], [x2, y2], ...coordinates]) => {\\n    const dx = x2 - x1, dy = y2 - y1;\\n\\n    return coordinates.every(([x, y]) => (dx * (y - y1)) === (dy * (x - x1)));\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nconst checkStraightLine = ([[x1, y1], [x2, y2], ...coordinates]) => {\\n    const dx = x2 - x1, dy = y2 - y1;\\n\\n    return coordinates.every(([x, y]) => (dx * (y - y1)) === (dy * (x - x1)));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3048853,
                "title": "c-detailed-mathematical-explanation-o-n-time-o-1-space",
                "content": "# Approach\\r\\n- If there are **only 2 points**, then **return true**, since a line can be drawn through any 2 points.\\r\\n\\r\\n- The approach will be as follows. **We will draw a line from the first two points and check if the other points pass through it**.\\r\\n\\r\\n- If the **x coordinate for the first two points is the same**, then the **line will be parallel to the y-axis**. Therefore, it is enough to check that the x of all other points also coincide with the current one.\\r\\n\\r\\n- If the **y coordinate for the first two points is the same**, then the **line will be parallel to the x-axis**. Therefore, it is enough to check that the y of all other points also coincide with the current one.\\r\\n\\r\\n- If the **abscissas and ordinates for the first two points don\\'t coincide**, then **the line will need to be built in a different way**.\\r\\n\\r\\n**The equation of a straight line** has the form: $ y = k \\\\cdot x + b $.\\r\\n\\r\\nCompose a **system of equations for two points**:\\r\\n\\r\\n$\\r\\n\\\\begin{cases}\\r\\ny_1 = k \\\\cdot x_1 + b \\\\\\\\\\r\\ny_2 = k \\\\cdot x_2 + b \\r\\n\\\\end{cases}\\r\\n$\\r\\n\\r\\nThe **unknowns** are the coefficients **k** and **b**. Let\\'s **rewrite** the system in the following form:\\r\\n\\r\\n$\\r\\n\\\\begin{cases}\\r\\nk \\\\cdot x_1 + 1 \\\\cdot b = y_1 \\\\\\\\\\r\\nk \\\\cdot x_2 + 1 \\\\cdot b = y_2\\r\\n\\\\end{cases}\\r\\n$\\r\\n\\r\\nSystem in **matrix form**:\\r\\n\\r\\n$\\r\\n\\\\begin{pmatrix}\\r\\n    x_1 & 1\\\\\\\\ \\r\\n    x_2 & 1 \\r\\n\\\\end{pmatrix}\\r\\n\\\\times\\r\\n\\\\begin{pmatrix}\\r\\n    k\\\\\\\\ \\r\\n    b   \\r\\n\\\\end{pmatrix}\\r\\n=\\r\\n\\\\begin{pmatrix}\\r\\n    y_1\\\\\\\\ \\r\\n    y_2   \\r\\n\\\\end{pmatrix}\\r\\n$\\r\\n\\r\\nThis system, for example, can be solved by the **Cramer method**:\\r\\n\\r\\n$\\r\\nk =\\r\\n\\\\frac{\\r\\n\\\\begin{vmatrix}\\r\\n  y_1 & 1\\\\\\\\\\r\\n  y_2 & 1\\r\\n\\\\end{vmatrix}}\\r\\n{\\\\begin{vmatrix}\\r\\n  x_1 & 1\\\\\\\\\\r\\n  x_2 & 1\\r\\n\\\\end{vmatrix}}\\r\\n= \\\\frac{y_1 - y_2}{x_1 - x_2}, \\r\\nb =\\r\\n\\\\frac{\\r\\n\\\\begin{vmatrix}\\r\\n  x_1 & y_1\\\\\\\\\\r\\n  x_2 & y_2\\r\\n\\\\end{vmatrix}}\\r\\n{\\\\begin{vmatrix}\\r\\n  x_1 & 1\\\\\\\\\\r\\n  x_2 & 1\\r\\n\\\\end{vmatrix}}\\r\\n= \\\\frac{x_1 \\\\cdot y_2 - y_1 \\\\cdot x_2}{x_1 - x_2}\\r\\n$\\r\\n\\r\\nWe get that the **equation of a straight line constructed from two points** $(x_1, y_1), (x_2, y_2) $ has **the form**:\\r\\n\\r\\n$\\r\\ny = \\\\frac{y_1 - y_2}{x_1 - x_2} \\\\cdot x + \\\\frac{x_1 \\\\cdot y_2 - y_1 \\\\cdot x_2}{x_1 - x_2} \\\\Rightarrow (x_1 - x_2) \\\\cdot y = (y_1 - y_2) \\\\cdot x + (x_1 \\\\cdot y_2 - y_1 \\\\cdot x_2)\\r\\n$\\r\\n\\r\\n**It suffices to check this equality for each next point.**\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: $ O(n) $\\r\\n- Space complexity: $ O(1) $\\r\\n\\r\\n# Code\\r\\n```C++ []\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        int n = coordinates.size();\\r\\n        if (n == 2) { return true; }\\r\\n        int x1 = coordinates[0][0], y1 = coordinates[0][1];\\r\\n        int x2 = coordinates[1][0], y2 = coordinates[1][1];\\r\\n        if (x1 == x2) {\\r\\n            for (int i = 2; i < n; i++) {\\r\\n                if (coordinates[i][0] != x1) { return false; }\\r\\n            }\\r\\n            return true;\\r\\n        }\\r\\n        if (y1 == y2) {\\r\\n            for (int i = 2; i < n; i++) {\\r\\n                if (coordinates[i][1] != y1) { return false; }\\r\\n            }\\r\\n            return true;\\r\\n        }\\r\\n        int dx = x2 - x1, dy = y2 - y1, resid = x2 * y1 - x1 * y2;\\r\\n        for (int i = 2; i < n; i++) {\\r\\n            int x = coordinates[i][0], y = coordinates[i][1];\\r\\n            if (dx * y - dy * x - resid != 0) { return false; }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```C++ []\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        int n = coordinates.size();\\r\\n        if (n == 2) { return true; }\\r\\n        int x1 = coordinates[0][0], y1 = coordinates[0][1];\\r\\n        int x2 = coordinates[1][0], y2 = coordinates[1][1];\\r\\n        if (x1 == x2) {\\r\\n            for (int i = 2; i < n; i++) {\\r\\n                if (coordinates[i][0] != x1) { return false; }\\r\\n            }\\r\\n            return true;\\r\\n        }\\r\\n        if (y1 == y2) {\\r\\n            for (int i = 2; i < n; i++) {\\r\\n                if (coordinates[i][1] != y1) { return false; }\\r\\n            }\\r\\n            return true;\\r\\n        }\\r\\n        int dx = x2 - x1, dy = y2 - y1, resid = x2 * y1 - x1 * y2;\\r\\n        for (int i = 2; i < n; i++) {\\r\\n            int x = coordinates[i][0], y = coordinates[i][1];\\r\\n            if (dx * y - dy * x - resid != 0) { return false; }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048371,
                "title": "simple-and-easy-to-understand-c",
                "content": "\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& v) {\\r\\n        double x = ( v[1][0] - v[0][0]  );\\r\\n        double y = (v[1][1]-v[0][1]);\\r\\n        double m;\\r\\n        if(x == 0) m= INT_MAX;\\r\\n        else m=y/x;\\r\\n        for(int i=2;i<v.size();i++){\\r\\n            double x1 = (v[i][0]-v[i-1][0]) ;\\r\\n            double y1 = (v[i][1] - v[i-1][1] );\\r\\n            double tan;\\r\\n            if( x1 == 0 )  tan = INT_MAX;\\r\\n            else tan = y1/x1;\\r\\n\\r\\n            if(m != tan) return false;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& v) {\\r\\n        double x = ( v[1][0] - v[0][0]  );\\r\\n        double y = (v[1][1]-v[0][1]);\\r\\n        double m;\\r\\n        if(x == 0) m= INT_MAX;\\r\\n        else m=y/x;\\r\\n        for(int i=2;i<v.size();i++){\\r\\n            double x1 = (v[i][0]-v[i-1][0]) ;\\r\\n            double y1 = (v[i][1] - v[i-1][1] );\\r\\n            double tan;\\r\\n            if( x1 == 0 )  tan = INT_MAX;\\r\\n            else tan = y1/x1;\\r\\n\\r\\n            if(m != tan) return false;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2817273,
                "title": "leetcode-the-hard-way-rust-windows",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n```rs\\nimpl Solution {\\n    pub fn check_straight_line(coordinates: Vec<Vec<i32>>) -> bool {\\n        // y2 - y1 / x2 - x1 = y3 - y2 / x3 - x2\\n        // = (y2 - y1) * (x3 - x2) = (y3 - y2) * (x2 - x1)\\n        for w in coordinates.windows(3) {\\n            if ((w[1][1] - w[0][1]) * (w[2][0] - w[1][0]) != (w[2][1] - w[1][1]) * (w[1][0] - w[0][0])) {\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rs\\nimpl Solution {\\n    pub fn check_straight_line(coordinates: Vec<Vec<i32>>) -> bool {\\n        // y2 - y1 / x2 - x1 = y3 - y2 / x3 - x2\\n        // = (y2 - y1) * (x3 - x2) = (y3 - y2) * (x2 - x1)\\n        for w in coordinates.windows(3) {\\n            if ((w[1][1] - w[0][1]) * (w[2][0] - w[1][0]) != (w[2][1] - w[1][1]) * (w[1][0] - w[0][0])) {\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2767366,
                "title": "c-solution",
                "content": "``` C++ []\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        \\r\\n        // in this case I\\'ve taken x/y instead of slope (y/x) for comparison, though either one works\\r\\n        float diff = (float)(coordinates[1][0] - coordinates[0][0]) / (coordinates[1][1] - coordinates[0][1]);\\r\\n\\r\\n        // denominator is 0 set diff to a dummy variable as in this case or you can set it to INT_MAX\\r\\n        if (coordinates[1][1] == coordinates[0][1]) diff = -100000;\\r\\n\\r\\n        for (int i{2}; i<coordinates.size(); ++i) {\\r\\n\\r\\n            // compare in case of line parallel to x axis [all y coordinates same]\\r\\n            if (coordinates[i][1]==coordinates[i-1][1]) {\\r\\n                if (diff==-100000) continue;\\r\\n                else return false;\\r\\n            }\\r\\n\\r\\n            // compare the x/y values and check if they are equal or not\\r\\n            if (((float)(coordinates[i][0] - coordinates[i-1][0]) / (coordinates[i][1] - coordinates[i-1][1]))==diff) continue;\\r\\n            else {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n```\\r\\n\\r\\n*Upvote this solution if it helped*\\r\\n\\r\\n## My GitHub: https://github.com/crimsonKn1ght",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        \\r\\n        // in this case I\\'ve taken x/y instead of slope (y/x) for comparison, though either one works\\r\\n        float diff = (float)(coordinates[1][0] - coordinates[0][0]) / (coordinates[1][1] - coordinates[0][1]);\\r\\n\\r\\n        // denominator is 0 set diff to a dummy variable as in this case or you can set it to INT_MAX\\r\\n        if (coordinates[1][1] == coordinates[0][1]) diff = -100000;\\r\\n\\r\\n        for (int i{2}; i<coordinates.size(); ++i) {\\r\\n\\r\\n            // compare in case of line parallel to x axis [all y coordinates same]\\r\\n            if (coordinates[i][1]==coordinates[i-1][1]) {\\r\\n                if (diff==-100000) continue;\\r\\n                else return false;\\r\\n            }\\r\\n\\r\\n            // compare the x/y values and check if they are equal or not\\r\\n            if (((float)(coordinates[i][0] - coordinates[i-1][0]) / (coordinates[i][1] - coordinates[i-1][1]))==diff) continue;\\r\\n            else {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646124,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& c) {\\n        double m;\\n        if((c[1][0]-c[0][0])==0)\\n            m=INT_MAX;\\n        else m=1.0*(c[1][1]-c[0][1])/(c[1][0]-c[0][0]);\\n        for(int i=1;i<c.size()-1;i++)\\n        {\\n            double k;\\n            if((c[i+1][0]-c[i][0])==0)\\n                k=INT_MAX;\\n            else \\n                 k=1.0*(c[i+1][1]-c[i][1])/(c[i+1][0]-c[i][0]);\\n            if(k!=m)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& c) {\\n        double m;\\n        if((c[1][0]-c[0][0])==0)\\n            m=INT_MAX;\\n        else m=1.0*(c[1][1]-c[0][1])/(c[1][0]-c[0][0]);\\n        for(int i=1;i<c.size()-1;i++)\\n        {\\n            double k;\\n            if((c[i+1][0]-c[i][0])==0)\\n                k=INT_MAX;\\n            else \\n                 k=1.0*(c[i+1][1]-c[i][1])/(c[i+1][0]-c[i][0]);\\n            if(k!=m)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271091,
                "title": "c-solution-easy-maths-better-than-97",
                "content": "```\\nbool checkStraightLine(vector<vector<int>>& coordinates) {\\n        if(coordinates.size() == 2)\\n        return true;\\n    int x0 = coordinates[0][0] , x1 = coordinates[1][0];\\n    int y0 = coordinates[0][1] , y1 = coordinates[1][1];\\n    int dx = x1 - x0 , dy = y1 - y0;\\n    for(int i = 2 ; i < coordinates.size() ; i++)    {\\n        int x = coordinates[i][0] , y = coordinates[i][1];\\n        if(dy * (x - x0) != dx * (y - y0))\\n            return false;\\n    }\\n    return true;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nbool checkStraightLine(vector<vector<int>>& coordinates) {\\n        if(coordinates.size() == 2)\\n        return true;\\n    int x0 = coordinates[0][0] , x1 = coordinates[1][0];\\n    int y0 = coordinates[0][1] , y1 = coordinates[1][1];\\n    int dx = x1 - x0 , dy = y1 - y0;\\n    for(int i = 2 ; i < coordinates.size() ; i++)    {\\n        int x = coordinates[i][0] , y = coordinates[i][1];\\n        if(dy * (x - x0) != dx * (y - y0))\\n            return false;\\n    }\\n    return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2077001,
                "title": "javascript-fastest-simple-solution",
                "content": "```\\n/**\\n * @param {number[][]} coordinates\\n * @return {boolean}\\n */\\nvar checkStraightLine = function(coordinates) {\\n    \\n    if(coordinates.length === 2) return true\\n    if(coordinates === null || coordinates[0].length === 0) return false;\\n       \\n    let p = coordinates[0];\\n    let q = coordinates[1];\\n    let curr\\n    \\n    for(let i = 2; i < coordinates.length; i++) {\\n        curr = coordinates[i];\\n        if((curr[0] - p[0]) * (q[1] - p[1]) !== (curr[1] - p[1]) * (q[0] - p[0])) return false;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} coordinates\\n * @return {boolean}\\n */\\nvar checkStraightLine = function(coordinates) {\\n    \\n    if(coordinates.length === 2) return true\\n    if(coordinates === null || coordinates[0].length === 0) return false;\\n       \\n    let p = coordinates[0];\\n    let q = coordinates[1];\\n    let curr\\n    \\n    for(let i = 2; i < coordinates.length; i++) {\\n        curr = coordinates[i];\\n        if((curr[0] - p[0]) * (q[1] - p[1]) !== (curr[1] - p[1]) * (q[0] - p[0])) return false;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824934,
                "title": "check-if-it-is-a-straight-line-python",
                "content": "class Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n\\t\\n        #for straight line slope must be same of every elements ...\\n        (x0,y0),(x1,y1)=coordinates[:2]\\n        for i in range(2,len(coordinates)):\\n            (x,y)=coordinates[i]\\n            if (y1-y0)*(x-x1)!=(x1-x0)*(y-y1):return False\\n        return True",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n\\t\\n        #for straight line slope must be same of every elements ...\\n        (x0,y0),(x1,y1)=coordinates[:2]\\n        for i in range(2,len(coordinates)):\\n            (x,y)=coordinates[i]\\n            if (y1-y0)*(x-x1)!=(x1-x0)*(y-y1):return False\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 1414062,
                "title": "easy-java-solution-0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "class Solution {\\n\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        int dx = coordinates[1][0]-coordinates[0][0];\\n        int dy = coordinates[1][1]-coordinates[0][1];\\n        \\n        for(int i =1; i<coordinates.length-1; i++)\\n            if(dx*(coordinates[i+1][1]-coordinates[i][1]) != dy*(coordinates[i+1][0]-coordinates[i][0]))\\n                return false;\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        int dx = coordinates[1][0]-coordinates[0][0];\\n        int dy = coordinates[1][1]-coordinates[0][1];\\n        \\n        for(int i =1; i<coordinates.length-1; i++)\\n            if(dx*(coordinates[i+1][1]-coordinates[i][1]) != dy*(coordinates[i+1][0]-coordinates[i][0]))\\n                return false;\\n        \\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 969755,
                "title": "java-slope-calculation-for-the-line",
                "content": "The slope value between the first and the second points should form identity with the slope value between the first and other points. This identity can be expressed as:\\n```\\n(y2-y1) / (x2-x1) = (y3-y2) / (x3-x2)\\n```\\nIn order to avoid possible zero division, it is better to use multiplication form instead of division one:\\n```\\n(y2 - y1) * (x3 - x2) = (x2 - x1) * (y3 - y2)\\n```\\nSince we\\'ll compare the slope value of the first two points, we\\'ll extract it as `dx` and `dy`:\\n```\\ndx = (x2-x1)\\ndy = (y2-y1)\\n```\\nThe final identity formula will look like:\\n```\\ndy * (x3 - x2) = dx * (y3 - y2)\\nor vice versa\\ndx * (y3 - y2) = dy * (x3 - x2)\\n```\\n\\nSolution:\\n```\\npublic boolean checkStraightLine(int[][] coordinates) {\\n        if(coordinates.length == 2 && coordinates[0].length == 2) {\\n            return true;\\n        }\\n\\n        int dx = coordinates[1][0] - coordinates[0][0];\\n        int dy = coordinates[1][1] - coordinates[0][1];\\n\\n        for(int i = 2; i < coordinates.length; i++) {\\n            if(dx * (coordinates[i][1] - coordinates[i-1][1]) == dy * (coordinates[i][0] - coordinates[i-1][0])) {\\n                continue;\\n            }\\n            return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n(y2-y1) / (x2-x1) = (y3-y2) / (x3-x2)\\n```\n```\\n(y2 - y1) * (x3 - x2) = (x2 - x1) * (y3 - y2)\\n```\n```\\ndx = (x2-x1)\\ndy = (y2-y1)\\n```\n```\\ndy * (x3 - x2) = dx * (y3 - y2)\\nor vice versa\\ndx * (y3 - y2) = dy * (x3 - x2)\\n```\n```\\npublic boolean checkStraightLine(int[][] coordinates) {\\n        if(coordinates.length == 2 && coordinates[0].length == 2) {\\n            return true;\\n        }\\n\\n        int dx = coordinates[1][0] - coordinates[0][0];\\n        int dy = coordinates[1][1] - coordinates[0][1];\\n\\n        for(int i = 2; i < coordinates.length; i++) {\\n            if(dx * (coordinates[i][1] - coordinates[i-1][1]) == dy * (coordinates[i][0] - coordinates[i-1][0])) {\\n                continue;\\n            }\\n            return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866276,
                "title": "java-very-easy-100-0ms",
                "content": "```\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n              float slope = getSlope(coordinates[0],coordinates[1]);\\n       \\n        for(int i = 2 ; i < coordinates.length ; i++){  \\n            if(slope != getSlope(coordinates[i-1], coordinates[i])){\\n                return false;\\n            } \\n        }\\n        \\n        return true;\\n    }\\n    \\n    public float getSlope(int[] p1, int[] p2){\\n         int x0 = p1[0];\\n        int y0 = p1[1];\\n        int x1 = p2[0];\\n        int y1 = p2[1];\\n        \\n      return   x1 == x0 ? Float.POSITIVE_INFINITY : (float)(y1-y0)/(x1-x0);\\n       \\n        \\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n              float slope = getSlope(coordinates[0],coordinates[1]);\\n       \\n        for(int i = 2 ; i < coordinates.length ; i++){  \\n            if(slope != getSlope(coordinates[i-1], coordinates[i])){\\n                return false;\\n            } \\n        }\\n        \\n        return true;\\n    }\\n    \\n    public float getSlope(int[] p1, int[] p2){\\n         int x0 = p1[0];\\n        int y0 = p1[1];\\n        int x1 = p2[0];\\n        int y1 = p2[1];\\n        \\n      return   x1 == x0 ? Float.POSITIVE_INFINITY : (float)(y1-y0)/(x1-x0);\\n       \\n        \\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757380,
                "title": "clean-python-high-speed",
                "content": "**Clean Python | High Speed**\\n\\nThe Python code below presents an easy solution to check if all points belong to the same line. The steps are the following:\\n\\n1. We take the first 2 coordinate pairs, and calculate the paramaters (m,b) for the line equation ( y = m * x + b ) passing through these points. Since all points should belong to the same line, we can use our new equation as a check.\\n\\n2. If x0==x1 for the first two points, we have a vertical line, and our line equation becomes ( x = x0 ).\\n\\n3. We build an auxiliary function called \"inline\", which checks if points belong to our line equation.\\n\\n4. We apply our function \"inline\" to all coordinate pairs, and return \"True\" if all points pass the check (otherwise False).\\n\\nI hope the explanation was helpful. I have used this algorithm plenty of times at work :)\\nCheers,\\n\\n```\\nclass Solution:\\n    def checkStraightLine(self, P):\\n        x0,y0 = P[0]\\n        x1,y1 = P[1]\\n        #\\n        if x0==x1:\\n            inline = lambda x,y: x==x0\\n        else:\\n            # y = m*x + b\\n            m = ( y1 - y0 )/float( x1 - x0 )\\n            b = y0 - m*x0\\n            inline = lambda x,y: y == ( m*x + b )\\n        #\\n        return all( [ inline(x,y) for x,y in P[2:] ] )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkStraightLine(self, P):\\n        x0,y0 = P[0]\\n        x1,y1 = P[1]\\n        #\\n        if x0==x1:\\n            inline = lambda x,y: x==x0\\n        else:\\n            # y = m*x + b\\n            m = ( y1 - y0 )/float( x1 - x0 )\\n            b = y0 - m*x0\\n            inline = lambda x,y: y == ( m*x + b )\\n        #\\n        return all( [ inline(x,y) for x,y in P[2:] ] )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 621181,
                "title": "c-short-i-hope-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int X = coordinates[0][0], Y = coordinates[0][1];\\n        int x_diff = coordinates[1][0] - X;\\n        int y_diff = coordinates[1][1] - Y;\\n        for(int i = 2; i < coordinates.size(); ++i)\\n        {\\n            int x = coordinates[i][0], y = coordinates[i][1];\\n            if(x_diff*(y-Y) != y_diff*(x-X)) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int X = coordinates[0][0], Y = coordinates[0][1];\\n        int x_diff = coordinates[1][0] - X;\\n        int y_diff = coordinates[1][1] - Y;\\n        for(int i = 2; i < coordinates.size(); ++i)\\n        {\\n            int x = coordinates[i][0], y = coordinates[i][1];\\n            if(x_diff*(y-Y) != y_diff*(x-X)) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620827,
                "title": "check-collinear-with-cross-product",
                "content": "\\nAssume c0, c1, c2 are all 1D vector of size 2 and they are in the same straight line:\\nThen the following statement must be true: \\n(c1[1]-c0[1])/(c1[0]-c0[0]) == (c2[1]-c0[1])/(c2[0]-c0[0])\\nHowever, it might face the overflow caused by the case where denominator is 0.\\n\\nHere we can uuse cross product theory to aovid the division-by-zero: \\na*d == b * c\\nsame as:\\na/b == c/d\\n\\n\\nSo a bette way is: check:\\n(c1[1]-c0[1]) * (c2[0]-c0[0]) = (c2[1]-c0[1]) * (c1[0]-c0[0])\\n\\n\\nSolution 1: Use cross product to check collinearity.\\n```\\nclass Solution {\\npublic: // Time/Space: O(N); O(1)\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int deltaX = coordinates[1][0] - coordinates[0][0];\\n        int deltaY = coordinates[1][1] - coordinates[0][1];\\n        for(int i = 2; i < coordinates.size(); i++)\\n            if( deltaX * (coordinates[i][1] - coordinates[0][1]) !=  deltaY * (coordinates[i][0] - coordinates[0][0]))\\n                return false;\\n        return true;\\n    }\\n};\\n```\\n\\n\\nSolution 2: Use naive  slope-intercept form:   https://en.wikipedia.org/wiki/Slope\\n```\\nclass Solution {\\npublic: // Time/Space: O(N); O(1)\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        auto& basePoint = coordinates[0];\\n        bool onlyCheckDelta0 = false;        \\n        float oldSlope;\\n        for(int i = 1; i < coordinates.size(); i++){\\n            int delta0 = coordinates[i][0] - basePoint[0];            \\n            if(delta0 == 0) onlyCheckDelta0=true;\\n            if(onlyCheckDelta0 && delta0!=0) return false;\\n            if(delta0 == 0) continue;\\n            \\n            int delta1 = coordinates[i][1] - basePoint[1];            \\n            float newSlope = (float)delta1/delta0;\\n            if(i==1) oldSlope = newSlope;\\n            else if(newSlope != oldSlope) return false;\\n        }        \\n        return true;            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic: // Time/Space: O(N); O(1)\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int deltaX = coordinates[1][0] - coordinates[0][0];\\n        int deltaY = coordinates[1][1] - coordinates[0][1];\\n        for(int i = 2; i < coordinates.size(); i++)\\n            if( deltaX * (coordinates[i][1] - coordinates[0][1]) !=  deltaY * (coordinates[i][0] - coordinates[0][0]))\\n                return false;\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic: // Time/Space: O(N); O(1)\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        auto& basePoint = coordinates[0];\\n        bool onlyCheckDelta0 = false;        \\n        float oldSlope;\\n        for(int i = 1; i < coordinates.size(); i++){\\n            int delta0 = coordinates[i][0] - basePoint[0];            \\n            if(delta0 == 0) onlyCheckDelta0=true;\\n            if(onlyCheckDelta0 && delta0!=0) return false;\\n            if(delta0 == 0) continue;\\n            \\n            int delta1 = coordinates[i][1] - basePoint[1];            \\n            float newSlope = (float)delta1/delta0;\\n            if(i==1) oldSlope = newSlope;\\n            else if(newSlope != oldSlope) return false;\\n        }        \\n        return true;            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532875,
                "title": "easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& c) {\\n     if(c.size()==0){return false;}\\n     int a =c[0][0];\\n     int b =c[0][1];\\n     int d =c[1][0];\\n     int e =c[1][1];\\n     const int dx = d-a;\\n     const int dy = e-b;\\n         for(int i = 2; i<c.size();i++){\\n             int dx1 = c[i][0]-c[0][0];\\n             int dy1 = c[i][1]-c[0][1];\\n             if(dx*dy1 !=dx1*dy) {return false;}\\n       \\n        else return true;\\n         }\\n         \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& c) {\\n     if(c.size()==0){return false;}\\n     int a =c[0][0];\\n     int b =c[0][1];\\n     int d =c[1][0];\\n     int e =c[1][1];\\n     const int dx = d-a;\\n     const int dy = e-b;\\n         for(int i = 2; i<c.size();i++){\\n             int dx1 = c[i][0]-c[0][0];\\n             int dy1 = c[i][1]-c[0][1];\\n             if(dx*dy1 !=dx1*dy) {return false;}\\n       \\n        else return true;\\n         }\\n         \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479565,
                "title": "my-c-solution",
                "content": "```\\nbool checkStraightLine(int** coordinates, int coordinatesSize, int* coordinatesColSize){\\n    int dx1 = coordinates[1][0] - coordinates[0][0];\\n    int dy1 = coordinates[1][1] - coordinates[0][1];\\n    for(int i=2; i<coordinatesSize; i++){\\n        int dx2 = coordinates[i][0] - coordinates[0][0];\\n        int dy2 = coordinates[i][1] - coordinates[0][1];\\n        if(dx1*dy2 != dx2*dy1) return false;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool checkStraightLine(int** coordinates, int coordinatesSize, int* coordinatesColSize){\\n    int dx1 = coordinates[1][0] - coordinates[0][0];\\n    int dy1 = coordinates[1][1] - coordinates[0][1];\\n    for(int i=2; i<coordinatesSize; i++){\\n        int dx2 = coordinates[i][0] - coordinates[0][0];\\n        int dy2 = coordinates[i][1] - coordinates[0][1];\\n        if(dx1*dy2 != dx2*dy1) return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3601228,
                "title": "python-short-1-liner-functional-programming",
                "content": "# Approach\\n1. Take 2 adjacent `points` at a time and calculate their `slope`.\\n\\n2. Return `true` if all `slopes` are equal else `False`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is the number of points.`\\n\\n# Code\\n```python\\nclass Solution:\\n    def checkStraightLine(self, points: list[list[int]]) -> bool:\\n        return all(starmap(eq, pairwise(starmap(lambda p, q: ((q[1] - p[1]) / (q[0] - p[0])) if (q[0] - p[0]) else inf, pairwise(points)))))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```python\\nclass Solution:\\n    def checkStraightLine(self, points: list[list[int]]) -> bool:\\n        return all(starmap(eq, pairwise(starmap(lambda p, q: ((q[1] - p[1]) / (q[0] - p[0])) if (q[0] - p[0]) else inf, pairwise(points)))))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601173,
                "title": "beats-100-java-c-explanation-brute-force-optimal-solution",
                "content": "# Naive Solution\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we are given a set of coordinates, we contantly check the slopes of the equations and verify it with the initial slopes. If they are any different, they do not form a straight line\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initially we need any two points in the plane to formulate the **Initial Slope**.\\n  $$(x2-x1) = (y2-y1)$$\\n- Hence we take the first two points, and store their coordinates in the variables (x1,y1) for first point and (x2,y2) for second point.\\n- We computed our initial slope, and we now take each and every point in the coordinates and check if the slope is same or not using any point next to it.\\n- If at any instant the slope is not equal to the inital slope, **False** is returned.\\n- If the loop ends, after verifying all the points, **True** is returned.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nn -> Number of Coordinates\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        double in_slope=((coordinates[1][1]-coordinates[0][1])*1.0)/(coordinates[1][0]-coordinates[0][0]);\\n        for(int i=0;i<coordinates.length;i++){\\n            for(int j=i+1;j<coordinates.length;j++){\\n                double slope = ((coordinates[j][1]-coordinates[i][1])*1.0)/(coordinates[j][0]-coordinates[i][0]);\\n                if(slope!=in_slope && slope!=-in_slope) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        double in_slope=((coordinates[1][1]-coordinates[0][1])*1.0)/(coordinates[1][0]-coordinates[0][0]);\\n        for(int i=0;i<coordinates.size();i++){\\n            for(int j=i+1;j<coordinates.size();j++){\\n                double slope = ((coordinates[j][1]-coordinates[i][1])*1.0)/(coordinates[j][0]-coordinates[i][0]);\\n                if(slope!=in_slope && slope!=-in_slope) return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```\\n---\\n\\n# Optimal Solution\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we are given a set of coordinates, we could formulate the straight line equation and check whether the solution exacts for every point given in the coordinates.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initially we need any two points in the plane to formulate the **Straight Line Equation**.\\n  $$(y-y1)*(x2-x1) = (y2-y1)*(x-x1)$$\\n- Hence we take the first two points, and store their coordinates in the variables (x1,y1) for first point and (x2,y2) for second point.\\n- As we have created our straight line equation, we run through other coordinates to check whether they lie on this line, by substituting their x and y coordinates in the equation.\\n- If atleast one point does not hold this relation, **False** is returned.\\n- If the loop ends, after verifying all the points, **True** is returned.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nn -> Number of Coordinates\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n\\n        int x1=coordinates[0][0],x2=coordinates[1][0],y1=coordinates[0][1],y2=coordinates[1][1];\\n\\n        for(int i=2;i<coordinates.length;i++){\\n            int x=coordinates[i][0],y=coordinates[i][1];\\n            if((y-y1)*(x2-x1) != (x-x1)*(y2-y1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int x1=coordinates[0][0],x2=coordinates[1][0],y1=coordinates[0][1],y2=coordinates[1][1];\\n\\n        for(int i=2;i<coordinates.size();i++){\\n            int x=coordinates[i][0],y=coordinates[i][1];\\n            if((y-y1)*(x2-x1) != (x-x1)*(y2-y1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```Java []\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        double in_slope=((coordinates[1][1]-coordinates[0][1])*1.0)/(coordinates[1][0]-coordinates[0][0]);\\n        for(int i=0;i<coordinates.length;i++){\\n            for(int j=i+1;j<coordinates.length;j++){\\n                double slope = ((coordinates[j][1]-coordinates[i][1])*1.0)/(coordinates[j][0]-coordinates[i][0]);\\n                if(slope!=in_slope && slope!=-in_slope) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        double in_slope=((coordinates[1][1]-coordinates[0][1])*1.0)/(coordinates[1][0]-coordinates[0][0]);\\n        for(int i=0;i<coordinates.size();i++){\\n            for(int j=i+1;j<coordinates.size();j++){\\n                double slope = ((coordinates[j][1]-coordinates[i][1])*1.0)/(coordinates[j][0]-coordinates[i][0]);\\n                if(slope!=in_slope && slope!=-in_slope) return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n\\n        int x1=coordinates[0][0],x2=coordinates[1][0],y1=coordinates[0][1],y2=coordinates[1][1];\\n\\n        for(int i=2;i<coordinates.length;i++){\\n            int x=coordinates[i][0],y=coordinates[i][1];\\n            if((y-y1)*(x2-x1) != (x-x1)*(y2-y1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int x1=coordinates[0][0],x2=coordinates[1][0],y1=coordinates[0][1],y2=coordinates[1][1];\\n\\n        for(int i=2;i<coordinates.size();i++){\\n            int x=coordinates[i][0],y=coordinates[i][1];\\n            if((y-y1)*(x2-x1) != (x-x1)*(y2-y1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600562,
                "title": "java-solution-for-check-if-it-is-a-straight-line-problem",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nThe intuition behind the solution is to check if all the given points lie on the same straight line. If the slope between any two points is equal to the slope between the first two points, then all the points lie on the same line.\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n1. Calculate the slope between the first two points (x0, y0) and (x1, y1) using the formula (y1 - y0) / (x1 - x0).\\r\\n1. Iterate through the remaining points starting from index 2.\\r\\n1. For each point (x, y), calculate the slope between (x, y) and (x0, y0).\\r\\n1. If the calculated slope is not equal to the slope between the first two points, return false.\\r\\n1. If all the slopes are equal, return true as all the points lie on the same line.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\nThe time complexity of this solution is O(n), where n is the number of points in the coordinates array. We iterate through all the points once to calculate and compare the slopes.\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\nThe space complexity is O(1) because we use a constant amount of additional space to store the variables x0, y0, x1, y1, x, and y.\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n    public boolean checkStraightLine(int[][] coordinates) {\\r\\n        // Calculate the slope between the first two points\\r\\n    int x0 = coordinates[0][0];\\r\\n    int y0 = coordinates[0][1];\\r\\n    int x1 = coordinates[1][0];\\r\\n    int y1 = coordinates[1][1];\\r\\n    \\r\\n    // Iterate through the remaining points and check if the slope remains consistent\\r\\n    for (int i = 2; i < coordinates.length; i++) {\\r\\n        int x = coordinates[i][0];\\r\\n        int y = coordinates[i][1];\\r\\n        \\r\\n        // If the current point doesn\\'t satisfy the slope formula, return false\\r\\n        if ((y1 - y0) * (x - x0) != (y - y0) * (x1 - x0)) {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    // All points satisfy the slope formula, so they form a straight line\\r\\n    return true;\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    public boolean checkStraightLine(int[][] coordinates) {\\r\\n        // Calculate the slope between the first two points\\r\\n    int x0 = coordinates[0][0];\\r\\n    int y0 = coordinates[0][1];\\r\\n    int x1 = coordinates[1][0];\\r\\n    int y1 = coordinates[1][1];\\r\\n    \\r\\n    // Iterate through the remaining points and check if the slope remains consistent\\r\\n    for (int i = 2; i < coordinates.length; i++) {\\r\\n        int x = coordinates[i][0];\\r\\n        int y = coordinates[i][1];\\r\\n        \\r\\n        // If the current point doesn\\'t satisfy the slope formula, return false\\r\\n        if ((y1 - y0) * (x - x0) != (y - y0) * (x1 - x0)) {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    // All points satisfy the slope formula, so they form a straight line\\r\\n    return true;\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600214,
                "title": "python-java-solution-using-slope-formula",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n```java []\\n public boolean checkStraightLine(int[][] coordinates) {\\n         double s;\\n        if (coordinates[1][0] - coordinates[0][0] == 0) {\\n            s = Double.MAX_VALUE;\\n        } else {\\n            s = (double)(coordinates[1][1] - coordinates[0][1]) / (coordinates[1][0] - coordinates[0][0]);\\n        }\\n        for (int i = 2; i < coordinates.length; i++) {\\n            double slope = Double.MAX_VALUE;\\n            if (coordinates[i][0] - coordinates[i-1][0] != 0) {\\n                slope = (double)(coordinates[i][1] - coordinates[i-1][1]) / (coordinates[i][0] - coordinates[i-1][0]);\\n            }\\n            if (slope != s) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\\n```python []\\n   def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        if(coordinates[1][0]-coordinates[0][0]==0):\\n            s=1e9\\n        else:\\n            s=(coordinates[1][1]-coordinates[0][1])//(coordinates[1][0]-coordinates[0][0])\\n        for i in range(1,len(coordinates)):\\n            slope=1e9\\n            if(coordinates[i][0]-coordinates[i-1][0]!=0):\\n                slope=(coordinates[i][1]-coordinates[i-1][1])//(coordinates[i][0]-coordinates[i-1][0])\\n            if(slope!=s):\\n                return False\\n        return True \\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```java []\\n public boolean checkStraightLine(int[][] coordinates) {\\n         double s;\\n        if (coordinates[1][0] - coordinates[0][0] == 0) {\\n            s = Double.MAX_VALUE;\\n        } else {\\n            s = (double)(coordinates[1][1] - coordinates[0][1]) / (coordinates[1][0] - coordinates[0][0]);\\n        }\\n        for (int i = 2; i < coordinates.length; i++) {\\n            double slope = Double.MAX_VALUE;\\n            if (coordinates[i][0] - coordinates[i-1][0] != 0) {\\n                slope = (double)(coordinates[i][1] - coordinates[i-1][1]) / (coordinates[i][0] - coordinates[i-1][0]);\\n            }\\n            if (slope != s) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\n```python []\\n   def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        if(coordinates[1][0]-coordinates[0][0]==0):\\n            s=1e9\\n        else:\\n            s=(coordinates[1][1]-coordinates[0][1])//(coordinates[1][0]-coordinates[0][0])\\n        for i in range(1,len(coordinates)):\\n            slope=1e9\\n            if(coordinates[i][0]-coordinates[i-1][0]!=0):\\n                slope=(coordinates[i][1]-coordinates[i-1][1])//(coordinates[i][0]-coordinates[i-1][0])\\n            if(slope!=s):\\n                return False\\n        return True \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3599804,
                "title": "easy-to-understand-c-code",
                "content": "# Intuition\\r\\nCsn do it by comparing the slope of 2 consecutive points\\r\\n\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:O(n)\\r\\n\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) \\r\\n    {\\r\\n        for(int i=1;i<coordinates.size()-1;i++)\\r\\n        {\\r\\n            /*double a=0;\\r\\n            if(coordinates[i][0]-coordinates[i-1][0]!=0)\\r\\n            {\\r\\n            a=((coordinates[i][1]-coordinates[i-1][1])/(coordinates[i][0]-coordinates[i-1][0]));\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                a=INT_MAX;\\r\\n            }\\r\\n            ####78 test cases passed out of 79\\r\\n            double b=0;\\r\\n            if(coordinates[i+1][0]-coordinates[i][0]!=0)\\r\\n            {\\r\\n            b=((coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0]));\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                b=INT_MAX;\\r\\n            }*/\\r\\n            double a=(coordinates[i][1]-coordinates[i-1][1])*(coordinates[i+1][0]-coordinates[i][0]);\\r\\n            double b=(coordinates[i][0]-coordinates[i-1][0])*(coordinates[i+1][1]-coordinates[i][1]);\\r\\n            if(a==b)\\r\\n            {\\r\\n                continue;\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) \\r\\n    {\\r\\n        for(int i=1;i<coordinates.size()-1;i++)\\r\\n        {\\r\\n            /*double a=0;\\r\\n            if(coordinates[i][0]-coordinates[i-1][0]!=0)\\r\\n            {\\r\\n            a=((coordinates[i][1]-coordinates[i-1][1])/(coordinates[i][0]-coordinates[i-1][0]));\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                a=INT_MAX;\\r\\n            }\\r\\n            ####78 test cases passed out of 79\\r\\n            double b=0;\\r\\n            if(coordinates[i+1][0]-coordinates[i][0]!=0)\\r\\n            {\\r\\n            b=((coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0]));\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                b=INT_MAX;\\r\\n            }*/\\r\\n            double a=(coordinates[i][1]-coordinates[i-1][1])*(coordinates[i+1][0]-coordinates[i][0]);\\r\\n            double b=(coordinates[i][0]-coordinates[i-1][0])*(coordinates[i+1][1]-coordinates[i][1]);\\r\\n            if(a==b)\\r\\n            {\\r\\n                continue;\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599244,
                "title": "maths-py",
                "content": "# Approach\\nEquating slopes\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def checkStraightLine(self, c: List[List[int]]) -> bool:\\n        x0,y0=c[0][0],c[0][1]\\n        x1,y1=c[1][0],c[1][1]\\n        for i in range(2, len(c)):\\n            x,y=c[i][0],c[i][1]\\n            if(x-x0)*(y1-y0)!=(y-y0)*(x1-x0):return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkStraightLine(self, c: List[List[int]]) -> bool:\\n        x0,y0=c[0][0],c[0][1]\\n        x1,y1=c[1][0],c[1][1]\\n        for i in range(2, len(c)):\\n            x,y=c[i][0],c[i][1]\\n            if(x-x0)*(y1-y0)!=(y-y0)*(x1-x0):return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599124,
                "title": "c-easy-solution",
                "content": "# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        set<int> slopes{};\\r\\n        int len = coordinates.size();\\r\\n        sort(coordinates.begin(), coordinates.end());\\r\\n        \\r\\n        for(int i{len - 1}; i > 0; i--){\\r\\n            if(i - 1 >= 0){\\r\\n                int rise = (coordinates[i][1] - coordinates[i - 1][1]);\\r\\n                int run = (coordinates[i][0] - coordinates[i - 1][0]);\\r\\n                int slope{};\\r\\n                \\r\\n                if(!run)\\r\\n                    slope = INT_MIN;\\r\\n                else slope =  rise / run;\\r\\n                \\r\\n                slopes.insert(slope);\\r\\n                \\r\\n                if(slopes.size() > 1)\\r\\n                    return false;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return slopes.size() == 1;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        set<int> slopes{};\\r\\n        int len = coordinates.size();\\r\\n        sort(coordinates.begin(), coordinates.end());\\r\\n        \\r\\n        for(int i{len - 1}; i > 0; i--){\\r\\n            if(i - 1 >= 0){\\r\\n                int rise = (coordinates[i][1] - coordinates[i - 1][1]);\\r\\n                int run = (coordinates[i][0] - coordinates[i - 1][0]);\\r\\n                int slope{};\\r\\n                \\r\\n                if(!run)\\r\\n                    slope = INT_MIN;\\r\\n                else slope =  rise / run;\\r\\n                \\r\\n                slopes.insert(slope);\\r\\n                \\r\\n                if(slopes.size() > 1)\\r\\n                    return false;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return slopes.size() == 1;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599096,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n    func checkStraightLine(_ c: [[Int]]) -> Bool {\\n        Set(c[1...].map{$0[1]==c[0][1] ? 1 : Float($0[0]-c[0][0]) / Float($0[1]-c[0][1])}).count == 1\\n    }\\n}\\n```\\n\\n---\\n\\n**One-Liner approach, illustrated (accepted answer)**\\n```\\nclass Solution {\\n    func checkStraightLine(_ coordinates: [[Int]]) -> Bool {\\n        let (X,Y) = (0,1) // indices\\n        let (x0, y0) = (coordinates[0][X], coordinates[0][Y])\\n\\n        return Set(\\n            coordinates.dropFirst()\\n            .map { point in\\n                point[X] == x0 ? .infinity : Float(point[Y]-y0) / Float(point[X]-x0)\\n            }\\n        )\\n        .count == 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func checkStraightLine(_ c: [[Int]]) -> Bool {\\n        Set(c[1...].map{$0[1]==c[0][1] ? 1 : Float($0[0]-c[0][0]) / Float($0[1]-c[0][1])}).count == 1\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func checkStraightLine(_ coordinates: [[Int]]) -> Bool {\\n        let (X,Y) = (0,1) // indices\\n        let (x0, y0) = (coordinates[0][X], coordinates[0][Y])\\n\\n        return Set(\\n            coordinates.dropFirst()\\n            .map { point in\\n                point[X] == x0 ? .infinity : Float(point[Y]-y0) / Float(point[X]-x0)\\n            }\\n        )\\n        .count == 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599024,
                "title": "solution-in-c",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) \\r\\n    {\\r\\n        int x0 = coordinates[0][0];\\r\\n        int y0 = coordinates[0][1];\\r\\n        int x1 = coordinates[1][0];\\r\\n        int y1 = coordinates[1][1];\\r\\n        for (int i = 2; i < coordinates.size(); i++) \\r\\n        {\\r\\n            int x = coordinates[i][0];\\r\\n            int y = coordinates[i][1];\\r\\n            if ((x - x0) * (y1 - y0) != (y - y0) * (x1 - x0))\\r\\n             {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) \\r\\n    {\\r\\n        int x0 = coordinates[0][0];\\r\\n        int y0 = coordinates[0][1];\\r\\n        int x1 = coordinates[1][0];\\r\\n        int y1 = coordinates[1][1];\\r\\n        for (int i = 2; i < coordinates.size(); i++) \\r\\n        {\\r\\n            int x = coordinates[i][0];\\r\\n            int y = coordinates[i][1];\\r\\n            if ((x - x0) * (y1 - y0) != (y - y0) * (x1 - x0))\\r\\n             {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598653,
                "title": "java-using-slope-property-beats-100-6-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public boolean checkStraightLine(int[][] coordinates) {\\n    var slope = coordinates[1][0] == coordinates[0][0]\\n      ? Double.MAX_VALUE\\n      : (double) (coordinates[1][1] - coordinates[0][1]) / (coordinates[1][0] - coordinates[0][0]);\\n    var c = coordinates[0][1] - slope * coordinates[0][0];\\n\\n    for (var i = 2; i < coordinates.length; i++)\\n      if (slope == Double.MAX_VALUE\\n        ? coordinates[i][0] != coordinates[0][0]\\n        : coordinates[i][1] - slope * coordinates[i][0] != c)\\n        return false;\\n    \\n    return true;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\n  public boolean checkStraightLine(int[][] coordinates) {\\n    var slope = coordinates[1][0] == coordinates[0][0]\\n      ? Double.MAX_VALUE\\n      : (double) (coordinates[1][1] - coordinates[0][1]) / (coordinates[1][0] - coordinates[0][0]);\\n    var c = coordinates[0][1] - slope * coordinates[0][0];\\n\\n    for (var i = 2; i < coordinates.length; i++)\\n      if (slope == Double.MAX_VALUE\\n        ? coordinates[i][0] != coordinates[0][0]\\n        : coordinates[i][1] - slope * coordinates[i][0] != c)\\n        return false;\\n    \\n    return true;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598606,
                "title": "easy-cpp-solution-with-intuitioin",
                "content": "# Intuition\\nIf there are only one or two points, it will always lie on a straight line.\\n\\nIf there are more than two points, we can select any two points and find the equation of the line passing through them. Once we have the equation, we can check whether all the points satisfy the equation or not.\\n\\nHere the equation will be this : \\npoint1 = {x1,y1}\\n                                 point2 = {x2,y2}\\n                    equation : (y-y1)*(x2-x1) = (x-x1)*(y2-y1)\\n\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        if(coordinates.size()<=2)return 1;\\n        int x = coordinates[1][0]-coordinates[0][0];\\n        int y = coordinates[1][1]-coordinates[0][1];\\n        auto good = [&](vector<int>&v)->bool{\\n            return x*(v[1]-coordinates[1][1]) == y*(v[0]-coordinates[1][0]);\\n        };\\n        int n = coordinates.size();\\n        for(int i = 1;i<n;i++){\\n            if(!good(coordinates[i]))return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        if(coordinates.size()<=2)return 1;\\n        int x = coordinates[1][0]-coordinates[0][0];\\n        int y = coordinates[1][1]-coordinates[0][1];\\n        auto good = [&](vector<int>&v)->bool{\\n            return x*(v[1]-coordinates[1][1]) == y*(v[0]-coordinates[1][0]);\\n        };\\n        int n = coordinates.size();\\n        for(int i = 1;i<n;i++){\\n            if(!good(coordinates[i]))return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132784,
                "title": "beginner-friendly-solution-with-comment-lines-0ms-beats-100",
                "content": "# Intuition\\r\\nPlease upvote if you like the solution\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n    public boolean checkStraightLine(int[][] coordinates) {\\r\\n        // --If there are two points only then must will in straight line\\r\\n        if(coordinates.length==2)\\r\\n        {\\r\\n            return true;\\r\\n        }\\r\\n\\r\\n        int i;\\r\\n\\r\\n        // --If points are on Y-axis i.e X-axis will be 0 for all given points\\r\\n        for(i=0;i<coordinates.length-1;i++)\\r\\n        {\\r\\n            if(coordinates[i][0]==coordinates[i+1][0])\\r\\n            {\\r\\n                continue;\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        if(i==coordinates.length-1)\\r\\n        {\\r\\n            return true;\\r\\n        }\\r\\n\\r\\n\\r\\n        // --If points are on X-axis i.e Y-axis will be 0 for all given points\\r\\n        for(i=0;i<coordinates.length-1;i++)\\r\\n        {\\r\\n            if(coordinates[i][1]==coordinates[i+1][1])\\r\\n            {\\r\\n                continue;\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        if(i==coordinates.length-1)\\r\\n        {\\r\\n            return true;\\r\\n        }\\r\\n\\r\\n\\r\\n        // --For all other rest conditions we will calculate the slope of line for given points\\r\\n        double slope1;\\r\\n        double slope2;\\r\\n        slope1=(double)(coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\r\\n        for(i=1;i<coordinates.length-1;i++)\\r\\n        {\\r\\n            slope2=(double)(coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0]);\\r\\n            if(slope1!=slope2)\\r\\n            {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        return true;        \\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    public boolean checkStraightLine(int[][] coordinates) {\\r\\n        // --If there are two points only then must will in straight line\\r\\n        if(coordinates.length==2)\\r\\n        {\\r\\n            return true;\\r\\n        }\\r\\n\\r\\n        int i;\\r\\n\\r\\n        // --If points are on Y-axis i.e X-axis will be 0 for all given points\\r\\n        for(i=0;i<coordinates.length-1;i++)\\r\\n        {\\r\\n            if(coordinates[i][0]==coordinates[i+1][0])\\r\\n            {\\r\\n                continue;\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        if(i==coordinates.length-1)\\r\\n        {\\r\\n            return true;\\r\\n        }\\r\\n\\r\\n\\r\\n        // --If points are on X-axis i.e Y-axis will be 0 for all given points\\r\\n        for(i=0;i<coordinates.length-1;i++)\\r\\n        {\\r\\n            if(coordinates[i][1]==coordinates[i+1][1])\\r\\n            {\\r\\n                continue;\\r\\n            }\\r\\n            else\\r\\n            {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        if(i==coordinates.length-1)\\r\\n        {\\r\\n            return true;\\r\\n        }\\r\\n\\r\\n\\r\\n        // --For all other rest conditions we will calculate the slope of line for given points\\r\\n        double slope1;\\r\\n        double slope2;\\r\\n        slope1=(double)(coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\r\\n        for(i=1;i<coordinates.length-1;i++)\\r\\n        {\\r\\n            slope2=(double)(coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0]);\\r\\n            if(slope1!=slope2)\\r\\n            {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        return true;        \\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944410,
                "title": "c-solution",
                "content": "# Code\\r\\n```\\r\\n#define inf 1000000007\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        double x = coordinates[1][0] - coordinates[0][0];\\r\\n        double y = coordinates[1][1] - coordinates[0][1];\\r\\n        double m;\\r\\n        if(x == 0) m = inf;\\r\\n        else m = y / x;\\r\\n        for(int i = 0; i < coordinates.size() - 1; i++) {\\r\\n            double dx = coordinates[i + 1][0] - coordinates[i][0];\\r\\n            double dy = coordinates[i + 1][1] - coordinates[i][1];\\r\\n            double slope;\\r\\n            if(dx == 0) slope = inf;\\r\\n            else slope = dy / dx;\\r\\n            if(slope != m) return false;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\n#define inf 1000000007\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        double x = coordinates[1][0] - coordinates[0][0];\\r\\n        double y = coordinates[1][1] - coordinates[0][1];\\r\\n        double m;\\r\\n        if(x == 0) m = inf;\\r\\n        else m = y / x;\\r\\n        for(int i = 0; i < coordinates.size() - 1; i++) {\\r\\n            double dx = coordinates[i + 1][0] - coordinates[i][0];\\r\\n            double dy = coordinates[i + 1][1] - coordinates[i][1];\\r\\n            double slope;\\r\\n            if(dx == 0) slope = inf;\\r\\n            else slope = dy / dx;\\r\\n            if(slope != m) return false;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936745,
                "title": "javascript-98-easy-solution",
                "content": "# Code\\r\\n```\\r\\nvar checkStraightLine = function (coordinates) {\\r\\n    const findDiff = (c1, c2) => {\\r\\n        if((coordinates[0][0]-coordinates[1][0])===0)\\r\\n        return  (c2[0] - c1[0])/(c2[1] - c1[1])\\r\\n        else\\r\\n        return (c2[1] - c1[1]) / (c2[0] - c1[0])\\r\\n    }\\r\\n    const diff =  findDiff(coordinates[0], coordinates[1])\\r\\n    for (let i = 0; i < coordinates.length - 1; i++) {\\r\\n        if (diff !== findDiff(coordinates[i], coordinates[i + 1]))\\r\\n            return false\\r\\n    }\\r\\n    return true\\r\\n};\\r\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\r\\nvar checkStraightLine = function (coordinates) {\\r\\n    const findDiff = (c1, c2) => {\\r\\n        if((coordinates[0][0]-coordinates[1][0])===0)\\r\\n        return  (c2[0] - c1[0])/(c2[1] - c1[1])\\r\\n        else\\r\\n        return (c2[1] - c1[1]) / (c2[0] - c1[0])\\r\\n    }\\r\\n    const diff =  findDiff(coordinates[0], coordinates[1])\\r\\n    for (let i = 0; i < coordinates.length - 1; i++) {\\r\\n        if (diff !== findDiff(coordinates[i], coordinates[i + 1]))\\r\\n            return false\\r\\n    }\\r\\n    return true\\r\\n};\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2797413,
                "title": "python-easy-solution",
                "content": "\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\r\\n        slope =0\\r\\n        for i in range(len(coordinates)-1):\\r\\n            x1,y1=coordinates[i]\\r\\n            x2,y2=coordinates[i+1]\\r\\n            if x2-x1==0:\\r\\n            #vertical line #m=slope\\r\\n                m=float(\\'inf\\')\\r\\n            else:\\r\\n                m=(y2-y1)/(x2-x1)\\r\\n            if slope==0:\\r\\n                slope=m\\r\\n            else :\\r\\n                if slope!=m:\\r\\n                    return False\\r\\n        return True \\r\\n        \\r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\r\\n        slope =0\\r\\n        for i in range(len(coordinates)-1):\\r\\n            x1,y1=coordinates[i]\\r\\n            x2,y2=coordinates[i+1]\\r\\n            if x2-x1==0:\\r\\n            #vertical line #m=slope\\r\\n                m=float(\\'inf\\')\\r\\n            else:\\r\\n                m=(y2-y1)/(x2-x1)\\r\\n            if slope==0:\\r\\n                slope=m\\r\\n            else :\\r\\n                if slope!=m:\\r\\n                    return False\\r\\n        return True \\r\\n        \\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634780,
                "title": "java-solution",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS**\\n```\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        int points = coordinates.length;\\n        int a1 = (coordinates[1][0] - coordinates[0][0]);\\n        int b1 = (coordinates[1][1] - coordinates[0][1]);\\n        for(int i = 2; i < points; ++i){\\n            int c1 = (coordinates[i][0] - coordinates[i-1][0]);\\n            int d1 = (coordinates[i][1] - coordinates[i-1][1]);\\n            if(b1*c1 != a1*d1){\\n            return false;\\n        }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        int points = coordinates.length;\\n        int a1 = (coordinates[1][0] - coordinates[0][0]);\\n        int b1 = (coordinates[1][1] - coordinates[0][1]);\\n        for(int i = 2; i < points; ++i){\\n            int c1 = (coordinates[i][0] - coordinates[i-1][0]);\\n            int d1 = (coordinates[i][1] - coordinates[i-1][1]);\\n            if(b1*c1 != a1*d1){\\n            return false;\\n        }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232307,
                "title": "java-solution-best-soluiton",
                "content": "```\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        int n = coordinates.length;\\n        for (int i=0;i<n-2;i++){\\n            if ((coordinates[i+1][1]-coordinates[i][1])*(coordinates[i+2][0] - coordinates[i+1][0])!=(coordinates[i+2][1]-coordinates[i+1][1])*(coordinates[i+1][0]-                            coordinates[i][0])){\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}\\n\\n```\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/fc11e159-96ef-4013-ac81-2169aab78c90_1656851222.649285.jpeg)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        int n = coordinates.length;\\n        for (int i=0;i<n-2;i++){\\n            if ((coordinates[i+1][1]-coordinates[i][1])*(coordinates[i+2][0] - coordinates[i+1][0])!=(coordinates[i+2][1]-coordinates[i+1][1])*(coordinates[i+1][0]-                            coordinates[i][0])){\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181366,
                "title": "simple-c-solution",
                "content": "\\t\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tbool checkStraightLine(vector<vector<int>>& c) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint p=c.size();\\n\\t\\t\\t\\t\\tint XD=(c[1][0]-c[0][0]);\\n\\t\\t\\t\\t\\tint YD=(c[1][1]-c[0][1]);\\n\\t\\t\\t\\t\\tint CXD=0,CYD=0;\\n\\t\\t\\t\\t\\tfor(int i=2;i<p;++i)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t   CXD=(c[i][0]-c[i-1][0]);\\n\\t\\t\\t\\t\\t   CYD=(c[i][1]-c[i-1][1]);\\n\\t\\t\\t\\t\\t   if(CXD*YD != CYD*XD)\\n\\t\\t\\t\\t\\t\\t\\treturn false;  \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tbool checkStraightLine(vector<vector<int>>& c) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint p=c.size();\\n\\t\\t\\t\\t\\tint XD=(c[1][0]-c[0][0]);\\n\\t\\t\\t\\t\\tint YD=(c[1][1]-c[0][1]);\\n\\t\\t\\t\\t\\tint CXD=0,CYD=0;\\n\\t\\t\\t\\t\\tfor(int i=2;i<p;++i)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t   CXD=(c[i][0]-c[i-1][0]);\\n\\t\\t\\t\\t\\t   CYD=(c[i][1]-c[i-1][1]);\\n\\t\\t\\t\\t\\t   if(CXD*YD != CYD*XD)\\n\\t\\t\\t\\t\\t\\t\\treturn false;  \\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2126422,
                "title": "memory-usage-14-3-mb-less-than-98-84-of-python3",
                "content": "**A straight line passing through points (x1 , y1) and (x2 , y2) is given by in the two point form as: y - y1 = [(y2 - y1) / (x2 - x1)] (x - x1).**\\n\\n![image](https://assets.leetcode.com/users/images/7ac80ce7-f906-4817-b0b3-8b6227f0d5da_1654688014.7324538.png)\\n\\n```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        \\n        x0, y0 = coordinates[0]\\n        x1, y1 = coordinates[1]\\n        \\n        dy = y1 - y0\\n        dx = x1 - x0\\n        \\n        for i in range(len(coordinates)):\\n            x = coordinates[i][0]\\n            y = coordinates[i][1]\\n            \\n            if dx*(y - y1) != dy*(x - x1):\\n                return False\\n        else:\\n            return True\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        \\n        x0, y0 = coordinates[0]\\n        x1, y1 = coordinates[1]\\n        \\n        dy = y1 - y0\\n        dx = x1 - x0\\n        \\n        for i in range(len(coordinates)):\\n            x = coordinates[i][0]\\n            y = coordinates[i][1]\\n            \\n            if dx*(y - y1) != dy*(x - x1):\\n                return False\\n        else:\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015728,
                "title": "my-java-o-n-solution-beats-100-of-submissions",
                "content": "```\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        int x0 = coordinates[0][0], y0 = coordinates[0][1], \\n            x1 = coordinates[1][0], y1 = coordinates[1][1];\\n        int dx = x1 - x0, dy = y1 - y0;\\n        for (int[] co : coordinates) {\\n            int x = co[0], y = co[1];\\n            if (dx * (y - y1) != dy * (x - x1))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        int x0 = coordinates[0][0], y0 = coordinates[0][1], \\n            x1 = coordinates[1][0], y1 = coordinates[1][1];\\n        int dx = x1 - x0, dy = y1 - y0;\\n        for (int[] co : coordinates) {\\n            int x = co[0], y = co[1];\\n            if (dx * (y - y1) != dy * (x - x1))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1835466,
                "title": "100-beat-0ms-easiest-java-solution-with-just-one-calculation",
                "content": "```\\n**class Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        Boolean ans = true;\\n        for(int i=0; i<coordinates.length-2 ; i++){\\n           if((coordinates[i+1][1]-coordinates[i][1])*(coordinates[i+2][0]-coordinates[i+1][0])!=(coordinates[i+2][1]-coordinates[i+1][1])*(coordinates[i+1][0]-coordinates[i][0])){\\n               ans=false;\\n           }\\n        }\\n        return ans;\\n\\n     }\\n}\\n```\\nSo there is just one calculation of checking slope. As we know , for linear points, this equation\\n**(y2-y1)/(x2-x1)=(y3-y2)/(x3-x2)**\\nmust follow , so i converted this into its different form-\\n**(y2-y1)*(x3-x2)=(y3-y2)*(x2-x1)**\\nthis will confirm the slope and will return value accordingly\\n\\n**Please upvote if you like it**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n**class Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        Boolean ans = true;\\n        for(int i=0; i<coordinates.length-2 ; i++){\\n           if((coordinates[i+1][1]-coordinates[i][1])*(coordinates[i+2][0]-coordinates[i+1][0])!=(coordinates[i+2][1]-coordinates[i+1][1])*(coordinates[i+1][0]-coordinates[i][0])){\\n               ans=false;\\n           }\\n        }\\n        return ans;\\n\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764725,
                "title": "c-simple-code-with-explanation",
                "content": "The slope for a line through any 2 points (x0, y0) and (x1, y1) is  ` (y1 - y0) / (x1 - x0)`\\nThe slope for a line through any 2 points (x1,y1) and (x,y) is ` (y-y1) / (x-x1)`\\nif these 3 points are in straight line the 2 slopes must be equal;\\n\\nslope formula\\n\\n`(y - y1) / (x - x1) = (y1 - y0) / (x1 - x0)`\\n\\nIn multiplication form:\\n\\n```\\n(x1 - x0) * (y - y1) = (x - x1) * (y1 - y0) \\n\\na * (y - y1) = b * (x - x1),    where a = x1 - x0 and b = y1 - y0\\n```\\n\\n\\n\\nclass Solution {\\npublic:\\n   ```\\n bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int a=coordinates[0][0]-coordinates[1][0]; //Difference between 1st and 2nd point\\'s x \\n        int b=coordinates[0][1]-coordinates[1][1]; //Difference between 1st and 2nd point\\'s y \\n        for(int i=2;i<coordinates.size();i++)\\n        {\\n            int x=coordinates[i][0]; //current point\\'s x\\n            int y=coordinates[i][1]; //current point\\'s y\\n            if( a*(y-coordinates[0][1]) != b*(x-coordinates[0][0]) ) //slope formula\\n                return 0;\\n        }\\n            \\n    return 1;\\n    }\\n```\\n};\\n\\n\\nUpvote if you find its helpful :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n(x1 - x0) * (y - y1) = (x - x1) * (y1 - y0) \\n\\na * (y - y1) = b * (x - x1),    where a = x1 - x0 and b = y1 - y0\\n```\n```\\n bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int a=coordinates[0][0]-coordinates[1][0]; //Difference between 1st and 2nd point\\'s x \\n        int b=coordinates[0][1]-coordinates[1][1]; //Difference between 1st and 2nd point\\'s y \\n        for(int i=2;i<coordinates.size();i++)\\n        {\\n            int x=coordinates[i][0]; //current point\\'s x\\n            int y=coordinates[i][1]; //current point\\'s y\\n            if( a*(y-coordinates[0][1]) != b*(x-coordinates[0][0]) ) //slope formula\\n                return 0;\\n        }\\n            \\n    return 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1749588,
                "title": "c-100-faster-easy-upvote-if-you-like",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        if(coordinates.size()==2)\\n            return true;\\n        \\n        int dx=(coordinates[1][1]-coordinates[0][1]);\\n        int dy=(coordinates[1][0]-coordinates[0][0]);\\n        for(int i=2;i<coordinates.size();i++)\\n        {\\n            if(dx * (coordinates[i][0] - coordinates[1][0]) != dy * (coordinates[i][1] - coordinates[1][1]) )\\n                return false;\\n        }\\n    return true;\\n    }\\n    \\n    \\n};\\n```\\n![image](https://assets.leetcode.com/users/images/8b7cd209-7faf-46dd-991f-db464efe316e_1644140362.1055171.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        if(coordinates.size()==2)\\n            return true;\\n        \\n        int dx=(coordinates[1][1]-coordinates[0][1]);\\n        int dy=(coordinates[1][0]-coordinates[0][0]);\\n        for(int i=2;i<coordinates.size();i++)\\n        {\\n            if(dx * (coordinates[i][0] - coordinates[1][0]) != dy * (coordinates[i][1] - coordinates[1][1]) )\\n                return false;\\n        }\\n    return true;\\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351337,
                "title": "python-solution-o-n-check-slope",
                "content": "```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        x0, y0 = coordinates[0]\\n        x1, y1 = coordinates[1]\\n\\n        dy = y1 - y0\\n        dx = x1 - x0\\n\\n        m = dy*x0 - dx*y0\\n\\n        for x, y in coordinates:\\n            if dy*x - dx*y != m:\\n                return False\\n\\n        return True\\n```\\n        \\n\\n### To avoid divide by zero error\\ndy   y2-y1\\n-- = -----  --> dy(x2 - x1) = dx(y2-y1) --> dy*x2 - dy*x1 = dx*y2 - dx*y1\\ndx   x2-x1\\n\\ndy*x1 - dx*y1 = dy*x2 - dx*y2\\n\\nnow we only take one side term to compare.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        x0, y0 = coordinates[0]\\n        x1, y1 = coordinates[1]\\n\\n        dy = y1 - y0\\n        dx = x1 - x0\\n\\n        m = dy*x0 - dx*y0\\n\\n        for x, y in coordinates:\\n            if dy*x - dx*y != m:\\n                return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1073145,
                "title": "math-python3",
                "content": "```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        x1, y1 = coordinates[0]\\n        x2, y2 = coordinates[1]\\n        \\n        m1 = x2-x1\\n        m2 = y2-y1 \\n        \\n        for i in range(2, len(coordinates)):\\n            x, y = coordinates[i]\\n            if (x - x1) * m2 != (y-y1)*m1:\\n                return False \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        x1, y1 = coordinates[0]\\n        x2, y2 = coordinates[1]\\n        \\n        m1 = x2-x1\\n        m2 = y2-y1 \\n        \\n        for i in range(2, len(coordinates)):\\n            x, y = coordinates[i]\\n            if (x - x1) * m2 != (y-y1)*m1:\\n                return False \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827037,
                "title": "javascript-solution",
                "content": "```\\nvar checkStraightLine = function (coordinates) {\\n  var [[x0, y0], [x1, y1]] = coordinates,\\n    slope = (y1 - y0) / (x1 - x0);\\n\\n  return (\\n    coordinates.every(([x, y], i) => (y - y0) / (x - x0) === slope || !i) ||\\n    coordinates.every(([x, _]) => x == x0)\\n  );\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkStraightLine = function (coordinates) {\\n  var [[x0, y0], [x1, y1]] = coordinates,\\n    slope = (y1 - y0) / (x1 - x0);\\n\\n  return (\\n    coordinates.every(([x, y], i) => (y - y0) / (x - x0) === slope || !i) ||\\n    coordinates.every(([x, _]) => x == x0)\\n  );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 621469,
                "title": "python-simple-solution-56-ms-faster-than-92-34",
                "content": "```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        x0 = coordinates[0][0]\\n        y0 = coordinates[0][1]\\n        \\n        x1 = coordinates[1][0]\\n        y1 = coordinates[1][1]\\n        \\n        if x0 == x1:\\n            for [x,y] in coordinates[2:]:\\n                if x != x0:\\n                    return False\\n            return True\\n        slope = (y1-y0)/(x1-x0)\\n        \\n        for [x,y] in coordinates[2:]:\\n            delta_y = y - y0\\n            delta_x = x - x0\\n            if slope*delta_x != delta_y:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        x0 = coordinates[0][0]\\n        y0 = coordinates[0][1]\\n        \\n        x1 = coordinates[1][0]\\n        y1 = coordinates[1][1]\\n        \\n        if x0 == x1:\\n            for [x,y] in coordinates[2:]:\\n                if x != x0:\\n                    return False\\n            return True\\n        slope = (y1-y0)/(x1-x0)\\n        \\n        for [x,y] in coordinates[2:]:\\n            delta_y = y - y0\\n            delta_x = x - x0\\n            if slope*delta_x != delta_y:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620689,
                "title": "java",
                "content": "```\\nclass Solution {\\n    // avoid divide by zero\\n    // y2 - y1   =  y3 - y4\\n    // x2 - x1      x3 - x4\\n    // (y2 - y1) (x4 - x3) = (y4 - y3)(x2 - x1)\\n        \\n    // dy = y2 - y1\\n    // dx = x2 - x1\\n    // dy2 = y4 - y3\\n    // dx2 = x4 - x3\\n    // had to look up formula for slope lol, haven\\'t used it in a while\\n    public boolean checkStraightLine(int[][] coordinates) {\\n\\n        int dy = coordinates[1][1] - coordinates[0][1];\\n        int dx = coordinates[1][0] - coordinates[0][0];\\n        \\n        \\n        for(int i = 2; i < coordinates.length; i++){\\n            int dy2 = coordinates[i][1] - coordinates[i - 1][1];\\n            int dx2 = coordinates[i][0] - coordinates[i - 1][0];\\n            \\n            if(dy * dx2 != dx * dy2){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // avoid divide by zero\\n    // y2 - y1   =  y3 - y4\\n    // x2 - x1      x3 - x4\\n    // (y2 - y1) (x4 - x3) = (y4 - y3)(x2 - x1)\\n        \\n    // dy = y2 - y1\\n    // dx = x2 - x1\\n    // dy2 = y4 - y3\\n    // dx2 = x4 - x3\\n    // had to look up formula for slope lol, haven\\'t used it in a while\\n    public boolean checkStraightLine(int[][] coordinates) {\\n\\n        int dy = coordinates[1][1] - coordinates[0][1];\\n        int dx = coordinates[1][0] - coordinates[0][0];\\n        \\n        \\n        for(int i = 2; i < coordinates.length; i++){\\n            int dy2 = coordinates[i][1] - coordinates[i - 1][1];\\n            int dx2 = coordinates[i][0] - coordinates[i - 1][0];\\n            \\n            if(dy * dx2 != dx * dy2){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 465312,
                "title": "python3-98-56ms",
                "content": "```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        (x0, y0), (x1, y1) = coordinates[:2]\\n        try:\\n            m = (y0 - y1) / (x0 - x1)\\n            for i in range(2, len(coordinates)):\\n                (x0, y0), (x1, y1) = coordinates[i], coordinates[i-1]\\n                if abs(m - (y0 - y1) / (x0 - x1)) > 0.00001:  # account for floating point inaccuracy\\n                    return False\\n            return True\\n        except ZeroDivisionError:\\n            return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        (x0, y0), (x1, y1) = coordinates[:2]\\n        try:\\n            m = (y0 - y1) / (x0 - x1)\\n            for i in range(2, len(coordinates)):\\n                (x0, y0), (x1, y1) = coordinates[i], coordinates[i-1]\\n                if abs(m - (y0 - y1) / (x0 - x1)) > 0.00001:  # account for floating point inaccuracy\\n                    return False\\n            return True\\n        except ZeroDivisionError:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423167,
                "title": "javascript-easy-and-fast",
                "content": "```\\nvar checkStraightLine = function(arr) {\\n    // if there are maximum 2 points, it\\'s a line\\n    if(arr.length <= 2) return true;\\n    \\n    // slope is diff between 1st and 2nd point\\n    let x1 = arr[0][0], y1 = arr[0][1], slope = (arr[1][1] - y1) / (arr[1][0] - x1);\\n    \\n    // slope for all other points should be same as first 2\\n    for(let i = 2; i < arr.length;i++){ \\n        if((arr[i][1] - y1)  !== slope * (arr[i][0]  - x1)) return false;\\n    }\\n    return true; \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkStraightLine = function(arr) {\\n    // if there are maximum 2 points, it\\'s a line\\n    if(arr.length <= 2) return true;\\n    \\n    // slope is diff between 1st and 2nd point\\n    let x1 = arr[0][0], y1 = arr[0][1], slope = (arr[1][1] - y1) / (arr[1][0] - x1);\\n    \\n    // slope for all other points should be same as first 2\\n    for(let i = 2; i < arr.length;i++){ \\n        if((arr[i][1] - y1)  !== slope * (arr[i][0]  - x1)) return false;\\n    }\\n    return true; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 417107,
                "title": "python-solution",
                "content": "If there are two or fewer points, they are guaranteed to lie on a straight line. \\n\\nOtherwise, taking the first point as the *offset*, and the vector from the first to the second point as the *direction vector*, we\\'d like to check that the direction vector is colinear with the vector from the offset to any of the remaining points.\\n\\nWe don\\'t use any division so that we can stay in the realm of integers to avoid any precision problems that might arise with floating point numbers. We can check the colinearity of two vectors *[a,b]* and *[c,d]* by checking that *ad = bc*. \\n\\n```python\\nclass Solution:\\n    \\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        if len(coordinates) <= 2:\\n            return True\\n        \\n        def sub(v1, v2):\\n\\t\\t    \"Helper for subtracting one vector from another.\"\\n            return (v1[0]-v2[0], v1[1]-v2[1])\\n        \\n        def colinear(v1, v2):\\n\\t\\t    \"Helper for checking colinearity of vectors.\"\\n            return v1[0]*v2[1] == v1[1]*v2[0]\\n        \\n        offset = coordinates[0]\\n        direction = sub(coordinates[1], offset)\\n        \\n        return all(\\n            colinear(sub(coord, offset), direction)\\n            for coord in coordinates[2:]\\n        )\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    \\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        if len(coordinates) <= 2:\\n            return True\\n        \\n        def sub(v1, v2):\\n\\t\\t    \"Helper for subtracting one vector from another.\"\\n            return (v1[0]-v2[0], v1[1]-v2[1])\\n        \\n        def colinear(v1, v2):\\n\\t\\t    \"Helper for checking colinearity of vectors.\"\\n            return v1[0]*v2[1] == v1[1]*v2[0]\\n        \\n        offset = coordinates[0]\\n        direction = sub(coordinates[1], offset)\\n        \\n        return all(\\n            colinear(sub(coord, offset), direction)\\n            for coord in coordinates[2:]\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613659,
                "title": "straight-line-the-stupid-way",
                "content": "# Intuition\\r\\nWe only need to check the change in delta once, since it\\'s supposed to be the same throughout.\\r\\n\\r\\n# Approach\\r\\nThis is the monkey approach, basically calculate the delta between our first two points and make sure it never changes. If the x value never changes we just set it to 2^32, the highest possible.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n$$O(n)$$ I think\\r\\n\\r\\n- Space complexity:\\r\\nShould be $$O(1)$$ \\r\\n\\r\\n# Code\\r\\n```\\r\\nimpl Solution {\\r\\n    pub fn check_straight_line(coordinates: Vec<Vec<i32>>) -> bool {\\r\\n        let mut prevx = coordinates[0][0];\\r\\n        let mut prevy = coordinates[0][1];\\r\\n        let mut xdiff = coordinates[1][0] - prevx;\\r\\n        let mut ydiff = coordinates[1][1] - prevy;\\r\\n        let mut tilt = 0;\\r\\n        if xdiff != 0 && ydiff != 0{\\r\\n            tilt = ydiff/xdiff;\\r\\n        } else if xdiff == 0 {\\r\\n            tilt = 2^32;\\r\\n        }\\r\\n        for coord in coordinates.iter().skip(1){\\r\\n            if (coord[0] - prevx) != 0 && (coord[1] - prevy) != 0{\\r\\n                if ((coord[1] - prevy)/(coord[0] - prevx)) != tilt {\\r\\n                    return false\\r\\n                }else{\\r\\n                    prevx = coord[0];\\r\\n                    prevy = coord[1];\\r\\n                }\\r\\n            }else if (coord[0] - prevx) == 0{\\r\\n                if xdiff != coord[0] - prevx{\\r\\n                    return false\\r\\n                }else{\\r\\n                    prevx = coord[0];\\r\\n                    prevy = coord[1];\\r\\n                }\\r\\n            }else {\\r\\n                if ydiff != coord[1] - prevy{\\r\\n                    return false\\r\\n                }else{\\r\\n                    prevx = coord[0];\\r\\n                    prevy = coord[1];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return true\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\r\\nimpl Solution {\\r\\n    pub fn check_straight_line(coordinates: Vec<Vec<i32>>) -> bool {\\r\\n        let mut prevx = coordinates[0][0];\\r\\n        let mut prevy = coordinates[0][1];\\r\\n        let mut xdiff = coordinates[1][0] - prevx;\\r\\n        let mut ydiff = coordinates[1][1] - prevy;\\r\\n        let mut tilt = 0;\\r\\n        if xdiff != 0 && ydiff != 0{\\r\\n            tilt = ydiff/xdiff;\\r\\n        } else if xdiff == 0 {\\r\\n            tilt = 2^32;\\r\\n        }\\r\\n        for coord in coordinates.iter().skip(1){\\r\\n            if (coord[0] - prevx) != 0 && (coord[1] - prevy) != 0{\\r\\n                if ((coord[1] - prevy)/(coord[0] - prevx)) != tilt {\\r\\n                    return false\\r\\n                }else{\\r\\n                    prevx = coord[0];\\r\\n                    prevy = coord[1];\\r\\n                }\\r\\n            }else if (coord[0] - prevx) == 0{\\r\\n                if xdiff != coord[0] - prevx{\\r\\n                    return false\\r\\n                }else{\\r\\n                    prevx = coord[0];\\r\\n                    prevy = coord[1];\\r\\n                }\\r\\n            }else {\\r\\n                if ydiff != coord[1] - prevy{\\r\\n                    return false\\r\\n                }else{\\r\\n                    prevx = coord[0];\\r\\n                    prevy = coord[1];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return true\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3602188,
                "title": "typescript-solution-runtime-beats-96-36-memory-beats-100-explained",
                "content": "![check if it is a straight line.PNG](https://assets.leetcode.com/users/images/58ae45a1-a274-4249-b45e-dab2de6071f1_1685998087.723891.png)\\r\\n\\r\\n\\r\\n# Intuition\\r\\nCalculate a & b in y = ax + b then check if coordinates[i] is alligned with our line by replacing y and x and validating the equation.\\r\\n# Approach\\r\\n1. We start by calculating `deltaY` and `deltaX`, which are used to calculate the slope `a` and the y-intercept `b`. They are generated from the first two coordinates because we only need to check if the remaining coordinates are on the same line.\\r\\n2. `a` is generated by dividing `deltaY` by `deltaX`.\\r\\n3. `b` is generated by using the first coordinate and calculating `b = y - a * x`.\\r\\n4. If `deltaX === 0` this means we have a vertical line, then we check if all the points have the same x-axis coordinate `coordinate[i][0]`, if not we return false.\\r\\n5. If `deltaY === 0` this means we have a horizontal line, then we check if all the points have the same y-axis coordinate `coordinate[i][1]`, if not we return false.\\r\\n6. If neither `deltaX` nor `deltaY` are 0, then we check the y = ax + b equation for every coordinate, and if it is not validated we return false. \\r\\n7. If no single case fails, we return true.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:O(N)\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:O(1)\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nfunction checkStraightLine(coordinates: number[][], deltaY = null, deltaX = null, a = null, b = null): boolean {\\r\\n  deltaY = coordinates[1][1] - coordinates[0][1]\\r\\n  deltaX = coordinates[1][0] - coordinates[0][0]\\r\\n  a = deltaY/deltaX\\r\\n  b = coordinates[0][1] - a * coordinates[0][0]\\r\\n  for ( let i = 1; i < coordinates.length; i++ ) {\\r\\n    if ( deltaX === 0 ) {\\r\\n      if ( coordinates[i][0] !== coordinates[i - 1][0]) return false\\r\\n    }\\r\\n    else if ( deltaY === 0 ) {\\r\\n      if ( coordinates[i][1] !== coordinates[i - 1][1]) return false\\r\\n    }\\r\\n    else {\\r\\n      if ( coordinates[i][1] !== a*coordinates[i][0] + b ) return false\\r\\n    }\\r\\n  } \\r\\n  return true\\r\\n};\\r\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\r\\nfunction checkStraightLine(coordinates: number[][], deltaY = null, deltaX = null, a = null, b = null): boolean {\\r\\n  deltaY = coordinates[1][1] - coordinates[0][1]\\r\\n  deltaX = coordinates[1][0] - coordinates[0][0]\\r\\n  a = deltaY/deltaX\\r\\n  b = coordinates[0][1] - a * coordinates[0][0]\\r\\n  for ( let i = 1; i < coordinates.length; i++ ) {\\r\\n    if ( deltaX === 0 ) {\\r\\n      if ( coordinates[i][0] !== coordinates[i - 1][0]) return false\\r\\n    }\\r\\n    else if ( deltaY === 0 ) {\\r\\n      if ( coordinates[i][1] !== coordinates[i - 1][1]) return false\\r\\n    }\\r\\n    else {\\r\\n      if ( coordinates[i][1] !== a*coordinates[i][0] + b ) return false\\r\\n    }\\r\\n  } \\r\\n  return true\\r\\n};\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3601995,
                "title": "100-fastest-and-easiest-solutions",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n- O(n)\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n- o(1)\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n    public boolean checkStraightLine(int[][] coordinates) {\\r\\n        if(coordinates.length==2) return true;\\r\\n        int checknext=0;\\r\\n        int check=0;\\r\\n        int dy=coordinates[1][1]-coordinates[0][1];\\r\\n        int dx=coordinates[1][0]-coordinates[0][0];\\r\\n        if(dx==0) check=Integer.MAX_VALUE;\\r\\n        double m=(1.0)*dy/dx;\\r\\n        for(int i=2;i<coordinates.length;i++){\\r\\n        int dynext=coordinates[i][1]-coordinates[i-1][1];\\r\\n        int dxnext=coordinates[i][0]-coordinates[i-1][0];\\r\\n        if(dxnext==0&&dx==0) continue; \\r\\n        double mnext=(1.0)*dynext/dxnext;\\r\\n        if(m!=mnext) return false;\\r\\n        }\\r\\n      return true;  \\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    public boolean checkStraightLine(int[][] coordinates) {\\r\\n        if(coordinates.length==2) return true;\\r\\n        int checknext=0;\\r\\n        int check=0;\\r\\n        int dy=coordinates[1][1]-coordinates[0][1];\\r\\n        int dx=coordinates[1][0]-coordinates[0][0];\\r\\n        if(dx==0) check=Integer.MAX_VALUE;\\r\\n        double m=(1.0)*dy/dx;\\r\\n        for(int i=2;i<coordinates.length;i++){\\r\\n        int dynext=coordinates[i][1]-coordinates[i-1][1];\\r\\n        int dxnext=coordinates[i][0]-coordinates[i-1][0];\\r\\n        if(dxnext==0&&dx==0) continue; \\r\\n        double mnext=(1.0)*dynext/dxnext;\\r\\n        if(m!=mnext) return false;\\r\\n        }\\r\\n      return true;  \\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601787,
                "title": "simplest-solution-ever-c",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n\\r\\n        int points = coordinates.size();\\r\\n        int xdiff = (coordinates[1][0]- coordinates[0][0]);\\r\\n        int ydiff = (coordinates[1][1]- coordinates[0][1]);\\r\\n        int curr_ydiff, curr_xdiff;\\r\\n\\r\\n        for(int i=2; i<points; ++i){\\r\\n\\r\\n\\r\\n          curr_xdiff = (coordinates[i][0]- coordinates[i-1][0]);\\r\\n          curr_ydiff = (coordinates[i][1]- coordinates[i-1][1]);\\r\\n\\r\\n          if(ydiff*curr_xdiff != xdiff*curr_ydiff)\\r\\n          return false; \\r\\n        }\\r\\n        return true;\\r\\n        \\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n\\r\\n        int points = coordinates.size();\\r\\n        int xdiff = (coordinates[1][0]- coordinates[0][0]);\\r\\n        int ydiff = (coordinates[1][1]- coordinates[0][1]);\\r\\n        int curr_ydiff, curr_xdiff;\\r\\n\\r\\n        for(int i=2; i<points; ++i){\\r\\n\\r\\n\\r\\n          curr_xdiff = (coordinates[i][0]- coordinates[i-1][0]);\\r\\n          curr_ydiff = (coordinates[i][1]- coordinates[i-1][1]);\\r\\n\\r\\n          if(ydiff*curr_xdiff != xdiff*curr_ydiff)\\r\\n          return false; \\r\\n        }\\r\\n        return true;\\r\\n        \\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601171,
                "title": "straight-line-formula",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n  \\n    bool checkStraightLine(vector<vector<int>>& c) {\\n        int n  = c.size();\\n        if(n<2)\\n            return true;\\n        int xx = (c[0][0]-c[1][0]);\\n        int yy = (c[0][1]-c[1][1]);\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int val1 = c[i][0]-c[0][0];\\n            int val2 = (c[i][1]-c[0][1]);\\n            \\n            if(val2 * xx != val1 * yy)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n  \\n    bool checkStraightLine(vector<vector<int>>& c) {\\n        int n  = c.size();\\n        if(n<2)\\n            return true;\\n        int xx = (c[0][0]-c[1][0]);\\n        int yy = (c[0][1]-c[1][1]);\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int val1 = c[i][0]-c[0][0];\\n            int val2 = (c[i][1]-c[0][1]);\\n            \\n            if(val2 * xx != val1 * yy)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600554,
                "title": "area-of-triangle-unique-approach",
                "content": "# Intuition\\r\\nWe know for 3 points to collinear  **Area must be zero** so using the formula we can check.\\r\\n\\r\\n# Approach\\r\\nTake first 2 points as reference and iterate in array check with remaining coordinates whether area is zero or not.\\r\\n\\r\\n**Area = (1/2) | x1(y2 \\u2212 y3) + x2(y3 \\u2212 y1) + x3(y1 \\u2212 y2) |**\\r\\n\\r\\nNo need to take mod and divide by 2 since not necessary.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: **O(n)**\\r\\n\\r\\n\\r\\n- Space complexity: **O(1)**\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        \\r\\n        // For Triangle if coordinates are (x1,y1),(x2,y2),(x3,y3) then:\\r\\n        // Area = (1/2) | x1(y2 \\u2212 y3) + x2(y3 \\u2212 y1) + x3(y1 \\u2212 y2) |\\r\\n        // so area must be zero for collinear of 3 points\\r\\n        // so no need to take mod and div by 2 for this;\\r\\n\\r\\n        int n=coordinates.size();\\r\\n        int x1=coordinates[0][0];\\r\\n        int y1=coordinates[0][1];\\r\\n        int x2=coordinates[1][0];\\r\\n        int y2=coordinates[1][1];\\r\\n\\r\\n        int area,x3,y3;\\r\\n        for(int i=2;i<n;i++)\\r\\n        {\\r\\n            x3=coordinates[i][0];\\r\\n            y3=coordinates[i][1];\\r\\n            area= x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2);\\r\\n            if(area)return false;\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        \\r\\n        // For Triangle if coordinates are (x1,y1),(x2,y2),(x3,y3) then:\\r\\n        // Area = (1/2) | x1(y2 \\u2212 y3) + x2(y3 \\u2212 y1) + x3(y1 \\u2212 y2) |\\r\\n        // so area must be zero for collinear of 3 points\\r\\n        // so no need to take mod and div by 2 for this;\\r\\n\\r\\n        int n=coordinates.size();\\r\\n        int x1=coordinates[0][0];\\r\\n        int y1=coordinates[0][1];\\r\\n        int x2=coordinates[1][0];\\r\\n        int y2=coordinates[1][1];\\r\\n\\r\\n        int area,x3,y3;\\r\\n        for(int i=2;i<n;i++)\\r\\n        {\\r\\n            x3=coordinates[i][0];\\r\\n            y3=coordinates[i][1];\\r\\n            area= x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2);\\r\\n            if(area)return false;\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600261,
                "title": "simple-solution",
                "content": "\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        const auto& p0 = coordinates[0];\\r\\n        const auto& p1 = coordinates[1];\\r\\n        const int x0 = p0[0];\\r\\n        const int y0 = p0[1];\\r\\n        const int x1 = p1[0];\\r\\n        const int y1 = p1[1];\\r\\n        for (int i = 2; i < coordinates.size(); i++) {\\r\\n            const auto& point = coordinates[i];\\r\\n            const int x = point[0];\\r\\n            const int y = point[1];\\r\\n\\r\\n            if ((x1 - x0) * (y - y0) != (y1 - y0) * (x - x0)) {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\r\\n        const auto& p0 = coordinates[0];\\r\\n        const auto& p1 = coordinates[1];\\r\\n        const int x0 = p0[0];\\r\\n        const int y0 = p0[1];\\r\\n        const int x1 = p1[0];\\r\\n        const int y1 = p1[1];\\r\\n        for (int i = 2; i < coordinates.size(); i++) {\\r\\n            const auto& point = coordinates[i];\\r\\n            const int x = point[0];\\r\\n            const int y = point[1];\\r\\n\\r\\n            if ((x1 - x0) * (y - y0) != (y1 - y0) * (x - x0)) {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599165,
                "title": "kotlin-python3-my-solution-with-time-o-n-and-space-o-1",
                "content": "The idea is to use the line formed by the first two points to examine all the points in `coordinates`. If all points lie on the line, they can make a straight line and we return true; otherwise, we return false. Try to avoid comparing Doubles due to potential precision issues, and be cautious of special cases involving vertical or horizontal lines. Additionally, since we are performing multiplication, we should check whether type Int can hold the values.\\n\\nBelow is my solution in kotlin,\\n```\\nclass Solution {\\n    /* Complexity:\\n     * Time O(N) and Space O(1) where N is the size of coordinates;\\n     */\\n    fun checkStraightLine(coordinates: Array<IntArray>): Boolean {\\n        val point1 = coordinates[0]\\n        val point2 = coordinates[1]\\n        return coordinates.all { point -> isStraightLine(point1, point2, point) }\\n    }\\n\\n    private fun isStraightLine(point1: IntArray, point2: IntArray, point3: IntArray): Boolean {\\n        val (x1, y1) = point1\\n        val (x2, y2) = point2\\n        val (x3, y3) = point3\\n        return (x2 - x1) * (y3 - y1) == (y2 - y1) * (x3 - x1)\\n    }\\n}\\n```\\nAnd the solution in python 3,\\n```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: list[list[int]]) -> bool:\\n        point1 = coordinates[0]\\n        point2 = coordinates[1]\\n        for point in coordinates:\\n            if not self.is_straight_line(point1, point2, point):\\n                return False\\n        return True\\n\\n    def is_straight_line(self, point1: list[int], point2: list[int], point3: list[int]) -> bool:\\n        (x1, y1) = point1\\n        (x2, y2) = point2\\n        (x3, y3) = point3\\n        return (x2 - x1) * (y3 - y1) == (y2 - y1) * (x3 - x1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    /* Complexity:\\n     * Time O(N) and Space O(1) where N is the size of coordinates;\\n     */\\n    fun checkStraightLine(coordinates: Array<IntArray>): Boolean {\\n        val point1 = coordinates[0]\\n        val point2 = coordinates[1]\\n        return coordinates.all { point -> isStraightLine(point1, point2, point) }\\n    }\\n\\n    private fun isStraightLine(point1: IntArray, point2: IntArray, point3: IntArray): Boolean {\\n        val (x1, y1) = point1\\n        val (x2, y2) = point2\\n        val (x3, y3) = point3\\n        return (x2 - x1) * (y3 - y1) == (y2 - y1) * (x3 - x1)\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: list[list[int]]) -> bool:\\n        point1 = coordinates[0]\\n        point2 = coordinates[1]\\n        for point in coordinates:\\n            if not self.is_straight_line(point1, point2, point):\\n                return False\\n        return True\\n\\n    def is_straight_line(self, point1: list[int], point2: list[int], point3: list[int]) -> bool:\\n        (x1, y1) = point1\\n        (x2, y2) = point2\\n        (x3, y3) = point3\\n        return (x2 - x1) * (y3 - y1) == (y2 - y1) * (x3 - x1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598812,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        x0,y0=coordinates[0]\\n        x1,y1=coordinates[1]\\n        for x,y in coordinates[2:]:\\n            if (y1-y0)*(x-x0)!=(y-y0)*(x1-x0):\\n                return False\\n\\n        return True        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        x0,y0=coordinates[0]\\n        x1,y1=coordinates[1]\\n        for x,y in coordinates[2:]:\\n            if (y1-y0)*(x-x0)!=(y-y0)*(x1-x0):\\n                return False\\n\\n        return True        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598578,
                "title": "daily-leetcoding-challenge-june-day-5",
                "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/check-if-it-is-a-straight-line/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Slope Property\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/check-if-it-is-a-straight-line/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3189183,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n         int a=coordinates[0][0]-coordinates[1][0]; \\n     int b=coordinates[0][1]-coordinates[1][1];\\n     for(int i=2;i<coordinates.size();i++)\\n     {\\n         int x=coordinates[i][0];\\n         int y=coordinates[i][1];\\n         if( a*(y-coordinates[0][1]) != b*(x-coordinates[0][0]) )\\n             return 0;\\n     }\\n         \\n    return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n         int a=coordinates[0][0]-coordinates[1][0]; \\n     int b=coordinates[0][1]-coordinates[1][1];\\n     for(int i=2;i<coordinates.size();i++)\\n     {\\n         int x=coordinates[i][0];\\n         int y=coordinates[i][1];\\n         if( a*(y-coordinates[0][1]) != b*(x-coordinates[0][0]) )\\n             return 0;\\n     }\\n         \\n    return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019970,
                "title": "simple-c-easy-solution",
                "content": "\\r\\n# Complexity\\r\\n- Time complexity:    O(n log(n))\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:  O(1)\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n   \\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& pt) {\\r\\n        int n = pt.size();\\r\\n        sort(pt.begin(),pt.end());\\r\\n        if( n == 1 || n == 2){\\r\\n            return true;\\r\\n        }\\r\\n        double slope = (double)(pt[1][1]-pt[0][1]) / (double)(pt[1][0] - pt[0][0]);\\r\\n        for(int i =1;i<n-1;i++){\\r\\n            double tempS = (double)(pt[i+1][1]-pt[i][1]) / (double)(pt[i+1][0] - pt[i][0]);\\r\\n            if( abs(tempS) != abs(slope)){\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    bool checkStraightLine(vector<vector<int>>& pt) {\\r\\n        int n = pt.size();\\r\\n        sort(pt.begin(),pt.end());\\r\\n        if( n == 1 || n == 2){\\r\\n            return true;\\r\\n        }\\r\\n        double slope = (double)(pt[1][1]-pt[0][1]) / (double)(pt[1][0] - pt[0][0]);\\r\\n        for(int i =1;i<n-1;i++){\\r\\n            double tempS = (double)(pt[i+1][1]-pt[i][1]) / (double)(pt[i+1][0] - pt[i][0]);\\r\\n            if( abs(tempS) != abs(slope)){\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887315,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public boolean checkStraightLine(int[][] coordinates) {\\n        int x0 = coordinates[0][0], y0 = coordinates[0][1], \\n            x1 = coordinates[1][0], y1 = coordinates[1][1];\\n        int dx = x1 - x0, dy = y1 - y0;\\n        for (int[] co : coordinates) {\\n            int x = co[0], y = co[1];\\n            if (dx * (y - y1) != dy * (x - x1))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public boolean checkStraightLine(int[][] coordinates) {\\n        int x0 = coordinates[0][0], y0 = coordinates[0][1], \\n            x1 = coordinates[1][0], y1 = coordinates[1][1];\\n        int dx = x1 - x0, dy = y1 - y0;\\n        for (int[] co : coordinates) {\\n            int x = co[0], y = co[1];\\n            if (dx * (y - y1) != dy * (x - x1))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657958,
                "title": "js-very-easy-solution",
                "content": "![image](https://assets.leetcode.com/users/images/8f126606-b4be-48d3-b9b9-d18545eb0450_1664853603.19047.png)\\n\\n```\\nvar isStraight = function([[ax,ay],[bx,by],[cx,cy]]) {\\n    return ((by-ay)*(cx-bx)===(cy-by)*(bx-ax));\\n};\\n\\nvar checkStraightLine = function(coordinates) {\\n    if (coordinates.length === 2) return true;\\n\\n    for (let i = 2; i < coordinates.length; i++) {\\n        if (!isStraight([coordinates[0], coordinates[1], coordinates[i]])) {\\n            return false;\\n        }\\n    }\\n        \\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isStraight = function([[ax,ay],[bx,by],[cx,cy]]) {\\n    return ((by-ay)*(cx-bx)===(cy-by)*(bx-ax));\\n};\\n\\nvar checkStraightLine = function(coordinates) {\\n    if (coordinates.length === 2) return true;\\n\\n    for (let i = 2; i < coordinates.length; i++) {\\n        if (!isStraight([coordinates[0], coordinates[1], coordinates[i]])) {\\n            return false;\\n        }\\n    }\\n        \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2578304,
                "title": "c-simple-and-easy-commented-code",
                "content": "If only one pt given -->return false\\n\\nIf two pt given -->always a straight line\\n\\nif  more than two pt given \\nslope of 1 line = slope of two\\nie\\n(x2-x1)/(y2-y1)==(x3-x2)/(y3-y2)\\n--> else false\\n\\n\\'\\'\\'\\n bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        \\n        if(coordinates.size()==1 || coordinates.size()==0)\\n        {\\n            return false;\\n        }\\n        \\n        if(coordinates.size()==2)\\n        {\\n            return true;\\n        }\\n        \\n        \\n        int x0 = coordinates[0][0], y0 = coordinates[0][1];\\n        int dx = coordinates[1][0] - x0, dy = coordinates[1][1] - y0;\\n        \\n        for (int i = 1; i < coordinates.size(); i++)\\n        {   \\n            // Checking two point formula for each point with the first point\\n            int x = coordinates[i][0], y = coordinates[i][1];\\n            if (dx * (y - y0) != dy * (x - x0))\\n            {\\n                        // Two point formula of line, if (x2-x1)*(y1-y0) = (x1-x0)(y2-y1), then a straight                              line, otherwise not\\n                return false;\\n            }  \\n\\t\\t\\t    \\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "If only one pt given -->return false\\n\\nIf two pt given -->always a straight line\\n\\nif  more than two pt given \\nslope of 1 line = slope of two\\nie\\n(x2-x1)/(y2-y1)==(x3-x2)/(y3-y2)\\n--> else false\\n\\n\\'\\'\\'\\n bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        \\n        if(coordinates.size()==1 || coordinates.size()==0)\\n        {\\n            return false;\\n        }\\n        \\n        if(coordinates.size()==2)\\n        {\\n            return true;\\n        }\\n        \\n        \\n        int x0 = coordinates[0][0], y0 = coordinates[0][1];\\n        int dx = coordinates[1][0] - x0, dy = coordinates[1][1] - y0;\\n        \\n        for (int i = 1; i < coordinates.size(); i++)\\n        {   \\n            // Checking two point formula for each point with the first point\\n            int x = coordinates[i][0], y = coordinates[i][1];\\n            if (dx * (y - y0) != dy * (x - x0))\\n            {\\n                        // Two point formula of line, if (x2-x1)*(y1-y0) = (x1-x0)(y2-y1), then a straight                              line, otherwise not\\n                return false;\\n            }  \\n\\t\\t\\t    \\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2414092,
                "title": "easy-understanding-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        //(y2-y1) = slope * (x2-x1)\\n\\t\\t//slope = (y2-y1)/(x2-x1)\\n\\t\\t//(y2\\'-y1\\')*(x2-x2) == (x2\\'-x1\\')*(y2-y1)\\n        int y = (coordinates[1][1]-coordinates[0][1]);\\n        int x = (coordinates[1][0]-coordinates[0][0]);\\n        for(int i=2;i<coordinates.size();i++){\\n            if((coordinates[i][1]-coordinates[i-1][1])*x!=(coordinates[i][0]-coordinates[i-1][0])*y)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        //(y2-y1) = slope * (x2-x1)\\n\\t\\t//slope = (y2-y1)/(x2-x1)\\n\\t\\t//(y2\\'-y1\\')*(x2-x2) == (x2\\'-x1\\')*(y2-y1)\\n        int y = (coordinates[1][1]-coordinates[0][1]);\\n        int x = (coordinates[1][0]-coordinates[0][0]);\\n        for(int i=2;i<coordinates.size();i++){\\n            if((coordinates[i][1]-coordinates[i-1][1])*x!=(coordinates[i][0]-coordinates[i-1][0])*y)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375536,
                "title": "python-basic-approach-with-explanation",
                "content": "here basic slope formula is used **y2-y1 / x2-x1**\\nso in each step we will see if  **y2-y1 / x2-x1 == y1-y / x1-x**\\nbut this may cause ZERO DIVISION ERROR hence we will simply change this equation in multiplication form   **y2-y1 / x2-x1 == y1-y / x1-x**   to **(y2-y1) ( x1-x ) ==(y1-y)(x2-x1)**\\n\\n\\tclass Solution:\\n\\t\\tdef checkStraightLine(self, list: List[List[int]]) -> bool:\\n\\t\\t\\tn=len(list)\\n\\t\\t\\tfor i in range(n-2):\\n\\t\\t\\t\\tif (list[i+1][1]-list[i][1])*(list[i+2][0]-list[i+1][0])!=(list[i+2][1]-list[i+1][1])*(list[i+1][0]-list[i][0]):\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True\\n\\nUpvote if this helped.",
                "solutionTags": [
                    "Python"
                ],
                "code": "here basic slope formula is used **y2-y1 / x2-x1**\\nso in each step we will see if  **y2-y1 / x2-x1 == y1-y / x1-x**\\nbut this may cause ZERO DIVISION ERROR hence we will simply change this equation in multiplication form   **y2-y1 / x2-x1 == y1-y / x1-x**   to **(y2-y1) ( x1-x ) ==(y1-y)(x2-x1)**\\n\\n\\tclass Solution:\\n\\t\\tdef checkStraightLine(self, list: List[List[int]]) -> bool:\\n\\t\\t\\tn=len(list)\\n\\t\\t\\tfor i in range(n-2):\\n\\t\\t\\t\\tif (list[i+1][1]-list[i][1])*(list[i+2][0]-list[i+1][0])!=(list[i+2][1]-list[i+1][1])*(list[i+1][0]-list[i][0]):\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True\\n\\nUpvote if this helped.",
                "codeTag": "Java"
            },
            {
                "id": 2320426,
                "title": "java-solution-easy-and-clean",
                "content": "class Solution \\n{\\n    public boolean checkStraightLine(int[][] coordinates) \\n    {\\n        int x1=coordinates[0][0];\\n        int y1=coordinates[0][1];\\n        int x2=coordinates[1][0];\\n        int y2=coordinates[1][1];\\n        for(int i=2;i<coordinates.length;i++)\\n        {\\n            int x3=coordinates[i][0];\\n            int y3=coordinates[i][1];\\n            if((y2-y1)*(x3-x1) != (x2-x1)*(y3-y1))\\n            return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution \\n{\\n    public boolean checkStraightLine(int[][] coordinates) \\n    {\\n        int x1=coordinates[0][0];\\n        int y1=coordinates[0][1];\\n        int x2=coordinates[1][0];\\n        int y2=coordinates[1][1];\\n        for(int i=2;i<coordinates.length;i++)\\n        {\\n            int x3=coordinates[i][0];\\n            int y3=coordinates[i][1];\\n            if((y2-y1)*(x3-x1) != (x2-x1)*(y3-y1))\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2297917,
                "title": "c",
                "content": "using the general equation of the line (y=kx+b), \\nconsider separately the case, when this line is vertical (it means x1=x2..xn)\\n```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int n = coordinates.size();\\n        if (n == 2) return true;\\n        for(int i = 2; i < n; i++) {\\n            int x = coordinates[i][0];\\n            int y = coordinates[i][1];\\n            int x1 = coordinates[0][0]; int y1 = coordinates[0][1]; int x2 = coordinates[1][0]; int y2 = coordinates[1][1];\\n            if(x1 != x2) {\\n            if(y != x*(y2-y1)/(x2-x1)+y1-x1*(y2-y1)/(x2-x1)) return false;\\n            }\\n            if(x1 == x2) {\\n                for(int i = 2; i < n; i++) {\\n                    if(coordinates[i][0] != x1) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\nupvote if it helped u",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int n = coordinates.size();\\n        if (n == 2) return true;\\n        for(int i = 2; i < n; i++) {\\n            int x = coordinates[i][0];\\n            int y = coordinates[i][1];\\n            int x1 = coordinates[0][0]; int y1 = coordinates[0][1]; int x2 = coordinates[1][0]; int y2 = coordinates[1][1];\\n            if(x1 != x2) {\\n            if(y != x*(y2-y1)/(x2-x1)+y1-x1*(y2-y1)/(x2-x1)) return false;\\n            }\\n            if(x1 == x2) {\\n                for(int i = 2; i < n; i++) {\\n                    if(coordinates[i][0] != x1) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182930,
                "title": "python-simple-python-solution-using-slope-concept",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 111 ms, faster than 25.34% of Python3 online submissions for Check If It Is a Straight Line.\\n# Memory Usage: 14.3 MB, less than 80.33% of Python3 online submissions for Check If It Is a Straight Line.\\n\\n\\tclass Solution:\\n\\t\\tdef checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n\\n\\t\\t\\tdy = (coordinates[1][1]-coordinates[0][1])\\n\\t\\t\\tdx = (coordinates[1][0]-coordinates[0][0])\\n\\n\\t\\t\\tfor i in range(1,len(coordinates)-1):\\n\\n\\t\\t\\t\\tnext_dy = (coordinates[i+1][1]-coordinates[i][1])\\n\\t\\t\\t\\tnext_dx = (coordinates[i+1][0]-coordinates[i][0])\\n\\n\\t\\t\\t\\tif dy * next_dx != dx * next_dy:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\treturn True\\n\\t\\t\\t\\n# Runtime: 80 ms, faster than 27.29% of Python3 online submissions for Check If It Is a Straight Line.\\n# Memory Usage: 16.8 MB, less than 50.49% of Python3 online submissions for Check If It Is a Straight Line.\\n\\n\\tclass Solution:\\n\\t\\tdef checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n\\n\\t\\t\\tresult = 1\\n\\t\\t\\tfirst = coordinates[0]\\n\\t\\t\\tsecond = coordinates[1]\\n\\n\\t\\t\\tdy1 = (second[1] - first[1])\\n\\t\\t\\tdx1 = (second[0] - first[0])\\n\\n\\t\\t\\tfor coordinate in coordinates[2:]:\\n\\n\\t\\t\\t\\tdy2 = (coordinate[1] - second[1])\\n\\t\\t\\t\\tdx2 = (coordinate[0] - second[0])\\n\\n\\t\\t\\t\\tsecond = coordinate\\n\\n\\t\\t\\t\\tif dy1 * dx2 != dy2 * dx1:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\treturn True\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 111 ms, faster than 25.34% of Python3 online submissions for Check If It Is a Straight Line.\\n# Memory Usage: 14.3 MB, less than 80.33% of Python3 online submissions for Check If It Is a Straight Line.\\n\\n\\tclass Solution:\\n\\t\\tdef checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n\\n\\t\\t\\tdy = (coordinates[1][1]-coordinates[0][1])\\n\\t\\t\\tdx = (coordinates[1][0]-coordinates[0][0])\\n\\n\\t\\t\\tfor i in range(1,len(coordinates)-1):\\n\\n\\t\\t\\t\\tnext_dy = (coordinates[i+1][1]-coordinates[i][1])\\n\\t\\t\\t\\tnext_dx = (coordinates[i+1][0]-coordinates[i][0])\\n\\n\\t\\t\\t\\tif dy * next_dx != dx * next_dy:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\treturn True\\n\\t\\t\\t\\n# Runtime: 80 ms, faster than 27.29% of Python3 online submissions for Check If It Is a Straight Line.\\n# Memory Usage: 16.8 MB, less than 50.49% of Python3 online submissions for Check If It Is a Straight Line.\\n\\n\\tclass Solution:\\n\\t\\tdef checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n\\n\\t\\t\\tresult = 1\\n\\t\\t\\tfirst = coordinates[0]\\n\\t\\t\\tsecond = coordinates[1]\\n\\n\\t\\t\\tdy1 = (second[1] - first[1])\\n\\t\\t\\tdx1 = (second[0] - first[0])\\n\\n\\t\\t\\tfor coordinate in coordinates[2:]:\\n\\n\\t\\t\\t\\tdy2 = (coordinate[1] - second[1])\\n\\t\\t\\t\\tdx2 = (coordinate[0] - second[0])\\n\\n\\t\\t\\t\\tsecond = coordinate\\n\\n\\t\\t\\t\\tif dy1 * dx2 != dy2 * dx1:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\treturn True\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 2091658,
                "title": "check-if-it-is-straight-line-simple-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        \\n        double slope;\\n            \\n        if(coordinates[1][0]-coordinates[0][0] == 0) // if denominator is zero then make slope infinity(INT_MAX)\\n            slope= INT_MAX;                          // above step is required because in c++ runtime error will occur\\n        else\\n            slope= (coordinates[1][1]-coordinates[0][1])*1.0/((coordinates[1][0]-coordinates[0][0])*1.0);\\n        \\n        if(coordinates.size()==2)\\n           return true;\\n           \\n        for(int i=1;i<coordinates.size();i++)\\n        {\\n            double currSlope;\\n            \\n            if(coordinates[i][0]-coordinates[0][0] == 0) // if denominator is zero then make slope infinity(INT_MAX)\\n                currSlope=INT_MAX;\\n            else\\n                currSlope= ((coordinates[i][1] -coordinates[0][1])*1.0)/((coordinates[i][0]-coordinates[0][0])*1.0);\\n            \\n            if(currSlope != slope)\\n                return false;\\n        }\\n           \\n        return true;\\n        \\n    }\\n};\\n```\\n\\nPlease upvote (Top - Left corner )  if you like it. !!!!!!!!!!!!!\\nsorry if i am unable to explain.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        \\n        double slope;\\n            \\n        if(coordinates[1][0]-coordinates[0][0] == 0) // if denominator is zero then make slope infinity(INT_MAX)\\n            slope= INT_MAX;                          // above step is required because in c++ runtime error will occur\\n        else\\n            slope= (coordinates[1][1]-coordinates[0][1])*1.0/((coordinates[1][0]-coordinates[0][0])*1.0);\\n        \\n        if(coordinates.size()==2)\\n           return true;\\n           \\n        for(int i=1;i<coordinates.size();i++)\\n        {\\n            double currSlope;\\n            \\n            if(coordinates[i][0]-coordinates[0][0] == 0) // if denominator is zero then make slope infinity(INT_MAX)\\n                currSlope=INT_MAX;\\n            else\\n                currSlope= ((coordinates[i][1] -coordinates[0][1])*1.0)/((coordinates[i][0]-coordinates[0][0])*1.0);\\n            \\n            if(currSlope != slope)\\n                return false;\\n        }\\n           \\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054231,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        (x0, y0), (x1, y1) = coordinates[0], coordinates[1]\\n        for i in range(2, len(coordinates)):\\n            x, y = coordinates[i]\\n            if (x0 - x1) * (y1 - y) != (x1 - x) * (y0 - y1):\\n                return False\\n        return True",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        (x0, y0), (x1, y1) = coordinates[0], coordinates[1]\\n        for i in range(2, len(coordinates)):\\n            x, y = coordinates[i]\\n            if (x0 - x1) * (y1 - y) != (x1 - x) * (y0 - y1):\\n                return False\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 2048622,
                "title": "java-100-faster-solution",
                "content": "class Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n      \\n\\t  //(coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0])-->Slope of line(y2-y1)/(x2-x1)\\n   \\n       if(coordinates[1][0] -coordinates[0][0] !=0){\\n           float m = (float)(coordinates[1][1]-coordinates[0][1])/(float)(coordinates[1][0]-coordinates[0][0]);\\n      for(int i = 1 ; i<coordinates.length-1 ; i++){\\n        \\n        if((coordinates[i+1][0]-coordinates[i][0])==0){\\n          return false;\\n        }\\n        \\n        \\n        if((float)(coordinates[i+1][1]-coordinates[i][1])/(float)(coordinates[i+1][0]-coordinates[i][0])!=m){\\n          return false;\\n        }\\n      }\\n   }\\n      \\n      else{\\n          for(int i = 1 ; i<coordinates.length-1 ; i++){\\n            if(coordinates[i+1][0] -coordinates[i][0] !=0){\\n            return false;\\n        }\\n      }\\n      }\\n      return true;\\n    }\\n}\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n      \\n\\t  //(coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0])-->Slope of line(y2-y1)/(x2-x1)\\n   \\n       if(coordinates[1][0] -coordinates[0][0] !=0){\\n           float m = (float)(coordinates[1][1]-coordinates[0][1])/(float)(coordinates[1][0]-coordinates[0][0]);\\n      for(int i = 1 ; i<coordinates.length-1 ; i++){\\n        \\n        if((coordinates[i+1][0]-coordinates[i][0])==0){\\n          return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2028990,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n    pub fn check_straight_line(coordinates: Vec<Vec<i32>>) -> bool {\\n        coordinates.len() < 3 ||\\n        {\\n            let x0 = coordinates[0][0];\\n            let y0 = coordinates[0][1];\\n            let dx = coordinates[1][0] - x0;\\n            let dy = coordinates[1][1] - y0;\\n            // Checking (yi - y0)/(xi - x0) == (y1 - y0)/(x1 - x0)\\n            // => (yi - y0)*(x1 - x0) == (y1 - y0)*(xi - x0)\\n            coordinates[2..].iter().all(|c| (c[1] - y0)*dx == dy*(c[0] - x0))\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn check_straight_line(coordinates: Vec<Vec<i32>>) -> bool {\\n        coordinates.len() < 3 ||\\n        {\\n            let x0 = coordinates[0][0];\\n            let y0 = coordinates[0][1];\\n            let dx = coordinates[1][0] - x0;\\n            let dy = coordinates[1][1] - y0;\\n            // Checking (yi - y0)/(xi - x0) == (y1 - y0)/(x1 - x0)\\n            // => (yi - y0)*(x1 - x0) == (y1 - y0)*(xi - x0)\\n            coordinates[2..].iter().all(|c| (c[1] - y0)*dx == dy*(c[0] - x0))\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1923124,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        \\n        int points = coordinates.size();\\n        int xdiff = coordinates[1][0]-coordinates[0][0];\\n        int ydiff = coordinates[1][1]-coordinates[0][1];\\n        int curr_xdiff,curr_ydiff;\\n        \\n        for(int i=2;i<points;++i)\\n        {\\n            curr_xdiff = coordinates[i][0]-coordinates[i-1][0];\\n            curr_ydiff = coordinates[i][1]-coordinates[i-1][1];\\n            if(ydiff*curr_xdiff != xdiff*curr_ydiff)\\n                return false;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        \\n        int points = coordinates.size();\\n        int xdiff = coordinates[1][0]-coordinates[0][0];\\n        int ydiff = coordinates[1][1]-coordinates[0][1];\\n        int curr_xdiff,curr_ydiff;\\n        \\n        for(int i=2;i<points;++i)\\n        {\\n            curr_xdiff = coordinates[i][0]-coordinates[i-1][0];\\n            curr_ydiff = coordinates[i][1]-coordinates[i-1][1];\\n            if(ydiff*curr_xdiff != xdiff*curr_ydiff)\\n                return false;\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 1919470,
                "title": "c-easy-solution-explained-no-conversions-to-float",
                "content": "```\\n    // Remind that the cross product of two collinear vectors is equal to zero vector\\n    //\\n    // X  Y   Z\\n    // X1 Y1  Z1\\n    // X2 Y2  Z2\\n    //\\n    // Cross product = (Y1*Z2 - Y2*Z1, X2*Z1 - X1*Z2, X1*Y2 - X2*Y1)\\n    //\\n    // Since we are dealing with 2D vectors, Z1 = Z2 = 0\\n    // And this is simplified to:\\n    // Cross product = (0, 0, X1*Y2 - X2*Y1)\\n    //\\n    // Hence we can check the collinearity of 2 vectors this way:\\n    inline bool is_collinear(int x1, int y1, int x2, int y2) const {\\n        return (x1*y2 - x2*y1) == 0;\\n    }\\n    \\n    // Now the solution is trivial\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int x1 = coordinates[1][0] - coordinates[0][0];\\n        int y1 = coordinates[1][1] - coordinates[0][1];\\n        \\n        for (int i = 2; i < coordinates.size(); i++) {\\n            int x2 = coordinates[i][0] - coordinates[0][0];\\n            int y2 = coordinates[i][1] - coordinates[0][1];\\n            if (!is_collinear(x1, y1, x2, y2)) return false;\\n        }\\n        \\n        return true;\\n    }\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    // Remind that the cross product of two collinear vectors is equal to zero vector\\n    //\\n    // X  Y   Z\\n    // X1 Y1  Z1\\n    // X2 Y2  Z2\\n    //\\n    // Cross product = (Y1*Z2 - Y2*Z1, X2*Z1 - X1*Z2, X1*Y2 - X2*Y1)\\n    //\\n    // Since we are dealing with 2D vectors, Z1 = Z2 = 0\\n    // And this is simplified to:\\n    // Cross product = (0, 0, X1*Y2 - X2*Y1)\\n    //\\n    // Hence we can check the collinearity of 2 vectors this way:\\n    inline bool is_collinear(int x1, int y1, int x2, int y2) const {\\n        return (x1*y2 - x2*y1) == 0;\\n    }\\n    \\n    // Now the solution is trivial\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int x1 = coordinates[1][0] - coordinates[0][0];\\n        int y1 = coordinates[1][1] - coordinates[0][1];\\n        \\n        for (int i = 2; i < coordinates.size(); i++) {\\n            int x2 = coordinates[i][0] - coordinates[0][0];\\n            int y2 = coordinates[i][1] - coordinates[0][1];\\n            if (!is_collinear(x1, y1, x2, y2)) return false;\\n        }\\n        \\n        return true;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1899572,
                "title": "1232-check-if-it-is-a-straight-line-java-using-maths",
                "content": "```\\nclass Solution {\\n    \\n    // TC o(n)\\n    // TS o(1)\\n    // here we are using maths formula to find it is straight line wich is \\n    // (y-y1)/(y2-y1)=(x-x1)/(x2-21)\\n    // to avoid divide by 0 we are using multiplication (y-y1)*(x2-21)=(x-x1)*(y2-y1)\\n    public boolean checkStraightLine(int[][] coordinates) {\\n       if(coordinates==null || coordinates.length<2) return false;\\n        \\n        int x1=coordinates[0][0];\\n        int y1=coordinates[0][1];\\n        \\n        int x2=coordinates[1][0];\\n        int y2=coordinates[1][1];\\n            \\n        for(int i=2;i<coordinates.length;i++){\\n          \\n          int x=coordinates[i][0];\\n          int y=coordinates[i][1];\\n            \\n           if( ((y-y1)*(x2-x1))!=((x-x1)*(y2-y1)) ){\\n               return false;\\n           }\\n       } \\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    // TC o(n)\\n    // TS o(1)\\n    // here we are using maths formula to find it is straight line wich is \\n    // (y-y1)/(y2-y1)=(x-x1)/(x2-21)\\n    // to avoid divide by 0 we are using multiplication (y-y1)*(x2-21)=(x-x1)*(y2-y1)\\n    public boolean checkStraightLine(int[][] coordinates) {\\n       if(coordinates==null || coordinates.length<2) return false;\\n        \\n        int x1=coordinates[0][0];\\n        int y1=coordinates[0][1];\\n        \\n        int x2=coordinates[1][0];\\n        int y2=coordinates[1][1];\\n            \\n        for(int i=2;i<coordinates.length;i++){\\n          \\n          int x=coordinates[i][0];\\n          int y=coordinates[i][1];\\n            \\n           if( ((y-y1)*(x2-x1))!=((x-x1)*(y2-y1)) ){\\n               return false;\\n           }\\n       } \\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836388,
                "title": "java-o-n-using-slope-of-line",
                "content": "To avoid involving float numbers to represent slopes, we can vary the formula of calculating slope: \\nfrom `delta_x1 / delta_y1 = delta_x2 / delta_y2` \\nto `delta_x1 * delta_y2 = delta_x2 * delta_y1`\\n\\nBy doing this, we don\\'t need to worry about float numbers or lines with 0 slope (horizontal line) or null slope (vertical line).\\n```java\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        int delta_x1 = coordinates[0][0] - coordinates[1][0];\\n        int delta_y1 = coordinates[0][1] - coordinates[1][1];\\n        int[] prev = coordinates[1];\\n        for (int i = 2; i < coordinates.length; ++i) {\\n            int[] point = coordinates[i];\\n            int delta_x2 = point[0] - prev[0];\\n            int delta_y2 = point[1] - prev[1];\\n            if (delta_x1 * delta_y2 != delta_x2 * delta_y1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        int delta_x1 = coordinates[0][0] - coordinates[1][0];\\n        int delta_y1 = coordinates[0][1] - coordinates[1][1];\\n        int[] prev = coordinates[1];\\n        for (int i = 2; i < coordinates.length; ++i) {\\n            int[] point = coordinates[i];\\n            int delta_x2 = point[0] - prev[0];\\n            int delta_y2 = point[1] - prev[1];\\n            if (delta_x1 * delta_y2 != delta_x2 * delta_y1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822886,
                "title": "python3-95-faster-using-slope-of-the-straight-line-method",
                "content": "class Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        \\n        x1 = coordinates[0][0]\\n        y1 = coordinates[0][1]\\n        \\n        x2 = coordinates[1][0]\\n        y2 = coordinates[1][1]\\n        \\n        dx = x2 - x1\\n        dy = y2 - y1\\n        \\n        for i in range(len(coordinates)):\\n            x = coordinates[i][0]\\n            y = coordinates[i][1]\\n            \\n            if dx * (y - y1) != dy * (x - x1):\\n                return False\\n        return True",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "class Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        \\n        x1 = coordinates[0][0]\\n        y1 = coordinates[0][1]\\n        \\n        x2 = coordinates[1][0]\\n        y2 = coordinates[1][1]\\n        \\n        dx = x2 - x1\\n        dy = y2 - y1\\n        \\n        for i in range(len(coordinates)):\\n            x = coordinates[i][0]\\n            y = coordinates[i][1]\\n            \\n            if dx * (y - y1) != dy * (x - x1):\\n                return False\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 1649337,
                "title": "easy-java-code-faster-than-100",
                "content": "class Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n \\n           \\n        \\n        for(int i = 2; i < coordinates.length; i++){\\n            double y1 = (double)coordinates[i-2][1];\\n            double x1 = (double)coordinates[i-2][0];\\n            double y2 = (double)coordinates[i-1][1];\\n            double x2 = (double)coordinates[i-1][0];\\n            double y3 = (double)coordinates[i][1];\\n            double x3 = (double)coordinates[i][0];\\n            \\n            //(y2-y1)/(x2-x1)=(y3-y2)/(x3-x2)\\n            if((x3-x2)*(y2-y1)-(x2-x1)*(y3-y2)!=0)return false;\\n            \\n        }\\n        \\n        return true;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n \\n           \\n        \\n        for(int i = 2; i < coordinates.length; i++){\\n            double y1 = (double)coordinates[i-2][1];\\n            double x1 = (double)coordinates[i-2][0];\\n            double y2 = (double)coordinates[i-1][1];\\n            double x2 = (double)coordinates[i-1][0];\\n            double y3 = (double)coordinates[i][1];\\n            double x3 = (double)coordinates[i][0];\\n            \\n            //(y2-y1)/(x2-x1)=(y3-y2)/(x3-x2)\\n            if((x3-x2)*(y2-y1)-(x2-x1)*(y3-y2)!=0)return false;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1555507,
                "title": "java-100-o-n-1-easy-to-understand-with-explanation",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n```\\nclass Solution {\\n    // public boolean checkStraightLine(int[][] coordinates) {\\n    // coordinates --> c\\n    public boolean checkStraightLine(int[][] c) {\\n        \\n        \\n        int xMove = c[1][0] - c[0][0];\\n        int yMove = c[1][1] - c[0][1];\\n        \\n        for(int i=1; i<c.length; i++){\\n\\n            int x = c[i][0] - c[i-1][0];\\n            int y = c[i][1] - c[i-1][1];\\n            \\n// linear function -> y = k * x + b;\\n// Here need to discuss y = k * x;\\n// k = yMove / xMove;\\n// y * xMove = x * yMove;\\n            \\n            if(y * xMove != x * yMove) return false;\\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1277333,
                "title": "java-100-faster-82-93-less-memory",
                "content": "```\\nclass Solution {\\n    public boolean checkStraightLine(int[][] crdnts) {\\n        double s;\\n        if((crdnts[1][0]-crdnts[0][0])==0)\\n            s=-1752;\\n        else\\n        s=((float)crdnts[1][1]-crdnts[0][1])/((float)crdnts[1][0]-crdnts[0][0]);\\n        //System.out.println(s);\\n        double temp;\\n        for(int i=1;i<crdnts.length-1;i++)\\n        {\\n            if(crdnts[i+1][0]-crdnts[i][0]==0)\\n                temp=-1752;\\n            else\\n            temp=((float)crdnts[i+1][1]-crdnts[i][1])/((float)crdnts[i+1][0]-crdnts[i][0]);\\n            //System.out.println(temp);\\n            if(temp!=s)\\n                return false;\\n        }\\n        \\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkStraightLine(int[][] crdnts) {\\n        double s;\\n        if((crdnts[1][0]-crdnts[0][0])==0)\\n            s=-1752;\\n        else\\n        s=((float)crdnts[1][1]-crdnts[0][1])/((float)crdnts[1][0]-crdnts[0][0]);\\n        //System.out.println(s);\\n        double temp;\\n        for(int i=1;i<crdnts.length-1;i++)\\n        {\\n            if(crdnts[i+1][0]-crdnts[i][0]==0)\\n                temp=-1752;\\n            else\\n            temp=((float)crdnts[i+1][1]-crdnts[i][1])/((float)crdnts[i+1][0]-crdnts[i][0]);\\n            //System.out.println(temp);\\n            if(temp!=s)\\n                return false;\\n        }\\n        \\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1020564,
                "title": "using-slope-and-gcd-c",
                "content": "\\nIf all points in the same line then the slope between any two points should be equal.\\nSo this problem boils down to get slope between two points. \\nSuppose we have two slope.\\n\\na / b and c / d. \\n\\nif (a /b == c /d), then we must have a * d == b * c.\\n\\nAnd this is what we need to check for each point.\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int is_straight = true;\\n        int dy = coordinates[1][1] - coordinates[0][1];\\n        int dx = coordinates[1][0] - coordinates[0][0];\\n\\n        for(int i=2; i < coordinates.size(); i++) {\\n            int cur_dy = coordinates[i][1] - coordinates[i-1][1];\\n            int cur_dx = coordinates[i][0]- coordinates[i-1][0];\\n\\n            if(cur_dx * dy != cur_dy * dx) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int is_straight = true;\\n        int dy = coordinates[1][1] - coordinates[0][1];\\n        int dx = coordinates[1][0] - coordinates[0][0];\\n\\n        for(int i=2; i < coordinates.size(); i++) {\\n            int cur_dy = coordinates[i][1] - coordinates[i-1][1];\\n            int cur_dx = coordinates[i][0]- coordinates[i-1][0];\\n\\n            if(cur_dx * dy != cur_dy * dx) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968191,
                "title": "c-12ms-runtime-with-vector-maths",
                "content": "Idea: Calculate the vector using the first 2 points. For every other point, calculate the vector from the one of the initial 2 points and check if new vector is parallel to the initial vector using their cross product(done using determinants..hence avoids division). If cross product is not zero...the points are not inline.\\n```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& c) {\\n        int n = c.size();\\n        if(n <= 1) return false;\\n        else if(n==2) return true;\\n        int dx = c[1][0] - c[0][0], dy = c[1][1] - c[0][1];\\n        \\n       \\n        for(int i=2; i<n; i++){\\n            int ddx = c[i][0]-c[1][0], ddy = c[i][1]-c[1][1];\\n     \\n            if(dx*ddy != dy*ddx) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& c) {\\n        int n = c.size();\\n        if(n <= 1) return false;\\n        else if(n==2) return true;\\n        int dx = c[1][0] - c[0][0], dy = c[1][1] - c[0][1];\\n        \\n       \\n        for(int i=2; i<n; i++){\\n            int ddx = c[i][0]-c[1][0], ddy = c[i][1]-c[1][1];\\n     \\n            if(dx*ddy != dy*ddx) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873226,
                "title": "java-solution-and-easy-to-understand-math-explanation",
                "content": "ex: We have 3 point **O, A , B** and how to check **B** in the straight line contains **O** and **A**;\\nWe have vector **OA** and if we want to check B in the straight line that contains O and A in math we have vector **OB = kOA**\\nso in this solution dx, dy it\\'s mean the coordinates of vector OA\\nand the coordinates of vector **OB = ((xB - xO), (yB - yO)**\\nfrom **OB = kOA** and finally we have** (dx1, dy1) = k * (dX, dY)** and then **dx1 * dy == dy1 * dx**\\nAnd that is it.\\n```java\\nclass Solution {\\n    \\n    public boolean checkStraightLine(int[][] coors) {\\n        if(coors.length == 2) return true;\\n        \\n        // vector BO = k * AO\\n        int dx = coors[1][0] - coors[0][0];\\n        int dy = coors[1][1] - coors[0][1];\\n        \\n        for(int i = 2; i < coors.length; i++) {\\n            int dx1 = coors[i][0] - coors[0][0];\\n            int dy1 = coors[i][1] - coors[0][1];\\n            if(dx*dy1 != dy*dx1) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    \\n    public boolean checkStraightLine(int[][] coors) {\\n        if(coors.length == 2) return true;\\n        \\n        // vector BO = k * AO\\n        int dx = coors[1][0] - coors[0][0];\\n        int dy = coors[1][1] - coors[0][1];\\n        \\n        for(int i = 2; i < coors.length; i++) {\\n            int dx1 = coors[i][0] - coors[0][0];\\n            int dy1 = coors[i][1] - coors[0][1];\\n            if(dx*dy1 != dy*dx1) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 849105,
                "title": "simple-javascript-solution",
                "content": "Please upvote if you find this solution helpful. Thanks!\\n```\\nvar checkStraightLine = function(coordinates) {\\n    \\n    let xDiff = coordinates[1][0] - coordinates[0][0];\\n    let yDiff = coordinates[1][1] - coordinates[0][1];\\n    \\n    for(let i = 2; i < coordinates.length; i++) {\\n        let currXDiff = coordinates[i][0] - coordinates[i-1][0];\\n        let currYDiff = coordinates[i][1] - coordinates[i-1][1];\\n        \\n        if(xDiff*currYDiff != yDiff*currXDiff) return false;\\n    }\\n    return true;\\n};",
                "solutionTags": [],
                "code": "Please upvote if you find this solution helpful. Thanks!\\n```\\nvar checkStraightLine = function(coordinates) {\\n    \\n    let xDiff = coordinates[1][0] - coordinates[0][0];\\n    let yDiff = coordinates[1][1] - coordinates[0][1];\\n    \\n    for(let i = 2; i < coordinates.length; i++) {\\n        let currXDiff = coordinates[i][0] - coordinates[i-1][0];\\n        let currYDiff = coordinates[i][1] - coordinates[i-1][1];\\n        \\n        if(xDiff*currYDiff != yDiff*currXDiff) return false;\\n    }\\n    return true;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 815052,
                "title": "ruby-solution-same-slope-between-all-combinations-with-first-point",
                "content": "##### Leetcode: 1232. Check If It Is a Straight Line.\\n\\nIdea behind this solution is that slope between first point and all others must be the same. What is a slope, it is a quotient between x distance and y distance of two points, it called dx and dy. First calculate slope between first two points, and than compare slope between first point and rest of them with first slope. \\n\\nIt is may happens that dy or dx are the same because it is horizontal or vertical line, and y and x values are same between all points respectively. These cases are added two.\\n\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 1232. Check If It Is a Straight Line.\\n# https://leetcode.com/problems/check-if-it-is-a-straight-line/\\n# Runtime: 44 ms, faster than 83.33% of Ruby online submissions for Check If It Is a Straight Line.\\n# Memory Usage: 9.8 MB, less than 58.33% of Ruby online submissions for Check If It Is a Straight Line.\\n# @param {Integer[][]} coordinates\\n# @return {Boolean}\\ndef check_straight_line(coordinates)\\n    c = coordinates\\n    \\n    return true if c.all?{|(a,b)| a == c[0][0]}\\n    return true if c.all?{|(a,b)| b == c[0][1]}\\n    \\n    a,b = c[0],c[1]\\n    dx = a[0] - b[0]\\n    dy = a[1] - b[1]\\n    slope = dx.fdiv(dy)\\n    \\n    c[2..-1].each do |b|\\n        dx = a[0] - b[0]\\n        dy = a[1] - b[1]\\n        return false if slope != dx.fdiv(dy)\\n    end\\n    \\n    true\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```Ruby\\n# Leetcode: 1232. Check If It Is a Straight Line.\\n# https://leetcode.com/problems/check-if-it-is-a-straight-line/\\n# Runtime: 44 ms, faster than 83.33% of Ruby online submissions for Check If It Is a Straight Line.\\n# Memory Usage: 9.8 MB, less than 58.33% of Ruby online submissions for Check If It Is a Straight Line.\\n# @param {Integer[][]} coordinates\\n# @return {Boolean}\\ndef check_straight_line(coordinates)\\n    c = coordinates\\n    \\n    return true if c.all?{|(a,b)| a == c[0][0]}\\n    return true if c.all?{|(a,b)| b == c[0][1]}\\n    \\n    a,b = c[0],c[1]\\n    dx = a[0] - b[0]\\n    dy = a[1] - b[1]\\n    slope = dx.fdiv(dy)\\n    \\n    c[2..-1].each do |b|\\n        dx = a[0] - b[0]\\n        dy = a[1] - b[1]\\n        return false if slope != dx.fdiv(dy)\\n    end\\n    \\n    true\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 795347,
                "title": "python-very-simple-clean-clear-solution",
                "content": "```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        \\n        y = coordinates[1][1] - coordinates[0][1]\\n        x = coordinates[1][0] - coordinates[0][0]\\n        \\n        for i in range(1, len(coordinates)):\\n            \\n            x_ = coordinates[i][0] - coordinates[i - 1][0]\\n            y_ = coordinates[i][1] - coordinates[i - 1][1]\\n        \\n            if y  * x_ != x * y_:\\n                return False\\n        \\n        return True\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        \\n        y = coordinates[1][1] - coordinates[0][1]\\n        x = coordinates[1][0] - coordinates[0][0]\\n        \\n        for i in range(1, len(coordinates)):\\n            \\n            x_ = coordinates[i][0] - coordinates[i - 1][0]\\n            y_ = coordinates[i][1] - coordinates[i - 1][1]\\n        \\n            if y  * x_ != x * y_:\\n                return False\\n        \\n        return True\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 621640,
                "title": "java-runtime-0-ms-faster-than-100-00-memory-usage-less-than-100-00",
                "content": "```\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Check If It Is a Straight Line.\\nMemory Usage: 39.1 MB, less than 100.00% of Java online submissions for Check If It Is a Straight Line.\\n\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n        double slope = ((double) coordinates[0][0] - coordinates[1][0])/((double) (coordinates[0][1] - coordinates[1][1]));\\n        \\n        // CASE +/-Infinity\\n        if(Math.abs(slope) == Double.POSITIVE_INFINITY){\\n            for(int i=1; i<coordinates.length; i++){if(coordinates[i][1] != coordinates[0][1]) return false;}\\n            return true;\\n        }\\n        \\n        for(int i=2; i<coordinates.length; i++){\\n            if( slope != ((double) coordinates[0][0] - (double) coordinates[i][0])/((double)coordinates[0][1] - (double) coordinates[i][1])){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Check If It Is a Straight Line.\\nMemory Usage: 39.1 MB, less than 100.00% of Java online submissions for Check If It Is a Straight Line.\\n\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n        double slope = ((double) coordinates[0][0] - coordinates[1][0])/((double) (coordinates[0][1] - coordinates[1][1]));\\n        \\n        // CASE +/-Infinity\\n        if(Math.abs(slope) == Double.POSITIVE_INFINITY){\\n            for(int i=1; i<coordinates.length; i++){if(coordinates[i][1] != coordinates[0][1]) return false;}\\n            return true;\\n        }\\n        \\n        for(int i=2; i<coordinates.length; i++){\\n            if( slope != ((double) coordinates[0][0] - (double) coordinates[i][0])/((double)coordinates[0][1] - (double) coordinates[i][1])){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 621604,
                "title": "easy-to-understand-python-solution",
                "content": "```\\nclass Solution(object):\\n    def checkStraightLine(self, coordinates):\\n        \"\"\"\\n        :type coordinates: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n# if number of points is 2 return true\\n        if len(coordinates) == 2:\\n            return True\\n        x1,y1 = coordinates[0][0],coordinates[0][1] # get coordinates of first point\\n        x2,y2 = coordinates[1][0],coordinates[1][1] # get coordinates of second point \\n# check if x2-x1 -> zero division case\\n        if x2-x1 == 0:    \\n            return False\\n        diff = (y2-y1)/(x2-x1) # compute  slope \\n        i = 2 # start loop from coordinates [2]\\n        while i < len(coordinates):\\n# zero divison case\\n            if coordinates[i][0] - coordinates[i-1][0] == 0:\\n                return False\\n# compute slope between current point and the previous point\\n            diff_ = (coordinates[i][1]-coordinates[i-1][1])/(coordinates[i][0] - coordinates[i-1][0])\\n\\t\\t\\t\\n# check if slope not equal to slope of first two points return false as points aren\\'t on same straight line\\n            if diff_ != diff:  \\n                return False\\n            i += 1\\n        return True\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def checkStraightLine(self, coordinates):\\n        \"\"\"\\n        :type coordinates: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n# if number of points is 2 return true\\n        if len(coordinates) == 2:\\n            return True\\n        x1,y1 = coordinates[0][0],coordinates[0][1] # get coordinates of first point\\n        x2,y2 = coordinates[1][0],coordinates[1][1] # get coordinates of second point \\n# check if x2-x1 -> zero division case\\n        if x2-x1 == 0:    \\n            return False\\n        diff = (y2-y1)/(x2-x1) # compute  slope \\n        i = 2 # start loop from coordinates [2]\\n        while i < len(coordinates):\\n# zero divison case\\n            if coordinates[i][0] - coordinates[i-1][0] == 0:\\n                return False\\n# compute slope between current point and the previous point\\n            diff_ = (coordinates[i][1]-coordinates[i-1][1])/(coordinates[i][0] - coordinates[i-1][0])\\n\\t\\t\\t\\n# check if slope not equal to slope of first two points return false as points aren\\'t on same straight line\\n            if diff_ != diff:  \\n                return False\\n            i += 1\\n        return True\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 621111,
                "title": "python-solution-o-n-56ms-and-100-less-memory",
                "content": "**If you like please upvote**\\n```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        (x1, y1), (x2, y2) = coordinates[:2]\\n        if len(coordinates)==2:\\n            return True\\n        for i in range(2, len(coordinates)):\\n            (x, y) = coordinates[i]\\n            if((y2 - y1) * (x1 - x) != (y1 - y) * (x2 - x1)):\\n                return False\\n        return True\\t\\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkStraightLine(self, coordinates: List[List[int]]) -> bool:\\n        (x1, y1), (x2, y2) = coordinates[:2]\\n        if len(coordinates)==2:\\n            return True\\n        for i in range(2, len(coordinates)):\\n            (x, y) = coordinates[i]\\n            if((y2 - y1) * (x1 - x) != (y1 - y) * (x2 - x1)):\\n                return False\\n        return True\\t\\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 620463,
                "title": "rust-solution-100",
                "content": "```\\n// Using formula for slop (x1, y1), (x2, y2) = (y2-y1)/(x2-x1) ->\\n// (x3 - x2)(y2 - y1) = (x2 - x1)(y3 - y2)\\nimpl Solution {\\n    pub fn check_straight_line(coordinates: Vec<Vec<i32>>) -> bool {\\n        if coordinates.len() <= 2 {\\n            return true;\\n        }\\n        for i in 2..coordinates.len() {\\n            if ((coordinates[i][0] - coordinates[i - 1][0]) * (coordinates[i - 1][1] - coordinates[i - 2][1]) !=\\n                (coordinates[i - 1][0] - coordinates[i - 2][0]) * (coordinates[i][1] - coordinates[i - 1][1])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// Using formula for slop (x1, y1), (x2, y2) = (y2-y1)/(x2-x1) ->\\n// (x3 - x2)(y2 - y1) = (x2 - x1)(y3 - y2)\\nimpl Solution {\\n    pub fn check_straight_line(coordinates: Vec<Vec<i32>>) -> bool {\\n        if coordinates.len() <= 2 {\\n            return true;\\n        }\\n        for i in 2..coordinates.len() {\\n            if ((coordinates[i][0] - coordinates[i - 1][0]) * (coordinates[i - 1][1] - coordinates[i - 2][1]) !=\\n                (coordinates[i - 1][0] - coordinates[i - 2][0]) * (coordinates[i][1] - coordinates[i - 1][1])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 619942,
                "title": "cpp-simple-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& c) {\\n        if(c.size()<3)\\n            return true;\\n        int dy=c[1][1]-c[0][1], dx=c[1][0]-c[0][0];\\n        for(int i=2;i<c.size();i++){\\n            int ddy=c[i][1]-c[i-1][1], ddx=c[i][0]-c[i-1][0];\\n            if(ddy*dx != ddx*dy)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& c) {\\n        if(c.size()<3)\\n            return true;\\n        int dy=c[1][1]-c[0][1], dx=c[1][0]-c[0][0];\\n        for(int i=2;i<c.size();i++){\\n            int ddy=c[i][1]-c[i-1][1], ddx=c[i][0]-c[i-1][0];\\n            if(ddy*dx != ddx*dy)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490884,
                "title": "java-0ms-100-using-direct-formula",
                "content": "```\\n public boolean checkStraightLine(int[][] coords) {\\n        //Condition of collinearity of three points\\n        // x1 (y2  - y3) + x2 (y3 - y1) + x3 (y1 - y2) = 0        \\n\\t\\t//https://www.math-only-math.com/straight-line-formulae.html\\n        for(int i=2;i<coords.length;i++){\\n            int total = coords[0][0]*(coords[1][1] - coords[i][1]) + coords[1][0]*(coords[i][1] - coords[0][1]) + coords[i][0]*(coords[0][1] - coords[1][1]);\\n            if(total!=0)\\n                return false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```\\n public boolean checkStraightLine(int[][] coords) {\\n        //Condition of collinearity of three points\\n        // x1 (y2  - y3) + x2 (y3 - y1) + x3 (y1 - y2) = 0        \\n\\t\\t//https://www.math-only-math.com/straight-line-formulae.html\\n        for(int i=2;i<coords.length;i++){\\n            int total = coords[0][0]*(coords[1][1] - coords[i][1]) + coords[1][0]*(coords[i][1] - coords[0][1]) + coords[i][0]*(coords[0][1] - coords[1][1]);\\n            if(total!=0)\\n                return false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 449496,
                "title": "java-line-equation-with-y-mx-c-faster-than-100-00",
                "content": "1. Form a Line Equation with first 2 points (x1,y1) and (x2,y2)\\nY=MX+C Here M (slope) =(y2-y1) / (x2 -x1), C = y1 - M*x1\\n\\n2. Substitue all the other points in this equation and validate\\n\\n```\\npublic boolean checkStraightLine(int[][] coordinates) {\\n        \\n        if(coordinates.length<=2){\\n            return true;\\n        }\\n        \\n        double m = (double)(coordinates[1][1] - coordinates[0][1]) / (double)(coordinates[1][0] - coordinates[0][0]);\\n        double c= coordinates[0][1] - m * coordinates[0][0];\\n        \\n        for(int i=2;i<coordinates.length;i++){\\n            \\n            if(coordinates[i][1] != (int) (m*coordinates[i][0] + c)){\\n                return false;\\n            }\\n            \\n        }\\n        \\n        return true;\\n        \\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic boolean checkStraightLine(int[][] coordinates) {\\n        \\n        if(coordinates.length<=2){\\n            return true;\\n        }\\n        \\n        double m = (double)(coordinates[1][1] - coordinates[0][1]) / (double)(coordinates[1][0] - coordinates[0][0]);\\n        double c= coordinates[0][1] - m * coordinates[0][0];\\n        \\n        for(int i=2;i<coordinates.length;i++){\\n            \\n            if(coordinates[i][1] != (int) (m*coordinates[i][0] + c)){\\n                return false;\\n            }\\n            \\n        }\\n        \\n        return true;\\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1781456,
                "content": [
                    {
                        "username": "JuanQP",
                        "content": "There are at least 3 things you should know to solve this.\\n\\n* Remember when in high school you asked your teacher *Who cares what is the slope between two points? When am I going to use this anyway?*, well, this is one of those situations. So, remember: \\n$$m = (y_2 - y_1) / (x_2 - x_1)$$\\n* It would be easy to solve this if the points were sorted... Right?\\n* There is a border case: What if two points have the same `x` value? Ouch. That would be a division by zero. Think how to take care of this particular case.\\n\\nThose tips should do the trick for you. Happy coding."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@theRadFad](/theRadFad) Yeah, sorting won\\'t be helpful here at all. The reason is that you can either sort in the direction of x or in the direction of y. If the points were in a straight line, they would already appear sorted in some direction (either x or y). So, in that case, you don\\'t get any advantage by sorting. I suppose its not needed."
                    },
                    {
                        "username": "theRadFad",
                        "content": "Lovely hints. I would just like to add that, perhaps, sorting may not be that important .. right?"
                    },
                    {
                        "username": "singh__12",
                        "content": "[@Jagannath01](/Jagannath01) You are dividing by zero for this case [[0,0],[0,1],[0,-1]] so modifie your code as                                                                         \\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int n=coordinates.size();\\n        int xmove=coordinates[1][0]-coordinates[0][0];  // same as x2-x1\\n        int ymove=coordinates[1][1]-coordinates[0][1];  // same as y2-y1\\n\\n        for(int i=1;i<n;i++){\\n            int x=coordinates[i][0]-coordinates[i-1][0];\\n            int y=coordinates[i][1]-coordinates[i-1][1];\\n            if(y*xmove!=x*ymove) return false;\\n        } \\n        return true;   \\n    }\\n};"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "i tried with the same approach still I am getting error..\\n\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n        int n=coordinates.length;\\n\\n        int m=(coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n\\n        boolean ans=false;\\n\\n        for(int i=1; i<n-1 ;i++){\\n\\n            if((coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0])==m){\\n\\n                ans=true;\\n            }\\n            else{\\n                ans=false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "mochy",
                        "content": "Use standard form so you don't have to deal with vertical lines (division by zero).\n$$y-y_1 = \fm(x-x_1)$$\n$$y-y_1 = \f(Δy/Δx)(x-x_1)$$\n$$Δx(y-y_1) = Δy(x-x_1)$$"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try vector method as opposed to Cartesian method"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as medium problem\\n"
                    },
                    {
                        "username": "luzede",
                        "content": "Writing the code is piece of cake if you remember the line equation from Highschool "
                    },
                    {
                        "username": "azuregcp",
                        "content": "Why? It\\'s just a basic high school mathematics problem."
                    },
                    {
                        "username": "ObviouslyBhavya",
                        "content": "To check if three points are in straight line or not we try to assume it as a triangle and if the area of traingle if zero then we say that the three points are in straight line.\\n\\nThe solution to this question is you take the first 2 points and check for every point if with any point the first two points makes a triangle of a positive area the answer is no that the coordinates are not in straight line.\\n\\nThe formula to calculate area is (1/12)*(x1(y2-y3) + x2(y3-y1) + x3(y1-y2)) apply the same formula learnt in school"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a question for the school math. Every point (x[i], y[i]) (for i!=0, 1)on the line satisfies\n$\n(y[i]-y[0])/(x[i]-x[0])=(y[1]-y[0])/(x[1]-x[0])=$slope of this line\n\nbut be careful, not divided by zero. Before submitting, try the following test case:\n```\n[[0,0],[0,1],[0,-1]]\n```\n[https://youtu.be/00BEcax1fu8](https://youtu.be/00BEcax1fu8)"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints for those who want to code on their own:\\n\\n1. 2 points are always co-linear.\\n2. 3 points are co-linear if the slope of lines joining any 2 of the 3 points is same.\\n3. Be a bit careful while calculating slope. The denominator might be 0.\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Finally a real Good Morning after a scary fortnight."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "tan(0)=(y2-y1)/(x2-x1)\\nfor multiple points.\\n(y2-y1)/(x2-x1)==(y1-y0)/(x1-x0)\\nBut in this 0/0 exception come.\\nSo rearrange the formula. \\n**(y2-y1)*(x1-x0)==(y1-y0)*(x2-x1)**\\n\\nCODE is solution section."
                    },
                    {
                        "username": "artem09122002",
                        "content": "I do not think that this case is correct \\n\\nInput\\ncoordinates =\\n[[0,0],[0,1],[0,-1]]\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@RomNc](/RomNc) But according to question, we have to \"Check if these points make a straight line in the XY plane or not\". So, I can't see anything wrong."
                    },
                    {
                        "username": "RomNc",
                        "content": "[@Rajat310](/Rajat310) The points form a straight line, but mathematically speaking the gradient of a vertical line is undefined. So, this one another amiguously presented question on leetcode. \nThe point is we need to apply some sort of mathemataical formula to solve this problem, while a vertilcal line is not a case to which this mathematical formula can be applied. But anyways..."
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@artem09122002](/artem09122002) It is true. The x-coordinates are all the same(i.e. constant) and thus form a straight line on the x-axis regardless of the y-axis."
                    }
                ]
            },
            {
                "id": 1917221,
                "content": [
                    {
                        "username": "JuanQP",
                        "content": "There are at least 3 things you should know to solve this.\\n\\n* Remember when in high school you asked your teacher *Who cares what is the slope between two points? When am I going to use this anyway?*, well, this is one of those situations. So, remember: \\n$$m = (y_2 - y_1) / (x_2 - x_1)$$\\n* It would be easy to solve this if the points were sorted... Right?\\n* There is a border case: What if two points have the same `x` value? Ouch. That would be a division by zero. Think how to take care of this particular case.\\n\\nThose tips should do the trick for you. Happy coding."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@theRadFad](/theRadFad) Yeah, sorting won\\'t be helpful here at all. The reason is that you can either sort in the direction of x or in the direction of y. If the points were in a straight line, they would already appear sorted in some direction (either x or y). So, in that case, you don\\'t get any advantage by sorting. I suppose its not needed."
                    },
                    {
                        "username": "theRadFad",
                        "content": "Lovely hints. I would just like to add that, perhaps, sorting may not be that important .. right?"
                    },
                    {
                        "username": "singh__12",
                        "content": "[@Jagannath01](/Jagannath01) You are dividing by zero for this case [[0,0],[0,1],[0,-1]] so modifie your code as                                                                         \\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int n=coordinates.size();\\n        int xmove=coordinates[1][0]-coordinates[0][0];  // same as x2-x1\\n        int ymove=coordinates[1][1]-coordinates[0][1];  // same as y2-y1\\n\\n        for(int i=1;i<n;i++){\\n            int x=coordinates[i][0]-coordinates[i-1][0];\\n            int y=coordinates[i][1]-coordinates[i-1][1];\\n            if(y*xmove!=x*ymove) return false;\\n        } \\n        return true;   \\n    }\\n};"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "i tried with the same approach still I am getting error..\\n\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n        int n=coordinates.length;\\n\\n        int m=(coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n\\n        boolean ans=false;\\n\\n        for(int i=1; i<n-1 ;i++){\\n\\n            if((coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0])==m){\\n\\n                ans=true;\\n            }\\n            else{\\n                ans=false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "mochy",
                        "content": "Use standard form so you don't have to deal with vertical lines (division by zero).\n$$y-y_1 = \fm(x-x_1)$$\n$$y-y_1 = \f(Δy/Δx)(x-x_1)$$\n$$Δx(y-y_1) = Δy(x-x_1)$$"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try vector method as opposed to Cartesian method"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as medium problem\\n"
                    },
                    {
                        "username": "luzede",
                        "content": "Writing the code is piece of cake if you remember the line equation from Highschool "
                    },
                    {
                        "username": "azuregcp",
                        "content": "Why? It\\'s just a basic high school mathematics problem."
                    },
                    {
                        "username": "ObviouslyBhavya",
                        "content": "To check if three points are in straight line or not we try to assume it as a triangle and if the area of traingle if zero then we say that the three points are in straight line.\\n\\nThe solution to this question is you take the first 2 points and check for every point if with any point the first two points makes a triangle of a positive area the answer is no that the coordinates are not in straight line.\\n\\nThe formula to calculate area is (1/12)*(x1(y2-y3) + x2(y3-y1) + x3(y1-y2)) apply the same formula learnt in school"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a question for the school math. Every point (x[i], y[i]) (for i!=0, 1)on the line satisfies\n$\n(y[i]-y[0])/(x[i]-x[0])=(y[1]-y[0])/(x[1]-x[0])=$slope of this line\n\nbut be careful, not divided by zero. Before submitting, try the following test case:\n```\n[[0,0],[0,1],[0,-1]]\n```\n[https://youtu.be/00BEcax1fu8](https://youtu.be/00BEcax1fu8)"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints for those who want to code on their own:\\n\\n1. 2 points are always co-linear.\\n2. 3 points are co-linear if the slope of lines joining any 2 of the 3 points is same.\\n3. Be a bit careful while calculating slope. The denominator might be 0.\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Finally a real Good Morning after a scary fortnight."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "tan(0)=(y2-y1)/(x2-x1)\\nfor multiple points.\\n(y2-y1)/(x2-x1)==(y1-y0)/(x1-x0)\\nBut in this 0/0 exception come.\\nSo rearrange the formula. \\n**(y2-y1)*(x1-x0)==(y1-y0)*(x2-x1)**\\n\\nCODE is solution section."
                    },
                    {
                        "username": "artem09122002",
                        "content": "I do not think that this case is correct \\n\\nInput\\ncoordinates =\\n[[0,0],[0,1],[0,-1]]\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@RomNc](/RomNc) But according to question, we have to \"Check if these points make a straight line in the XY plane or not\". So, I can't see anything wrong."
                    },
                    {
                        "username": "RomNc",
                        "content": "[@Rajat310](/Rajat310) The points form a straight line, but mathematically speaking the gradient of a vertical line is undefined. So, this one another amiguously presented question on leetcode. \nThe point is we need to apply some sort of mathemataical formula to solve this problem, while a vertilcal line is not a case to which this mathematical formula can be applied. But anyways..."
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@artem09122002](/artem09122002) It is true. The x-coordinates are all the same(i.e. constant) and thus form a straight line on the x-axis regardless of the y-axis."
                    }
                ]
            },
            {
                "id": 1737208,
                "content": [
                    {
                        "username": "JuanQP",
                        "content": "There are at least 3 things you should know to solve this.\\n\\n* Remember when in high school you asked your teacher *Who cares what is the slope between two points? When am I going to use this anyway?*, well, this is one of those situations. So, remember: \\n$$m = (y_2 - y_1) / (x_2 - x_1)$$\\n* It would be easy to solve this if the points were sorted... Right?\\n* There is a border case: What if two points have the same `x` value? Ouch. That would be a division by zero. Think how to take care of this particular case.\\n\\nThose tips should do the trick for you. Happy coding."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@theRadFad](/theRadFad) Yeah, sorting won\\'t be helpful here at all. The reason is that you can either sort in the direction of x or in the direction of y. If the points were in a straight line, they would already appear sorted in some direction (either x or y). So, in that case, you don\\'t get any advantage by sorting. I suppose its not needed."
                    },
                    {
                        "username": "theRadFad",
                        "content": "Lovely hints. I would just like to add that, perhaps, sorting may not be that important .. right?"
                    },
                    {
                        "username": "singh__12",
                        "content": "[@Jagannath01](/Jagannath01) You are dividing by zero for this case [[0,0],[0,1],[0,-1]] so modifie your code as                                                                         \\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int n=coordinates.size();\\n        int xmove=coordinates[1][0]-coordinates[0][0];  // same as x2-x1\\n        int ymove=coordinates[1][1]-coordinates[0][1];  // same as y2-y1\\n\\n        for(int i=1;i<n;i++){\\n            int x=coordinates[i][0]-coordinates[i-1][0];\\n            int y=coordinates[i][1]-coordinates[i-1][1];\\n            if(y*xmove!=x*ymove) return false;\\n        } \\n        return true;   \\n    }\\n};"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "i tried with the same approach still I am getting error..\\n\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n        int n=coordinates.length;\\n\\n        int m=(coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n\\n        boolean ans=false;\\n\\n        for(int i=1; i<n-1 ;i++){\\n\\n            if((coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0])==m){\\n\\n                ans=true;\\n            }\\n            else{\\n                ans=false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "mochy",
                        "content": "Use standard form so you don't have to deal with vertical lines (division by zero).\n$$y-y_1 = \fm(x-x_1)$$\n$$y-y_1 = \f(Δy/Δx)(x-x_1)$$\n$$Δx(y-y_1) = Δy(x-x_1)$$"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try vector method as opposed to Cartesian method"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as medium problem\\n"
                    },
                    {
                        "username": "luzede",
                        "content": "Writing the code is piece of cake if you remember the line equation from Highschool "
                    },
                    {
                        "username": "azuregcp",
                        "content": "Why? It\\'s just a basic high school mathematics problem."
                    },
                    {
                        "username": "ObviouslyBhavya",
                        "content": "To check if three points are in straight line or not we try to assume it as a triangle and if the area of traingle if zero then we say that the three points are in straight line.\\n\\nThe solution to this question is you take the first 2 points and check for every point if with any point the first two points makes a triangle of a positive area the answer is no that the coordinates are not in straight line.\\n\\nThe formula to calculate area is (1/12)*(x1(y2-y3) + x2(y3-y1) + x3(y1-y2)) apply the same formula learnt in school"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a question for the school math. Every point (x[i], y[i]) (for i!=0, 1)on the line satisfies\n$\n(y[i]-y[0])/(x[i]-x[0])=(y[1]-y[0])/(x[1]-x[0])=$slope of this line\n\nbut be careful, not divided by zero. Before submitting, try the following test case:\n```\n[[0,0],[0,1],[0,-1]]\n```\n[https://youtu.be/00BEcax1fu8](https://youtu.be/00BEcax1fu8)"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints for those who want to code on their own:\\n\\n1. 2 points are always co-linear.\\n2. 3 points are co-linear if the slope of lines joining any 2 of the 3 points is same.\\n3. Be a bit careful while calculating slope. The denominator might be 0.\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Finally a real Good Morning after a scary fortnight."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "tan(0)=(y2-y1)/(x2-x1)\\nfor multiple points.\\n(y2-y1)/(x2-x1)==(y1-y0)/(x1-x0)\\nBut in this 0/0 exception come.\\nSo rearrange the formula. \\n**(y2-y1)*(x1-x0)==(y1-y0)*(x2-x1)**\\n\\nCODE is solution section."
                    },
                    {
                        "username": "artem09122002",
                        "content": "I do not think that this case is correct \\n\\nInput\\ncoordinates =\\n[[0,0],[0,1],[0,-1]]\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@RomNc](/RomNc) But according to question, we have to \"Check if these points make a straight line in the XY plane or not\". So, I can't see anything wrong."
                    },
                    {
                        "username": "RomNc",
                        "content": "[@Rajat310](/Rajat310) The points form a straight line, but mathematically speaking the gradient of a vertical line is undefined. So, this one another amiguously presented question on leetcode. \nThe point is we need to apply some sort of mathemataical formula to solve this problem, while a vertilcal line is not a case to which this mathematical formula can be applied. But anyways..."
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@artem09122002](/artem09122002) It is true. The x-coordinates are all the same(i.e. constant) and thus form a straight line on the x-axis regardless of the y-axis."
                    }
                ]
            },
            {
                "id": 1917820,
                "content": [
                    {
                        "username": "JuanQP",
                        "content": "There are at least 3 things you should know to solve this.\\n\\n* Remember when in high school you asked your teacher *Who cares what is the slope between two points? When am I going to use this anyway?*, well, this is one of those situations. So, remember: \\n$$m = (y_2 - y_1) / (x_2 - x_1)$$\\n* It would be easy to solve this if the points were sorted... Right?\\n* There is a border case: What if two points have the same `x` value? Ouch. That would be a division by zero. Think how to take care of this particular case.\\n\\nThose tips should do the trick for you. Happy coding."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@theRadFad](/theRadFad) Yeah, sorting won\\'t be helpful here at all. The reason is that you can either sort in the direction of x or in the direction of y. If the points were in a straight line, they would already appear sorted in some direction (either x or y). So, in that case, you don\\'t get any advantage by sorting. I suppose its not needed."
                    },
                    {
                        "username": "theRadFad",
                        "content": "Lovely hints. I would just like to add that, perhaps, sorting may not be that important .. right?"
                    },
                    {
                        "username": "singh__12",
                        "content": "[@Jagannath01](/Jagannath01) You are dividing by zero for this case [[0,0],[0,1],[0,-1]] so modifie your code as                                                                         \\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int n=coordinates.size();\\n        int xmove=coordinates[1][0]-coordinates[0][0];  // same as x2-x1\\n        int ymove=coordinates[1][1]-coordinates[0][1];  // same as y2-y1\\n\\n        for(int i=1;i<n;i++){\\n            int x=coordinates[i][0]-coordinates[i-1][0];\\n            int y=coordinates[i][1]-coordinates[i-1][1];\\n            if(y*xmove!=x*ymove) return false;\\n        } \\n        return true;   \\n    }\\n};"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "i tried with the same approach still I am getting error..\\n\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n        int n=coordinates.length;\\n\\n        int m=(coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n\\n        boolean ans=false;\\n\\n        for(int i=1; i<n-1 ;i++){\\n\\n            if((coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0])==m){\\n\\n                ans=true;\\n            }\\n            else{\\n                ans=false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "mochy",
                        "content": "Use standard form so you don't have to deal with vertical lines (division by zero).\n$$y-y_1 = \fm(x-x_1)$$\n$$y-y_1 = \f(Δy/Δx)(x-x_1)$$\n$$Δx(y-y_1) = Δy(x-x_1)$$"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try vector method as opposed to Cartesian method"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as medium problem\\n"
                    },
                    {
                        "username": "luzede",
                        "content": "Writing the code is piece of cake if you remember the line equation from Highschool "
                    },
                    {
                        "username": "azuregcp",
                        "content": "Why? It\\'s just a basic high school mathematics problem."
                    },
                    {
                        "username": "ObviouslyBhavya",
                        "content": "To check if three points are in straight line or not we try to assume it as a triangle and if the area of traingle if zero then we say that the three points are in straight line.\\n\\nThe solution to this question is you take the first 2 points and check for every point if with any point the first two points makes a triangle of a positive area the answer is no that the coordinates are not in straight line.\\n\\nThe formula to calculate area is (1/12)*(x1(y2-y3) + x2(y3-y1) + x3(y1-y2)) apply the same formula learnt in school"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a question for the school math. Every point (x[i], y[i]) (for i!=0, 1)on the line satisfies\n$\n(y[i]-y[0])/(x[i]-x[0])=(y[1]-y[0])/(x[1]-x[0])=$slope of this line\n\nbut be careful, not divided by zero. Before submitting, try the following test case:\n```\n[[0,0],[0,1],[0,-1]]\n```\n[https://youtu.be/00BEcax1fu8](https://youtu.be/00BEcax1fu8)"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints for those who want to code on their own:\\n\\n1. 2 points are always co-linear.\\n2. 3 points are co-linear if the slope of lines joining any 2 of the 3 points is same.\\n3. Be a bit careful while calculating slope. The denominator might be 0.\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Finally a real Good Morning after a scary fortnight."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "tan(0)=(y2-y1)/(x2-x1)\\nfor multiple points.\\n(y2-y1)/(x2-x1)==(y1-y0)/(x1-x0)\\nBut in this 0/0 exception come.\\nSo rearrange the formula. \\n**(y2-y1)*(x1-x0)==(y1-y0)*(x2-x1)**\\n\\nCODE is solution section."
                    },
                    {
                        "username": "artem09122002",
                        "content": "I do not think that this case is correct \\n\\nInput\\ncoordinates =\\n[[0,0],[0,1],[0,-1]]\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@RomNc](/RomNc) But according to question, we have to \"Check if these points make a straight line in the XY plane or not\". So, I can't see anything wrong."
                    },
                    {
                        "username": "RomNc",
                        "content": "[@Rajat310](/Rajat310) The points form a straight line, but mathematically speaking the gradient of a vertical line is undefined. So, this one another amiguously presented question on leetcode. \nThe point is we need to apply some sort of mathemataical formula to solve this problem, while a vertilcal line is not a case to which this mathematical formula can be applied. But anyways..."
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@artem09122002](/artem09122002) It is true. The x-coordinates are all the same(i.e. constant) and thus form a straight line on the x-axis regardless of the y-axis."
                    }
                ]
            },
            {
                "id": 1745231,
                "content": [
                    {
                        "username": "JuanQP",
                        "content": "There are at least 3 things you should know to solve this.\\n\\n* Remember when in high school you asked your teacher *Who cares what is the slope between two points? When am I going to use this anyway?*, well, this is one of those situations. So, remember: \\n$$m = (y_2 - y_1) / (x_2 - x_1)$$\\n* It would be easy to solve this if the points were sorted... Right?\\n* There is a border case: What if two points have the same `x` value? Ouch. That would be a division by zero. Think how to take care of this particular case.\\n\\nThose tips should do the trick for you. Happy coding."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@theRadFad](/theRadFad) Yeah, sorting won\\'t be helpful here at all. The reason is that you can either sort in the direction of x or in the direction of y. If the points were in a straight line, they would already appear sorted in some direction (either x or y). So, in that case, you don\\'t get any advantage by sorting. I suppose its not needed."
                    },
                    {
                        "username": "theRadFad",
                        "content": "Lovely hints. I would just like to add that, perhaps, sorting may not be that important .. right?"
                    },
                    {
                        "username": "singh__12",
                        "content": "[@Jagannath01](/Jagannath01) You are dividing by zero for this case [[0,0],[0,1],[0,-1]] so modifie your code as                                                                         \\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int n=coordinates.size();\\n        int xmove=coordinates[1][0]-coordinates[0][0];  // same as x2-x1\\n        int ymove=coordinates[1][1]-coordinates[0][1];  // same as y2-y1\\n\\n        for(int i=1;i<n;i++){\\n            int x=coordinates[i][0]-coordinates[i-1][0];\\n            int y=coordinates[i][1]-coordinates[i-1][1];\\n            if(y*xmove!=x*ymove) return false;\\n        } \\n        return true;   \\n    }\\n};"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "i tried with the same approach still I am getting error..\\n\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n        int n=coordinates.length;\\n\\n        int m=(coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n\\n        boolean ans=false;\\n\\n        for(int i=1; i<n-1 ;i++){\\n\\n            if((coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0])==m){\\n\\n                ans=true;\\n            }\\n            else{\\n                ans=false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "mochy",
                        "content": "Use standard form so you don't have to deal with vertical lines (division by zero).\n$$y-y_1 = \fm(x-x_1)$$\n$$y-y_1 = \f(Δy/Δx)(x-x_1)$$\n$$Δx(y-y_1) = Δy(x-x_1)$$"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try vector method as opposed to Cartesian method"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as medium problem\\n"
                    },
                    {
                        "username": "luzede",
                        "content": "Writing the code is piece of cake if you remember the line equation from Highschool "
                    },
                    {
                        "username": "azuregcp",
                        "content": "Why? It\\'s just a basic high school mathematics problem."
                    },
                    {
                        "username": "ObviouslyBhavya",
                        "content": "To check if three points are in straight line or not we try to assume it as a triangle and if the area of traingle if zero then we say that the three points are in straight line.\\n\\nThe solution to this question is you take the first 2 points and check for every point if with any point the first two points makes a triangle of a positive area the answer is no that the coordinates are not in straight line.\\n\\nThe formula to calculate area is (1/12)*(x1(y2-y3) + x2(y3-y1) + x3(y1-y2)) apply the same formula learnt in school"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a question for the school math. Every point (x[i], y[i]) (for i!=0, 1)on the line satisfies\n$\n(y[i]-y[0])/(x[i]-x[0])=(y[1]-y[0])/(x[1]-x[0])=$slope of this line\n\nbut be careful, not divided by zero. Before submitting, try the following test case:\n```\n[[0,0],[0,1],[0,-1]]\n```\n[https://youtu.be/00BEcax1fu8](https://youtu.be/00BEcax1fu8)"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints for those who want to code on their own:\\n\\n1. 2 points are always co-linear.\\n2. 3 points are co-linear if the slope of lines joining any 2 of the 3 points is same.\\n3. Be a bit careful while calculating slope. The denominator might be 0.\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Finally a real Good Morning after a scary fortnight."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "tan(0)=(y2-y1)/(x2-x1)\\nfor multiple points.\\n(y2-y1)/(x2-x1)==(y1-y0)/(x1-x0)\\nBut in this 0/0 exception come.\\nSo rearrange the formula. \\n**(y2-y1)*(x1-x0)==(y1-y0)*(x2-x1)**\\n\\nCODE is solution section."
                    },
                    {
                        "username": "artem09122002",
                        "content": "I do not think that this case is correct \\n\\nInput\\ncoordinates =\\n[[0,0],[0,1],[0,-1]]\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@RomNc](/RomNc) But according to question, we have to \"Check if these points make a straight line in the XY plane or not\". So, I can't see anything wrong."
                    },
                    {
                        "username": "RomNc",
                        "content": "[@Rajat310](/Rajat310) The points form a straight line, but mathematically speaking the gradient of a vertical line is undefined. So, this one another amiguously presented question on leetcode. \nThe point is we need to apply some sort of mathemataical formula to solve this problem, while a vertilcal line is not a case to which this mathematical formula can be applied. But anyways..."
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@artem09122002](/artem09122002) It is true. The x-coordinates are all the same(i.e. constant) and thus form a straight line on the x-axis regardless of the y-axis."
                    }
                ]
            },
            {
                "id": 1917215,
                "content": [
                    {
                        "username": "JuanQP",
                        "content": "There are at least 3 things you should know to solve this.\\n\\n* Remember when in high school you asked your teacher *Who cares what is the slope between two points? When am I going to use this anyway?*, well, this is one of those situations. So, remember: \\n$$m = (y_2 - y_1) / (x_2 - x_1)$$\\n* It would be easy to solve this if the points were sorted... Right?\\n* There is a border case: What if two points have the same `x` value? Ouch. That would be a division by zero. Think how to take care of this particular case.\\n\\nThose tips should do the trick for you. Happy coding."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@theRadFad](/theRadFad) Yeah, sorting won\\'t be helpful here at all. The reason is that you can either sort in the direction of x or in the direction of y. If the points were in a straight line, they would already appear sorted in some direction (either x or y). So, in that case, you don\\'t get any advantage by sorting. I suppose its not needed."
                    },
                    {
                        "username": "theRadFad",
                        "content": "Lovely hints. I would just like to add that, perhaps, sorting may not be that important .. right?"
                    },
                    {
                        "username": "singh__12",
                        "content": "[@Jagannath01](/Jagannath01) You are dividing by zero for this case [[0,0],[0,1],[0,-1]] so modifie your code as                                                                         \\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int n=coordinates.size();\\n        int xmove=coordinates[1][0]-coordinates[0][0];  // same as x2-x1\\n        int ymove=coordinates[1][1]-coordinates[0][1];  // same as y2-y1\\n\\n        for(int i=1;i<n;i++){\\n            int x=coordinates[i][0]-coordinates[i-1][0];\\n            int y=coordinates[i][1]-coordinates[i-1][1];\\n            if(y*xmove!=x*ymove) return false;\\n        } \\n        return true;   \\n    }\\n};"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "i tried with the same approach still I am getting error..\\n\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n        int n=coordinates.length;\\n\\n        int m=(coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n\\n        boolean ans=false;\\n\\n        for(int i=1; i<n-1 ;i++){\\n\\n            if((coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0])==m){\\n\\n                ans=true;\\n            }\\n            else{\\n                ans=false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "mochy",
                        "content": "Use standard form so you don't have to deal with vertical lines (division by zero).\n$$y-y_1 = \fm(x-x_1)$$\n$$y-y_1 = \f(Δy/Δx)(x-x_1)$$\n$$Δx(y-y_1) = Δy(x-x_1)$$"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try vector method as opposed to Cartesian method"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as medium problem\\n"
                    },
                    {
                        "username": "luzede",
                        "content": "Writing the code is piece of cake if you remember the line equation from Highschool "
                    },
                    {
                        "username": "azuregcp",
                        "content": "Why? It\\'s just a basic high school mathematics problem."
                    },
                    {
                        "username": "ObviouslyBhavya",
                        "content": "To check if three points are in straight line or not we try to assume it as a triangle and if the area of traingle if zero then we say that the three points are in straight line.\\n\\nThe solution to this question is you take the first 2 points and check for every point if with any point the first two points makes a triangle of a positive area the answer is no that the coordinates are not in straight line.\\n\\nThe formula to calculate area is (1/12)*(x1(y2-y3) + x2(y3-y1) + x3(y1-y2)) apply the same formula learnt in school"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a question for the school math. Every point (x[i], y[i]) (for i!=0, 1)on the line satisfies\n$\n(y[i]-y[0])/(x[i]-x[0])=(y[1]-y[0])/(x[1]-x[0])=$slope of this line\n\nbut be careful, not divided by zero. Before submitting, try the following test case:\n```\n[[0,0],[0,1],[0,-1]]\n```\n[https://youtu.be/00BEcax1fu8](https://youtu.be/00BEcax1fu8)"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints for those who want to code on their own:\\n\\n1. 2 points are always co-linear.\\n2. 3 points are co-linear if the slope of lines joining any 2 of the 3 points is same.\\n3. Be a bit careful while calculating slope. The denominator might be 0.\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Finally a real Good Morning after a scary fortnight."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "tan(0)=(y2-y1)/(x2-x1)\\nfor multiple points.\\n(y2-y1)/(x2-x1)==(y1-y0)/(x1-x0)\\nBut in this 0/0 exception come.\\nSo rearrange the formula. \\n**(y2-y1)*(x1-x0)==(y1-y0)*(x2-x1)**\\n\\nCODE is solution section."
                    },
                    {
                        "username": "artem09122002",
                        "content": "I do not think that this case is correct \\n\\nInput\\ncoordinates =\\n[[0,0],[0,1],[0,-1]]\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@RomNc](/RomNc) But according to question, we have to \"Check if these points make a straight line in the XY plane or not\". So, I can't see anything wrong."
                    },
                    {
                        "username": "RomNc",
                        "content": "[@Rajat310](/Rajat310) The points form a straight line, but mathematically speaking the gradient of a vertical line is undefined. So, this one another amiguously presented question on leetcode. \nThe point is we need to apply some sort of mathemataical formula to solve this problem, while a vertilcal line is not a case to which this mathematical formula can be applied. But anyways..."
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@artem09122002](/artem09122002) It is true. The x-coordinates are all the same(i.e. constant) and thus form a straight line on the x-axis regardless of the y-axis."
                    }
                ]
            },
            {
                "id": 1719187,
                "content": [
                    {
                        "username": "JuanQP",
                        "content": "There are at least 3 things you should know to solve this.\\n\\n* Remember when in high school you asked your teacher *Who cares what is the slope between two points? When am I going to use this anyway?*, well, this is one of those situations. So, remember: \\n$$m = (y_2 - y_1) / (x_2 - x_1)$$\\n* It would be easy to solve this if the points were sorted... Right?\\n* There is a border case: What if two points have the same `x` value? Ouch. That would be a division by zero. Think how to take care of this particular case.\\n\\nThose tips should do the trick for you. Happy coding."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@theRadFad](/theRadFad) Yeah, sorting won\\'t be helpful here at all. The reason is that you can either sort in the direction of x or in the direction of y. If the points were in a straight line, they would already appear sorted in some direction (either x or y). So, in that case, you don\\'t get any advantage by sorting. I suppose its not needed."
                    },
                    {
                        "username": "theRadFad",
                        "content": "Lovely hints. I would just like to add that, perhaps, sorting may not be that important .. right?"
                    },
                    {
                        "username": "singh__12",
                        "content": "[@Jagannath01](/Jagannath01) You are dividing by zero for this case [[0,0],[0,1],[0,-1]] so modifie your code as                                                                         \\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int n=coordinates.size();\\n        int xmove=coordinates[1][0]-coordinates[0][0];  // same as x2-x1\\n        int ymove=coordinates[1][1]-coordinates[0][1];  // same as y2-y1\\n\\n        for(int i=1;i<n;i++){\\n            int x=coordinates[i][0]-coordinates[i-1][0];\\n            int y=coordinates[i][1]-coordinates[i-1][1];\\n            if(y*xmove!=x*ymove) return false;\\n        } \\n        return true;   \\n    }\\n};"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "i tried with the same approach still I am getting error..\\n\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n        int n=coordinates.length;\\n\\n        int m=(coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n\\n        boolean ans=false;\\n\\n        for(int i=1; i<n-1 ;i++){\\n\\n            if((coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0])==m){\\n\\n                ans=true;\\n            }\\n            else{\\n                ans=false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "mochy",
                        "content": "Use standard form so you don't have to deal with vertical lines (division by zero).\n$$y-y_1 = \fm(x-x_1)$$\n$$y-y_1 = \f(Δy/Δx)(x-x_1)$$\n$$Δx(y-y_1) = Δy(x-x_1)$$"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try vector method as opposed to Cartesian method"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as medium problem\\n"
                    },
                    {
                        "username": "luzede",
                        "content": "Writing the code is piece of cake if you remember the line equation from Highschool "
                    },
                    {
                        "username": "azuregcp",
                        "content": "Why? It\\'s just a basic high school mathematics problem."
                    },
                    {
                        "username": "ObviouslyBhavya",
                        "content": "To check if three points are in straight line or not we try to assume it as a triangle and if the area of traingle if zero then we say that the three points are in straight line.\\n\\nThe solution to this question is you take the first 2 points and check for every point if with any point the first two points makes a triangle of a positive area the answer is no that the coordinates are not in straight line.\\n\\nThe formula to calculate area is (1/12)*(x1(y2-y3) + x2(y3-y1) + x3(y1-y2)) apply the same formula learnt in school"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a question for the school math. Every point (x[i], y[i]) (for i!=0, 1)on the line satisfies\n$\n(y[i]-y[0])/(x[i]-x[0])=(y[1]-y[0])/(x[1]-x[0])=$slope of this line\n\nbut be careful, not divided by zero. Before submitting, try the following test case:\n```\n[[0,0],[0,1],[0,-1]]\n```\n[https://youtu.be/00BEcax1fu8](https://youtu.be/00BEcax1fu8)"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints for those who want to code on their own:\\n\\n1. 2 points are always co-linear.\\n2. 3 points are co-linear if the slope of lines joining any 2 of the 3 points is same.\\n3. Be a bit careful while calculating slope. The denominator might be 0.\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Finally a real Good Morning after a scary fortnight."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "tan(0)=(y2-y1)/(x2-x1)\\nfor multiple points.\\n(y2-y1)/(x2-x1)==(y1-y0)/(x1-x0)\\nBut in this 0/0 exception come.\\nSo rearrange the formula. \\n**(y2-y1)*(x1-x0)==(y1-y0)*(x2-x1)**\\n\\nCODE is solution section."
                    },
                    {
                        "username": "artem09122002",
                        "content": "I do not think that this case is correct \\n\\nInput\\ncoordinates =\\n[[0,0],[0,1],[0,-1]]\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@RomNc](/RomNc) But according to question, we have to \"Check if these points make a straight line in the XY plane or not\". So, I can't see anything wrong."
                    },
                    {
                        "username": "RomNc",
                        "content": "[@Rajat310](/Rajat310) The points form a straight line, but mathematically speaking the gradient of a vertical line is undefined. So, this one another amiguously presented question on leetcode. \nThe point is we need to apply some sort of mathemataical formula to solve this problem, while a vertilcal line is not a case to which this mathematical formula can be applied. But anyways..."
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@artem09122002](/artem09122002) It is true. The x-coordinates are all the same(i.e. constant) and thus form a straight line on the x-axis regardless of the y-axis."
                    }
                ]
            },
            {
                "id": 1917509,
                "content": [
                    {
                        "username": "JuanQP",
                        "content": "There are at least 3 things you should know to solve this.\\n\\n* Remember when in high school you asked your teacher *Who cares what is the slope between two points? When am I going to use this anyway?*, well, this is one of those situations. So, remember: \\n$$m = (y_2 - y_1) / (x_2 - x_1)$$\\n* It would be easy to solve this if the points were sorted... Right?\\n* There is a border case: What if two points have the same `x` value? Ouch. That would be a division by zero. Think how to take care of this particular case.\\n\\nThose tips should do the trick for you. Happy coding."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@theRadFad](/theRadFad) Yeah, sorting won\\'t be helpful here at all. The reason is that you can either sort in the direction of x or in the direction of y. If the points were in a straight line, they would already appear sorted in some direction (either x or y). So, in that case, you don\\'t get any advantage by sorting. I suppose its not needed."
                    },
                    {
                        "username": "theRadFad",
                        "content": "Lovely hints. I would just like to add that, perhaps, sorting may not be that important .. right?"
                    },
                    {
                        "username": "singh__12",
                        "content": "[@Jagannath01](/Jagannath01) You are dividing by zero for this case [[0,0],[0,1],[0,-1]] so modifie your code as                                                                         \\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int n=coordinates.size();\\n        int xmove=coordinates[1][0]-coordinates[0][0];  // same as x2-x1\\n        int ymove=coordinates[1][1]-coordinates[0][1];  // same as y2-y1\\n\\n        for(int i=1;i<n;i++){\\n            int x=coordinates[i][0]-coordinates[i-1][0];\\n            int y=coordinates[i][1]-coordinates[i-1][1];\\n            if(y*xmove!=x*ymove) return false;\\n        } \\n        return true;   \\n    }\\n};"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "i tried with the same approach still I am getting error..\\n\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n        int n=coordinates.length;\\n\\n        int m=(coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n\\n        boolean ans=false;\\n\\n        for(int i=1; i<n-1 ;i++){\\n\\n            if((coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0])==m){\\n\\n                ans=true;\\n            }\\n            else{\\n                ans=false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "mochy",
                        "content": "Use standard form so you don't have to deal with vertical lines (division by zero).\n$$y-y_1 = \fm(x-x_1)$$\n$$y-y_1 = \f(Δy/Δx)(x-x_1)$$\n$$Δx(y-y_1) = Δy(x-x_1)$$"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try vector method as opposed to Cartesian method"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as medium problem\\n"
                    },
                    {
                        "username": "luzede",
                        "content": "Writing the code is piece of cake if you remember the line equation from Highschool "
                    },
                    {
                        "username": "azuregcp",
                        "content": "Why? It\\'s just a basic high school mathematics problem."
                    },
                    {
                        "username": "ObviouslyBhavya",
                        "content": "To check if three points are in straight line or not we try to assume it as a triangle and if the area of traingle if zero then we say that the three points are in straight line.\\n\\nThe solution to this question is you take the first 2 points and check for every point if with any point the first two points makes a triangle of a positive area the answer is no that the coordinates are not in straight line.\\n\\nThe formula to calculate area is (1/12)*(x1(y2-y3) + x2(y3-y1) + x3(y1-y2)) apply the same formula learnt in school"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a question for the school math. Every point (x[i], y[i]) (for i!=0, 1)on the line satisfies\n$\n(y[i]-y[0])/(x[i]-x[0])=(y[1]-y[0])/(x[1]-x[0])=$slope of this line\n\nbut be careful, not divided by zero. Before submitting, try the following test case:\n```\n[[0,0],[0,1],[0,-1]]\n```\n[https://youtu.be/00BEcax1fu8](https://youtu.be/00BEcax1fu8)"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints for those who want to code on their own:\\n\\n1. 2 points are always co-linear.\\n2. 3 points are co-linear if the slope of lines joining any 2 of the 3 points is same.\\n3. Be a bit careful while calculating slope. The denominator might be 0.\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Finally a real Good Morning after a scary fortnight."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "tan(0)=(y2-y1)/(x2-x1)\\nfor multiple points.\\n(y2-y1)/(x2-x1)==(y1-y0)/(x1-x0)\\nBut in this 0/0 exception come.\\nSo rearrange the formula. \\n**(y2-y1)*(x1-x0)==(y1-y0)*(x2-x1)**\\n\\nCODE is solution section."
                    },
                    {
                        "username": "artem09122002",
                        "content": "I do not think that this case is correct \\n\\nInput\\ncoordinates =\\n[[0,0],[0,1],[0,-1]]\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@RomNc](/RomNc) But according to question, we have to \"Check if these points make a straight line in the XY plane or not\". So, I can't see anything wrong."
                    },
                    {
                        "username": "RomNc",
                        "content": "[@Rajat310](/Rajat310) The points form a straight line, but mathematically speaking the gradient of a vertical line is undefined. So, this one another amiguously presented question on leetcode. \nThe point is we need to apply some sort of mathemataical formula to solve this problem, while a vertilcal line is not a case to which this mathematical formula can be applied. But anyways..."
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@artem09122002](/artem09122002) It is true. The x-coordinates are all the same(i.e. constant) and thus form a straight line on the x-axis regardless of the y-axis."
                    }
                ]
            },
            {
                "id": 1917485,
                "content": [
                    {
                        "username": "JuanQP",
                        "content": "There are at least 3 things you should know to solve this.\\n\\n* Remember when in high school you asked your teacher *Who cares what is the slope between two points? When am I going to use this anyway?*, well, this is one of those situations. So, remember: \\n$$m = (y_2 - y_1) / (x_2 - x_1)$$\\n* It would be easy to solve this if the points were sorted... Right?\\n* There is a border case: What if two points have the same `x` value? Ouch. That would be a division by zero. Think how to take care of this particular case.\\n\\nThose tips should do the trick for you. Happy coding."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@theRadFad](/theRadFad) Yeah, sorting won\\'t be helpful here at all. The reason is that you can either sort in the direction of x or in the direction of y. If the points were in a straight line, they would already appear sorted in some direction (either x or y). So, in that case, you don\\'t get any advantage by sorting. I suppose its not needed."
                    },
                    {
                        "username": "theRadFad",
                        "content": "Lovely hints. I would just like to add that, perhaps, sorting may not be that important .. right?"
                    },
                    {
                        "username": "singh__12",
                        "content": "[@Jagannath01](/Jagannath01) You are dividing by zero for this case [[0,0],[0,1],[0,-1]] so modifie your code as                                                                         \\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int n=coordinates.size();\\n        int xmove=coordinates[1][0]-coordinates[0][0];  // same as x2-x1\\n        int ymove=coordinates[1][1]-coordinates[0][1];  // same as y2-y1\\n\\n        for(int i=1;i<n;i++){\\n            int x=coordinates[i][0]-coordinates[i-1][0];\\n            int y=coordinates[i][1]-coordinates[i-1][1];\\n            if(y*xmove!=x*ymove) return false;\\n        } \\n        return true;   \\n    }\\n};"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "i tried with the same approach still I am getting error..\\n\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n        int n=coordinates.length;\\n\\n        int m=(coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n\\n        boolean ans=false;\\n\\n        for(int i=1; i<n-1 ;i++){\\n\\n            if((coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0])==m){\\n\\n                ans=true;\\n            }\\n            else{\\n                ans=false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "mochy",
                        "content": "Use standard form so you don't have to deal with vertical lines (division by zero).\n$$y-y_1 = \fm(x-x_1)$$\n$$y-y_1 = \f(Δy/Δx)(x-x_1)$$\n$$Δx(y-y_1) = Δy(x-x_1)$$"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try vector method as opposed to Cartesian method"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as medium problem\\n"
                    },
                    {
                        "username": "luzede",
                        "content": "Writing the code is piece of cake if you remember the line equation from Highschool "
                    },
                    {
                        "username": "azuregcp",
                        "content": "Why? It\\'s just a basic high school mathematics problem."
                    },
                    {
                        "username": "ObviouslyBhavya",
                        "content": "To check if three points are in straight line or not we try to assume it as a triangle and if the area of traingle if zero then we say that the three points are in straight line.\\n\\nThe solution to this question is you take the first 2 points and check for every point if with any point the first two points makes a triangle of a positive area the answer is no that the coordinates are not in straight line.\\n\\nThe formula to calculate area is (1/12)*(x1(y2-y3) + x2(y3-y1) + x3(y1-y2)) apply the same formula learnt in school"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a question for the school math. Every point (x[i], y[i]) (for i!=0, 1)on the line satisfies\n$\n(y[i]-y[0])/(x[i]-x[0])=(y[1]-y[0])/(x[1]-x[0])=$slope of this line\n\nbut be careful, not divided by zero. Before submitting, try the following test case:\n```\n[[0,0],[0,1],[0,-1]]\n```\n[https://youtu.be/00BEcax1fu8](https://youtu.be/00BEcax1fu8)"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints for those who want to code on their own:\\n\\n1. 2 points are always co-linear.\\n2. 3 points are co-linear if the slope of lines joining any 2 of the 3 points is same.\\n3. Be a bit careful while calculating slope. The denominator might be 0.\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Finally a real Good Morning after a scary fortnight."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "tan(0)=(y2-y1)/(x2-x1)\\nfor multiple points.\\n(y2-y1)/(x2-x1)==(y1-y0)/(x1-x0)\\nBut in this 0/0 exception come.\\nSo rearrange the formula. \\n**(y2-y1)*(x1-x0)==(y1-y0)*(x2-x1)**\\n\\nCODE is solution section."
                    },
                    {
                        "username": "artem09122002",
                        "content": "I do not think that this case is correct \\n\\nInput\\ncoordinates =\\n[[0,0],[0,1],[0,-1]]\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@RomNc](/RomNc) But according to question, we have to \"Check if these points make a straight line in the XY plane or not\". So, I can't see anything wrong."
                    },
                    {
                        "username": "RomNc",
                        "content": "[@Rajat310](/Rajat310) The points form a straight line, but mathematically speaking the gradient of a vertical line is undefined. So, this one another amiguously presented question on leetcode. \nThe point is we need to apply some sort of mathemataical formula to solve this problem, while a vertilcal line is not a case to which this mathematical formula can be applied. But anyways..."
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@artem09122002](/artem09122002) It is true. The x-coordinates are all the same(i.e. constant) and thus form a straight line on the x-axis regardless of the y-axis."
                    }
                ]
            },
            {
                "id": 1925884,
                "content": [
                    {
                        "username": "JuanQP",
                        "content": "There are at least 3 things you should know to solve this.\\n\\n* Remember when in high school you asked your teacher *Who cares what is the slope between two points? When am I going to use this anyway?*, well, this is one of those situations. So, remember: \\n$$m = (y_2 - y_1) / (x_2 - x_1)$$\\n* It would be easy to solve this if the points were sorted... Right?\\n* There is a border case: What if two points have the same `x` value? Ouch. That would be a division by zero. Think how to take care of this particular case.\\n\\nThose tips should do the trick for you. Happy coding."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@theRadFad](/theRadFad) Yeah, sorting won\\'t be helpful here at all. The reason is that you can either sort in the direction of x or in the direction of y. If the points were in a straight line, they would already appear sorted in some direction (either x or y). So, in that case, you don\\'t get any advantage by sorting. I suppose its not needed."
                    },
                    {
                        "username": "theRadFad",
                        "content": "Lovely hints. I would just like to add that, perhaps, sorting may not be that important .. right?"
                    },
                    {
                        "username": "singh__12",
                        "content": "[@Jagannath01](/Jagannath01) You are dividing by zero for this case [[0,0],[0,1],[0,-1]] so modifie your code as                                                                         \\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int n=coordinates.size();\\n        int xmove=coordinates[1][0]-coordinates[0][0];  // same as x2-x1\\n        int ymove=coordinates[1][1]-coordinates[0][1];  // same as y2-y1\\n\\n        for(int i=1;i<n;i++){\\n            int x=coordinates[i][0]-coordinates[i-1][0];\\n            int y=coordinates[i][1]-coordinates[i-1][1];\\n            if(y*xmove!=x*ymove) return false;\\n        } \\n        return true;   \\n    }\\n};"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "i tried with the same approach still I am getting error..\\n\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n        int n=coordinates.length;\\n\\n        int m=(coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n\\n        boolean ans=false;\\n\\n        for(int i=1; i<n-1 ;i++){\\n\\n            if((coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0])==m){\\n\\n                ans=true;\\n            }\\n            else{\\n                ans=false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "mochy",
                        "content": "Use standard form so you don't have to deal with vertical lines (division by zero).\n$$y-y_1 = \fm(x-x_1)$$\n$$y-y_1 = \f(Δy/Δx)(x-x_1)$$\n$$Δx(y-y_1) = Δy(x-x_1)$$"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try vector method as opposed to Cartesian method"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as medium problem\\n"
                    },
                    {
                        "username": "luzede",
                        "content": "Writing the code is piece of cake if you remember the line equation from Highschool "
                    },
                    {
                        "username": "azuregcp",
                        "content": "Why? It\\'s just a basic high school mathematics problem."
                    },
                    {
                        "username": "ObviouslyBhavya",
                        "content": "To check if three points are in straight line or not we try to assume it as a triangle and if the area of traingle if zero then we say that the three points are in straight line.\\n\\nThe solution to this question is you take the first 2 points and check for every point if with any point the first two points makes a triangle of a positive area the answer is no that the coordinates are not in straight line.\\n\\nThe formula to calculate area is (1/12)*(x1(y2-y3) + x2(y3-y1) + x3(y1-y2)) apply the same formula learnt in school"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a question for the school math. Every point (x[i], y[i]) (for i!=0, 1)on the line satisfies\n$\n(y[i]-y[0])/(x[i]-x[0])=(y[1]-y[0])/(x[1]-x[0])=$slope of this line\n\nbut be careful, not divided by zero. Before submitting, try the following test case:\n```\n[[0,0],[0,1],[0,-1]]\n```\n[https://youtu.be/00BEcax1fu8](https://youtu.be/00BEcax1fu8)"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints for those who want to code on their own:\\n\\n1. 2 points are always co-linear.\\n2. 3 points are co-linear if the slope of lines joining any 2 of the 3 points is same.\\n3. Be a bit careful while calculating slope. The denominator might be 0.\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Finally a real Good Morning after a scary fortnight."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "tan(0)=(y2-y1)/(x2-x1)\\nfor multiple points.\\n(y2-y1)/(x2-x1)==(y1-y0)/(x1-x0)\\nBut in this 0/0 exception come.\\nSo rearrange the formula. \\n**(y2-y1)*(x1-x0)==(y1-y0)*(x2-x1)**\\n\\nCODE is solution section."
                    },
                    {
                        "username": "artem09122002",
                        "content": "I do not think that this case is correct \\n\\nInput\\ncoordinates =\\n[[0,0],[0,1],[0,-1]]\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@RomNc](/RomNc) But according to question, we have to \"Check if these points make a straight line in the XY plane or not\". So, I can't see anything wrong."
                    },
                    {
                        "username": "RomNc",
                        "content": "[@Rajat310](/Rajat310) The points form a straight line, but mathematically speaking the gradient of a vertical line is undefined. So, this one another amiguously presented question on leetcode. \nThe point is we need to apply some sort of mathemataical formula to solve this problem, while a vertilcal line is not a case to which this mathematical formula can be applied. But anyways..."
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@artem09122002](/artem09122002) It is true. The x-coordinates are all the same(i.e. constant) and thus form a straight line on the x-axis regardless of the y-axis."
                    }
                ]
            },
            {
                "id": 1781456,
                "content": [
                    {
                        "username": "JuanQP",
                        "content": "There are at least 3 things you should know to solve this.\\n\\n* Remember when in high school you asked your teacher *Who cares what is the slope between two points? When am I going to use this anyway?*, well, this is one of those situations. So, remember: \\n$$m = (y_2 - y_1) / (x_2 - x_1)$$\\n* It would be easy to solve this if the points were sorted... Right?\\n* There is a border case: What if two points have the same `x` value? Ouch. That would be a division by zero. Think how to take care of this particular case.\\n\\nThose tips should do the trick for you. Happy coding."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@theRadFad](/theRadFad) Yeah, sorting won\\'t be helpful here at all. The reason is that you can either sort in the direction of x or in the direction of y. If the points were in a straight line, they would already appear sorted in some direction (either x or y). So, in that case, you don\\'t get any advantage by sorting. I suppose its not needed."
                    },
                    {
                        "username": "theRadFad",
                        "content": "Lovely hints. I would just like to add that, perhaps, sorting may not be that important .. right?"
                    },
                    {
                        "username": "singh__12",
                        "content": "[@Jagannath01](/Jagannath01) You are dividing by zero for this case [[0,0],[0,1],[0,-1]] so modifie your code as                                                                         \\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int n=coordinates.size();\\n        int xmove=coordinates[1][0]-coordinates[0][0];  // same as x2-x1\\n        int ymove=coordinates[1][1]-coordinates[0][1];  // same as y2-y1\\n\\n        for(int i=1;i<n;i++){\\n            int x=coordinates[i][0]-coordinates[i-1][0];\\n            int y=coordinates[i][1]-coordinates[i-1][1];\\n            if(y*xmove!=x*ymove) return false;\\n        } \\n        return true;   \\n    }\\n};"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "i tried with the same approach still I am getting error..\\n\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n        int n=coordinates.length;\\n\\n        int m=(coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n\\n        boolean ans=false;\\n\\n        for(int i=1; i<n-1 ;i++){\\n\\n            if((coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0])==m){\\n\\n                ans=true;\\n            }\\n            else{\\n                ans=false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "mochy",
                        "content": "Use standard form so you don't have to deal with vertical lines (division by zero).\n$$y-y_1 = \fm(x-x_1)$$\n$$y-y_1 = \f(Δy/Δx)(x-x_1)$$\n$$Δx(y-y_1) = Δy(x-x_1)$$"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try vector method as opposed to Cartesian method"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as medium problem\\n"
                    },
                    {
                        "username": "luzede",
                        "content": "Writing the code is piece of cake if you remember the line equation from Highschool "
                    },
                    {
                        "username": "azuregcp",
                        "content": "Why? It\\'s just a basic high school mathematics problem."
                    },
                    {
                        "username": "ObviouslyBhavya",
                        "content": "To check if three points are in straight line or not we try to assume it as a triangle and if the area of traingle if zero then we say that the three points are in straight line.\\n\\nThe solution to this question is you take the first 2 points and check for every point if with any point the first two points makes a triangle of a positive area the answer is no that the coordinates are not in straight line.\\n\\nThe formula to calculate area is (1/12)*(x1(y2-y3) + x2(y3-y1) + x3(y1-y2)) apply the same formula learnt in school"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a question for the school math. Every point (x[i], y[i]) (for i!=0, 1)on the line satisfies\n$\n(y[i]-y[0])/(x[i]-x[0])=(y[1]-y[0])/(x[1]-x[0])=$slope of this line\n\nbut be careful, not divided by zero. Before submitting, try the following test case:\n```\n[[0,0],[0,1],[0,-1]]\n```\n[https://youtu.be/00BEcax1fu8](https://youtu.be/00BEcax1fu8)"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints for those who want to code on their own:\\n\\n1. 2 points are always co-linear.\\n2. 3 points are co-linear if the slope of lines joining any 2 of the 3 points is same.\\n3. Be a bit careful while calculating slope. The denominator might be 0.\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Finally a real Good Morning after a scary fortnight."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "tan(0)=(y2-y1)/(x2-x1)\\nfor multiple points.\\n(y2-y1)/(x2-x1)==(y1-y0)/(x1-x0)\\nBut in this 0/0 exception come.\\nSo rearrange the formula. \\n**(y2-y1)*(x1-x0)==(y1-y0)*(x2-x1)**\\n\\nCODE is solution section."
                    },
                    {
                        "username": "artem09122002",
                        "content": "I do not think that this case is correct \\n\\nInput\\ncoordinates =\\n[[0,0],[0,1],[0,-1]]\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@RomNc](/RomNc) But according to question, we have to \"Check if these points make a straight line in the XY plane or not\". So, I can't see anything wrong."
                    },
                    {
                        "username": "RomNc",
                        "content": "[@Rajat310](/Rajat310) The points form a straight line, but mathematically speaking the gradient of a vertical line is undefined. So, this one another amiguously presented question on leetcode. \nThe point is we need to apply some sort of mathemataical formula to solve this problem, while a vertilcal line is not a case to which this mathematical formula can be applied. But anyways..."
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@artem09122002](/artem09122002) It is true. The x-coordinates are all the same(i.e. constant) and thus form a straight line on the x-axis regardless of the y-axis."
                    }
                ]
            },
            {
                "id": 1917221,
                "content": [
                    {
                        "username": "JuanQP",
                        "content": "There are at least 3 things you should know to solve this.\\n\\n* Remember when in high school you asked your teacher *Who cares what is the slope between two points? When am I going to use this anyway?*, well, this is one of those situations. So, remember: \\n$$m = (y_2 - y_1) / (x_2 - x_1)$$\\n* It would be easy to solve this if the points were sorted... Right?\\n* There is a border case: What if two points have the same `x` value? Ouch. That would be a division by zero. Think how to take care of this particular case.\\n\\nThose tips should do the trick for you. Happy coding."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@theRadFad](/theRadFad) Yeah, sorting won\\'t be helpful here at all. The reason is that you can either sort in the direction of x or in the direction of y. If the points were in a straight line, they would already appear sorted in some direction (either x or y). So, in that case, you don\\'t get any advantage by sorting. I suppose its not needed."
                    },
                    {
                        "username": "theRadFad",
                        "content": "Lovely hints. I would just like to add that, perhaps, sorting may not be that important .. right?"
                    },
                    {
                        "username": "singh__12",
                        "content": "[@Jagannath01](/Jagannath01) You are dividing by zero for this case [[0,0],[0,1],[0,-1]] so modifie your code as                                                                         \\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int n=coordinates.size();\\n        int xmove=coordinates[1][0]-coordinates[0][0];  // same as x2-x1\\n        int ymove=coordinates[1][1]-coordinates[0][1];  // same as y2-y1\\n\\n        for(int i=1;i<n;i++){\\n            int x=coordinates[i][0]-coordinates[i-1][0];\\n            int y=coordinates[i][1]-coordinates[i-1][1];\\n            if(y*xmove!=x*ymove) return false;\\n        } \\n        return true;   \\n    }\\n};"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "i tried with the same approach still I am getting error..\\n\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n        int n=coordinates.length;\\n\\n        int m=(coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n\\n        boolean ans=false;\\n\\n        for(int i=1; i<n-1 ;i++){\\n\\n            if((coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0])==m){\\n\\n                ans=true;\\n            }\\n            else{\\n                ans=false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "mochy",
                        "content": "Use standard form so you don't have to deal with vertical lines (division by zero).\n$$y-y_1 = \fm(x-x_1)$$\n$$y-y_1 = \f(Δy/Δx)(x-x_1)$$\n$$Δx(y-y_1) = Δy(x-x_1)$$"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try vector method as opposed to Cartesian method"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as medium problem\\n"
                    },
                    {
                        "username": "luzede",
                        "content": "Writing the code is piece of cake if you remember the line equation from Highschool "
                    },
                    {
                        "username": "azuregcp",
                        "content": "Why? It\\'s just a basic high school mathematics problem."
                    },
                    {
                        "username": "ObviouslyBhavya",
                        "content": "To check if three points are in straight line or not we try to assume it as a triangle and if the area of traingle if zero then we say that the three points are in straight line.\\n\\nThe solution to this question is you take the first 2 points and check for every point if with any point the first two points makes a triangle of a positive area the answer is no that the coordinates are not in straight line.\\n\\nThe formula to calculate area is (1/12)*(x1(y2-y3) + x2(y3-y1) + x3(y1-y2)) apply the same formula learnt in school"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a question for the school math. Every point (x[i], y[i]) (for i!=0, 1)on the line satisfies\n$\n(y[i]-y[0])/(x[i]-x[0])=(y[1]-y[0])/(x[1]-x[0])=$slope of this line\n\nbut be careful, not divided by zero. Before submitting, try the following test case:\n```\n[[0,0],[0,1],[0,-1]]\n```\n[https://youtu.be/00BEcax1fu8](https://youtu.be/00BEcax1fu8)"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints for those who want to code on their own:\\n\\n1. 2 points are always co-linear.\\n2. 3 points are co-linear if the slope of lines joining any 2 of the 3 points is same.\\n3. Be a bit careful while calculating slope. The denominator might be 0.\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Finally a real Good Morning after a scary fortnight."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "tan(0)=(y2-y1)/(x2-x1)\\nfor multiple points.\\n(y2-y1)/(x2-x1)==(y1-y0)/(x1-x0)\\nBut in this 0/0 exception come.\\nSo rearrange the formula. \\n**(y2-y1)*(x1-x0)==(y1-y0)*(x2-x1)**\\n\\nCODE is solution section."
                    },
                    {
                        "username": "artem09122002",
                        "content": "I do not think that this case is correct \\n\\nInput\\ncoordinates =\\n[[0,0],[0,1],[0,-1]]\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@RomNc](/RomNc) But according to question, we have to \"Check if these points make a straight line in the XY plane or not\". So, I can't see anything wrong."
                    },
                    {
                        "username": "RomNc",
                        "content": "[@Rajat310](/Rajat310) The points form a straight line, but mathematically speaking the gradient of a vertical line is undefined. So, this one another amiguously presented question on leetcode. \nThe point is we need to apply some sort of mathemataical formula to solve this problem, while a vertilcal line is not a case to which this mathematical formula can be applied. But anyways..."
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@artem09122002](/artem09122002) It is true. The x-coordinates are all the same(i.e. constant) and thus form a straight line on the x-axis regardless of the y-axis."
                    }
                ]
            },
            {
                "id": 1737208,
                "content": [
                    {
                        "username": "JuanQP",
                        "content": "There are at least 3 things you should know to solve this.\\n\\n* Remember when in high school you asked your teacher *Who cares what is the slope between two points? When am I going to use this anyway?*, well, this is one of those situations. So, remember: \\n$$m = (y_2 - y_1) / (x_2 - x_1)$$\\n* It would be easy to solve this if the points were sorted... Right?\\n* There is a border case: What if two points have the same `x` value? Ouch. That would be a division by zero. Think how to take care of this particular case.\\n\\nThose tips should do the trick for you. Happy coding."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@theRadFad](/theRadFad) Yeah, sorting won\\'t be helpful here at all. The reason is that you can either sort in the direction of x or in the direction of y. If the points were in a straight line, they would already appear sorted in some direction (either x or y). So, in that case, you don\\'t get any advantage by sorting. I suppose its not needed."
                    },
                    {
                        "username": "theRadFad",
                        "content": "Lovely hints. I would just like to add that, perhaps, sorting may not be that important .. right?"
                    },
                    {
                        "username": "singh__12",
                        "content": "[@Jagannath01](/Jagannath01) You are dividing by zero for this case [[0,0],[0,1],[0,-1]] so modifie your code as                                                                         \\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int n=coordinates.size();\\n        int xmove=coordinates[1][0]-coordinates[0][0];  // same as x2-x1\\n        int ymove=coordinates[1][1]-coordinates[0][1];  // same as y2-y1\\n\\n        for(int i=1;i<n;i++){\\n            int x=coordinates[i][0]-coordinates[i-1][0];\\n            int y=coordinates[i][1]-coordinates[i-1][1];\\n            if(y*xmove!=x*ymove) return false;\\n        } \\n        return true;   \\n    }\\n};"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "i tried with the same approach still I am getting error..\\n\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n        int n=coordinates.length;\\n\\n        int m=(coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n\\n        boolean ans=false;\\n\\n        for(int i=1; i<n-1 ;i++){\\n\\n            if((coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0])==m){\\n\\n                ans=true;\\n            }\\n            else{\\n                ans=false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "mochy",
                        "content": "Use standard form so you don't have to deal with vertical lines (division by zero).\n$$y-y_1 = \fm(x-x_1)$$\n$$y-y_1 = \f(Δy/Δx)(x-x_1)$$\n$$Δx(y-y_1) = Δy(x-x_1)$$"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try vector method as opposed to Cartesian method"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as medium problem\\n"
                    },
                    {
                        "username": "luzede",
                        "content": "Writing the code is piece of cake if you remember the line equation from Highschool "
                    },
                    {
                        "username": "azuregcp",
                        "content": "Why? It\\'s just a basic high school mathematics problem."
                    },
                    {
                        "username": "ObviouslyBhavya",
                        "content": "To check if three points are in straight line or not we try to assume it as a triangle and if the area of traingle if zero then we say that the three points are in straight line.\\n\\nThe solution to this question is you take the first 2 points and check for every point if with any point the first two points makes a triangle of a positive area the answer is no that the coordinates are not in straight line.\\n\\nThe formula to calculate area is (1/12)*(x1(y2-y3) + x2(y3-y1) + x3(y1-y2)) apply the same formula learnt in school"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a question for the school math. Every point (x[i], y[i]) (for i!=0, 1)on the line satisfies\n$\n(y[i]-y[0])/(x[i]-x[0])=(y[1]-y[0])/(x[1]-x[0])=$slope of this line\n\nbut be careful, not divided by zero. Before submitting, try the following test case:\n```\n[[0,0],[0,1],[0,-1]]\n```\n[https://youtu.be/00BEcax1fu8](https://youtu.be/00BEcax1fu8)"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints for those who want to code on their own:\\n\\n1. 2 points are always co-linear.\\n2. 3 points are co-linear if the slope of lines joining any 2 of the 3 points is same.\\n3. Be a bit careful while calculating slope. The denominator might be 0.\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Finally a real Good Morning after a scary fortnight."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "tan(0)=(y2-y1)/(x2-x1)\\nfor multiple points.\\n(y2-y1)/(x2-x1)==(y1-y0)/(x1-x0)\\nBut in this 0/0 exception come.\\nSo rearrange the formula. \\n**(y2-y1)*(x1-x0)==(y1-y0)*(x2-x1)**\\n\\nCODE is solution section."
                    },
                    {
                        "username": "artem09122002",
                        "content": "I do not think that this case is correct \\n\\nInput\\ncoordinates =\\n[[0,0],[0,1],[0,-1]]\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@RomNc](/RomNc) But according to question, we have to \"Check if these points make a straight line in the XY plane or not\". So, I can't see anything wrong."
                    },
                    {
                        "username": "RomNc",
                        "content": "[@Rajat310](/Rajat310) The points form a straight line, but mathematically speaking the gradient of a vertical line is undefined. So, this one another amiguously presented question on leetcode. \nThe point is we need to apply some sort of mathemataical formula to solve this problem, while a vertilcal line is not a case to which this mathematical formula can be applied. But anyways..."
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@artem09122002](/artem09122002) It is true. The x-coordinates are all the same(i.e. constant) and thus form a straight line on the x-axis regardless of the y-axis."
                    }
                ]
            },
            {
                "id": 1917820,
                "content": [
                    {
                        "username": "JuanQP",
                        "content": "There are at least 3 things you should know to solve this.\\n\\n* Remember when in high school you asked your teacher *Who cares what is the slope between two points? When am I going to use this anyway?*, well, this is one of those situations. So, remember: \\n$$m = (y_2 - y_1) / (x_2 - x_1)$$\\n* It would be easy to solve this if the points were sorted... Right?\\n* There is a border case: What if two points have the same `x` value? Ouch. That would be a division by zero. Think how to take care of this particular case.\\n\\nThose tips should do the trick for you. Happy coding."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@theRadFad](/theRadFad) Yeah, sorting won\\'t be helpful here at all. The reason is that you can either sort in the direction of x or in the direction of y. If the points were in a straight line, they would already appear sorted in some direction (either x or y). So, in that case, you don\\'t get any advantage by sorting. I suppose its not needed."
                    },
                    {
                        "username": "theRadFad",
                        "content": "Lovely hints. I would just like to add that, perhaps, sorting may not be that important .. right?"
                    },
                    {
                        "username": "singh__12",
                        "content": "[@Jagannath01](/Jagannath01) You are dividing by zero for this case [[0,0],[0,1],[0,-1]] so modifie your code as                                                                         \\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int n=coordinates.size();\\n        int xmove=coordinates[1][0]-coordinates[0][0];  // same as x2-x1\\n        int ymove=coordinates[1][1]-coordinates[0][1];  // same as y2-y1\\n\\n        for(int i=1;i<n;i++){\\n            int x=coordinates[i][0]-coordinates[i-1][0];\\n            int y=coordinates[i][1]-coordinates[i-1][1];\\n            if(y*xmove!=x*ymove) return false;\\n        } \\n        return true;   \\n    }\\n};"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "i tried with the same approach still I am getting error..\\n\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n        int n=coordinates.length;\\n\\n        int m=(coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n\\n        boolean ans=false;\\n\\n        for(int i=1; i<n-1 ;i++){\\n\\n            if((coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0])==m){\\n\\n                ans=true;\\n            }\\n            else{\\n                ans=false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "mochy",
                        "content": "Use standard form so you don't have to deal with vertical lines (division by zero).\n$$y-y_1 = \fm(x-x_1)$$\n$$y-y_1 = \f(Δy/Δx)(x-x_1)$$\n$$Δx(y-y_1) = Δy(x-x_1)$$"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try vector method as opposed to Cartesian method"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as medium problem\\n"
                    },
                    {
                        "username": "luzede",
                        "content": "Writing the code is piece of cake if you remember the line equation from Highschool "
                    },
                    {
                        "username": "azuregcp",
                        "content": "Why? It\\'s just a basic high school mathematics problem."
                    },
                    {
                        "username": "ObviouslyBhavya",
                        "content": "To check if three points are in straight line or not we try to assume it as a triangle and if the area of traingle if zero then we say that the three points are in straight line.\\n\\nThe solution to this question is you take the first 2 points and check for every point if with any point the first two points makes a triangle of a positive area the answer is no that the coordinates are not in straight line.\\n\\nThe formula to calculate area is (1/12)*(x1(y2-y3) + x2(y3-y1) + x3(y1-y2)) apply the same formula learnt in school"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a question for the school math. Every point (x[i], y[i]) (for i!=0, 1)on the line satisfies\n$\n(y[i]-y[0])/(x[i]-x[0])=(y[1]-y[0])/(x[1]-x[0])=$slope of this line\n\nbut be careful, not divided by zero. Before submitting, try the following test case:\n```\n[[0,0],[0,1],[0,-1]]\n```\n[https://youtu.be/00BEcax1fu8](https://youtu.be/00BEcax1fu8)"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints for those who want to code on their own:\\n\\n1. 2 points are always co-linear.\\n2. 3 points are co-linear if the slope of lines joining any 2 of the 3 points is same.\\n3. Be a bit careful while calculating slope. The denominator might be 0.\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Finally a real Good Morning after a scary fortnight."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "tan(0)=(y2-y1)/(x2-x1)\\nfor multiple points.\\n(y2-y1)/(x2-x1)==(y1-y0)/(x1-x0)\\nBut in this 0/0 exception come.\\nSo rearrange the formula. \\n**(y2-y1)*(x1-x0)==(y1-y0)*(x2-x1)**\\n\\nCODE is solution section."
                    },
                    {
                        "username": "artem09122002",
                        "content": "I do not think that this case is correct \\n\\nInput\\ncoordinates =\\n[[0,0],[0,1],[0,-1]]\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@RomNc](/RomNc) But according to question, we have to \"Check if these points make a straight line in the XY plane or not\". So, I can't see anything wrong."
                    },
                    {
                        "username": "RomNc",
                        "content": "[@Rajat310](/Rajat310) The points form a straight line, but mathematically speaking the gradient of a vertical line is undefined. So, this one another amiguously presented question on leetcode. \nThe point is we need to apply some sort of mathemataical formula to solve this problem, while a vertilcal line is not a case to which this mathematical formula can be applied. But anyways..."
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@artem09122002](/artem09122002) It is true. The x-coordinates are all the same(i.e. constant) and thus form a straight line on the x-axis regardless of the y-axis."
                    }
                ]
            },
            {
                "id": 1745231,
                "content": [
                    {
                        "username": "JuanQP",
                        "content": "There are at least 3 things you should know to solve this.\\n\\n* Remember when in high school you asked your teacher *Who cares what is the slope between two points? When am I going to use this anyway?*, well, this is one of those situations. So, remember: \\n$$m = (y_2 - y_1) / (x_2 - x_1)$$\\n* It would be easy to solve this if the points were sorted... Right?\\n* There is a border case: What if two points have the same `x` value? Ouch. That would be a division by zero. Think how to take care of this particular case.\\n\\nThose tips should do the trick for you. Happy coding."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@theRadFad](/theRadFad) Yeah, sorting won\\'t be helpful here at all. The reason is that you can either sort in the direction of x or in the direction of y. If the points were in a straight line, they would already appear sorted in some direction (either x or y). So, in that case, you don\\'t get any advantage by sorting. I suppose its not needed."
                    },
                    {
                        "username": "theRadFad",
                        "content": "Lovely hints. I would just like to add that, perhaps, sorting may not be that important .. right?"
                    },
                    {
                        "username": "singh__12",
                        "content": "[@Jagannath01](/Jagannath01) You are dividing by zero for this case [[0,0],[0,1],[0,-1]] so modifie your code as                                                                         \\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int n=coordinates.size();\\n        int xmove=coordinates[1][0]-coordinates[0][0];  // same as x2-x1\\n        int ymove=coordinates[1][1]-coordinates[0][1];  // same as y2-y1\\n\\n        for(int i=1;i<n;i++){\\n            int x=coordinates[i][0]-coordinates[i-1][0];\\n            int y=coordinates[i][1]-coordinates[i-1][1];\\n            if(y*xmove!=x*ymove) return false;\\n        } \\n        return true;   \\n    }\\n};"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "i tried with the same approach still I am getting error..\\n\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n        int n=coordinates.length;\\n\\n        int m=(coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n\\n        boolean ans=false;\\n\\n        for(int i=1; i<n-1 ;i++){\\n\\n            if((coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0])==m){\\n\\n                ans=true;\\n            }\\n            else{\\n                ans=false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "mochy",
                        "content": "Use standard form so you don't have to deal with vertical lines (division by zero).\n$$y-y_1 = \fm(x-x_1)$$\n$$y-y_1 = \f(Δy/Δx)(x-x_1)$$\n$$Δx(y-y_1) = Δy(x-x_1)$$"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try vector method as opposed to Cartesian method"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as medium problem\\n"
                    },
                    {
                        "username": "luzede",
                        "content": "Writing the code is piece of cake if you remember the line equation from Highschool "
                    },
                    {
                        "username": "azuregcp",
                        "content": "Why? It\\'s just a basic high school mathematics problem."
                    },
                    {
                        "username": "ObviouslyBhavya",
                        "content": "To check if three points are in straight line or not we try to assume it as a triangle and if the area of traingle if zero then we say that the three points are in straight line.\\n\\nThe solution to this question is you take the first 2 points and check for every point if with any point the first two points makes a triangle of a positive area the answer is no that the coordinates are not in straight line.\\n\\nThe formula to calculate area is (1/12)*(x1(y2-y3) + x2(y3-y1) + x3(y1-y2)) apply the same formula learnt in school"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a question for the school math. Every point (x[i], y[i]) (for i!=0, 1)on the line satisfies\n$\n(y[i]-y[0])/(x[i]-x[0])=(y[1]-y[0])/(x[1]-x[0])=$slope of this line\n\nbut be careful, not divided by zero. Before submitting, try the following test case:\n```\n[[0,0],[0,1],[0,-1]]\n```\n[https://youtu.be/00BEcax1fu8](https://youtu.be/00BEcax1fu8)"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints for those who want to code on their own:\\n\\n1. 2 points are always co-linear.\\n2. 3 points are co-linear if the slope of lines joining any 2 of the 3 points is same.\\n3. Be a bit careful while calculating slope. The denominator might be 0.\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Finally a real Good Morning after a scary fortnight."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "tan(0)=(y2-y1)/(x2-x1)\\nfor multiple points.\\n(y2-y1)/(x2-x1)==(y1-y0)/(x1-x0)\\nBut in this 0/0 exception come.\\nSo rearrange the formula. \\n**(y2-y1)*(x1-x0)==(y1-y0)*(x2-x1)**\\n\\nCODE is solution section."
                    },
                    {
                        "username": "artem09122002",
                        "content": "I do not think that this case is correct \\n\\nInput\\ncoordinates =\\n[[0,0],[0,1],[0,-1]]\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@RomNc](/RomNc) But according to question, we have to \"Check if these points make a straight line in the XY plane or not\". So, I can't see anything wrong."
                    },
                    {
                        "username": "RomNc",
                        "content": "[@Rajat310](/Rajat310) The points form a straight line, but mathematically speaking the gradient of a vertical line is undefined. So, this one another amiguously presented question on leetcode. \nThe point is we need to apply some sort of mathemataical formula to solve this problem, while a vertilcal line is not a case to which this mathematical formula can be applied. But anyways..."
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@artem09122002](/artem09122002) It is true. The x-coordinates are all the same(i.e. constant) and thus form a straight line on the x-axis regardless of the y-axis."
                    }
                ]
            },
            {
                "id": 1917215,
                "content": [
                    {
                        "username": "JuanQP",
                        "content": "There are at least 3 things you should know to solve this.\\n\\n* Remember when in high school you asked your teacher *Who cares what is the slope between two points? When am I going to use this anyway?*, well, this is one of those situations. So, remember: \\n$$m = (y_2 - y_1) / (x_2 - x_1)$$\\n* It would be easy to solve this if the points were sorted... Right?\\n* There is a border case: What if two points have the same `x` value? Ouch. That would be a division by zero. Think how to take care of this particular case.\\n\\nThose tips should do the trick for you. Happy coding."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@theRadFad](/theRadFad) Yeah, sorting won\\'t be helpful here at all. The reason is that you can either sort in the direction of x or in the direction of y. If the points were in a straight line, they would already appear sorted in some direction (either x or y). So, in that case, you don\\'t get any advantage by sorting. I suppose its not needed."
                    },
                    {
                        "username": "theRadFad",
                        "content": "Lovely hints. I would just like to add that, perhaps, sorting may not be that important .. right?"
                    },
                    {
                        "username": "singh__12",
                        "content": "[@Jagannath01](/Jagannath01) You are dividing by zero for this case [[0,0],[0,1],[0,-1]] so modifie your code as                                                                         \\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int n=coordinates.size();\\n        int xmove=coordinates[1][0]-coordinates[0][0];  // same as x2-x1\\n        int ymove=coordinates[1][1]-coordinates[0][1];  // same as y2-y1\\n\\n        for(int i=1;i<n;i++){\\n            int x=coordinates[i][0]-coordinates[i-1][0];\\n            int y=coordinates[i][1]-coordinates[i-1][1];\\n            if(y*xmove!=x*ymove) return false;\\n        } \\n        return true;   \\n    }\\n};"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "i tried with the same approach still I am getting error..\\n\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n        int n=coordinates.length;\\n\\n        int m=(coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n\\n        boolean ans=false;\\n\\n        for(int i=1; i<n-1 ;i++){\\n\\n            if((coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0])==m){\\n\\n                ans=true;\\n            }\\n            else{\\n                ans=false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "mochy",
                        "content": "Use standard form so you don't have to deal with vertical lines (division by zero).\n$$y-y_1 = \fm(x-x_1)$$\n$$y-y_1 = \f(Δy/Δx)(x-x_1)$$\n$$Δx(y-y_1) = Δy(x-x_1)$$"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try vector method as opposed to Cartesian method"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as medium problem\\n"
                    },
                    {
                        "username": "luzede",
                        "content": "Writing the code is piece of cake if you remember the line equation from Highschool "
                    },
                    {
                        "username": "azuregcp",
                        "content": "Why? It\\'s just a basic high school mathematics problem."
                    },
                    {
                        "username": "ObviouslyBhavya",
                        "content": "To check if three points are in straight line or not we try to assume it as a triangle and if the area of traingle if zero then we say that the three points are in straight line.\\n\\nThe solution to this question is you take the first 2 points and check for every point if with any point the first two points makes a triangle of a positive area the answer is no that the coordinates are not in straight line.\\n\\nThe formula to calculate area is (1/12)*(x1(y2-y3) + x2(y3-y1) + x3(y1-y2)) apply the same formula learnt in school"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a question for the school math. Every point (x[i], y[i]) (for i!=0, 1)on the line satisfies\n$\n(y[i]-y[0])/(x[i]-x[0])=(y[1]-y[0])/(x[1]-x[0])=$slope of this line\n\nbut be careful, not divided by zero. Before submitting, try the following test case:\n```\n[[0,0],[0,1],[0,-1]]\n```\n[https://youtu.be/00BEcax1fu8](https://youtu.be/00BEcax1fu8)"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints for those who want to code on their own:\\n\\n1. 2 points are always co-linear.\\n2. 3 points are co-linear if the slope of lines joining any 2 of the 3 points is same.\\n3. Be a bit careful while calculating slope. The denominator might be 0.\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Finally a real Good Morning after a scary fortnight."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "tan(0)=(y2-y1)/(x2-x1)\\nfor multiple points.\\n(y2-y1)/(x2-x1)==(y1-y0)/(x1-x0)\\nBut in this 0/0 exception come.\\nSo rearrange the formula. \\n**(y2-y1)*(x1-x0)==(y1-y0)*(x2-x1)**\\n\\nCODE is solution section."
                    },
                    {
                        "username": "artem09122002",
                        "content": "I do not think that this case is correct \\n\\nInput\\ncoordinates =\\n[[0,0],[0,1],[0,-1]]\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@RomNc](/RomNc) But according to question, we have to \"Check if these points make a straight line in the XY plane or not\". So, I can't see anything wrong."
                    },
                    {
                        "username": "RomNc",
                        "content": "[@Rajat310](/Rajat310) The points form a straight line, but mathematically speaking the gradient of a vertical line is undefined. So, this one another amiguously presented question on leetcode. \nThe point is we need to apply some sort of mathemataical formula to solve this problem, while a vertilcal line is not a case to which this mathematical formula can be applied. But anyways..."
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@artem09122002](/artem09122002) It is true. The x-coordinates are all the same(i.e. constant) and thus form a straight line on the x-axis regardless of the y-axis."
                    }
                ]
            },
            {
                "id": 1719187,
                "content": [
                    {
                        "username": "JuanQP",
                        "content": "There are at least 3 things you should know to solve this.\\n\\n* Remember when in high school you asked your teacher *Who cares what is the slope between two points? When am I going to use this anyway?*, well, this is one of those situations. So, remember: \\n$$m = (y_2 - y_1) / (x_2 - x_1)$$\\n* It would be easy to solve this if the points were sorted... Right?\\n* There is a border case: What if two points have the same `x` value? Ouch. That would be a division by zero. Think how to take care of this particular case.\\n\\nThose tips should do the trick for you. Happy coding."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@theRadFad](/theRadFad) Yeah, sorting won\\'t be helpful here at all. The reason is that you can either sort in the direction of x or in the direction of y. If the points were in a straight line, they would already appear sorted in some direction (either x or y). So, in that case, you don\\'t get any advantage by sorting. I suppose its not needed."
                    },
                    {
                        "username": "theRadFad",
                        "content": "Lovely hints. I would just like to add that, perhaps, sorting may not be that important .. right?"
                    },
                    {
                        "username": "singh__12",
                        "content": "[@Jagannath01](/Jagannath01) You are dividing by zero for this case [[0,0],[0,1],[0,-1]] so modifie your code as                                                                         \\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int n=coordinates.size();\\n        int xmove=coordinates[1][0]-coordinates[0][0];  // same as x2-x1\\n        int ymove=coordinates[1][1]-coordinates[0][1];  // same as y2-y1\\n\\n        for(int i=1;i<n;i++){\\n            int x=coordinates[i][0]-coordinates[i-1][0];\\n            int y=coordinates[i][1]-coordinates[i-1][1];\\n            if(y*xmove!=x*ymove) return false;\\n        } \\n        return true;   \\n    }\\n};"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "i tried with the same approach still I am getting error..\\n\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n        int n=coordinates.length;\\n\\n        int m=(coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n\\n        boolean ans=false;\\n\\n        for(int i=1; i<n-1 ;i++){\\n\\n            if((coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0])==m){\\n\\n                ans=true;\\n            }\\n            else{\\n                ans=false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "mochy",
                        "content": "Use standard form so you don't have to deal with vertical lines (division by zero).\n$$y-y_1 = \fm(x-x_1)$$\n$$y-y_1 = \f(Δy/Δx)(x-x_1)$$\n$$Δx(y-y_1) = Δy(x-x_1)$$"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try vector method as opposed to Cartesian method"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as medium problem\\n"
                    },
                    {
                        "username": "luzede",
                        "content": "Writing the code is piece of cake if you remember the line equation from Highschool "
                    },
                    {
                        "username": "azuregcp",
                        "content": "Why? It\\'s just a basic high school mathematics problem."
                    },
                    {
                        "username": "ObviouslyBhavya",
                        "content": "To check if three points are in straight line or not we try to assume it as a triangle and if the area of traingle if zero then we say that the three points are in straight line.\\n\\nThe solution to this question is you take the first 2 points and check for every point if with any point the first two points makes a triangle of a positive area the answer is no that the coordinates are not in straight line.\\n\\nThe formula to calculate area is (1/12)*(x1(y2-y3) + x2(y3-y1) + x3(y1-y2)) apply the same formula learnt in school"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a question for the school math. Every point (x[i], y[i]) (for i!=0, 1)on the line satisfies\n$\n(y[i]-y[0])/(x[i]-x[0])=(y[1]-y[0])/(x[1]-x[0])=$slope of this line\n\nbut be careful, not divided by zero. Before submitting, try the following test case:\n```\n[[0,0],[0,1],[0,-1]]\n```\n[https://youtu.be/00BEcax1fu8](https://youtu.be/00BEcax1fu8)"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints for those who want to code on their own:\\n\\n1. 2 points are always co-linear.\\n2. 3 points are co-linear if the slope of lines joining any 2 of the 3 points is same.\\n3. Be a bit careful while calculating slope. The denominator might be 0.\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Finally a real Good Morning after a scary fortnight."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "tan(0)=(y2-y1)/(x2-x1)\\nfor multiple points.\\n(y2-y1)/(x2-x1)==(y1-y0)/(x1-x0)\\nBut in this 0/0 exception come.\\nSo rearrange the formula. \\n**(y2-y1)*(x1-x0)==(y1-y0)*(x2-x1)**\\n\\nCODE is solution section."
                    },
                    {
                        "username": "artem09122002",
                        "content": "I do not think that this case is correct \\n\\nInput\\ncoordinates =\\n[[0,0],[0,1],[0,-1]]\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@RomNc](/RomNc) But according to question, we have to \"Check if these points make a straight line in the XY plane or not\". So, I can't see anything wrong."
                    },
                    {
                        "username": "RomNc",
                        "content": "[@Rajat310](/Rajat310) The points form a straight line, but mathematically speaking the gradient of a vertical line is undefined. So, this one another amiguously presented question on leetcode. \nThe point is we need to apply some sort of mathemataical formula to solve this problem, while a vertilcal line is not a case to which this mathematical formula can be applied. But anyways..."
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@artem09122002](/artem09122002) It is true. The x-coordinates are all the same(i.e. constant) and thus form a straight line on the x-axis regardless of the y-axis."
                    }
                ]
            },
            {
                "id": 1917509,
                "content": [
                    {
                        "username": "JuanQP",
                        "content": "There are at least 3 things you should know to solve this.\\n\\n* Remember when in high school you asked your teacher *Who cares what is the slope between two points? When am I going to use this anyway?*, well, this is one of those situations. So, remember: \\n$$m = (y_2 - y_1) / (x_2 - x_1)$$\\n* It would be easy to solve this if the points were sorted... Right?\\n* There is a border case: What if two points have the same `x` value? Ouch. That would be a division by zero. Think how to take care of this particular case.\\n\\nThose tips should do the trick for you. Happy coding."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@theRadFad](/theRadFad) Yeah, sorting won\\'t be helpful here at all. The reason is that you can either sort in the direction of x or in the direction of y. If the points were in a straight line, they would already appear sorted in some direction (either x or y). So, in that case, you don\\'t get any advantage by sorting. I suppose its not needed."
                    },
                    {
                        "username": "theRadFad",
                        "content": "Lovely hints. I would just like to add that, perhaps, sorting may not be that important .. right?"
                    },
                    {
                        "username": "singh__12",
                        "content": "[@Jagannath01](/Jagannath01) You are dividing by zero for this case [[0,0],[0,1],[0,-1]] so modifie your code as                                                                         \\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int n=coordinates.size();\\n        int xmove=coordinates[1][0]-coordinates[0][0];  // same as x2-x1\\n        int ymove=coordinates[1][1]-coordinates[0][1];  // same as y2-y1\\n\\n        for(int i=1;i<n;i++){\\n            int x=coordinates[i][0]-coordinates[i-1][0];\\n            int y=coordinates[i][1]-coordinates[i-1][1];\\n            if(y*xmove!=x*ymove) return false;\\n        } \\n        return true;   \\n    }\\n};"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "i tried with the same approach still I am getting error..\\n\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n        int n=coordinates.length;\\n\\n        int m=(coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n\\n        boolean ans=false;\\n\\n        for(int i=1; i<n-1 ;i++){\\n\\n            if((coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0])==m){\\n\\n                ans=true;\\n            }\\n            else{\\n                ans=false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "mochy",
                        "content": "Use standard form so you don't have to deal with vertical lines (division by zero).\n$$y-y_1 = \fm(x-x_1)$$\n$$y-y_1 = \f(Δy/Δx)(x-x_1)$$\n$$Δx(y-y_1) = Δy(x-x_1)$$"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try vector method as opposed to Cartesian method"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as medium problem\\n"
                    },
                    {
                        "username": "luzede",
                        "content": "Writing the code is piece of cake if you remember the line equation from Highschool "
                    },
                    {
                        "username": "azuregcp",
                        "content": "Why? It\\'s just a basic high school mathematics problem."
                    },
                    {
                        "username": "ObviouslyBhavya",
                        "content": "To check if three points are in straight line or not we try to assume it as a triangle and if the area of traingle if zero then we say that the three points are in straight line.\\n\\nThe solution to this question is you take the first 2 points and check for every point if with any point the first two points makes a triangle of a positive area the answer is no that the coordinates are not in straight line.\\n\\nThe formula to calculate area is (1/12)*(x1(y2-y3) + x2(y3-y1) + x3(y1-y2)) apply the same formula learnt in school"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a question for the school math. Every point (x[i], y[i]) (for i!=0, 1)on the line satisfies\n$\n(y[i]-y[0])/(x[i]-x[0])=(y[1]-y[0])/(x[1]-x[0])=$slope of this line\n\nbut be careful, not divided by zero. Before submitting, try the following test case:\n```\n[[0,0],[0,1],[0,-1]]\n```\n[https://youtu.be/00BEcax1fu8](https://youtu.be/00BEcax1fu8)"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints for those who want to code on their own:\\n\\n1. 2 points are always co-linear.\\n2. 3 points are co-linear if the slope of lines joining any 2 of the 3 points is same.\\n3. Be a bit careful while calculating slope. The denominator might be 0.\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Finally a real Good Morning after a scary fortnight."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "tan(0)=(y2-y1)/(x2-x1)\\nfor multiple points.\\n(y2-y1)/(x2-x1)==(y1-y0)/(x1-x0)\\nBut in this 0/0 exception come.\\nSo rearrange the formula. \\n**(y2-y1)*(x1-x0)==(y1-y0)*(x2-x1)**\\n\\nCODE is solution section."
                    },
                    {
                        "username": "artem09122002",
                        "content": "I do not think that this case is correct \\n\\nInput\\ncoordinates =\\n[[0,0],[0,1],[0,-1]]\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@RomNc](/RomNc) But according to question, we have to \"Check if these points make a straight line in the XY plane or not\". So, I can't see anything wrong."
                    },
                    {
                        "username": "RomNc",
                        "content": "[@Rajat310](/Rajat310) The points form a straight line, but mathematically speaking the gradient of a vertical line is undefined. So, this one another amiguously presented question on leetcode. \nThe point is we need to apply some sort of mathemataical formula to solve this problem, while a vertilcal line is not a case to which this mathematical formula can be applied. But anyways..."
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@artem09122002](/artem09122002) It is true. The x-coordinates are all the same(i.e. constant) and thus form a straight line on the x-axis regardless of the y-axis."
                    }
                ]
            },
            {
                "id": 1917485,
                "content": [
                    {
                        "username": "JuanQP",
                        "content": "There are at least 3 things you should know to solve this.\\n\\n* Remember when in high school you asked your teacher *Who cares what is the slope between two points? When am I going to use this anyway?*, well, this is one of those situations. So, remember: \\n$$m = (y_2 - y_1) / (x_2 - x_1)$$\\n* It would be easy to solve this if the points were sorted... Right?\\n* There is a border case: What if two points have the same `x` value? Ouch. That would be a division by zero. Think how to take care of this particular case.\\n\\nThose tips should do the trick for you. Happy coding."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@theRadFad](/theRadFad) Yeah, sorting won\\'t be helpful here at all. The reason is that you can either sort in the direction of x or in the direction of y. If the points were in a straight line, they would already appear sorted in some direction (either x or y). So, in that case, you don\\'t get any advantage by sorting. I suppose its not needed."
                    },
                    {
                        "username": "theRadFad",
                        "content": "Lovely hints. I would just like to add that, perhaps, sorting may not be that important .. right?"
                    },
                    {
                        "username": "singh__12",
                        "content": "[@Jagannath01](/Jagannath01) You are dividing by zero for this case [[0,0],[0,1],[0,-1]] so modifie your code as                                                                         \\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int n=coordinates.size();\\n        int xmove=coordinates[1][0]-coordinates[0][0];  // same as x2-x1\\n        int ymove=coordinates[1][1]-coordinates[0][1];  // same as y2-y1\\n\\n        for(int i=1;i<n;i++){\\n            int x=coordinates[i][0]-coordinates[i-1][0];\\n            int y=coordinates[i][1]-coordinates[i-1][1];\\n            if(y*xmove!=x*ymove) return false;\\n        } \\n        return true;   \\n    }\\n};"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "i tried with the same approach still I am getting error..\\n\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n        int n=coordinates.length;\\n\\n        int m=(coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n\\n        boolean ans=false;\\n\\n        for(int i=1; i<n-1 ;i++){\\n\\n            if((coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0])==m){\\n\\n                ans=true;\\n            }\\n            else{\\n                ans=false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "mochy",
                        "content": "Use standard form so you don't have to deal with vertical lines (division by zero).\n$$y-y_1 = \fm(x-x_1)$$\n$$y-y_1 = \f(Δy/Δx)(x-x_1)$$\n$$Δx(y-y_1) = Δy(x-x_1)$$"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try vector method as opposed to Cartesian method"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as medium problem\\n"
                    },
                    {
                        "username": "luzede",
                        "content": "Writing the code is piece of cake if you remember the line equation from Highschool "
                    },
                    {
                        "username": "azuregcp",
                        "content": "Why? It\\'s just a basic high school mathematics problem."
                    },
                    {
                        "username": "ObviouslyBhavya",
                        "content": "To check if three points are in straight line or not we try to assume it as a triangle and if the area of traingle if zero then we say that the three points are in straight line.\\n\\nThe solution to this question is you take the first 2 points and check for every point if with any point the first two points makes a triangle of a positive area the answer is no that the coordinates are not in straight line.\\n\\nThe formula to calculate area is (1/12)*(x1(y2-y3) + x2(y3-y1) + x3(y1-y2)) apply the same formula learnt in school"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a question for the school math. Every point (x[i], y[i]) (for i!=0, 1)on the line satisfies\n$\n(y[i]-y[0])/(x[i]-x[0])=(y[1]-y[0])/(x[1]-x[0])=$slope of this line\n\nbut be careful, not divided by zero. Before submitting, try the following test case:\n```\n[[0,0],[0,1],[0,-1]]\n```\n[https://youtu.be/00BEcax1fu8](https://youtu.be/00BEcax1fu8)"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints for those who want to code on their own:\\n\\n1. 2 points are always co-linear.\\n2. 3 points are co-linear if the slope of lines joining any 2 of the 3 points is same.\\n3. Be a bit careful while calculating slope. The denominator might be 0.\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Finally a real Good Morning after a scary fortnight."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "tan(0)=(y2-y1)/(x2-x1)\\nfor multiple points.\\n(y2-y1)/(x2-x1)==(y1-y0)/(x1-x0)\\nBut in this 0/0 exception come.\\nSo rearrange the formula. \\n**(y2-y1)*(x1-x0)==(y1-y0)*(x2-x1)**\\n\\nCODE is solution section."
                    },
                    {
                        "username": "artem09122002",
                        "content": "I do not think that this case is correct \\n\\nInput\\ncoordinates =\\n[[0,0],[0,1],[0,-1]]\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@RomNc](/RomNc) But according to question, we have to \"Check if these points make a straight line in the XY plane or not\". So, I can't see anything wrong."
                    },
                    {
                        "username": "RomNc",
                        "content": "[@Rajat310](/Rajat310) The points form a straight line, but mathematically speaking the gradient of a vertical line is undefined. So, this one another amiguously presented question on leetcode. \nThe point is we need to apply some sort of mathemataical formula to solve this problem, while a vertilcal line is not a case to which this mathematical formula can be applied. But anyways..."
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@artem09122002](/artem09122002) It is true. The x-coordinates are all the same(i.e. constant) and thus form a straight line on the x-axis regardless of the y-axis."
                    }
                ]
            },
            {
                "id": 1925884,
                "content": [
                    {
                        "username": "JuanQP",
                        "content": "There are at least 3 things you should know to solve this.\\n\\n* Remember when in high school you asked your teacher *Who cares what is the slope between two points? When am I going to use this anyway?*, well, this is one of those situations. So, remember: \\n$$m = (y_2 - y_1) / (x_2 - x_1)$$\\n* It would be easy to solve this if the points were sorted... Right?\\n* There is a border case: What if two points have the same `x` value? Ouch. That would be a division by zero. Think how to take care of this particular case.\\n\\nThose tips should do the trick for you. Happy coding."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@theRadFad](/theRadFad) Yeah, sorting won\\'t be helpful here at all. The reason is that you can either sort in the direction of x or in the direction of y. If the points were in a straight line, they would already appear sorted in some direction (either x or y). So, in that case, you don\\'t get any advantage by sorting. I suppose its not needed."
                    },
                    {
                        "username": "theRadFad",
                        "content": "Lovely hints. I would just like to add that, perhaps, sorting may not be that important .. right?"
                    },
                    {
                        "username": "singh__12",
                        "content": "[@Jagannath01](/Jagannath01) You are dividing by zero for this case [[0,0],[0,1],[0,-1]] so modifie your code as                                                                         \\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\\n        int n=coordinates.size();\\n        int xmove=coordinates[1][0]-coordinates[0][0];  // same as x2-x1\\n        int ymove=coordinates[1][1]-coordinates[0][1];  // same as y2-y1\\n\\n        for(int i=1;i<n;i++){\\n            int x=coordinates[i][0]-coordinates[i-1][0];\\n            int y=coordinates[i][1]-coordinates[i-1][1];\\n            if(y*xmove!=x*ymove) return false;\\n        } \\n        return true;   \\n    }\\n};"
                    },
                    {
                        "username": "Jagannath01",
                        "content": "i tried with the same approach still I am getting error..\\n\\nclass Solution {\\n    public boolean checkStraightLine(int[][] coordinates) {\\n        \\n        int n=coordinates.length;\\n\\n        int m=(coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n\\n        boolean ans=false;\\n\\n        for(int i=1; i<n-1 ;i++){\\n\\n            if((coordinates[i+1][1]-coordinates[i][1])/(coordinates[i+1][0]-coordinates[i][0])==m){\\n\\n                ans=true;\\n            }\\n            else{\\n                ans=false;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "mochy",
                        "content": "Use standard form so you don't have to deal with vertical lines (division by zero).\n$$y-y_1 = \fm(x-x_1)$$\n$$y-y_1 = \f(Δy/Δx)(x-x_1)$$\n$$Δx(y-y_1) = Δy(x-x_1)$$"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: try vector method as opposed to Cartesian method"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should be marked as medium problem\\n"
                    },
                    {
                        "username": "luzede",
                        "content": "Writing the code is piece of cake if you remember the line equation from Highschool "
                    },
                    {
                        "username": "azuregcp",
                        "content": "Why? It\\'s just a basic high school mathematics problem."
                    },
                    {
                        "username": "ObviouslyBhavya",
                        "content": "To check if three points are in straight line or not we try to assume it as a triangle and if the area of traingle if zero then we say that the three points are in straight line.\\n\\nThe solution to this question is you take the first 2 points and check for every point if with any point the first two points makes a triangle of a positive area the answer is no that the coordinates are not in straight line.\\n\\nThe formula to calculate area is (1/12)*(x1(y2-y3) + x2(y3-y1) + x3(y1-y2)) apply the same formula learnt in school"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a question for the school math. Every point (x[i], y[i]) (for i!=0, 1)on the line satisfies\n$\n(y[i]-y[0])/(x[i]-x[0])=(y[1]-y[0])/(x[1]-x[0])=$slope of this line\n\nbut be careful, not divided by zero. Before submitting, try the following test case:\n```\n[[0,0],[0,1],[0,-1]]\n```\n[https://youtu.be/00BEcax1fu8](https://youtu.be/00BEcax1fu8)"
                    },
                    {
                        "username": "ayushprakash1912",
                        "content": "Hints for those who want to code on their own:\\n\\n1. 2 points are always co-linear.\\n2. 3 points are co-linear if the slope of lines joining any 2 of the 3 points is same.\\n3. Be a bit careful while calculating slope. The denominator might be 0.\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Finally a real Good Morning after a scary fortnight."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "tan(0)=(y2-y1)/(x2-x1)\\nfor multiple points.\\n(y2-y1)/(x2-x1)==(y1-y0)/(x1-x0)\\nBut in this 0/0 exception come.\\nSo rearrange the formula. \\n**(y2-y1)*(x1-x0)==(y1-y0)*(x2-x1)**\\n\\nCODE is solution section."
                    },
                    {
                        "username": "artem09122002",
                        "content": "I do not think that this case is correct \\n\\nInput\\ncoordinates =\\n[[0,0],[0,1],[0,-1]]\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@RomNc](/RomNc) But according to question, we have to \"Check if these points make a straight line in the XY plane or not\". So, I can't see anything wrong."
                    },
                    {
                        "username": "RomNc",
                        "content": "[@Rajat310](/Rajat310) The points form a straight line, but mathematically speaking the gradient of a vertical line is undefined. So, this one another amiguously presented question on leetcode. \nThe point is we need to apply some sort of mathemataical formula to solve this problem, while a vertilcal line is not a case to which this mathematical formula can be applied. But anyways..."
                    },
                    {
                        "username": "Rajat310",
                        "content": "[@artem09122002](/artem09122002) It is true. The x-coordinates are all the same(i.e. constant) and thus form a straight line on the x-axis regardless of the y-axis."
                    }
                ]
            },
            {
                "id": 1918115,
                "content": [
                    {
                        "username": "VaseemBhai",
                        "content": "This is an amazing problem.\\nSimple math but makes you wonder about all the problems at your job that you could\\'ve solved differently."
                    },
                    {
                        "username": "Augus7",
                        "content": "ffs give better test cases"
                    },
                    {
                        "username": "haoder2003",
                        "content": "[@aakashdarji20](/aakashdarji20) hehe"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "What is ff?"
                    },
                    {
                        "username": "hewy96",
                        "content": "I suck at maths why am I getting this question? in what world or interview would I get asked this man"
                    },
                    {
                        "username": "cecilia5",
                        "content": "How would you do this in high dimension?"
                    },
                    {
                        "username": "anwendeng",
                        "content": " How do you in higher dimension? It could be a plane in R^3, or  (n-1)-dimensional hyperplane in R^(n-1). Or just  on a line?"
                    },
                    {
                        "username": "wafsinc",
                        "content": "First, subtract the first vector from all the vectors. This just moves the first point to the origin. Now all the points are colinear if and only if every point is a scalar multiple of the second vector."
                    },
                    {
                        "username": "sundeepas4u",
                        "content": "Hi All,\\ni am not sure if i am making a mistake. i am just trying to solve with equation y=m*x+c where m is the slope and c is the intercept on y axis.\\n\\nnow i would follow the below steps\\n1. i calculate the slope by m= (y2-y1)/(x2-x1) where (x1,y1) and (x2,y2) are first two elements of the coordinates array. \\n2. here if x2-x1 is 0 or y2-y1 is 0 then i consider slope as 0 as the line is either parallel to x axis or y axis. i handle this check seperately.\\n3. if i have a non zero slope, i use y=m*x+c and calculate c by substituting  first point in the equation.\\n4. now i have both m and c, i just loop through the array and check foreach (x,y) if y is equal to m*x+c. if not i will return false. \\n5. if the loop succeeds i return true.\\n\\nfor some reason this is not working. am i doing something wrong?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This method won\\'t work if the points are vertically aligned (hint: the gradient is NOT zero)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "be careful, not divided by zero"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Slope Calculation: The main idea to solve this problem is to calculate the slope between consecutive points.\\n\\nInitial Slope: Calculate the slope between the first two points (x1, y1) and (x2, y2) as slope = (y2 - y1) / (x2 - x1).\\n\\nComparing Slopes: For each subsequent point (xi, yi), calculate the slope between the previous point and the current point.\\n\\nHandling Vertical Lines: To handle vertical lines where (x2 - x1) is zero, check if the denominator is zero before calculating the slope. If it\\'s zero, set the current slope to a unique value (e.g., double.MaxValue).\\n\\nCompare Slopes: Compare the current slope with the initial slope. If any of the calculated slopes are different, return false, indicating that the points do not form a straight line.\\n\\nReturn true: If all slopes are equal, return true, indicating that the points form a straight line."
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "How does Leetcode perform division in Python? There\\'s a test case that I\\'m having trouble with that works perfectly fine in my own IDE, but for some reason on here it evaluates a regular division (/) as an integer divison (//)?"
                    },
                    {
                        "username": "Rajat310",
                        "content": "Monday well spent \\u26A1\\uD83D\\uDCB9"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "[[2,4],[2,5],[2,8]] is not a straight line but its expecting true. what to do in such case?"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "Got it, thanks"
                    },
                    {
                        "username": "vvvvz",
                        "content": "yep, it is a valid case, all coordinates describe vertical line - i.e., x is constant for all points, y can be different"
                    },
                    {
                        "username": "femorg",
                        "content": "it is a straight line on the x-axis regardless of where the y-values are."
                    },
                    {
                        "username": "aftab0711",
                        "content": "Basic geometry:\\n\\n1. If Every coordinates have same slope then they form a straight line.\\n2. Lets assume you are give two coordinates in a plan (x1,y1), (x2,y2).\\n3. Then slope \\'m\\' is equal to (y2-y1) / (x2-x1).\\n4. What if (x2-x1)=0? (then slop becomes undefined) see my solution understand more.\\ncheck my solution to handle edge cases  https://leetcode.com/problems/check-if-it-is-a-straight-line/solutions/3601634/easy-java-explained-approach/"
                    }
                ]
            },
            {
                "id": 1918030,
                "content": [
                    {
                        "username": "VaseemBhai",
                        "content": "This is an amazing problem.\\nSimple math but makes you wonder about all the problems at your job that you could\\'ve solved differently."
                    },
                    {
                        "username": "Augus7",
                        "content": "ffs give better test cases"
                    },
                    {
                        "username": "haoder2003",
                        "content": "[@aakashdarji20](/aakashdarji20) hehe"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "What is ff?"
                    },
                    {
                        "username": "hewy96",
                        "content": "I suck at maths why am I getting this question? in what world or interview would I get asked this man"
                    },
                    {
                        "username": "cecilia5",
                        "content": "How would you do this in high dimension?"
                    },
                    {
                        "username": "anwendeng",
                        "content": " How do you in higher dimension? It could be a plane in R^3, or  (n-1)-dimensional hyperplane in R^(n-1). Or just  on a line?"
                    },
                    {
                        "username": "wafsinc",
                        "content": "First, subtract the first vector from all the vectors. This just moves the first point to the origin. Now all the points are colinear if and only if every point is a scalar multiple of the second vector."
                    },
                    {
                        "username": "sundeepas4u",
                        "content": "Hi All,\\ni am not sure if i am making a mistake. i am just trying to solve with equation y=m*x+c where m is the slope and c is the intercept on y axis.\\n\\nnow i would follow the below steps\\n1. i calculate the slope by m= (y2-y1)/(x2-x1) where (x1,y1) and (x2,y2) are first two elements of the coordinates array. \\n2. here if x2-x1 is 0 or y2-y1 is 0 then i consider slope as 0 as the line is either parallel to x axis or y axis. i handle this check seperately.\\n3. if i have a non zero slope, i use y=m*x+c and calculate c by substituting  first point in the equation.\\n4. now i have both m and c, i just loop through the array and check foreach (x,y) if y is equal to m*x+c. if not i will return false. \\n5. if the loop succeeds i return true.\\n\\nfor some reason this is not working. am i doing something wrong?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This method won\\'t work if the points are vertically aligned (hint: the gradient is NOT zero)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "be careful, not divided by zero"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Slope Calculation: The main idea to solve this problem is to calculate the slope between consecutive points.\\n\\nInitial Slope: Calculate the slope between the first two points (x1, y1) and (x2, y2) as slope = (y2 - y1) / (x2 - x1).\\n\\nComparing Slopes: For each subsequent point (xi, yi), calculate the slope between the previous point and the current point.\\n\\nHandling Vertical Lines: To handle vertical lines where (x2 - x1) is zero, check if the denominator is zero before calculating the slope. If it\\'s zero, set the current slope to a unique value (e.g., double.MaxValue).\\n\\nCompare Slopes: Compare the current slope with the initial slope. If any of the calculated slopes are different, return false, indicating that the points do not form a straight line.\\n\\nReturn true: If all slopes are equal, return true, indicating that the points form a straight line."
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "How does Leetcode perform division in Python? There\\'s a test case that I\\'m having trouble with that works perfectly fine in my own IDE, but for some reason on here it evaluates a regular division (/) as an integer divison (//)?"
                    },
                    {
                        "username": "Rajat310",
                        "content": "Monday well spent \\u26A1\\uD83D\\uDCB9"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "[[2,4],[2,5],[2,8]] is not a straight line but its expecting true. what to do in such case?"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "Got it, thanks"
                    },
                    {
                        "username": "vvvvz",
                        "content": "yep, it is a valid case, all coordinates describe vertical line - i.e., x is constant for all points, y can be different"
                    },
                    {
                        "username": "femorg",
                        "content": "it is a straight line on the x-axis regardless of where the y-values are."
                    },
                    {
                        "username": "aftab0711",
                        "content": "Basic geometry:\\n\\n1. If Every coordinates have same slope then they form a straight line.\\n2. Lets assume you are give two coordinates in a plan (x1,y1), (x2,y2).\\n3. Then slope \\'m\\' is equal to (y2-y1) / (x2-x1).\\n4. What if (x2-x1)=0? (then slop becomes undefined) see my solution understand more.\\ncheck my solution to handle edge cases  https://leetcode.com/problems/check-if-it-is-a-straight-line/solutions/3601634/easy-java-explained-approach/"
                    }
                ]
            },
            {
                "id": 1917846,
                "content": [
                    {
                        "username": "VaseemBhai",
                        "content": "This is an amazing problem.\\nSimple math but makes you wonder about all the problems at your job that you could\\'ve solved differently."
                    },
                    {
                        "username": "Augus7",
                        "content": "ffs give better test cases"
                    },
                    {
                        "username": "haoder2003",
                        "content": "[@aakashdarji20](/aakashdarji20) hehe"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "What is ff?"
                    },
                    {
                        "username": "hewy96",
                        "content": "I suck at maths why am I getting this question? in what world or interview would I get asked this man"
                    },
                    {
                        "username": "cecilia5",
                        "content": "How would you do this in high dimension?"
                    },
                    {
                        "username": "anwendeng",
                        "content": " How do you in higher dimension? It could be a plane in R^3, or  (n-1)-dimensional hyperplane in R^(n-1). Or just  on a line?"
                    },
                    {
                        "username": "wafsinc",
                        "content": "First, subtract the first vector from all the vectors. This just moves the first point to the origin. Now all the points are colinear if and only if every point is a scalar multiple of the second vector."
                    },
                    {
                        "username": "sundeepas4u",
                        "content": "Hi All,\\ni am not sure if i am making a mistake. i am just trying to solve with equation y=m*x+c where m is the slope and c is the intercept on y axis.\\n\\nnow i would follow the below steps\\n1. i calculate the slope by m= (y2-y1)/(x2-x1) where (x1,y1) and (x2,y2) are first two elements of the coordinates array. \\n2. here if x2-x1 is 0 or y2-y1 is 0 then i consider slope as 0 as the line is either parallel to x axis or y axis. i handle this check seperately.\\n3. if i have a non zero slope, i use y=m*x+c and calculate c by substituting  first point in the equation.\\n4. now i have both m and c, i just loop through the array and check foreach (x,y) if y is equal to m*x+c. if not i will return false. \\n5. if the loop succeeds i return true.\\n\\nfor some reason this is not working. am i doing something wrong?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This method won\\'t work if the points are vertically aligned (hint: the gradient is NOT zero)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "be careful, not divided by zero"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Slope Calculation: The main idea to solve this problem is to calculate the slope between consecutive points.\\n\\nInitial Slope: Calculate the slope between the first two points (x1, y1) and (x2, y2) as slope = (y2 - y1) / (x2 - x1).\\n\\nComparing Slopes: For each subsequent point (xi, yi), calculate the slope between the previous point and the current point.\\n\\nHandling Vertical Lines: To handle vertical lines where (x2 - x1) is zero, check if the denominator is zero before calculating the slope. If it\\'s zero, set the current slope to a unique value (e.g., double.MaxValue).\\n\\nCompare Slopes: Compare the current slope with the initial slope. If any of the calculated slopes are different, return false, indicating that the points do not form a straight line.\\n\\nReturn true: If all slopes are equal, return true, indicating that the points form a straight line."
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "How does Leetcode perform division in Python? There\\'s a test case that I\\'m having trouble with that works perfectly fine in my own IDE, but for some reason on here it evaluates a regular division (/) as an integer divison (//)?"
                    },
                    {
                        "username": "Rajat310",
                        "content": "Monday well spent \\u26A1\\uD83D\\uDCB9"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "[[2,4],[2,5],[2,8]] is not a straight line but its expecting true. what to do in such case?"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "Got it, thanks"
                    },
                    {
                        "username": "vvvvz",
                        "content": "yep, it is a valid case, all coordinates describe vertical line - i.e., x is constant for all points, y can be different"
                    },
                    {
                        "username": "femorg",
                        "content": "it is a straight line on the x-axis regardless of where the y-values are."
                    },
                    {
                        "username": "aftab0711",
                        "content": "Basic geometry:\\n\\n1. If Every coordinates have same slope then they form a straight line.\\n2. Lets assume you are give two coordinates in a plan (x1,y1), (x2,y2).\\n3. Then slope \\'m\\' is equal to (y2-y1) / (x2-x1).\\n4. What if (x2-x1)=0? (then slop becomes undefined) see my solution understand more.\\ncheck my solution to handle edge cases  https://leetcode.com/problems/check-if-it-is-a-straight-line/solutions/3601634/easy-java-explained-approach/"
                    }
                ]
            },
            {
                "id": 1917462,
                "content": [
                    {
                        "username": "VaseemBhai",
                        "content": "This is an amazing problem.\\nSimple math but makes you wonder about all the problems at your job that you could\\'ve solved differently."
                    },
                    {
                        "username": "Augus7",
                        "content": "ffs give better test cases"
                    },
                    {
                        "username": "haoder2003",
                        "content": "[@aakashdarji20](/aakashdarji20) hehe"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "What is ff?"
                    },
                    {
                        "username": "hewy96",
                        "content": "I suck at maths why am I getting this question? in what world or interview would I get asked this man"
                    },
                    {
                        "username": "cecilia5",
                        "content": "How would you do this in high dimension?"
                    },
                    {
                        "username": "anwendeng",
                        "content": " How do you in higher dimension? It could be a plane in R^3, or  (n-1)-dimensional hyperplane in R^(n-1). Or just  on a line?"
                    },
                    {
                        "username": "wafsinc",
                        "content": "First, subtract the first vector from all the vectors. This just moves the first point to the origin. Now all the points are colinear if and only if every point is a scalar multiple of the second vector."
                    },
                    {
                        "username": "sundeepas4u",
                        "content": "Hi All,\\ni am not sure if i am making a mistake. i am just trying to solve with equation y=m*x+c where m is the slope and c is the intercept on y axis.\\n\\nnow i would follow the below steps\\n1. i calculate the slope by m= (y2-y1)/(x2-x1) where (x1,y1) and (x2,y2) are first two elements of the coordinates array. \\n2. here if x2-x1 is 0 or y2-y1 is 0 then i consider slope as 0 as the line is either parallel to x axis or y axis. i handle this check seperately.\\n3. if i have a non zero slope, i use y=m*x+c and calculate c by substituting  first point in the equation.\\n4. now i have both m and c, i just loop through the array and check foreach (x,y) if y is equal to m*x+c. if not i will return false. \\n5. if the loop succeeds i return true.\\n\\nfor some reason this is not working. am i doing something wrong?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This method won\\'t work if the points are vertically aligned (hint: the gradient is NOT zero)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "be careful, not divided by zero"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Slope Calculation: The main idea to solve this problem is to calculate the slope between consecutive points.\\n\\nInitial Slope: Calculate the slope between the first two points (x1, y1) and (x2, y2) as slope = (y2 - y1) / (x2 - x1).\\n\\nComparing Slopes: For each subsequent point (xi, yi), calculate the slope between the previous point and the current point.\\n\\nHandling Vertical Lines: To handle vertical lines where (x2 - x1) is zero, check if the denominator is zero before calculating the slope. If it\\'s zero, set the current slope to a unique value (e.g., double.MaxValue).\\n\\nCompare Slopes: Compare the current slope with the initial slope. If any of the calculated slopes are different, return false, indicating that the points do not form a straight line.\\n\\nReturn true: If all slopes are equal, return true, indicating that the points form a straight line."
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "How does Leetcode perform division in Python? There\\'s a test case that I\\'m having trouble with that works perfectly fine in my own IDE, but for some reason on here it evaluates a regular division (/) as an integer divison (//)?"
                    },
                    {
                        "username": "Rajat310",
                        "content": "Monday well spent \\u26A1\\uD83D\\uDCB9"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "[[2,4],[2,5],[2,8]] is not a straight line but its expecting true. what to do in such case?"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "Got it, thanks"
                    },
                    {
                        "username": "vvvvz",
                        "content": "yep, it is a valid case, all coordinates describe vertical line - i.e., x is constant for all points, y can be different"
                    },
                    {
                        "username": "femorg",
                        "content": "it is a straight line on the x-axis regardless of where the y-values are."
                    },
                    {
                        "username": "aftab0711",
                        "content": "Basic geometry:\\n\\n1. If Every coordinates have same slope then they form a straight line.\\n2. Lets assume you are give two coordinates in a plan (x1,y1), (x2,y2).\\n3. Then slope \\'m\\' is equal to (y2-y1) / (x2-x1).\\n4. What if (x2-x1)=0? (then slop becomes undefined) see my solution understand more.\\ncheck my solution to handle edge cases  https://leetcode.com/problems/check-if-it-is-a-straight-line/solutions/3601634/easy-java-explained-approach/"
                    }
                ]
            },
            {
                "id": 1776550,
                "content": [
                    {
                        "username": "VaseemBhai",
                        "content": "This is an amazing problem.\\nSimple math but makes you wonder about all the problems at your job that you could\\'ve solved differently."
                    },
                    {
                        "username": "Augus7",
                        "content": "ffs give better test cases"
                    },
                    {
                        "username": "haoder2003",
                        "content": "[@aakashdarji20](/aakashdarji20) hehe"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "What is ff?"
                    },
                    {
                        "username": "hewy96",
                        "content": "I suck at maths why am I getting this question? in what world or interview would I get asked this man"
                    },
                    {
                        "username": "cecilia5",
                        "content": "How would you do this in high dimension?"
                    },
                    {
                        "username": "anwendeng",
                        "content": " How do you in higher dimension? It could be a plane in R^3, or  (n-1)-dimensional hyperplane in R^(n-1). Or just  on a line?"
                    },
                    {
                        "username": "wafsinc",
                        "content": "First, subtract the first vector from all the vectors. This just moves the first point to the origin. Now all the points are colinear if and only if every point is a scalar multiple of the second vector."
                    },
                    {
                        "username": "sundeepas4u",
                        "content": "Hi All,\\ni am not sure if i am making a mistake. i am just trying to solve with equation y=m*x+c where m is the slope and c is the intercept on y axis.\\n\\nnow i would follow the below steps\\n1. i calculate the slope by m= (y2-y1)/(x2-x1) where (x1,y1) and (x2,y2) are first two elements of the coordinates array. \\n2. here if x2-x1 is 0 or y2-y1 is 0 then i consider slope as 0 as the line is either parallel to x axis or y axis. i handle this check seperately.\\n3. if i have a non zero slope, i use y=m*x+c and calculate c by substituting  first point in the equation.\\n4. now i have both m and c, i just loop through the array and check foreach (x,y) if y is equal to m*x+c. if not i will return false. \\n5. if the loop succeeds i return true.\\n\\nfor some reason this is not working. am i doing something wrong?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This method won\\'t work if the points are vertically aligned (hint: the gradient is NOT zero)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "be careful, not divided by zero"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Slope Calculation: The main idea to solve this problem is to calculate the slope between consecutive points.\\n\\nInitial Slope: Calculate the slope between the first two points (x1, y1) and (x2, y2) as slope = (y2 - y1) / (x2 - x1).\\n\\nComparing Slopes: For each subsequent point (xi, yi), calculate the slope between the previous point and the current point.\\n\\nHandling Vertical Lines: To handle vertical lines where (x2 - x1) is zero, check if the denominator is zero before calculating the slope. If it\\'s zero, set the current slope to a unique value (e.g., double.MaxValue).\\n\\nCompare Slopes: Compare the current slope with the initial slope. If any of the calculated slopes are different, return false, indicating that the points do not form a straight line.\\n\\nReturn true: If all slopes are equal, return true, indicating that the points form a straight line."
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "How does Leetcode perform division in Python? There\\'s a test case that I\\'m having trouble with that works perfectly fine in my own IDE, but for some reason on here it evaluates a regular division (/) as an integer divison (//)?"
                    },
                    {
                        "username": "Rajat310",
                        "content": "Monday well spent \\u26A1\\uD83D\\uDCB9"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "[[2,4],[2,5],[2,8]] is not a straight line but its expecting true. what to do in such case?"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "Got it, thanks"
                    },
                    {
                        "username": "vvvvz",
                        "content": "yep, it is a valid case, all coordinates describe vertical line - i.e., x is constant for all points, y can be different"
                    },
                    {
                        "username": "femorg",
                        "content": "it is a straight line on the x-axis regardless of where the y-values are."
                    },
                    {
                        "username": "aftab0711",
                        "content": "Basic geometry:\\n\\n1. If Every coordinates have same slope then they form a straight line.\\n2. Lets assume you are give two coordinates in a plan (x1,y1), (x2,y2).\\n3. Then slope \\'m\\' is equal to (y2-y1) / (x2-x1).\\n4. What if (x2-x1)=0? (then slop becomes undefined) see my solution understand more.\\ncheck my solution to handle edge cases  https://leetcode.com/problems/check-if-it-is-a-straight-line/solutions/3601634/easy-java-explained-approach/"
                    }
                ]
            },
            {
                "id": 2057019,
                "content": [
                    {
                        "username": "VaseemBhai",
                        "content": "This is an amazing problem.\\nSimple math but makes you wonder about all the problems at your job that you could\\'ve solved differently."
                    },
                    {
                        "username": "Augus7",
                        "content": "ffs give better test cases"
                    },
                    {
                        "username": "haoder2003",
                        "content": "[@aakashdarji20](/aakashdarji20) hehe"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "What is ff?"
                    },
                    {
                        "username": "hewy96",
                        "content": "I suck at maths why am I getting this question? in what world or interview would I get asked this man"
                    },
                    {
                        "username": "cecilia5",
                        "content": "How would you do this in high dimension?"
                    },
                    {
                        "username": "anwendeng",
                        "content": " How do you in higher dimension? It could be a plane in R^3, or  (n-1)-dimensional hyperplane in R^(n-1). Or just  on a line?"
                    },
                    {
                        "username": "wafsinc",
                        "content": "First, subtract the first vector from all the vectors. This just moves the first point to the origin. Now all the points are colinear if and only if every point is a scalar multiple of the second vector."
                    },
                    {
                        "username": "sundeepas4u",
                        "content": "Hi All,\\ni am not sure if i am making a mistake. i am just trying to solve with equation y=m*x+c where m is the slope and c is the intercept on y axis.\\n\\nnow i would follow the below steps\\n1. i calculate the slope by m= (y2-y1)/(x2-x1) where (x1,y1) and (x2,y2) are first two elements of the coordinates array. \\n2. here if x2-x1 is 0 or y2-y1 is 0 then i consider slope as 0 as the line is either parallel to x axis or y axis. i handle this check seperately.\\n3. if i have a non zero slope, i use y=m*x+c and calculate c by substituting  first point in the equation.\\n4. now i have both m and c, i just loop through the array and check foreach (x,y) if y is equal to m*x+c. if not i will return false. \\n5. if the loop succeeds i return true.\\n\\nfor some reason this is not working. am i doing something wrong?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This method won\\'t work if the points are vertically aligned (hint: the gradient is NOT zero)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "be careful, not divided by zero"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Slope Calculation: The main idea to solve this problem is to calculate the slope between consecutive points.\\n\\nInitial Slope: Calculate the slope between the first two points (x1, y1) and (x2, y2) as slope = (y2 - y1) / (x2 - x1).\\n\\nComparing Slopes: For each subsequent point (xi, yi), calculate the slope between the previous point and the current point.\\n\\nHandling Vertical Lines: To handle vertical lines where (x2 - x1) is zero, check if the denominator is zero before calculating the slope. If it\\'s zero, set the current slope to a unique value (e.g., double.MaxValue).\\n\\nCompare Slopes: Compare the current slope with the initial slope. If any of the calculated slopes are different, return false, indicating that the points do not form a straight line.\\n\\nReturn true: If all slopes are equal, return true, indicating that the points form a straight line."
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "How does Leetcode perform division in Python? There\\'s a test case that I\\'m having trouble with that works perfectly fine in my own IDE, but for some reason on here it evaluates a regular division (/) as an integer divison (//)?"
                    },
                    {
                        "username": "Rajat310",
                        "content": "Monday well spent \\u26A1\\uD83D\\uDCB9"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "[[2,4],[2,5],[2,8]] is not a straight line but its expecting true. what to do in such case?"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "Got it, thanks"
                    },
                    {
                        "username": "vvvvz",
                        "content": "yep, it is a valid case, all coordinates describe vertical line - i.e., x is constant for all points, y can be different"
                    },
                    {
                        "username": "femorg",
                        "content": "it is a straight line on the x-axis regardless of where the y-values are."
                    },
                    {
                        "username": "aftab0711",
                        "content": "Basic geometry:\\n\\n1. If Every coordinates have same slope then they form a straight line.\\n2. Lets assume you are give two coordinates in a plan (x1,y1), (x2,y2).\\n3. Then slope \\'m\\' is equal to (y2-y1) / (x2-x1).\\n4. What if (x2-x1)=0? (then slop becomes undefined) see my solution understand more.\\ncheck my solution to handle edge cases  https://leetcode.com/problems/check-if-it-is-a-straight-line/solutions/3601634/easy-java-explained-approach/"
                    }
                ]
            },
            {
                "id": 1955068,
                "content": [
                    {
                        "username": "VaseemBhai",
                        "content": "This is an amazing problem.\\nSimple math but makes you wonder about all the problems at your job that you could\\'ve solved differently."
                    },
                    {
                        "username": "Augus7",
                        "content": "ffs give better test cases"
                    },
                    {
                        "username": "haoder2003",
                        "content": "[@aakashdarji20](/aakashdarji20) hehe"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "What is ff?"
                    },
                    {
                        "username": "hewy96",
                        "content": "I suck at maths why am I getting this question? in what world or interview would I get asked this man"
                    },
                    {
                        "username": "cecilia5",
                        "content": "How would you do this in high dimension?"
                    },
                    {
                        "username": "anwendeng",
                        "content": " How do you in higher dimension? It could be a plane in R^3, or  (n-1)-dimensional hyperplane in R^(n-1). Or just  on a line?"
                    },
                    {
                        "username": "wafsinc",
                        "content": "First, subtract the first vector from all the vectors. This just moves the first point to the origin. Now all the points are colinear if and only if every point is a scalar multiple of the second vector."
                    },
                    {
                        "username": "sundeepas4u",
                        "content": "Hi All,\\ni am not sure if i am making a mistake. i am just trying to solve with equation y=m*x+c where m is the slope and c is the intercept on y axis.\\n\\nnow i would follow the below steps\\n1. i calculate the slope by m= (y2-y1)/(x2-x1) where (x1,y1) and (x2,y2) are first two elements of the coordinates array. \\n2. here if x2-x1 is 0 or y2-y1 is 0 then i consider slope as 0 as the line is either parallel to x axis or y axis. i handle this check seperately.\\n3. if i have a non zero slope, i use y=m*x+c and calculate c by substituting  first point in the equation.\\n4. now i have both m and c, i just loop through the array and check foreach (x,y) if y is equal to m*x+c. if not i will return false. \\n5. if the loop succeeds i return true.\\n\\nfor some reason this is not working. am i doing something wrong?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This method won\\'t work if the points are vertically aligned (hint: the gradient is NOT zero)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "be careful, not divided by zero"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Slope Calculation: The main idea to solve this problem is to calculate the slope between consecutive points.\\n\\nInitial Slope: Calculate the slope between the first two points (x1, y1) and (x2, y2) as slope = (y2 - y1) / (x2 - x1).\\n\\nComparing Slopes: For each subsequent point (xi, yi), calculate the slope between the previous point and the current point.\\n\\nHandling Vertical Lines: To handle vertical lines where (x2 - x1) is zero, check if the denominator is zero before calculating the slope. If it\\'s zero, set the current slope to a unique value (e.g., double.MaxValue).\\n\\nCompare Slopes: Compare the current slope with the initial slope. If any of the calculated slopes are different, return false, indicating that the points do not form a straight line.\\n\\nReturn true: If all slopes are equal, return true, indicating that the points form a straight line."
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "How does Leetcode perform division in Python? There\\'s a test case that I\\'m having trouble with that works perfectly fine in my own IDE, but for some reason on here it evaluates a regular division (/) as an integer divison (//)?"
                    },
                    {
                        "username": "Rajat310",
                        "content": "Monday well spent \\u26A1\\uD83D\\uDCB9"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "[[2,4],[2,5],[2,8]] is not a straight line but its expecting true. what to do in such case?"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "Got it, thanks"
                    },
                    {
                        "username": "vvvvz",
                        "content": "yep, it is a valid case, all coordinates describe vertical line - i.e., x is constant for all points, y can be different"
                    },
                    {
                        "username": "femorg",
                        "content": "it is a straight line on the x-axis regardless of where the y-values are."
                    },
                    {
                        "username": "aftab0711",
                        "content": "Basic geometry:\\n\\n1. If Every coordinates have same slope then they form a straight line.\\n2. Lets assume you are give two coordinates in a plan (x1,y1), (x2,y2).\\n3. Then slope \\'m\\' is equal to (y2-y1) / (x2-x1).\\n4. What if (x2-x1)=0? (then slop becomes undefined) see my solution understand more.\\ncheck my solution to handle edge cases  https://leetcode.com/problems/check-if-it-is-a-straight-line/solutions/3601634/easy-java-explained-approach/"
                    }
                ]
            },
            {
                "id": 1918169,
                "content": [
                    {
                        "username": "VaseemBhai",
                        "content": "This is an amazing problem.\\nSimple math but makes you wonder about all the problems at your job that you could\\'ve solved differently."
                    },
                    {
                        "username": "Augus7",
                        "content": "ffs give better test cases"
                    },
                    {
                        "username": "haoder2003",
                        "content": "[@aakashdarji20](/aakashdarji20) hehe"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "What is ff?"
                    },
                    {
                        "username": "hewy96",
                        "content": "I suck at maths why am I getting this question? in what world or interview would I get asked this man"
                    },
                    {
                        "username": "cecilia5",
                        "content": "How would you do this in high dimension?"
                    },
                    {
                        "username": "anwendeng",
                        "content": " How do you in higher dimension? It could be a plane in R^3, or  (n-1)-dimensional hyperplane in R^(n-1). Or just  on a line?"
                    },
                    {
                        "username": "wafsinc",
                        "content": "First, subtract the first vector from all the vectors. This just moves the first point to the origin. Now all the points are colinear if and only if every point is a scalar multiple of the second vector."
                    },
                    {
                        "username": "sundeepas4u",
                        "content": "Hi All,\\ni am not sure if i am making a mistake. i am just trying to solve with equation y=m*x+c where m is the slope and c is the intercept on y axis.\\n\\nnow i would follow the below steps\\n1. i calculate the slope by m= (y2-y1)/(x2-x1) where (x1,y1) and (x2,y2) are first two elements of the coordinates array. \\n2. here if x2-x1 is 0 or y2-y1 is 0 then i consider slope as 0 as the line is either parallel to x axis or y axis. i handle this check seperately.\\n3. if i have a non zero slope, i use y=m*x+c and calculate c by substituting  first point in the equation.\\n4. now i have both m and c, i just loop through the array and check foreach (x,y) if y is equal to m*x+c. if not i will return false. \\n5. if the loop succeeds i return true.\\n\\nfor some reason this is not working. am i doing something wrong?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This method won\\'t work if the points are vertically aligned (hint: the gradient is NOT zero)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "be careful, not divided by zero"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Slope Calculation: The main idea to solve this problem is to calculate the slope between consecutive points.\\n\\nInitial Slope: Calculate the slope between the first two points (x1, y1) and (x2, y2) as slope = (y2 - y1) / (x2 - x1).\\n\\nComparing Slopes: For each subsequent point (xi, yi), calculate the slope between the previous point and the current point.\\n\\nHandling Vertical Lines: To handle vertical lines where (x2 - x1) is zero, check if the denominator is zero before calculating the slope. If it\\'s zero, set the current slope to a unique value (e.g., double.MaxValue).\\n\\nCompare Slopes: Compare the current slope with the initial slope. If any of the calculated slopes are different, return false, indicating that the points do not form a straight line.\\n\\nReturn true: If all slopes are equal, return true, indicating that the points form a straight line."
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "How does Leetcode perform division in Python? There\\'s a test case that I\\'m having trouble with that works perfectly fine in my own IDE, but for some reason on here it evaluates a regular division (/) as an integer divison (//)?"
                    },
                    {
                        "username": "Rajat310",
                        "content": "Monday well spent \\u26A1\\uD83D\\uDCB9"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "[[2,4],[2,5],[2,8]] is not a straight line but its expecting true. what to do in such case?"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "Got it, thanks"
                    },
                    {
                        "username": "vvvvz",
                        "content": "yep, it is a valid case, all coordinates describe vertical line - i.e., x is constant for all points, y can be different"
                    },
                    {
                        "username": "femorg",
                        "content": "it is a straight line on the x-axis regardless of where the y-values are."
                    },
                    {
                        "username": "aftab0711",
                        "content": "Basic geometry:\\n\\n1. If Every coordinates have same slope then they form a straight line.\\n2. Lets assume you are give two coordinates in a plan (x1,y1), (x2,y2).\\n3. Then slope \\'m\\' is equal to (y2-y1) / (x2-x1).\\n4. What if (x2-x1)=0? (then slop becomes undefined) see my solution understand more.\\ncheck my solution to handle edge cases  https://leetcode.com/problems/check-if-it-is-a-straight-line/solutions/3601634/easy-java-explained-approach/"
                    }
                ]
            },
            {
                "id": 1918120,
                "content": [
                    {
                        "username": "VaseemBhai",
                        "content": "This is an amazing problem.\\nSimple math but makes you wonder about all the problems at your job that you could\\'ve solved differently."
                    },
                    {
                        "username": "Augus7",
                        "content": "ffs give better test cases"
                    },
                    {
                        "username": "haoder2003",
                        "content": "[@aakashdarji20](/aakashdarji20) hehe"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "What is ff?"
                    },
                    {
                        "username": "hewy96",
                        "content": "I suck at maths why am I getting this question? in what world or interview would I get asked this man"
                    },
                    {
                        "username": "cecilia5",
                        "content": "How would you do this in high dimension?"
                    },
                    {
                        "username": "anwendeng",
                        "content": " How do you in higher dimension? It could be a plane in R^3, or  (n-1)-dimensional hyperplane in R^(n-1). Or just  on a line?"
                    },
                    {
                        "username": "wafsinc",
                        "content": "First, subtract the first vector from all the vectors. This just moves the first point to the origin. Now all the points are colinear if and only if every point is a scalar multiple of the second vector."
                    },
                    {
                        "username": "sundeepas4u",
                        "content": "Hi All,\\ni am not sure if i am making a mistake. i am just trying to solve with equation y=m*x+c where m is the slope and c is the intercept on y axis.\\n\\nnow i would follow the below steps\\n1. i calculate the slope by m= (y2-y1)/(x2-x1) where (x1,y1) and (x2,y2) are first two elements of the coordinates array. \\n2. here if x2-x1 is 0 or y2-y1 is 0 then i consider slope as 0 as the line is either parallel to x axis or y axis. i handle this check seperately.\\n3. if i have a non zero slope, i use y=m*x+c and calculate c by substituting  first point in the equation.\\n4. now i have both m and c, i just loop through the array and check foreach (x,y) if y is equal to m*x+c. if not i will return false. \\n5. if the loop succeeds i return true.\\n\\nfor some reason this is not working. am i doing something wrong?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This method won\\'t work if the points are vertically aligned (hint: the gradient is NOT zero)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "be careful, not divided by zero"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Slope Calculation: The main idea to solve this problem is to calculate the slope between consecutive points.\\n\\nInitial Slope: Calculate the slope between the first two points (x1, y1) and (x2, y2) as slope = (y2 - y1) / (x2 - x1).\\n\\nComparing Slopes: For each subsequent point (xi, yi), calculate the slope between the previous point and the current point.\\n\\nHandling Vertical Lines: To handle vertical lines where (x2 - x1) is zero, check if the denominator is zero before calculating the slope. If it\\'s zero, set the current slope to a unique value (e.g., double.MaxValue).\\n\\nCompare Slopes: Compare the current slope with the initial slope. If any of the calculated slopes are different, return false, indicating that the points do not form a straight line.\\n\\nReturn true: If all slopes are equal, return true, indicating that the points form a straight line."
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "How does Leetcode perform division in Python? There\\'s a test case that I\\'m having trouble with that works perfectly fine in my own IDE, but for some reason on here it evaluates a regular division (/) as an integer divison (//)?"
                    },
                    {
                        "username": "Rajat310",
                        "content": "Monday well spent \\u26A1\\uD83D\\uDCB9"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "[[2,4],[2,5],[2,8]] is not a straight line but its expecting true. what to do in such case?"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "Got it, thanks"
                    },
                    {
                        "username": "vvvvz",
                        "content": "yep, it is a valid case, all coordinates describe vertical line - i.e., x is constant for all points, y can be different"
                    },
                    {
                        "username": "femorg",
                        "content": "it is a straight line on the x-axis regardless of where the y-values are."
                    },
                    {
                        "username": "aftab0711",
                        "content": "Basic geometry:\\n\\n1. If Every coordinates have same slope then they form a straight line.\\n2. Lets assume you are give two coordinates in a plan (x1,y1), (x2,y2).\\n3. Then slope \\'m\\' is equal to (y2-y1) / (x2-x1).\\n4. What if (x2-x1)=0? (then slop becomes undefined) see my solution understand more.\\ncheck my solution to handle edge cases  https://leetcode.com/problems/check-if-it-is-a-straight-line/solutions/3601634/easy-java-explained-approach/"
                    }
                ]
            },
            {
                "id": 1918081,
                "content": [
                    {
                        "username": "VaseemBhai",
                        "content": "This is an amazing problem.\\nSimple math but makes you wonder about all the problems at your job that you could\\'ve solved differently."
                    },
                    {
                        "username": "Augus7",
                        "content": "ffs give better test cases"
                    },
                    {
                        "username": "haoder2003",
                        "content": "[@aakashdarji20](/aakashdarji20) hehe"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "What is ff?"
                    },
                    {
                        "username": "hewy96",
                        "content": "I suck at maths why am I getting this question? in what world or interview would I get asked this man"
                    },
                    {
                        "username": "cecilia5",
                        "content": "How would you do this in high dimension?"
                    },
                    {
                        "username": "anwendeng",
                        "content": " How do you in higher dimension? It could be a plane in R^3, or  (n-1)-dimensional hyperplane in R^(n-1). Or just  on a line?"
                    },
                    {
                        "username": "wafsinc",
                        "content": "First, subtract the first vector from all the vectors. This just moves the first point to the origin. Now all the points are colinear if and only if every point is a scalar multiple of the second vector."
                    },
                    {
                        "username": "sundeepas4u",
                        "content": "Hi All,\\ni am not sure if i am making a mistake. i am just trying to solve with equation y=m*x+c where m is the slope and c is the intercept on y axis.\\n\\nnow i would follow the below steps\\n1. i calculate the slope by m= (y2-y1)/(x2-x1) where (x1,y1) and (x2,y2) are first two elements of the coordinates array. \\n2. here if x2-x1 is 0 or y2-y1 is 0 then i consider slope as 0 as the line is either parallel to x axis or y axis. i handle this check seperately.\\n3. if i have a non zero slope, i use y=m*x+c and calculate c by substituting  first point in the equation.\\n4. now i have both m and c, i just loop through the array and check foreach (x,y) if y is equal to m*x+c. if not i will return false. \\n5. if the loop succeeds i return true.\\n\\nfor some reason this is not working. am i doing something wrong?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This method won\\'t work if the points are vertically aligned (hint: the gradient is NOT zero)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "be careful, not divided by zero"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Slope Calculation: The main idea to solve this problem is to calculate the slope between consecutive points.\\n\\nInitial Slope: Calculate the slope between the first two points (x1, y1) and (x2, y2) as slope = (y2 - y1) / (x2 - x1).\\n\\nComparing Slopes: For each subsequent point (xi, yi), calculate the slope between the previous point and the current point.\\n\\nHandling Vertical Lines: To handle vertical lines where (x2 - x1) is zero, check if the denominator is zero before calculating the slope. If it\\'s zero, set the current slope to a unique value (e.g., double.MaxValue).\\n\\nCompare Slopes: Compare the current slope with the initial slope. If any of the calculated slopes are different, return false, indicating that the points do not form a straight line.\\n\\nReturn true: If all slopes are equal, return true, indicating that the points form a straight line."
                    },
                    {
                        "username": "cccccwwwww",
                        "content": "How does Leetcode perform division in Python? There\\'s a test case that I\\'m having trouble with that works perfectly fine in my own IDE, but for some reason on here it evaluates a regular division (/) as an integer divison (//)?"
                    },
                    {
                        "username": "Rajat310",
                        "content": "Monday well spent \\u26A1\\uD83D\\uDCB9"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "[[2,4],[2,5],[2,8]] is not a straight line but its expecting true. what to do in such case?"
                    },
                    {
                        "username": "aakashdarji20",
                        "content": "Got it, thanks"
                    },
                    {
                        "username": "vvvvz",
                        "content": "yep, it is a valid case, all coordinates describe vertical line - i.e., x is constant for all points, y can be different"
                    },
                    {
                        "username": "femorg",
                        "content": "it is a straight line on the x-axis regardless of where the y-values are."
                    },
                    {
                        "username": "aftab0711",
                        "content": "Basic geometry:\\n\\n1. If Every coordinates have same slope then they form a straight line.\\n2. Lets assume you are give two coordinates in a plan (x1,y1), (x2,y2).\\n3. Then slope \\'m\\' is equal to (y2-y1) / (x2-x1).\\n4. What if (x2-x1)=0? (then slop becomes undefined) see my solution understand more.\\ncheck my solution to handle edge cases  https://leetcode.com/problems/check-if-it-is-a-straight-line/solutions/3601634/easy-java-explained-approach/"
                    }
                ]
            },
            {
                "id": 1918026,
                "content": [
                    {
                        "username": "youngkaneda",
                        "content": "checking if the cross product always result in 0, we can see if the points are on a straight line:\\n(x2\\u2212x1)(y3\\u2212y1)\\u2212(y2\\u2212y1)(x3\\u2212x1)"
                    },
                    {
                        "username": "CodingCubed",
                        "content": "I am having trouble with the test-case  `[[1,1], [2,2],[2,0]]`. I have a statement to check if \\u0394x (dividing by zero) is zero. But this case specifically is giving me problems and I don\\'t know why.\\n\\nPlease explain in simple math terms. I am 14. (Also if you want to make a code solution, Java would be preferable)."
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "This is the edge case handling for vertical lines : \\n        \\n        vector<int> p1 = coordinates[0];\\n        vector<int> p2 = coordinates[1];\\n        if(p1[0] == p2[0]){\\n            for(int i = 2;i < size; i++){\\n                if(coordinates[i][0] != p1[0])\\n                    return false;\\n            }\\n            return true;\\n        }"
                    },
                    {
                        "username": "Socrii13",
                        "content": "we can also use mid element property and its doing very well the only thing which have to think about if the number of point given is  odd then there have to fill some logic part . \\nExplicitly check with the middle with the slop property "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Just solved this in Java. I was so confused when my code gave the wrong answer. I calculated the slope for the first two points and then found the line intercept using c = y - m*x. Whenever (x2 - x1) was zero, I used Double.POSITIVE_INFINITY. Then I checked if the next successive pairs of points have the same slope and intercept. But I was getting wrong answers for some test cases. The intercept becomes NaN when the slope is infinity. Turns out using \"!=\" operator between two NaN\\'s was the problem (NaN != NaN is true in Java lol). Fixed that and it passed all cases "
                    },
                    {
                        "username": "Tirbal",
                        "content": "The question does not explicitly state that points are sorted by x, but this is critical, because if we sort them, the time-complexity drops from \"O(n) beats 100%\" to \"O(n*log(n)) beats 5%\"."
                    },
                    {
                        "username": "Ricardofer2004",
                        "content": "There is no reason as to why you should sort the points. Thus, it should not matter either way"
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "float slope = 0;\\n        if(coordinates[1][0]-coordinates[0][0]==0){\\n            slope=(float)Integer.MAX_VALUE;\\n        }\\n        else{\\n            slope = (coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n        }\\n        for(int i = 2 ; i < coordinates.length ; i++){\\n            float s = 0;\\n            if(coordinates[i][0]-coordinates[i-1][0]==0){\\n            s=(float)Integer.MAX_VALUE;\\n            }\\n            else{\\n            s= (coordinates[i][1]-coordinates[i-1][1])/(coordinates[i][0]-coordinates[i-1][0]);\\n            }\\nif(s!=slope) return false;\\n        }\\n        return true; \\n\\nwhy is this wrong?? it gives error on the last test case\\n"
                    },
                    {
                        "username": "swarajkalbande123",
                        "content": "That is because you have to typecast coordinates[i][1]-coordinates[i-1][1] to float before dividing\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "any two points will always make a straight line, so find the slope, then traverse the input and find slope for each two consecutive points, like if A,B  & B,C lies in a straight line definitely A,C is in straight line. But make sure to check for vertical line, coz there the slope will be infinite,\\n\\nformula for slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "keerti_2109",
                        "content": "check with the slope of first two points, slope of two points is y2-y1/x2-x1  To get rid of edge case do not divide just do cross multiplication (dx1*dy2 = dy1*dx2)"
                    },
                    {
                        "username": "Avanishmanitripathi",
                        "content": "The major point of discussion in the question \"Check if these points make a straight line in the XY plane\" is to determine if a given set of points lie on a straight line. This involves understanding the geometric properties of a line and applying them to the given set of points. One approach to solving this problem is to calculate the slope between pairs of points and check if it is the same for all pairs. Another approach is to use cross product to check if the points are collinear."
                    }
                ]
            },
            {
                "id": 1917973,
                "content": [
                    {
                        "username": "youngkaneda",
                        "content": "checking if the cross product always result in 0, we can see if the points are on a straight line:\\n(x2\\u2212x1)(y3\\u2212y1)\\u2212(y2\\u2212y1)(x3\\u2212x1)"
                    },
                    {
                        "username": "CodingCubed",
                        "content": "I am having trouble with the test-case  `[[1,1], [2,2],[2,0]]`. I have a statement to check if \\u0394x (dividing by zero) is zero. But this case specifically is giving me problems and I don\\'t know why.\\n\\nPlease explain in simple math terms. I am 14. (Also if you want to make a code solution, Java would be preferable)."
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "This is the edge case handling for vertical lines : \\n        \\n        vector<int> p1 = coordinates[0];\\n        vector<int> p2 = coordinates[1];\\n        if(p1[0] == p2[0]){\\n            for(int i = 2;i < size; i++){\\n                if(coordinates[i][0] != p1[0])\\n                    return false;\\n            }\\n            return true;\\n        }"
                    },
                    {
                        "username": "Socrii13",
                        "content": "we can also use mid element property and its doing very well the only thing which have to think about if the number of point given is  odd then there have to fill some logic part . \\nExplicitly check with the middle with the slop property "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Just solved this in Java. I was so confused when my code gave the wrong answer. I calculated the slope for the first two points and then found the line intercept using c = y - m*x. Whenever (x2 - x1) was zero, I used Double.POSITIVE_INFINITY. Then I checked if the next successive pairs of points have the same slope and intercept. But I was getting wrong answers for some test cases. The intercept becomes NaN when the slope is infinity. Turns out using \"!=\" operator between two NaN\\'s was the problem (NaN != NaN is true in Java lol). Fixed that and it passed all cases "
                    },
                    {
                        "username": "Tirbal",
                        "content": "The question does not explicitly state that points are sorted by x, but this is critical, because if we sort them, the time-complexity drops from \"O(n) beats 100%\" to \"O(n*log(n)) beats 5%\"."
                    },
                    {
                        "username": "Ricardofer2004",
                        "content": "There is no reason as to why you should sort the points. Thus, it should not matter either way"
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "float slope = 0;\\n        if(coordinates[1][0]-coordinates[0][0]==0){\\n            slope=(float)Integer.MAX_VALUE;\\n        }\\n        else{\\n            slope = (coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n        }\\n        for(int i = 2 ; i < coordinates.length ; i++){\\n            float s = 0;\\n            if(coordinates[i][0]-coordinates[i-1][0]==0){\\n            s=(float)Integer.MAX_VALUE;\\n            }\\n            else{\\n            s= (coordinates[i][1]-coordinates[i-1][1])/(coordinates[i][0]-coordinates[i-1][0]);\\n            }\\nif(s!=slope) return false;\\n        }\\n        return true; \\n\\nwhy is this wrong?? it gives error on the last test case\\n"
                    },
                    {
                        "username": "swarajkalbande123",
                        "content": "That is because you have to typecast coordinates[i][1]-coordinates[i-1][1] to float before dividing\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "any two points will always make a straight line, so find the slope, then traverse the input and find slope for each two consecutive points, like if A,B  & B,C lies in a straight line definitely A,C is in straight line. But make sure to check for vertical line, coz there the slope will be infinite,\\n\\nformula for slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "keerti_2109",
                        "content": "check with the slope of first two points, slope of two points is y2-y1/x2-x1  To get rid of edge case do not divide just do cross multiplication (dx1*dy2 = dy1*dx2)"
                    },
                    {
                        "username": "Avanishmanitripathi",
                        "content": "The major point of discussion in the question \"Check if these points make a straight line in the XY plane\" is to determine if a given set of points lie on a straight line. This involves understanding the geometric properties of a line and applying them to the given set of points. One approach to solving this problem is to calculate the slope between pairs of points and check if it is the same for all pairs. Another approach is to use cross product to check if the points are collinear."
                    }
                ]
            },
            {
                "id": 1917971,
                "content": [
                    {
                        "username": "youngkaneda",
                        "content": "checking if the cross product always result in 0, we can see if the points are on a straight line:\\n(x2\\u2212x1)(y3\\u2212y1)\\u2212(y2\\u2212y1)(x3\\u2212x1)"
                    },
                    {
                        "username": "CodingCubed",
                        "content": "I am having trouble with the test-case  `[[1,1], [2,2],[2,0]]`. I have a statement to check if \\u0394x (dividing by zero) is zero. But this case specifically is giving me problems and I don\\'t know why.\\n\\nPlease explain in simple math terms. I am 14. (Also if you want to make a code solution, Java would be preferable)."
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "This is the edge case handling for vertical lines : \\n        \\n        vector<int> p1 = coordinates[0];\\n        vector<int> p2 = coordinates[1];\\n        if(p1[0] == p2[0]){\\n            for(int i = 2;i < size; i++){\\n                if(coordinates[i][0] != p1[0])\\n                    return false;\\n            }\\n            return true;\\n        }"
                    },
                    {
                        "username": "Socrii13",
                        "content": "we can also use mid element property and its doing very well the only thing which have to think about if the number of point given is  odd then there have to fill some logic part . \\nExplicitly check with the middle with the slop property "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Just solved this in Java. I was so confused when my code gave the wrong answer. I calculated the slope for the first two points and then found the line intercept using c = y - m*x. Whenever (x2 - x1) was zero, I used Double.POSITIVE_INFINITY. Then I checked if the next successive pairs of points have the same slope and intercept. But I was getting wrong answers for some test cases. The intercept becomes NaN when the slope is infinity. Turns out using \"!=\" operator between two NaN\\'s was the problem (NaN != NaN is true in Java lol). Fixed that and it passed all cases "
                    },
                    {
                        "username": "Tirbal",
                        "content": "The question does not explicitly state that points are sorted by x, but this is critical, because if we sort them, the time-complexity drops from \"O(n) beats 100%\" to \"O(n*log(n)) beats 5%\"."
                    },
                    {
                        "username": "Ricardofer2004",
                        "content": "There is no reason as to why you should sort the points. Thus, it should not matter either way"
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "float slope = 0;\\n        if(coordinates[1][0]-coordinates[0][0]==0){\\n            slope=(float)Integer.MAX_VALUE;\\n        }\\n        else{\\n            slope = (coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n        }\\n        for(int i = 2 ; i < coordinates.length ; i++){\\n            float s = 0;\\n            if(coordinates[i][0]-coordinates[i-1][0]==0){\\n            s=(float)Integer.MAX_VALUE;\\n            }\\n            else{\\n            s= (coordinates[i][1]-coordinates[i-1][1])/(coordinates[i][0]-coordinates[i-1][0]);\\n            }\\nif(s!=slope) return false;\\n        }\\n        return true; \\n\\nwhy is this wrong?? it gives error on the last test case\\n"
                    },
                    {
                        "username": "swarajkalbande123",
                        "content": "That is because you have to typecast coordinates[i][1]-coordinates[i-1][1] to float before dividing\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "any two points will always make a straight line, so find the slope, then traverse the input and find slope for each two consecutive points, like if A,B  & B,C lies in a straight line definitely A,C is in straight line. But make sure to check for vertical line, coz there the slope will be infinite,\\n\\nformula for slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "keerti_2109",
                        "content": "check with the slope of first two points, slope of two points is y2-y1/x2-x1  To get rid of edge case do not divide just do cross multiplication (dx1*dy2 = dy1*dx2)"
                    },
                    {
                        "username": "Avanishmanitripathi",
                        "content": "The major point of discussion in the question \"Check if these points make a straight line in the XY plane\" is to determine if a given set of points lie on a straight line. This involves understanding the geometric properties of a line and applying them to the given set of points. One approach to solving this problem is to calculate the slope between pairs of points and check if it is the same for all pairs. Another approach is to use cross product to check if the points are collinear."
                    }
                ]
            },
            {
                "id": 1917840,
                "content": [
                    {
                        "username": "youngkaneda",
                        "content": "checking if the cross product always result in 0, we can see if the points are on a straight line:\\n(x2\\u2212x1)(y3\\u2212y1)\\u2212(y2\\u2212y1)(x3\\u2212x1)"
                    },
                    {
                        "username": "CodingCubed",
                        "content": "I am having trouble with the test-case  `[[1,1], [2,2],[2,0]]`. I have a statement to check if \\u0394x (dividing by zero) is zero. But this case specifically is giving me problems and I don\\'t know why.\\n\\nPlease explain in simple math terms. I am 14. (Also if you want to make a code solution, Java would be preferable)."
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "This is the edge case handling for vertical lines : \\n        \\n        vector<int> p1 = coordinates[0];\\n        vector<int> p2 = coordinates[1];\\n        if(p1[0] == p2[0]){\\n            for(int i = 2;i < size; i++){\\n                if(coordinates[i][0] != p1[0])\\n                    return false;\\n            }\\n            return true;\\n        }"
                    },
                    {
                        "username": "Socrii13",
                        "content": "we can also use mid element property and its doing very well the only thing which have to think about if the number of point given is  odd then there have to fill some logic part . \\nExplicitly check with the middle with the slop property "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Just solved this in Java. I was so confused when my code gave the wrong answer. I calculated the slope for the first two points and then found the line intercept using c = y - m*x. Whenever (x2 - x1) was zero, I used Double.POSITIVE_INFINITY. Then I checked if the next successive pairs of points have the same slope and intercept. But I was getting wrong answers for some test cases. The intercept becomes NaN when the slope is infinity. Turns out using \"!=\" operator between two NaN\\'s was the problem (NaN != NaN is true in Java lol). Fixed that and it passed all cases "
                    },
                    {
                        "username": "Tirbal",
                        "content": "The question does not explicitly state that points are sorted by x, but this is critical, because if we sort them, the time-complexity drops from \"O(n) beats 100%\" to \"O(n*log(n)) beats 5%\"."
                    },
                    {
                        "username": "Ricardofer2004",
                        "content": "There is no reason as to why you should sort the points. Thus, it should not matter either way"
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "float slope = 0;\\n        if(coordinates[1][0]-coordinates[0][0]==0){\\n            slope=(float)Integer.MAX_VALUE;\\n        }\\n        else{\\n            slope = (coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n        }\\n        for(int i = 2 ; i < coordinates.length ; i++){\\n            float s = 0;\\n            if(coordinates[i][0]-coordinates[i-1][0]==0){\\n            s=(float)Integer.MAX_VALUE;\\n            }\\n            else{\\n            s= (coordinates[i][1]-coordinates[i-1][1])/(coordinates[i][0]-coordinates[i-1][0]);\\n            }\\nif(s!=slope) return false;\\n        }\\n        return true; \\n\\nwhy is this wrong?? it gives error on the last test case\\n"
                    },
                    {
                        "username": "swarajkalbande123",
                        "content": "That is because you have to typecast coordinates[i][1]-coordinates[i-1][1] to float before dividing\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "any two points will always make a straight line, so find the slope, then traverse the input and find slope for each two consecutive points, like if A,B  & B,C lies in a straight line definitely A,C is in straight line. But make sure to check for vertical line, coz there the slope will be infinite,\\n\\nformula for slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "keerti_2109",
                        "content": "check with the slope of first two points, slope of two points is y2-y1/x2-x1  To get rid of edge case do not divide just do cross multiplication (dx1*dy2 = dy1*dx2)"
                    },
                    {
                        "username": "Avanishmanitripathi",
                        "content": "The major point of discussion in the question \"Check if these points make a straight line in the XY plane\" is to determine if a given set of points lie on a straight line. This involves understanding the geometric properties of a line and applying them to the given set of points. One approach to solving this problem is to calculate the slope between pairs of points and check if it is the same for all pairs. Another approach is to use cross product to check if the points are collinear."
                    }
                ]
            },
            {
                "id": 1917743,
                "content": [
                    {
                        "username": "youngkaneda",
                        "content": "checking if the cross product always result in 0, we can see if the points are on a straight line:\\n(x2\\u2212x1)(y3\\u2212y1)\\u2212(y2\\u2212y1)(x3\\u2212x1)"
                    },
                    {
                        "username": "CodingCubed",
                        "content": "I am having trouble with the test-case  `[[1,1], [2,2],[2,0]]`. I have a statement to check if \\u0394x (dividing by zero) is zero. But this case specifically is giving me problems and I don\\'t know why.\\n\\nPlease explain in simple math terms. I am 14. (Also if you want to make a code solution, Java would be preferable)."
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "This is the edge case handling for vertical lines : \\n        \\n        vector<int> p1 = coordinates[0];\\n        vector<int> p2 = coordinates[1];\\n        if(p1[0] == p2[0]){\\n            for(int i = 2;i < size; i++){\\n                if(coordinates[i][0] != p1[0])\\n                    return false;\\n            }\\n            return true;\\n        }"
                    },
                    {
                        "username": "Socrii13",
                        "content": "we can also use mid element property and its doing very well the only thing which have to think about if the number of point given is  odd then there have to fill some logic part . \\nExplicitly check with the middle with the slop property "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Just solved this in Java. I was so confused when my code gave the wrong answer. I calculated the slope for the first two points and then found the line intercept using c = y - m*x. Whenever (x2 - x1) was zero, I used Double.POSITIVE_INFINITY. Then I checked if the next successive pairs of points have the same slope and intercept. But I was getting wrong answers for some test cases. The intercept becomes NaN when the slope is infinity. Turns out using \"!=\" operator between two NaN\\'s was the problem (NaN != NaN is true in Java lol). Fixed that and it passed all cases "
                    },
                    {
                        "username": "Tirbal",
                        "content": "The question does not explicitly state that points are sorted by x, but this is critical, because if we sort them, the time-complexity drops from \"O(n) beats 100%\" to \"O(n*log(n)) beats 5%\"."
                    },
                    {
                        "username": "Ricardofer2004",
                        "content": "There is no reason as to why you should sort the points. Thus, it should not matter either way"
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "float slope = 0;\\n        if(coordinates[1][0]-coordinates[0][0]==0){\\n            slope=(float)Integer.MAX_VALUE;\\n        }\\n        else{\\n            slope = (coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n        }\\n        for(int i = 2 ; i < coordinates.length ; i++){\\n            float s = 0;\\n            if(coordinates[i][0]-coordinates[i-1][0]==0){\\n            s=(float)Integer.MAX_VALUE;\\n            }\\n            else{\\n            s= (coordinates[i][1]-coordinates[i-1][1])/(coordinates[i][0]-coordinates[i-1][0]);\\n            }\\nif(s!=slope) return false;\\n        }\\n        return true; \\n\\nwhy is this wrong?? it gives error on the last test case\\n"
                    },
                    {
                        "username": "swarajkalbande123",
                        "content": "That is because you have to typecast coordinates[i][1]-coordinates[i-1][1] to float before dividing\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "any two points will always make a straight line, so find the slope, then traverse the input and find slope for each two consecutive points, like if A,B  & B,C lies in a straight line definitely A,C is in straight line. But make sure to check for vertical line, coz there the slope will be infinite,\\n\\nformula for slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "keerti_2109",
                        "content": "check with the slope of first two points, slope of two points is y2-y1/x2-x1  To get rid of edge case do not divide just do cross multiplication (dx1*dy2 = dy1*dx2)"
                    },
                    {
                        "username": "Avanishmanitripathi",
                        "content": "The major point of discussion in the question \"Check if these points make a straight line in the XY plane\" is to determine if a given set of points lie on a straight line. This involves understanding the geometric properties of a line and applying them to the given set of points. One approach to solving this problem is to calculate the slope between pairs of points and check if it is the same for all pairs. Another approach is to use cross product to check if the points are collinear."
                    }
                ]
            },
            {
                "id": 1917715,
                "content": [
                    {
                        "username": "youngkaneda",
                        "content": "checking if the cross product always result in 0, we can see if the points are on a straight line:\\n(x2\\u2212x1)(y3\\u2212y1)\\u2212(y2\\u2212y1)(x3\\u2212x1)"
                    },
                    {
                        "username": "CodingCubed",
                        "content": "I am having trouble with the test-case  `[[1,1], [2,2],[2,0]]`. I have a statement to check if \\u0394x (dividing by zero) is zero. But this case specifically is giving me problems and I don\\'t know why.\\n\\nPlease explain in simple math terms. I am 14. (Also if you want to make a code solution, Java would be preferable)."
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "This is the edge case handling for vertical lines : \\n        \\n        vector<int> p1 = coordinates[0];\\n        vector<int> p2 = coordinates[1];\\n        if(p1[0] == p2[0]){\\n            for(int i = 2;i < size; i++){\\n                if(coordinates[i][0] != p1[0])\\n                    return false;\\n            }\\n            return true;\\n        }"
                    },
                    {
                        "username": "Socrii13",
                        "content": "we can also use mid element property and its doing very well the only thing which have to think about if the number of point given is  odd then there have to fill some logic part . \\nExplicitly check with the middle with the slop property "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Just solved this in Java. I was so confused when my code gave the wrong answer. I calculated the slope for the first two points and then found the line intercept using c = y - m*x. Whenever (x2 - x1) was zero, I used Double.POSITIVE_INFINITY. Then I checked if the next successive pairs of points have the same slope and intercept. But I was getting wrong answers for some test cases. The intercept becomes NaN when the slope is infinity. Turns out using \"!=\" operator between two NaN\\'s was the problem (NaN != NaN is true in Java lol). Fixed that and it passed all cases "
                    },
                    {
                        "username": "Tirbal",
                        "content": "The question does not explicitly state that points are sorted by x, but this is critical, because if we sort them, the time-complexity drops from \"O(n) beats 100%\" to \"O(n*log(n)) beats 5%\"."
                    },
                    {
                        "username": "Ricardofer2004",
                        "content": "There is no reason as to why you should sort the points. Thus, it should not matter either way"
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "float slope = 0;\\n        if(coordinates[1][0]-coordinates[0][0]==0){\\n            slope=(float)Integer.MAX_VALUE;\\n        }\\n        else{\\n            slope = (coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n        }\\n        for(int i = 2 ; i < coordinates.length ; i++){\\n            float s = 0;\\n            if(coordinates[i][0]-coordinates[i-1][0]==0){\\n            s=(float)Integer.MAX_VALUE;\\n            }\\n            else{\\n            s= (coordinates[i][1]-coordinates[i-1][1])/(coordinates[i][0]-coordinates[i-1][0]);\\n            }\\nif(s!=slope) return false;\\n        }\\n        return true; \\n\\nwhy is this wrong?? it gives error on the last test case\\n"
                    },
                    {
                        "username": "swarajkalbande123",
                        "content": "That is because you have to typecast coordinates[i][1]-coordinates[i-1][1] to float before dividing\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "any two points will always make a straight line, so find the slope, then traverse the input and find slope for each two consecutive points, like if A,B  & B,C lies in a straight line definitely A,C is in straight line. But make sure to check for vertical line, coz there the slope will be infinite,\\n\\nformula for slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "keerti_2109",
                        "content": "check with the slope of first two points, slope of two points is y2-y1/x2-x1  To get rid of edge case do not divide just do cross multiplication (dx1*dy2 = dy1*dx2)"
                    },
                    {
                        "username": "Avanishmanitripathi",
                        "content": "The major point of discussion in the question \"Check if these points make a straight line in the XY plane\" is to determine if a given set of points lie on a straight line. This involves understanding the geometric properties of a line and applying them to the given set of points. One approach to solving this problem is to calculate the slope between pairs of points and check if it is the same for all pairs. Another approach is to use cross product to check if the points are collinear."
                    }
                ]
            },
            {
                "id": 1917618,
                "content": [
                    {
                        "username": "youngkaneda",
                        "content": "checking if the cross product always result in 0, we can see if the points are on a straight line:\\n(x2\\u2212x1)(y3\\u2212y1)\\u2212(y2\\u2212y1)(x3\\u2212x1)"
                    },
                    {
                        "username": "CodingCubed",
                        "content": "I am having trouble with the test-case  `[[1,1], [2,2],[2,0]]`. I have a statement to check if \\u0394x (dividing by zero) is zero. But this case specifically is giving me problems and I don\\'t know why.\\n\\nPlease explain in simple math terms. I am 14. (Also if you want to make a code solution, Java would be preferable)."
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "This is the edge case handling for vertical lines : \\n        \\n        vector<int> p1 = coordinates[0];\\n        vector<int> p2 = coordinates[1];\\n        if(p1[0] == p2[0]){\\n            for(int i = 2;i < size; i++){\\n                if(coordinates[i][0] != p1[0])\\n                    return false;\\n            }\\n            return true;\\n        }"
                    },
                    {
                        "username": "Socrii13",
                        "content": "we can also use mid element property and its doing very well the only thing which have to think about if the number of point given is  odd then there have to fill some logic part . \\nExplicitly check with the middle with the slop property "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Just solved this in Java. I was so confused when my code gave the wrong answer. I calculated the slope for the first two points and then found the line intercept using c = y - m*x. Whenever (x2 - x1) was zero, I used Double.POSITIVE_INFINITY. Then I checked if the next successive pairs of points have the same slope and intercept. But I was getting wrong answers for some test cases. The intercept becomes NaN when the slope is infinity. Turns out using \"!=\" operator between two NaN\\'s was the problem (NaN != NaN is true in Java lol). Fixed that and it passed all cases "
                    },
                    {
                        "username": "Tirbal",
                        "content": "The question does not explicitly state that points are sorted by x, but this is critical, because if we sort them, the time-complexity drops from \"O(n) beats 100%\" to \"O(n*log(n)) beats 5%\"."
                    },
                    {
                        "username": "Ricardofer2004",
                        "content": "There is no reason as to why you should sort the points. Thus, it should not matter either way"
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "float slope = 0;\\n        if(coordinates[1][0]-coordinates[0][0]==0){\\n            slope=(float)Integer.MAX_VALUE;\\n        }\\n        else{\\n            slope = (coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n        }\\n        for(int i = 2 ; i < coordinates.length ; i++){\\n            float s = 0;\\n            if(coordinates[i][0]-coordinates[i-1][0]==0){\\n            s=(float)Integer.MAX_VALUE;\\n            }\\n            else{\\n            s= (coordinates[i][1]-coordinates[i-1][1])/(coordinates[i][0]-coordinates[i-1][0]);\\n            }\\nif(s!=slope) return false;\\n        }\\n        return true; \\n\\nwhy is this wrong?? it gives error on the last test case\\n"
                    },
                    {
                        "username": "swarajkalbande123",
                        "content": "That is because you have to typecast coordinates[i][1]-coordinates[i-1][1] to float before dividing\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "any two points will always make a straight line, so find the slope, then traverse the input and find slope for each two consecutive points, like if A,B  & B,C lies in a straight line definitely A,C is in straight line. But make sure to check for vertical line, coz there the slope will be infinite,\\n\\nformula for slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "keerti_2109",
                        "content": "check with the slope of first two points, slope of two points is y2-y1/x2-x1  To get rid of edge case do not divide just do cross multiplication (dx1*dy2 = dy1*dx2)"
                    },
                    {
                        "username": "Avanishmanitripathi",
                        "content": "The major point of discussion in the question \"Check if these points make a straight line in the XY plane\" is to determine if a given set of points lie on a straight line. This involves understanding the geometric properties of a line and applying them to the given set of points. One approach to solving this problem is to calculate the slope between pairs of points and check if it is the same for all pairs. Another approach is to use cross product to check if the points are collinear."
                    }
                ]
            },
            {
                "id": 1917582,
                "content": [
                    {
                        "username": "youngkaneda",
                        "content": "checking if the cross product always result in 0, we can see if the points are on a straight line:\\n(x2\\u2212x1)(y3\\u2212y1)\\u2212(y2\\u2212y1)(x3\\u2212x1)"
                    },
                    {
                        "username": "CodingCubed",
                        "content": "I am having trouble with the test-case  `[[1,1], [2,2],[2,0]]`. I have a statement to check if \\u0394x (dividing by zero) is zero. But this case specifically is giving me problems and I don\\'t know why.\\n\\nPlease explain in simple math terms. I am 14. (Also if you want to make a code solution, Java would be preferable)."
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "This is the edge case handling for vertical lines : \\n        \\n        vector<int> p1 = coordinates[0];\\n        vector<int> p2 = coordinates[1];\\n        if(p1[0] == p2[0]){\\n            for(int i = 2;i < size; i++){\\n                if(coordinates[i][0] != p1[0])\\n                    return false;\\n            }\\n            return true;\\n        }"
                    },
                    {
                        "username": "Socrii13",
                        "content": "we can also use mid element property and its doing very well the only thing which have to think about if the number of point given is  odd then there have to fill some logic part . \\nExplicitly check with the middle with the slop property "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Just solved this in Java. I was so confused when my code gave the wrong answer. I calculated the slope for the first two points and then found the line intercept using c = y - m*x. Whenever (x2 - x1) was zero, I used Double.POSITIVE_INFINITY. Then I checked if the next successive pairs of points have the same slope and intercept. But I was getting wrong answers for some test cases. The intercept becomes NaN when the slope is infinity. Turns out using \"!=\" operator between two NaN\\'s was the problem (NaN != NaN is true in Java lol). Fixed that and it passed all cases "
                    },
                    {
                        "username": "Tirbal",
                        "content": "The question does not explicitly state that points are sorted by x, but this is critical, because if we sort them, the time-complexity drops from \"O(n) beats 100%\" to \"O(n*log(n)) beats 5%\"."
                    },
                    {
                        "username": "Ricardofer2004",
                        "content": "There is no reason as to why you should sort the points. Thus, it should not matter either way"
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "float slope = 0;\\n        if(coordinates[1][0]-coordinates[0][0]==0){\\n            slope=(float)Integer.MAX_VALUE;\\n        }\\n        else{\\n            slope = (coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n        }\\n        for(int i = 2 ; i < coordinates.length ; i++){\\n            float s = 0;\\n            if(coordinates[i][0]-coordinates[i-1][0]==0){\\n            s=(float)Integer.MAX_VALUE;\\n            }\\n            else{\\n            s= (coordinates[i][1]-coordinates[i-1][1])/(coordinates[i][0]-coordinates[i-1][0]);\\n            }\\nif(s!=slope) return false;\\n        }\\n        return true; \\n\\nwhy is this wrong?? it gives error on the last test case\\n"
                    },
                    {
                        "username": "swarajkalbande123",
                        "content": "That is because you have to typecast coordinates[i][1]-coordinates[i-1][1] to float before dividing\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "any two points will always make a straight line, so find the slope, then traverse the input and find slope for each two consecutive points, like if A,B  & B,C lies in a straight line definitely A,C is in straight line. But make sure to check for vertical line, coz there the slope will be infinite,\\n\\nformula for slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "keerti_2109",
                        "content": "check with the slope of first two points, slope of two points is y2-y1/x2-x1  To get rid of edge case do not divide just do cross multiplication (dx1*dy2 = dy1*dx2)"
                    },
                    {
                        "username": "Avanishmanitripathi",
                        "content": "The major point of discussion in the question \"Check if these points make a straight line in the XY plane\" is to determine if a given set of points lie on a straight line. This involves understanding the geometric properties of a line and applying them to the given set of points. One approach to solving this problem is to calculate the slope between pairs of points and check if it is the same for all pairs. Another approach is to use cross product to check if the points are collinear."
                    }
                ]
            },
            {
                "id": 1917492,
                "content": [
                    {
                        "username": "youngkaneda",
                        "content": "checking if the cross product always result in 0, we can see if the points are on a straight line:\\n(x2\\u2212x1)(y3\\u2212y1)\\u2212(y2\\u2212y1)(x3\\u2212x1)"
                    },
                    {
                        "username": "CodingCubed",
                        "content": "I am having trouble with the test-case  `[[1,1], [2,2],[2,0]]`. I have a statement to check if \\u0394x (dividing by zero) is zero. But this case specifically is giving me problems and I don\\'t know why.\\n\\nPlease explain in simple math terms. I am 14. (Also if you want to make a code solution, Java would be preferable)."
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "This is the edge case handling for vertical lines : \\n        \\n        vector<int> p1 = coordinates[0];\\n        vector<int> p2 = coordinates[1];\\n        if(p1[0] == p2[0]){\\n            for(int i = 2;i < size; i++){\\n                if(coordinates[i][0] != p1[0])\\n                    return false;\\n            }\\n            return true;\\n        }"
                    },
                    {
                        "username": "Socrii13",
                        "content": "we can also use mid element property and its doing very well the only thing which have to think about if the number of point given is  odd then there have to fill some logic part . \\nExplicitly check with the middle with the slop property "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Just solved this in Java. I was so confused when my code gave the wrong answer. I calculated the slope for the first two points and then found the line intercept using c = y - m*x. Whenever (x2 - x1) was zero, I used Double.POSITIVE_INFINITY. Then I checked if the next successive pairs of points have the same slope and intercept. But I was getting wrong answers for some test cases. The intercept becomes NaN when the slope is infinity. Turns out using \"!=\" operator between two NaN\\'s was the problem (NaN != NaN is true in Java lol). Fixed that and it passed all cases "
                    },
                    {
                        "username": "Tirbal",
                        "content": "The question does not explicitly state that points are sorted by x, but this is critical, because if we sort them, the time-complexity drops from \"O(n) beats 100%\" to \"O(n*log(n)) beats 5%\"."
                    },
                    {
                        "username": "Ricardofer2004",
                        "content": "There is no reason as to why you should sort the points. Thus, it should not matter either way"
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "float slope = 0;\\n        if(coordinates[1][0]-coordinates[0][0]==0){\\n            slope=(float)Integer.MAX_VALUE;\\n        }\\n        else{\\n            slope = (coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n        }\\n        for(int i = 2 ; i < coordinates.length ; i++){\\n            float s = 0;\\n            if(coordinates[i][0]-coordinates[i-1][0]==0){\\n            s=(float)Integer.MAX_VALUE;\\n            }\\n            else{\\n            s= (coordinates[i][1]-coordinates[i-1][1])/(coordinates[i][0]-coordinates[i-1][0]);\\n            }\\nif(s!=slope) return false;\\n        }\\n        return true; \\n\\nwhy is this wrong?? it gives error on the last test case\\n"
                    },
                    {
                        "username": "swarajkalbande123",
                        "content": "That is because you have to typecast coordinates[i][1]-coordinates[i-1][1] to float before dividing\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "any two points will always make a straight line, so find the slope, then traverse the input and find slope for each two consecutive points, like if A,B  & B,C lies in a straight line definitely A,C is in straight line. But make sure to check for vertical line, coz there the slope will be infinite,\\n\\nformula for slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "keerti_2109",
                        "content": "check with the slope of first two points, slope of two points is y2-y1/x2-x1  To get rid of edge case do not divide just do cross multiplication (dx1*dy2 = dy1*dx2)"
                    },
                    {
                        "username": "Avanishmanitripathi",
                        "content": "The major point of discussion in the question \"Check if these points make a straight line in the XY plane\" is to determine if a given set of points lie on a straight line. This involves understanding the geometric properties of a line and applying them to the given set of points. One approach to solving this problem is to calculate the slope between pairs of points and check if it is the same for all pairs. Another approach is to use cross product to check if the points are collinear."
                    }
                ]
            },
            {
                "id": 1917441,
                "content": [
                    {
                        "username": "youngkaneda",
                        "content": "checking if the cross product always result in 0, we can see if the points are on a straight line:\\n(x2\\u2212x1)(y3\\u2212y1)\\u2212(y2\\u2212y1)(x3\\u2212x1)"
                    },
                    {
                        "username": "CodingCubed",
                        "content": "I am having trouble with the test-case  `[[1,1], [2,2],[2,0]]`. I have a statement to check if \\u0394x (dividing by zero) is zero. But this case specifically is giving me problems and I don\\'t know why.\\n\\nPlease explain in simple math terms. I am 14. (Also if you want to make a code solution, Java would be preferable)."
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "This is the edge case handling for vertical lines : \\n        \\n        vector<int> p1 = coordinates[0];\\n        vector<int> p2 = coordinates[1];\\n        if(p1[0] == p2[0]){\\n            for(int i = 2;i < size; i++){\\n                if(coordinates[i][0] != p1[0])\\n                    return false;\\n            }\\n            return true;\\n        }"
                    },
                    {
                        "username": "Socrii13",
                        "content": "we can also use mid element property and its doing very well the only thing which have to think about if the number of point given is  odd then there have to fill some logic part . \\nExplicitly check with the middle with the slop property "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Just solved this in Java. I was so confused when my code gave the wrong answer. I calculated the slope for the first two points and then found the line intercept using c = y - m*x. Whenever (x2 - x1) was zero, I used Double.POSITIVE_INFINITY. Then I checked if the next successive pairs of points have the same slope and intercept. But I was getting wrong answers for some test cases. The intercept becomes NaN when the slope is infinity. Turns out using \"!=\" operator between two NaN\\'s was the problem (NaN != NaN is true in Java lol). Fixed that and it passed all cases "
                    },
                    {
                        "username": "Tirbal",
                        "content": "The question does not explicitly state that points are sorted by x, but this is critical, because if we sort them, the time-complexity drops from \"O(n) beats 100%\" to \"O(n*log(n)) beats 5%\"."
                    },
                    {
                        "username": "Ricardofer2004",
                        "content": "There is no reason as to why you should sort the points. Thus, it should not matter either way"
                    },
                    {
                        "username": "vaibhav_oo7",
                        "content": "float slope = 0;\\n        if(coordinates[1][0]-coordinates[0][0]==0){\\n            slope=(float)Integer.MAX_VALUE;\\n        }\\n        else{\\n            slope = (coordinates[1][1]-coordinates[0][1])/(coordinates[1][0]-coordinates[0][0]);\\n        }\\n        for(int i = 2 ; i < coordinates.length ; i++){\\n            float s = 0;\\n            if(coordinates[i][0]-coordinates[i-1][0]==0){\\n            s=(float)Integer.MAX_VALUE;\\n            }\\n            else{\\n            s= (coordinates[i][1]-coordinates[i-1][1])/(coordinates[i][0]-coordinates[i-1][0]);\\n            }\\nif(s!=slope) return false;\\n        }\\n        return true; \\n\\nwhy is this wrong?? it gives error on the last test case\\n"
                    },
                    {
                        "username": "swarajkalbande123",
                        "content": "That is because you have to typecast coordinates[i][1]-coordinates[i-1][1] to float before dividing\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "any two points will always make a straight line, so find the slope, then traverse the input and find slope for each two consecutive points, like if A,B  & B,C lies in a straight line definitely A,C is in straight line. But make sure to check for vertical line, coz there the slope will be infinite,\\n\\nformula for slope = (y2-y1)/(x2-x1)"
                    },
                    {
                        "username": "keerti_2109",
                        "content": "check with the slope of first two points, slope of two points is y2-y1/x2-x1  To get rid of edge case do not divide just do cross multiplication (dx1*dy2 = dy1*dx2)"
                    },
                    {
                        "username": "Avanishmanitripathi",
                        "content": "The major point of discussion in the question \"Check if these points make a straight line in the XY plane\" is to determine if a given set of points lie on a straight line. This involves understanding the geometric properties of a line and applying them to the given set of points. One approach to solving this problem is to calculate the slope between pairs of points and check if it is the same for all pairs. Another approach is to use cross product to check if the points are collinear."
                    }
                ]
            },
            {
                "id": 1917424,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "a hint to maybe save you time:\n\ninput list is \"sorted\" by x.  \n\nedit: i was wrong, you may still need to sort the list."
                    },
                    {
                        "username": "user5400vw",
                        "content": "[@beardedone](/beardedone) ah, ok, i take it back.  I made a bad assumption based on my solution passing - thanks for checking - i will edit the original comment"
                    },
                    {
                        "username": "beardedone",
                        "content": "I checked... not all the test cases have an input array that is sorted."
                    },
                    {
                        "username": "beardedone",
                        "content": "The input list is sorted?  Are you sure?  That isn\\'t a constraint, and I can create a test case where the input array is not sorted.  If all the test cases for this problem use a sorted array, I think that may be a defect."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "Try calculating area "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Find the \\u0394X\\\\Delta X\\u0394X and \\u0394Y\\\\Delta Y\\u0394Y using the points at index 0 and 1.\\nIterate over the indices from 2 to the end of the list, and for each index i find the \\u0394X\\\\Delta X\\u0394X, \\u0394Y\\\\Delta Y\\u0394Y for points at index 0 and i.\\nCompare the slope calculated in step #1 with that of step #2 using the previous equation.\\nIf the equation is not satisfied, return false.\\nOtherwise, at the end of the loop return true**"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "School Maths is BACK here."
                    },
                    {
                        "username": "giriraj191",
                        "content": "All Users add `Divide by Zero` Testcase in Example TC\\'s, I am also Victim \\uD83D\\uDE25\\n\\n**TC**\\n[[0,0],[0,1],[0,-1]]"
                    },
                    {
                        "username": "psionl0",
                        "content": "A deceptively easy question. I wonder how many other programmers had to revise their algorithms several times as new test cases failed.\n\nSome high school algebra: the slope of a line through any 2 points is \nm = (y0 - y1) / (x0 - x1) = (y1 - y2) / (x1 - x2). Of course, it could be that xi = xj so this can't be used directly. However, we can cross multiply:\n(y0 - y1) * (x1 - x2) = (y1 - y2)  * (x0 - x1) will be true if the 3 points are collinear.\n\nSo go with the test: ``(y[i] - y[i+1]) * (x[i+1] - x[i+2]) == (y[i+1] - y[i+2]) * (x[i] - x[i+1])``\n"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Do i just check if the next point is on the same \"diagonal\" , i.e mod(xj - xi) = mod(yj - yi) ?\ni think this would be faster than comparing slopes"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "[@artyomushko](/artyomushko) oh ok thanks"
                    },
                    {
                        "username": "artyomushko",
                        "content": "The line is not always a diagonal. So [[0,0],[1,2],[2,4]] will not pass your code"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Daily editors know we always have a hard Monday so they\\'re treating us with easy."
                    },
                    {
                        "username": "khe1154",
                        "content": "easy question if you did not flunked maths \\uD83E\\uDD23"
                    },
                    {
                        "username": "yashjoshi5328",
                        "content": "A little Geometry lesson: \\n**COLLINEAR POINTS**\\n\\n-We have a formula to get area of triangle from three coordinates\\ni.e:\\narea=0.5*[x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)]\\nThe above is derived from [shoelace formula](https://www.geeksforgeeks.org/area-of-a-polygon-with-given-n-ordered-vertices/)\\n\\n-if the area is=0\\nthen that means all points in a same line i.e. straight line\\nthus the 3 points are said to be **Collinear Points**"
                    }
                ]
            },
            {
                "id": 1917383,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "a hint to maybe save you time:\n\ninput list is \"sorted\" by x.  \n\nedit: i was wrong, you may still need to sort the list."
                    },
                    {
                        "username": "user5400vw",
                        "content": "[@beardedone](/beardedone) ah, ok, i take it back.  I made a bad assumption based on my solution passing - thanks for checking - i will edit the original comment"
                    },
                    {
                        "username": "beardedone",
                        "content": "I checked... not all the test cases have an input array that is sorted."
                    },
                    {
                        "username": "beardedone",
                        "content": "The input list is sorted?  Are you sure?  That isn\\'t a constraint, and I can create a test case where the input array is not sorted.  If all the test cases for this problem use a sorted array, I think that may be a defect."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "Try calculating area "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Find the \\u0394X\\\\Delta X\\u0394X and \\u0394Y\\\\Delta Y\\u0394Y using the points at index 0 and 1.\\nIterate over the indices from 2 to the end of the list, and for each index i find the \\u0394X\\\\Delta X\\u0394X, \\u0394Y\\\\Delta Y\\u0394Y for points at index 0 and i.\\nCompare the slope calculated in step #1 with that of step #2 using the previous equation.\\nIf the equation is not satisfied, return false.\\nOtherwise, at the end of the loop return true**"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "School Maths is BACK here."
                    },
                    {
                        "username": "giriraj191",
                        "content": "All Users add `Divide by Zero` Testcase in Example TC\\'s, I am also Victim \\uD83D\\uDE25\\n\\n**TC**\\n[[0,0],[0,1],[0,-1]]"
                    },
                    {
                        "username": "psionl0",
                        "content": "A deceptively easy question. I wonder how many other programmers had to revise their algorithms several times as new test cases failed.\n\nSome high school algebra: the slope of a line through any 2 points is \nm = (y0 - y1) / (x0 - x1) = (y1 - y2) / (x1 - x2). Of course, it could be that xi = xj so this can't be used directly. However, we can cross multiply:\n(y0 - y1) * (x1 - x2) = (y1 - y2)  * (x0 - x1) will be true if the 3 points are collinear.\n\nSo go with the test: ``(y[i] - y[i+1]) * (x[i+1] - x[i+2]) == (y[i+1] - y[i+2]) * (x[i] - x[i+1])``\n"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Do i just check if the next point is on the same \"diagonal\" , i.e mod(xj - xi) = mod(yj - yi) ?\ni think this would be faster than comparing slopes"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "[@artyomushko](/artyomushko) oh ok thanks"
                    },
                    {
                        "username": "artyomushko",
                        "content": "The line is not always a diagonal. So [[0,0],[1,2],[2,4]] will not pass your code"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Daily editors know we always have a hard Monday so they\\'re treating us with easy."
                    },
                    {
                        "username": "khe1154",
                        "content": "easy question if you did not flunked maths \\uD83E\\uDD23"
                    },
                    {
                        "username": "yashjoshi5328",
                        "content": "A little Geometry lesson: \\n**COLLINEAR POINTS**\\n\\n-We have a formula to get area of triangle from three coordinates\\ni.e:\\narea=0.5*[x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)]\\nThe above is derived from [shoelace formula](https://www.geeksforgeeks.org/area-of-a-polygon-with-given-n-ordered-vertices/)\\n\\n-if the area is=0\\nthen that means all points in a same line i.e. straight line\\nthus the 3 points are said to be **Collinear Points**"
                    }
                ]
            },
            {
                "id": 1917358,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "a hint to maybe save you time:\n\ninput list is \"sorted\" by x.  \n\nedit: i was wrong, you may still need to sort the list."
                    },
                    {
                        "username": "user5400vw",
                        "content": "[@beardedone](/beardedone) ah, ok, i take it back.  I made a bad assumption based on my solution passing - thanks for checking - i will edit the original comment"
                    },
                    {
                        "username": "beardedone",
                        "content": "I checked... not all the test cases have an input array that is sorted."
                    },
                    {
                        "username": "beardedone",
                        "content": "The input list is sorted?  Are you sure?  That isn\\'t a constraint, and I can create a test case where the input array is not sorted.  If all the test cases for this problem use a sorted array, I think that may be a defect."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "Try calculating area "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Find the \\u0394X\\\\Delta X\\u0394X and \\u0394Y\\\\Delta Y\\u0394Y using the points at index 0 and 1.\\nIterate over the indices from 2 to the end of the list, and for each index i find the \\u0394X\\\\Delta X\\u0394X, \\u0394Y\\\\Delta Y\\u0394Y for points at index 0 and i.\\nCompare the slope calculated in step #1 with that of step #2 using the previous equation.\\nIf the equation is not satisfied, return false.\\nOtherwise, at the end of the loop return true**"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "School Maths is BACK here."
                    },
                    {
                        "username": "giriraj191",
                        "content": "All Users add `Divide by Zero` Testcase in Example TC\\'s, I am also Victim \\uD83D\\uDE25\\n\\n**TC**\\n[[0,0],[0,1],[0,-1]]"
                    },
                    {
                        "username": "psionl0",
                        "content": "A deceptively easy question. I wonder how many other programmers had to revise their algorithms several times as new test cases failed.\n\nSome high school algebra: the slope of a line through any 2 points is \nm = (y0 - y1) / (x0 - x1) = (y1 - y2) / (x1 - x2). Of course, it could be that xi = xj so this can't be used directly. However, we can cross multiply:\n(y0 - y1) * (x1 - x2) = (y1 - y2)  * (x0 - x1) will be true if the 3 points are collinear.\n\nSo go with the test: ``(y[i] - y[i+1]) * (x[i+1] - x[i+2]) == (y[i+1] - y[i+2]) * (x[i] - x[i+1])``\n"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Do i just check if the next point is on the same \"diagonal\" , i.e mod(xj - xi) = mod(yj - yi) ?\ni think this would be faster than comparing slopes"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "[@artyomushko](/artyomushko) oh ok thanks"
                    },
                    {
                        "username": "artyomushko",
                        "content": "The line is not always a diagonal. So [[0,0],[1,2],[2,4]] will not pass your code"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Daily editors know we always have a hard Monday so they\\'re treating us with easy."
                    },
                    {
                        "username": "khe1154",
                        "content": "easy question if you did not flunked maths \\uD83E\\uDD23"
                    },
                    {
                        "username": "yashjoshi5328",
                        "content": "A little Geometry lesson: \\n**COLLINEAR POINTS**\\n\\n-We have a formula to get area of triangle from three coordinates\\ni.e:\\narea=0.5*[x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)]\\nThe above is derived from [shoelace formula](https://www.geeksforgeeks.org/area-of-a-polygon-with-given-n-ordered-vertices/)\\n\\n-if the area is=0\\nthen that means all points in a same line i.e. straight line\\nthus the 3 points are said to be **Collinear Points**"
                    }
                ]
            },
            {
                "id": 1917357,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "a hint to maybe save you time:\n\ninput list is \"sorted\" by x.  \n\nedit: i was wrong, you may still need to sort the list."
                    },
                    {
                        "username": "user5400vw",
                        "content": "[@beardedone](/beardedone) ah, ok, i take it back.  I made a bad assumption based on my solution passing - thanks for checking - i will edit the original comment"
                    },
                    {
                        "username": "beardedone",
                        "content": "I checked... not all the test cases have an input array that is sorted."
                    },
                    {
                        "username": "beardedone",
                        "content": "The input list is sorted?  Are you sure?  That isn\\'t a constraint, and I can create a test case where the input array is not sorted.  If all the test cases for this problem use a sorted array, I think that may be a defect."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "Try calculating area "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Find the \\u0394X\\\\Delta X\\u0394X and \\u0394Y\\\\Delta Y\\u0394Y using the points at index 0 and 1.\\nIterate over the indices from 2 to the end of the list, and for each index i find the \\u0394X\\\\Delta X\\u0394X, \\u0394Y\\\\Delta Y\\u0394Y for points at index 0 and i.\\nCompare the slope calculated in step #1 with that of step #2 using the previous equation.\\nIf the equation is not satisfied, return false.\\nOtherwise, at the end of the loop return true**"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "School Maths is BACK here."
                    },
                    {
                        "username": "giriraj191",
                        "content": "All Users add `Divide by Zero` Testcase in Example TC\\'s, I am also Victim \\uD83D\\uDE25\\n\\n**TC**\\n[[0,0],[0,1],[0,-1]]"
                    },
                    {
                        "username": "psionl0",
                        "content": "A deceptively easy question. I wonder how many other programmers had to revise their algorithms several times as new test cases failed.\n\nSome high school algebra: the slope of a line through any 2 points is \nm = (y0 - y1) / (x0 - x1) = (y1 - y2) / (x1 - x2). Of course, it could be that xi = xj so this can't be used directly. However, we can cross multiply:\n(y0 - y1) * (x1 - x2) = (y1 - y2)  * (x0 - x1) will be true if the 3 points are collinear.\n\nSo go with the test: ``(y[i] - y[i+1]) * (x[i+1] - x[i+2]) == (y[i+1] - y[i+2]) * (x[i] - x[i+1])``\n"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Do i just check if the next point is on the same \"diagonal\" , i.e mod(xj - xi) = mod(yj - yi) ?\ni think this would be faster than comparing slopes"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "[@artyomushko](/artyomushko) oh ok thanks"
                    },
                    {
                        "username": "artyomushko",
                        "content": "The line is not always a diagonal. So [[0,0],[1,2],[2,4]] will not pass your code"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Daily editors know we always have a hard Monday so they\\'re treating us with easy."
                    },
                    {
                        "username": "khe1154",
                        "content": "easy question if you did not flunked maths \\uD83E\\uDD23"
                    },
                    {
                        "username": "yashjoshi5328",
                        "content": "A little Geometry lesson: \\n**COLLINEAR POINTS**\\n\\n-We have a formula to get area of triangle from three coordinates\\ni.e:\\narea=0.5*[x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)]\\nThe above is derived from [shoelace formula](https://www.geeksforgeeks.org/area-of-a-polygon-with-given-n-ordered-vertices/)\\n\\n-if the area is=0\\nthen that means all points in a same line i.e. straight line\\nthus the 3 points are said to be **Collinear Points**"
                    }
                ]
            },
            {
                "id": 1917346,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "a hint to maybe save you time:\n\ninput list is \"sorted\" by x.  \n\nedit: i was wrong, you may still need to sort the list."
                    },
                    {
                        "username": "user5400vw",
                        "content": "[@beardedone](/beardedone) ah, ok, i take it back.  I made a bad assumption based on my solution passing - thanks for checking - i will edit the original comment"
                    },
                    {
                        "username": "beardedone",
                        "content": "I checked... not all the test cases have an input array that is sorted."
                    },
                    {
                        "username": "beardedone",
                        "content": "The input list is sorted?  Are you sure?  That isn\\'t a constraint, and I can create a test case where the input array is not sorted.  If all the test cases for this problem use a sorted array, I think that may be a defect."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "Try calculating area "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Find the \\u0394X\\\\Delta X\\u0394X and \\u0394Y\\\\Delta Y\\u0394Y using the points at index 0 and 1.\\nIterate over the indices from 2 to the end of the list, and for each index i find the \\u0394X\\\\Delta X\\u0394X, \\u0394Y\\\\Delta Y\\u0394Y for points at index 0 and i.\\nCompare the slope calculated in step #1 with that of step #2 using the previous equation.\\nIf the equation is not satisfied, return false.\\nOtherwise, at the end of the loop return true**"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "School Maths is BACK here."
                    },
                    {
                        "username": "giriraj191",
                        "content": "All Users add `Divide by Zero` Testcase in Example TC\\'s, I am also Victim \\uD83D\\uDE25\\n\\n**TC**\\n[[0,0],[0,1],[0,-1]]"
                    },
                    {
                        "username": "psionl0",
                        "content": "A deceptively easy question. I wonder how many other programmers had to revise their algorithms several times as new test cases failed.\n\nSome high school algebra: the slope of a line through any 2 points is \nm = (y0 - y1) / (x0 - x1) = (y1 - y2) / (x1 - x2). Of course, it could be that xi = xj so this can't be used directly. However, we can cross multiply:\n(y0 - y1) * (x1 - x2) = (y1 - y2)  * (x0 - x1) will be true if the 3 points are collinear.\n\nSo go with the test: ``(y[i] - y[i+1]) * (x[i+1] - x[i+2]) == (y[i+1] - y[i+2]) * (x[i] - x[i+1])``\n"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Do i just check if the next point is on the same \"diagonal\" , i.e mod(xj - xi) = mod(yj - yi) ?\ni think this would be faster than comparing slopes"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "[@artyomushko](/artyomushko) oh ok thanks"
                    },
                    {
                        "username": "artyomushko",
                        "content": "The line is not always a diagonal. So [[0,0],[1,2],[2,4]] will not pass your code"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Daily editors know we always have a hard Monday so they\\'re treating us with easy."
                    },
                    {
                        "username": "khe1154",
                        "content": "easy question if you did not flunked maths \\uD83E\\uDD23"
                    },
                    {
                        "username": "yashjoshi5328",
                        "content": "A little Geometry lesson: \\n**COLLINEAR POINTS**\\n\\n-We have a formula to get area of triangle from three coordinates\\ni.e:\\narea=0.5*[x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)]\\nThe above is derived from [shoelace formula](https://www.geeksforgeeks.org/area-of-a-polygon-with-given-n-ordered-vertices/)\\n\\n-if the area is=0\\nthen that means all points in a same line i.e. straight line\\nthus the 3 points are said to be **Collinear Points**"
                    }
                ]
            },
            {
                "id": 1917308,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "a hint to maybe save you time:\n\ninput list is \"sorted\" by x.  \n\nedit: i was wrong, you may still need to sort the list."
                    },
                    {
                        "username": "user5400vw",
                        "content": "[@beardedone](/beardedone) ah, ok, i take it back.  I made a bad assumption based on my solution passing - thanks for checking - i will edit the original comment"
                    },
                    {
                        "username": "beardedone",
                        "content": "I checked... not all the test cases have an input array that is sorted."
                    },
                    {
                        "username": "beardedone",
                        "content": "The input list is sorted?  Are you sure?  That isn\\'t a constraint, and I can create a test case where the input array is not sorted.  If all the test cases for this problem use a sorted array, I think that may be a defect."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "Try calculating area "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Find the \\u0394X\\\\Delta X\\u0394X and \\u0394Y\\\\Delta Y\\u0394Y using the points at index 0 and 1.\\nIterate over the indices from 2 to the end of the list, and for each index i find the \\u0394X\\\\Delta X\\u0394X, \\u0394Y\\\\Delta Y\\u0394Y for points at index 0 and i.\\nCompare the slope calculated in step #1 with that of step #2 using the previous equation.\\nIf the equation is not satisfied, return false.\\nOtherwise, at the end of the loop return true**"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "School Maths is BACK here."
                    },
                    {
                        "username": "giriraj191",
                        "content": "All Users add `Divide by Zero` Testcase in Example TC\\'s, I am also Victim \\uD83D\\uDE25\\n\\n**TC**\\n[[0,0],[0,1],[0,-1]]"
                    },
                    {
                        "username": "psionl0",
                        "content": "A deceptively easy question. I wonder how many other programmers had to revise their algorithms several times as new test cases failed.\n\nSome high school algebra: the slope of a line through any 2 points is \nm = (y0 - y1) / (x0 - x1) = (y1 - y2) / (x1 - x2). Of course, it could be that xi = xj so this can't be used directly. However, we can cross multiply:\n(y0 - y1) * (x1 - x2) = (y1 - y2)  * (x0 - x1) will be true if the 3 points are collinear.\n\nSo go with the test: ``(y[i] - y[i+1]) * (x[i+1] - x[i+2]) == (y[i+1] - y[i+2]) * (x[i] - x[i+1])``\n"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Do i just check if the next point is on the same \"diagonal\" , i.e mod(xj - xi) = mod(yj - yi) ?\ni think this would be faster than comparing slopes"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "[@artyomushko](/artyomushko) oh ok thanks"
                    },
                    {
                        "username": "artyomushko",
                        "content": "The line is not always a diagonal. So [[0,0],[1,2],[2,4]] will not pass your code"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Daily editors know we always have a hard Monday so they\\'re treating us with easy."
                    },
                    {
                        "username": "khe1154",
                        "content": "easy question if you did not flunked maths \\uD83E\\uDD23"
                    },
                    {
                        "username": "yashjoshi5328",
                        "content": "A little Geometry lesson: \\n**COLLINEAR POINTS**\\n\\n-We have a formula to get area of triangle from three coordinates\\ni.e:\\narea=0.5*[x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)]\\nThe above is derived from [shoelace formula](https://www.geeksforgeeks.org/area-of-a-polygon-with-given-n-ordered-vertices/)\\n\\n-if the area is=0\\nthen that means all points in a same line i.e. straight line\\nthus the 3 points are said to be **Collinear Points**"
                    }
                ]
            },
            {
                "id": 1917277,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "a hint to maybe save you time:\n\ninput list is \"sorted\" by x.  \n\nedit: i was wrong, you may still need to sort the list."
                    },
                    {
                        "username": "user5400vw",
                        "content": "[@beardedone](/beardedone) ah, ok, i take it back.  I made a bad assumption based on my solution passing - thanks for checking - i will edit the original comment"
                    },
                    {
                        "username": "beardedone",
                        "content": "I checked... not all the test cases have an input array that is sorted."
                    },
                    {
                        "username": "beardedone",
                        "content": "The input list is sorted?  Are you sure?  That isn\\'t a constraint, and I can create a test case where the input array is not sorted.  If all the test cases for this problem use a sorted array, I think that may be a defect."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "Try calculating area "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Find the \\u0394X\\\\Delta X\\u0394X and \\u0394Y\\\\Delta Y\\u0394Y using the points at index 0 and 1.\\nIterate over the indices from 2 to the end of the list, and for each index i find the \\u0394X\\\\Delta X\\u0394X, \\u0394Y\\\\Delta Y\\u0394Y for points at index 0 and i.\\nCompare the slope calculated in step #1 with that of step #2 using the previous equation.\\nIf the equation is not satisfied, return false.\\nOtherwise, at the end of the loop return true**"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "School Maths is BACK here."
                    },
                    {
                        "username": "giriraj191",
                        "content": "All Users add `Divide by Zero` Testcase in Example TC\\'s, I am also Victim \\uD83D\\uDE25\\n\\n**TC**\\n[[0,0],[0,1],[0,-1]]"
                    },
                    {
                        "username": "psionl0",
                        "content": "A deceptively easy question. I wonder how many other programmers had to revise their algorithms several times as new test cases failed.\n\nSome high school algebra: the slope of a line through any 2 points is \nm = (y0 - y1) / (x0 - x1) = (y1 - y2) / (x1 - x2). Of course, it could be that xi = xj so this can't be used directly. However, we can cross multiply:\n(y0 - y1) * (x1 - x2) = (y1 - y2)  * (x0 - x1) will be true if the 3 points are collinear.\n\nSo go with the test: ``(y[i] - y[i+1]) * (x[i+1] - x[i+2]) == (y[i+1] - y[i+2]) * (x[i] - x[i+1])``\n"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Do i just check if the next point is on the same \"diagonal\" , i.e mod(xj - xi) = mod(yj - yi) ?\ni think this would be faster than comparing slopes"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "[@artyomushko](/artyomushko) oh ok thanks"
                    },
                    {
                        "username": "artyomushko",
                        "content": "The line is not always a diagonal. So [[0,0],[1,2],[2,4]] will not pass your code"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Daily editors know we always have a hard Monday so they\\'re treating us with easy."
                    },
                    {
                        "username": "khe1154",
                        "content": "easy question if you did not flunked maths \\uD83E\\uDD23"
                    },
                    {
                        "username": "yashjoshi5328",
                        "content": "A little Geometry lesson: \\n**COLLINEAR POINTS**\\n\\n-We have a formula to get area of triangle from three coordinates\\ni.e:\\narea=0.5*[x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)]\\nThe above is derived from [shoelace formula](https://www.geeksforgeeks.org/area-of-a-polygon-with-given-n-ordered-vertices/)\\n\\n-if the area is=0\\nthen that means all points in a same line i.e. straight line\\nthus the 3 points are said to be **Collinear Points**"
                    }
                ]
            },
            {
                "id": 1917268,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "a hint to maybe save you time:\n\ninput list is \"sorted\" by x.  \n\nedit: i was wrong, you may still need to sort the list."
                    },
                    {
                        "username": "user5400vw",
                        "content": "[@beardedone](/beardedone) ah, ok, i take it back.  I made a bad assumption based on my solution passing - thanks for checking - i will edit the original comment"
                    },
                    {
                        "username": "beardedone",
                        "content": "I checked... not all the test cases have an input array that is sorted."
                    },
                    {
                        "username": "beardedone",
                        "content": "The input list is sorted?  Are you sure?  That isn\\'t a constraint, and I can create a test case where the input array is not sorted.  If all the test cases for this problem use a sorted array, I think that may be a defect."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "Try calculating area "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Find the \\u0394X\\\\Delta X\\u0394X and \\u0394Y\\\\Delta Y\\u0394Y using the points at index 0 and 1.\\nIterate over the indices from 2 to the end of the list, and for each index i find the \\u0394X\\\\Delta X\\u0394X, \\u0394Y\\\\Delta Y\\u0394Y for points at index 0 and i.\\nCompare the slope calculated in step #1 with that of step #2 using the previous equation.\\nIf the equation is not satisfied, return false.\\nOtherwise, at the end of the loop return true**"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "School Maths is BACK here."
                    },
                    {
                        "username": "giriraj191",
                        "content": "All Users add `Divide by Zero` Testcase in Example TC\\'s, I am also Victim \\uD83D\\uDE25\\n\\n**TC**\\n[[0,0],[0,1],[0,-1]]"
                    },
                    {
                        "username": "psionl0",
                        "content": "A deceptively easy question. I wonder how many other programmers had to revise their algorithms several times as new test cases failed.\n\nSome high school algebra: the slope of a line through any 2 points is \nm = (y0 - y1) / (x0 - x1) = (y1 - y2) / (x1 - x2). Of course, it could be that xi = xj so this can't be used directly. However, we can cross multiply:\n(y0 - y1) * (x1 - x2) = (y1 - y2)  * (x0 - x1) will be true if the 3 points are collinear.\n\nSo go with the test: ``(y[i] - y[i+1]) * (x[i+1] - x[i+2]) == (y[i+1] - y[i+2]) * (x[i] - x[i+1])``\n"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Do i just check if the next point is on the same \"diagonal\" , i.e mod(xj - xi) = mod(yj - yi) ?\ni think this would be faster than comparing slopes"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "[@artyomushko](/artyomushko) oh ok thanks"
                    },
                    {
                        "username": "artyomushko",
                        "content": "The line is not always a diagonal. So [[0,0],[1,2],[2,4]] will not pass your code"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Daily editors know we always have a hard Monday so they\\'re treating us with easy."
                    },
                    {
                        "username": "khe1154",
                        "content": "easy question if you did not flunked maths \\uD83E\\uDD23"
                    },
                    {
                        "username": "yashjoshi5328",
                        "content": "A little Geometry lesson: \\n**COLLINEAR POINTS**\\n\\n-We have a formula to get area of triangle from three coordinates\\ni.e:\\narea=0.5*[x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)]\\nThe above is derived from [shoelace formula](https://www.geeksforgeeks.org/area-of-a-polygon-with-given-n-ordered-vertices/)\\n\\n-if the area is=0\\nthen that means all points in a same line i.e. straight line\\nthus the 3 points are said to be **Collinear Points**"
                    }
                ]
            },
            {
                "id": 1917214,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "a hint to maybe save you time:\n\ninput list is \"sorted\" by x.  \n\nedit: i was wrong, you may still need to sort the list."
                    },
                    {
                        "username": "user5400vw",
                        "content": "[@beardedone](/beardedone) ah, ok, i take it back.  I made a bad assumption based on my solution passing - thanks for checking - i will edit the original comment"
                    },
                    {
                        "username": "beardedone",
                        "content": "I checked... not all the test cases have an input array that is sorted."
                    },
                    {
                        "username": "beardedone",
                        "content": "The input list is sorted?  Are you sure?  That isn\\'t a constraint, and I can create a test case where the input array is not sorted.  If all the test cases for this problem use a sorted array, I think that may be a defect."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "Try calculating area "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Find the \\u0394X\\\\Delta X\\u0394X and \\u0394Y\\\\Delta Y\\u0394Y using the points at index 0 and 1.\\nIterate over the indices from 2 to the end of the list, and for each index i find the \\u0394X\\\\Delta X\\u0394X, \\u0394Y\\\\Delta Y\\u0394Y for points at index 0 and i.\\nCompare the slope calculated in step #1 with that of step #2 using the previous equation.\\nIf the equation is not satisfied, return false.\\nOtherwise, at the end of the loop return true**"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "School Maths is BACK here."
                    },
                    {
                        "username": "giriraj191",
                        "content": "All Users add `Divide by Zero` Testcase in Example TC\\'s, I am also Victim \\uD83D\\uDE25\\n\\n**TC**\\n[[0,0],[0,1],[0,-1]]"
                    },
                    {
                        "username": "psionl0",
                        "content": "A deceptively easy question. I wonder how many other programmers had to revise their algorithms several times as new test cases failed.\n\nSome high school algebra: the slope of a line through any 2 points is \nm = (y0 - y1) / (x0 - x1) = (y1 - y2) / (x1 - x2). Of course, it could be that xi = xj so this can't be used directly. However, we can cross multiply:\n(y0 - y1) * (x1 - x2) = (y1 - y2)  * (x0 - x1) will be true if the 3 points are collinear.\n\nSo go with the test: ``(y[i] - y[i+1]) * (x[i+1] - x[i+2]) == (y[i+1] - y[i+2]) * (x[i] - x[i+1])``\n"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Do i just check if the next point is on the same \"diagonal\" , i.e mod(xj - xi) = mod(yj - yi) ?\ni think this would be faster than comparing slopes"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "[@artyomushko](/artyomushko) oh ok thanks"
                    },
                    {
                        "username": "artyomushko",
                        "content": "The line is not always a diagonal. So [[0,0],[1,2],[2,4]] will not pass your code"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Daily editors know we always have a hard Monday so they\\'re treating us with easy."
                    },
                    {
                        "username": "khe1154",
                        "content": "easy question if you did not flunked maths \\uD83E\\uDD23"
                    },
                    {
                        "username": "yashjoshi5328",
                        "content": "A little Geometry lesson: \\n**COLLINEAR POINTS**\\n\\n-We have a formula to get area of triangle from three coordinates\\ni.e:\\narea=0.5*[x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)]\\nThe above is derived from [shoelace formula](https://www.geeksforgeeks.org/area-of-a-polygon-with-given-n-ordered-vertices/)\\n\\n-if the area is=0\\nthen that means all points in a same line i.e. straight line\\nthus the 3 points are said to be **Collinear Points**"
                    }
                ]
            },
            {
                "id": 1891318,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "a hint to maybe save you time:\n\ninput list is \"sorted\" by x.  \n\nedit: i was wrong, you may still need to sort the list."
                    },
                    {
                        "username": "user5400vw",
                        "content": "[@beardedone](/beardedone) ah, ok, i take it back.  I made a bad assumption based on my solution passing - thanks for checking - i will edit the original comment"
                    },
                    {
                        "username": "beardedone",
                        "content": "I checked... not all the test cases have an input array that is sorted."
                    },
                    {
                        "username": "beardedone",
                        "content": "The input list is sorted?  Are you sure?  That isn\\'t a constraint, and I can create a test case where the input array is not sorted.  If all the test cases for this problem use a sorted array, I think that may be a defect."
                    },
                    {
                        "username": "02Gaurav",
                        "content": "Try calculating area "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**Find the \\u0394X\\\\Delta X\\u0394X and \\u0394Y\\\\Delta Y\\u0394Y using the points at index 0 and 1.\\nIterate over the indices from 2 to the end of the list, and for each index i find the \\u0394X\\\\Delta X\\u0394X, \\u0394Y\\\\Delta Y\\u0394Y for points at index 0 and i.\\nCompare the slope calculated in step #1 with that of step #2 using the previous equation.\\nIf the equation is not satisfied, return false.\\nOtherwise, at the end of the loop return true**"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "School Maths is BACK here."
                    },
                    {
                        "username": "giriraj191",
                        "content": "All Users add `Divide by Zero` Testcase in Example TC\\'s, I am also Victim \\uD83D\\uDE25\\n\\n**TC**\\n[[0,0],[0,1],[0,-1]]"
                    },
                    {
                        "username": "psionl0",
                        "content": "A deceptively easy question. I wonder how many other programmers had to revise their algorithms several times as new test cases failed.\n\nSome high school algebra: the slope of a line through any 2 points is \nm = (y0 - y1) / (x0 - x1) = (y1 - y2) / (x1 - x2). Of course, it could be that xi = xj so this can't be used directly. However, we can cross multiply:\n(y0 - y1) * (x1 - x2) = (y1 - y2)  * (x0 - x1) will be true if the 3 points are collinear.\n\nSo go with the test: ``(y[i] - y[i+1]) * (x[i+1] - x[i+2]) == (y[i+1] - y[i+2]) * (x[i] - x[i+1])``\n"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "Do i just check if the next point is on the same \"diagonal\" , i.e mod(xj - xi) = mod(yj - yi) ?\ni think this would be faster than comparing slopes"
                    },
                    {
                        "username": "chSatyaSavith",
                        "content": "[@artyomushko](/artyomushko) oh ok thanks"
                    },
                    {
                        "username": "artyomushko",
                        "content": "The line is not always a diagonal. So [[0,0],[1,2],[2,4]] will not pass your code"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Daily editors know we always have a hard Monday so they\\'re treating us with easy."
                    },
                    {
                        "username": "khe1154",
                        "content": "easy question if you did not flunked maths \\uD83E\\uDD23"
                    },
                    {
                        "username": "yashjoshi5328",
                        "content": "A little Geometry lesson: \\n**COLLINEAR POINTS**\\n\\n-We have a formula to get area of triangle from three coordinates\\ni.e:\\narea=0.5*[x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)]\\nThe above is derived from [shoelace formula](https://www.geeksforgeeks.org/area-of-a-polygon-with-given-n-ordered-vertices/)\\n\\n-if the area is=0\\nthen that means all points in a same line i.e. straight line\\nthus the 3 points are said to be **Collinear Points**"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Number of Removals to Make Mountain Array",
        "question_content": "<p>You may recall that an array <code>arr</code> is a <strong>mountain array</strong> if and only if:</p>\n\n<ul>\n\t<li><code>arr.length &gt;= 3</code></li>\n\t<li>There exists some index <code>i</code> (<strong>0-indexed</strong>) with <code>0 &lt; i &lt; arr.length - 1</code> such that:\n\t<ul>\n\t\t<li><code>arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]</code></li>\n\t\t<li><code>arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>Given an integer array <code>nums</code>​​​, return <em>the <strong>minimum</strong> number of elements to remove to make </em><code>nums<em>​​​</em></code><em> </em><em>a <strong>mountain array</strong>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The array itself is a mountain array so we do not need to remove any elements.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,1,1,5,6,2,3,1]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> One solution is to remove the elements at indices 0, 1, and 5, making the array nums = [1,5,6,3,1].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>It is guaranteed that you can make a mountain array out of <code>nums</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 952053,
                "title": "python-3-solutions-lis-dp-o-n-log-n-explained",
                "content": "## Solution 1: using LIS\\n\\nThe first idea when I saw this problem is to use already existing problem **300**: Longest Increasing Subsequence (LIS), you can see my solutions with explanations here https://leetcode.com/problems/longest-increasing-subsequence/discuss/667975/Python-3-Lines-dp-with-binary-search-explained\\n\\nSo, the idea is the following: split our list into two parts, and find LIS for left part and also Longest Decreasing Subsequence for the second part. However we need to handle couple of things before: first of all, we want our LIS end with index `i`, so for this we can remove all elements which are less than `nums[i]` from our part. The same we do for the right part and we also reverse it. Finally, find LIS for these parts and if lengths of both parts `2` or more, it means we can construct Mountain Array, so we update our `max_found`.\\n\\n**Complexity**: time complexity it is `O(n log n)` for one LIS, so it will be `O(n^2 log n)` for all partitions, space complexity is `O(n)`.\\n\\n```\\nclass Solution:\\n    def minimumMountainRemovals(self, nums):\\n        def lengthOfLIS(nums):\\n            dp = [10**10] * (len(nums) + 1)\\n            for elem in nums: \\n                dp[bisect.bisect_left(dp, elem)] = elem  \\n            return dp.index(10**10)\\n\\n        max_found = 0\\n        n = len(nums)\\n        for i in range(1, n - 1):\\n            left  = [num for num in nums[:i] if num < nums[i]] + [nums[i]]\\n            right = [nums[i]] + [num for num in nums[i+1:] if num < nums[i]]\\n            right = right[::-1]\\n            a, b = lengthOfLIS(left), lengthOfLIS(right)\\n            if a >=2 and b >= 2: \\n                max_found = max(max_found, a + b - 1)\\n\\n        return n - max_found\\n```\\n\\n## Solution 2, using pure dp\\n\\nActually, it can be done in easier way: let `dp1[i]` be maximum length of LIS, ending with element index `i` and `dp2[i]` be maximum length of Mountain array. Then, update of `dp1` is straightforward: iterate over all previous elements and update it. For `dp2[i]` we again need to iterate over all previous elements and if `nums[j] < nums[i]`, we can update `dp2[i]`, using `dp2[j] + 1` or `dp1[j] + 1`.\\n\\n**Complexity**: time complexity is `O(n^2)`, space complexity is `O(n)`.\\n\\n```\\nclass Solution:\\n    def minimumMountainRemovals(self, nums):\\n        n = len(nums)\\n        dp1, dp2 = [1]*n, [1]*n\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[j] < nums[i]: dp1[i] = max(dp1[i], 1+dp1[j])\\n                if nums[j] > nums[i]: \\n                    if dp1[j] > 1: dp2[i] = max(dp2[i], 1 + dp1[j])\\n                    if dp2[j] > 1: dp2[i] = max(dp2[i], 1 + dp2[j])\\n        \\n        return n - max(dp2)\\n```\\n\\n## Solution 3, O(n log n)\\n\\nActually, we can update LIS solution we already have, but now we need to return also `lens` array, where `lens[i]` is the lenght of LIS, ending with index `i`.\\n\\n```\\nclass Solution:\\n    def minimumMountainRemovals(self, nums):\\n        def LIS(nums):\\n            dp = [10**10] * (len(nums) + 1)\\n            lens = [0]*len(nums)\\n            for i, elem in enumerate(nums): \\n                lens[i] = bisect_left(dp, elem) + 1\\n                dp[lens[i] - 1] = elem \\n            return lens\\n        \\n        l1, l2 = LIS(nums), LIS(nums[::-1])[::-1]\\n        ans, n = 0, len(nums)\\n        for i in range(n):\\n            if l1[i] >= 2 and l2[i] >= 2:\\n                ans = max(ans, l1[i] + l2[i] - 1)\\n                \\n        return n - ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMountainRemovals(self, nums):\\n        def lengthOfLIS(nums):\\n            dp = [10**10] * (len(nums) + 1)\\n            for elem in nums: \\n                dp[bisect.bisect_left(dp, elem)] = elem  \\n            return dp.index(10**10)\\n\\n        max_found = 0\\n        n = len(nums)\\n        for i in range(1, n - 1):\\n            left  = [num for num in nums[:i] if num < nums[i]] + [nums[i]]\\n            right = [nums[i]] + [num for num in nums[i+1:] if num < nums[i]]\\n            right = right[::-1]\\n            a, b = lengthOfLIS(left), lengthOfLIS(right)\\n            if a >=2 and b >= 2: \\n                max_found = max(max_found, a + b - 1)\\n\\n        return n - max_found\\n```\n```\\nclass Solution:\\n    def minimumMountainRemovals(self, nums):\\n        n = len(nums)\\n        dp1, dp2 = [1]*n, [1]*n\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[j] < nums[i]: dp1[i] = max(dp1[i], 1+dp1[j])\\n                if nums[j] > nums[i]: \\n                    if dp1[j] > 1: dp2[i] = max(dp2[i], 1 + dp1[j])\\n                    if dp2[j] > 1: dp2[i] = max(dp2[i], 1 + dp2[j])\\n        \\n        return n - max(dp2)\\n```\n```\\nclass Solution:\\n    def minimumMountainRemovals(self, nums):\\n        def LIS(nums):\\n            dp = [10**10] * (len(nums) + 1)\\n            lens = [0]*len(nums)\\n            for i, elem in enumerate(nums): \\n                lens[i] = bisect_left(dp, elem) + 1\\n                dp[lens[i] - 1] = elem \\n            return lens\\n        \\n        l1, l2 = LIS(nums), LIS(nums[::-1])[::-1]\\n        ans, n = 0, len(nums)\\n        for i in range(n):\\n            if l1[i] >= 2 and l2[i] >= 2:\\n                ans = max(ans, l1[i] + l2[i] - 1)\\n                \\n        return n - ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952016,
                "title": "java-lis-with-detailed-explanation-and-comments-o-n-2-time-and-o-n-space-revised",
                "content": "```\\n/*\\n    Concept: We need to find the maximum number of elements of the array that can be \\n\\tinvolved in a mountain array. We know, that a mountain array contains a peak element \\n\\tand there is an increasing subsequence in the left of the peak and a decreasing subsequence in the right. \\n\\tSo, we need to find out the element(peak), for which the total number of elements from the \\n\\toriginal array involved in the left increasing subsequence and the right decreasing \\n\\tsubsequence, in maximum. This will create a mountain array with the peak element. \\n\\tThen, we can delete the rest of the elements of the array not involved in this mountain array.\\n*/\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n=nums.length;\\n        int []left=new int [n]; // maximum increasing subsequence in the left of an element.\\n        int []right=new int [n]; // maximum increasing subsequence in the left of an element.\\n        Arrays.fill(left,1);\\n        Arrays.fill(right,1);\\n        \\n        // calculating maximum increasing subsequence for the left of an index.\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i]&&left[i]<left[j]+1)\\n                    left[i]=left[j]+1;\\n            }\\n        }\\n        \\n        // calculating maximum increasing subsequence for the right of an index.\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=n-1;j>i;j--){\\n                if(nums[j]<nums[i]&&right[i]<right[j]+1)\\n                    right[i]=right[j]+1;\\n            }\\n        }\\n        \\n        // calculating the maximum number of elements that can be involved in a mountain array.\\n        int max=0;\\n        for(int i=1;i<n-1;i++){\\n\\t\\t   /*\\n\\t\\t       If the below conditional statement is not given, then strictly increasing or strictly \\n\\t\\t\\t   decreasing sequences will also be considered. It will hence fail in,\\n\\t\\t\\t   Test case: [10, 9, 8, 7, 6, 5, 4, 5, 4].\\n\\t\\t\\t\\t\\t---Thanks to @chejianchao for suggesting the test case.\\n\\t\\t\\t\\tWe need to make sure both the LIS on the left and right, ending at index i, \\n\\t\\t\\t\\thas length > 1. \\n\\t\\t   */\\n\\t\\t\\tif(right[i]>1&&left[i]>1) // if element nums[i] is a valid peak, \\n\\t\\t\\t\\tmax=Math.max(max,left[i]+right[i]-1);\\n        }\\n        \\n        // we need to delete the rest of the elements.\\n        return n-max;\\n    }\\n}\\n// O(N^2) time and O(N) space. \\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Concept: We need to find the maximum number of elements of the array that can be \\n\\tinvolved in a mountain array. We know, that a mountain array contains a peak element \\n\\tand there is an increasing subsequence in the left of the peak and a decreasing subsequence in the right. \\n\\tSo, we need to find out the element(peak), for which the total number of elements from the \\n\\toriginal array involved in the left increasing subsequence and the right decreasing \\n\\tsubsequence, in maximum. This will create a mountain array with the peak element. \\n\\tThen, we can delete the rest of the elements of the array not involved in this mountain array.\\n*/\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n=nums.length;\\n        int []left=new int [n]; // maximum increasing subsequence in the left of an element.\\n        int []right=new int [n]; // maximum increasing subsequence in the left of an element.\\n        Arrays.fill(left,1);\\n        Arrays.fill(right,1);\\n        \\n        // calculating maximum increasing subsequence for the left of an index.\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i]&&left[i]<left[j]+1)\\n                    left[i]=left[j]+1;\\n            }\\n        }\\n        \\n        // calculating maximum increasing subsequence for the right of an index.\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=n-1;j>i;j--){\\n                if(nums[j]<nums[i]&&right[i]<right[j]+1)\\n                    right[i]=right[j]+1;\\n            }\\n        }\\n        \\n        // calculating the maximum number of elements that can be involved in a mountain array.\\n        int max=0;\\n        for(int i=1;i<n-1;i++){\\n\\t\\t   /*\\n\\t\\t       If the below conditional statement is not given, then strictly increasing or strictly \\n\\t\\t\\t   decreasing sequences will also be considered. It will hence fail in,\\n\\t\\t\\t   Test case: [10, 9, 8, 7, 6, 5, 4, 5, 4].\\n\\t\\t\\t\\t\\t---Thanks to @chejianchao for suggesting the test case.\\n\\t\\t\\t\\tWe need to make sure both the LIS on the left and right, ending at index i, \\n\\t\\t\\t\\thas length > 1. \\n\\t\\t   */\\n\\t\\t\\tif(right[i]>1&&left[i]>1) // if element nums[i] is a valid peak, \\n\\t\\t\\t\\tmax=Math.max(max,left[i]+right[i]-1);\\n        }\\n        \\n        // we need to delete the rest of the elements.\\n        return n-max;\\n    }\\n}\\n// O(N^2) time and O(N) space. \\n```",
                "codeTag": "Java"
            },
            {
                "id": 951980,
                "title": "c-three-passes-o-nlogn",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Three passes\\n\\n### Intuition\\n\\nAssume we pick `A[i]` as the peak of the mountain, then we are looking for the longest increasing subsequence to the left of `A[i]`, and the longest decreasing subsequence to the right of `A[i]`.\\n\\nWe can reuse the `O(NlogN)` time **binary search** solution to [300. Longest Increasing Subsequence (Medium)](https://leetcode.com/problems/longest-increasing-subsequence/).\\n\\nFor the binary search solution to problem 300, please checkout [my explanation](../300.%20Longest%20Increasing%20Subsequence).\\n\\n### Algorithm\\n\\nLet `a[i]` be the length of the longest increasing subsequence in `A[0..(i-1)]` that can has `A[i]` appended to it, and `b[i]` be the length of the longest decreasing subsequence in `A[(i+1)..(N-1)]` that can has `A[i]` prepended to it.\\n\\nWe can scan from left to right to set the `a[i]` values, and scan from right to left to set the `b[i]` values.\\n\\nFor `1 <= i <= N - 2`, the longest mountain size is `a[i] + b[i] + 1`.\\n\\nSo the answer is the minimum `N - (a[i] + b[i] + 1)`.\\n\\nNote that we need to skip cases where either `a[i]` or `b[i]` is zero because it\\'s invalid.\\n\\nTest cases that should be added:\\n* `[1,2,1,2,3,4]` and `[4,3,2,1,2,1]`. Correct answer is `3`.\\n* `[1,2,1,1,2,3,4,5]` and `[5,4,3,2,1,1,2,1]`. Correct answer is `5`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& A) {\\n        int N = A.size(), ans = N;\\n        vector<int> a(N), b(N), v;\\n        for (int i = 0 ; i < N; ++i) {\\n            int x = A[i];\\n            auto it = lower_bound(begin(v), end(v), x);\\n            a[i] = it - begin(v);\\n            if (it != end(v)) *it = x;\\n            else v.push_back(x);\\n        }\\n        v.clear();\\n        for (int i = N - 1; i >= 0; --i) {\\n            int x = A[i];\\n            auto it = lower_bound(begin(v), end(v), x) ;\\n            b[i] = it - begin(v); \\n            if (it != end(v)) *it = x;\\n            else v.push_back(x);\\n        }\\n        for (int i = 1; i < N; ++i) {\\n            if (a[i] && b[i]) ans = min(ans, N - (a[i] + b[i] + 1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& A) {\\n        int N = A.size(), ans = N;\\n        vector<int> a(N), b(N), v;\\n        for (int i = 0 ; i < N; ++i) {\\n            int x = A[i];\\n            auto it = lower_bound(begin(v), end(v), x);\\n            a[i] = it - begin(v);\\n            if (it != end(v)) *it = x;\\n            else v.push_back(x);\\n        }\\n        v.clear();\\n        for (int i = N - 1; i >= 0; --i) {\\n            int x = A[i];\\n            auto it = lower_bound(begin(v), end(v), x) ;\\n            b[i] = it - begin(v); \\n            if (it != end(v)) *it = x;\\n            else v.push_back(x);\\n        }\\n        for (int i = 1; i < N; ++i) {\\n            if (a[i] && b[i]) ans = min(ans, N - (a[i] + b[i] + 1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951990,
                "title": "python-same-problem-with-max-increasing-subarray-revised-testcases-are-not-enough",
                "content": "The test cases are not strong enough.  There\\'s one case lc didn\\'t cover and most of the right submits using DP would fail...\\nTest case: [10, 9, 8, 7, 6, 5, 4, 5, 4].   \\n---Thansk to @chejianchao \\n\\n\\nsome change to update the dp array with all 0s (only +1 once there\\'s increasing or deceasing)\\nand then add if condition (non zero since we need a peak) during sweeping the array...\\n\\nLeft to right:  Find the maximum increasing subarray ends at pos[i]\\nRight to left\\uFF1A Find the maximum decreasing subarray ends at pos[i]\\n\\nSweep the array one more time to find the maximum increasing left side and maximum decreasing right side at the stop pos[i]\\nsince left side might be all decreasing and right side might be all increasing... so the if condition during sweeping should be added. \\n\\nclass Solution:\\n\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        if len(nums) <= 3:\\n            return 0\\n        # nums = [2,1,1,5,6,2,3,1]\\n        n = len(nums)\\n\\n        # for sure, the inc and dec dp array can be merged using one dp array... but 2 array is easier to read.... \\n        inc = [0] * n\\n        dec = [0] * n\\n\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    inc[i] = max(inc[i], inc[j] + 1)\\n        # print(inc)\\n        for i in range(n-2, -1, -1):\\n            for j in range(n-1, i, -1):\\n                if nums[i] > nums[j]:\\n                    dec[i] = max(dec[i], dec[j] + 1)\\n        # print(dec)\\n        res = 0\\n        for i in range(n):\\n         # if any one side is 0 it means it\\'s strictly increasing (right side) or desceasing (left side) and these positions are not valid\\n            if inc[i] > 0 and dec[i] > 0:\\n                res = max(res, inc[i] + dec[i])\\n        \\n        return n - res - 1\\n\\n        \\n",
                "solutionTags": [],
                "code": "The test cases are not strong enough.  There\\'s one case lc didn\\'t cover and most of the right submits using DP would fail...\\nTest case: [10, 9, 8, 7, 6, 5, 4, 5, 4].   \\n---Thansk to @chejianchao \\n\\n\\nsome change to update the dp array with all 0s (only +1 once there\\'s increasing or deceasing)\\nand then add if condition (non zero since we need a peak) during sweeping the array...\\n\\nLeft to right:  Find the maximum increasing subarray ends at pos[i]\\nRight to left\\uFF1A Find the maximum decreasing subarray ends at pos[i]\\n\\nSweep the array one more time to find the maximum increasing left side and maximum decreasing right side at the stop pos[i]\\nsince left side might be all decreasing and right side might be all increasing... so the if condition during sweeping should be added. \\n\\nclass Solution:\\n\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        if len(nums) <= 3:\\n            return 0\\n        # nums = [2,1,1,5,6,2,3,1]\\n        n = len(nums)\\n\\n        # for sure, the inc and dec dp array can be merged using one dp array... but 2 array is easier to read.... \\n        inc = [0] * n\\n        dec = [0] * n\\n\\n        for i in range(1, n):\\n            for j in range(i):\\n                if nums[i] > nums[j]:\\n                    inc[i] = max(inc[i], inc[j] + 1)\\n        # print(inc)\\n        for i in range(n-2, -1, -1):\\n            for j in range(n-1, i, -1):\\n                if nums[i] > nums[j]:\\n                    dec[i] = max(dec[i], dec[j] + 1)\\n        # print(dec)\\n        res = 0\\n        for i in range(n):\\n         # if any one side is 0 it means it\\'s strictly increasing (right side) or desceasing (left side) and these positions are not valid\\n            if inc[i] > 0 and dec[i] > 0:\\n                res = max(res, inc[i] + dec[i])\\n        \\n        return n - res - 1\\n\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 1166577,
                "title": "total-length-length-of-longest-bitonic-sequence",
                "content": "Caclculate the longest bitonic sequence in the array and subtract this from total length of array.\\n\\n\\n\\n```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        \\n        int n = nums.length;\\n        int[] LIS = new int[n];\\n        int[] LDS = new int[n];\\n    \\n        Arrays.fill(LIS, 1);\\n        Arrays.fill(LDS, 1);\\n        // calculate the longest increase subsequence (LIS) for every index i\\n        for(int i=1 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < i ; j++)\\n            {\\n                if(nums[i] > nums[j] && LIS[j]+1 > LIS[i])\\n                    LIS[i] = LIS[j]+1;\\n            }\\n        }\\n        \\n\\t\\t// calculate the longest decreasing subsequence(LDS) for every index i and keep track of the maximum of LIS+LDS\\n        int max = 0;\\n        for(int i=n-2 ; i >= 0 ; i--)\\n        {\\n            for(int j = n-1 ; j > i ; j--)\\n            {\\n                if(nums[i] > nums[j] && LDS[j]+1 > LDS[i])\\n                    LDS[i] = LDS[j]+1;\\n            }\\n            \\n            if(LIS[i] > 1 && LDS[i] > 1) \\n                max = Math.max(LIS[i]+LDS[i]-1, max);\\n        }\\n        return n - max;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        \\n        int n = nums.length;\\n        int[] LIS = new int[n];\\n        int[] LDS = new int[n];\\n    \\n        Arrays.fill(LIS, 1);\\n        Arrays.fill(LDS, 1);\\n        // calculate the longest increase subsequence (LIS) for every index i\\n        for(int i=1 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < i ; j++)\\n            {\\n                if(nums[i] > nums[j] && LIS[j]+1 > LIS[i])\\n                    LIS[i] = LIS[j]+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 955088,
                "title": "c-o-n-log-n",
                "content": "**Intuition**\\nWe need to determine the longest increasing subsequence (LIS) starting from the left and right sides of the array, and find a position `i` (a peak) that maximizes both. We can re-use the solution from [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/).\\n\\n**Solution**\\nLIS can be solved using DP, which is quadratic, or using a monotonically increasing stack. The latter is more efficient - linearithmic - but it\\'s a bit tricky. As we progress through the array, we replace numbers in the stack with smaller numbers, while maintaining the monotonically increasing sequence.\\n\\nExample: `[1,3,6,2,3,5,6]`\\n1. `[1,3,6]`(add 1, 3, and 6).\\n2. `[1,2,6]` (3 -> 2)\\n3. `[1,2,3]` (6 -> 3)\\n4. `[1,2,3,5,6]` (add 5 and 6).\\n\\nFor this problem, we build our stack `l` from the left. We need to store the size of LIS for each point (`dp[i]`).\\n\\nThen, we build another stack `r` from the right. Therefore, for each element `i`, we can find out the length of increasing (size of the left stack at `i`, which stored in `dp[i]`) and decreasing (right stack size) subsequences originating from `i`. The result is the maximum value for all potential peaks.\\n\\n> Note: for the mountain array to be valid, we need to only consider peaks where `dp[i] > 1` and `r.size() > 1`.\\n\\n**C++**\\n```cpp\\nint minimumMountainRemovals(vector<int>& n) {\\n    int res = INT_MAX, sz = n.size();\\n    vector<int> l, r, dp(sz);\\n    for (int i = 0; i < sz; ++i) {\\n        auto it = lower_bound(begin(l), end(l), n[i]);\\n        if (it == l.end())\\n            l.push_back(n[i]);\\n        else \\n            *it = n[i];\\n        dp[i] = l.size();\\n    }\\n    for (auto n : dp)\\n        cout << n << \" \";\\n    cout << endl;\\n    for (int i = n.size() - 1; i > 0; --i) {\\n        auto it = lower_bound(begin(r), end(r), n[i]);\\n        if (it == r.end())\\n            r.push_back(n[i]);\\n        else \\n            *it = n[i];\\n        if (dp[i] > 1 && r.size() > 1)\\n            res = min(res, sz - dp[i] - (int)r.size() + 1);\\n    }\\n    return res;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n log n)\\n- Memory: O(n)",
                "solutionTags": [],
                "code": "```cpp\\nint minimumMountainRemovals(vector<int>& n) {\\n    int res = INT_MAX, sz = n.size();\\n    vector<int> l, r, dp(sz);\\n    for (int i = 0; i < sz; ++i) {\\n        auto it = lower_bound(begin(l), end(l), n[i]);\\n        if (it == l.end())\\n            l.push_back(n[i]);\\n        else \\n            *it = n[i];\\n        dp[i] = l.size();\\n    }\\n    for (auto n : dp)\\n        cout << n << \" \";\\n    cout << endl;\\n    for (int i = n.size() - 1; i > 0; --i) {\\n        auto it = lower_bound(begin(r), end(r), n[i]);\\n        if (it == r.end())\\n            r.push_back(n[i]);\\n        else \\n            *it = n[i];\\n        if (dp[i] > 1 && r.size() > 1)\\n            res = min(res, sz - dp[i] - (int)r.size() + 1);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1718397,
                "title": "best-c-solution-easy-to-understand-explained-with-examples",
                "content": "This problem is a variation of Longest increasing subsequence. \\nIntuition :  If for each element ,we calculate the numbers which are in decreasing fashion from both left side and right side, we will be able to calculate one possible mountain. And, if we found all the possible mountains and choose the one with maximum length , then that will be our answer.\\nThe thing is if we have chosen the mountain with the maximum length, then that will eventually lead to less number of removals of other elements and hence our answer will be result.size()- maximum_length_of_mountain.\\n\\nLets understand this more in a detail to get clarity what i am saying :\\n Lets say our array is : \\n ```\\n                                              index no--->  0  1  2  3  4  5  6  7\\n                                                elements    2  1  1  5  6  2  3  1\\n\\t            now LIS from  left to right will be ---->   1  1  1  2  3  2  3  1    (Lets call it LIS_lefttoright)\\n\\t\\t\\t\\t   now LIS from righ to left will be ------>   2  1  1  3  3  2  2  1(lets call it LIS_righttoleft)\\nnow lets pick the index 3, LIS_lefttoright[3] is equals to 2. That is it says that heyy dude, \\nthe length of the longest increasing subseq to this element is 2 ( 2-->5 or 1--->5).\\nTake another index 4, LIS_lefttoright[4] is 3 which says that the length of the longest increasing \\nsubsequence is 3 (2-->5-->6 or 1-->5-->6).\\n\\nSimilarly in case of LIS right to left, if we see index 4, LIS_righttoleft[4]=3 which says that \\nlongest increasing subseq from right to upto this element is 3( 1-->2-->6).\\nNotice that we are counting the element 6 two times, so we have to remove this double counting in our calculation.\\nSo, now we are in a position to tell us the whole mountain length possible at index 4 which is :\\nmountain length at index 4 (element 6) is LIS_lefttoright[4]+LIS_righttoleft[4]-1 \\nwhy minus 1 coz we are counting 6 twice !!\\n\\nNow in a similar manner we will count the possible mountain length at each index and we will choose the maximum of it\\nand then we will subtract it from the total length and there you have it !!! you have your answer !!\\n\\nOne important note : if LIS_lefttoright or LIS_righttoleft value is 1, that means there is no element to its left or right\\nwhich is less than that element and that can not be your possible mountain and hence we will ignore those scenarios.\\nFor example in case of index 2 : we have LIS_lefttoright as 1 which says that there is nothing less than that element\\nto its left and hence it can not be included in the case of possible mountain.\\nSame case with LIS_righttoleft.\\n\\t\\n ```\\n \\n```\\nclass Solution {\\npublic:\\n    //since we are using LIS the time complexity is O(n2).\\n     vector<int> LISlefttoright(vector<int>&nums){\\n        vector<int>dp(nums.size(),1);\\n        for(int i =1;i<nums.size();i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j] && dp[i]<dp[j]+1){\\n                    dp[i]=dp[j]+1;\\n                    answer=max(answer,dp[i]);\\n                }\\n                    \\n            }\\n        }\\n        return dp;\\n    \\n    }\\n    vector<int> LISrighttoleft(vector<int>&nums){\\n       \\n        vector<int>dp(nums.size(),1);\\n        for(int i=nums.size()-2;i>=0;i--){\\n            for(int j=nums.size()-1;j>i;j--){\\n                if(nums[i]>nums[j] && dp[i]<dp[j]+1){\\n                    dp[i]=dp[j]+1;\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\n    int minimumMountainRemovals(vector<int>& nums) {\\n       vector<int>dp1=LISlefttoright(nums);\\n        vector<int>dp2=LISrighttoleft(nums);\\n        int result=-1;\\n        for(int i =0;i<nums.size();i++){\\n          \\n            if(dp1[i]==1 || dp2[i]==1) continue; \\n            //see dp1 says that longest increasing subseq from left to that element\\n            // and if the value is 1 that simply means there are no elements to its left\\n            //the same way with dp2 which says about the longest increasing subseq from right to left\\n            // and if the value is 1 that simply means there are no elements to its right \\n            // the value is 1 coz we are counting that particular element as well \\n            result=max(result,dp1[i]+dp2[i]-1);  //subtracting 1 to prevent double counting\\n        }\\n        return nums.size()-result;\\n    }\\n};\\n```\\n\\nLet me know if you have any doubts. I will be happy to discuss them !!\\nIf the solution helped , dont forget to upvote !! Thanks !!",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n                                              index no--->  0  1  2  3  4  5  6  7\\n                                                elements    2  1  1  5  6  2  3  1\\n\\t            now LIS from  left to right will be ---->   1  1  1  2  3  2  3  1    (Lets call it LIS_lefttoright)\\n\\t\\t\\t\\t   now LIS from righ to left will be ------>   2  1  1  3  3  2  2  1(lets call it LIS_righttoleft)\\nnow lets pick the index 3, LIS_lefttoright[3] is equals to 2. That is it says that heyy dude, \\nthe length of the longest increasing subseq to this element is 2 ( 2-->5 or 1--->5).\\nTake another index 4, LIS_lefttoright[4] is 3 which says that the length of the longest increasing \\nsubsequence is 3 (2-->5-->6 or 1-->5-->6).\\n\\nSimilarly in case of LIS right to left, if we see index 4, LIS_righttoleft[4]=3 which says that \\nlongest increasing subseq from right to upto this element is 3( 1-->2-->6).\\nNotice that we are counting the element 6 two times, so we have to remove this double counting in our calculation.\\nSo, now we are in a position to tell us the whole mountain length possible at index 4 which is :\\nmountain length at index 4 (element 6) is LIS_lefttoright[4]+LIS_righttoleft[4]-1 \\nwhy minus 1 coz we are counting 6 twice !!\\n\\nNow in a similar manner we will count the possible mountain length at each index and we will choose the maximum of it\\nand then we will subtract it from the total length and there you have it !!! you have your answer !!\\n\\nOne important note : if LIS_lefttoright or LIS_righttoleft value is 1, that means there is no element to its left or right\\nwhich is less than that element and that can not be your possible mountain and hence we will ignore those scenarios.\\nFor example in case of index 2 : we have LIS_lefttoright as 1 which says that there is nothing less than that element\\nto its left and hence it can not be included in the case of possible mountain.\\nSame case with LIS_righttoleft.\\n\\t\\n ```\n```\\nclass Solution {\\npublic:\\n    //since we are using LIS the time complexity is O(n2).\\n     vector<int> LISlefttoright(vector<int>&nums){\\n        vector<int>dp(nums.size(),1);\\n        for(int i =1;i<nums.size();i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j] && dp[i]<dp[j]+1){\\n                    dp[i]=dp[j]+1;\\n                    answer=max(answer,dp[i]);\\n                }\\n                    \\n            }\\n        }\\n        return dp;\\n    \\n    }\\n    vector<int> LISrighttoleft(vector<int>&nums){\\n       \\n        vector<int>dp(nums.size(),1);\\n        for(int i=nums.size()-2;i>=0;i--){\\n            for(int j=nums.size()-1;j>i;j--){\\n                if(nums[i]>nums[j] && dp[i]<dp[j]+1){\\n                    dp[i]=dp[j]+1;\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\n    int minimumMountainRemovals(vector<int>& nums) {\\n       vector<int>dp1=LISlefttoright(nums);\\n        vector<int>dp2=LISrighttoleft(nums);\\n        int result=-1;\\n        for(int i =0;i<nums.size();i++){\\n          \\n            if(dp1[i]==1 || dp2[i]==1) continue; \\n            //see dp1 says that longest increasing subseq from left to that element\\n            // and if the value is 1 that simply means there are no elements to its left\\n            //the same way with dp2 which says about the longest increasing subseq from right to left\\n            // and if the value is 1 that simply means there are no elements to its right \\n            // the value is 1 coz we are counting that particular element as well \\n            result=max(result,dp1[i]+dp2[i]-1);  //subtracting 1 to prevent double counting\\n        }\\n        return nums.size()-result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952166,
                "title": "c-o-nlogn-dp-lis-easy",
                "content": "We observe that a Mountain array consists of 2 increasing array. \\nFirst one from left to a midpoint.\\nSecond one from rightmost to midpoint.\\nSo to calculate the minimum number of removals to make a mountain array , \\nwe can find the minimum number of removals to make an increasing array twice , for both increasing arrays and sum up the answer.\\nTo find the minimum number of removals to make an array increasing , \\nwe can find the length of the longest increasing subsequence and then subtract it from the length of sequence.\\nLongest increasing subsequence is a well known problem and can be solved in nlogn using Multiset.\\nLink to LIS problem : [Length of Longest increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)\\n\\nCode:\\n```\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumMountainRemovals(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tmultiset<int> lis;\\n\\t\\t\\tvector<int> dp1(n),dp2(n);\\n\\t\\t\\tfor(int i = 0; i < nums.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(lis.empty())lis.insert(nums[i]);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tauto it = lis.lower_bound(nums[i]);\\n\\t\\t\\t\\t\\tif(it != lis.end())lis.erase(it);\\n\\t\\t\\t\\t\\tlis.insert(nums[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp1[i] = i + 1 - lis.size();\\n\\t\\t\\t}\\n\\n\\t\\t\\tlis.clear();\\n\\t\\t\\tfor(int i = nums.size()-1; i >=0; i--)\\n\\t\\t\\t{\\n\\n\\t\\t\\t\\tif(lis.empty())lis.insert(nums[i]);     \\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tauto it = lis.lower_bound(nums[i]);\\n\\t\\t\\t\\t\\tif(it != lis.end())lis.erase(it);  \\n\\t\\t\\t\\t\\tlis.insert(nums[i]);\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tdp2[i] = nums.size()-i-lis.size();\\n\\t\\t\\t}\\n\\n\\t\\t\\tint ans = n;\\n\\n\\t\\t\\tfor(int i = 1; i < nums.size()-1; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans = min(ans,dp1[i] + dp2[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumMountainRemovals(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tmultiset<int> lis;\\n\\t\\t\\tvector<int> dp1(n),dp2(n);\\n\\t\\t\\tfor(int i = 0; i < nums.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(lis.empty())lis.insert(nums[i]);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tauto it = lis.lower_bound(nums[i]);\\n\\t\\t\\t\\t\\tif(it != lis.end())lis.erase(it);\\n\\t\\t\\t\\t\\tlis.insert(nums[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp1[i] = i + 1 - lis.size();\\n\\t\\t\\t}\\n\\n\\t\\t\\tlis.clear();\\n\\t\\t\\tfor(int i = nums.size()-1; i >=0; i--)\\n\\t\\t\\t{\\n\\n\\t\\t\\t\\tif(lis.empty())lis.insert(nums[i]);     \\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tauto it = lis.lower_bound(nums[i]);\\n\\t\\t\\t\\t\\tif(it != lis.end())lis.erase(it);  \\n\\t\\t\\t\\t\\tlis.insert(nums[i]);\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tdp2[i] = nums.size()-i-lis.size();\\n\\t\\t\\t}\\n\\n\\t\\t\\tint ans = n;\\n\\n\\t\\t\\tfor(int i = 1; i < nums.size()-1; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans = min(ans,dp1[i] + dp2[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952136,
                "title": "python-lis-o-nlogn",
                "content": "# Intuition\\nLongest increasing sequence\\n<br>\\n\\n# Explanation\\nPick A[1],A[2],..,A[n-2] as the peak value,\\nfind on the longest increasing sequence on its left and on its right.\\nThe maximum mountain = left + right - 1\\n<br>\\n\\n# Solution 1, brute force this ides\\n**Python:**\\nTime O(n^2logn), Space O(n)\\n```py\\n    def minimumMountainRemovals(self, A):\\n        n = len(A)\\n\\n        def longest(A):\\n            mono = [10**9] * n\\n            for a in A:\\n                i = bisect.bisect_left(mono, a)\\n                mono[i] = a\\n            return i if i else -n\\n        return n - max(longest(A[:i + 1]) + longest(A[:i - 1:-1]) + 1 for i in xrange(1, n - 1))\\n```\\n<br>\\n\\n# Solution 2, two passes\\n**Python**\\nTime O(nlogn), Space O(n)\\n```py\\n    def minimumMountainRemovals(self, A):\\n        n = len(A)\\n        dp = [0] * n\\n        mono = [10**9] * n\\n        for i in xrange(n):\\n            j = bisect.bisect_left(mono, A[i])\\n            mono[j] = A[i]\\n            dp[i] += j + 1 if j else -n\\n        mono = [10**9] * n\\n        for i in xrange(n - 1, -1, -1):\\n            j = bisect.bisect_left(mono, A[i])\\n            mono[j] = A[i]\\n            dp[i] += j if j else -n\\n        return n - max(dp[1:-1])\\n```",
                "solutionTags": [],
                "code": "```py\\n    def minimumMountainRemovals(self, A):\\n        n = len(A)\\n\\n        def longest(A):\\n            mono = [10**9] * n\\n            for a in A:\\n                i = bisect.bisect_left(mono, a)\\n                mono[i] = a\\n            return i if i else -n\\n        return n - max(longest(A[:i + 1]) + longest(A[:i - 1:-1]) + 1 for i in xrange(1, n - 1))\\n```\n```py\\n    def minimumMountainRemovals(self, A):\\n        n = len(A)\\n        dp = [0] * n\\n        mono = [10**9] * n\\n        for i in xrange(n):\\n            j = bisect.bisect_left(mono, A[i])\\n            mono[j] = A[i]\\n            dp[i] += j + 1 if j else -n\\n        mono = [10**9] * n\\n        for i in xrange(n - 1, -1, -1):\\n            j = bisect.bisect_left(mono, A[i])\\n            mono[j] = A[i]\\n            dp[i] += j if j else -n\\n        return n - max(dp[1:-1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 952335,
                "title": "fixed-this-question-is-missing-some-corner-cases",
                "content": "Found some of the solutions can\\'t pass the test case:\\n```\\n[10, 9, 8, 7, 6, 5, 4, 5, 4]\\n```\\nthe correct answer is 6.\\nThe solutions need to check the LIS\\'s length > 1.",
                "solutionTags": [],
                "code": "```\\n[10, 9, 8, 7, 6, 5, 4, 5, 4]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2580443,
                "title": "simple-easy-java-solution-dp",
                "content": "Hi Family,\\n\\nI put the solution with proper comment\\nPlease upvote it, if you liked\\n\\n```\\n\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n = nums.length;\\n        \\n        // memoization for forward direction\\n        int[] dp1 = new int[n];\\n        Arrays.fill(dp1,1);\\n        \\n        // memoizationfor backward direction\\n        int[] dp2 = new int[n];\\n        Arrays.fill(dp2,1);\\n        \\n        //find the Longest increasing subsequence in Forward Direction\\n        for (int cur=1;cur<n;cur++){\\n            for (int prev=0;prev<cur;prev++){\\n                if (nums[prev] < nums[cur] && (1 + dp1[prev] > dp1[cur])){\\n                    dp1[cur] = 1 + dp1[prev];\\n                }\\n            }\\n        }\\n        \\n        // find the longest increasing subsequence in backward direction\\n        for (int cur=n-1;cur>=0;cur--){\\n            for (int prev=n-1;prev>cur;prev--){\\n                if (nums[prev] < nums[cur] && (1 + dp2[prev] > dp2[cur])){\\n                    dp2[cur] = 1 + dp2[prev]; \\n                }\\n            }\\n        }\\n        // find the max no. of element which is included for making the mountain\\n        \\n        int maxi = 0;\\n        for (int i=0;i<n;i++){\\n            if(dp1[i] > 1 && dp2[i] > 1) // if this ith elemenet is single then dont consider in the longest bitonic subsequence\\n            maxi = Math.max(maxi,dp1[i]+dp2[i]-1);\\n        }\\n        \\n        return n - maxi;\\n        \\n    }\\n}\\n```\\n\\nThanks",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n = nums.length;\\n        \\n        // memoization for forward direction\\n        int[] dp1 = new int[n];\\n        Arrays.fill(dp1,1);\\n        \\n        // memoizationfor backward direction\\n        int[] dp2 = new int[n];\\n        Arrays.fill(dp2,1);\\n        \\n        //find the Longest increasing subsequence in Forward Direction\\n        for (int cur=1;cur<n;cur++){\\n            for (int prev=0;prev<cur;prev++){\\n                if (nums[prev] < nums[cur] && (1 + dp1[prev] > dp1[cur])){\\n                    dp1[cur] = 1 + dp1[prev];\\n                }\\n            }\\n        }\\n        \\n        // find the longest increasing subsequence in backward direction\\n        for (int cur=n-1;cur>=0;cur--){\\n            for (int prev=n-1;prev>cur;prev--){\\n                if (nums[prev] < nums[cur] && (1 + dp2[prev] > dp2[cur])){\\n                    dp2[cur] = 1 + dp2[prev]; \\n                }\\n            }\\n        }\\n        // find the max no. of element which is included for making the mountain\\n        \\n        int maxi = 0;\\n        for (int i=0;i<n;i++){\\n            if(dp1[i] > 1 && dp2[i] > 1) // if this ith elemenet is single then dont consider in the longest bitonic subsequence\\n            maxi = Math.max(maxi,dp1[i]+dp2[i]-1);\\n        }\\n        \\n        return n - maxi;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427909,
                "title": "python-solution-using-lis-longest-increasing-subsequence-concept",
                "content": "The code can be made shorter by combining both inc and dec, but it decreases readibility of the code.\\n```\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        inc = [0] * n\\n        dec = [0] * n\\n        \\n#  Longest Increasing Subsequence\\n        for i in range(1,n):\\n            for j in range(0,i):\\n                if nums[i] > nums[j]:\\n                    inc[i] = max(inc[i], inc[j] + 1)\\n                \\n#  Longest Decreasing Subsequence\\n        for i in range(n-2,-1,-1):\\n            for j in range(n-1,i,-1):\\n                if nums[i] > nums[j]:\\n                    dec[i] = max(dec[i], dec[j] + 1)\\n        \\n# Final calculation\\n        res = 0\\n        for i in range(0,n):\\n            if inc[i] > 0 and dec[i] > 0:\\n                res = max(res, inc[i] + dec[i])\\n                \\n# Final conclusion        \\n        return n - res - 1\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        inc = [0] * n\\n        dec = [0] * n\\n        \\n#  Longest Increasing Subsequence\\n        for i in range(1,n):\\n            for j in range(0,i):\\n                if nums[i] > nums[j]:\\n                    inc[i] = max(inc[i], inc[j] + 1)\\n                \\n#  Longest Decreasing Subsequence\\n        for i in range(n-2,-1,-1):\\n            for j in range(n-1,i,-1):\\n                if nums[i] > nums[j]:\\n                    dec[i] = max(dec[i], dec[j] + 1)\\n        \\n# Final calculation\\n        res = 0\\n        for i in range(0,n):\\n            if inc[i] > 0 and dec[i] > 0:\\n                res = max(res, inc[i] + dec[i])\\n                \\n# Final conclusion        \\n        return n - res - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951981,
                "title": "c-easy-o-n-2-solution-using-lis-twice",
                "content": "The basic idea of this problem is that the minimum number of removals to make a mountain array is equal to nums-(longest mountain subsequence). We can calculate the longest mountain subsequence by first calculating the LIS from the left and the right and storing the answers in dpleft and dpright. Then consider each 0<i<n to be the middle of a mountain subsequence only if dpleft[i]>1 and dpright[i]>1 the length of this mountain subsequence is dpleft[i]+dright[i]-1 (we subtract 1 to not double count the middle element)\\n\\n```\\nint minimumMountainRemovals(vector<int>& nums) {\\n    vector<int> dpleft(nums.size(), 1);\\n    vector<int> dpright(nums.size(), 1);\\n    for(int i=1; i<nums.size(); i++) {\\n        for(int j=0; j<i; j++) {\\n            if(nums[i]>nums[j]) {\\n                dpleft[i] = max(dpleft[i], dpleft[j]+1);\\n            }\\n        }\\n    }\\n    //coming from right\\n    for(int i=nums.size()-2; i>=0; i--) {\\n        for(int j=nums.size()-1; j>i; j--) {\\n            if(nums[i]>nums[j]) {\\n                dpright[i] = max(dpright[i], dpright[j]+1);\\n            }\\n        }\\n    }\\n    //calculate the longest\\n    int longest = 0;\\n    //conside i the middle\\n    for(int i=1; i<nums.size()-1; i++) {\\n        if(dpleft[i]>1 && dpright[i]>1) {\\n            int ans = dpleft[i]+dpright[i]-1;\\n            longest = max(longest, ans);\\n        }\\n    }\\n    return nums.size()-longest;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint minimumMountainRemovals(vector<int>& nums) {\\n    vector<int> dpleft(nums.size(), 1);\\n    vector<int> dpright(nums.size(), 1);\\n    for(int i=1; i<nums.size(); i++) {\\n        for(int j=0; j<i; j++) {\\n            if(nums[i]>nums[j]) {\\n                dpleft[i] = max(dpleft[i], dpleft[j]+1);\\n            }\\n        }\\n    }\\n    //coming from right\\n    for(int i=nums.size()-2; i>=0; i--) {\\n        for(int j=nums.size()-1; j>i; j--) {\\n            if(nums[i]>nums[j]) {\\n                dpright[i] = max(dpright[i], dpright[j]+1);\\n            }\\n        }\\n    }\\n    //calculate the longest\\n    int longest = 0;\\n    //conside i the middle\\n    for(int i=1; i<nums.size()-1; i++) {\\n        if(dpleft[i]>1 && dpright[i]>1) {\\n            int ans = dpleft[i]+dpright[i]-1;\\n            longest = max(longest, ans);\\n        }\\n    }\\n    return nums.size()-longest;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1221463,
                "title": "c-solution-using-longest-increasing-subsequence-concept-twice",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> m1(n,1),m2(n,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[j]<nums[i])\\n                    m1[i]=max(m1[i],m1[j]+1);\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=n-1;j>i;j--)\\n            {\\n                if(nums[j]<nums[i])\\n                    m2[i]=max(m2[i],m2[j]+1);\\n            }\\n        }\\n        int res=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n          if(m1[i]==1||m2[i]==1)\\n              continue;\\n          res=max(res,m1[i]+m2[i]-1);   \\n        }\\n        return(n-res);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> m1(n,1),m2(n,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[j]<nums[i])\\n                    m1[i]=max(m1[i],m1[j]+1);\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=n-1;j>i;j--)\\n            {\\n                if(nums[j]<nums[i])\\n                    m2[i]=max(m2[i],m2[j]+1);\\n            }\\n        }\\n        int res=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n          if(m1[i]==1||m2[i]==1)\\n              continue;\\n          res=max(res,m1[i]+m2[i]-1);   \\n        }\\n        return(n-res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734682,
                "title": "lis-variation-beats-85-java-with-comments",
                "content": "Please Dry run it once for Better Understanding (::\\n```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n = nums.length;\\n\\t\\t//step:1 find the longest increasing subsequences till i\\n        int[] lis = new int[n];\\n        \\n        for (int i = 0; i < n; i++){\\n            int max = 1;\\n            for (int j = 0;j <i; j++){\\n                if (nums[j] < nums[i]){\\n                    max = Math.max(max, lis[j] + 1);\\n                }\\n            }\\n             lis[i] = max;\\n        }\\n        \\n\\t\\t//step : 2 find longest decreasing subsequence starting from i\\n        int[] lds = new int[n];\\n        for (int i = n-1; i >= 0; i--){\\n            int max = 1;\\n            for (int j = i+1; j < n; j++){\\n                if (nums[i] > nums[j]){\\n                    max = Math.max(max, lds[j]+ 1);\\n                }\\n            }\\n            lds[i] = max;\\n        }\\n        \\n\\t\\t/*step 3: now find longest bitonic subsequence \\n\\t\\tbut ensure that there something on the left and right of a particular index i \\n\\t\\tinorder to make it a mountain  which means lis[i] > 1 and lds[i] > 1\\n\\t\\t*/\\n        int lbs = 0;\\n        for (int i = 0; i < n; i++){\\n            if (lis[i] > 1 && lds[i] > 1)\\n            lbs = Math.max(lis[i] + lds[i]-1, lbs);\\n        }\\n\\t\\t//step 4: min remove is size of the original array - the length of the longest bitonic              subsequence found\\n        return n - lbs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n = nums.length;\\n\\t\\t//step:1 find the longest increasing subsequences till i\\n        int[] lis = new int[n];\\n        \\n        for (int i = 0; i < n; i++){\\n            int max = 1;\\n            for (int j = 0;j <i; j++){\\n                if (nums[j] < nums[i]){\\n                    max = Math.max(max, lis[j] + 1);\\n                }\\n            }\\n             lis[i] = max;\\n        }\\n        \\n\\t\\t//step : 2 find longest decreasing subsequence starting from i\\n        int[] lds = new int[n];\\n        for (int i = n-1; i >= 0; i--){\\n            int max = 1;\\n            for (int j = i+1; j < n; j++){\\n                if (nums[i] > nums[j]){\\n                    max = Math.max(max, lds[j]+ 1);\\n                }\\n            }\\n            lds[i] = max;\\n        }\\n        \\n\\t\\t/*step 3: now find longest bitonic subsequence \\n\\t\\tbut ensure that there something on the left and right of a particular index i \\n\\t\\tinorder to make it a mountain  which means lis[i] > 1 and lds[i] > 1\\n\\t\\t*/\\n        int lbs = 0;\\n        for (int i = 0; i < n; i++){\\n            if (lis[i] > 1 && lds[i] > 1)\\n            lbs = Math.max(lis[i] + lds[i]-1, lbs);\\n        }\\n\\t\\t//step 4: min remove is size of the original array - the length of the longest bitonic              subsequence found\\n        return n - lbs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956129,
                "title": "java-easy-dp-o-n-2-solution-longest-bitonic-subsequence",
                "content": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n = nums.length;\\n\\t\\t//step:1 find the longest increasing subsequences till i\\n        int[] lis = new int[n];\\n        \\n        for (int i = 0; i < n; i++){\\n            int max = 1;\\n            for (int j = i-1;j >= 0; j--){\\n                if (nums[j] < nums[i]){\\n                    max = Math.max(max, lis[j] + 1);\\n                }\\n            }\\n             lis[i] = max;\\n        }\\n        \\n\\t\\t//step : 2 find longest decreasing subsequence starting from i\\n        int[] lds = new int[n];\\n        for (int i = n-1; i >= 0; i--){\\n            int max = 1;\\n            for (int j = i+1; j < n; j++){\\n                if (nums[i] > nums[j]){\\n                    max = Math.max(max, lds[j]+ 1);\\n                }\\n            }\\n            lds[i] = max;\\n        }\\n        \\n\\t\\t/*step 3: now find longest bitonic subsequence \\n\\t\\tbut ensure that there something on the left and right of a particular index i \\n\\t\\tinorder to make it a mountain  which means lis[i] > 1 and lds[i] > 1\\n\\t\\t*/\\n        int lbs = 0;\\n        for (int i = 0; i < n; i++){\\n            if (lis[i] > 1 && lds[i] > 1)\\n            lbs = Math.max(lis[i] + lds[i]-1, lbs);\\n        }\\n\\t\\t//step 4: min remove is size of the original array - the length of the longest bitonic subsequence found\\n        return n - lbs;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n = nums.length;\\n\\t\\t//step:1 find the longest increasing subsequences till i\\n        int[] lis = new int[n];\\n        \\n        for (int i = 0; i < n; i++){\\n            int max = 1;\\n            for (int j = i-1;j >= 0; j--){\\n                if (nums[j] < nums[i]){\\n                    max = Math.max(max, lis[j] + 1);\\n                }\\n            }\\n             lis[i] = max;\\n        }\\n        \\n\\t\\t//step : 2 find longest decreasing subsequence starting from i\\n        int[] lds = new int[n];\\n        for (int i = n-1; i >= 0; i--){\\n            int max = 1;\\n            for (int j = i+1; j < n; j++){\\n                if (nums[i] > nums[j]){\\n                    max = Math.max(max, lds[j]+ 1);\\n                }\\n            }\\n            lds[i] = max;\\n        }\\n        \\n\\t\\t/*step 3: now find longest bitonic subsequence \\n\\t\\tbut ensure that there something on the left and right of a particular index i \\n\\t\\tinorder to make it a mountain  which means lis[i] > 1 and lds[i] > 1\\n\\t\\t*/\\n        int lbs = 0;\\n        for (int i = 0; i < n; i++){\\n            if (lis[i] > 1 && lds[i] > 1)\\n            lbs = Math.max(lis[i] + lds[i]-1, lbs);\\n        }\\n\\t\\t//step 4: min remove is size of the original array - the length of the longest bitonic subsequence found\\n        return n - lbs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2133773,
                "title": "clean-c-code-lis-from-2-sides-comments-and-explanation-beginner-friendly",
                "content": "**Table of content :**\\n1. Full detailed c++ code with comments and explanation\\n2. Concise short c++ code\\n\\ne.g  `[2, 1, 5, 6, 3, 1]`  \\nLIS length from left to right = 3 `(1-->5-->6)`\\nLIS length from right to left = 3 `(6-->3-->1)`\\nans = total sequence length - (LIS LToR + LIS RToL - 1(peak value counted twice so subtract it once)) \\nans = 6 - (3 + 3 - 1) = 1\\n\\n**Time complexity** : `O(nlogn)`\\n**Space complexity** : `O(n)`\\n\\n**C++ code with comments and explanation**\\n```\\nclass Solution {\\npublic:\\n    \\n    // problem is variation of LIS\\n    int minimumMountainRemovals(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<int> inc(n), dec(n), v;\\n        \\n        // inc(n) -> it is used to store the size of increasing subsequence from \"left to right\" \\n        // dec(n) -> it is used to store the size of increasing subsequences from \"right to left\", not confuse \\n        // with the variable name\\n        \\n        // LIS from left to right\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(v.empty() or nums[i] > v.back())\\n            {\\n                v.push_back(nums[i]);\\n                inc[i] = v.size();  // Whole code is similar to LIS problem only this new line is used for storage \\n            }                       // of LIS size at every index\\n            else\\n            {\\n                // find the smallest number which is >= nums[i] using Binary Search\\n                int lo = 0, hi = v.size() - 1;\\n                while(lo<=hi)\\n                {\\n                    int mid = lo + (hi-lo)/2;\\n                    if(v[mid] >= nums[i]){\\n                        hi = mid - 1;\\n                    }\\n                    else\\n                        lo = mid + 1;\\n                }\\n                \\n                inc[i] = lo+1;\\n                v[lo] = nums[i];\\n            }\\n        }\\n        \\n        \\n        v.clear();\\n        \\n        // LIS from right to left\\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            if(v.empty() or nums[i] > v.back())\\n            {\\n                v.push_back(nums[i]);\\n                dec[i] = v.size();   // Whole code is similar to LIS problem only this new line is used for storage \\n            }                        // of LIS size at every index\\n            else\\n            {\\n                // find the smallest number which is >= nums[i] using Binary Search\\n                int lo = 0, hi = v.size() - 1;\\n                while(lo<=hi)\\n                {\\n                    int mid = lo + (hi-lo)/2;\\n                    if(v[mid] >= nums[i]){\\n                        hi = mid - 1;\\n                    }\\n                    else\\n                        lo = mid + 1;\\n                }\\n                \\n                dec[i] = lo + 1;\\n                v[lo] = nums[i];\\n            }\\n        }\\n        \\n        // find longest increasing subsequence so that we will get minimum number of removals \\n        // after subtraction from \"total sequence length\" \\n        int mx = 0;\\n        \\n        for(int i=1; i<nums.size()-1; i++) \\n        {\\n       \\n        /* e.g [2, 1, 5, 6, 3, 1]  \\n           LIS length from left to right = 3 (1-->5-->6)\\n           LIS length from right to left = 3 (6-->3-->1)\\n           ans = total sequence length - (LIS LToR + LIS RToL - 1(peak value counted twice so subtract it once)) \\n           ans = 6 - (3 + 3 - 1) = 1\\n        */\\n            \\n            // minimum length of subsequence is 2 because it is guaranteed that you can make a \\n            // mountain array out of nums.\\n            if(inc[i]>1 and dec[i]>1) \\n            {\\n                int ans = inc[i]+dec[i]-1;\\n                mx = max(mx, ans);\\n            }\\n        }\\n        return nums.size() - mx;\\n    }\\n};\\n```\\n\\n**Concise c++ code**\\n```\\nclass Solution {\\npublic:\\n   \\n    int lower_bound(vector<int>&v, int x)\\n\\t{\\n\\t\\tint lo = 0, hi = v.size() - 1;\\n\\t\\twhile(lo<=hi)\\n\\t\\t{\\n\\t\\t\\tint mid = lo + (hi-lo)/2;\\n\\t\\t\\tif(v[mid] >= x){\\n\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t}\\n\\t\\treturn lo;\\n\\t}\\n\\t\\n    int minimumMountainRemovals(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<int> inc(n), dec(n), v;\\n\\t\\t\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(v.empty() or nums[i] > v.back())\\n            {\\n                v.push_back(nums[i]);\\n                inc[i] = v.size();  \\n            }                       \\n            else\\n            {\\n                // find the index of smallest number which is >= nums[i] using Binary Search\\n                int index = lower_bound(v, nums[i]);\\n                \\n                inc[i] = index+1;\\n                v[index] = nums[i];\\n            }\\n        }\\n        \\n        \\n        v.clear();\\n       \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            if(v.empty() or nums[i] > v.back())\\n            {\\n                v.push_back(nums[i]);\\n                dec[i] = v.size();   \\n            }                        \\n            else\\n            {\\n                // find the smallest number which is >= nums[i] using Binary Search\\n                int index = lower_bound(v, nums[i]);\\n                \\n                dec[i] = index + 1;\\n                v[index] = nums[i];\\n            }\\n        }\\n\\n        int mx = 0;\\n        for(int i=1; i<nums.size()-1; i++) \\n        {\\n            if(inc[i]>1 and dec[i]>1) \\n            {\\n                int ans = inc[i]+dec[i]-1;\\n                mx = max(mx, ans);\\n            }\\n        }\\n        return nums.size() - mx;\\n    }\\n};\\n```\\n*Happy coding !*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // problem is variation of LIS\\n    int minimumMountainRemovals(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<int> inc(n), dec(n), v;\\n        \\n        // inc(n) -> it is used to store the size of increasing subsequence from \"left to right\" \\n        // dec(n) -> it is used to store the size of increasing subsequences from \"right to left\", not confuse \\n        // with the variable name\\n        \\n        // LIS from left to right\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(v.empty() or nums[i] > v.back())\\n            {\\n                v.push_back(nums[i]);\\n                inc[i] = v.size();  // Whole code is similar to LIS problem only this new line is used for storage \\n            }                       // of LIS size at every index\\n            else\\n            {\\n                // find the smallest number which is >= nums[i] using Binary Search\\n                int lo = 0, hi = v.size() - 1;\\n                while(lo<=hi)\\n                {\\n                    int mid = lo + (hi-lo)/2;\\n                    if(v[mid] >= nums[i]){\\n                        hi = mid - 1;\\n                    }\\n                    else\\n                        lo = mid + 1;\\n                }\\n                \\n                inc[i] = lo+1;\\n                v[lo] = nums[i];\\n            }\\n        }\\n        \\n        \\n        v.clear();\\n        \\n        // LIS from right to left\\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            if(v.empty() or nums[i] > v.back())\\n            {\\n                v.push_back(nums[i]);\\n                dec[i] = v.size();   // Whole code is similar to LIS problem only this new line is used for storage \\n            }                        // of LIS size at every index\\n            else\\n            {\\n                // find the smallest number which is >= nums[i] using Binary Search\\n                int lo = 0, hi = v.size() - 1;\\n                while(lo<=hi)\\n                {\\n                    int mid = lo + (hi-lo)/2;\\n                    if(v[mid] >= nums[i]){\\n                        hi = mid - 1;\\n                    }\\n                    else\\n                        lo = mid + 1;\\n                }\\n                \\n                dec[i] = lo + 1;\\n                v[lo] = nums[i];\\n            }\\n        }\\n        \\n        // find longest increasing subsequence so that we will get minimum number of removals \\n        // after subtraction from \"total sequence length\" \\n        int mx = 0;\\n        \\n        for(int i=1; i<nums.size()-1; i++) \\n        {\\n       \\n        /* e.g [2, 1, 5, 6, 3, 1]  \\n           LIS length from left to right = 3 (1-->5-->6)\\n           LIS length from right to left = 3 (6-->3-->1)\\n           ans = total sequence length - (LIS LToR + LIS RToL - 1(peak value counted twice so subtract it once)) \\n           ans = 6 - (3 + 3 - 1) = 1\\n        */\\n            \\n            // minimum length of subsequence is 2 because it is guaranteed that you can make a \\n            // mountain array out of nums.\\n            if(inc[i]>1 and dec[i]>1) \\n            {\\n                int ans = inc[i]+dec[i]-1;\\n                mx = max(mx, ans);\\n            }\\n        }\\n        return nums.size() - mx;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n   \\n    int lower_bound(vector<int>&v, int x)\\n\\t{\\n\\t\\tint lo = 0, hi = v.size() - 1;\\n\\t\\twhile(lo<=hi)\\n\\t\\t{\\n\\t\\t\\tint mid = lo + (hi-lo)/2;\\n\\t\\t\\tif(v[mid] >= x){\\n\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t}\\n\\t\\treturn lo;\\n\\t}\\n\\t\\n    int minimumMountainRemovals(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<int> inc(n), dec(n), v;\\n\\t\\t\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(v.empty() or nums[i] > v.back())\\n            {\\n                v.push_back(nums[i]);\\n                inc[i] = v.size();  \\n            }                       \\n            else\\n            {\\n                // find the index of smallest number which is >= nums[i] using Binary Search\\n                int index = lower_bound(v, nums[i]);\\n                \\n                inc[i] = index+1;\\n                v[index] = nums[i];\\n            }\\n        }\\n        \\n        \\n        v.clear();\\n       \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            if(v.empty() or nums[i] > v.back())\\n            {\\n                v.push_back(nums[i]);\\n                dec[i] = v.size();   \\n            }                        \\n            else\\n            {\\n                // find the smallest number which is >= nums[i] using Binary Search\\n                int index = lower_bound(v, nums[i]);\\n                \\n                dec[i] = index + 1;\\n                v[index] = nums[i];\\n            }\\n        }\\n\\n        int mx = 0;\\n        for(int i=1; i<nums.size()-1; i++) \\n        {\\n            if(inc[i]>1 and dec[i]>1) \\n            {\\n                int ans = inc[i]+dec[i]-1;\\n                mx = max(mx, ans);\\n            }\\n        }\\n        return nums.size() - mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813827,
                "title": "beats-98-c-love-babbar-s-o-nlogn-optimized-approach-with-explaination",
                "content": "# Explaination\\nFirst We use DP1 vector to calculate LIS at evry index.\\nThen We Calculate LDS for every index and store in DP2 vector.\\n\\nNow we will take maximum of sum of LDS and LIS and every index.\\n\\n**NOTE: LDS[i] and LIS[i] both greater than 1.**\\nbecause length of the mountain must be greater than 3 and also only value will not be considered as LIS and LDS, we need atleast 2 elements. \\n\\n# Complexity\\n- Time complexity: O(NlogN), traversing nums array and using lower bound.\\n\\n- Space complexity: O(N), using dp vectors.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int LIS(vector<int>&nums,vector<int>&dp1){\\n        int n=nums.size();\\n        vector<int> store;\\n        store.push_back(nums[0]);\\n        for(int i=1;i<n;i++){\\n            if(nums[i]> store.back()) store.push_back(nums[i]);\\n            else{\\n                int lb= lower_bound(store.begin(),store.end(),nums[i]) -store.begin();\\n                store[lb]=nums[i];\\n            }\\n            dp1[i]= store.size();\\n        }\\n        int ans=store.size();\\n        return ans;\\n    }\\n\\n    int LDS(vector<int>&nums,vector<int>&dp2){\\n        int n=nums.size();\\n        vector<int> store;\\n        store.push_back(nums[n-1]);\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]> store.back()) store.push_back(nums[i]);\\n            else{\\n                int lb= lower_bound(store.begin(),store.end(),nums[i]) -store.begin();\\n                store[lb]=nums[i];\\n            }\\n            dp2[i]= store.size();\\n        }\\n        int ans=store.size();\\n        return ans;\\n    }\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp1(n,0);\\n        int lis= LIS(nums,dp1);\\n\\n        vector<int> dp2(n,0);\\n        int lds= LDS(nums,dp2);\\n\\n        int maxi=-1;\\n        for(int i=0;i<n;i++){\\n            if(dp1[i]>1 && dp2[i]>1){\\n                maxi=max(maxi,dp1[i]+dp2[i]);\\n            }\\n        }\\n        return n-maxi+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int LIS(vector<int>&nums,vector<int>&dp1){\\n        int n=nums.size();\\n        vector<int> store;\\n        store.push_back(nums[0]);\\n        for(int i=1;i<n;i++){\\n            if(nums[i]> store.back()) store.push_back(nums[i]);\\n            else{\\n                int lb= lower_bound(store.begin(),store.end(),nums[i]) -store.begin();\\n                store[lb]=nums[i];\\n            }\\n            dp1[i]= store.size();\\n        }\\n        int ans=store.size();\\n        return ans;\\n    }\\n\\n    int LDS(vector<int>&nums,vector<int>&dp2){\\n        int n=nums.size();\\n        vector<int> store;\\n        store.push_back(nums[n-1]);\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]> store.back()) store.push_back(nums[i]);\\n            else{\\n                int lb= lower_bound(store.begin(),store.end(),nums[i]) -store.begin();\\n                store[lb]=nums[i];\\n            }\\n            dp2[i]= store.size();\\n        }\\n        int ans=store.size();\\n        return ans;\\n    }\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp1(n,0);\\n        int lis= LIS(nums,dp1);\\n\\n        vector<int> dp2(n,0);\\n        int lds= LDS(nums,dp2);\\n\\n        int maxi=-1;\\n        for(int i=0;i<n;i++){\\n            if(dp1[i]>1 && dp2[i]>1){\\n                maxi=max(maxi,dp1[i]+dp2[i]);\\n            }\\n        }\\n        return n-maxi+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396219,
                "title": "lis-variation-easy-dp",
                "content": "```\\nint minimumMountainRemovals(vector<int>& nums) {\\n        int n=nums.size();\\n\\t    vector<int>  lis(n,1);\\n\\t    vector<int> lds(n,1);\\n\\t    for(int i=0;i<n;i++){\\n\\t        for(int j=0;j<i;j++){\\n\\t            if(nums[i]>nums[j]){\\n\\t                lis[i]=max(lis[i],lis[j]+1);\\n\\t            }\\n\\t        }\\n\\t    }\\n\\t     for(int i=n-1;i>=0;i--){\\n\\t        for(int j=n-1;j>i;j--){\\n\\t            if(nums[i]>nums[j]){\\n\\t                lds[i]=max(lds[i],lds[j]+1);\\n\\t            }\\n\\t        }\\n\\t    }\\n\\t    int maxi=INT_MIN;\\n\\t    for(int i=0;i<n;i++){\\n            if(lis[i]==1 or lds[i]==1)\\n                continue;\\n\\t        maxi=max(maxi,lis[i]+lds[i]-1);\\n\\t    }\\n\\t    return n-maxi;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint minimumMountainRemovals(vector<int>& nums) {\\n        int n=nums.size();\\n\\t    vector<int>  lis(n,1);\\n\\t    vector<int> lds(n,1);\\n\\t    for(int i=0;i<n;i++){\\n\\t        for(int j=0;j<i;j++){\\n\\t            if(nums[i]>nums[j]){\\n\\t                lis[i]=max(lis[i],lis[j]+1);\\n\\t            }\\n\\t        }\\n\\t    }\\n\\t     for(int i=n-1;i>=0;i--){\\n\\t        for(int j=n-1;j>i;j--){\\n\\t            if(nums[i]>nums[j]){\\n\\t                lds[i]=max(lds[i],lds[j]+1);\\n\\t            }\\n\\t        }\\n\\t    }\\n\\t    int maxi=INT_MIN;\\n\\t    for(int i=0;i<n;i++){\\n            if(lis[i]==1 or lds[i]==1)\\n                continue;\\n\\t        maxi=max(maxi,lis[i]+lds[i]-1);\\n\\t    }\\n\\t    return n-maxi;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1721254,
                "title": "c-easy-to-understand-simple-dp-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp1(n,0),dp2(n,0);\\n        int ans=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            int maxi=0;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[j]<nums[i])\\n                {\\n                    dp1[i]=max(dp1[i],dp1[j]+1);\\n                }\\n            }\\n        }  \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            int maxi=0;\\n            for(int j=n-1;j>i;j--)\\n            {\\n                if(nums[j]<nums[i])\\n                {\\n                    dp2[i]=max(dp2[i],dp2[j]+1);\\n                }\\n            }\\n        }\\n        int res=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp1[i]!=0&&dp2[i]!=0)\\n            {\\n                res=max(res,dp1[i]+dp2[i]);\\n            }\\n        }\\n        return n-(res+1);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> dp1(n,0),dp2(n,0);\\n        int ans=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            int maxi=0;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[j]<nums[i])\\n                {\\n                    dp1[i]=max(dp1[i],dp1[j]+1);\\n                }\\n            }\\n        }  \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            int maxi=0;\\n            for(int j=n-1;j>i;j--)\\n            {\\n                if(nums[j]<nums[i])\\n                {\\n                    dp2[i]=max(dp2[i],dp2[j]+1);\\n                }\\n            }\\n        }\\n        int res=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp1[i]!=0&&dp2[i]!=0)\\n            {\\n                res=max(res,dp1[i]+dp2[i]);\\n            }\\n        }\\n        return n-(res+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952149,
                "title": "java-lis-solution",
                "content": "Idea:\\nFor each point, if it is the peek point, we try to found the longest subsequence from its right and left;\\nThe length of the array is **leftLIS[i]+rightLIS[i]-1**. \\nWe want to remove **n-(leftLIS[i]+rightLIS[i]-1)**\\n\\n```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] A) {\\n        int res=Integer.MAX_VALUE;\\n        int n=A.length;\\n        int dp1[]=new int[n];\\n        int dp2[]=new int[n];\\n        \\n        dp1[0]=1;\\n        dp2[n-1]=1;\\n        \\n        for(int i=1;i<A.length;i++){\\n            int max=0;\\n            for(int j=i-1;j>=0;j--){\\n                if(A[j]<A[i]){\\n                    if(max<dp1[j]){\\n                        max=dp1[j];\\n                    }\\n                }\\n            }\\n            dp1[i]=max+1;\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            int max=0;\\n            for(int j=i+1;j<A.length;j++){\\n                if(A[j]<A[i]){\\n                    max=Math.max(max,dp2[j]);\\n                }\\n            }\\n            dp2[i]=max+1;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(dp1[i]<2||dp2[i]<2)continue;\\n            \\n            int len=dp1[i]+dp2[i]-1;\\n            res=Math.min(res,n-len);\\n        }\\n        \\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] A) {\\n        int res=Integer.MAX_VALUE;\\n        int n=A.length;\\n        int dp1[]=new int[n];\\n        int dp2[]=new int[n];\\n        \\n        dp1[0]=1;\\n        dp2[n-1]=1;\\n        \\n        for(int i=1;i<A.length;i++){\\n            int max=0;\\n            for(int j=i-1;j>=0;j--){\\n                if(A[j]<A[i]){\\n                    if(max<dp1[j]){\\n                        max=dp1[j];\\n                    }\\n                }\\n            }\\n            dp1[i]=max+1;\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            int max=0;\\n            for(int j=i+1;j<A.length;j++){\\n                if(A[j]<A[i]){\\n                    max=Math.max(max,dp2[j]);\\n                }\\n            }\\n            dp2[i]=max+1;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(dp1[i]<2||dp2[i]<2)continue;\\n            \\n            int len=dp1[i]+dp2[i]-1;\\n            res=Math.min(res,n-len);\\n        }\\n        \\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952003,
                "title": "java-dp-o-n-2-got-tle-need-help",
                "content": "```\\nclass Solution {\\n    public static int func(int[] nums, int n, int i, int j, int flag, int[][][] dp) {\\n        if(i == n) return flag == 3 ? 0 : n;\\n        if(dp[i][j][flag] != -1) return dp[i][j][flag];\\n        if(j == n) {\\n            int m1 = func(nums, n, i + 1, i, 1, dp);\\n            int m2 = 1 + func(nums, n, i + 1, j, flag, dp);\\n            return Math.min(m1, m2);\\n        }\\n        int min = 1 + func(nums, n, i + 1, j, flag, dp);\\n        if(flag == 1 && nums[i] > nums[j]) min = Math.min(min, Math.min(func(nums, n, i + 1, i, 2, dp), func(nums, n, i + 1, i, 1, dp)));\\n        if((flag == 3 || flag == 2) && nums[i] < nums[j]) min = Math.min(min, func(nums, n, i + 1, i, 3, dp));\\n        return dp[i][j][flag] = min;\\n    }\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n = nums.length;\\n        int[][][] dp = new int[n + 1][n + 1][4];\\n        for(int i = 0; i <= n; i++) {\\n            for(int j = 0; j <= n; j++) {\\n                dp[i][j][0] = dp[i][j][1] = dp[i][j][2] = dp[i][j][3] = -1;\\n            }\\n        }\\n        return func(nums, n, 0, n, 0, dp);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public static int func(int[] nums, int n, int i, int j, int flag, int[][][] dp) {\\n        if(i == n) return flag == 3 ? 0 : n;\\n        if(dp[i][j][flag] != -1) return dp[i][j][flag];\\n        if(j == n) {\\n            int m1 = func(nums, n, i + 1, i, 1, dp);\\n            int m2 = 1 + func(nums, n, i + 1, j, flag, dp);\\n            return Math.min(m1, m2);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3667863,
                "title": "similar-to-lis-clean-and-understandable-approach-with-explanation-time-o-n-n-and-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the code is to use dynamic programming to find the minimum number of elements to remove from the input list nums in order to obtain a mountain sequence. So we use the concept of Longest Increasing Subsequence.\\n\\nPre-requiasite: First solve Longest Increasing Subsequence for better undersatnding.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nInitialize two arrays, dp1 and dp2, with zeros. These arrays will store the lengths of the longest increasing and decreasing subsequences, respectively, ending at each index.\\n\\nUse dynamic programming to calculate the length of the longest increasing subsequence (LIS) for each index i in the input list nums. This is done using a nested loop. For each pair of indices (i, j) where 0 <= j < i, if nums[i] is greater than nums[j], we can extend the increasing subsequence ending at index j by including the element at index i. Update inc[i] to be the maximum length of increasing subsequence ending at index i.\\n\\nSimilarly, use dynamic programming to calculate the length of the longest decreasing subsequence for each index i in nums. This is done using another nested loop, but this time we start from the second-to-last index (n-2) and iterate in reverse order.\\n\\nIterate through all indices i and find the maximum length of the mountain sequence that can be formed by including index i. This can be calculated as inc[i] + dec[i] - 1.\\n\\nFinally, the minimum number of elements to remove to obtain a mountain sequence is equal to n - max_length - 1, where n is the length of nums and max_length is the maximum mountain sequence length obtained in the previous step.\\n\\nReturn the minimum number of removals required to obtain a mountain sequence.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe are using two nested loops that are run twice, so O(n*n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe are using two rows of size n, so O(n)+O(n)~O(n).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp1(n,0);\\n\\n        for(int i=1;i<n;i++){\\n            for(int prev=0;prev<i;prev++){\\n                if(nums[prev]<nums[i] && dp1[i]<dp1[prev]+1){\\n                    dp1[i]=(dp1[prev]+1);\\n                }\\n            }\\n        }\\n        vector<int>dp2(n,0);\\n        for(int i=n-2;i>=0;i--){\\n            for(int prev=n-1;prev>=i;prev--){\\n                if(nums[prev]<nums[i] && dp2[i]<dp2[prev]+1){\\n                    dp2[i]=(dp2[prev]+1);\\n                }\\n            }\\n        }\\n        int mx=0;\\n        for(int i=0;i<n;i++){\\n            if(dp1[i]>0 && dp2[i]>0){\\n                mx=max(mx,dp1[i]+dp2[i]);\\n            }\\n            \\n        }\\n        return n-mx-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp1(n,0);\\n\\n        for(int i=1;i<n;i++){\\n            for(int prev=0;prev<i;prev++){\\n                if(nums[prev]<nums[i] && dp1[i]<dp1[prev]+1){\\n                    dp1[i]=(dp1[prev]+1);\\n                }\\n            }\\n        }\\n        vector<int>dp2(n,0);\\n        for(int i=n-2;i>=0;i--){\\n            for(int prev=n-1;prev>=i;prev--){\\n                if(nums[prev]<nums[i] && dp2[i]<dp2[prev]+1){\\n                    dp2[i]=(dp2[prev]+1);\\n                }\\n            }\\n        }\\n        int mx=0;\\n        for(int i=0;i<n;i++){\\n            if(dp1[i]>0 && dp2[i]>0){\\n                mx=max(mx,dp1[i]+dp2[i]);\\n            }\\n            \\n        }\\n        return n-mx-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607084,
                "title": "c-stack-lower-bound",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& v) {\\n        int n = v.size(),i,x;\\n        vector<int> l(n,0),r(n,0),s;\\n        s.push_back(v[0]);\\n        for(i = 1; i < n; i++){//longest incresing subsequence from left\\n            x = lower_bound(s.begin(),s.end(),v[i])-s.begin();\\n            if(x==s.size()){\\n                s.push_back(v[i]);\\n            }else{\\n                s[x] = v[i];\\n            }\\n            l[i] = i+1-s.size();\\n        }\\n        s.clear();\\n        s.push_back(v[n-1]);\\n        for(i = n-2; i >= 0; i--){//longest incresing subsequence from right\\n            x = lower_bound(s.begin(),s.end(),v[i])-s.begin();\\n            if(x==s.size()){\\n                s.push_back(v[i]);\\n            }else{\\n                s[x] = v[i];\\n            }\\n            r[i] = n-1-i+1-s.size();\\n        }\\n        int ans = n;\\n        for(i = 0; i < n; i++){\\n            if(i+1-l[i]>=2 && n-i-r[i]>=2)//>=2 bcz from left and right at least 2 element must be there a<b>c \\n//i+1-l[i] and n-i-r[i] tells us no of element which we want delete from left and right.\\n                ans = min(ans,l[i]+r[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& v) {\\n        int n = v.size(),i,x;\\n        vector<int> l(n,0),r(n,0),s;\\n        s.push_back(v[0]);\\n        for(i = 1; i < n; i++){//longest incresing subsequence from left\\n            x = lower_bound(s.begin(),s.end(),v[i])-s.begin();\\n            if(x==s.size()){\\n                s.push_back(v[i]);\\n            }else{\\n                s[x] = v[i];\\n            }\\n            l[i] = i+1-s.size();\\n        }\\n        s.clear();\\n        s.push_back(v[n-1]);\\n        for(i = n-2; i >= 0; i--){//longest incresing subsequence from right\\n            x = lower_bound(s.begin(),s.end(),v[i])-s.begin();\\n            if(x==s.size()){\\n                s.push_back(v[i]);\\n            }else{\\n                s[x] = v[i];\\n            }\\n            r[i] = n-1-i+1-s.size();\\n        }\\n        int ans = n;\\n        for(i = 0; i < n; i++){\\n            if(i+1-l[i]>=2 && n-i-r[i]>=2)//>=2 bcz from left and right at least 2 element must be there a<b>c \\n//i+1-l[i] and n-i-r[i] tells us no of element which we want delete from left and right.\\n                ans = min(ans,l[i]+r[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555975,
                "title": "bitonic-subsequence-lis-striver-s-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>dp1(n,1);\\n         vector<int>dp2(n,1);\\n        \\n\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            for(int prev=0;prev<i;prev++)\\n            {\\n                if(arr[prev]<arr[i] && 1+dp1[prev]>dp1[i]){\\n                    dp1[i]=1+dp1[prev]; \\n                }\\n            }\\n           \\n                \\n        }\\n\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            \\n            for(int prev=n-1;prev>i;prev--)\\n            {\\n                if(arr[prev]<arr[i] && 1+dp2[prev]>dp2[i]){\\n                    dp2[i]=1+dp2[prev]; \\n                }\\n            }\\n           \\n                \\n        }\\n        int maxi=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp1[i]==1||dp2[i]==1) continue;\\n            maxi=max(maxi,dp1[i]+dp2[i]-1);\\n        }\\n       return n-maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>dp1(n,1);\\n         vector<int>dp2(n,1);\\n        \\n\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            for(int prev=0;prev<i;prev++)\\n            {\\n                if(arr[prev]<arr[i] && 1+dp1[prev]>dp1[i]){\\n                    dp1[i]=1+dp1[prev]; \\n                }\\n            }\\n           \\n                \\n        }\\n\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            \\n            for(int prev=n-1;prev>i;prev--)\\n            {\\n                if(arr[prev]<arr[i] && 1+dp2[prev]>dp2[i]){\\n                    dp2[i]=1+dp2[prev]; \\n                }\\n            }\\n           \\n                \\n        }\\n        int maxi=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp1[i]==1||dp2[i]==1) continue;\\n            maxi=max(maxi,dp1[i]+dp2[i]-1);\\n        }\\n       return n-maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501272,
                "title": "java-binary-search-dp-lis-variant",
                "content": "## Intution: \\n\\nCalculate the length of the Longest Increasing Subsequence (LIS) as well as the length of the Longest Decreasing Subsequence (LDS) for each index i and store them in two arrays.\\n\\nNow, if we consider each index as a potential peak of a mountain array, the answer for each index is given by `LIS[i] + LDS[i] - 1`.\\n\\nReturn `nums.length - maximum answer obtained from all indices`.\\n\\n``` java []\\n// Binary Search \\n// TC -> 2*O(nlogn) + O(n) \\u2248 O(nlogn)\\n// SC -> 3*O(n) \\u2248 O(n) \\n\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n = nums.length;\\n        int[] ans1 = new int[n], ans2 = new int[n];\\n        ArrayList<Integer> list = new ArrayList<>();\\n        list.add(nums[0]);\\n\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>list.get(list.size()-1)){\\n                list.add(nums[i]);\\n                ans1[i] = list.size();\\n            }\\n            else{\\n                int idx = upperBound(list,nums[i]);\\n                list.set(idx,nums[i]);\\n                ans1[i] = idx+1;\\n            }\\n        }\\n        list.clear();\\n        list.add(nums[n-1]);\\n      \\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]>list.get(list.size()-1)){\\n                list.add(nums[i]);\\n                ans2[i] = list.size();\\n            }\\n            else{\\n                int idx = upperBound(list,nums[i]);\\n                list.set(idx,nums[i]);\\n                ans2[i] = idx+1;\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=1;i<n-1;i++){\\n            if(ans1[i]>1 && ans2[i]>1){\\n                ans= Math.max(ans,ans1[i]+ans2[i]-1);\\n            }\\n        }\\n\\n        return nums.length-ans;\\n    }\\n\\n    private int upperBound(ArrayList<Integer> list,int target){\\n        int i=0, j=list.size()-1;\\n        while(i<=j){\\n            int mid = (i+j)/2;\\n\\n            if(list.get(mid)<=target){\\n                i=mid+1;\\n            }\\n            else{\\n                j=mid-1;\\n            }\\n        }\\n        return list.get(Math.max(j,0)) == target? j:i; // return last targetIndex | insertionIndex\\n    }\\n}\\n```\\n\\n``` java []\\n// Tabulation (DP)\\n// TC -> O(n*n)\\n// SC -> O(n)\\n\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int[] dp1 = new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            int max=0;\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i])\\n                    max=Math.max(max,dp1[j]);\\n            }\\n            dp1[i] = max+1;\\n        }\\n\\n        int[] dp2 = new int[nums.length];\\n        for(int i=nums.length-1;i>=0;i--){\\n            int max=0;\\n            for(int j=nums.length-1;j>i;j--){\\n                if(nums[j]<nums[i])\\n                    max=Math.max(max,dp2[j]);\\n            }\\n            dp2[i] = max+1;\\n        }\\n        \\n        int ans=0; \\n        for(int i=1;i<nums.length-1;i++){\\n            if(dp1[i]>1 && dp2[i]>1)\\n            ans=Math.max(ans,dp1[i]+dp2[i]-1);\\n        }\\n        return nums.length-ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "``` java []\\n// Binary Search \\n// TC -> 2*O(nlogn) + O(n) \\u2248 O(nlogn)\\n// SC -> 3*O(n) \\u2248 O(n) \\n\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n = nums.length;\\n        int[] ans1 = new int[n], ans2 = new int[n];\\n        ArrayList<Integer> list = new ArrayList<>();\\n        list.add(nums[0]);\\n\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>list.get(list.size()-1)){\\n                list.add(nums[i]);\\n                ans1[i] = list.size();\\n            }\\n            else{\\n                int idx = upperBound(list,nums[i]);\\n                list.set(idx,nums[i]);\\n                ans1[i] = idx+1;\\n            }\\n        }\\n        list.clear();\\n        list.add(nums[n-1]);\\n      \\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]>list.get(list.size()-1)){\\n                list.add(nums[i]);\\n                ans2[i] = list.size();\\n            }\\n            else{\\n                int idx = upperBound(list,nums[i]);\\n                list.set(idx,nums[i]);\\n                ans2[i] = idx+1;\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=1;i<n-1;i++){\\n            if(ans1[i]>1 && ans2[i]>1){\\n                ans= Math.max(ans,ans1[i]+ans2[i]-1);\\n            }\\n        }\\n\\n        return nums.length-ans;\\n    }\\n\\n    private int upperBound(ArrayList<Integer> list,int target){\\n        int i=0, j=list.size()-1;\\n        while(i<=j){\\n            int mid = (i+j)/2;\\n\\n            if(list.get(mid)<=target){\\n                i=mid+1;\\n            }\\n            else{\\n                j=mid-1;\\n            }\\n        }\\n        return list.get(Math.max(j,0)) == target? j:i; // return last targetIndex | insertionIndex\\n    }\\n}\\n```\n``` java []\\n// Tabulation (DP)\\n// TC -> O(n*n)\\n// SC -> O(n)\\n\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int[] dp1 = new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            int max=0;\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i])\\n                    max=Math.max(max,dp1[j]);\\n            }\\n            dp1[i] = max+1;\\n        }\\n\\n        int[] dp2 = new int[nums.length];\\n        for(int i=nums.length-1;i>=0;i--){\\n            int max=0;\\n            for(int j=nums.length-1;j>i;j--){\\n                if(nums[j]<nums[i])\\n                    max=Math.max(max,dp2[j]);\\n            }\\n            dp2[i] = max+1;\\n        }\\n        \\n        int ans=0; \\n        for(int i=1;i<nums.length-1;i++){\\n            if(dp1[i]>1 && dp2[i]>1)\\n            ans=Math.max(ans,dp1[i]+dp2[i]-1);\\n        }\\n        return nums.length-ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437206,
                "title": "lis-c-time-o-n-2-aaditya-verma-type",
                "content": "````\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size(),i,j;\\n        vector<int> dp(n);\\n        for(i = 0; i < n; i++){//find lis from left side\\n            dp[i] = 1;\\n            for(j = i-1; j >= 0; j--){\\n                if(nums[j]<nums[i]&&dp[i]<dp[j]+1){\\n                    dp[i] = dp[j]+1;\\n                }\\n            }\\n        }\\n        vector<int> r(n);\\n        for(i = n-1; i >= 0; i--){//find lis from right side\\n            r[i] = 1;\\n            for(j = i+1; j < n; j++){\\n                if(nums[j]<nums[i]&&r[i]<r[j]+1){\\n                    r[i] =r[j]+1;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(i = 1; i < n-1; i++){\\n            if(dp[i]>1&&r[i]>1){//if length of lis from left and right > 1 than update ans\\n                ans = max(ans,dp[i]+r[i]-1);\\n            }\\n        }\\n        return n-ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size(),i,j;\\n        vector<int> dp(n);\\n        for(i = 0; i < n; i++){//find lis from left side\\n            dp[i] = 1;\\n            for(j = i-1; j >= 0; j--){\\n                if(nums[j]<nums[i]&&dp[i]<dp[j]+1){\\n                    dp[i] = dp[j]+1;\\n                }\\n            }\\n        }\\n        vector<int> r(n);\\n        for(i = n-1; i >= 0; i--){//find lis from right side\\n            r[i] = 1;\\n            for(j = i+1; j < n; j++){\\n                if(nums[j]<nums[i]&&r[i]<r[j]+1){\\n                    r[i] =r[j]+1;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(i = 1; i < n-1; i++){\\n            if(dp[i]>1&&r[i]>1){//if length of lis from left and right > 1 than update ans\\n                ans = max(ans,dp[i]+r[i]-1);\\n            }\\n        }\\n        return n-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336858,
                "title": "c-easy-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int> dp1(n,1), dp2(n,1);\\n        \\n        // LIS from front\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<i; j++)\\n            {\\n                if(nums[i] > nums[j] && 1 + dp1[j] > dp1[i])\\n                {\\n                    dp1[i] = 1 + dp1[j];\\n                }\\n            }\\n        }\\n        \\n        //LIS from back\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            for(int j=n-1; j>i; j--)\\n            {\\n                if(nums[i] > nums[j] && dp2[j] + 1 > dp2[i]){\\n                    dp2[i] = dp2[j] + 1;\\n                }\\n            }\\n        }\\n        \\n        int maxi = 1;\\n        for(int i=0; i<n; i++){\\n            if(dp1[i] > 1 && dp2[i] > 1){\\n                maxi = max(maxi, dp1[i] + dp2[i] -1);\\n            }\\n        }\\n        return (n-maxi);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int> dp1(n,1), dp2(n,1);\\n        \\n        // LIS from front\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<i; j++)\\n            {\\n                if(nums[i] > nums[j] && 1 + dp1[j] > dp1[i])\\n                {\\n                    dp1[i] = 1 + dp1[j];\\n                }\\n            }\\n        }\\n        \\n        //LIS from back\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            for(int j=n-1; j>i; j--)\\n            {\\n                if(nums[i] > nums[j] && dp2[j] + 1 > dp2[i]){\\n                    dp2[i] = dp2[j] + 1;\\n                }\\n            }\\n        }\\n        \\n        int maxi = 1;\\n        for(int i=0; i<n; i++){\\n            if(dp1[i] > 1 && dp2[i] > 1){\\n                maxi = max(maxi, dp1[i] + dp2[i] -1);\\n            }\\n        }\\n        return (n-maxi);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108771,
                "title": "find-the-length-of-the-longest-bitonic-subsequence",
                "content": "```\\nclass Solution {\\n\\tpublic int minimumMountainRemovals(int[] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\t// find the LIS from left\\n\\t\\tint[] left = new int[n];\\n\\t\\tleft[0] = 1;\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\t\\tif (arr[i] > arr[j]) {\\n\\t\\t\\t\\t\\tif (left[j] > left[i]) {\\n\\t\\t\\t\\t\\t\\tleft[i] = left[j];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tleft[i]++;\\n\\t\\t}\\n\\n\\t\\t// find the LIS from right\\n\\t\\tint[] right = new int[n];\\n\\t\\tright[n - 1] = 1;\\n\\t\\tfor (int i = n - 2; i >= 0; i--) {\\n\\t\\t\\tfor (int j = n - 1; j > i; j--) {\\n\\t\\t\\t\\tif (arr[i] > arr[j]) {\\n\\t\\t\\t\\t\\tif (right[j] > right[i]) {\\n\\t\\t\\t\\t\\t\\tright[i] = right[j];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tright[i]++;\\n\\t\\t}\\n\\t\\t// find the longest bitonic subsequence length\\n\\t\\tint max = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (left[i] != 1 && right[i] != 1)\\n\\t\\t\\t\\tmax = Math.max(left[i] + right[i] - 1, max);\\n\\t\\t}\\n\\t\\treturn n - max;\\n\\t}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\tpublic int minimumMountainRemovals(int[] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\t// find the LIS from left\\n\\t\\tint[] left = new int[n];\\n\\t\\tleft[0] = 1;\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\t\\tif (arr[i] > arr[j]) {\\n\\t\\t\\t\\t\\tif (left[j] > left[i]) {\\n\\t\\t\\t\\t\\t\\tleft[i] = left[j];\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1732748,
                "title": "java-o-nlogn-dp-solution",
                "content": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n = nums.length, lbs = 0; // lbs -> longest bitomic subsequence\\n        int [] dp = new int[n], dp2 = new int[n]; // dp[i] -> lis end at index i, dp2[i] -> lds end at index i\\n        List<Integer> lis = new ArrayList<>();\\n        for (int i = 0; i<n-1; i++) { // calculate longest increasing subsequence\\n            if (lis.isEmpty() || lis.get(lis.size()-1)<nums[i]) lis.add(nums[i]);\\n            else {   \\n                int idx = Collections.binarySearch(lis, nums[i]);\\n                if (idx<0) {\\n                    lis.set(-idx-1, nums[i]);\\n                }\\n            }\\n            dp[i] = lis.size();\\n        }\\n        lis = new ArrayList<>();\\n        for (int i = n-1; i>=1; i--) { // calculate longest decreasing subsequence\\n            if (lis.isEmpty() || lis.get(lis.size()-1)<nums[i]) lis.add(nums[i]);\\n            else {   \\n                int idx = Collections.binarySearch(lis, nums[i]);\\n                if (idx<0) {\\n                    lis.set(-idx-1, nums[i]);\\n                }\\n            }\\n            dp2[i] = lis.size();\\n            if (dp[i]>1 && dp2[i]>1) lbs = Math.max(lbs, dp[i]+dp2[i]-1);\\n        }\\n        return n-lbs;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n = nums.length, lbs = 0; // lbs -> longest bitomic subsequence\\n        int [] dp = new int[n], dp2 = new int[n]; // dp[i] -> lis end at index i, dp2[i] -> lds end at index i\\n        List<Integer> lis = new ArrayList<>();\\n        for (int i = 0; i<n-1; i++) { // calculate longest increasing subsequence\\n            if (lis.isEmpty() || lis.get(lis.size()-1)<nums[i]) lis.add(nums[i]);\\n            else {   \\n                int idx = Collections.binarySearch(lis, nums[i]);\\n                if (idx<0) {\\n                    lis.set(-idx-1, nums[i]);\\n                }\\n            }\\n            dp[i] = lis.size();\\n        }\\n        lis = new ArrayList<>();\\n        for (int i = n-1; i>=1; i--) { // calculate longest decreasing subsequence\\n            if (lis.isEmpty() || lis.get(lis.size()-1)<nums[i]) lis.add(nums[i]);\\n            else {   \\n                int idx = Collections.binarySearch(lis, nums[i]);\\n                if (idx<0) {\\n                    lis.set(-idx-1, nums[i]);\\n                }\\n            }\\n            dp2[i] = lis.size();\\n            if (dp[i]>1 && dp2[i]>1) lbs = Math.max(lbs, dp[i]+dp2[i]-1);\\n        }\\n        return n-lbs;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578383,
                "title": "longest-increasing-subsequence-and-longest-decreasing-subsequence-java",
                "content": "The only tricky thing is - you need to make sure lis[i] is atleast 2 and lds[i] is also atleast 2 to consider.\\n```java\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int N = nums.length;\\n        int[] lis = new int[N];\\n        int[] lds = new int[N];\\n        for(int i=0; i<N; i++) {\\n            lis[i] = 1;\\n            for(int j=i-1; j>=0; j--) {\\n                if (nums[j] < nums[i] && lis[i] < lis[j] + 1) {\\n                    lis[i] = lis[j] + 1;\\n                }\\n            }\\n        }\\n        \\n        for(int i=N-1; i>=0; i--) {\\n            lds[i] = 1;\\n            for(int j=i+1; j<N; j++) {\\n                if (nums[i] > nums[j] && lds[i] < lds[j] + 1) {\\n                    lds[i] = lds[j] + 1;\\n                }\\n            }\\n        }\\n        \\n        int maxElements = 0;\\n        for(int i=0; i<N; i++) {\\n            if (lis[i] >= 2 && lds[i] >= 2) {\\n                maxElements = Math.max(maxElements, lis[i] + lds[i] - 1);\\n            }\\n        }\\n        \\n        return N - maxElements;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int N = nums.length;\\n        int[] lis = new int[N];\\n        int[] lds = new int[N];\\n        for(int i=0; i<N; i++) {\\n            lis[i] = 1;\\n            for(int j=i-1; j>=0; j--) {\\n                if (nums[j] < nums[i] && lis[i] < lis[j] + 1) {\\n                    lis[i] = lis[j] + 1;\\n                }\\n            }\\n        }\\n        \\n        for(int i=N-1; i>=0; i--) {\\n            lds[i] = 1;\\n            for(int j=i+1; j<N; j++) {\\n                if (nums[i] > nums[j] && lds[i] < lds[j] + 1) {\\n                    lds[i] = lds[j] + 1;\\n                }\\n            }\\n        }\\n        \\n        int maxElements = 0;\\n        for(int i=0; i<N; i++) {\\n            if (lis[i] >= 2 && lds[i] >= 2) {\\n                maxElements = Math.max(maxElements, lis[i] + lds[i] - 1);\\n            }\\n        }\\n        \\n        return N - maxElements;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545828,
                "title": "longest-inc-subsequence-dp-golang",
                "content": "inc[i] => min removals to make strictly increasing sequence from nums[:i]\\n dec[i] => min removals to make strictly decreasing subsequence from nums[j:]\\n\\nfor every index i in nums:\\nassume i is the peak, therefore, \\nmin number of removals for i to be the peak = i - inc[i]-1 + n-1-i - dec[i]-1\\nSome brief explanation of the calculation above:\\n1. we have i elements to the left of i, and inc[i] number of increasing elements inclusive of nums[i], so the number of removals to the left is i - inc[i] - 1\\n2. we have n-1-i elements to the right of i, and dec[i] number of decreasing elements inclusive of nums[i], so the number of removals to the right is n-1-i - dec[i] - 1\\n\\n*note: the above is assuming inclusive index at the boundary, the implementation below is not inclusive.\\n\\nres is simply the min of all possible peaks\\n\\nSome tricky cases to consider is that for an index to be considered a peak, it MUST have elements to its left and right to fulfill the inc and desc slopes, ie inc[i] > 0 and dec[i] > 0 to qualify as a peak to be considered.\\n\\n```\\nfunc minimumMountainRemovals(nums []int) int {\\n    n := len(nums)\\n    \\n    inc := make([]int, n) // inc[i] = longest inc subsequence from nums[:i], not inclusive of i\\n    for i := range nums {  // Longest inc subsequence\\n        for j := 0; j<i; j++ {\\n            if nums[i] > nums[j] {\\n                inc[i] = max(inc[i], inc[j]+1)\\n            }\\n        }\\n    }\\n    \\n    dec := make([]int, n) // dec[i] = longest dec subsequence from nums[j:], not inclusive of j\\n    for i := n-1; i>-1; i-- {\\n        for j := n-1; j>i; j-- {\\n            if nums[i] > nums[j] {\\n                dec[i] = max(dec[i], dec[j]+1)\\n            }\\n        }\\n    }\\n    \\n    // fmt.Println(inc, dec)\\n    \\n    res := math.MaxInt32\\n    for i := range nums { // must have inc[i] > 0 and dec[i] > 0 to be considered a peak\\n        if inc[i] > 0 && dec[i] > 0 {\\n            removals := i-inc[i] + n-1-i - dec[i]\\n            // fmt.Println(\"peak: \", nums[i], \"removals: \", removals)\\n            res = min(res, removals)\\n        }\\n    }\\n    return res\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minimumMountainRemovals(nums []int) int {\\n    n := len(nums)\\n    \\n    inc := make([]int, n) // inc[i] = longest inc subsequence from nums[:i], not inclusive of i\\n    for i := range nums {  // Longest inc subsequence\\n        for j := 0; j<i; j++ {\\n            if nums[i] > nums[j] {\\n                inc[i] = max(inc[i], inc[j]+1)\\n            }\\n        }\\n    }\\n    \\n    dec := make([]int, n) // dec[i] = longest dec subsequence from nums[j:], not inclusive of j\\n    for i := n-1; i>-1; i-- {\\n        for j := n-1; j>i; j-- {\\n            if nums[i] > nums[j] {\\n                dec[i] = max(dec[i], dec[j]+1)\\n            }\\n        }\\n    }\\n    \\n    // fmt.Println(inc, dec)\\n    \\n    res := math.MaxInt32\\n    for i := range nums { // must have inc[i] > 0 and dec[i] > 0 to be considered a peak\\n        if inc[i] > 0 && dec[i] > 0 {\\n            removals := i-inc[i] + n-1-i - dec[i]\\n            // fmt.Println(\"peak: \", nums[i], \"removals: \", removals)\\n            res = min(res, removals)\\n        }\\n    }\\n    return res\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1135906,
                "title": "easy-dp-sol-with-comments-longest-increasing-subsequence",
                "content": "*  lis (longest increasing subsequences) and lds ( longest decreasing subsequence) are two dp arrays, both filled in similar fashion (read comments).\\n*  similar problem - longest bitonic subsequence\\n*  **Complexity Analysis**\\nTime: O(n^2)\\nSpace: O(n)\\n\\n```\\nclass Solution\\n{\\npublic:\\n  int minimumMountainRemovals(vector<int> &nums)\\n  {\\n    int n = nums.size();\\n      \\n    //lis[i] stores the longest increasing subsequences ending at i\\n    vector<int> lis(n, 1);\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n      int maxi = 1;\\n      for (int j = 0; j < i; j++)\\n      {\\n        if (nums[j] < nums[i])\\n        {\\n          maxi = max(maxi, lis[j] + 1);\\n        }\\n      }\\n      lis[i] = maxi;\\n    }\\n\\n    // now apply above algorithm in reverse\\n    //lds[i] stores the longest increasing subsequences till i in the reverse of array nums\\n    //OR\\n    //lds[i] stores longest decreasing subsequence starting from i\\n    vector<int> lds(n, 1);\\n    for (int i = n - 1; i >= 0; i--)\\n    {\\n      int maxi = 1;\\n      for (int j = i + 1; j < n; j++)\\n      {\\n        if (nums[i] > nums[j])\\n        {\\n          maxi = max(maxi, lds[j] + 1);\\n        }\\n      }\\n      lds[i] = maxi;\\n    }\\n\\n    /*Add lds[i] and lis[i] but nums[i] is counted twice so longest bitonic subsequence lis[i] + lds[i] - 1\\n\\t\\t*/\\n    int lbs = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n      if (lis[i] > 1 && lds[i] > 1)\\n        lbs = max(lis[i] + lds[i] - 1, lbs);\\n    }\\n    //remove other elements which are not in subsequence\\n    return n - lbs;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n  int minimumMountainRemovals(vector<int> &nums)\\n  {\\n    int n = nums.size();\\n      \\n    //lis[i] stores the longest increasing subsequences ending at i\\n    vector<int> lis(n, 1);\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n      int maxi = 1;\\n      for (int j = 0; j < i; j++)\\n      {\\n        if (nums[j] < nums[i])\\n        {\\n          maxi = max(maxi, lis[j] + 1);\\n        }\\n      }\\n      lis[i] = maxi;\\n    }\\n\\n    // now apply above algorithm in reverse\\n    //lds[i] stores the longest increasing subsequences till i in the reverse of array nums\\n    //OR\\n    //lds[i] stores longest decreasing subsequence starting from i\\n    vector<int> lds(n, 1);\\n    for (int i = n - 1; i >= 0; i--)\\n    {\\n      int maxi = 1;\\n      for (int j = i + 1; j < n; j++)\\n      {\\n        if (nums[i] > nums[j])\\n        {\\n          maxi = max(maxi, lds[j] + 1);\\n        }\\n      }\\n      lds[i] = maxi;\\n    }\\n\\n    /*Add lds[i] and lis[i] but nums[i] is counted twice so longest bitonic subsequence lis[i] + lds[i] - 1\\n\\t\\t*/\\n    int lbs = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n      if (lis[i] > 1 && lds[i] > 1)\\n        lbs = max(lis[i] + lds[i] - 1, lbs);\\n    }\\n    //remove other elements which are not in subsequence\\n    return n - lbs;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713477,
                "title": "q1671-accepted-c-used-lis-dp-easiest",
                "content": "CRUX\\n1) Calculate LIS from Left as well as Right.\\n2) 1 is substracted to remove the common peak (Point).\\n3) Therefore, the ans is the mountain peak. So \\'n - ans\\' is the points to be removed.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp1(n,1);\\n        vector<int> dp2(n,1);\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i] > nums[j] && 1+dp1[j] > dp1[i])\\n                    dp1[i] = 1+dp1[j];\\n            }\\n        }\\n        reverse(nums.begin(),nums.end());\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i] > nums[j] && 1+dp2[j] > dp2[i])\\n                    dp2[i] = 1+dp2[j];\\n            }\\n        }\\n        reverse(dp2.begin(),dp2.end());\\n        int maxLen = 1;\\n        for(int i=0;i<n;i++){\\n            if(dp1[i]>1 && dp2[i]>1){\\n                maxLen = max(dp1[i] + dp2[i] - 1, maxLen);\\n            }\\n        }\\n        \\n        return n-maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp1(n,1);\\n        vector<int> dp2(n,1);\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i] > nums[j] && 1+dp1[j] > dp1[i])\\n                    dp1[i] = 1+dp1[j];\\n            }\\n        }\\n        reverse(nums.begin(),nums.end());\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i] > nums[j] && 1+dp2[j] > dp2[i])\\n                    dp2[i] = 1+dp2[j];\\n            }\\n        }\\n        reverse(dp2.begin(),dp2.end());\\n        int maxLen = 1;\\n        for(int i=0;i<n;i++){\\n            if(dp1[i]>1 && dp2[i]>1){\\n                maxLen = max(dp1[i] + dp2[i] - 1, maxLen);\\n            }\\n        }\\n        \\n        return n-maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585434,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n=nums.length;\\n        int left[]=new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            left[i]=1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    left[i]=Math.max(left[i],left[j]+1);\\n                }\\n            }\\n        }\\n        int right[]=new int[n];\\n        for(int i=n-1;i>=0;--i)\\n        {\\n            right[i]=1;\\n            for(int j=n-1;j>i;--j)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    right[i]=Math.max(right[i],right[j]+1);\\n                }\\n            }\\n        }\\n        int maxLen=0;\\n        for(int i=0;i<n;++i)\\n        {\\n            if(left[i]>=2 && right[i]>=2)\\n            {\\n                int len=left[i]+right[i]-1;\\n                maxLen=Math.max(maxLen,len);\\n            }\\n        }\\n        int min=n-maxLen;\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n=nums.length;\\n        int left[]=new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            left[i]=1;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    left[i]=Math.max(left[i],left[j]+1);\\n                }\\n            }\\n        }\\n        int right[]=new int[n];\\n        for(int i=n-1;i>=0;--i)\\n        {\\n            right[i]=1;\\n            for(int j=n-1;j>i;--j)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    right[i]=Math.max(right[i],right[j]+1);\\n                }\\n            }\\n        }\\n        int maxLen=0;\\n        for(int i=0;i<n;++i)\\n        {\\n            if(left[i]>=2 && right[i]>=2)\\n            {\\n                int len=left[i]+right[i]-1;\\n                maxLen=Math.max(maxLen,len);\\n            }\\n        }\\n        int min=n-maxLen;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284842,
                "title": "c-longest-bitonic-sequence-lis-pattern-dp-striver",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> dp(n, 1), dp2(n, 1);\\n        int ans = 0;\\n        for (int ind=0; ind<n; ind++) {\\n            for (int prev=0; prev<ind; prev++) {\\n                if (arr[prev] < arr[ind] && 1 + dp[prev] > dp[ind]) {\\n                    dp[ind] = 1 + dp[prev];\\n                }\\n            }\\n        }\\n        for (int ind=n-1; ind>=0; ind--) {\\n            for (int prev=n-1; prev>ind; prev--) {\\n                if (arr[prev] < arr[ind] && 1 + dp2[prev] > dp2[ind]) {\\n                    dp2[ind] = 1 + dp2[prev];\\n                }\\n            }\\n        }\\n        for (int i=0; i<n; i++) {\\n            if (dp[i] > 1 && dp2[i] > 1) {\\n                ans = max(dp[i] + dp2[i] - 1, ans);\\n            }\\n        }\\n        return n - ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> dp(n, 1), dp2(n, 1);\\n        int ans = 0;\\n        for (int ind=0; ind<n; ind++) {\\n            for (int prev=0; prev<ind; prev++) {\\n                if (arr[prev] < arr[ind] && 1 + dp[prev] > dp[ind]) {\\n                    dp[ind] = 1 + dp[prev];\\n                }\\n            }\\n        }\\n        for (int ind=n-1; ind>=0; ind--) {\\n            for (int prev=n-1; prev>ind; prev--) {\\n                if (arr[prev] < arr[ind] && 1 + dp2[prev] > dp2[ind]) {\\n                    dp2[ind] = 1 + dp2[prev];\\n                }\\n            }\\n        }\\n        for (int i=0; i<n; i++) {\\n            if (dp[i] > 1 && dp2[i] > 1) {\\n                ans = max(dp[i] + dp2[i] - 1, ans);\\n            }\\n        }\\n        return n - ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174935,
                "title": "java-my-easy-solution-with-comments-o-n-2",
                "content": "Longest Bitonic Subsequence with peak at i index = LIS ending at i index + LDS starting at (i - 1) index\\nConstarint : (LIS at index i >= 2) && (LDS at index i >= 2)\\n**Time :** O(n^2 + n^2 + n) ~ O(n^2)\\n**Space :** O(2 * n)\\n```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        //longest increasing subsequence from left to right\\n        int[] left = new int[nums.length];\\n        for(int i = 0; i < nums.length; ++i){\\n            left[i] = 1;\\n            for(int j = 0; j < i; ++j){\\n                if(nums[j] < nums[i]){\\n                    left[i] = Math.max(left[i], left[j] + 1);\\n                }\\n            }\\n        }\\n        \\n        //longest increasing subsequence from right to left(longest deccreasing subsequence from left to right)\\n        int[] right = new int[nums.length];\\n        for(int i = nums.length - 1; i >= 0; --i){\\n            right[i] = 1;\\n            for(int j = nums.length - 1; j > i; --j){\\n                if(nums[j] < nums[i]){\\n                    right[i] = Math.max(right[i], right[j] + 1);\\n                }\\n            }\\n        }\\n        \\n        //Now calculating the longest bitonic subsequence\\n        //Now it is imporatant to note that, mountain array can not have only decreasing or increasing part, it must have both part\\n        //So for that reason we must have atleast 2 elements, in every subsequece to form valid mountain \\n        int maxLen = 0;\\n        for(int i = 0; i < nums.length; ++i){\\n            if(left[i] >= 2 && right[i] >= 2){\\n                int len = left[i] + right[i] - 1;\\n                maxLen = Math.max(maxLen, len);\\n            }\\n        }\\n        \\n        //minimum number of elements we should reomve to form the mountain array will be\\n        int minRemove = nums.length - maxLen;\\n        return minRemove;\\n    }\\n}\\n```\\n**If you like the solution, then please do Upvote it. Thank You!**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        //longest increasing subsequence from left to right\\n        int[] left = new int[nums.length];\\n        for(int i = 0; i < nums.length; ++i){\\n            left[i] = 1;\\n            for(int j = 0; j < i; ++j){\\n                if(nums[j] < nums[i]){\\n                    left[i] = Math.max(left[i], left[j] + 1);\\n                }\\n            }\\n        }\\n        \\n        //longest increasing subsequence from right to left(longest deccreasing subsequence from left to right)\\n        int[] right = new int[nums.length];\\n        for(int i = nums.length - 1; i >= 0; --i){\\n            right[i] = 1;\\n            for(int j = nums.length - 1; j > i; --j){\\n                if(nums[j] < nums[i]){\\n                    right[i] = Math.max(right[i], right[j] + 1);\\n                }\\n            }\\n        }\\n        \\n        //Now calculating the longest bitonic subsequence\\n        //Now it is imporatant to note that, mountain array can not have only decreasing or increasing part, it must have both part\\n        //So for that reason we must have atleast 2 elements, in every subsequece to form valid mountain \\n        int maxLen = 0;\\n        for(int i = 0; i < nums.length; ++i){\\n            if(left[i] >= 2 && right[i] >= 2){\\n                int len = left[i] + right[i] - 1;\\n                maxLen = Math.max(maxLen, len);\\n            }\\n        }\\n        \\n        //minimum number of elements we should reomve to form the mountain array will be\\n        int minRemove = nums.length - maxLen;\\n        return minRemove;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909476,
                "title": "in-easy-way-minimum-number-of-removals-to-make-mountain-array",
                "content": "\\n# Approach\\nBy using LIS \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n=nums.size();\\n\\n        vector<int>l(n,1);\\n        vector<int>d(n,1);\\n\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<i; j++){\\n               if (nums[i] > nums[j] )\\n                  l[i] = max(l[i],l[j] + 1);\\n            }\\n        }\\n        \\n\\n        for (int i = n-1; i >= 0; i--)\\n            for (int j = n-1; j > i; j--)\\n                if (nums[i] > nums[j] )\\n                      d[i]=max(d[i],d[j]+1);\\n       \\n        int ans=-1;\\n\\n        for(int i=0; i<n; i++){\\n             if(l[i]!= 1 && d[i]!= 1)\\n             ans=max(l[i]+d[i]-1,ans);\\n        }\\n\\n         return n-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n=nums.size();\\n\\n        vector<int>l(n,1);\\n        vector<int>d(n,1);\\n\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<i; j++){\\n               if (nums[i] > nums[j] )\\n                  l[i] = max(l[i],l[j] + 1);\\n            }\\n        }\\n        \\n\\n        for (int i = n-1; i >= 0; i--)\\n            for (int j = n-1; j > i; j--)\\n                if (nums[i] > nums[j] )\\n                      d[i]=max(d[i],d[j]+1);\\n       \\n        int ans=-1;\\n\\n        for(int i=0; i<n; i++){\\n             if(l[i]!= 1 && d[i]!= 1)\\n             ans=max(l[i]+d[i]-1,ans);\\n        }\\n\\n         return n-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839040,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\n//from Zhenglai Liu\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& A) {\\n        int N = A.size(), ans = N;\\n        vector<int> a(N), b(N), v;\\n        for (int i = 0 ; i < N; ++i) {\\n            int x = A[i];\\n            auto it = lower_bound(begin(v), end(v), x);\\n            a[i] = it - begin(v);\\n            if (it != end(v)) *it = x;\\n            else v.push_back(x);\\n        }\\n        v.clear();\\n        for (int i = N - 1; i >= 0; --i) {\\n            int x = A[i];\\n            auto it = lower_bound(begin(v), end(v), x) ;\\n            b[i] = it - begin(v); \\n            if (it != end(v)) *it = x;\\n            else v.push_back(x);\\n        }\\n        for (int i = 1; i < N; ++i) {\\n            if (a[i] && b[i]) ans = min(ans, N - (a[i] + b[i] + 1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//from Zhenglai Liu\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& A) {\\n        int N = A.size(), ans = N;\\n        vector<int> a(N), b(N), v;\\n        for (int i = 0 ; i < N; ++i) {\\n            int x = A[i];\\n            auto it = lower_bound(begin(v), end(v), x);\\n            a[i] = it - begin(v);\\n            if (it != end(v)) *it = x;\\n            else v.push_back(x);\\n        }\\n        v.clear();\\n        for (int i = N - 1; i >= 0; --i) {\\n            int x = A[i];\\n            auto it = lower_bound(begin(v), end(v), x) ;\\n            b[i] = it - begin(v); \\n            if (it != end(v)) *it = x;\\n            else v.push_back(x);\\n        }\\n        for (int i = 1; i < N; ++i) {\\n            if (a[i] && b[i]) ans = min(ans, N - (a[i] + b[i] + 1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572556,
                "title": "c-lis-bitonic-concept",
                "content": "If you are familiar with Longest Bitonic Subsequence solution using 2 LIS(from start and from end), then this solution might help you\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int> dp1(n,1),dp2(n,1);\\n        for(int ind=1;ind<n;ind++)\\n        {\\n            for(int prev=0;prev<ind;prev++)\\n            {\\n                if(arr[ind]>arr[prev])\\n                    dp1[ind]=max(dp1[ind],1+dp1[prev]);\\n            }\\n        }\\n        for(int ind=n-1;ind>=0;ind--)\\n        {\\n            for(int prev=n-1;prev>ind;prev--)\\n            {\\n                if(arr[ind]>arr[prev])\\n                    dp2[ind]=max(dp2[ind],1+dp2[prev]);\\n            }\\n        }\\n        int maxi=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp1[i]==1 || dp2[i]==1)\\n                continue;\\n            maxi=max(maxi,dp1[i]+dp2[i]-1);\\n        }\\n        return n-maxi;\\n    }\\n};\\n```\\nThe only addition to this code is that condition of ``` if(dp1[i]==1 || dp2[i]==1) ```\\nThink of it like this.\\nWhenever we have 1 at dp1[i] it means that there is no increasing subsequence behind it. So therefore we don\\'t want it in our subsequence as it could be a part of strictly decreasing subsequence. Example- arr=[3,2,1], dp1=[1,1,1]. Here we have to ignore every value(as dp1[i]=1 for all i) therefore this array can\\'t be transformed to mountain array.The same reason is for dp2 because if for any i, dp2[i]=1, then there is no decreasing subequence after it. Example- arr=[1,2,3], dp2=[1,1,1]. Here also, we can\\'t create any mountain array. \\nThere is a better test case to understand the intuition. [9,8,1,7,6,5,4,3,2,1] Try printing dp1, dp2 and see why this works.\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int> dp1(n,1),dp2(n,1);\\n        for(int ind=1;ind<n;ind++)\\n        {\\n            for(int prev=0;prev<ind;prev++)\\n            {\\n                if(arr[ind]>arr[prev])\\n                    dp1[ind]=max(dp1[ind],1+dp1[prev]);\\n            }\\n        }\\n        for(int ind=n-1;ind>=0;ind--)\\n        {\\n            for(int prev=n-1;prev>ind;prev--)\\n            {\\n                if(arr[ind]>arr[prev])\\n                    dp2[ind]=max(dp2[ind],1+dp2[prev]);\\n            }\\n        }\\n        int maxi=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp1[i]==1 || dp2[i]==1)\\n                continue;\\n            maxi=max(maxi,dp1[i]+dp2[i]-1);\\n        }\\n        return n-maxi;\\n    }\\n};\\n```\n``` if(dp1[i]==1 || dp2[i]==1) ```",
                "codeTag": "Java"
            },
            {
                "id": 2409135,
                "title": "c-lis-dp-easy-explanation",
                "content": "/*\\n    Intuition \\n    \\n    Step 1: Find LIS for each index from Left to Right and Right to Left\\n    Step 2: Find max Mountain by simply adding left and right LIS for any index and subtract 1\\n    because the current index element is added twice\\n    Step 3: Since, here we are interested in minimum number of elements to be removed\\n    subtract maxi from n => Minimum numbers to be removed\\n\\t\\n\\tThis problem is actually Related to Bitonic Problem in which We can have 3 types of Mountain arrays:\\n\\nLeft Mount (Only Left Side Uphill and No Right side)\\nRight Mount (Only Right Side Uphill and No Left side)\\nBoth Side\\nHere, in the problem statement they have asked about the mountain only which means the 3rd scenario and that is why to exclude the 1st and 2nd case we have put that condition.\\n\\nCheck this example:\\n[9,8,1,7,6,5,4,3,2,1]\\n\\ndp1 dp2\\n1 9\\n1 8\\n1 1\\n2 7 (Max Mount for this problem statement)\\n2 6\\n2 5\\n2 4\\n2 3\\n2 2\\n1 1\\n\\nHere, if we consider all three scenarios then our answer will be 1\\nBut for this problem statement out answer will be 2\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    int minimumMountainRemovals(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if(n <= 3) return 0;\\n        vector<int> dp1(n, 1), dp2(n, 1);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < i; j++)\\n            {\\n                if(nums[i] > nums[j])\\n                    dp1[i] = max(dp1[i], dp1[j]+1);\\n            }\\n        }\\n\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            for(int j = n-1; j > i; j--)\\n            {\\n                if(nums[i] > nums[j])\\n                    dp2[i] = max(dp2[i], dp2[j]+1);\\n            }\\n        }\\n        \\n        int maxi = -1e9;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(dp1[i] != 1 && dp2[i] != 1)\\n                maxi = max(maxi, dp1[i] + dp2[i] - 1);\\n        }\\n        \\n        return n - maxi;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int minimumMountainRemovals(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if(n <= 3) return 0;\\n        vector<int> dp1(n, 1), dp2(n, 1);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < i; j++)\\n            {\\n                if(nums[i] > nums[j])\\n                    dp1[i] = max(dp1[i], dp1[j]+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2289428,
                "title": "simple-c-code-o-n-2",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> LISFront(n,1);\\n        vector<int> LISBack(n,1);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < i; j++)\\n            {\\n                if(nums[j] < nums[i] && LISFront[i] <= LISFront[j])\\n                    LISFront[i] = 1+ LISFront[j];\\n            }\\n        }\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            for(int j = n-1; j >= i; j--)\\n            {\\n                if(nums[j] < nums[i] && LISBack[i] <= LISBack[j])\\n                    LISBack[i] = 1+ LISBack[j];\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(LISBack[i] == 1 || LISFront[i] == 1) continue;\\n            ans = max(ans, LISBack[i]+LISFront[i]-1);\\n        }\\n        return n-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> LISFront(n,1);\\n        vector<int> LISBack(n,1);\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < i; j++)\\n            {\\n                if(nums[j] < nums[i] && LISFront[i] <= LISFront[j])\\n                    LISFront[i] = 1+ LISFront[j];\\n            }\\n        }\\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            for(int j = n-1; j >= i; j--)\\n            {\\n                if(nums[j] < nums[i] && LISBack[i] <= LISBack[j])\\n                    LISBack[i] = 1+ LISBack[j];\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(LISBack[i] == 1 || LISFront[i] == 1) continue;\\n            ans = max(ans, LISBack[i]+LISFront[i]-1);\\n        }\\n        return n-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910624,
                "title": "dynamic-programming-lis-c-o-nlogn",
                "content": "With the thought of mountain first thing come to understanding is array is forming bitonic subsequence. Now in order to remove minimum elements to make the array bitonic or mountain, what we can do is simply reach the top of mountain from both the side with the help of Longest increasing subsequence and then subract it from total number of element to get the minimum number of elements to be removed.\\n\\n**Input** : [2,1,1,5,6,2,3,1]\\n\\n**LIS** :   1 1 1 2 3 2 3 1 \\n**LDS** :  2 1 1 3 3 2 2 1\\npeak would be max of  **max(lis[i] , lis[j] -1)** subracting 1 because peak have been calculated twice.\\n\\npeak = 6-1 = 5;\\nresult = n - peak = 8 - 5 = 3.\\n```\\n\\n vector<int> longestIncreasingSubsequence(vector<int>nums, int n){\\n       \\n        vector<int > v;\\n        vector<int>lis;\\n        lis.push_back(1);\\n        v.push_back(nums[0]);\\n        \\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>v.back()){\\n                v.push_back(nums[i]);\\n                lis.push_back(v.size());\\n            }\\n            else{\\n                int idx=lower_bound(v.begin(),v.end(),nums[i])-v.begin();\\n                v[idx]=nums[i];\\n                lis.push_back(idx+1);\\n            }\\n        }\\n        \\n        return lis;\\n    }\\n    \\n    int minimumMountainRemovals(vector<int>& nums) {\\n        // maximum length of bitonic subsequence\\n        \\n        int n = nums.size();\\n        vector<int> lis = longestIncreasingSubsequence(nums, n);\\n        \\n     \\n        reverse(nums.begin(), nums.end());\\n        vector<int> lds = longestIncreasingSubsequence(nums, n);\\n        reverse(lds.begin(), lds.end());\\n\\n        int result=-1;\\n        \\n        for(int i =0;i<nums.size();i++){\\n            if(lis[i]==1 || lds[i]==1) continue;   //ignore all those who is 1 because it doesnt not have any to it\\'s left or right side\\n\\t\\t\\t\\n            result=max(result,lis[i]+lds[i]-1);  //subtracting 1 to prevent double counting\\n        }\\n        return nums.size()-result;\\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n vector<int> longestIncreasingSubsequence(vector<int>nums, int n){\\n       \\n        vector<int > v;\\n        vector<int>lis;\\n        lis.push_back(1);\\n        v.push_back(nums[0]);\\n        \\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>v.back()){\\n                v.push_back(nums[i]);\\n                lis.push_back(v.size());\\n            }\\n            else{\\n                int idx=lower_bound(v.begin(),v.end(),nums[i])-v.begin();\\n                v[idx]=nums[i];\\n                lis.push_back(idx+1);\\n            }\\n        }\\n        \\n        return lis;\\n    }\\n    \\n    int minimumMountainRemovals(vector<int>& nums) {\\n        // maximum length of bitonic subsequence\\n        \\n        int n = nums.size();\\n        vector<int> lis = longestIncreasingSubsequence(nums, n);\\n        \\n     \\n        reverse(nums.begin(), nums.end());\\n        vector<int> lds = longestIncreasingSubsequence(nums, n);\\n        reverse(lds.begin(), lds.end());\\n\\n        int result=-1;\\n        \\n        for(int i =0;i<nums.size();i++){\\n            if(lis[i]==1 || lds[i]==1) continue;   //ignore all those who is 1 because it doesnt not have any to it\\'s left or right side\\n\\t\\t\\t\\n            result=max(result,lis[i]+lds[i]-1);  //subtracting 1 to prevent double counting\\n        }\\n        return nums.size()-result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1543614,
                "title": "python-easy-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef minimumMountainRemovals(self, lst: List[int]) -> int:\\n\\t\\t\\tl = len(lst)\\n\\t\\t\\tdp = [0] * l\\n\\t\\t\\tdp1 = [0] * l\\n\\n\\t\\t\\tfor i in range(l):   # for increasing subsequence\\n\\t\\t\\t\\tmaxi = 0\\n\\t\\t\\t\\tfor j in range(i):\\n\\t\\t\\t\\t\\tif lst[i] > lst[j]:\\n\\t\\t\\t\\t\\t\\tif dp[j] > maxi:\\n\\t\\t\\t\\t\\t\\t\\tmaxi = dp[j]\\n\\n\\t\\t\\t\\tdp[i] = maxi + 1\\n\\n\\t\\t\\tfor i in range(l - 1, -1, -1):  # for decreasing subsequence\\n\\t\\t\\t\\tmaxi1 = 0\\n\\t\\t\\t\\tfor j in range(l - 1, i, -1):\\n\\t\\t\\t\\t\\tif lst[i] > lst[j]:\\n\\t\\t\\t\\t\\t\\tif dp1[j] > maxi1:\\n\\t\\t\\t\\t\\t\\t\\tmaxi1 = dp1[j]\\n\\n\\t\\t\\t\\tdp1[i] = maxi1 + 1\\n\\n\\t\\t\\tans = 0\\n\\t\\t\\tfor i in range(l):\\n\\t\\t\\t\\tif dp[i] > 1 and dp1[i] > 1:\\n\\t\\t\\t\\t\\ttemp = dp[i] + dp1[i] - 1\\n\\t\\t\\t\\t\\tif temp > ans:\\n\\t\\t\\t\\t\\t\\tans = temp\\n\\n\\t\\t\\treturn l - ans\\n\\n# if you like the solution, Please upvote!!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef minimumMountainRemovals(self, lst: List[int]) -> int:\\n\\t\\t\\tl = len(lst)\\n\\t\\t\\tdp = [0] * l\\n\\t\\t\\tdp1 = [0] * l\\n\\n\\t\\t\\tfor i in range(l):   # for increasing subsequence\\n\\t\\t\\t\\tmaxi = 0\\n\\t\\t\\t\\tfor j in range(i):\\n\\t\\t\\t\\t\\tif lst[i] > lst[j]:\\n\\t\\t\\t\\t\\t\\tif dp[j] > maxi:\\n\\t\\t\\t\\t\\t\\t\\tmaxi = dp[j]\\n\\n\\t\\t\\t\\tdp[i] = maxi + 1\\n\\n\\t\\t\\tfor i in range(l - 1, -1, -1):  # for decreasing subsequence\\n\\t\\t\\t\\tmaxi1 = 0\\n\\t\\t\\t\\tfor j in range(l - 1, i, -1):\\n\\t\\t\\t\\t\\tif lst[i] > lst[j]:\\n\\t\\t\\t\\t\\t\\tif dp1[j] > maxi1:\\n\\t\\t\\t\\t\\t\\t\\tmaxi1 = dp1[j]\\n\\n\\t\\t\\t\\tdp1[i] = maxi1 + 1\\n\\n\\t\\t\\tans = 0\\n\\t\\t\\tfor i in range(l):\\n\\t\\t\\t\\tif dp[i] > 1 and dp1[i] > 1:\\n\\t\\t\\t\\t\\ttemp = dp[i] + dp1[i] - 1\\n\\t\\t\\t\\t\\tif temp > ans:\\n\\t\\t\\t\\t\\t\\tans = temp\\n\\n\\t\\t\\treturn l - ans\\n\\n# if you like the solution, Please upvote!!",
                "codeTag": "Java"
            },
            {
                "id": 1520526,
                "title": "java-easy-using-longest-increasing-subsequence-o-n-2-beats-50-submissions-in-time",
                "content": "class Solution {\\n    \\n    public int minimumMountainRemovals(int[] nums) {\\n        \\n        int[] dp1 = new int[nums.length];\\n        int[] dp2 = new int[nums.length];\\n        \\n        Arrays.fill(dp1,1);\\n        Arrays.fill(dp2,1);\\n        \\n        for(int i=1;i<nums.length;i++) {\\n            for(int j=0;j<i;j++) {\\n                if(nums[j]<nums[i]) {\\n                    if(dp1[i]<dp1[j]+1) {\\n                        dp1[i] = dp1[j]+1;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        for(int i=nums.length-2;i>=0;i--) {\\n            for(int j=nums.length-1;j>i;j--) {\\n                if(nums[i]>nums[j]) {\\n                    if(dp2[i]<dp2[j]+1) {\\n                        dp2[i] = dp2[j]+1;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        int maxi = dp1[0];\\n        for(int i=1;i<dp1.length;i++) {\\n            maxi = Math.max(maxi,dp1[i]);\\n            dp1[i] = maxi;\\n        }\\n        maxi = dp2[dp2.length-1];\\n        for(int i=dp2.length-2;i>=0;i--) {\\n            maxi = Math.max(dp2[i],maxi);\\n            dp2[i] = maxi;\\n        }\\n        maxi = 0;\\n        for(int i=1;i<nums.length-1;i++) {\\n            if(dp1[i]!=1 && dp2[i]!=1)\\n            maxi = Math.max(maxi,dp1[i]+dp2[i]);\\n        }\\n        return nums.length-maxi+1;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    \\n    public int minimumMountainRemovals(int[] nums) {\\n        \\n        int[] dp1 = new int[nums.length];\\n        int[] dp2 = new int[nums.length];\\n        \\n        Arrays.fill(dp1,1);\\n        Arrays.fill(dp2,1);\\n        \\n        for(int i=1;i<nums.length;i++) {\\n            for(int j=0;j<i;j++) {\\n                if(nums[j]<nums[i]) {\\n                    if(dp1[i]<dp1[j]+1) {\\n                        dp1[i] = dp1[j]+1;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1377922,
                "title": "faster-easy",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums)\\n\\t{\\n        int n = nums.size();\\n\\t    vector<int> dp1(n , 0);\\n\\t    vector<int> dp2(n , 0);\\n\\t    int LBS = 0;\\n\\t    \\n\\t\\t//increasing\\n\\t    for(int i = 0 ; i < n ; i++)\\n\\t    {\\n\\t        int ma = 0;\\n\\t        for(int j = 0 ; j < i ; j++)\\n\\t        {\\n\\t            if(nums[j] < nums[i])\\n\\t            {\\n\\t                if(dp1[j] > ma)\\n\\t                {\\n\\t                   ma = dp1[j];\\n\\t                }\\n\\t            }\\n\\t        }\\n\\t        dp1[i] = ma + 1;\\n\\t    }\\n\\t\\t\\n       // decreasing\\n\\t    for(int i = n - 1 ; i >= 0 ; i--)\\n\\t    {\\n\\t        int ma = 0;\\n\\t        for(int j = n - 1 ; j > i ; j--)\\n\\t        {\\n\\t            if(nums[j] < nums[i])\\n\\t            {\\n\\t                if(dp2[j] > ma)\\n\\t                {\\n\\t                   ma = dp2[j];\\n\\t                }\\n\\t            }\\n\\t        }\\n\\t        dp2[i] = ma + 1;\\n\\t    }\\n\\t\\t\\n\\t    for(int i = 0 ; i < n ; i++)\\n\\t    {\\n\\t      if(dp1[i]> 1 && dp2[i] > 1)\\n\\t      {\\n\\t          LBS = max(dp1[i] + dp2[i] - 1 , LBS);\\n\\t      }\\n\\t    }\\n\\t    return n - LBS;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums)\\n\\t{\\n        int n = nums.size();\\n\\t    vector<int> dp1(n , 0);\\n\\t    vector<int> dp2(n , 0);\\n\\t    int LBS = 0;\\n\\t    \\n\\t\\t//increasing\\n\\t    for(int i = 0 ; i < n ; i++)\\n\\t    {\\n\\t        int ma = 0;\\n\\t        for(int j = 0 ; j < i ; j++)\\n\\t        {\\n\\t            if(nums[j] < nums[i])\\n\\t            {\\n\\t                if(dp1[j] > ma)\\n\\t                {\\n\\t                   ma = dp1[j];\\n\\t                }\\n\\t            }\\n\\t        }\\n\\t        dp1[i] = ma + 1;\\n\\t    }\\n\\t\\t\\n       // decreasing\\n\\t    for(int i = n - 1 ; i >= 0 ; i--)\\n\\t    {\\n\\t        int ma = 0;\\n\\t        for(int j = n - 1 ; j > i ; j--)\\n\\t        {\\n\\t            if(nums[j] < nums[i])\\n\\t            {\\n\\t                if(dp2[j] > ma)\\n\\t                {\\n\\t                   ma = dp2[j];\\n\\t                }\\n\\t            }\\n\\t        }\\n\\t        dp2[i] = ma + 1;\\n\\t    }\\n\\t\\t\\n\\t    for(int i = 0 ; i < n ; i++)\\n\\t    {\\n\\t      if(dp1[i]> 1 && dp2[i] > 1)\\n\\t      {\\n\\t          LBS = max(dp1[i] + dp2[i] - 1 , LBS);\\n\\t      }\\n\\t    }\\n\\t    return n - LBS;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328084,
                "title": "using-lis-approach-c-solution",
                "content": "```\\n vector<int> lengthOfLIS(vector<int>& a){\\n        \\n        \\n       \\n        int n=a.size();\\n        \\n       vector<int> dp(n);\\n        \\n        for(int i=0;i<n;i++){\\n            dp[i]=1;\\n        }\\n        \\n        int maxlength=1;\\n        for(int i=1;i<a.size();i++){\\n       \\n            \\n            for(int j=0;j<i;j++){\\n                  \\n                if(a[i]>a[j]){\\n                    dp[i]=max(dp[i], 1 + dp[j]);\\n                }\\n               \\n                 \\n            }\\n            \\n        }\\n            return dp;\\n        \\n    };\\n    int minimumMountainRemovals(vector<int>& nums) {\\n     \\n        vector<int> lis= lengthOfLIS(nums);\\n        reverse(nums.begin(),nums.end());\\n        \\n        vector<int> lds=lengthOfLIS(nums);\\n        reverse(lds.begin(),lds.end());\\n        \\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(lis[i]!=1 and lds[i]!=1){\\n              ans=max(ans ,lis[i] + lds[i] - 1 );\\n            }\\n        \\n        }\\n        \\n        return nums.size() - ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n vector<int> lengthOfLIS(vector<int>& a){\\n        \\n        \\n       \\n        int n=a.size();\\n        \\n       vector<int> dp(n);\\n        \\n        for(int i=0;i<n;i++){\\n            dp[i]=1;\\n        }\\n        \\n        int maxlength=1;\\n        for(int i=1;i<a.size();i++){\\n       \\n            \\n            for(int j=0;j<i;j++){\\n                  \\n                if(a[i]>a[j]){\\n                    dp[i]=max(dp[i], 1 + dp[j]);\\n                }\\n               \\n                 \\n            }\\n            \\n        }\\n            return dp;\\n        \\n    };\\n    int minimumMountainRemovals(vector<int>& nums) {\\n     \\n        vector<int> lis= lengthOfLIS(nums);\\n        reverse(nums.begin(),nums.end());\\n        \\n        vector<int> lds=lengthOfLIS(nums);\\n        reverse(lds.begin(),lds.end());\\n        \\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(lis[i]!=1 and lds[i]!=1){\\n              ans=max(ans ,lis[i] + lds[i] - 1 );\\n            }\\n        \\n        }\\n        \\n        return nums.size() - ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1014684,
                "title": "c-dp-solution-with-in-depth-explanation",
                "content": "\\t/*\\n\\n    - Our objective in this problem is to find the minimum number of removals\\n      needed to make a mountain array. In other words, we are trying to form\\n      a mountain array with the most elements possible.\\n      \\n    - A mountain array is a special kind of array where there is a maximum element\\n      somewhere in the array such that all elements before it are in a strictly increasing\\n      sequence and all elements after it are in a strictly decreasing sequence.\\n      \\n    - The minimum size of a mountain array has to be 3.\\n    \\n    - In this question, it is guaranteed that it is possible to form a mountain array.\\n      Note : The given array itself could also be a mountain array.\\n      \\n    - Our strategy to solve this problem should be to treat every element of the array as the\\n      \"peak\" of a mountain subsequence.\\n      \\n    - For every \"peak\", we do two things : \\n        a) Calculate the length of the longest increasing subsequence for elements\\n           less than it and to the left of it.\\n        b) Calculate the length of the longest decreasing subsequence for elements\\n           less than it and to the right of it.\\n           \\n        Note : These longest subsequences can be computed using Dynamic Programming.\\n               Let dpl[cur] represent the length of the longest increasing subsequence \\n               for elements less than nums[cur] and have index positions < cur (are to its left).\\n               To compute dpl[cur] we obtain the max value \"dpl[j]\" such that nums[j] < nums[cur]\\n               and dpl[j] is the maximum value in dpl[] for nums[] values < nums[cur] and to the\\n               left of cur. We also add one to our result.\\n               \\n               We apply the same logic (with a few tweaks) for part b) and store the\\n               results in dpr[].\\n      \\n    - Finally after computing dpl[] and dpr[], we say that the peak of our largest mountain\\n      array is placed at index \"maxIndex\" where dpl[maxIndex] + dpr[maxIndex] is maximum.\\n      Note : We should not consider a position where dpl[i] == 0 || dpr[i] == 0.\\n      \\n    - Our answer will be nums.size() - (dpl[maxIndex] + dpr[maxIndex] + 1)\\n    \\n    - Our solution has a O(n^2) time complexity and O(n) space complexity.\\n    \\n    */\\n    \\n    \\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        vector<int> dpl(nums.size());\\n        vector<int> dpr(nums.size());\\n        \\n        for(int i = 0; i < nums.size(); ++i) {\\n            \\n            int max = -1;\\n            \\n            for(int j = 0; j < i; ++j) {\\n                if(nums[j] < nums[i] && dpl[j] > max) {\\n                    max = dpl[j];\\n                }\\n            }\\n            \\n            if(max == -1) {\\n                dpl[i] = 0;\\n            } else {\\n                dpl[i] = max + 1;\\n            }\\n            \\n        }\\n        \\n        for(int i = nums.size() - 1; i >= 0; --i) {\\n            \\n            int max = -1;\\n            \\n            for(int j = nums.size() - 1; j > i; --j) {\\n                if(nums[j] < nums[i] && dpr[j] > max) {\\n                    max = dpr[j];\\n                }\\n            }\\n            \\n            if(max == -1) {\\n                dpr[i] = 0;\\n            } else {\\n                dpr[i] = max + 1;\\n            }\\n            \\n        }\\n        \\n        int longest = 0;\\n        \\n        for(int i = 0; i < nums.size(); ++i) {\\n            if(dpl[i] != 0 && dpr[i] != 0 && dpl[i] + dpr[i] > longest) {\\n                longest = dpl[i] + dpr[i];\\n            }\\n        }\\n        \\n        return (nums.size() - longest - 1);\\n    }",
                "solutionTags": [],
                "code": "\\t/*\\n\\n    - Our objective in this problem is to find the minimum number of removals\\n      needed to make a mountain array. In other words, we are trying to form\\n      a mountain array with the most elements possible.\\n      \\n    - A mountain array is a special kind of array where there is a maximum element\\n      somewhere in the array such that all elements before it are in a strictly increasing\\n      sequence and all elements after it are in a strictly decreasing sequence.\\n      \\n    - The minimum size of a mountain array has to be 3.\\n    \\n    - In this question, it is guaranteed that it is possible to form a mountain array.\\n      Note : The given array itself could also be a mountain array.\\n      \\n    - Our strategy to solve this problem should be to treat every element of the array as the\\n      \"peak\" of a mountain subsequence.\\n      \\n    - For every \"peak\", we do two things : \\n        a) Calculate the length of the longest increasing subsequence for elements\\n           less than it and to the left of it.\\n        b) Calculate the length of the longest decreasing subsequence for elements\\n           less than it and to the right of it.\\n           \\n        Note : These longest subsequences can be computed using Dynamic Programming.\\n               Let dpl[cur] represent the length of the longest increasing subsequence \\n               for elements less than nums[cur] and have index positions < cur (are to its left).\\n               To compute dpl[cur] we obtain the max value \"dpl[j]\" such that nums[j] < nums[cur]\\n               and dpl[j] is the maximum value in dpl[] for nums[] values < nums[cur] and to the\\n               left of cur. We also add one to our result.\\n               \\n               We apply the same logic (with a few tweaks) for part b) and store the\\n               results in dpr[].\\n      \\n    - Finally after computing dpl[] and dpr[], we say that the peak of our largest mountain\\n      array is placed at index \"maxIndex\" where dpl[maxIndex] + dpr[maxIndex] is maximum.\\n      Note : We should not consider a position where dpl[i] == 0 || dpr[i] == 0.\\n      \\n    - Our answer will be nums.size() - (dpl[maxIndex] + dpr[maxIndex] + 1)\\n    \\n    - Our solution has a O(n^2) time complexity and O(n) space complexity.\\n    \\n    */\\n    \\n    \\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        vector<int> dpl(nums.size());\\n        vector<int> dpr(nums.size());\\n        \\n        for(int i = 0; i < nums.size(); ++i) {\\n            \\n            int max = -1;\\n            \\n            for(int j = 0; j < i; ++j) {\\n                if(nums[j] < nums[i] && dpl[j] > max) {\\n                    max = dpl[j];\\n                }\\n            }\\n            \\n            if(max == -1) {\\n                dpl[i] = 0;\\n            } else {\\n                dpl[i] = max + 1;\\n            }\\n            \\n        }\\n        \\n        for(int i = nums.size() - 1; i >= 0; --i) {\\n            \\n            int max = -1;\\n            \\n            for(int j = nums.size() - 1; j > i; --j) {\\n                if(nums[j] < nums[i] && dpr[j] > max) {\\n                    max = dpr[j];\\n                }\\n            }\\n            \\n            if(max == -1) {\\n                dpr[i] = 0;\\n            } else {\\n                dpr[i] = max + 1;\\n            }\\n            \\n        }\\n        \\n        int longest = 0;\\n        \\n        for(int i = 0; i < nums.size(); ++i) {\\n            if(dpl[i] != 0 && dpr[i] != 0 && dpl[i] + dpr[i] > longest) {\\n                longest = dpl[i] + dpr[i];\\n            }\\n        }\\n        \\n        return (nums.size() - longest - 1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1006255,
                "title": "c-bitonic-subsequence-logic-with-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int size=nums.size();\\n        vector<int> lis(size,1);\\n        for(int i=0;i<size;i++){\\n            int maxYet=0;\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i]){\\n                    maxYet=max(maxYet,lis[j]);\\n                }\\n            }\\n            lis[i]=maxYet+1;\\n        }\\n        vector<int> ldp(size,1);\\n        for(int i=size-2;i>=0;i--){\\n            int maxYet=0;\\n            for(int j=size-1;j>i;j--){\\n                if(nums[j]<nums[i]){\\n                    maxYet=max(maxYet,ldp[j]);\\n                }\\n            }\\n            ldp[i]=maxYet+1;\\n        }\\n        int ans=0;\\n        for(int i=1;i<size-1;i++){\\n\\t\\t//bcz there might be a condition where the sum is higher but its not a mountain( \\\\ ) but we have to choose a mountain( ^ ).\\n            if(lis[i]>1 && ldp[i]>1)\\n            ans=max(ans,(lis[i]+ldp[i])-1);\\n        }\\n        return size-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int size=nums.size();\\n        vector<int> lis(size,1);\\n        for(int i=0;i<size;i++){\\n            int maxYet=0;\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i]){\\n                    maxYet=max(maxYet,lis[j]);\\n                }\\n            }\\n            lis[i]=maxYet+1;\\n        }\\n        vector<int> ldp(size,1);\\n        for(int i=size-2;i>=0;i--){\\n            int maxYet=0;\\n            for(int j=size-1;j>i;j--){\\n                if(nums[j]<nums[i]){\\n                    maxYet=max(maxYet,ldp[j]);\\n                }\\n            }\\n            ldp[i]=maxYet+1;\\n        }\\n        int ans=0;\\n        for(int i=1;i<size-1;i++){\\n\\t\\t//bcz there might be a condition where the sum is higher but its not a mountain( \\\\ ) but we have to choose a mountain( ^ ).\\n            if(lis[i]>1 && ldp[i]>1)\\n            ans=max(ans,(lis[i]+ldp[i])-1);\\n        }\\n        return size-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957630,
                "title": "java-max-lis-from-front-and-max-lis-from-back",
                "content": "```\\n/**\\n    A different version of longest increasing subsequence\\n    Find LIS from front\\n    Find LIS from back\\n    find a position where sum of the two is max..\\n    ans = (totalLen - left+right-1)\\n**/\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n = nums.length, max = 0;\\n\\t\\t\\n        int[] front = new int[n+1];\\n        Arrays.fill(front, 1);\\n\\t\\t\\n        int[] back = new int[n+1];\\n        Arrays.fill(back, 1);\\n\\n        for(int i=0 ; i<n ; i++){\\n            for(int j=0 ; j<i ; j++){\\n                if(nums[i] > nums[j] && front[i] < front[j] + 1){\\n                    front[i] = front[j] + 1;\\n                }\\n            }\\n        }\\n        \\n        for(int i=n-1 ; i>=0 ; i--){\\n            for(int j=n-1 ; j>i ; j--){\\n                if(nums[i] > nums[j] && back[i] < back[j] + 1){\\n                    back[i] = back[j] + 1;\\n                }\\n            }\\n\\t\\t\\t//find position where sum of the front[i] & back[i] is max (-1 to not include the mountain peak twice)\\n            if(back[i] > 1 && front[i] > 1)\\n                max = Math.max(max, back[i] + front[i]-1);\\n        }\\n        return n - max;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n    A different version of longest increasing subsequence\\n    Find LIS from front\\n    Find LIS from back\\n    find a position where sum of the two is max..\\n    ans = (totalLen - left+right-1)\\n**/\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n = nums.length, max = 0;\\n\\t\\t\\n        int[] front = new int[n+1];\\n        Arrays.fill(front, 1);\\n\\t\\t\\n        int[] back = new int[n+1];\\n        Arrays.fill(back, 1);\\n\\n        for(int i=0 ; i<n ; i++){\\n            for(int j=0 ; j<i ; j++){\\n                if(nums[i] > nums[j] && front[i] < front[j] + 1){\\n                    front[i] = front[j] + 1;\\n                }\\n            }\\n        }\\n        \\n        for(int i=n-1 ; i>=0 ; i--){\\n            for(int j=n-1 ; j>i ; j--){\\n                if(nums[i] > nums[j] && back[i] < back[j] + 1){\\n                    back[i] = back[j] + 1;\\n                }\\n            }\\n\\t\\t\\t//find position where sum of the front[i] & back[i] is max (-1 to not include the mountain peak twice)\\n            if(back[i] > 1 && front[i] > 1)\\n                max = Math.max(max, back[i] + front[i]-1);\\n        }\\n        return n - max;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952049,
                "title": "c-easy-and-o-n-2-with-explanation",
                "content": "Ok so a big hint its a extendex version of standard problem of dp name longest bitonic subsequence.\\n\\nso first try to think like that if you know how to solve longest bitonic subsequence then its a cake walk for you \\n\\nso for longest bitonic what you have to do is to built longest increasing subsequence form left.\\nans then built longest increasing subsequence form right.\\nof after that nothing is need to do just run over again and find sum of left and right if it is greater then the current sum then update current sum.\\n\\nat last you will get your longest bitonic subsequence.\\nafter that just substrack the value with the size of arr given that is your answer,\\nand you will get your answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        vector<int>l(nums.size(),1);\\n        vector<int>r(nums.size(),1);\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j] && l[i]<l[j]+1)\\n                    l[i]=l[j]+1;\\n            }\\n        }\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=n-1;j>i;j--)\\n            {\\n                if(nums[i]>nums[j] && r[i]<r[j]+1)\\n                    r[i]=r[j]+1;\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(l[i]+r[i]-1>ans)\\n                ans=l[i]+r[i]-1;\\n        }\\n        cout<<ans<<endl;\\n        return nums.size()-ans;\\n    }\\n};\\n```\\n\\n**hope you like my solution please upvote if you like it**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        vector<int>l(nums.size(),1);\\n        vector<int>r(nums.size(),1);\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j] && l[i]<l[j]+1)\\n                    l[i]=l[j]+1;\\n            }\\n        }\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=n-1;j>i;j--)\\n            {\\n                if(nums[i]>nums[j] && r[i]<r[j]+1)\\n                    r[i]=r[j]+1;\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(l[i]+r[i]-1>ans)\\n                ans=l[i]+r[i]-1;\\n        }\\n        cout<<ans<<endl;\\n        return nums.size()-ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 952021,
                "title": "c-simple-lis-longest-inc-subseq-approach-explained",
                "content": "This problem is a variation standard LIS dp question. For each element, precompute - \\n\\n\\t1- The largest increasing subseq for the elements left to it, considering current element as the end series.\\n\\t2- The largest decreasing subseq(LDS) for elements right to it, considering current element as the starting of series.\\n\\t\\nNow traverse through the array, **taking each element as the peak**, then minimum number of elements that we have to delete - \\n\\n\\t1- On left side, which are not part of current element\\'s LIS.\\n\\t2- On right side, which are not part of current element\\'s LDS.\\n\\t\\nOne more thing to keep in mind is that, there should be atleast one element on left and right(as given in the problem statement). Which means LIS, LDS should not be zero for current element.\\n\\nTime - O(n^2)\\nSpace - O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int i,j,n=nums.size(),ans=INT_MAX;\\n        \\n        vector<int>lis(n,0), lds(n,0);\\n        \\n\\t\\t// precompute LIS with current element as the end of that sequence\\n        for(i=1;i<n;i++){\\n            for(j=0;j<i;j++)\\n                if(nums[i]>nums[j])\\n                    lis[i]=max(lis[i],lis[j]+1);\\n        }\\n        \\n\\t\\t// precompute LDS with current element as start of that sequence\\n        for(i=n-2;i>=0;i--){\\n            for(j=n-1;j>i;j--)\\n                if(nums[i]>nums[j])\\n                    lds[i]=max(lds[i],lds[j]+1);\\n        }\\n        \\n        for(i=1;i<n-1;i++){\\n            if(lis[i]==0 || lds[i]==0 )             // to make sure that atleast one element is on both sides\\n                continue;\\n            \\n            ans = min( ans, (i-lis[i])+(n-i-1-lds[i]));     //number of elements to delete\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int i,j,n=nums.size(),ans=INT_MAX;\\n        \\n        vector<int>lis(n,0), lds(n,0);\\n        \\n\\t\\t// precompute LIS with current element as the end of that sequence\\n        for(i=1;i<n;i++){\\n            for(j=0;j<i;j++)\\n                if(nums[i]>nums[j])\\n                    lis[i]=max(lis[i],lis[j]+1);\\n        }\\n        \\n\\t\\t// precompute LDS with current element as start of that sequence\\n        for(i=n-2;i>=0;i--){\\n            for(j=n-1;j>i;j--)\\n                if(nums[i]>nums[j])\\n                    lds[i]=max(lds[i],lds[j]+1);\\n        }\\n        \\n        for(i=1;i<n-1;i++){\\n            if(lis[i]==0 || lds[i]==0 )             // to make sure that atleast one element is on both sides\\n                continue;\\n            \\n            ans = min( ans, (i-lis[i])+(n-i-1-lds[i]));     //number of elements to delete\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951989,
                "title": "c-o-n-2-lis-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int> dp1(n,1);// dp[i]----length of longest increasing subsequence upto i from 0\\n        for(int i=0;i<n;++i){\\n            for(int j=i-1;j>=0;--j){\\n                if(arr[i]>arr[j]){\\n                    dp1[i]=max(dp1[i],1+dp1[j]);\\n                }\\n            }\\n            \\n        }\\n        \\n        for(int i=0;i<n;++i){\\n            if(i){\\n                dp1[i]=max(dp1[i-1],dp1[i]);\\n            }\\n            cout<<dp1[i]<<\" \";\\n        }\\n        cout<<endl;\\n        vector<int> dp2(n,1);   //dp2[i]----length of longent decreasing sub sequence upto n-1 from i\\n        for(int i=n-1;i>=0;--i){\\n            for(int j=i;j<n;++j){\\n                if(arr[i]>arr[j]){\\n                    dp2[i]=max(dp2[i],dp2[j]+1);\\n                }\\n            }\\n        }\\n        \\n        for(int i=n-2;i>=0;--i){\\n            dp2[i]=max(dp2[i],dp2[i+1]);\\n        }\\n        for(int i=0;i<n;++i){\\n            cout<<dp2[i]<<\" \";\\n        }\\n        int res=0;\\n        for(int i=1;i<n-1;++i){\\n            res=max(res,dp1[i]+dp2[i]);\\n            \\n        }\\n        return n-res+1;\\n        //[1,16,84,9,29,71,86,79,72,12]\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int> dp1(n,1);// dp[i]----length of longest increasing subsequence upto i from 0\\n        for(int i=0;i<n;++i){\\n            for(int j=i-1;j>=0;--j){\\n                if(arr[i]>arr[j]){\\n                    dp1[i]=max(dp1[i],1+dp1[j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3907121,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int LongestBitonicSequence(vector<int>arr,int n)\\n\\t{\\n\\n   \\n        vector<int>dp1(n,1);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int prev=0;prev<i;prev++)\\n            {\\n                if(arr[prev]<arr[i] && 1+dp1[prev]>dp1[i])\\n                {\\n                    dp1[i]=1+dp1[prev];\\n                }\\n            }\\n            \\n        }\\n        vector<int>dp2(n,1);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int prev=n-1;prev>i;prev--)\\n            {\\n                if(arr[prev]<arr[i] && 1+dp2[prev]>dp2[i])\\n                {\\n                    dp2[i]=1+dp2[prev];\\n                }\\n            }\\n            \\n        }\\n    \\tint maxi=0;\\n    \\tfor(int i=0;i<n;i++){\\n            if(dp1[i]==1||dp2[i]==1) continue;\\n    \\t\\tmaxi=max(maxi,dp1[i]+dp2[i]-1);\\n    \\t}\\n    \\treturn maxi;\\n\\t}\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        return n-LongestBitonicSequence(nums,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int LongestBitonicSequence(vector<int>arr,int n)\\n\\t{\\n\\n   \\n        vector<int>dp1(n,1);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int prev=0;prev<i;prev++)\\n            {\\n                if(arr[prev]<arr[i] && 1+dp1[prev]>dp1[i])\\n                {\\n                    dp1[i]=1+dp1[prev];\\n                }\\n            }\\n            \\n        }\\n        vector<int>dp2(n,1);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int prev=n-1;prev>i;prev--)\\n            {\\n                if(arr[prev]<arr[i] && 1+dp2[prev]>dp2[i])\\n                {\\n                    dp2[i]=1+dp2[prev];\\n                }\\n            }\\n            \\n        }\\n    \\tint maxi=0;\\n    \\tfor(int i=0;i<n;i++){\\n            if(dp1[i]==1||dp2[i]==1) continue;\\n    \\t\\tmaxi=max(maxi,dp1[i]+dp2[i]-1);\\n    \\t}\\n    \\treturn maxi;\\n\\t}\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        return n-LongestBitonicSequence(nums,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462510,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n=nums.length;\\n        int dp1[]=new int[n];\\n        int dp2[]=new int[n];\\n        Arrays.fill(dp1,1);\\n        Arrays.fill(dp2,1);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int prev=0;prev<=i-1;prev++)\\n            {\\n                if(nums[prev]<nums[i] && dp1[prev]+1>dp1[i])\\n                    dp1[i]=dp1[prev]+1;\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int prev=n-1;prev>i;prev--)\\n            {\\n                if(nums[prev]<nums[i] && dp2[prev]+1>dp2[i])\\n                    dp2[i]=dp2[prev]+1;\\n            }\\n        }\\n        int max=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp1[i]>1 && dp2[i]>1)\\n                max=(int)Math.max(max,(dp1[i]+dp2[i]-1));\\n        }\\n            \\n        return nums.length-max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n=nums.length;\\n        int dp1[]=new int[n];\\n        int dp2[]=new int[n];\\n        Arrays.fill(dp1,1);\\n        Arrays.fill(dp2,1);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int prev=0;prev<=i-1;prev++)\\n            {\\n                if(nums[prev]<nums[i] && dp1[prev]+1>dp1[i])\\n                    dp1[i]=dp1[prev]+1;\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int prev=n-1;prev>i;prev--)\\n            {\\n                if(nums[prev]<nums[i] && dp2[prev]+1>dp2[i])\\n                    dp2[i]=dp2[prev]+1;\\n            }\\n        }\\n        int max=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp1[i]>1 && dp2[i]>1)\\n                max=(int)Math.max(max,(dp1[i]+dp2[i]-1));\\n        }\\n            \\n        return nums.length-max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205748,
                "title": "python-lis-from-left-and-right-and-combine-result-easy-understanding",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        LIS = [1] * N\\n        LDS = [1] * N\\n\\n        # Longest Increasing Subsequences from Left\\n        for i in range(N):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    LIS[i] = max(LIS[i], 1 + LIS[j])\\n        \\n        #Longest Increasing Subsequences from Right\\n        for i in range(N-1,-1,-1):\\n            for j in range(i+1, N):\\n                if nums[j] < nums[i]:\\n                    LDS[i] = max(LDS[i], 1 + LDS[j])\\n        \\n        ans = 1000\\n        for a,b in zip(LIS, LDS):\\n            if a == 1 or b == 1: continue\\n            else: ans = min(ans, N - a - b + 1)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        LIS = [1] * N\\n        LDS = [1] * N\\n\\n        # Longest Increasing Subsequences from Left\\n        for i in range(N):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    LIS[i] = max(LIS[i], 1 + LIS[j])\\n        \\n        #Longest Increasing Subsequences from Right\\n        for i in range(N-1,-1,-1):\\n            for j in range(i+1, N):\\n                if nums[j] < nums[i]:\\n                    LDS[i] = max(LDS[i], 1 + LDS[j])\\n        \\n        ans = 1000\\n        for a,b in zip(LIS, LDS):\\n            if a == 1 or b == 1: continue\\n            else: ans = min(ans, N - a - b + 1)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2865837,
                "title": "c-dp-longest-bitonic-subsequence-lbs-lis-lds",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing the Concept of Longest Bitonic Subsequence (LBS)\\n***Note*** - Bitonic subsequence is a subsequnce which is first strictly increasing and then strictly decreaseing eg like a mountain.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The minium number of elements to be removed from the array is equal to the length of array minus length of **Longest Bitonic Subsequence** of the array. i.e.\\n\\n    **min_removals = len(array) - len(LBS)**\\n\\n- To find the Longest Bitonic Subsequence of the array :\\n     - First We find the **Longest Increasing Subsequence**\\n     - Second, We find the **Longest Decreasing Subsequence.**\\n - In dynamic Programming Approach of finding LIS and LDS, We keep two arrays LIS[] and LDS[] where \\n --  **LIS[i]** stores the length of the longest LIS ending at arr[i].\\n --  **LDS[i]** stores the length of the longest LDS starting from arr[i].\\n- So the length of Longest Bitonic Sequence is the maximum value of \\n**(LDS[i] + LIS[i] -1)**\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // LONGEST INCREASING SUBSEQUENCE (LIS)\\n        int lis[n];\\n        lis[0]=1;\\n        for(int i=1 ; i<n ; i++){\\n            int max_end_here = 0;\\n            for(int j=0 ; j<i ; j++){\\n                if(nums[i] > nums[j]){\\n                    max_end_here = max(max_end_here , lis[j]);\\n                }\\n            }\\n            lis[i] = max_end_here +1;\\n        }\\n\\n        // LONGEST DECREASING SUBSEQUENCE (LDS)\\n        int lds[n];\\n        lds[n-1]=1;\\n        for(int i=n-2 ; i>=0 ; i--){\\n            int max_start_here =0 ;\\n            for(int j=i+1 ; j<n ; j++){\\n                if(nums[i] > nums[j]){\\n                    max_start_here = max(max_start_here , lds[j]);\\n                }\\n            }\\n            lds[i] = max_start_here+1;\\n        }\\n\\n        // finding length of LONGEST BITONIC SUBSEQUENCE (LBS)\\n        int lbs =INT_MIN;\\n        for(int i=0 ; i<n ; i++){\\n            // Check there are both LIS and LDS for an element.\\n            if(lis[i]>1 && lds[i]>1)\\n                lbs = max(lbs , lis[i]+lds[i]-1);\\n        }\\n\\n        // Minimum number of removals required\\n        return n-lbs;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // LONGEST INCREASING SUBSEQUENCE (LIS)\\n        int lis[n];\\n        lis[0]=1;\\n        for(int i=1 ; i<n ; i++){\\n            int max_end_here = 0;\\n            for(int j=0 ; j<i ; j++){\\n                if(nums[i] > nums[j]){\\n                    max_end_here = max(max_end_here , lis[j]);\\n                }\\n            }\\n            lis[i] = max_end_here +1;\\n        }\\n\\n        // LONGEST DECREASING SUBSEQUENCE (LDS)\\n        int lds[n];\\n        lds[n-1]=1;\\n        for(int i=n-2 ; i>=0 ; i--){\\n            int max_start_here =0 ;\\n            for(int j=i+1 ; j<n ; j++){\\n                if(nums[i] > nums[j]){\\n                    max_start_here = max(max_start_here , lds[j]);\\n                }\\n            }\\n            lds[i] = max_start_here+1;\\n        }\\n\\n        // finding length of LONGEST BITONIC SUBSEQUENCE (LBS)\\n        int lbs =INT_MIN;\\n        for(int i=0 ; i<n ; i++){\\n            // Check there are both LIS and LDS for an element.\\n            if(lis[i]>1 && lds[i]>1)\\n                lbs = max(lbs , lis[i]+lds[i]-1);\\n        }\\n\\n        // Minimum number of removals required\\n        return n-lbs;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771210,
                "title": "detailed-dp-explanation-with-comments",
                "content": "//please upvote if this solution is useful\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> lis(n,1); //longest increasing subsequence ending at index i\\n        vector<int> lds(n,1); //longest decreasing subsequence beggining at index i\\n        for(int i=0;i<n;i++){\\n            lis[i]=1;\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[j]<nums[i]) lis[i]=max(lis[i],1+lis[j]);\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            lds[i]=1;\\n            for(int j=i+1;j<n;j++){\\n                if(nums[j]<nums[i]) lds[i]=max(lds[i],1+lds[j]);\\n            }\\n        }\\n        int ans=1;\\n        for(int i=0;i<n;i++){\\n             if(lis[i]>1 && lds[i]>1) ans=max(ans,lis[i]+lds[i]-1);\\n        }\\n        cout<<ans;\\n        return n-ans;\\n    }\\n};\\n\\n/*\\n Solution:\\n 1) Find the length of the longest Bitonic Subsequence\\n 2) required ans=nums.size()-length of LBS\\n \\n LBS:\\n let l[i]=length of longest increasing subsequence ending at index i\\n let r[i]=length of lonngest decreasing subsequence beggining at index i\\n lbs[i]=l[i]+r[i]-1; only if l[i]>1 && r[i]>1\\n LBS=max_element(lbs);\\n \\n One imp observation:\\n We must make sure that when we are updating the ans then that index must have lis[i] and lds[i] both greater than 1\\n*/",
                "solutionTags": [
                    "C",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> lis(n,1); //longest increasing subsequence ending at index i\\n        vector<int> lds(n,1); //longest decreasing subsequence beggining at index i\\n        for(int i=0;i<n;i++){\\n            lis[i]=1;\\n            for(int j=i-1;j>=0;j--){\\n                if(nums[j]<nums[i]) lis[i]=max(lis[i],1+lis[j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2606876,
                "title": "java-easy-lis-bitonic-sequence",
                "content": "```\\nclass Solution {\\n    // Longest Bitonic subsequence\\n    public int minimumMountainRemovals(int[] arr) {\\n        int n = arr.length;\\n        \\n        int dp1[] = new int[n];\\n        int dp2[] = new int[n];\\n        Arrays.fill(dp1, 1);\\n        Arrays.fill(dp2, 1);\\n        \\n        for(int i = 0;i<n;i++){\\n            for(int j = 0; j<i;j++){\\n                if(arr[i] > arr[j] && dp1[i] < dp1[j]+1)\\n                    dp1[i] = dp1[j]+1;\\n            }\\n        }\\n        for(int i = n-1;i>=0;i--){\\n            for(int j = n-1; j>i;j--){\\n                if(arr[i] > arr[j] && dp2[i] < dp2[j]+1)\\n                    dp2[i] = dp2[j]+1;\\n            }\\n        }\\n        int max =1;\\n         for(int i = 0;i<n;i++){\\n             if(dp1[i] > 1 && dp2[i] > 1) // checking monotonic increasing or decreasing\\n            max = Math.max(max, dp1[i]+dp2[i]-1);\\n        }\\n        return arr.length-max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    // Longest Bitonic subsequence\\n    public int minimumMountainRemovals(int[] arr) {\\n        int n = arr.length;\\n        \\n        int dp1[] = new int[n];\\n        int dp2[] = new int[n];\\n        Arrays.fill(dp1, 1);\\n        Arrays.fill(dp2, 1);\\n        \\n        for(int i = 0;i<n;i++){\\n            for(int j = 0; j<i;j++){\\n                if(arr[i] > arr[j] && dp1[i] < dp1[j]+1)\\n                    dp1[i] = dp1[j]+1;\\n            }\\n        }\\n        for(int i = n-1;i>=0;i--){\\n            for(int j = n-1; j>i;j--){\\n                if(arr[i] > arr[j] && dp2[i] < dp2[j]+1)\\n                    dp2[i] = dp2[j]+1;\\n            }\\n        }\\n        int max =1;\\n         for(int i = 0;i<n;i++){\\n             if(dp1[i] > 1 && dp2[i] > 1) // checking monotonic increasing or decreasing\\n            max = Math.max(max, dp1[i]+dp2[i]-1);\\n        }\\n        return arr.length-max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522207,
                "title": "c-extension-of-bitonic-subsequence-clean-short",
                "content": "![image](https://assets.leetcode.com/users/images/25c286c7-9745-4a13-ab49-442f4ae35378_1662183963.9399962.png)\\n\\n**T->O(n^2) && S->O(n)**\\n\\n***This question is the extension of Bitonic sequence. In this question we just have to think in opposite manner that instead of finding the min elements to be removed we must find the max elements that can be included in the mountain array AKA Bitonic subsequence.***\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumMountainRemovals(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tvector<int>dp1(n,1),dp2(n,1),sum(n);\\n\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\tfor(int prev=0;prev<i;prev++){\\n\\t\\t\\t\\t\\tif(nums[i]>nums[prev] && 1+dp1[prev]>dp1[i]) dp1[i]=1+dp1[prev];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=n-2;i>=0;i--){\\n\\t\\t\\t\\tfor(int prev=n-1;prev>i;prev--){\\n\\t\\t\\t\\t\\tif(nums[i]>nums[prev] && 1+dp2[prev]>dp2[i]) dp2[i]=1+dp2[prev];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tif(dp1[i]!=1 && dp2[i]!=1)sum[i]=dp1[i]+dp2[i];\\n\\t\\t\\t}        \\n\\t\\t\\treturn n-(*max_element(sum.begin(),sum.end())-1);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minimumMountainRemovals(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tvector<int>dp1(n,1),dp2(n,1),sum(n);\\n\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\tfor(int prev=0;prev<i;prev++){\\n\\t\\t\\t\\t\\tif(nums[i]>nums[prev] && 1+dp1[prev]>dp1[i]) dp1[i]=1+dp1[prev];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2495913,
                "title": "c-lis-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp1(n,1);  //to calculate LIS from the left side\\n\\n        int maxi = 1;\\n\\n        for(int i=1; i<=n-1; i++){\\n\\n            for(int prev_index = 0; prev_index <= i-1; prev_index ++){\\n\\n                if( nums[i]>nums[prev_index] && 1 + dp1[prev_index] > dp1[i]){\\n                    dp1[i] = 1 + dp1[prev_index]; //dp1[i] stores the length of LIS till the ith index from left\\n                }\\n            }\\n        }\\n        \\n        vector<int> dp2(n,1);   //to calculate LIS from the right side\\n        for(int i=n-2; i>=0; i--){\\n\\n            for(int prev_index = n-1; prev_index >i; prev_index --){\\n\\n                if( nums[i]>nums[prev_index] && 1 + dp2[prev_index] > dp2[i]){ \\n                    dp2[i] = 1 + dp2[prev_index]; //dp2[i] stores the length of LIS till the ith index from right\\n                }\\n            }\\n        }\\n       \\n        for(int i=1;i<n-1;i++){\\n            if(dp1[i]>1&&dp2[i]>1)    //validity of peak\\n                maxi=max(maxi,dp1[i]+dp2[i]-1);    // -1 because the middle element(peak) gets considered twice\\n        }\\n      \\n        return n-maxi;   //maxi follows the mountain array so we need to remove the rest elements\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp1(n,1);  //to calculate LIS from the left side\\n\\n        int maxi = 1;\\n\\n        for(int i=1; i<=n-1; i++){\\n\\n            for(int prev_index = 0; prev_index <= i-1; prev_index ++){\\n\\n                if( nums[i]>nums[prev_index] && 1 + dp1[prev_index] > dp1[i]){\\n                    dp1[i] = 1 + dp1[prev_index]; //dp1[i] stores the length of LIS till the ith index from left\\n                }\\n            }\\n        }\\n        \\n        vector<int> dp2(n,1);   //to calculate LIS from the right side\\n        for(int i=n-2; i>=0; i--){\\n\\n            for(int prev_index = n-1; prev_index >i; prev_index --){\\n\\n                if( nums[i]>nums[prev_index] && 1 + dp2[prev_index] > dp2[i]){ \\n                    dp2[i] = 1 + dp2[prev_index]; //dp2[i] stores the length of LIS till the ith index from right\\n                }\\n            }\\n        }\\n       \\n        for(int i=1;i<n-1;i++){\\n            if(dp1[i]>1&&dp2[i]>1)    //validity of peak\\n                maxi=max(maxi,dp1[i]+dp2[i]-1);    // -1 because the middle element(peak) gets considered twice\\n        }\\n      \\n        return n-maxi;   //maxi follows the mountain array so we need to remove the rest elements\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454663,
                "title": "using-lis-and-lds-in-linear-time",
                "content": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) \\n    {\\n        int[] lis=new int[nums.length];\\n        int[] lds=new int[nums.length];\\n        \\n        lis[0]=1; \\n        lds[nums.length-1]=1;\\n        \\n        for(int i=1;i<nums.length;i++)\\n        {\\n            int max=0;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[j]<nums[i])\\n                {\\n                    if(lis[j]>max)\\n                    {\\n                        max=lis[j];\\n                    }\\n                }\\n            }\\n            lis[i]=max+1;\\n        }\\n        for(int i=nums.length-2;i>=0;i--)\\n        {\\n            int max=0;\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                if(nums[j]<nums[i])\\n                {\\n                    if(lds[j]>max)\\n                    {\\n                        max=lds[j];\\n                    }\\n                }\\n            }\\n            lds[i]=max+1;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(lis[i]>=2 && lds[i]>=2)\\n            {\\n                ans=Math.max(ans,lis[i]+lds[i]-1);\\n            }\\n        }\\n        \\n        return nums.length-ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) \\n    {\\n        int[] lis=new int[nums.length];\\n        int[] lds=new int[nums.length];\\n        \\n        lis[0]=1; \\n        lds[nums.length-1]=1;\\n        \\n        for(int i=1;i<nums.length;i++)\\n        {\\n            int max=0;\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[j]<nums[i])\\n                {\\n                    if(lis[j]>max)\\n                    {\\n                        max=lis[j];\\n                    }\\n                }\\n            }\\n            lis[i]=max+1;\\n        }\\n        for(int i=nums.length-2;i>=0;i--)\\n        {\\n            int max=0;\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                if(nums[j]<nums[i])\\n                {\\n                    if(lds[j]>max)\\n                    {\\n                        max=lds[j];\\n                    }\\n                }\\n            }\\n            lds[i]=max+1;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(lis[i]>=2 && lds[i]>=2)\\n            {\\n                ans=Math.max(ans,lis[i]+lds[i]-1);\\n            }\\n        }\\n        \\n        return nums.length-ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337575,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& v) {\\n     int n=v.size();\\n    if(n<=1)return 0;\\n    vector<int>a(n),b(n),inc(n+1,INT_MAX),dec(n+1,INT_MAX);\\n    inc[0]=INT_MIN;\\n    dec[0]=INT_MIN;\\n    for(int i=0;i<n;i++){\\n        int idx=lower_bound(inc.begin(),inc.end(),v[i])-inc.begin();\\n        a[i]=idx-1;\\n        inc[idx]=v[i];\\n    }\\n    for(int i=n-1;i>=0;i--){\\n        int idx=lower_bound(dec.begin(),dec.end(),v[i])-dec.begin();\\n        b[i]=idx-1;\\n        dec[idx]=v[i];\\n    }\\n    int ans=INT_MAX;\\n    for(int i=0;i<n;i++){\\n        if(a[i]&&b[i])ans=min(ans,n-(a[i]+b[i]+1));\\n    }\\n    return ans;   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& v) {\\n     int n=v.size();\\n    if(n<=1)return 0;\\n    vector<int>a(n),b(n),inc(n+1,INT_MAX),dec(n+1,INT_MAX);\\n    inc[0]=INT_MIN;\\n    dec[0]=INT_MIN;\\n    for(int i=0;i<n;i++){\\n        int idx=lower_bound(inc.begin(),inc.end(),v[i])-inc.begin();\\n        a[i]=idx-1;\\n        inc[idx]=v[i];\\n    }\\n    for(int i=n-1;i>=0;i--){\\n        int idx=lower_bound(dec.begin(),dec.end(),v[i])-dec.begin();\\n        b[i]=idx-1;\\n        dec[idx]=v[i];\\n    }\\n    int ans=INT_MAX;\\n    for(int i=0;i<n;i++){\\n        if(a[i]&&b[i])ans=min(ans,n-(a[i]+b[i]+1));\\n    }\\n    return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2225366,
                "title": "c-lis-dp-o-n-log-n-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n+1, 1000000000);\\n        vector<int> LIS1(n,0);\\n        vector<int> LIS2(n,0);\\n        for(int i = 0;i<n;++i)\\n        {\\n            int idx = lower_bound(dp.begin(),dp.end(),nums[i])-dp.begin(); // seach for the correct position for nums[i]\\n            LIS1[i] = idx+1; // current LIS ending with index i is idx +1 as lower_bound is 0 based \\n            dp[idx] = nums[i]; //override the element at dp[idx] with nums[i] \\n        }\\n        fill(dp.begin(),dp.end(),1000000000); // re-fill our dp array with maximum value\\n        for(int i = n-1;i>=0;--i) // instead of LDS we can apply the same logic above which is LIS but starting from the end of the array\\n        {\\n            int idx = lower_bound(dp.begin(),dp.end(),nums[i])-dp.begin(); \\n            LIS2[i] = idx+1;\\n            dp[idx] = nums[i];\\n        }\\n        int ans = 0;\\n        for(int i = 0;i <n;++i)\\n            if(LIS1[i]>=2 && LIS2[i]>=2) // we are assuming that this index is the current peak but if one of the peaks length is 1 so it can\\'t be a peak \\n                ans = max(ans,LIS1[i]+LIS2[i]-1);\\n        \\n        return n-ans; // we found the LIS so we need to subtract it from the length of the total numbers to get the mountain\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n+1, 1000000000);\\n        vector<int> LIS1(n,0);\\n        vector<int> LIS2(n,0);\\n        for(int i = 0;i<n;++i)\\n        {\\n            int idx = lower_bound(dp.begin(),dp.end(),nums[i])-dp.begin(); // seach for the correct position for nums[i]\\n            LIS1[i] = idx+1; // current LIS ending with index i is idx +1 as lower_bound is 0 based \\n            dp[idx] = nums[i]; //override the element at dp[idx] with nums[i] \\n        }\\n        fill(dp.begin(),dp.end(),1000000000); // re-fill our dp array with maximum value\\n        for(int i = n-1;i>=0;--i) // instead of LDS we can apply the same logic above which is LIS but starting from the end of the array\\n        {\\n            int idx = lower_bound(dp.begin(),dp.end(),nums[i])-dp.begin(); \\n            LIS2[i] = idx+1;\\n            dp[idx] = nums[i];\\n        }\\n        int ans = 0;\\n        for(int i = 0;i <n;++i)\\n            if(LIS1[i]>=2 && LIS2[i]>=2) // we are assuming that this index is the current peak but if one of the peaks length is 1 so it can\\'t be a peak \\n                ans = max(ans,LIS1[i]+LIS2[i]-1);\\n        \\n        return n-ans; // we found the LIS so we need to subtract it from the length of the total numbers to get the mountain\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175866,
                "title": "c-lis-prefix-lds-suffix-o-nlogn-solution",
                "content": "We create two arrays `prefix` and `suffix` such that `prefix[i]` indicates length of `Longest Increasing Subsequence`  starting from `0` and ending at `i`, and `suffix[i]` indicates length of `Longest Decreasing Subsequence` starting from `i` and ending at `n-1`. Let us assume that the peak of the mountain is at `i`. Then the number of letters to be removed will be `n - (prefix[i] + suffix[i] - 1)`. We will find minimum of all the possible `i`.\\n* Note that the mountain has at least one element on its left and right of the peak. So we will only consider indices `i` such that `prefix[i] >= 2 && suffix[i] >= 2`.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximum(int a, int b){\\n        return a > b ? a : b;\\n    }\\n    int minimum(int a, int b){\\n        return a < b ? a : b;\\n    }\\n    vector<int> longestIncreasingSubsequence(vector<int>& nums){\\n        int n = nums.size(), index;\\n        vector<int> LIS, ans(n);\\n        LIS.push_back(nums[0]);\\n        ans[0] = 1;\\n        for(int i = 1; i < n; i++){\\n            if(nums[i] < LIS[0]){\\n                LIS[0] = nums[i];\\n                ans[i] = 1;\\n            }\\n            else if(LIS.back() < nums[i]){\\n                LIS.push_back(nums[i]);\\n                ans[i] = LIS.size();\\n            }\\n            else{\\n                index = lower_bound(LIS.begin(), LIS.end(), nums[i]) - LIS.begin();\\n                LIS[index] = nums[i];\\n                ans[i] = index+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> prefix = longestIncreasingSubsequence(nums);\\n        reverse(nums.begin(), nums.end());\\n        vector<int> suffix = longestIncreasingSubsequence(nums);\\n        reverse(suffix.begin(), suffix.end());\\n        int ans = n;\\n        for(int i = 1; i < n-1; i++){\\n            if(prefix[i] >= 2 && suffix[i] >= 2){\\n                ans = minimum(ans, n+1-(prefix[i]+suffix[i]));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximum(int a, int b){\\n        return a > b ? a : b;\\n    }\\n    int minimum(int a, int b){\\n        return a < b ? a : b;\\n    }\\n    vector<int> longestIncreasingSubsequence(vector<int>& nums){\\n        int n = nums.size(), index;\\n        vector<int> LIS, ans(n);\\n        LIS.push_back(nums[0]);\\n        ans[0] = 1;\\n        for(int i = 1; i < n; i++){\\n            if(nums[i] < LIS[0]){\\n                LIS[0] = nums[i];\\n                ans[i] = 1;\\n            }\\n            else if(LIS.back() < nums[i]){\\n                LIS.push_back(nums[i]);\\n                ans[i] = LIS.size();\\n            }\\n            else{\\n                index = lower_bound(LIS.begin(), LIS.end(), nums[i]) - LIS.begin();\\n                LIS[index] = nums[i];\\n                ans[i] = index+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> prefix = longestIncreasingSubsequence(nums);\\n        reverse(nums.begin(), nums.end());\\n        vector<int> suffix = longestIncreasingSubsequence(nums);\\n        reverse(suffix.begin(), suffix.end());\\n        int ans = n;\\n        for(int i = 1; i < n-1; i++){\\n            if(prefix[i] >= 2 && suffix[i] >= 2){\\n                ans = minimum(ans, n+1-(prefix[i]+suffix[i]));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171761,
                "title": "c-lis-lds-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& a) {\\n        int n = a.size();\\n        vector<int> dp1(n, 1);          \\n        //LIS form front\\n        for(int i=0; i<n; i++){\\n            for(int prev=0; prev<i; prev++){\\n                if(a[i]>a[prev] && dp1[i] < 1 + dp1[prev] ){\\n                    dp1[i] = 1 + dp1[prev];\\n                }\\n            }\\n        }\\n        \\n        vector<int> dp2(n, 1);          \\n        //LIS form back or LDS\\n        for(int i = n-1; i>=0; i--){\\n            for(int prev = n-1; prev>i; prev--){\\n                if(a[i]>a[prev] && dp2[i] < 1 + dp2[prev] ){\\n                    dp2[i] = 1 + dp2[prev];\\n                }\\n            }\\n        }\\n        \\n        int maxi = 0;\\n        for(int i = 0; i<n; i++){\\n            if(dp1[i]>1 && dp2[i]>1){\\n                maxi = max(maxi, dp1[i]+dp2[i]-1);\\n            }\\n        }\\n        return n-maxi;\\n    }\\n};\\n```\\nTC O[N^2]  &&  SC O[N]",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& a) {\\n        int n = a.size();\\n        vector<int> dp1(n, 1);          \\n        //LIS form front\\n        for(int i=0; i<n; i++){\\n            for(int prev=0; prev<i; prev++){\\n                if(a[i]>a[prev] && dp1[i] < 1 + dp1[prev] ){\\n                    dp1[i] = 1 + dp1[prev];\\n                }\\n            }\\n        }\\n        \\n        vector<int> dp2(n, 1);          \\n        //LIS form back or LDS\\n        for(int i = n-1; i>=0; i--){\\n            for(int prev = n-1; prev>i; prev--){\\n                if(a[i]>a[prev] && dp2[i] < 1 + dp2[prev] ){\\n                    dp2[i] = 1 + dp2[prev];\\n                }\\n            }\\n        }\\n        \\n        int maxi = 0;\\n        for(int i = 0; i<n; i++){\\n            if(dp1[i]>1 && dp2[i]>1){\\n                maxi = max(maxi, dp1[i]+dp2[i]-1);\\n            }\\n        }\\n        return n-maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169252,
                "title": "c-lis-o-nlog-n-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(int arr[],int l,int r,int x){\\n        while(r>l){\\n            int m= l+(r-l)/2;\\n            if(arr[m]>=x){\\n                r=m;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return r;\\n    }\\n    int he(vector<int>nums,vector<int>&dp){\\n        int tail[nums.size()];\\n        tail[0]=nums[0];int len=1;\\n        for(int i=0;i<nums.size();i++){\\n             if(nums[i]>tail[len-1]){\\n                tail[len]=nums[i];len++;dp[i]=len;\\n            }\\n            else{\\n                int x=helper(tail,0,len-1,nums[i]);\\n                tail[x]=nums[i];dp[i]=x+1;\\n            }\\n        }\\n        return 0;\\n    }\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        vector<int>dp(nums.size(),1),dp1(nums.size(),1);\\n        he(nums,dp);\\n        reverse(nums.begin(),nums.end());\\n        he(nums,dp1);int x=0;\\n        for(int i=1;i<nums.size()-1;i++){\\n            if(dp[i]!=1&&dp1[nums.size()-i-1]!=1){\\n                x=max(x,dp[i]+dp1[nums.size()-i-1]-1);\\n            }\\n        }\\n        return nums.size()-x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int arr[],int l,int r,int x){\\n        while(r>l){\\n            int m= l+(r-l)/2;\\n            if(arr[m]>=x){\\n                r=m;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return r;\\n    }\\n    int he(vector<int>nums,vector<int>&dp){\\n        int tail[nums.size()];\\n        tail[0]=nums[0];int len=1;\\n        for(int i=0;i<nums.size();i++){\\n             if(nums[i]>tail[len-1]){\\n                tail[len]=nums[i];len++;dp[i]=len;\\n            }\\n            else{\\n                int x=helper(tail,0,len-1,nums[i]);\\n                tail[x]=nums[i];dp[i]=x+1;\\n            }\\n        }\\n        return 0;\\n    }\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        vector<int>dp(nums.size(),1),dp1(nums.size(),1);\\n        he(nums,dp);\\n        reverse(nums.begin(),nums.end());\\n        he(nums,dp1);int x=0;\\n        for(int i=1;i<nums.size()-1;i++){\\n            if(dp[i]!=1&&dp1[nums.size()-i-1]!=1){\\n                x=max(x,dp[i]+dp1[nums.size()-i-1]-1);\\n            }\\n        }\\n        return nums.size()-x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166930,
                "title": "c-longest-increasing-subsequence-solution-in-o-n-log-n",
                "content": "**Explanation**:\\n\\n- question based on largest increasing subsequence, decreasing subsequence.\\n- at every step, store the length of largest increasing & decreasing subsequence.\\n- for a mountain to become we should always have largest increasing index & decreasing value greater than 1. means we need at least one element on left and one element on the right of the peak. if this condition is not met, then numbers can\\'t form increasing subsequence.\\n- for finding the answer, check posibility of each number being peak. and find out lenght of mountain array.\\n\\n**Space complexity**: $O(1)$\\n**time complexity**: $O(n)$\\n\\n```cpp\\n\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums)\\n    {\\n        vector<int> left, right, temp;\\n        int n = nums.size();\\n\\n        // longest increasing subsequence.\\n        for (int i = 0; i < n; i++) {\\n            if (temp.size() == 0 || temp.back() < nums[i]) {\\n                temp.push_back(nums[i]);\\n                left.push_back(temp.size());\\n            } else {\\n                auto idx = lower_bound(temp.begin(), temp.end(), nums[i]);\\n                if (idx != temp.end()) {\\n                    *idx = nums[i];\\n                }\\n                left.push_back(idx - temp.begin() + 1);\\n            }\\n        }\\n\\n        temp.clear();\\n\\n        // longest decreasing subsequence.\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (temp.empty() || temp.back() < nums[i]) {\\n                temp.push_back(nums[i]);\\n                right.push_back(temp.size());\\n            } else {\\n                auto idx = lower_bound(temp.begin(), temp.end(), nums[i]);\\n                if (idx != temp.end()) {\\n                    *idx = nums[i];\\n                }\\n                right.push_back(idx - temp.begin() + 1);\\n            }\\n        }\\n\\n        reverse(right.begin(), right.end());\\n\\n        int answer = INT_MAX;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (left[i] > 1 && right[i] > 1) {\\n                answer = min(answer, (n - (left[i] + right[i] - 1)));\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\n\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums)\\n    {\\n        vector<int> left, right, temp;\\n        int n = nums.size();\\n\\n        // longest increasing subsequence.\\n        for (int i = 0; i < n; i++) {\\n            if (temp.size() == 0 || temp.back() < nums[i]) {\\n                temp.push_back(nums[i]);\\n                left.push_back(temp.size());\\n            } else {\\n                auto idx = lower_bound(temp.begin(), temp.end(), nums[i]);\\n                if (idx != temp.end()) {\\n                    *idx = nums[i];\\n                }\\n                left.push_back(idx - temp.begin() + 1);\\n            }\\n        }\\n\\n        temp.clear();\\n\\n        // longest decreasing subsequence.\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (temp.empty() || temp.back() < nums[i]) {\\n                temp.push_back(nums[i]);\\n                right.push_back(temp.size());\\n            } else {\\n                auto idx = lower_bound(temp.begin(), temp.end(), nums[i]);\\n                if (idx != temp.end()) {\\n                    *idx = nums[i];\\n                }\\n                right.push_back(idx - temp.begin() + 1);\\n            }\\n        }\\n\\n        reverse(right.begin(), right.end());\\n\\n        int answer = INT_MAX;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (left[i] > 1 && right[i] > 1) {\\n                answer = min(answer, (n - (left[i] + right[i] - 1)));\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109868,
                "title": "c-easy-to-understand-lis",
                "content": "Just find the LIS from the left and the right, then just find the best index **i**. Make sure the length of 2 LIS greater or equal 2.\\n```\\nclass Solution {\\n public:\\n  int minimumMountainRemovals(vector<int>& nums) {\\n    int n = nums.size();\\n    vector<int> leftLIS(n, 0), rightLIS(n, 0);\\n    // Find the left LIS\\n    for (int i = 0; i < n; i++) {\\n      int bestVal = 0;\\n      for (int j = i - 1; j >= 0; j--) {\\n        if (nums[i] > nums[j] && leftLIS[j] > bestVal) {\\n          bestVal = leftLIS[j];\\n        }\\n      }\\n      leftLIS[i] = bestVal + 1;\\n    }\\n    // Find the right LIS\\n    for (int i = n - 1; i >= 0; i--) {\\n      int bestVal = 0;\\n      for (int j = i + 1; j < n; j++) {\\n        if (nums[i] > nums[j] && rightLIS[j] > bestVal) {\\n          bestVal = rightLIS[j];\\n        }\\n      }\\n      rightLIS[i] = bestVal + 1;\\n    }\\n    int result = INT_MAX;\\n    for (int i = 1; i < n - 1; i++) {\\n      result = min(result, n - (leftLIS[i] + rightLIS[i] - 1));\\n    }\\n    return result;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  int minimumMountainRemovals(vector<int>& nums) {\\n    int n = nums.size();\\n    vector<int> leftLIS(n, 0), rightLIS(n, 0);\\n    // Find the left LIS\\n    for (int i = 0; i < n; i++) {\\n      int bestVal = 0;\\n      for (int j = i - 1; j >= 0; j--) {\\n        if (nums[i] > nums[j] && leftLIS[j] > bestVal) {\\n          bestVal = leftLIS[j];\\n        }\\n      }\\n      leftLIS[i] = bestVal + 1;\\n    }\\n    // Find the right LIS\\n    for (int i = n - 1; i >= 0; i--) {\\n      int bestVal = 0;\\n      for (int j = i + 1; j < n; j++) {\\n        if (nums[i] > nums[j] && rightLIS[j] > bestVal) {\\n          bestVal = rightLIS[j];\\n        }\\n      }\\n      rightLIS[i] = bestVal + 1;\\n    }\\n    int result = INT_MAX;\\n    for (int i = 1; i < n - 1; i++) {\\n      result = min(result, n - (leftLIS[i] + rightLIS[i] - 1));\\n    }\\n    return result;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104550,
                "title": "o-n-logn-time-and-o-n-space",
                "content": "The idea is that we calculate longgest increasing subset end at the position i(inc[i]) and longgest decreasing subset start at the position dec[i] using binary search. Then we scan the array and we can find the answer.\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        vector<int> inc(nums.size()), dec(nums.size()), v;\\n        inc[0] = 1;\\n        dec[nums.size() - 1] = 1;\\n        v.push_back(nums[0]);\\n        for(int i = 1; i < nums.size(); i++){\\n            if(nums[i] > v.back()){\\n                v.push_back(nums[i]);\\n                inc[i] = v.size();\\n            }\\n            else{\\n                int s = 0, e = v.size() - 1;\\n                while(s < e){\\n                    int mid = (s+e)/2;\\n                    if(v[mid] >= nums[i]){\\n                        e = mid;\\n                    }\\n                    else\\n                        s = mid + 1;\\n                }\\n                inc[i] = s + 1;\\n                v[s] = nums[i];\\n            }\\n        }\\n        v.clear();\\n        v.push_back(nums.back());\\n        for(int i = nums.size() - 2; i > - 1; i--){\\n            if(nums[i] > v.back()){\\n                v.push_back(nums[i]);\\n                dec[i] = v.size();\\n            }\\n            else{\\n                int s = 0, e = v.size() - 1;\\n                while(s < e){\\n                    int mid = (s+e)/2;\\n                    if(v[mid] >= nums[i]){\\n                        e = mid;\\n                    }\\n                    else\\n                        s = mid + 1;\\n                }\\n                dec[i] = s + 1;\\n                v[s] = nums[i];\\n            }\\n        }\\n        int m = 0;\\n    //conside i the middle\\n    for(int i=1; i<nums.size()-1; i++) {\\n        if(inc[i]>1 && dec[i]>1) {\\n            int ans = inc[i]+dec[i]-1;\\n            m = max(m, ans);\\n        }\\n    }\\n        return nums.size() - m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        vector<int> inc(nums.size()), dec(nums.size()), v;\\n        inc[0] = 1;\\n        dec[nums.size() - 1] = 1;\\n        v.push_back(nums[0]);\\n        for(int i = 1; i < nums.size(); i++){\\n            if(nums[i] > v.back()){\\n                v.push_back(nums[i]);\\n                inc[i] = v.size();\\n            }\\n            else{\\n                int s = 0, e = v.size() - 1;\\n                while(s < e){\\n                    int mid = (s+e)/2;\\n                    if(v[mid] >= nums[i]){\\n                        e = mid;\\n                    }\\n                    else\\n                        s = mid + 1;\\n                }\\n                inc[i] = s + 1;\\n                v[s] = nums[i];\\n            }\\n        }\\n        v.clear();\\n        v.push_back(nums.back());\\n        for(int i = nums.size() - 2; i > - 1; i--){\\n            if(nums[i] > v.back()){\\n                v.push_back(nums[i]);\\n                dec[i] = v.size();\\n            }\\n            else{\\n                int s = 0, e = v.size() - 1;\\n                while(s < e){\\n                    int mid = (s+e)/2;\\n                    if(v[mid] >= nums[i]){\\n                        e = mid;\\n                    }\\n                    else\\n                        s = mid + 1;\\n                }\\n                dec[i] = s + 1;\\n                v[s] = nums[i];\\n            }\\n        }\\n        int m = 0;\\n    //conside i the middle\\n    for(int i=1; i<nums.size()-1; i++) {\\n        if(inc[i]>1 && dec[i]>1) {\\n            int ans = inc[i]+dec[i]-1;\\n            m = max(m, ans);\\n        }\\n    }\\n        return nums.size() - m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2059441,
                "title": "c-lis-dp-bitonic-subsequence",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp1(n+1,1),dp2(n+1,1),bito(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j] && 1+dp1[j]>dp1[i])\\n                {\\n                    dp1[i]=1+dp1[j];\\n                }\\n            }\\n        }\\n        \\n         for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[i]>nums[j] && 1+dp2[j]>dp2[i])\\n                {\\n                    dp2[i]=1+dp2[j];\\n                }\\n            }\\n        }\\n        int temp=0;\\n        for(int i=0;i<n+1;i++)\\n        {\\n            if(dp1[i]>1&&dp2[i]>1)\\n                 temp=max(temp,dp1[i]+dp2[i]-1);\\n        }\\n        cout<<temp<<\" \";\\n        return n-temp;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp1(n+1,1),dp2(n+1,1),bito(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j] && 1+dp1[j]>dp1[i])\\n                {\\n                    dp1[i]=1+dp1[j];\\n                }\\n            }\\n        }\\n        \\n         for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(nums[i]>nums[j] && 1+dp2[j]>dp2[i])\\n                {\\n                    dp2[i]=1+dp2[j];\\n                }\\n            }\\n        }\\n        int temp=0;\\n        for(int i=0;i<n+1;i++)\\n        {\\n            if(dp1[i]>1&&dp2[i]>1)\\n                 temp=max(temp,dp1[i]+dp2[i]-1);\\n        }\\n        cout<<temp<<\" \";\\n        return n-temp;        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1857308,
                "title": "python-two-liss-99-faster-simple-logic",
                "content": "left[i] means length of the longest strictly increasing subsequence that ends at nums[i]\\n```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        def LIS(nums):\\n            longest = []\\n            res = []\\n            for x in nums:\\n                if not res or longest[-1] < x:\\n                    longest.append(x)\\n                    res.append(len(longest))\\n                else:\\n                    idx = bisect_left(longest,x)\\n                    longest[idx] = x\\n                    res.append(idx+1)\\n            return res\\n        left = LIS(nums)\\n        right = LIS(nums[::-1])\\n        res = float(\\'inf\\')\\n        n = len(nums)\\n        for i in range(1,len(nums)-1):\\n            res = min(res, n-(left[i] + right[-i-1] - 1) if left[i]>=2 and right[-i-1]>=2 else float(\\'inf\\'))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        def LIS(nums):\\n            longest = []\\n            res = []\\n            for x in nums:\\n                if not res or longest[-1] < x:\\n                    longest.append(x)\\n                    res.append(len(longest))\\n                else:\\n                    idx = bisect_left(longest,x)\\n                    longest[idx] = x\\n                    res.append(idx+1)\\n            return res\\n        left = LIS(nums)\\n        right = LIS(nums[::-1])\\n        res = float(\\'inf\\')\\n        n = len(nums)\\n        for i in range(1,len(nums)-1):\\n            res = min(res, n-(left[i] + right[-i-1] - 1) if left[i]>=2 and right[-i-1]>=2 else float(\\'inf\\'))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729769,
                "title": "java-dp-solution-using-lis-with-comments",
                "content": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        \\n        // LIS(i) = longest increasing subsequence ending at index i\\n        \\n        int n = nums.length;\\n        int[] leftIncreasing = new int[n];\\n        int[] rightIncreasing = new int[n];\\n        \\n        // Base Cases\\n        leftIncreasing[0] = 1;\\n        rightIncreasing[n-1] = 1;\\n        \\n        // Computing LIS from left to right\\n        for(int i = 1; i < n; i++){\\n            leftIncreasing[i] = 1;\\n            \\n            for(int j = 0; j < i; j++){\\n                \\n                if(nums[j] < nums[i] && leftIncreasing[j] + 1 > leftIncreasing[i]){\\n                    leftIncreasing[i] = leftIncreasing[j] + 1;\\n                }\\n            }        \\n        }\\n        \\n        // Computing LIS from right to left\\n        \\n        for(int i = n - 2; i > -1; i--){\\n            rightIncreasing[i] = 1;\\n            \\n            for(int j = n - 1; j > i; j--){\\n                \\n                if(nums[i] > nums[j] && rightIncreasing[j] + 1 > rightIncreasing[i]){\\n                    rightIncreasing[i] = rightIncreasing[j] + 1;\\n                }\\n            }\\n        }\\n        \\n        \\n        //adding the length of LIS from left and right at index i and subtracting 1\\n        //gives  length of mountain array with its peek at i\\n        // we need to find the maxLength of a MountainArray\\n        \\n        int maxLenMountainArray = 0;\\n        \\n        \\n        // the first and last element can obviously not be a peek since they don\\'t fulfill the property\\n        // i.e: resulting mountain would be only ascending or descending\\n        // one of LIS cannot be 1 since that would mean that LIS starts and ends there. i.e same as described above \\n        \\n        for(int i = 1; i < n - 1; i++){\\n            if(!(leftIncreasing[i] == 1 || rightIncreasing[i] == 1)){\\n                 if(leftIncreasing[i] + rightIncreasing[i] > maxLenMountainArray){\\n                    maxLenMountainArray = leftIncreasing[i] + rightIncreasing[i] - 1;\\n                }\\n            }           \\n        }\\n        \\n        // the number of deletions is length of nums - length of mountain array\\n        \\n        return n - maxLenMountainArray;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        \\n        // LIS(i) = longest increasing subsequence ending at index i\\n        \\n        int n = nums.length;\\n        int[] leftIncreasing = new int[n];\\n        int[] rightIncreasing = new int[n];\\n        \\n        // Base Cases\\n        leftIncreasing[0] = 1;\\n        rightIncreasing[n-1] = 1;\\n        \\n        // Computing LIS from left to right\\n        for(int i = 1; i < n; i++){\\n            leftIncreasing[i] = 1;\\n            \\n            for(int j = 0; j < i; j++){\\n                \\n                if(nums[j] < nums[i] && leftIncreasing[j] + 1 > leftIncreasing[i]){\\n                    leftIncreasing[i] = leftIncreasing[j] + 1;\\n                }\\n            }        \\n        }\\n        \\n        // Computing LIS from right to left\\n        \\n        for(int i = n - 2; i > -1; i--){\\n            rightIncreasing[i] = 1;\\n            \\n            for(int j = n - 1; j > i; j--){\\n                \\n                if(nums[i] > nums[j] && rightIncreasing[j] + 1 > rightIncreasing[i]){\\n                    rightIncreasing[i] = rightIncreasing[j] + 1;\\n                }\\n            }\\n        }\\n        \\n        \\n        //adding the length of LIS from left and right at index i and subtracting 1\\n        //gives  length of mountain array with its peek at i\\n        // we need to find the maxLength of a MountainArray\\n        \\n        int maxLenMountainArray = 0;\\n        \\n        \\n        // the first and last element can obviously not be a peek since they don\\'t fulfill the property\\n        // i.e: resulting mountain would be only ascending or descending\\n        // one of LIS cannot be 1 since that would mean that LIS starts and ends there. i.e same as described above \\n        \\n        for(int i = 1; i < n - 1; i++){\\n            if(!(leftIncreasing[i] == 1 || rightIncreasing[i] == 1)){\\n                 if(leftIncreasing[i] + rightIncreasing[i] > maxLenMountainArray){\\n                    maxLenMountainArray = leftIncreasing[i] + rightIncreasing[i] - 1;\\n                }\\n            }           \\n        }\\n        \\n        // the number of deletions is length of nums - length of mountain array\\n        \\n        return n - maxLenMountainArray;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722955,
                "title": "python3-time-complexity-o-n-2",
                "content": "```\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        n = len(nums)        \\n        left = [0 for i in range(n)]\\n        right = [0 for i in range(n)]\\n        \\n        for i in range(1, n):\\n            val = 0 \\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    val = max(val, left[j] + 1)\\n        \\n            left[i] = val\\n            \\n        for i in range(n - 2, -1, -1):\\n            val = 0 \\n            for j in range(i + 1, n):\\n                if nums[j] < nums[i]:\\n                    val = max(val, right[j] + 1)\\n            \\n            right[i] = val\\n            \\n        ans = inf\\n        \\n        for i in range(1, n - 1):\\n            if left[i] > 0 and right[i] > 0:\\n                ans = min(ans, n - 1 - left[i] - right[i])    \\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        n = len(nums)        \\n        left = [0 for i in range(n)]\\n        right = [0 for i in range(n)]\\n        \\n        for i in range(1, n):\\n            val = 0 \\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    val = max(val, left[j] + 1)\\n        \\n            left[i] = val\\n            \\n        for i in range(n - 2, -1, -1):\\n            val = 0 \\n            for j in range(i + 1, n):\\n                if nums[j] < nums[i]:\\n                    val = max(val, right[j] + 1)\\n            \\n            right[i] = val\\n            \\n        ans = inf\\n        \\n        for i in range(1, n - 1):\\n            if left[i] > 0 and right[i] > 0:\\n                ans = min(ans, n - 1 - left[i] - right[i])    \\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1717702,
                "title": "golang-o-nlogn-solution",
                "content": "This problem is the same of finding longest mountain.\\n\\nFirst we need to form 2 arrays representing the longest increasing and decreasing subsequence from for each 0 to i in nums. (the longest decreasing subsequence is just the longest increasing subsequence of reversed nums).\\n\\nFor each i from 0 to n - 1, assume nums[i] is the peak, find longest increasing subsequence of nums[0:i] and longest decreasing subsequence of num[i:n-1]. The longest mountain for ith peak is the sum of them and subtract by 1 due to the duplicate count of peak.\\n\\nWe can filter out some elements which are not possible to be peaks\\ni.e. the lowest points\\ne.g. [2,3,**1**,5,6]\\nthose elements having a \\'1\\' in longest increasing subsequence because none of the previous elements has lower value.\\n\\nFind the maximum among the longest mountain of each peaks\\nReturn n - max\\n\\nTime complexity: O(nlogn) for lis, O(n) for finding max\\n\\n```go\\nfunc lis(nums []int) []int {\\n    res := make([]int, len(nums))\\n    res[0] = 1\\n    ends := make([]int, 1)\\n    ends[0] = nums[0]\\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] > ends[len(ends) - 1] {\\n            ends = append(ends, nums[i])\\n            res[i] = len(ends)\\n        } else {\\n            k := -1\\n            for j := len(ends) - 2; j > -1; j-- {\\n                if ends[j] < nums[i] {\\n                    k = j\\n                    break\\n                }\\n            }\\n            ends[k + 1] = nums[i]\\n            res[i] = k + 2\\n        }\\n    }\\n    return res\\n}\\n\\nfunc minimumMountainRemovals(nums []int) int {\\n    n := len(nums)\\n    up := lis(nums)\\n    for i, j := 0, n - 1; i < j; i, j = i+1, j-1 {\\n        nums[i], nums[j] = nums[j], nums[i]\\n    }\\n    down := lis(nums)\\n    max := 0\\n    for i := 0; i < n; i++ {\\n        if up[i] == 1 || down[n-i-1] == 1 {\\n            continue\\n        }\\n        if up[i] + down[n-i-1] - 1 > max {\\n            max = up[i] + down[n-i-1] - 1\\n        }\\n    }\\n    return n - max\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc lis(nums []int) []int {\\n    res := make([]int, len(nums))\\n    res[0] = 1\\n    ends := make([]int, 1)\\n    ends[0] = nums[0]\\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] > ends[len(ends) - 1] {\\n            ends = append(ends, nums[i])\\n            res[i] = len(ends)\\n        } else {\\n            k := -1\\n            for j := len(ends) - 2; j > -1; j-- {\\n                if ends[j] < nums[i] {\\n                    k = j\\n                    break\\n                }\\n            }\\n            ends[k + 1] = nums[i]\\n            res[i] = k + 2\\n        }\\n    }\\n    return res\\n}\\n\\nfunc minimumMountainRemovals(nums []int) int {\\n    n := len(nums)\\n    up := lis(nums)\\n    for i, j := 0, n - 1; i < j; i, j = i+1, j-1 {\\n        nums[i], nums[j] = nums[j], nums[i]\\n    }\\n    down := lis(nums)\\n    max := 0\\n    for i := 0; i < n; i++ {\\n        if up[i] == 1 || down[n-i-1] == 1 {\\n            continue\\n        }\\n        if up[i] + down[n-i-1] - 1 > max {\\n            max = up[i] + down[n-i-1] - 1\\n        }\\n    }\\n    return n - max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1717617,
                "title": "extended-lis-memoization-dp",
                "content": "=> Think carefully and recall LIS Concept what we used to do there.\\n\\n=> in this, we find LDS (Longest Decreasing Subsequence) from left and right  insted of LIS because we need to form a  Mountain. Does it make sense ?? Definitely Yes.\\n\\n=> and traverse that LDS and treat each point as a peak of mountain and take left maximum LDS and same for right and find longest mountain from this pick.\\n\\n=> here, Some edge cases you can see in Code \\n\\n=> Happy Coding :)\\n \\n  \\n    int minimumMountainRemovals(vector<int>& nums) {\\n         vector<int>lisl(nums.size(),0),lisr(nums.size(),0);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int maxi=0;\\n            for(int j=0;j<i;j++){        \\n                if(nums[j]<nums[i]){  \\n                    maxi=max(maxi,lisl[j]);\\n                }\\n            }\\n            lisl[i]=maxi+1;\\n        }\\n           \\n         for(int i=nums.size()-1;i>=0;i--){\\n            int maxi=0;\\n            for(int j=nums.size()-1;j>i;j--){\\n                if(nums[j]<nums[i]){\\n                    maxi=max(maxi,lisr[j]);\\n                }     \\n            } \\n            lisr[i]=maxi+1; \\n        }\\n        \\n       \\n        int ans=INT_MAX;\\n        for(int i=1;i<nums.size()-1;i++){\\n            if(lisl[i]!=1 and lisr[i]!=1 and (nums.size()-lisl[i]-lisr[i]+1)<ans){\\n                ans=(nums.size()-lisl[i]-lisr[i]+1);\\n            }                                    \\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "Memoization",
                    "Simulation"
                ],
                "code": "=> Think carefully and recall LIS Concept what we used to do there.\\n\\n=> in this, we find LDS (Longest Decreasing Subsequence) from left and right  insted of LIS because we need to form a  Mountain. Does it make sense ?? Definitely Yes.\\n\\n=> and traverse that LDS and treat each point as a peak of mountain and take left maximum LDS and same for right and find longest mountain from this pick.\\n\\n=> here, Some edge cases you can see in Code \\n\\n=> Happy Coding :)\\n \\n  \\n    int minimumMountainRemovals(vector<int>& nums) {\\n         vector<int>lisl(nums.size(),0),lisr(nums.size(),0);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int maxi=0;\\n            for(int j=0;j<i;j++){        \\n                if(nums[j]<nums[i]){  \\n                    maxi=max(maxi,lisl[j]);\\n                }\\n            }\\n            lisl[i]=maxi+1;\\n        }\\n           \\n         for(int i=nums.size()-1;i>=0;i--){\\n            int maxi=0;\\n            for(int j=nums.size()-1;j>i;j--){\\n                if(nums[j]<nums[i]){\\n                    maxi=max(maxi,lisr[j]);\\n                }     \\n            } \\n            lisr[i]=maxi+1; \\n        }\\n        \\n       \\n        int ans=INT_MAX;\\n        for(int i=1;i<nums.size()-1;i++){\\n            if(lisl[i]!=1 and lisr[i]!=1 and (nums.size()-lisl[i]-lisr[i]+1)<ans){\\n                ans=(nums.size()-lisl[i]-lisr[i]+1);\\n            }                                    \\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1678046,
                "title": "c-nlogn",
                "content": "This is variation of Famous LIS problem.\\nFor each index i we want Longest Increasing Subsequence ending at i from left` l[i]` and right `r[i] ` .\\nLengthof mountain array with peak at i is    **`l[i]+r[i]-1`** .\\nLIS can be calculated in O(n2) and O(nlogn).\\nHere I have Calculated in nlogn.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n=nums.size();  int ans=0;\\n        \\n        vector<int> l(n,1),r(n,1);\\n\\n        vector<int> v;  \\n        for(int i=0;i<n;i++){\\n            auto it=lower_bound(v.begin(),v.end(),nums[i]);\\n            int index=it-v.begin();  l[i]=index+1;\\n            \\n            if(it==v.end()) v.push_back(nums[i]);   else *it=nums[i];\\n        }\\n        v.clear();\\n        for(int i=n-1;i>=0;i--){\\n            auto it=lower_bound(v.begin(),v.end(),nums[i]);\\n            int index=it-v.begin();   r[i]=index+1;\\n            \\n            if(l[i]>1&&r[i]>1)   ans=max(ans,l[i]+r[i]-1);\\n           \\n            if(it==v.end()) v.push_back(nums[i]);  else *it=nums[i];\\n        }\\n        \\n        return n-ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n=nums.size();  int ans=0;\\n        \\n        vector<int> l(n,1),r(n,1);\\n\\n        vector<int> v;  \\n        for(int i=0;i<n;i++){\\n            auto it=lower_bound(v.begin(),v.end(),nums[i]);\\n            int index=it-v.begin();  l[i]=index+1;\\n            \\n            if(it==v.end()) v.push_back(nums[i]);   else *it=nums[i];\\n        }\\n        v.clear();\\n        for(int i=n-1;i>=0;i--){\\n            auto it=lower_bound(v.begin(),v.end(),nums[i]);\\n            int index=it-v.begin();   r[i]=index+1;\\n            \\n            if(l[i]>1&&r[i]>1)   ans=max(ans,l[i]+r[i]-1);\\n           \\n            if(it==v.end()) v.push_back(nums[i]);  else *it=nums[i];\\n        }\\n        \\n        return n-ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667678,
                "title": "c-lis-two-passes",
                "content": "Time complexity `O(nlogn)`\\n```\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size(), max_cnt = 0;\\n        vector<int> LIS0, LIS1;\\n        vector<int> cnt(n, 0);\\n        for (int i = 0; i < n; ++i)\\n        {\\n            auto it = lower_bound(LIS0.begin(), LIS0.end(), nums[i]);\\n            cnt[i] += distance(LIS0.begin(), it);\\n            if (it == LIS0.end())\\n                LIS0.push_back(nums[i]);\\n            else\\n                *it = nums[i];\\n        }\\n        for (int i = n - 1; i > 0; --i)\\n        {\\n            auto it = lower_bound(LIS1.begin(), LIS1.end(), nums[i]);\\n            int tmp = distance(LIS1.begin(), it);\\n            if (tmp > 0 && cnt[i] > 0)\\n                max_cnt = max(max_cnt, tmp + cnt[i] + 1);\\n            if (it == LIS1.end())\\n                LIS1.push_back(nums[i]);\\n            else\\n                *it = nums[i];\\n        }\\n        return n - max_cnt;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size(), max_cnt = 0;\\n        vector<int> LIS0, LIS1;\\n        vector<int> cnt(n, 0);\\n        for (int i = 0; i < n; ++i)\\n        {\\n            auto it = lower_bound(LIS0.begin(), LIS0.end(), nums[i]);\\n            cnt[i] += distance(LIS0.begin(), it);\\n            if (it == LIS0.end())\\n                LIS0.push_back(nums[i]);\\n            else\\n                *it = nums[i];\\n        }\\n        for (int i = n - 1; i > 0; --i)\\n        {\\n            auto it = lower_bound(LIS1.begin(), LIS1.end(), nums[i]);\\n            int tmp = distance(LIS1.begin(), it);\\n            if (tmp > 0 && cnt[i] > 0)\\n                max_cnt = max(max_cnt, tmp + cnt[i] + 1);\\n            if (it == LIS1.end())\\n                LIS1.push_back(nums[i]);\\n            else\\n                *it = nums[i];\\n        }\\n        return n - max_cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1629286,
                "title": "c-longest-increasing-subsequence",
                "content": "```\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        // from lest to right, longest increasing subsequence\\n        vector<int> up(n, 1);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] < nums[i])\\n                    up[i] = max(up[i], up[j] + 1);\\n            }\\n        }\\n        // from right to left, longest increasing subsequence\\n        vector<int> down(n, 1);\\n        for (int i = n-1; i >= 0; i--) {\\n            for (int j = n-1; j > i; j--) {\\n                if (nums[i] > nums[j])\\n                    down[i] = max(down[i], down[j] + 1);\\n            }\\n        }\\n        \\n        // let\\'s find the maximum length of bitonic sequence to get minimum removal!\\n        int res = 0;\\n        for (int i = 0; i < n; i++) \\n            if (up[i] >= 2 && down[i] >= 2) // basic condition for bitonic sequence!\\n                res = max(res, up[i] + down[i] - 1);\\n        \\n        return n - res;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        // from lest to right, longest increasing subsequence\\n        vector<int> up(n, 1);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] < nums[i])\\n                    up[i] = max(up[i], up[j] + 1);\\n            }\\n        }\\n        // from right to left, longest increasing subsequence\\n        vector<int> down(n, 1);\\n        for (int i = n-1; i >= 0; i--) {\\n            for (int j = n-1; j > i; j--) {\\n                if (nums[i] > nums[j])\\n                    down[i] = max(down[i], down[j] + 1);\\n            }\\n        }\\n        \\n        // let\\'s find the maximum length of bitonic sequence to get minimum removal!\\n        int res = 0;\\n        for (int i = 0; i < n; i++) \\n            if (up[i] >= 2 && down[i] >= 2) // basic condition for bitonic sequence!\\n                res = max(res, up[i] + down[i] - 1);\\n        \\n        return n - res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1588058,
                "title": "java-dp-solution-easy-to-understand",
                "content": "```\\npublic int minimumMountainRemovals(int[] nums) {\\n\\n        int len = nums.length;\\n\\n        //longest increasing subsequence (LIS)\\n        int[] lis = new int[len];\\n        //longest decreasing subsequence (LDS)\\n        int[] lds = new int[len];\\n\\n        //1. build longest increasing subsequence\\n        for(int i = 0; i < len; i++){\\n            lis[i] = 1;\\n            for(int j = 0; j < i; j++){\\n                if(nums[i] > nums[j]){\\n                    lis[i] = Math.max(lis[i], lis[j]+1);\\n                }\\n            }\\n        }\\n\\n        //2. build longest decreasing subsequence\\n        for(int i = len-1; i>=0; i--){\\n            lds[i] = 1;\\n            for(int j = len-1; j > i; j--){\\n                if(nums[i] > nums[j]){\\n                    lds[i] = Math.max(lds[i], lds[j]+1);\\n                }\\n            }\\n        }\\n\\n        int mountainLen = 0;\\n        for(int i = 0; i < len; i++){\\n            if(lis[i] > 1 && lds[i] > 1){\\n                //let\\'s image current i as the peak of mountain\\n                //if lis[i] > 1, it means there are elements on the left slope of mountain\\n                //if lds[i] > 1, it means there are elements on the right slope of mountain\\n                //so current total number of mountain elements should be lis[i] + lds[i] - 1\\n                //since i are both included in lis[i] and lds[i], we need to minus one\\n                mountainLen = Math.max(mountainLen, lis[i]+lds[i]-1);\\n            }\\n        }\\n        return len - mountainLen;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minimumMountainRemovals(int[] nums) {\\n\\n        int len = nums.length;\\n\\n        //longest increasing subsequence (LIS)\\n        int[] lis = new int[len];\\n        //longest decreasing subsequence (LDS)\\n        int[] lds = new int[len];\\n\\n        //1. build longest increasing subsequence\\n        for(int i = 0; i < len; i++){\\n            lis[i] = 1;\\n            for(int j = 0; j < i; j++){\\n                if(nums[i] > nums[j]){\\n                    lis[i] = Math.max(lis[i], lis[j]+1);\\n                }\\n            }\\n        }\\n\\n        //2. build longest decreasing subsequence\\n        for(int i = len-1; i>=0; i--){\\n            lds[i] = 1;\\n            for(int j = len-1; j > i; j--){\\n                if(nums[i] > nums[j]){\\n                    lds[i] = Math.max(lds[i], lds[j]+1);\\n                }\\n            }\\n        }\\n\\n        int mountainLen = 0;\\n        for(int i = 0; i < len; i++){\\n            if(lis[i] > 1 && lds[i] > 1){\\n                //let\\'s image current i as the peak of mountain\\n                //if lis[i] > 1, it means there are elements on the left slope of mountain\\n                //if lds[i] > 1, it means there are elements on the right slope of mountain\\n                //so current total number of mountain elements should be lis[i] + lds[i] - 1\\n                //since i are both included in lis[i] and lds[i], we need to minus one\\n                mountainLen = Math.max(mountainLen, lis[i]+lds[i]-1);\\n            }\\n        }\\n        return len - mountainLen;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1500184,
                "title": "python-lis-easy-understandable-code-illustration",
                "content": "```\\ndef minimumMountainRemovals(nums):\\n\\tdp_begin = [1]*len(nums)\\n\\tdp_end = [1]*len(nums)\\n\\tfor i in range(len(nums)):\\n\\t\\tfor j in range(i+1):\\n\\t\\t\\tif nums[j] < nums[i]:\\n\\t\\t\\t\\tdp_begin[i] = max(dp_begin[j]+1, dp_begin[i])\\n\\n\\tmaxi = 0\\n\\tfor i in range(len(nums)):\\n\\t\\tmaxi = max(maxi, dp_begin[i])\\n\\t\\tdp_begin[i] = maxi\\n\\n\\tfor i in range(len(nums)-1, -1, -1):\\n\\t\\tfor j in range(i+1, len(nums)):\\n\\t\\t\\tif nums[j] < nums[i]:\\n\\t\\t\\t\\tdp_end[i] = max(dp_end[j]+1, dp_end[i])\\n\\tmaxi = 0\\n\\tfor i in range(len(nums)-1, -1, -1):\\n\\t\\tmaxi = max(maxi, dp_end[i])\\n\\t\\tdp_end[i] = maxi\\n\\n\\tbest = 0\\n\\tfor i in range(1, len(dp_begin)-1):\\n\\t\\tif dp_begin[i] != 1 and dp_end[i] != 1:\\n\\t\\t\\tbest = max(best, dp_begin[i]+dp_end[i])\\n\\n\\treturn len(nums)-best+1\\n```\\n\\n- the **main idea** is that we want to calculate **largest increasing subsequence** (LIS) up until a index `i` \\nand the **largest decreasing subsequence** (LDS) onwards from index `i`\\ndoing this will help us select an index as mountain peak that will still keep as many elements as possible\\n\\n- after getting this LIS dp array, we still need to update each index to have the **cummalative max**\\nand for LDS dp array, we also need to calculate cummalative max but starting from right to left \\nsince we want all elements to the left of a certain index to be decreasing\\n\\n- lastly, calculate the **biggest sum between each index in LIS dp array and LDS dp array**\\nand substract 1 since the mountain peak was included twice (one for each dp array)\\nthis max sum is the total of all elements included in the mountain array -> \\nso subtract this max sum from `len(nums)` to get total elements removed\\n\\nbelow, I just go over an example:\\n\\n\\n<img src=\"https://assets.leetcode.com/users/images/bb947b93-d9ed-4471-8084-f0f44cab3235_1633233460.6172075.png\" width = \"1000\" />\\n",
                "solutionTags": [],
                "code": "```\\ndef minimumMountainRemovals(nums):\\n\\tdp_begin = [1]*len(nums)\\n\\tdp_end = [1]*len(nums)\\n\\tfor i in range(len(nums)):\\n\\t\\tfor j in range(i+1):\\n\\t\\t\\tif nums[j] < nums[i]:\\n\\t\\t\\t\\tdp_begin[i] = max(dp_begin[j]+1, dp_begin[i])\\n\\n\\tmaxi = 0\\n\\tfor i in range(len(nums)):\\n\\t\\tmaxi = max(maxi, dp_begin[i])\\n\\t\\tdp_begin[i] = maxi\\n\\n\\tfor i in range(len(nums)-1, -1, -1):\\n\\t\\tfor j in range(i+1, len(nums)):\\n\\t\\t\\tif nums[j] < nums[i]:\\n\\t\\t\\t\\tdp_end[i] = max(dp_end[j]+1, dp_end[i])\\n\\tmaxi = 0\\n\\tfor i in range(len(nums)-1, -1, -1):\\n\\t\\tmaxi = max(maxi, dp_end[i])\\n\\t\\tdp_end[i] = maxi\\n\\n\\tbest = 0\\n\\tfor i in range(1, len(dp_begin)-1):\\n\\t\\tif dp_begin[i] != 1 and dp_end[i] != 1:\\n\\t\\t\\tbest = max(best, dp_begin[i]+dp_end[i])\\n\\n\\treturn len(nums)-best+1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1463802,
                "title": "c-solution-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        vector<int>dp(n,0);\\n        dp[0]=1;\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i]){\\n                    dp[i]=max(dp[i],dp[j]);\\n                }\\n            }\\n            \\n            dp[i]+=1;\\n        }\\n        vector<int>dp2(n,0);\\n        dp2[n-1]=1;\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=i;j<n;j++){\\n                if(nums[i]>nums[j])\\n                    dp2[i]=max(dp2[j],dp2[i]);\\n            }\\n            dp2[i]+=1;\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            if(dp[i]!=1 && dp2[i]!=1)\\n                ans=max(ans,dp[i]+dp2[i]);\\n        }\\n        \\n        return n-(ans-1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        vector<int>dp(n,0);\\n        dp[0]=1;\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[j]<nums[i]){\\n                    dp[i]=max(dp[i],dp[j]);\\n                }\\n            }\\n            \\n            dp[i]+=1;\\n        }\\n        vector<int>dp2(n,0);\\n        dp2[n-1]=1;\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=i;j<n;j++){\\n                if(nums[i]>nums[j])\\n                    dp2[i]=max(dp2[j],dp2[i]);\\n            }\\n            dp2[i]+=1;\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            if(dp[i]!=1 && dp2[i]!=1)\\n                ans=max(ans,dp[i]+dp2[i]);\\n        }\\n        \\n        return n-(ans-1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402174,
                "title": "java-easy-java-solution-with-time-complexity-of-o-n-log-n",
                "content": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] A) {\\n        int n = A.length;\\n        int[] inc = new int[n], dec = new int[n], dp = new int[n];\\n        int size = 0, idx = 0;\\n        for(int x : A){\\n            int i = binarySearch(dp, x, size);\\n            dp[i] = x;\\n            if(i == size) size++;\\n            inc[idx++] = size;\\n        }\\n        \\n        dp = new int[n];\\n        size = 0;\\n        for(idx = n - 1; idx >= 0; idx--){\\n            int x = A[idx];\\n            int i = binarySearch(dp, x, size);\\n            dp[i] = x;\\n            if(i == size) size++;\\n            dec[idx] = size;\\n        }\\n        \\n        int max = 0;\\n        for(int i = 0; i < n; i++){\\n            if(inc[i] != 1 && dec[i] != 1)\\n            max = Math.max(max, inc[i] + dec[i] - 1);\\n        }\\n        \\n        return n - max;\\n    }\\n    \\n    int binarySearch(int[] dp, int x, int size){\\n        int i = 0, j = size - 1;\\n        while(i <= j){\\n            int m = (j+i)/2;\\n            if(dp[m] < x) i = m + 1;\\n            else j = m - 1;\\n        }\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] A) {\\n        int n = A.length;\\n        int[] inc = new int[n], dec = new int[n], dp = new int[n];\\n        int size = 0, idx = 0;\\n        for(int x : A){\\n            int i = binarySearch(dp, x, size);\\n            dp[i] = x;\\n            if(i == size) size++;\\n            inc[idx++] = size;\\n        }\\n        \\n        dp = new int[n];\\n        size = 0;\\n        for(idx = n - 1; idx >= 0; idx--){\\n            int x = A[idx];\\n            int i = binarySearch(dp, x, size);\\n            dp[i] = x;\\n            if(i == size) size++;\\n            dec[idx] = size;\\n        }\\n        \\n        int max = 0;\\n        for(int i = 0; i < n; i++){\\n            if(inc[i] != 1 && dec[i] != 1)\\n            max = Math.max(max, inc[i] + dec[i] - 1);\\n        }\\n        \\n        return n - max;\\n    }\\n    \\n    int binarySearch(int[] dp, int x, int size){\\n        int i = 0, j = size - 1;\\n        while(i <= j){\\n            int m = (j+i)/2;\\n            if(dp[m] < x) i = m + 1;\\n            else j = m - 1;\\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401029,
                "title": "java-lis-dp-greedy-binary-search-2-methods-beats-91",
                "content": "\\n\\n\\t// O(n^2) O(n)\\n\\tpublic int minimumMountainRemovals1(int[] nums) {\\n\\n\\t\\tint len = nums.length, omax = Integer.MIN_VALUE;\\n\\t\\tint[] dp1 = new int[len], dp2 = new int[len];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tint msf = 0;\\n\\t\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\t\\tif (nums[i] > nums[j] && dp1[j] > msf)\\n\\t\\t\\t\\t\\tmsf = dp1[j];\\n\\t\\t\\t}\\n\\t\\t\\tdp1[i] = msf + 1;\\n\\t\\t}\\n\\n\\t\\tfor (int i = len - 1; i >= 0; i--) {\\n\\t\\t\\tint msf = 0;\\n\\t\\t\\tfor (int j = i + 1; j < len; j++) {\\n\\t\\t\\t\\tif (nums[i] > nums[j] && dp2[j] > msf)\\n\\t\\t\\t\\t\\tmsf = dp2[j];\\n\\t\\t\\t}\\n\\t\\t\\tdp2[i] = msf + 1;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i < len - 1; i++) {\\n\\n\\t\\t\\tint left = dp1[i], right = dp2[i];\\n\\t\\t\\tif (left > 1 && right > 1 && left + right - 1 > omax)\\n\\t\\t\\t\\tomax = left + right - 1;\\n\\t\\t}\\n\\n\\t\\treturn len - omax;\\n\\t}\\n\\n\\t// O(nlogn) O(n)\\n\\tpublic int minimumMountainRemovals2(int[] nums) {\\n\\n\\t\\tint len = nums.length, omax = Integer.MIN_VALUE;\\n\\t\\tint[] dp1 = longestIncreasingSubsequence(nums);\\n\\t\\tint[] dp2 = longestDecreasingSubsequence(nums);\\n\\n\\t\\tfor (int i = 1; i < len - 1; i++) {\\n\\t\\t\\tint left = dp1[i], right = dp2[i];\\n\\t\\t\\tif (left + right - 1 > omax)\\n\\t\\t\\t\\tomax = left + right - 1;\\n\\t\\t}\\n\\n\\t\\treturn len - omax;\\n\\t}\\n\\n\\t// O(nlogn) O(n)\\n\\tpublic int[] longestDecreasingSubsequence(int[] nums) {\\n\\n\\t\\tint len = 1, length = nums.length;\\n\\t\\tint[] ans = new int[length], arr = new int[length];\\n\\n\\t\\tarr[0] = nums[length - 1];\\n\\t\\tans[length - 1] = 1;\\n\\n\\t\\tfor (int i = len - 2; i >= 0; i--) {\\n\\n\\t\\t\\tint val = nums[i];\\n\\t\\t\\tif (val > arr[len - 1]) {\\n\\t\\t\\t\\tarr[len++] = val;\\n\\t\\t\\t\\tans[i] = len;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tint idx = binarySearch(arr, 0, len - 1, val);\\n\\t\\t\\t\\tarr[idx] = val;\\n\\t\\t\\t\\tans[i] = idx + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(nlogn) O(n)\\n\\tpublic int[] longestIncreasingSubsequence(int[] nums) {\\n\\n\\t\\tint len = 1, length = nums.length;\\n\\t\\tint[] ans = new int[length], arr = new int[length];\\n\\n\\t\\tarr[0] = nums[0];\\n\\t\\tans[0] = 1;\\n\\n\\t\\tfor (int i = 1; i < length; i++) {\\n\\n\\t\\t\\tint val = nums[i];\\n\\t\\t\\tif (val > arr[len - 1]) {\\n\\t\\t\\t\\tarr[len++] = val;\\n\\t\\t\\t\\tans[i] = len;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tint idx = binarySearch(arr, 0, len - 1, val);\\n\\t\\t\\t\\tarr[idx] = val;\\n\\t\\t\\t\\tans[i] = idx + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(logn) O(1)\\n\\tpublic int binarySearch(int[] arr, int lo, int hi, int val) {\\n\\n\\t\\tint ans = -1;\\n\\t\\twhile (lo <= hi) {\\n\\n\\t\\t\\tint mid = (lo + hi) / 2;\\n\\t\\t\\tif (val <= arr[mid]) {\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\n\\t// O(n^2) O(n)\\n\\tpublic int minimumMountainRemovals1(int[] nums) {\\n\\n\\t\\tint len = nums.length, omax = Integer.MIN_VALUE;\\n\\t\\tint[] dp1 = new int[len], dp2 = new int[len];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tint msf = 0;\\n\\t\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\t\\tif (nums[i] > nums[j] && dp1[j] > msf)\\n\\t\\t\\t\\t\\tmsf = dp1[j];\\n\\t\\t\\t}\\n\\t\\t\\tdp1[i] = msf + 1;\\n\\t\\t}\\n\\n\\t\\tfor (int i = len - 1; i >= 0; i--) {\\n\\t\\t\\tint msf = 0;\\n\\t\\t\\tfor (int j = i + 1; j < len; j++) {\\n\\t\\t\\t\\tif (nums[i] > nums[j] && dp2[j] > msf)\\n\\t\\t\\t\\t\\tmsf = dp2[j];\\n\\t\\t\\t}\\n\\t\\t\\tdp2[i] = msf + 1;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i < len - 1; i++) {\\n\\n\\t\\t\\tint left = dp1[i], right = dp2[i];\\n\\t\\t\\tif (left > 1 && right > 1 && left + right - 1 > omax)\\n\\t\\t\\t\\tomax = left + right - 1;\\n\\t\\t}\\n\\n\\t\\treturn len - omax;\\n\\t}\\n\\n\\t// O(nlogn) O(n)\\n\\tpublic int minimumMountainRemovals2(int[] nums) {\\n\\n\\t\\tint len = nums.length, omax = Integer.MIN_VALUE;\\n\\t\\tint[] dp1 = longestIncreasingSubsequence(nums);\\n\\t\\tint[] dp2 = longestDecreasingSubsequence(nums);\\n\\n\\t\\tfor (int i = 1; i < len - 1; i++) {\\n\\t\\t\\tint left = dp1[i], right = dp2[i];\\n\\t\\t\\tif (left + right - 1 > omax)\\n\\t\\t\\t\\tomax = left + right - 1;\\n\\t\\t}\\n\\n\\t\\treturn len - omax;\\n\\t}\\n\\n\\t// O(nlogn) O(n)\\n\\tpublic int[] longestDecreasingSubsequence(int[] nums) {\\n\\n\\t\\tint len = 1, length = nums.length;\\n\\t\\tint[] ans = new int[length], arr = new int[length];\\n\\n\\t\\tarr[0] = nums[length - 1];\\n\\t\\tans[length - 1] = 1;\\n\\n\\t\\tfor (int i = len - 2; i >= 0; i--) {\\n\\n\\t\\t\\tint val = nums[i];\\n\\t\\t\\tif (val > arr[len - 1]) {\\n\\t\\t\\t\\tarr[len++] = val;\\n\\t\\t\\t\\tans[i] = len;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tint idx = binarySearch(arr, 0, len - 1, val);\\n\\t\\t\\t\\tarr[idx] = val;\\n\\t\\t\\t\\tans[i] = idx + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(nlogn) O(n)\\n\\tpublic int[] longestIncreasingSubsequence(int[] nums) {\\n\\n\\t\\tint len = 1, length = nums.length;\\n\\t\\tint[] ans = new int[length], arr = new int[length];\\n\\n\\t\\tarr[0] = nums[0];\\n\\t\\tans[0] = 1;\\n\\n\\t\\tfor (int i = 1; i < length; i++) {\\n\\n\\t\\t\\tint val = nums[i];\\n\\t\\t\\tif (val > arr[len - 1]) {\\n\\t\\t\\t\\tarr[len++] = val;\\n\\t\\t\\t\\tans[i] = len;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tint idx = binarySearch(arr, 0, len - 1, val);\\n\\t\\t\\t\\tarr[idx] = val;\\n\\t\\t\\t\\tans[i] = idx + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(logn) O(1)\\n\\tpublic int binarySearch(int[] arr, int lo, int hi, int val) {\\n\\n\\t\\tint ans = -1;\\n\\t\\twhile (lo <= hi) {\\n\\n\\t\\t\\tint mid = (lo + hi) / 2;\\n\\t\\t\\tif (val <= arr[mid]) {\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1396611,
                "title": "java-lis",
                "content": "Here, main idea is to calculate longest Bitonic sequence using Longest increasing sequence(LIS) and the subtract it from the total length to get the result.\\n```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] arr) {\\n        int len=arr.length;\\n        int[] LIS=new int[len];\\n        int[] LDS=new int[len];\\n\\t\\tint res=0;\\n        Arrays.fill(LIS, 1);\\n        Arrays.fill(LDS, 1);\\n        \\n        for(int i=1;i<len;i++)\\n        {\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(arr[j]<arr[i])\\n                {\\n                    LIS[i]=Math.max(LIS[i], 1+LIS[j]);\\n                }\\n            }\\n        }\\n        \\n        for(int i=len-2;i>=0;i--)\\n        {\\n            for(int j=i+1;j<len;j++)\\n            {\\n                if(arr[j]<arr[i])\\n                {\\n                    LDS[i]=Math.max(LDS[i], 1+LDS[j]);\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<len-1;i++)\\n        {\\n            if(LIS[i]>1 && LDS[i]>1)\\n            {\\n                res=Math.max(res, LIS[i]+LDS[i]-1);\\n            }\\n        }\\n        \\n        return len-res;\\n    }\\n}\\n```\\n\\nTo improve time complexity from O(n*n) to O(n*logn), Binary Search can be used.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] arr) {\\n        int len=arr.length;\\n        int[] LIS=new int[len];\\n        int[] LDS=new int[len];\\n\\t\\tint res=0;\\n        Arrays.fill(LIS, 1);\\n        Arrays.fill(LDS, 1);\\n        \\n        for(int i=1;i<len;i++)\\n        {\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(arr[j]<arr[i])\\n                {\\n                    LIS[i]=Math.max(LIS[i], 1+LIS[j]);\\n                }\\n            }\\n        }\\n        \\n        for(int i=len-2;i>=0;i--)\\n        {\\n            for(int j=i+1;j<len;j++)\\n            {\\n                if(arr[j]<arr[i])\\n                {\\n                    LDS[i]=Math.max(LDS[i], 1+LDS[j]);\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<len-1;i++)\\n        {\\n            if(LIS[i]>1 && LDS[i]>1)\\n            {\\n                res=Math.max(res, LIS[i]+LDS[i]-1);\\n            }\\n        }\\n        \\n        return len-res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390146,
                "title": "python-binary-search-dp-with-thought-process-when-being-asked-during-interviews",
                "content": "### Binary Search + DP\\nLet\\'s observe the mountain array first. \\nIn order to make it mountain array with peak at index *i*, we need guarrentee the intergers to the left of *i* is strictly increasing and the integers to the right of *i* is strictly decreasing. Besides, we want to remove the minimum number of integers from the *nums*. So we need select the one with the longest length sum of increasing sequence to the left and decreasing sequence to the right.\\nYou might have got the idea, we calcuate the longest increasing subsequence to the left and right respectively using DP for each index, and pick up the one with the longest length.\\nThe pitfall here is that we need reverse the *nums* to calculate the increasing subsequence to the right and reverse the dp array back.\\nNote, we only care about those with non zero length from left and right side since the peak can\\'t be the edge (index 0 and len - 1)\\nFinally, we just get the result by subtracting the longest length of mountain from the array length.\\n\\n```python\\ndef minimumMountainRemovals(self, nums: List[int]) -> int:\\n\\tn = len(nums)\\n        \\n    def lis(nums):\\n\\t\\tlongest = []\\n        length = [1] * n\\n        for i, num in enumerate(nums):\\n\\t\\t\\tindex = bisect.bisect_left(longest, num)\\n            if index == len(longest):\\n\\t\\t\\t\\tlongest.append(num)\\n\\t\\t\\telse:     \\n\\t\\t\\t\\tlongest[index] = num\\n\\t\\t\\tlength[i] = index\\n\\t\\treturn length\\n\\n\\tleft = lis(nums)\\n    right = lis(nums[::-1])[::-1]\\n \\n    max_length = 1    \\n    for i in range(1, n - 1):\\n\\t\\tif left[i] and right[i]:\\n\\t\\t\\tmax_length = max(max_length, left[i] + right[i] + 1)\\n\\treturn n - max_length\\n```\\n\\n*Time Complexity*= **O(NlgN)**\\n*Space Complexity*= **O(N)**\\n",
                "solutionTags": [],
                "code": "```python\\ndef minimumMountainRemovals(self, nums: List[int]) -> int:\\n\\tn = len(nums)\\n        \\n    def lis(nums):\\n\\t\\tlongest = []\\n        length = [1] * n\\n        for i, num in enumerate(nums):\\n\\t\\t\\tindex = bisect.bisect_left(longest, num)\\n            if index == len(longest):\\n\\t\\t\\t\\tlongest.append(num)\\n\\t\\t\\telse:     \\n\\t\\t\\t\\tlongest[index] = num\\n\\t\\t\\tlength[i] = index\\n\\t\\treturn length\\n\\n\\tleft = lis(nums)\\n    right = lis(nums[::-1])[::-1]\\n \\n    max_length = 1    \\n    for i in range(1, n - 1):\\n\\t\\tif left[i] and right[i]:\\n\\t\\t\\tmax_length = max(max_length, left[i] + right[i] + 1)\\n\\treturn n - max_length\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1387062,
                "title": "easy-to-understand-c-solution-explained-increasing-decreasing-subarray",
                "content": "Runtime: 268 ms, faster than 44.71% of C++ online submissions for Minimum Number of Removals to Make Mountain Array.\\nMemory Usage: 12.2 MB, less than 30.39% of C++ online submissions for Minimum Number of Removals to Make Mountain Array.\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& a) \\n    {\\n        int i,j,n=a.size(),m=0;\\n\\t    vector<int> lis(n+1,1);\\n\\t    vector<int> lds(n+1,1);\\n\\t    for(i=1;i<n;i++)\\n\\t    {\\n\\t        for(j=0;j<i;j++)\\n\\t        {\\n\\t            if(a[i]>a[j]) //For each element find maximum possible increasing subarray\\n\\t            lis[i]=max(lis[i],lis[j]+1);\\n\\t        }\\n\\t    }\\n       //Mountain array is nothing but first increasing-then decreasing subarray\\n\\t    for(i=n-2;i>=0;i--)\\n\\t    {\\n\\t        for(j=n-1;j>i;j--)\\n\\t        {\\n\\t            if(a[i]>a[j]) //For each element find maximum possible decreasing subarray by iterating from end\\n\\t            lds[i]=max(lds[i],lds[j]+1);\\n\\t        }\\n\\t    }\\n\\t    for(i=0;i<n;i++)\\n\\t    {\\n\\t        if( lis[i]>1 && lds[i]>1 && (lis[i]+lds[i]-1)>m )\\n\\t        {\\n\\t            m=(lis[i]+lds[i]-1); \\n\\t//\\'m\\' is maximum possible mountain (increasing-decreasing subarray) with a[i] as peak element \\n\\t        }\\n\\t    }\\n\\t    return n-m;  //Trivial thing\\n    }\\n};\\n```\\nPlease \\'UPVOTE\\' if you feel this helpful :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& a) \\n    {\\n        int i,j,n=a.size(),m=0;\\n\\t    vector<int> lis(n+1,1);\\n\\t    vector<int> lds(n+1,1);\\n\\t    for(i=1;i<n;i++)\\n\\t    {\\n\\t        for(j=0;j<i;j++)\\n\\t        {\\n\\t            if(a[i]>a[j]) //For each element find maximum possible increasing subarray\\n\\t            lis[i]=max(lis[i],lis[j]+1);\\n\\t        }\\n\\t    }\\n       //Mountain array is nothing but first increasing-then decreasing subarray\\n\\t    for(i=n-2;i>=0;i--)\\n\\t    {\\n\\t        for(j=n-1;j>i;j--)\\n\\t        {\\n\\t            if(a[i]>a[j]) //For each element find maximum possible decreasing subarray by iterating from end\\n\\t            lds[i]=max(lds[i],lds[j]+1);\\n\\t        }\\n\\t    }\\n\\t    for(i=0;i<n;i++)\\n\\t    {\\n\\t        if( lis[i]>1 && lds[i]>1 && (lis[i]+lds[i]-1)>m )\\n\\t        {\\n\\t            m=(lis[i]+lds[i]-1); \\n\\t//\\'m\\' is maximum possible mountain (increasing-decreasing subarray) with a[i] as peak element \\n\\t        }\\n\\t    }\\n\\t    return n-m;  //Trivial thing\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373677,
                "title": "c-dp-using-largest-bitonic-susequence-concept-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        //standard procedure to find the largest bitonic subsequence\\n        \\n        int n = nums.size();\\n\\t    int lis[n];\\n\\t    int lds[n];\\n\\t    lis[0] = 1;\\n\\t    lds[n-1] = 1;\\n\\t    for(int i = 1; i < n; i++){\\n\\t        lis[i] = 1;\\n\\t        for(int j = i-1; j>=0; j--){\\n\\t            if(nums[j] < nums[i])\\n\\t                lis[i] = max(lis[i], 1 + lis[j]);\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    for(int i = n-2; i >=0; i--){\\n\\t        lds[i] = 1;\\n\\t        for(int j = i+ 1; j < n; j++){\\n\\t            if(nums[j] < nums[i])\\n\\t                lds[i] = max(lds[i], 1 + lds[j]);\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    int ans = 0;\\n\\t    for(int i = 0; i < n; i++){\\n            if(lis[i]!=1 && lds[i]!=1)\\n\\t        ans = max(ans, lis[i] + lds[i] - 1);\\n\\t    }\\n        \\n        // we include the not equal to one condition because for a mountain array the size is always greater than equal to 3\\n        \\n        \\n\\t    \\n\\t    return n - ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        //standard procedure to find the largest bitonic subsequence\\n        \\n        int n = nums.size();\\n\\t    int lis[n];\\n\\t    int lds[n];\\n\\t    lis[0] = 1;\\n\\t    lds[n-1] = 1;\\n\\t    for(int i = 1; i < n; i++){\\n\\t        lis[i] = 1;\\n\\t        for(int j = i-1; j>=0; j--){\\n\\t            if(nums[j] < nums[i])\\n\\t                lis[i] = max(lis[i], 1 + lis[j]);\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    for(int i = n-2; i >=0; i--){\\n\\t        lds[i] = 1;\\n\\t        for(int j = i+ 1; j < n; j++){\\n\\t            if(nums[j] < nums[i])\\n\\t                lds[i] = max(lds[i], 1 + lds[j]);\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    int ans = 0;\\n\\t    for(int i = 0; i < n; i++){\\n            if(lis[i]!=1 && lds[i]!=1)\\n\\t        ans = max(ans, lis[i] + lds[i] - 1);\\n\\t    }\\n        \\n        // we include the not equal to one condition because for a mountain array the size is always greater than equal to 3\\n        \\n        \\n\\t    \\n\\t    return n - ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327295,
                "title": "python-using-longest-increasing-subsequence-lis-beats-100-in-speed",
                "content": "\\n```\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        \\n        # we cannot have all increasing or all decreasing array so we need to remove these items first\\n\\n        j = 1\\n        \\n        # count the number of elements that are increasing at the begining\\n        while nums[j] <= nums[j-1]:\\n            j += 1\\n        \\n        # count the number of elements that are decreasing in reversed array\\n        l = len(nums) - 2        \\n        while nums[l] <= nums[l + 1]:\\n            l -= 1\\n            \\n        n = len(nums) - 1   # save the length of original array\\n        \\n        nums = nums[j - 1 : l + 2] # update  the array and remove the increasing and decreasing part\\n        \\n        L = len(nums) - 1\\n        \\n        \\n        dp = []\\n        ans = []\\n        # find the number of minimum removing items until index i for increasing array (left to right)\\n        for i in range(L + 1):\\n            ind = bisect_left(ans, nums[i])\\n\\n            if ind == len(ans):\\n                ans.append(nums[i])\\n            else:\\n                ans[ind] = nums[i]\\n            dp.append(i - ind)\\n\\n        ans = []\\n        # find the number of minimum removing item until index i for decreasing array (right to left)\\n        for i in reversed(range(L + 1)):\\n            ind = bisect_left(ans, nums[i])\\n\\n            if ind == len(ans):\\n                ans.append(nums[i])\\n            else:\\n                ans[ind] = nums[i]\\n            dp[i] += L - i - ind\\n        \\n\\n\\n        return min(dp) + j - 1 + n - (l + 1) \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        \\n        # we cannot have all increasing or all decreasing array so we need to remove these items first\\n\\n        j = 1\\n        \\n        # count the number of elements that are increasing at the begining\\n        while nums[j] <= nums[j-1]:\\n            j += 1\\n        \\n        # count the number of elements that are decreasing in reversed array\\n        l = len(nums) - 2        \\n        while nums[l] <= nums[l + 1]:\\n            l -= 1\\n            \\n        n = len(nums) - 1   # save the length of original array\\n        \\n        nums = nums[j - 1 : l + 2] # update  the array and remove the increasing and decreasing part\\n        \\n        L = len(nums) - 1\\n        \\n        \\n        dp = []\\n        ans = []\\n        # find the number of minimum removing items until index i for increasing array (left to right)\\n        for i in range(L + 1):\\n            ind = bisect_left(ans, nums[i])\\n\\n            if ind == len(ans):\\n                ans.append(nums[i])\\n            else:\\n                ans[ind] = nums[i]\\n            dp.append(i - ind)\\n\\n        ans = []\\n        # find the number of minimum removing item until index i for decreasing array (right to left)\\n        for i in reversed(range(L + 1)):\\n            ind = bisect_left(ans, nums[i])\\n\\n            if ind == len(ans):\\n                ans.append(nums[i])\\n            else:\\n                ans[ind] = nums[i]\\n            dp[i] += L - i - ind\\n        \\n\\n\\n        return min(dp) + j - 1 + n - (l + 1) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279223,
                "title": "lis-variation-easy-c-clean-codes",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> lis(vector<int> v)\\n    {\\n        int i,n=v.size();\\n        vector<int> dp(n,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if((v[j]<v[i]))\\n                {\\n                    dp[i]=max(dp[i],dp[j]+1);\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\n    \\n    \\n    int minimumMountainRemovals(vector<int>& nums) {\\n        vector<int> a1=lis(nums);\\n        reverse(nums.begin(),nums.end());\\n        vector<int> a2=lis(nums);\\n        reverse(a2.begin(),a2.end());\\n        reverse(nums.begin(),nums.end());\\n        int n=nums.size(),an=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if((a1[i]==1)||(a2[i]==1))\\n            {\\n                continue;\\n            }\\n            an=max(an,(a2[i]+a1[i]-1));\\n        }\\n        return (n-an);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> lis(vector<int> v)\\n    {\\n        int i,n=v.size();\\n        vector<int> dp(n,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if((v[j]<v[i]))\\n                {\\n                    dp[i]=max(dp[i],dp[j]+1);\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\n    \\n    \\n    int minimumMountainRemovals(vector<int>& nums) {\\n        vector<int> a1=lis(nums);\\n        reverse(nums.begin(),nums.end());\\n        vector<int> a2=lis(nums);\\n        reverse(a2.begin(),a2.end());\\n        reverse(nums.begin(),nums.end());\\n        int n=nums.size(),an=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if((a1[i]==1)||(a2[i]==1))\\n            {\\n                continue;\\n            }\\n            an=max(an,(a2[i]+a1[i]-1));\\n        }\\n        return (n-an);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255713,
                "title": "c-longest-bitonic-subsequence-variation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        vector<long long int> lis(nums.size(),1);\\n        vector<long long int> lds(nums.size(),1);\\n        long long int n=nums.size();\\n        \\n        for(long long int i=1;i<n;i++)\\n        {\\n            for(long long int j=i-1;j>=0;j--)\\n            {\\n                if(nums[i]>nums[j])\\n                    lis[i]=max(lis[i],lis[j]+1);\\n            }\\n        }\\n        \\n        for(long long int i=n-2;i>=0;i--)\\n        {\\n            for(long long int j=n-1;j>=i+1;j--)\\n            {\\n                if(nums[i]>nums[j])\\n                    lds[i]=max(lds[i],lds[j]+1);\\n            }\\n        }\\n        \\n        long long int ans=3;\\n        \\n        for(long long int i=0;i<n;i++)\\n        {\\n            if(lis[i]==1 or lds[i]==1)\\n                continue;\\n            \\n            long long int temp=lis[i]+lds[i]-1;\\n            ans=max(ans,temp);\\n        }\\n        \\n        return n-ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        vector<long long int> lis(nums.size(),1);\\n        vector<long long int> lds(nums.size(),1);\\n        long long int n=nums.size();\\n        \\n        for(long long int i=1;i<n;i++)\\n        {\\n            for(long long int j=i-1;j>=0;j--)\\n            {\\n                if(nums[i]>nums[j])\\n                    lis[i]=max(lis[i],lis[j]+1);\\n            }\\n        }\\n        \\n        for(long long int i=n-2;i>=0;i--)\\n        {\\n            for(long long int j=n-1;j>=i+1;j--)\\n            {\\n                if(nums[i]>nums[j])\\n                    lds[i]=max(lds[i],lds[j]+1);\\n            }\\n        }\\n        \\n        long long int ans=3;\\n        \\n        for(long long int i=0;i<n;i++)\\n        {\\n            if(lis[i]==1 or lds[i]==1)\\n                continue;\\n            \\n            long long int temp=lis[i]+lds[i]-1;\\n            ans=max(ans,temp);\\n        }\\n        \\n        return n-ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215976,
                "title": "faster-than-97-01-cpp-implementation-soln-2-o-nlogn-approach",
                "content": "```\\nNote: If you find my post helpful, please upvote :)\\n```\\nCPP implementation by using lis for precomputation of left and right array via nlogn simple approach.\\n\\n```\\nclass Solution {\\npublic:\\n    void getlis(vector<int>v,vector<int>&req)\\n    {\\n        for(int i=0;i<v.size();i++)req.push_back(1);\\n        vector<int>vv;\\n       \\n            vv.push_back(v[0]);\\n      \\n       for(int i=1;i<v.size();i++)\\n        {\\n       \\n            if(v[i]<vv[0])vv[0]=v[i];\\n           else\\n           {\\n               if(v[i]>vv[vv.size()-1])\\n               {\\n                   vv.push_back(v[i]);\\n                   req[i]=vv.size();\\n               }\\n               else\\n               {\\n                   int ind=lower_bound(vv.begin(),vv.end(),v[i])-vv.begin();\\n                   vv[ind]=v[i];\\n                   req[i]=ind+1;\\n                   \\n               }\\n           }\\n        }\\n      \\n    \\n    }\\n    int minimumMountainRemovals(vector<int>& nums) {\\n      vector<int>left,right;int ee=0;\\n        getlis(nums,left);\\n        reverse(nums.begin(),nums.end());\\n         getlis(nums,right);\\n        int ans=0;\\n      int ab=nums.size();\\n        for(int i=0;i<ab;i++)\\n        {\\n            if(left[i]>1&&right[ab-i-1]>1)\\n                ans=max(ans,left[i]+right[ab-i-1]-1);\\n        }\\n        return ab-ans;\\n      \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nNote: If you find my post helpful, please upvote :)\\n```\n```\\nclass Solution {\\npublic:\\n    void getlis(vector<int>v,vector<int>&req)\\n    {\\n        for(int i=0;i<v.size();i++)req.push_back(1);\\n        vector<int>vv;\\n       \\n            vv.push_back(v[0]);\\n      \\n       for(int i=1;i<v.size();i++)\\n        {\\n       \\n            if(v[i]<vv[0])vv[0]=v[i];\\n           else\\n           {\\n               if(v[i]>vv[vv.size()-1])\\n               {\\n                   vv.push_back(v[i]);\\n                   req[i]=vv.size();\\n               }\\n               else\\n               {\\n                   int ind=lower_bound(vv.begin(),vv.end(),v[i])-vv.begin();\\n                   vv[ind]=v[i];\\n                   req[i]=ind+1;\\n                   \\n               }\\n           }\\n        }\\n      \\n    \\n    }\\n    int minimumMountainRemovals(vector<int>& nums) {\\n      vector<int>left,right;int ee=0;\\n        getlis(nums,left);\\n        reverse(nums.begin(),nums.end());\\n         getlis(nums,right);\\n        int ans=0;\\n      int ab=nums.size();\\n        for(int i=0;i<ab;i++)\\n        {\\n            if(left[i]>1&&right[ab-i-1]>1)\\n                ans=max(ans,left[i]+right[ab-i-1]-1);\\n        }\\n        return ab-ans;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206264,
                "title": "can-some-help-i-am-trying-for-o-nlogn-in-java",
                "content": "```\\nclass Solution {\\n    public void helper1(int[] nums,int c,ArrayList<Integer> it,int[] inc){\\n        int right = it.size()-1,left = 0;\\n        while(left<right){\\n            int mid = (left+right)/2;\\n            if(it.get(mid) >= nums[c])\\n                right = mid;\\n            else\\n                left = mid+1;\\n        }\\n        inc[c] = left+1;\\n        it.set(left,nums[c]);\\n    }\\n    public void lis(int[] nums,int[] inc,int n){\\n        ArrayList<Integer> it = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            if(it.size() == 0){\\n                it.add(nums[i]);\\n                inc[i] = 1;\\n            }\\n            else if(it.get(0) >= nums.length){\\n                it.set(0,nums[i]);\\n                inc[i] = 1;\\n            }\\n            else if(it.get(it.size()-1) < nums[i]){\\n                it.add(nums[i]);\\n                inc[i] = it.size();\\n            }\\n            else\\n                helper1(nums,i,it,inc);  \\n        }\\n    }\\n\\tpublic int minimumMountainRemovals(int[] nums) {\\n\\t\\tint n = nums.length;\\n\\t\\tint[] inc = new int[n];\\n\\t\\tint[] dec = new int[n];\\n\\t\\tlis(nums,inc,n);\\n        int[] rev = new int[n];\\n        for(int i=0;i<n;i++)\\n            rev[i] = nums[n-i-1];\\n        int[] rd = new int[n];\\n        lis(rev,rd,n);\\n        for(int i=0;i<n;i++)\\n            dec[i] = rd[n-i-1];\\n\\t\\tint maxLen = 1;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\tif(inc[i]>1 && dec[i]>1)\\n\\t\\t\\t\\tmaxLen = Math.max(maxLen, inc[i] + dec[i] -1);\\n\\t\\treturn n - maxLen;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void helper1(int[] nums,int c,ArrayList<Integer> it,int[] inc){\\n        int right = it.size()-1,left = 0;\\n        while(left<right){\\n            int mid = (left+right)/2;\\n            if(it.get(mid) >= nums[c])\\n                right = mid;\\n            else\\n                left = mid+1;\\n        }\\n        inc[c] = left+1;\\n        it.set(left,nums[c]);\\n    }\\n    public void lis(int[] nums,int[] inc,int n){\\n        ArrayList<Integer> it = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            if(it.size() == 0){\\n                it.add(nums[i]);\\n                inc[i] = 1;\\n            }\\n            else if(it.get(0) >= nums.length){\\n                it.set(0,nums[i]);\\n                inc[i] = 1;\\n            }\\n            else if(it.get(it.size()-1) < nums[i]){\\n                it.add(nums[i]);\\n                inc[i] = it.size();\\n            }\\n            else\\n                helper1(nums,i,it,inc);  \\n        }\\n    }\\n\\tpublic int minimumMountainRemovals(int[] nums) {\\n\\t\\tint n = nums.length;\\n\\t\\tint[] inc = new int[n];\\n\\t\\tint[] dec = new int[n];\\n\\t\\tlis(nums,inc,n);\\n        int[] rev = new int[n];\\n        for(int i=0;i<n;i++)\\n            rev[i] = nums[n-i-1];\\n        int[] rd = new int[n];\\n        lis(rev,rd,n);\\n        for(int i=0;i<n;i++)\\n            dec[i] = rd[n-i-1];\\n\\t\\tint maxLen = 1;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\tif(inc[i]>1 && dec[i]>1)\\n\\t\\t\\t\\tmaxLen = Math.max(maxLen, inc[i] + dec[i] -1);\\n\\t\\treturn n - maxLen;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127414,
                "title": "c-100-lis-o-nlogn",
                "content": "```\\nint minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> left(n),right(n),st;\\n        \\n        for (int i =0;i<n;i++){\\n            auto it = lower_bound(st.begin(),st.end(),nums[i]);\\n            if (it!=st.end()){\\n                 int idx = it- st.begin();\\n                st[idx] = nums[i];\\n                left[i] = idx+1;\\n            }else{\\n                st.push_back(nums[i]);\\n                left[i] = st.size();\\n            }\\n        }\\n        \\n        st.clear();\\n        reverse(nums.begin(),nums.end());\\n        \\n        for (int i =0;i<n;i++){\\n            auto it = lower_bound(st.begin(),st.end(),nums[i]);\\n            if (it!=st.end()){\\n                 int idx = it- st.begin();\\n                st[idx] = nums[i];\\n                right[n-1-i] = idx+1;\\n            }else{\\n                st.push_back(nums[i]);\\n                right[n-1-i] = st.size();\\n            }\\n        }\\n        \\n        int res = INT_MAX;\\n        for (int i =1;i<n-1;i++){\\n            if (left[i]>1 && right[i]>1){\\n                res = min(res,i+1-left[i]+n-i-right[i]);\\n            }\\n            \\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\nint minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> left(n),right(n),st;\\n        \\n        for (int i =0;i<n;i++){\\n            auto it = lower_bound(st.begin(),st.end(),nums[i]);\\n            if (it!=st.end()){\\n                 int idx = it- st.begin();\\n                st[idx] = nums[i];\\n                left[i] = idx+1;\\n            }else{\\n                st.push_back(nums[i]);\\n                left[i] = st.size();\\n            }\\n        }\\n        \\n        st.clear();\\n        reverse(nums.begin(),nums.end());\\n        \\n        for (int i =0;i<n;i++){\\n            auto it = lower_bound(st.begin(),st.end(),nums[i]);\\n            if (it!=st.end()){\\n                 int idx = it- st.begin();\\n                st[idx] = nums[i];\\n                right[n-1-i] = idx+1;\\n            }else{\\n                st.push_back(nums[i]);\\n                right[n-1-i] = st.size();\\n            }\\n        }\\n        \\n        int res = INT_MAX;\\n        for (int i =1;i<n-1;i++){\\n            if (left[i]>1 && right[i]>1){\\n                res = min(res,i+1-left[i]+n-i-right[i]);\\n            }\\n            \\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1105635,
                "title": "c-bi-directional-lis",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        vector<int> dp1(nums.size(),1),dp2(nums.size(),1);\\n        \\n        for(int i = 1; i < dp1.size(); ++i){\\n            for(int j = i - 1; j >= 0; j--){\\n                if(nums[i] > nums[j]){\\n                    dp1[i] = max(dp1[i],dp1[j] + 1);\\n                }\\n            }\\n        }\\n        \\n        for(int i = dp2.size() - 2; i >= 0; --i){\\n            for(int j = i + 1; j < dp2.size(); j++){\\n                if(nums[i] > nums[j]){\\n                    dp2[i] = max(dp2[i],dp2[j] + 1);\\n                }\\n            }\\n        }\\n        \\n        int maxToKeep = INT_MIN;\\n        \\n        for(int i = 0; i < dp1.size(); ++i){\\n            if(dp1[i] > 1 && dp2[i] > 1){\\n                maxToKeep = max(maxToKeep, dp1[i] + dp2[i] - 1);\\n            }\\n        }\\n        \\n        return nums.size() - maxToKeep;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        vector<int> dp1(nums.size(),1),dp2(nums.size(),1);\\n        \\n        for(int i = 1; i < dp1.size(); ++i){\\n            for(int j = i - 1; j >= 0; j--){\\n                if(nums[i] > nums[j]){\\n                    dp1[i] = max(dp1[i],dp1[j] + 1);\\n                }\\n            }\\n        }\\n        \\n        for(int i = dp2.size() - 2; i >= 0; --i){\\n            for(int j = i + 1; j < dp2.size(); j++){\\n                if(nums[i] > nums[j]){\\n                    dp2[i] = max(dp2[i],dp2[j] + 1);\\n                }\\n            }\\n        }\\n        \\n        int maxToKeep = INT_MIN;\\n        \\n        for(int i = 0; i < dp1.size(); ++i){\\n            if(dp1[i] > 1 && dp2[i] > 1){\\n                maxToKeep = max(maxToKeep, dp1[i] + dp2[i] - 1);\\n            }\\n        }\\n        \\n        return nums.size() - maxToKeep;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1061130,
                "title": "simple-forward-backward-lis-python",
                "content": "```\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        \\n        LIS_forward = [0]*len(nums)\\n        LIS_backward = [0]*len(nums)\\n        \\n        for i in range (0, len(nums)):\\n            max_prev = 0\\n            for j in range (0, i):\\n                if nums[j] < nums[i]:\\n                    max_prev = max(max_prev, LIS_forward[j])\\n            LIS_forward[i] = max_prev +1 \\n        \\n        for i in range (len(nums)-1, -1, -1):\\n            max_next = 0\\n            for j in range (i, len(nums)):\\n                if nums[j] < nums[i]:\\n                    max_next = max(max_next, LIS_backward[j])\\n            LIS_backward[i] = max_next +1 \\n        \\n        max_LIS = 0\\n        for i in range (1, len(nums)-1):\\n            if LIS_forward[i] > 1 and LIS_backward[i] > 1: \\n                max_LIS = max (max_LIS, LIS_forward[i] + LIS_backward[i] -1) \\n\\n        \\n        return len(nums) - max_LIS\\n            \\n            \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        \\n        LIS_forward = [0]*len(nums)\\n        LIS_backward = [0]*len(nums)\\n        \\n        for i in range (0, len(nums)):\\n            max_prev = 0\\n            for j in range (0, i):\\n                if nums[j] < nums[i]:\\n                    max_prev = max(max_prev, LIS_forward[j])\\n            LIS_forward[i] = max_prev +1 \\n        \\n        for i in range (len(nums)-1, -1, -1):\\n            max_next = 0\\n            for j in range (i, len(nums)):\\n                if nums[j] < nums[i]:\\n                    max_next = max(max_next, LIS_backward[j])\\n            LIS_backward[i] = max_next +1 \\n        \\n        max_LIS = 0\\n        for i in range (1, len(nums)-1):\\n            if LIS_forward[i] > 1 and LIS_backward[i] > 1: \\n                max_LIS = max (max_LIS, LIS_forward[i] + LIS_backward[i] -1) \\n\\n        \\n        return len(nums) - max_LIS\\n            \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 1047417,
                "title": "simple-lis-dp",
                "content": "The idea is to find the length of LIS once from left to right and again from right to left.\\n\\n```\\nclass Solution {\\npublic:\\n\\t// LIS from left to right\\n\\tvoid findListLeft(vector<int>& nums, vector<int>& lisLeft) {\\n\\t\\tfor (int i = 1; i < nums.size(); i++) {\\n\\t\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\t\\tif (nums[i] > nums[j]) {\\n\\t\\t\\t\\t\\tlisLeft[i] = max(lisLeft[i], lisLeft[j] + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// LIS from right to left\\n\\tvoid findListRight(vector<int>& nums, vector<int>& lisRight) {\\n\\t\\tfor (int i = nums.size() - 2; i >= 0; i--) {\\n\\t\\t\\tfor (int j = nums.size() - 1; j > i; j--) {\\n\\t\\t\\t\\tif (nums[i] > nums[j]) {\\n\\t\\t\\t\\t\\tlisRight[i] = max(lisRight[i], lisRight[j] + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tint minimumMountainRemovals(vector<int>& nums) {\\n\\t\\tvector<int> lisLeft(nums.size(), 1), lisRight(nums.size(), 1);\\n\\t\\tfindListLeft(nums, lisLeft);\\n\\t\\tfindListRight(nums, lisRight);\\n\\t\\tint minmRemovals = nums.size();\\n\\t\\t// index 0 can\\'t be a moutain because there is nothing smaller in the left\\n\\t\\t// index nums.size() - 1 can\\'t be a moutain because there is nothing larger in the right\\n\\t\\tfor (int i = 1; i < nums.size() - 1; i++) {\\n\\t\\t\\t// an index can be considered as a moutain only if there is at least one smaller in the left\\n\\t\\t\\t// and at least one larger in the right\\n\\t\\t\\tif (lisLeft[i] > 1 && lisRight[i] > 1)\\n\\t\\t\\t\\tminmRemovals = min(minmRemovals, (int)nums.size() - (lisLeft[i] + lisRight[i] - 1));\\n\\t\\t}\\n\\t\\treturn minmRemovals;\\n\\t}\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\t// LIS from left to right\\n\\tvoid findListLeft(vector<int>& nums, vector<int>& lisLeft) {\\n\\t\\tfor (int i = 1; i < nums.size(); i++) {\\n\\t\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\t\\tif (nums[i] > nums[j]) {\\n\\t\\t\\t\\t\\tlisLeft[i] = max(lisLeft[i], lisLeft[j] + 1);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1022942,
                "title": "java-o-n-2-concept-of-longest-increasing-subsequence",
                "content": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int[] dp1 = new int[nums.length];\\n        int[] dp2 = new int[nums.length];\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            dp1[i] = dp2[i] = 1;\\n        } \\n        \\n        //lis\\n        for(int i = 1; i < nums.length; i++) {\\n            for(int j = 0; j < i; j++) {\\n                if(nums[i] > nums[j]) {\\n                    dp1[i] = Math.max(dp1[i], 1+dp1[j]);\\n                }\\n            }\\n        }\\n        \\n        //lis(reverse)\\n        for(int i = nums.length-2; i >= 0; i--) {\\n            for(int j = nums.length-1; j > i; j--) {\\n                if(nums[i] > nums[j]) {\\n                    dp2[i] = Math.max(dp2[i], 1+dp2[j]);\\n                }\\n            }\\n        }\\n                \\n        //maximum mountain\\n        int max = 0;\\n        for(int i = 1; i < nums.length-1; i++) {  //0 and n-1 th index can\\'t make mountain\\n            if(hasLeft(nums, i) && hasRight(nums, i)) {\\n                max = Math.max(max, dp1[i]+dp2[i]-1);\\n            }\\n        }\\n        \\n        return nums.length-max;\\n    }\\n    \\n    //is there any small element in left of this index\\n    private boolean hasLeft(int[] nums, int top) {\\n        for(int i = 0; i < top; i++) {\\n            if(nums[i] < nums[top]) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    //is there any small element in right of this index\\n    private boolean hasRight(int[] nums, int top) {\\n        for(int i = top+1; i < nums.length; i++) {\\n            if(nums[top] > nums[i]) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int[] dp1 = new int[nums.length];\\n        int[] dp2 = new int[nums.length];\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            dp1[i] = dp2[i] = 1;\\n        } \\n        \\n        //lis\\n        for(int i = 1; i < nums.length; i++) {\\n            for(int j = 0; j < i; j++) {\\n                if(nums[i] > nums[j]) {\\n                    dp1[i] = Math.max(dp1[i], 1+dp1[j]);\\n                }\\n            }\\n        }\\n        \\n        //lis(reverse)\\n        for(int i = nums.length-2; i >= 0; i--) {\\n            for(int j = nums.length-1; j > i; j--) {\\n                if(nums[i] > nums[j]) {\\n                    dp2[i] = Math.max(dp2[i], 1+dp2[j]);\\n                }\\n            }\\n        }\\n                \\n        //maximum mountain\\n        int max = 0;\\n        for(int i = 1; i < nums.length-1; i++) {  //0 and n-1 th index can\\'t make mountain\\n            if(hasLeft(nums, i) && hasRight(nums, i)) {\\n                max = Math.max(max, dp1[i]+dp2[i]-1);\\n            }\\n        }\\n        \\n        return nums.length-max;\\n    }\\n    \\n    //is there any small element in left of this index\\n    private boolean hasLeft(int[] nums, int top) {\\n        for(int i = 0; i < top; i++) {\\n            if(nums[i] < nums[top]) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    //is there any small element in right of this index\\n    private boolean hasRight(int[] nums, int top) {\\n        for(int i = top+1; i < nums.length; i++) {\\n            if(nums[top] > nums[i]) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959313,
                "title": "java-23ms-solution-with-comment",
                "content": "```java\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        List<Integer> ascending = new ArrayList<>();\\n        // al1.get(i) longest ascending subsequence, end with nums[i]\\n        List<Integer> al1 = new ArrayList<>(nums.length);\\n        ascending.add(nums[0]);\\n        al1.add(1);\\n        for (int i = 1; i < nums.length-1; i++) {\\n            constructSubsequence(ascending, al1, nums[i]);\\n        }\\n\\n        List<Integer> descending = new LinkedList<>();\\n        // al2.get(i) longest descending subsequence, start with nums[nums.length-1-i]\\n        List<Integer> al2 = new ArrayList<>(nums.length);\\n        descending.add(nums[nums.length-1]);\\n        al2.add(1);\\n        for (int i = nums.length-2; i > 0; i--) {\\n            constructSubsequence(descending, al2, nums[i]);\\n        }\\n\\n        int maxMountainSize = 0;\\n        for (int i = 1; i < nums.length-1; i++) {\\n            int left = al1.get(i) - 1;\\n            int right = al2.get(nums.length-1-i) - 1;\\n            // if left or right is 0, not a valid mountain\\n            if (left*right > 0) {\\n                maxMountainSize = Integer.max(maxMountainSize, left + right + 1);\\n            }\\n        }\\n        return nums.length-maxMountainSize;\\n    }\\n\\n    /**\\n     * @param magic sorted list\\n     * @param res   longest ascending/descending subsequence\\n     * @param value value to process\\n     */\\n    private void constructSubsequence(List<Integer> magic, List<Integer> res, int value) {\\n        int index = Collections.binarySearch(magic, value);\\n        if (index >= 0) {\\n            // if found, just add to res, nothing need to do with magic\\n            res.add(index+1);\\n        } else {\\n            // add to res and change magic\\n            int realInsertIndex = -index - 1;\\n            res.add(realInsertIndex+1);\\n            if (realInsertIndex == magic.size()) {\\n                // append value to magic\\n                magic.add(realInsertIndex, value);\\n            } else {\\n                // magic.get(realInsertIndex) < value, so we replace it by value\\n                magic.set(realInsertIndex, value);\\n            }\\n        }\\n    }\\n\\n    static public void test() {\\n        Solution s = new Solution();\\n        System.out.println(s.minimumMountainRemovals(new int[]{1,3,1}) == 0);\\n        System.out.println(s.minimumMountainRemovals(new int[]{2,1,1,5,6,2,3,1}) == 3);\\n        System.out.println(s.minimumMountainRemovals(new int[]{4,3,2,1,1,2,3,1}) == 4);\\n        System.out.println(s.minimumMountainRemovals(new int[]{1,2,3,4,4,3,2,1}) == 1);\\n        System.out.println(s.minimumMountainRemovals(new int[]{100,92,89,77,74,66,64,66,64}) == 6);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        List<Integer> ascending = new ArrayList<>();\\n        // al1.get(i) longest ascending subsequence, end with nums[i]\\n        List<Integer> al1 = new ArrayList<>(nums.length);\\n        ascending.add(nums[0]);\\n        al1.add(1);\\n        for (int i = 1; i < nums.length-1; i++) {\\n            constructSubsequence(ascending, al1, nums[i]);\\n        }\\n\\n        List<Integer> descending = new LinkedList<>();\\n        // al2.get(i) longest descending subsequence, start with nums[nums.length-1-i]\\n        List<Integer> al2 = new ArrayList<>(nums.length);\\n        descending.add(nums[nums.length-1]);\\n        al2.add(1);\\n        for (int i = nums.length-2; i > 0; i--) {\\n            constructSubsequence(descending, al2, nums[i]);\\n        }\\n\\n        int maxMountainSize = 0;\\n        for (int i = 1; i < nums.length-1; i++) {\\n            int left = al1.get(i) - 1;\\n            int right = al2.get(nums.length-1-i) - 1;\\n            // if left or right is 0, not a valid mountain\\n            if (left*right > 0) {\\n                maxMountainSize = Integer.max(maxMountainSize, left + right + 1);\\n            }\\n        }\\n        return nums.length-maxMountainSize;\\n    }\\n\\n    /**\\n     * @param magic sorted list\\n     * @param res   longest ascending/descending subsequence\\n     * @param value value to process\\n     */\\n    private void constructSubsequence(List<Integer> magic, List<Integer> res, int value) {\\n        int index = Collections.binarySearch(magic, value);\\n        if (index >= 0) {\\n            // if found, just add to res, nothing need to do with magic\\n            res.add(index+1);\\n        } else {\\n            // add to res and change magic\\n            int realInsertIndex = -index - 1;\\n            res.add(realInsertIndex+1);\\n            if (realInsertIndex == magic.size()) {\\n                // append value to magic\\n                magic.add(realInsertIndex, value);\\n            } else {\\n                // magic.get(realInsertIndex) < value, so we replace it by value\\n                magic.set(realInsertIndex, value);\\n            }\\n        }\\n    }\\n\\n    static public void test() {\\n        Solution s = new Solution();\\n        System.out.println(s.minimumMountainRemovals(new int[]{1,3,1}) == 0);\\n        System.out.println(s.minimumMountainRemovals(new int[]{2,1,1,5,6,2,3,1}) == 3);\\n        System.out.println(s.minimumMountainRemovals(new int[]{4,3,2,1,1,2,3,1}) == 4);\\n        System.out.println(s.minimumMountainRemovals(new int[]{1,2,3,4,4,3,2,1}) == 1);\\n        System.out.println(s.minimumMountainRemovals(new int[]{100,92,89,77,74,66,64,66,64}) == 6);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954019,
                "title": "java-lis-and-lds-dp",
                "content": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n = nums.length;\\n        int[] lis = new int[n];\\n        Arrays.fill(lis, 1);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] < nums[i]) {\\n                    lis[i] = Math.max(lis[i], lis[j] + 1);\\n                }\\n            }\\n        }\\n        int[] lds = new int[n];\\n        Arrays.fill(lds, 1);\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = n - 1; j > i; j--) {\\n                if (nums[j] < nums[i]) {\\n                    lds[i] = Math.max(lds[i], lds[j] + 1);\\n                }\\n            }\\n        }\\n        int res = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            if (lis[i] > 1 && lds[i] > 1) {\\n                res = Math.max(res, lis[i] + lds[i] - 1);\\n            }\\n        }\\n        return n - res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n = nums.length;\\n        int[] lis = new int[n];\\n        Arrays.fill(lis, 1);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] < nums[i]) {\\n                    lis[i] = Math.max(lis[i], lis[j] + 1);\\n                }\\n            }\\n        }\\n        int[] lds = new int[n];\\n        Arrays.fill(lds, 1);\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = n - 1; j > i; j--) {\\n                if (nums[j] < nums[i]) {\\n                    lds[i] = Math.max(lds[i], lds[j] + 1);\\n                }\\n            }\\n        }\\n        int res = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            if (lis[i] > 1 && lds[i] > 1) {\\n                res = Math.max(res, lis[i] + lds[i] - 1);\\n            }\\n        }\\n        return n - res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952329,
                "title": "my-java-solution-using-longest-bitonic-subsequence-concept",
                "content": "```\\n// this is same as longest bitonic subsequence where bitonic sequences are the sequences that increase first then decrease after some time\\n// so we find the maximum longest bitonic subsequence and subtract the total array length. This will give the element to be removed.\\n\\nclass Solution {\\n    public int minimumMountainRemovals(int[] array) {\\n        int n = array.length;\\n        int [] lis = new int [n];\\n        int [] lds = new int [n];\\n        for (int i=0; i<n; i++) {\\n            lis[i] = 1;\\n            lds[i] = 1;\\n        }\\n        for (int i=1; i<n; i++) {\\n            for (int j=0; j<i; j++) {\\n                if (array[i] > array[j] && lis[i] < lis[j] + 1)\\n                    lis[i] = lis[j] + 1;\\n            }\\n        }\\n        for (int i=n-2; i>=0; i--) {\\n            for (int j=n-1; j>i; j--) {\\n                if (array[i] > array[j] && lds[i] < lds[j] + 1)\\n                    lds[i] = lds[j] + 1;\\n            }\\n        }\\n        int max = 0;\\n        for (int i=1; i<n-1; i++) {\\n            if (max < lis[i] + lds[i] - 1)\\n                max = lis[i] + lds[i] - 1;\\n        }\\n        return n - max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n// this is same as longest bitonic subsequence where bitonic sequences are the sequences that increase first then decrease after some time\\n// so we find the maximum longest bitonic subsequence and subtract the total array length. This will give the element to be removed.\\n\\nclass Solution {\\n    public int minimumMountainRemovals(int[] array) {\\n        int n = array.length;\\n        int [] lis = new int [n];\\n        int [] lds = new int [n];\\n        for (int i=0; i<n; i++) {\\n            lis[i] = 1;\\n            lds[i] = 1;\\n        }\\n        for (int i=1; i<n; i++) {\\n            for (int j=0; j<i; j++) {\\n                if (array[i] > array[j] && lis[i] < lis[j] + 1)\\n                    lis[i] = lis[j] + 1;\\n            }\\n        }\\n        for (int i=n-2; i>=0; i--) {\\n            for (int j=n-1; j>i; j--) {\\n                if (array[i] > array[j] && lds[i] < lds[j] + 1)\\n                    lds[i] = lds[j] + 1;\\n            }\\n        }\\n        int max = 0;\\n        for (int i=1; i<n-1; i++) {\\n            if (max < lis[i] + lds[i] - 1)\\n                max = lis[i] + lds[i] - 1;\\n        }\\n        return n - max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952294,
                "title": "c-solution-lis-both-side-o-nlogn",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    void LIS(vector<int> &nums, vector<int> &I){\\n        vector<int> arr(nums.size(), INT_MAX);\\n        for(int i = 0; i < nums.size(); ++i) {\\n            int idx = lower_bound(arr.begin(), arr.end(), nums[i]) - arr.begin();\\n            I.push_back(max(idx + 1, I.size() ? I.back() : 0));\\n            arr[idx] = nums[i];\\n        }\\n    }\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        vector<int> I, D;\\n        auto rn = nums;\\n        reverse(rn.begin(), rn.end());\\n        LIS(nums, I);\\n        LIS(rn, D);\\n        reverse(D.begin(), D.end());\\n        int ans = 0;\\n        for(int i = 1; i < nums.size() - 1; ++i) {\\n            if(I[i] > 1 && D[i] > 1)\\n                ans = max(ans, I[i] + D[i + 1]- (nums[i] == nums[i + 1]));\\n        }\\n        return nums.size() - ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    void LIS(vector<int> &nums, vector<int> &I){\\n        vector<int> arr(nums.size(), INT_MAX);\\n        for(int i = 0; i < nums.size(); ++i) {\\n            int idx = lower_bound(arr.begin(), arr.end(), nums[i]) - arr.begin();\\n            I.push_back(max(idx + 1, I.size() ? I.back() : 0));\\n            arr[idx] = nums[i];\\n        }\\n    }\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        vector<int> I, D;\\n        auto rn = nums;\\n        reverse(rn.begin(), rn.end());\\n        LIS(nums, I);\\n        LIS(rn, D);\\n        reverse(D.begin(), D.end());\\n        int ans = 0;\\n        for(int i = 1; i < nums.size() - 1; ++i) {\\n            if(I[i] > 1 && D[i] > 1)\\n                ans = max(ans, I[i] + D[i + 1]- (nums[i] == nums[i + 1]));\\n        }\\n        return nums.size() - ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952215,
                "title": "it-s-just-twice-longest-increasing-subsequence",
                "content": "```\\nint minimumMountainRemovals(vector<int>& nums) {\\n    int n = nums.size();\\n    vector<int> a(n+2);\\n    vector<int> b(n+2);\\n    for(int i = 0; i < n; ++i)\\n        a[i] = b[i] = 1;\\n    for(int i = 0; i < n ; ++i){\\n        for(int j = 0; j < i; ++j)\\n            if(nums[j] < nums[i]){\\n                a[i] = max(a[i], a[j] + 1);\\n            }\\n    }\\n    for(int i = n-1; i >=0 ; --i){\\n        for(int j = n-1; j > i; --j){\\n            if(nums[j] < nums[i]){\\n                b[i] = max(b[i],b[j]+1);\\n            }\\n        }\\n    }\\n    int ans = 0;\\n    for(int i = 1; i < n-1; ++i)\\n        ans = max(ans,a[i]+b[i]);\\n    return n - ans + 1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumMountainRemovals(vector<int>& nums) {\\n    int n = nums.size();\\n    vector<int> a(n+2);\\n    vector<int> b(n+2);\\n    for(int i = 0; i < n; ++i)\\n        a[i] = b[i] = 1;\\n    for(int i = 0; i < n ; ++i){\\n        for(int j = 0; j < i; ++j)\\n            if(nums[j] < nums[i]){\\n                a[i] = max(a[i], a[j] + 1);\\n            }\\n    }\\n    for(int i = n-1; i >=0 ; --i){\\n        for(int j = n-1; j > i; --j){\\n            if(nums[j] < nums[i]){\\n                b[i] = max(b[i],b[j]+1);\\n            }\\n        }\\n    }\\n    int ans = 0;\\n    for(int i = 1; i < n-1; ++i)\\n        ans = max(ans,a[i]+b[i]);\\n    return n - ans + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 952202,
                "title": "longest-increasing-subsequence-o-n-2-o-nlogn-clean-code-easy-to-understand",
                "content": "This is a brilliant example of how longest increasing subsequence (LIS) could be applied.\\n\\n**Idea**\\n\\nThe idea is simple: The minimum number of elements to remove is equivalent to the maximum length subsequence which is also a moutain.\\n\\n**Algorithm**\\n\\nFor each index i, we find the longest increasing subsequence starting from index 0.\\nFor each index i, we find the longest decreasing subsequence starting from index i, which is equivalent to the longest increasing subsequence starting from index n-1.\\n\\n**Implementation 1: plain DP**\\n\\ncomplexity: O(n^2)\\nspace O(n)\\n\\n```python\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        def LIS(nums):\\n            dp = [1] * n\\n            for i in range(1, n):\\n                for j in range(i):\\n                    if nums[i] > nums[j]:\\n                        dp[i] = max(dp[i], dp[j] + 1)\\n            return dp\\n        \\n        n = len(nums)\\n        inc = LIS(nums)\\n        dec = list(reversed(LIS(nums[::-1])))\\n        \\n        return n - max(inc[i] + dec[i] - 1 for i in range(1, n - 1))\\n```\\n\\n**Implementation 2: patience sorting**\\n\\nComplexity O(nlogn)\\nSpace O(n)\\n\\n```\\ndef minimumMountainRemovals(self, nums: List[int]) -> int:\\n        def LIS(nums):\\n            dp = [1] * len(nums)\\n            deck = []\\n            for i in range(len(nums)):\\n                index = bisect.bisect_left(deck, nums[i])\\n                if index == len(deck):\\n                    deck.append(nums[i])\\n                else:\\n                    deck[index] = nums[i]\\n                dp[i] = index + 1\\n            return dp\\n        \\n        n = len(nums)\\n        inc = LIS(nums)\\n        dec = list(reversed(LIS(nums[::-1])))\\n        return n - max(inc[i] + dec[i] - 1 for i in range(1, n - 1))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        def LIS(nums):\\n            dp = [1] * n\\n            for i in range(1, n):\\n                for j in range(i):\\n                    if nums[i] > nums[j]:\\n                        dp[i] = max(dp[i], dp[j] + 1)\\n            return dp\\n        \\n        n = len(nums)\\n        inc = LIS(nums)\\n        dec = list(reversed(LIS(nums[::-1])))\\n        \\n        return n - max(inc[i] + dec[i] - 1 for i in range(1, n - 1))\\n```\n```\\ndef minimumMountainRemovals(self, nums: List[int]) -> int:\\n        def LIS(nums):\\n            dp = [1] * len(nums)\\n            deck = []\\n            for i in range(len(nums)):\\n                index = bisect.bisect_left(deck, nums[i])\\n                if index == len(deck):\\n                    deck.append(nums[i])\\n                else:\\n                    deck[index] = nums[i]\\n                dp[i] = index + 1\\n            return dp\\n        \\n        n = len(nums)\\n        inc = LIS(nums)\\n        dec = list(reversed(LIS(nums[::-1])))\\n        return n - max(inc[i] + dec[i] - 1 for i in range(1, n - 1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952109,
                "title": "cpp-solutions",
                "content": "This is similar to longest increasing subsequence problem, where we need to find the length of longest subsequence and store it in the solution.\\n* Here we do the same for both sides, from the start, and from the end.\\n* And then at a point in middle, we find a index such that the sum of LIS in left and right side is maximum. This is the maximum length of mountain we can create with peak at that particular index.\\n* So after finding the longest size of array, we subtract it from the total array size to find the redundant elements to remove. \\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& arr) {\\n        int n=arr.size();\\n        int dpl[n],dpr[n],m=0;\\n        memset(dpl,0,sizeof(dpl));\\n        memset(dpr,0,sizeof(dpr));\\n        dpl[0]=1,dpr[n-1]=1;\\n        for(int i=1;i<n;i++){\\n            dpl[i]=1,dpr[i]=1;\\n            for(int j=0;j<i;j++)\\n                if(arr[j]<arr[i])\\n                    dpl[i]=max(dpl[i],dpl[j]+1);\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=n-1;j>i;j--)\\n                if(arr[j]<arr[i])\\n                    dpr[i]=max(dpr[i],dpr[j]+1);\\n        }\\n        for(int i=0;i<n;i++)\\n            if(dpl[i]>1 && dpr[i]>1)\\n                m=max(m,(dpl[i]-1)+(dpr[i]-1)+1);\\n        return n-m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& arr) {\\n        int n=arr.size();\\n        int dpl[n],dpr[n],m=0;\\n        memset(dpl,0,sizeof(dpl));\\n        memset(dpr,0,sizeof(dpr));\\n        dpl[0]=1,dpr[n-1]=1;\\n        for(int i=1;i<n;i++){\\n            dpl[i]=1,dpr[i]=1;\\n            for(int j=0;j<i;j++)\\n                if(arr[j]<arr[i])\\n                    dpl[i]=max(dpl[i],dpl[j]+1);\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=n-1;j>i;j--)\\n                if(arr[j]<arr[i])\\n                    dpr[i]=max(dpr[i],dpr[j]+1);\\n        }\\n        for(int i=0;i<n;i++)\\n            if(dpl[i]>1 && dpr[i]>1)\\n                m=max(m,(dpl[i]-1)+(dpr[i]-1)+1);\\n        return n-m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952045,
                "title": "lis-lds-o-n-2-o-nlogk",
                "content": "We can change the problem to LIS and LDS problem. LIS has the O(N^2) and O(N log K) where K is the length of the LIS.\\n*  O(N^2) , runtime 524 ms.\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> I(n, 1), D(n, 1);\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[j] < nums[i]) {\\n                    I[i] = max(I[i], I[j] + 1);\\n                }\\n            }\\n        }\\n        for (int i = n-1; i >=0; --i) {\\n            for (int j = n-1; j > i; --j) {\\n                if (nums[j] < nums[i]) {\\n                    D[i] = max(D[i], D[j] + 1);\\n                }\\n            }\\n        }\\n        int ret = 0;\\n        for (int i = 1; i < n - 1; ++i) {\\n            ret = max(ret, (I[i] + D[i] - 1) >=3 ? I[i] + D[i] - 1:0);\\n        }\\n        return n - ret;\\n    }\\n};\\n```\\n*  O(N log K) , runtime 40ms.\\nThe basic idea for this one is maintaining a longest increasing sequence and greedly updating the old longest increasing sequence by some available small values.\\nFor example, if we have 1, 10, 2, 5, 4\\nfor 1, we will have [1]\\nfor 10, we will have [1, 10]\\nfor 2, we will have [1, 2], 10 is updated to 2 as [1, 2] can have more potential to build a longer sequence than [1, 10],\\nfor 5, we have [1, 2, 5] ...\\nfor 4, we have [1, 2, 4].\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> I(n, 1), D(n, 1);\\n        vector<int> LIS(n, 0), LDS(n, 0);\\n        int k =0;\\n        for (int i = 0; i < n; ++i) {// n log k\\n            auto pos = lower_bound(LIS.begin(), LIS.begin()+k, nums[i])-LIS.begin();\\n            LIS[pos] = nums[i];\\n            if (pos==k) k = pos + 1;\\n            I[i] = k;\\n        }\\n        k = 0;\\n        for (int i = n-1; i >=0; --i) {// n log k\\n            auto pos = lower_bound(LDS.begin(), LDS.begin()+k, nums[i])-LDS.begin();\\n            LDS[pos] = nums[i];\\n            if (pos==k) k = pos + 1;\\n            D[i] = k;\\n        }\\n        int ret = 0;\\n        for (int i = 1; i < n - 1; ++i) {\\n            ret = max(ret, (I[i] + D[i] - 1) >=3 ? I[i] + D[i] - 1:0);\\n        }\\n        return n - ret;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> I(n, 1), D(n, 1);\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[j] < nums[i]) {\\n                    I[i] = max(I[i], I[j] + 1);\\n                }\\n            }\\n        }\\n        for (int i = n-1; i >=0; --i) {\\n            for (int j = n-1; j > i; --j) {\\n                if (nums[j] < nums[i]) {\\n                    D[i] = max(D[i], D[j] + 1);\\n                }\\n            }\\n        }\\n        int ret = 0;\\n        for (int i = 1; i < n - 1; ++i) {\\n            ret = max(ret, (I[i] + D[i] - 1) >=3 ? I[i] + D[i] - 1:0);\\n        }\\n        return n - ret;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> I(n, 1), D(n, 1);\\n        vector<int> LIS(n, 0), LDS(n, 0);\\n        int k =0;\\n        for (int i = 0; i < n; ++i) {// n log k\\n            auto pos = lower_bound(LIS.begin(), LIS.begin()+k, nums[i])-LIS.begin();\\n            LIS[pos] = nums[i];\\n            if (pos==k) k = pos + 1;\\n            I[i] = k;\\n        }\\n        k = 0;\\n        for (int i = n-1; i >=0; --i) {// n log k\\n            auto pos = lower_bound(LDS.begin(), LDS.begin()+k, nums[i])-LDS.begin();\\n            LDS[pos] = nums[i];\\n            if (pos==k) k = pos + 1;\\n            D[i] = k;\\n        }\\n        int ret = 0;\\n        for (int i = 1; i < n - 1; ++i) {\\n            ret = max(ret, (I[i] + D[i] - 1) >=3 ? I[i] + D[i] - 1:0);\\n        }\\n        return n - ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952024,
                "title": "simple-c-solution-using-lis",
                "content": "```\\n public class Solution\\n    {\\n        public int MinimumMountainRemovals(int[] nums)\\n        {\\n            int res = int.MaxValue;\\n            int[] dpLeft = new int[nums.Length];\\n            int[] dpRight = new int[nums.Length];\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                dpLeft[i] = 1;\\n                for (int j = 0; j < i; j++)\\n                {\\n                    if (nums[j] < nums[i])\\n                    {\\n                        dpLeft[i] = Math.Max(dpLeft[i], dpLeft[j] + 1);\\n                    }\\n                }\\n            }\\n\\n\\n            for (int i = nums.Length - 1; i >= 0; i--)\\n            {\\n                dpRight[i] = 1;\\n\\n                for (int j = nums.Length - 1; j > i; j--)\\n                {\\n                    if (nums[j] < nums[i])\\n                    {\\n                        dpRight[i] = Math.Max(dpRight[i], dpRight[j] + 1);\\n                    }\\n                }\\n            }\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                var l = dpLeft[i];\\n                var r = dpRight[i];\\n\\n                if (l > 1 && r > 1)\\n                {\\n                    var len = l + r - 1;\\n                    res = Math.Min(res, nums.Length - len);\\n                }\\n\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n public class Solution\\n    {\\n        public int MinimumMountainRemovals(int[] nums)\\n        {\\n            int res = int.MaxValue;\\n            int[] dpLeft = new int[nums.Length];\\n            int[] dpRight = new int[nums.Length];\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                dpLeft[i] = 1;\\n                for (int j = 0; j < i; j++)\\n                {\\n                    if (nums[j] < nums[i])\\n                    {\\n                        dpLeft[i] = Math.Max(dpLeft[i], dpLeft[j] + 1);\\n                    }\\n                }\\n            }\\n\\n\\n            for (int i = nums.Length - 1; i >= 0; i--)\\n            {\\n                dpRight[i] = 1;\\n\\n                for (int j = nums.Length - 1; j > i; j--)\\n                {\\n                    if (nums[j] < nums[i])\\n                    {\\n                        dpRight[i] = Math.Max(dpRight[i], dpRight[j] + 1);\\n                    }\\n                }\\n            }\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                var l = dpLeft[i];\\n                var r = dpRight[i];\\n\\n                if (l > 1 && r > 1)\\n                {\\n                    var len = l + r - 1;\\n                    res = Math.Min(res, nums.Length - len);\\n                }\\n\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952013,
                "title": "java-longest-increasing-subsequence-variance-o-n-2",
                "content": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n = nums.length;\\n        int[] inc = new int[n];\\n        int[] dec = new int[n];\\n        Arrays.fill(inc,1);\\n        Arrays.fill(dec,1);\\n        for(int i=0; i<n; i++){\\n            for(int j=i-1; j>=0; j--){\\n                if(nums[i]>nums[j]){\\n                    inc[i] = Math.max(inc[i], inc[j]+1);\\n                }\\n            }\\n        }\\n        for(int i=n-1; i>=0; i--){\\n            for(int j=i+1; j<n; j++){\\n                if(nums[i]>nums[j]){\\n                    dec[i] = Math.max(dec[i], dec[j]+1);\\n                }\\n            }\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++){\\n            if(inc[i]>1 && dec[i]>1){\\n                res = Math.min(res, n-inc[i]-dec[i]+1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n = nums.length;\\n        int[] inc = new int[n];\\n        int[] dec = new int[n];\\n        Arrays.fill(inc,1);\\n        Arrays.fill(dec,1);\\n        for(int i=0; i<n; i++){\\n            for(int j=i-1; j>=0; j--){\\n                if(nums[i]>nums[j]){\\n                    inc[i] = Math.max(inc[i], inc[j]+1);\\n                }\\n            }\\n        }\\n        for(int i=n-1; i>=0; i--){\\n            for(int j=i+1; j<n; j++){\\n                if(nums[i]>nums[j]){\\n                    dec[i] = Math.max(dec[i], dec[j]+1);\\n                }\\n            }\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++){\\n            if(inc[i]>1 && dec[i]>1){\\n                res = Math.min(res, n-inc[i]-dec[i]+1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952005,
                "title": "java-o-n-2-solution-using-dp",
                "content": "Suppose we are watching on some mountain array with **nums[i]** as a mountain element. The left part before this element is an increasing sequence, and the right part after this element is a decreasing sequence. For removing the minimum number of elements from the initial array, both sequences should be the longest possible.\\nThus, for each element in the given array, we need to compute two longest sequences.\\nOne of them is the longest increasing sequence starting from the left and ending at this element.\\nAnother one is the longest decreasing sequence starting from the right and ending at this element.\\nBoth tasks are well-known and can be solved using dynamic programming approach: track **dp[i]** as an answer and set it to max value from precalculated **dp[0] + 1, dp[1] + 1, dp[2] + 1, ..., dp[j] + 1, ..., dp[i - 1] + 1** for those only which has **nums[j] < nums[i]**.\\nAfter that, we need to find the max possible sum from these two values among all the elements.\\n```\\npublic int minimumMountainRemovals(int[] nums) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = 1;\\n        for (int i = 1; i < dp.length; i++) {\\n            dp[i] = 1;\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] < nums[i]) {\\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\\n                }\\n            }\\n        }\\n        int[] dp2 = new int[nums.length];\\n        dp2[dp2.length - 1] = 1;\\n        for (int i = dp2.length - 2; i >= 0; i--) {\\n            dp2[i] = 1;\\n            for (int j = dp2.length - 1; j > i; j--) {\\n                if (nums[j] < nums[i]) {\\n                    dp2[i] = Math.max(dp2[i], dp2[j] + 1);\\n                }\\n            }\\n        }\\n        int result = 0;\\n        for (int i = 1; i < dp.length - 1; i++) {\\n            result = Math.max(result, dp[i] + dp2[i]);\\n        }\\n        return nums.length - result + 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minimumMountainRemovals(int[] nums) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = 1;\\n        for (int i = 1; i < dp.length; i++) {\\n            dp[i] = 1;\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] < nums[i]) {\\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\\n                }\\n            }\\n        }\\n        int[] dp2 = new int[nums.length];\\n        dp2[dp2.length - 1] = 1;\\n        for (int i = dp2.length - 2; i >= 0; i--) {\\n            dp2[i] = 1;\\n            for (int j = dp2.length - 1; j > i; j--) {\\n                if (nums[j] < nums[i]) {\\n                    dp2[i] = Math.max(dp2[i], dp2[j] + 1);\\n                }\\n            }\\n        }\\n        int result = 0;\\n        for (int i = 1; i < dp.length - 1; i++) {\\n            result = Math.max(result, dp[i] + dp2[i]);\\n        }\\n        return nums.length - result + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 951991,
                "title": "c-using-longest-increasing-subsequence-approach",
                "content": "```\\npublic:\\n    vector<int> fun(vector<int>& arr)  \\n    {  \\n        int n = arr.size();\\n        vector<int> v(n, 0); \\n        v[0] = 1;    \\n        for (int i = 1; i < n; i++ )  \\n        { \\n            v[i] = 1; \\n            for (int j = 0; j < i; j++ )   \\n                if ( arr[i] > arr[j] && v[i] < v[j] + 1)  \\n                    v[i] = v[j] + 1;  \\n        } \\n        return v;\\n    } \\n    \\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp_front = fun(nums);\\n        reverse(nums.begin(), nums.end());\\n        vector<int> dp_back = fun(nums);\\n        reverse(dp_back.begin(), dp_back.end());\\n        int ans = INT_MAX;\\n        for(int i=1; i<n-1; i++)\\n            ans = min(ans, n - dp_front[i] - dp_back[i]);\\n\\n        return ans+1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic:\\n    vector<int> fun(vector<int>& arr)  \\n    {  \\n        int n = arr.size();\\n        vector<int> v(n, 0); \\n        v[0] = 1;    \\n        for (int i = 1; i < n; i++ )  \\n        { \\n            v[i] = 1; \\n            for (int j = 0; j < i; j++ )   \\n                if ( arr[i] > arr[j] && v[i] < v[j] + 1)  \\n                    v[i] = v[j] + 1;  \\n        } \\n        return v;\\n    } \\n    \\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp_front = fun(nums);\\n        reverse(nums.begin(), nums.end());\\n        vector<int> dp_back = fun(nums);\\n        reverse(dp_back.begin(), dp_back.end());\\n        int ans = INT_MAX;\\n        for(int i=1; i<n-1; i++)\\n            ans = min(ans, n - dp_front[i] - dp_back[i]);\\n\\n        return ans+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 951978,
                "title": "javascript-dp-o-n-2",
                "content": "The whole idea is reducing this problem to finding, for any **VALID** position of the **PEAK**, \\nits **maximum INCREASING subarray\\'s length from its left and maximum DECREASING subarray\\'s length from its right**. \\n\\n**Maximizing** the length from the left and right means that we re essentially **minimizing** the removals. \\n\\nConsider the following example\\n```\\nA   = [ 4 , 3 , 2 , 1 , 1 , 2 , 3 , 1 ]\\nlisL= [ 1 , 1 , 1 , 1 , 1 , 2 , 3 , 1 ]\\nlisR= [ 4 , 3 , 2 , 1 , 1 , 2 , 2 , 1 ]\\n\\nNow consider the 6-th element, \\nits lisL=3, which basically means the subarray [1,2,3]\\nits lisR=2, which basically means the subarray [3,1]\\nif we merge  these two subarrays we get our mountain => [1,2,3,1], of length 4 \\nso I removed 4 elements to create that, which happens to be the result\\n```\\n```\\nvar minimumMountainRemovals = function(A) {\\n    let n=A.length,\\n        lisL=[...Array(n)].map(d=>1),\\n        ldsR=[...Array(n)].map(d=>1)\\n\\n    // longest Increasing subsequence that ends at i \\n    for(let i=0;i<n;i++)\\n        for (let j = 0; j < i; j++) \\n            if(A[i]>A[j])\\n                lisL[i]=Math.max(lisL[i],lisL[j]+1)\\n    // longest Decreasing subsequence that starts at i\\n    for(let i=n-1;i>=0;i--)\\n        for (let j = n-1; j >i; j--) \\n            if(A[i]>A[j])\\n                ldsR[i]=Math.max(ldsR[i],ldsR[j]+1)\\n\\n    let result=Infinity\\n    for (let i = 1; i < n-1; i++) {\\n        let mountainLength=lisL[i]+ldsR[i]-1\\n        if(lisL[i]>1&&ldsR[i]>1)\\n            result=Math.min(result,n-mountainLength)\\n    }\\n    return result\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nA   = [ 4 , 3 , 2 , 1 , 1 , 2 , 3 , 1 ]\\nlisL= [ 1 , 1 , 1 , 1 , 1 , 2 , 3 , 1 ]\\nlisR= [ 4 , 3 , 2 , 1 , 1 , 2 , 2 , 1 ]\\n\\nNow consider the 6-th element, \\nits lisL=3, which basically means the subarray [1,2,3]\\nits lisR=2, which basically means the subarray [3,1]\\nif we merge  these two subarrays we get our mountain => [1,2,3,1], of length 4 \\nso I removed 4 elements to create that, which happens to be the result\\n```\n```\\nvar minimumMountainRemovals = function(A) {\\n    let n=A.length,\\n        lisL=[...Array(n)].map(d=>1),\\n        ldsR=[...Array(n)].map(d=>1)\\n\\n    // longest Increasing subsequence that ends at i \\n    for(let i=0;i<n;i++)\\n        for (let j = 0; j < i; j++) \\n            if(A[i]>A[j])\\n                lisL[i]=Math.max(lisL[i],lisL[j]+1)\\n    // longest Decreasing subsequence that starts at i\\n    for(let i=n-1;i>=0;i--)\\n        for (let j = n-1; j >i; j--) \\n            if(A[i]>A[j])\\n                ldsR[i]=Math.max(ldsR[i],ldsR[j]+1)\\n\\n    let result=Infinity\\n    for (let i = 1; i < n-1; i++) {\\n        let mountainLength=lisL[i]+ldsR[i]-1\\n        if(lisL[i]>1&&ldsR[i]>1)\\n            result=Math.min(result,n-mountainLength)\\n    }\\n    return result\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 951975,
                "title": "c-o-n-2-find-biggest-mountain-deduce-deletions-from-it",
                "content": "We want consider every element from 1 to n-1 as a possible peak. In this approach I\\'m calculating the biggest mountain and using that to see how many elements I have to delete. We look for a smaller element to the left that has the most smaller elements to it\\'s left. Then we do the same for the right side, this accumulates to the biggest mountain. \\n\\n```\\nint minimumMountainRemovals(vector<int>& nums)\\n{\\n    const int size = static_cast<int>( nums.size() );\\n    vector<int> l( size, 0 );\\n    vector<int> r( size, 0 );\\n    \\n    for( int i = 0; i < size; ++i )\\n    {\\n        for( int e = 0; e < i; ++e )\\n            if( nums[e] < nums[i] )\\n                l[i] = max( l[i], l[e]+1 );\\n    }\\n    \\n    for( int i = size-1; i >= 0; --i )\\n    {\\n        for( int e = size-1; e > i; --e )\\n            if( nums[e] < nums[i] )\\n                r[i] = max( r[i], r[e]+1 );\\n    }\\n    \\n    int best = 0;\\n    for( int i = 1; i < (size-1); ++i )\\n        best = max( best, l[i]+r[i]+1 );\\n    \\n    return size-best;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumMountainRemovals(vector<int>& nums)\\n{\\n    const int size = static_cast<int>( nums.size() );\\n    vector<int> l( size, 0 );\\n    vector<int> r( size, 0 );\\n    \\n    for( int i = 0; i < size; ++i )\\n    {\\n        for( int e = 0; e < i; ++e )\\n            if( nums[e] < nums[i] )\\n                l[i] = max( l[i], l[e]+1 );\\n    }\\n    \\n    for( int i = size-1; i >= 0; --i )\\n    {\\n        for( int e = size-1; e > i; --e )\\n            if( nums[e] < nums[i] )\\n                r[i] = max( r[i], r[e]+1 );\\n    }\\n    \\n    int best = 0;\\n    for( int i = 1; i < (size-1); ++i )\\n        best = max( best, l[i]+r[i]+1 );\\n    \\n    return size-best;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090827,
                "title": "python-video-walkthrough",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/ZZFiLUKaC-8)\\n```\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        L = [1] * len(nums)\\n        R = [1] * len(nums)\\n        for i in range(len(nums)):\\n            L[i] = 1 + max([L[j] for j in range(i) if nums[i] > nums[j]], default=0)\\n        for i in range(len(nums)-1,-1,-1):\\n            R[i] = 1 + max([R[j] for j in range(len(nums)-1,i,-1) if nums[i] > nums[j]], default=0)\\n        return min(len(nums) - L[i] - R[i] + 1 for i in range(len(nums)) if L[i] > 1 and R[i] > 1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        L = [1] * len(nums)\\n        R = [1] * len(nums)\\n        for i in range(len(nums)):\\n            L[i] = 1 + max([L[j] for j in range(i) if nums[i] > nums[j]], default=0)\\n        for i in range(len(nums)-1,-1,-1):\\n            R[i] = 1 + max([R[j] for j in range(len(nums)-1,i,-1) if nums[i] > nums[j]], default=0)\\n        return min(len(nums) - L[i] - R[i] + 1 for i in range(len(nums)) if L[i] > 1 and R[i] > 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086202,
                "title": "lis-twice-with-o-n",
                "content": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n = nums.length;  \\n\\n        // Using left dp to find out the min elements to be removed for each index.\\n        int []left = new int[n];\\n        for(int i=0; i<n; i++) {\\n            int minRequired = i;\\n            for(int j=0; j<i; j++) {\\n                if(nums[j] < nums[i]) {\\n                    minRequired = Math.min(minRequired, i - j - 1 + left[j]);\\n                }\\n            }\\n            left[i] = minRequired;\\n        }\\n        \\n         // Using right dp to find out the min elements to be removed for each index.\\n        int []right = new int[n];\\n        Arrays.fill(right, 0);\\n        for(int i= n-1; i>=0; i--) {\\n            int minRequired = n - i - 1;\\n            for(int j=n-1; j>i; j--) {\\n                if(nums[j] < nums[i]) {\\n                    minRequired = Math.min(minRequired, j - i - 1 + right[j]);\\n                }\\n            }\\n            right[i] = minRequired;\\n        }\\n        \\n        \\n        // Exclude if any element after removal becomes first or last. \\n        int minRemovals = n;\\n        for(int i=1; i<n-1; i++) {\\n            if(left[i] != i && right[i] != n - i -1) {\\n                minRemovals = Math.min(minRemovals, left[i] + right[i]);\\n            }\\n        }\\n        \\n        return minRemovals;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n = nums.length;  \\n\\n        // Using left dp to find out the min elements to be removed for each index.\\n        int []left = new int[n];\\n        for(int i=0; i<n; i++) {\\n            int minRequired = i;\\n            for(int j=0; j<i; j++) {\\n                if(nums[j] < nums[i]) {\\n                    minRequired = Math.min(minRequired, i - j - 1 + left[j]);\\n                }\\n            }\\n            left[i] = minRequired;\\n        }\\n        \\n         // Using right dp to find out the min elements to be removed for each index.\\n        int []right = new int[n];\\n        Arrays.fill(right, 0);\\n        for(int i= n-1; i>=0; i--) {\\n            int minRequired = n - i - 1;\\n            for(int j=n-1; j>i; j--) {\\n                if(nums[j] < nums[i]) {\\n                    minRequired = Math.min(minRequired, j - i - 1 + right[j]);\\n                }\\n            }\\n            right[i] = minRequired;\\n        }\\n        \\n        \\n        // Exclude if any element after removal becomes first or last. \\n        int minRemovals = n;\\n        for(int i=1; i<n-1; i++) {\\n            if(left[i] != i && right[i] != n - i -1) {\\n                minRemovals = Math.min(minRemovals, left[i] + right[i]);\\n            }\\n        }\\n        \\n        return minRemovals;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084686,
                "title": "easy-o-nlogn-solution-binary-search-beginner-code",
                "content": "# Intution\\n\\nIf we consider the ith element as the peak element, then try to calculate the strictly increasing subsequence from left and also try to calculate the strictly decreasing subsequence from right.\\n\\nThis subsequence can be found using binary search by creating a temporary array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     \\n    int minimumMountainRemovals(vector<int>& nums) {\\n\\n        int n = nums.size();\\n        \\n        vector<int> res;\\n        res.push_back(nums[0]);\\n\\n        vector<int>length(n, 0);\\n        length[0] = 1;\\n        \\n        for(int i=1; i<n; i++){\\n            if(nums[i] > res.back()) {\\n                res.push_back(nums[i]);\\n                length[i] = res.size();\\n            } else {\\n                int index;\\n                int l = 0;\\n                int r = res.size() - 1;\\n                while(l <= r){\\n                    int mid = l + (r - l) / 2;\\n                    if(res[mid] >= nums[i]) {\\n                        index = mid;\\n                        r = mid - 1;\\n                    } else {\\n                        l = mid + 1;\\n                    }\\n                }\\n                res[index] = nums[i];\\n                length[i] = index + 1;\\n            }\\n        }\\n\\n\\n        reverse(nums.begin(), nums.end());\\n        res.clear();\\n        res.push_back(nums[0]);\\n\\n        vector<int>length1(n, 0);\\n        length1[n - 1 - 0] = 1;\\n        \\n        for(int i=1; i<n; i++){\\n            if(nums[i] > res.back()) {\\n                res.push_back(nums[i]);\\n                length1[(n - 1) - (i)] = res.size();\\n            } else {\\n                int index;\\n                int l = 0;\\n                int r = res.size() - 1;\\n                while(l <= r){\\n                    int mid = l + (r - l) / 2;\\n                    if(res[mid] >= nums[i]) {\\n                        index = mid;\\n                        r = mid - 1;\\n                    } else {\\n                        l = mid + 1;\\n                    }\\n                }\\n                res[index] = nums[i];\\n                length1[(n - 1) - (i)] = index + 1;\\n            }\\n        }\\n\\n\\n        int maxilength = 0;\\n\\n        for(int i = 1; i < n - 1; i++) {\\n            if(length[i] >= 2 && length1[i] >= 2)\\n            maxilength = max(maxilength, length[i] + length1[i] - 1);\\n        }\\n\\n        return n - maxilength;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     \\n    int minimumMountainRemovals(vector<int>& nums) {\\n\\n        int n = nums.size();\\n        \\n        vector<int> res;\\n        res.push_back(nums[0]);\\n\\n        vector<int>length(n, 0);\\n        length[0] = 1;\\n        \\n        for(int i=1; i<n; i++){\\n            if(nums[i] > res.back()) {\\n                res.push_back(nums[i]);\\n                length[i] = res.size();\\n            } else {\\n                int index;\\n                int l = 0;\\n                int r = res.size() - 1;\\n                while(l <= r){\\n                    int mid = l + (r - l) / 2;\\n                    if(res[mid] >= nums[i]) {\\n                        index = mid;\\n                        r = mid - 1;\\n                    } else {\\n                        l = mid + 1;\\n                    }\\n                }\\n                res[index] = nums[i];\\n                length[i] = index + 1;\\n            }\\n        }\\n\\n\\n        reverse(nums.begin(), nums.end());\\n        res.clear();\\n        res.push_back(nums[0]);\\n\\n        vector<int>length1(n, 0);\\n        length1[n - 1 - 0] = 1;\\n        \\n        for(int i=1; i<n; i++){\\n            if(nums[i] > res.back()) {\\n                res.push_back(nums[i]);\\n                length1[(n - 1) - (i)] = res.size();\\n            } else {\\n                int index;\\n                int l = 0;\\n                int r = res.size() - 1;\\n                while(l <= r){\\n                    int mid = l + (r - l) / 2;\\n                    if(res[mid] >= nums[i]) {\\n                        index = mid;\\n                        r = mid - 1;\\n                    } else {\\n                        l = mid + 1;\\n                    }\\n                }\\n                res[index] = nums[i];\\n                length1[(n - 1) - (i)] = index + 1;\\n            }\\n        }\\n\\n\\n        int maxilength = 0;\\n\\n        for(int i = 1; i < n - 1; i++) {\\n            if(length[i] >= 2 && length1[i] >= 2)\\n            maxilength = max(maxilength, length[i] + length1[i] - 1);\\n        }\\n\\n        return n - maxilength;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070833,
                "title": "java-lis-no-dp-easy-understanding",
                "content": "\\n1. Initialize two arrays, \"left\" and \"right,\" to keep track of the longest increasing subsequence to the left and right of each element in the \"nums\" array.\\n\\n2. Iterate through the \"nums\" array from left to right (index \"i\") and, for each element, find the longest increasing subsequence to the left of it. Store this value in the \"left\" array.\\n\\n3. Similarly, iterate through the \"nums\" array from right to left (index \"i\") and, for each element, find the longest increasing subsequence to the right of it. Store this value in the \"right\" array.\\n\\n4. Then, iterate through the \"nums\" array again (excluding the first and last elements) and calculate the length of the mountain sequence that can be formed using each element as the peak. This is done by summing the \"left\" and \"right\" values for that element, plus 1 for the peak itself, and finding the maximum length.\\n\\n5. Finally, return the difference between the length of the \"nums\" array and the maximum mountain length found in step 4. This represents the minimum number of elements that need to be removed to create a mountain array.\\n\\n```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n = nums.length ;\\n        int left[] = new int[n] ;\\n        left[0] = 0 ;\\n        int right[] = new int[n] ;\\n        right[n-1] = 0 ;\\n         for (int i = 1; i < n; i++) {\\n            int ans = 0;\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] < nums[i]) {\\n                    ans = Math.max(left[j] + 1, ans);\\n                }\\n            }\\n            left[i] = ans;\\n        }\\n        for(int i=n-2; i>=0; i--) {\\n            int ans = 0 ;\\n           for(int j=n-1; j>i; j--) {\\n               if(nums[j]<nums[i]) {\\n                   ans=Math.max(right[j]+1,ans) ;\\n               }\\n           }\\n            right[i]=ans ;\\n        }\\n        int ans = 0;\\n        for (int i = 1; i < n - 1; i++) {\\n            if (left[i] > 0 && right[i] > 0) {\\n                ans = Math.max(ans, left[i] + right[i] + 1);\\n            }\\n        }\\n        return n - ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int n = nums.length ;\\n        int left[] = new int[n] ;\\n        left[0] = 0 ;\\n        int right[] = new int[n] ;\\n        right[n-1] = 0 ;\\n         for (int i = 1; i < n; i++) {\\n            int ans = 0;\\n            for (int j = 0; j < i; j++) {\\n                if (nums[j] < nums[i]) {\\n                    ans = Math.max(left[j] + 1, ans);\\n                }\\n            }\\n            left[i] = ans;\\n        }\\n        for(int i=n-2; i>=0; i--) {\\n            int ans = 0 ;\\n           for(int j=n-1; j>i; j--) {\\n               if(nums[j]<nums[i]) {\\n                   ans=Math.max(right[j]+1,ans) ;\\n               }\\n           }\\n            right[i]=ans ;\\n        }\\n        int ans = 0;\\n        for (int i = 1; i < n - 1; i++) {\\n            if (left[i] > 0 && right[i] > 0) {\\n                ans = Math.max(ans, left[i] + right[i] + 1);\\n            }\\n        }\\n        return n - ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063427,
                "title": "bs-solution-lis",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums){\\n        int n = nums.size();\\n        vector<int> a1, a2; \\n        vector<int> ans;\\n        ans.push_back(nums[0]);\\n        a1.push_back(1);\\n        for(int i = 1; i<nums.size(); i++){\\n            if(nums[i] > ans.back()) ans.push_back(nums[i]);\\n            else {\\n                int low = lower_bound(ans.begin(), ans.end(), nums[i]) - ans.begin();\\n                ans[low] = nums[i];\\n            }\\n            a1.push_back(ans.size());\\n        }\\n        ans.clear();\\n        reverse(nums.begin(), nums.end());\\n        ans.push_back(nums[0]);\\n        a2.push_back(1);\\n        for(int i = 1; i<nums.size(); i++){\\n            if(nums[i] > ans.back()) ans.push_back(nums[i]);\\n            else {\\n                int low = lower_bound(ans.begin(), ans.end(), nums[i]) - ans.begin();\\n                ans[low] = nums[i];\\n            }\\n            a2.push_back(ans.size());\\n        }\\n        int maxi = -1;\\n        for(int i = 0; i<a1.size() - 1; i++){\\n            if(a1[i] > 1 && a2[n-1-i] > 1) maxi = max(maxi, a1[i] + a2[n-1 -i]);\\n        }\\n        return a1.size() - maxi + 1;\\n    }\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        // we need to find the longest increasing subsequence. form the front and from the back.\\n        return solve(nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &nums){\\n        int n = nums.size();\\n        vector<int> a1, a2; \\n        vector<int> ans;\\n        ans.push_back(nums[0]);\\n        a1.push_back(1);\\n        for(int i = 1; i<nums.size(); i++){\\n            if(nums[i] > ans.back()) ans.push_back(nums[i]);\\n            else {\\n                int low = lower_bound(ans.begin(), ans.end(), nums[i]) - ans.begin();\\n                ans[low] = nums[i];\\n            }\\n            a1.push_back(ans.size());\\n        }\\n        ans.clear();\\n        reverse(nums.begin(), nums.end());\\n        ans.push_back(nums[0]);\\n        a2.push_back(1);\\n        for(int i = 1; i<nums.size(); i++){\\n            if(nums[i] > ans.back()) ans.push_back(nums[i]);\\n            else {\\n                int low = lower_bound(ans.begin(), ans.end(), nums[i]) - ans.begin();\\n                ans[low] = nums[i];\\n            }\\n            a2.push_back(ans.size());\\n        }\\n        int maxi = -1;\\n        for(int i = 0; i<a1.size() - 1; i++){\\n            if(a1[i] > 1 && a2[n-1-i] > 1) maxi = max(maxi, a1[i] + a2[n-1 -i]);\\n        }\\n        return a1.size() - maxi + 1;\\n    }\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        // we need to find the longest increasing subsequence. form the front and from the back.\\n        return solve(nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059355,
                "title": "java-lis-o-n-logn",
                "content": "# Code\\n```java\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int[] left = new int[nums.length];\\n        int[] right = new int[nums.length];\\n        List<Integer> lis = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            left[i] = lengthOfLIS(lis, nums[i]);\\n        }\\n\\n        lis.clear();\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            right[i] = lengthOfLIS(lis, nums[i]);\\n        }\\n\\n        int ans = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (left[i] >= 2 && right[i] >= 2) {\\n                int val = left[i] + right[i] - 1;\\n                ans = Math.max(ans, val);\\n            }\\n        }\\n        return nums.length - ans;\\n    }\\n\\n    \\n    public int lengthOfLIS(List<Integer> sub, int num) {\\n        if (sub.isEmpty() || num > sub.get(sub.size() - 1)) {\\n            sub.add(num);\\n            return sub.size();\\n        } else {\\n            int j = binarySearch(sub, num);\\n            sub.set(j, num);\\n            return j + 1;\\n        }\\n    }\\n    \\n    private int binarySearch(List<Integer> sub, int num) {\\n        int left = 0;\\n        int right = sub.size() - 1;\\n        \\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (sub.get(mid) == num) {\\n                return mid;\\n            }\\n            \\n            if (sub.get(mid) < num) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int[] left = new int[nums.length];\\n        int[] right = new int[nums.length];\\n        List<Integer> lis = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            left[i] = lengthOfLIS(lis, nums[i]);\\n        }\\n\\n        lis.clear();\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            right[i] = lengthOfLIS(lis, nums[i]);\\n        }\\n\\n        int ans = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (left[i] >= 2 && right[i] >= 2) {\\n                int val = left[i] + right[i] - 1;\\n                ans = Math.max(ans, val);\\n            }\\n        }\\n        return nums.length - ans;\\n    }\\n\\n    \\n    public int lengthOfLIS(List<Integer> sub, int num) {\\n        if (sub.isEmpty() || num > sub.get(sub.size() - 1)) {\\n            sub.add(num);\\n            return sub.size();\\n        } else {\\n            int j = binarySearch(sub, num);\\n            sub.set(j, num);\\n            return j + 1;\\n        }\\n    }\\n    \\n    private int binarySearch(List<Integer> sub, int num) {\\n        int left = 0;\\n        int right = sub.size() - 1;\\n        \\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (sub.get(mid) == num) {\\n                return mid;\\n            }\\n            \\n            if (sub.get(mid) < num) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056153,
                "title": "simple-c-solution-using-lis",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> dp1(n, 1);\\n        \\n        for(int ind = 0; ind < n; ind++)\\n        {\\n            for(int prev = 0; prev < ind; prev++)\\n            {\\n                if(nums[prev] < nums[ind] && 1 + dp1[prev] > dp1[ind])\\n                {\\n                    dp1[ind] = 1 + dp1[prev];\\n                }\\n            }\\n        }\\n        \\n        vector<int> dp2(n, 1);\\n        \\n        for(int ind = n - 1; ind >= 0; ind--)\\n        {\\n            for(int prev = n - 1; prev > ind; prev--)\\n            {\\n                if(nums[prev] < nums[ind] && 1 + dp2[prev] > dp2[ind])\\n                {\\n                    dp2[ind] = 1 + dp2[prev];\\n                }\\n            }\\n        }\\n        \\n        int maxi = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(dp2[i] > 1 && dp1[i] > 1)\\n                maxi = max(maxi, dp1[i] + dp2[i] - 1);\\n        }\\n        \\n        return n - maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> dp1(n, 1);\\n        \\n        for(int ind = 0; ind < n; ind++)\\n        {\\n            for(int prev = 0; prev < ind; prev++)\\n            {\\n                if(nums[prev] < nums[ind] && 1 + dp1[prev] > dp1[ind])\\n                {\\n                    dp1[ind] = 1 + dp1[prev];\\n                }\\n            }\\n        }\\n        \\n        vector<int> dp2(n, 1);\\n        \\n        for(int ind = n - 1; ind >= 0; ind--)\\n        {\\n            for(int prev = n - 1; prev > ind; prev--)\\n            {\\n                if(nums[prev] < nums[ind] && 1 + dp2[prev] > dp2[ind])\\n                {\\n                    dp2[ind] = 1 + dp2[prev];\\n                }\\n            }\\n        }\\n        \\n        int maxi = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(dp2[i] > 1 && dp1[i] > 1)\\n                maxi = max(maxi, dp1[i] + dp2[i] - 1);\\n        }\\n        \\n        return n - maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032822,
                "title": "striver-lis-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp1(n,1);\\n        vector<int> dp2(n, 1);\\n        // find LIS\\n        int maxi=0;\\n        for(int i=0; i<n; i++){\\n            for(int prev=0; prev<i; prev++){\\n                if(nums[i] > nums[prev] && 1+dp1[prev] > dp1[i] ){\\n                    dp1[i] = 1+dp1[prev];\\n                }\\n            }\\n        }\\n        for(int i=n-1; i>=0; i--){\\n            for(int prev=n-1; prev>i; prev--){\\n                if(nums[i] > nums[prev] && 1+dp2[prev] > dp2[i]){\\n                    dp2[i] =1+dp2[prev];\\n                }\\n            }\\n        }\\n        int longest =0;\\n        for(int i=0; i<n; i++){\\n            if(dp2[i] >1 and dp1[i]>1){\\n                int len= dp1[i] + dp2[i]-1;\\n                longest = max(longest,len);\\n            }\\n        }\\n        return n-longest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp1(n,1);\\n        vector<int> dp2(n, 1);\\n        // find LIS\\n        int maxi=0;\\n        for(int i=0; i<n; i++){\\n            for(int prev=0; prev<i; prev++){\\n                if(nums[i] > nums[prev] && 1+dp1[prev] > dp1[i] ){\\n                    dp1[i] = 1+dp1[prev];\\n                }\\n            }\\n        }\\n        for(int i=n-1; i>=0; i--){\\n            for(int prev=n-1; prev>i; prev--){\\n                if(nums[i] > nums[prev] && 1+dp2[prev] > dp2[i]){\\n                    dp2[i] =1+dp2[prev];\\n                }\\n            }\\n        }\\n        int longest =0;\\n        for(int i=0; i<n; i++){\\n            if(dp2[i] >1 and dp1[i]>1){\\n                int len= dp1[i] + dp2[i]-1;\\n                longest = max(longest,len);\\n            }\\n        }\\n        return n-longest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026165,
                "title": "c-dp-lis-variation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n,1);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                dp[i] = max(dp[i],dp[j]+1);\\n            }\\n        }\\n        \\n        vector<int> dp1(n,1);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=n-1;j>i;j--)\\n            {\\n                if(nums[i]>nums[j])\\n                dp1[i] = max(dp1[i],dp1[j]+1);\\n            }\\n        }\\n        int ans = INT_MIN;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(dp[i]!=1 && dp1[i]!=1)\\n            ans = max(ans,(dp[i]+dp1[i]-1));\\n        }\\n        return n-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n,1);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                dp[i] = max(dp[i],dp[j]+1);\\n            }\\n        }\\n        \\n        vector<int> dp1(n,1);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=n-1;j>i;j--)\\n            {\\n                if(nums[i]>nums[j])\\n                dp1[i] = max(dp1[i],dp1[j]+1);\\n            }\\n        }\\n        int ans = INT_MIN;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(dp[i]!=1 && dp1[i]!=1)\\n            ans = max(ans,(dp[i]+dp1[i]-1));\\n        }\\n        return n-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003060,
                "title": "python-lis-lds",
                "content": "# Complexity\\n- Time complexity: O(n^2)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        lis = [1]*n\\n        lds = [1]*n\\n\\n        for i in range(n):\\n            num1 = nums[i]\\n            for j in range(i):\\n                num2 = nums[j]\\n                if num1 > num2:\\n                    lis[i] = max(lis[i], 1+lis[j])\\n                \\n        for i in reversed(range(n)):\\n            num1 = nums[i]\\n            for j in reversed(range(i+1, n)):\\n                num2 = nums[j]\\n                if num1 > num2:\\n                    lds[i] = max(lds[i], 1+lds[j])\\n\\n        mtn_wid = 0\\n        for a, b in zip(lis, lds):\\n            if a == 1 or b == 1: continue \\n            # impossible for a mountain to be formed if a==1 or b==1\\n            # e.g. it means that there is not a sequence leading up to this point\\n            mtn_wid = max(a+b-1, mtn_wid)\\n\\n        return n-mtn_wid\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        lis = [1]*n\\n        lds = [1]*n\\n\\n        for i in range(n):\\n            num1 = nums[i]\\n            for j in range(i):\\n                num2 = nums[j]\\n                if num1 > num2:\\n                    lis[i] = max(lis[i], 1+lis[j])\\n                \\n        for i in reversed(range(n)):\\n            num1 = nums[i]\\n            for j in reversed(range(i+1, n)):\\n                num2 = nums[j]\\n                if num1 > num2:\\n                    lds[i] = max(lds[i], 1+lds[j])\\n\\n        mtn_wid = 0\\n        for a, b in zip(lis, lds):\\n            if a == 1 or b == 1: continue \\n            # impossible for a mountain to be formed if a==1 or b==1\\n            # e.g. it means that there is not a sequence leading up to this point\\n            mtn_wid = max(a+b-1, mtn_wid)\\n\\n        return n-mtn_wid\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992618,
                "title": "not-passing-the-last-7-test-cases-can-anyone-please-help",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI find the length of the longest bitonic subsequence and subtract the len of array \\n\\nTo find the longest Bitonic Subsequence, \\nI calculate the Longest increasing subsequence forward and backward.\\nThen I reverse my backward DP again so there\\'s an index match when calculating the longest length for the bitonic subsequence. However, I still dont understand why those test cases are failing :(\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        #Find the Length of the Longest Bitonic Sequence and subtract it from the length of the array \\n\\n        lisF = self.LongestIncreasingSubsequence(nums)\\n        lisB = self.LongestIncreasingSubsequence(nums[::-1])\\n\\n        longestBitonic = 1\\n        for i in range(len(nums)):\\n            if lisF[i] > 1 and lisB[::-1][i] > 1:\\n                longestBitonic = max(longestBitonic, lisF[i] + lisB[::-1][i] - 1)\\n        \\n        return len(nums) - longestBitonic\\n\\n\\n    def LongestIncreasingSubsequence(self, nums):\\n        dp = [1] * len(nums)\\n\\n        for i in range(1, len(nums)):\\n            for j in range(i):\\n                if nums[j] < nums[i] and dp[i] <= dp[j]:\\n                    dp[i] = 1 + dp[j]\\n                \\n        \\n        return dp \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        #Find the Length of the Longest Bitonic Sequence and subtract it from the length of the array \\n\\n        lisF = self.LongestIncreasingSubsequence(nums)\\n        lisB = self.LongestIncreasingSubsequence(nums[::-1])\\n\\n        longestBitonic = 1\\n        for i in range(len(nums)):\\n            if lisF[i] > 1 and lisB[::-1][i] > 1:\\n                longestBitonic = max(longestBitonic, lisF[i] + lisB[::-1][i] - 1)\\n        \\n        return len(nums) - longestBitonic\\n\\n\\n    def LongestIncreasingSubsequence(self, nums):\\n        dp = [1] * len(nums)\\n\\n        for i in range(1, len(nums)):\\n            for j in range(i):\\n                if nums[j] < nums[i] and dp[i] <= dp[j]:\\n                    dp[i] = 1 + dp[j]\\n                \\n        \\n        return dp \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991670,
                "title": "patience-sorting-explanation-and-solution-c",
                "content": "****Actually, this problem is quite basic. Because the complexity that can pass this test is only O(N^2) (Conditions for the test say n = 1000).****\\n\\n* Realizing that the complexity is quite loose, we can immediately use Dynamic Programming (LIS).\\n\\n**Simple idea:**\\n* We only need to keep track of the longest increasing subsequence on the left and right side (on the right, we will return from the end).\\n* Then check which position can find the longest Mountain Array (To avoid overlapping 1 vertex we will subtract 1), then we choose the position from 1 <= i <= n - 1 and then calculate the length Initially \"nums\" then subtract the longest Mountain Plate to get the final result.\\n\\n****But to optimize the complexity down to O(nlog(n)) we need to know binary search (It will be like cards set out for us to compare and gradually fill in. If it <= original card then we put it on the original card, but if we can\\'t find the original card, we will find a new place to put the card on top).****\\n\\n****Vote if you think it\\'s good****\\n\\n****Here is my C++ code you can refer to****\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> dp[2], max_len[2];\\n        max_len[0].resize(n);\\n        max_len[1].resize(n);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            auto it = lower_bound(dp[0].begin(), dp[0].end(), nums[i]);\\n            if (it == dp[0].end()) {\\n                dp[0].push_back(nums[i]);\\n                max_len[0][i] = dp[0].size();\\n            }\\n            else {\\n                *it = nums[i];\\n                max_len[0][i] = distance(dp[0].begin(), it) + 1;\\n            }\\n        }\\n        \\n        for (int i = n - 1; i >= 0; --i) {\\n            auto it = lower_bound(dp[1].begin(), dp[1].end(), nums[i]);\\n            if (it == dp[1].end()) {\\n                dp[1].push_back(nums[i]);\\n                max_len[1][i] = dp[1].size();\\n            }\\n            else {\\n                *it = nums[i];\\n                max_len[1][i] = distance(dp[1].begin(), it) + 1;\\n            }\\n        }\\n        \\n        int LIS_ = 0;\\n        \\n        for (int i = 1; i < n - 1; ++i) {\\n            if (max_len[0][i] > 1 and max_len[1][i] > 1) {\\n                LIS_ = max(LIS_, max_len[0][i] + max_len[1][i] - 1);\\n            }\\n        }\\n        \\n        return n - LIS_;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> dp[2], max_len[2];\\n        max_len[0].resize(n);\\n        max_len[1].resize(n);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            auto it = lower_bound(dp[0].begin(), dp[0].end(), nums[i]);\\n            if (it == dp[0].end()) {\\n                dp[0].push_back(nums[i]);\\n                max_len[0][i] = dp[0].size();\\n            }\\n            else {\\n                *it = nums[i];\\n                max_len[0][i] = distance(dp[0].begin(), it) + 1;\\n            }\\n        }\\n        \\n        for (int i = n - 1; i >= 0; --i) {\\n            auto it = lower_bound(dp[1].begin(), dp[1].end(), nums[i]);\\n            if (it == dp[1].end()) {\\n                dp[1].push_back(nums[i]);\\n                max_len[1][i] = dp[1].size();\\n            }\\n            else {\\n                *it = nums[i];\\n                max_len[1][i] = distance(dp[1].begin(), it) + 1;\\n            }\\n        }\\n        \\n        int LIS_ = 0;\\n        \\n        for (int i = 1; i < n - 1; ++i) {\\n            if (max_len[0][i] > 1 and max_len[1][i] > 1) {\\n                LIS_ = max(LIS_, max_len[0][i] + max_len[1][i] - 1);\\n            }\\n        }\\n        \\n        return n - LIS_;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982679,
                "title": "lis-tabulation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j] && 1+dp[j]>dp[i]){\\n                    dp[i]=1+dp[j];\\n                }\\n            }\\n        }\\n        reverse(nums.begin(),nums.end());\\n        vector<int>dp1(n,1);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j] && 1+dp1[j]>dp1[i]){\\n                    dp1[i]=1+dp1[j];\\n                }\\n            }\\n        }\\n        reverse(dp1.begin(),dp1.end());\\n        int maxi=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            if(dp[i]>1 && dp1[i]>1)maxi=max(maxi,dp[i]+dp1[i]-1);\\n        }\\n        return n-maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp(n,1);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j] && 1+dp[j]>dp[i]){\\n                    dp[i]=1+dp[j];\\n                }\\n            }\\n        }\\n        reverse(nums.begin(),nums.end());\\n        vector<int>dp1(n,1);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(nums[i]>nums[j] && 1+dp1[j]>dp1[i]){\\n                    dp1[i]=1+dp1[j];\\n                }\\n            }\\n        }\\n        reverse(dp1.begin(),dp1.end());\\n        int maxi=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            if(dp[i]>1 && dp1[i]>1)maxi=max(maxi,dp[i]+dp1[i]-1);\\n        }\\n        return n-maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981719,
                "title": "lbs-dp-memoization",
                "content": "\\n\\n# Approach\\n\\nThis is just **Longest Bitonic Subsequence**.\\nFor example if a n array is of length 5 and the LBS is 3 it means we have to delete 5-3 elements.\\nso question just broke down to LBS.\\n***Here is to calculate LBS***\\nSimple lets suppose there is an array of 5 size.\\nFor LBS we will calculate each index\\'s longest increasing subsequence(from 0 to i)and longest decreasing subsequence(from i to n-1).\\n# Complexity\\n- Time complexity:\\no(n*n)\\n\\n- Space complexity:\\no(n*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int lds(vector<int>&nums,int i,int pre,vector<vector<int>>&dp1)\\n    {\\n        if(i==nums.size())\\n        return 0;\\n        if(dp1[i][pre]!=-1)\\n        return dp1[i][pre];\\n        if(nums[i]<nums[pre])\\n        return dp1[i][pre]=max(1+lds(nums,i+1,i,dp1),lds(nums,i+1,pre,dp1));\\n        else\\n        return dp1[i][pre]=lds(nums,i+1,pre,dp1);\\n    }\\n\\n    int lis(vector<int>&nums,int i,int pre,vector<vector<int>>&dp2)\\n    {\\n        if(i==-1)\\n        return 0;\\n        if(dp2[i][pre]!=-1)\\n        return dp2[i][pre];\\n        if(nums[i]<nums[pre])\\n        return dp2[i][pre]=max(1+lis(nums,i-1,i,dp2),lis(nums,i-1,pre,dp2));\\n        else\\n        return dp2[i][pre]=lis(nums,i-1,pre,dp2);\\n    }\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n\\n      int ans=INT_MIN;\\n      int n=nums.size();\\n      vector<vector<int>>dp1(n,vector<int>(n,-1));\\n      vector<vector<int>>dp2(n,vector<int>(n,-1));\\n      for(int i=1;i<n-1;i++)\\n      {\\n        int right=lds(nums,i+1,i,dp1);\\n        \\n        if(right==0)\\n        continue;\\n\\n        int left=lis(nums,i-1,i,dp2);\\n\\n        if(left==0)\\n        continue;\\n\\n        ans=max(ans,left+right+1);\\n      }\\n\\n      return n-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int lds(vector<int>&nums,int i,int pre,vector<vector<int>>&dp1)\\n    {\\n        if(i==nums.size())\\n        return 0;\\n        if(dp1[i][pre]!=-1)\\n        return dp1[i][pre];\\n        if(nums[i]<nums[pre])\\n        return dp1[i][pre]=max(1+lds(nums,i+1,i,dp1),lds(nums,i+1,pre,dp1));\\n        else\\n        return dp1[i][pre]=lds(nums,i+1,pre,dp1);\\n    }\\n\\n    int lis(vector<int>&nums,int i,int pre,vector<vector<int>>&dp2)\\n    {\\n        if(i==-1)\\n        return 0;\\n        if(dp2[i][pre]!=-1)\\n        return dp2[i][pre];\\n        if(nums[i]<nums[pre])\\n        return dp2[i][pre]=max(1+lis(nums,i-1,i,dp2),lis(nums,i-1,pre,dp2));\\n        else\\n        return dp2[i][pre]=lis(nums,i-1,pre,dp2);\\n    }\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n\\n      int ans=INT_MIN;\\n      int n=nums.size();\\n      vector<vector<int>>dp1(n,vector<int>(n,-1));\\n      vector<vector<int>>dp2(n,vector<int>(n,-1));\\n      for(int i=1;i<n-1;i++)\\n      {\\n        int right=lds(nums,i+1,i,dp1);\\n        \\n        if(right==0)\\n        continue;\\n\\n        int left=lis(nums,i-1,i,dp2);\\n\\n        if(left==0)\\n        continue;\\n\\n        ans=max(ans,left+right+1);\\n      }\\n\\n      return n-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965864,
                "title": "easy-solution-using-longest-increasing-subsequnece",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        vector<int> dp1(n,1);\\n        vector<int> dp2(n,1);\\n        //for increasing subsequence \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[j]<nums[i])\\n                {\\n                    dp1[i]=max(dp1[i],dp1[j]+1);\\n                }\\n            }\\n        }\\n\\n        //for decresing subsequence\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=n-1;j>i;j--)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    dp2[i]=max(dp2[i],dp2[j]+1);\\n                }\\n            }\\n        }\\n        int lis=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp1[i]>1 && dp2[i]>1)\\n            lis=max(lis,dp1[i]+dp2[i]-1);\\n        }\\n        return n-lis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        vector<int> dp1(n,1);\\n        vector<int> dp2(n,1);\\n        //for increasing subsequence \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[j]<nums[i])\\n                {\\n                    dp1[i]=max(dp1[i],dp1[j]+1);\\n                }\\n            }\\n        }\\n\\n        //for decresing subsequence\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=n-1;j>i;j--)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    dp2[i]=max(dp2[i],dp2[j]+1);\\n                }\\n            }\\n        }\\n        int lis=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp1[i]>1 && dp2[i]>1)\\n            lis=max(lis,dp1[i]+dp2[i]-1);\\n        }\\n        return n-lis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963493,
                "title": "c-lis-binary-search-step-wise-approach",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n//IF WE FIND THE LENGTH OFM THE LONGEST MOUNTAIN ARRAY and SUBTRACT FROM THE LENGTH OF NUMS ARRAY WE GET THE REQUIRED NO. OF REMOVALS.\\n    int LISbinarySearch(vector<int>& nums,vector<int>& lis)\\n    {\\n        if(nums.size()==0)\\n            return 0;\\n\\n        vector<int> ans;//this array will store the length of LIS considering each element(index) as pivot(endpoint).\\n        //current element tak sabse lambe increasing substring ka length kitna he.\\n\\n        //length of LIS for the first element is always 1. as there are no elements smaller then the first element of nums array.\\n        \\n        lis.push_back(1);\\n        ans.push_back(nums[0]);\\n\\n        for(int index=1;index<nums.size();index++)\\n        {\\n            if(nums[index]>ans.back())\\n            {\\n                ans.push_back(nums[index]); //if the current element of nums array is greater than the last inserted element of ans array then just replace it in the last (index)position.\\n\\n                lis.push_back(ans.size());\\n            }\\n            else\\n            {\\n                //justBiggerIndex return the index of the element in ans array which is just greater than the cureent element of nums array.\\n                int justBiggerIndex=lower_bound(ans.begin(),ans.end(),nums[index])-ans.begin();\\n                //insert it at that position.\\n                ans[justBiggerIndex]=nums[index];\\n                lis.push_back(justBiggerIndex+1);\\n                //in this case justBiggerIndex+1 will be the length of LIS just less than the current element.\\n            }\\n        }\\n        return ans.size();\\n    }\\n    int minimumMountainRemovals(vector<int>& nums) \\n    {\\n        \\n        vector<int> lis;\\n        //this array stores the length of the LIS till each element of nums array (considering it as pivot = last element).(xth(x is the index) element tak LIS ka length kitna he.)\\n        vector<int> lds; //lds=longest decreasing subsequence.\\n\\n        LISbinarySearch(nums,lis);\\n        //this array stores the length of the LIS till each element of reversed nums array.works just like the lis array but for reversed nums array.\\n\\n        reverse(nums.begin(),nums.end());\\n\\n        LISbinarySearch(nums,lds);\\n\\n        //when we reverse the lds array we get the longest decreasing subsequence of the nums array.//considering each element as the pivot.(starting point)\\n        reverse(lds.begin(),lds.end());\\n\\n      \\n         int maximumLengthOfMountainArray=INT_MIN;\\n\\n        for(int k=0;k<nums.size();++k)\\n        {\\n            if(lis[k]==1 || lds[k]==1)\\n                continue;\\n            maximumLengthOfMountainArray=max(maximumLengthOfMountainArray,lis[k]+lds[k]-1); //as one element will be repeated twice in , once in lis array & once in lds array thus we subtract 1.\\n        }\\n\\n        int MinimumNumberofRemovals=nums.size()-maximumLengthOfMountainArray; //rest of the element need to be removed.\\n        return MinimumNumberofRemovals;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n//IF WE FIND THE LENGTH OFM THE LONGEST MOUNTAIN ARRAY and SUBTRACT FROM THE LENGTH OF NUMS ARRAY WE GET THE REQUIRED NO. OF REMOVALS.\\n    int LISbinarySearch(vector<int>& nums,vector<int>& lis)\\n    {\\n        if(nums.size()==0)\\n            return 0;\\n\\n        vector<int> ans;//this array will store the length of LIS considering each element(index) as pivot(endpoint).\\n        //current element tak sabse lambe increasing substring ka length kitna he.\\n\\n        //length of LIS for the first element is always 1. as there are no elements smaller then the first element of nums array.\\n        \\n        lis.push_back(1);\\n        ans.push_back(nums[0]);\\n\\n        for(int index=1;index<nums.size();index++)\\n        {\\n            if(nums[index]>ans.back())\\n            {\\n                ans.push_back(nums[index]); //if the current element of nums array is greater than the last inserted element of ans array then just replace it in the last (index)position.\\n\\n                lis.push_back(ans.size());\\n            }\\n            else\\n            {\\n                //justBiggerIndex return the index of the element in ans array which is just greater than the cureent element of nums array.\\n                int justBiggerIndex=lower_bound(ans.begin(),ans.end(),nums[index])-ans.begin();\\n                //insert it at that position.\\n                ans[justBiggerIndex]=nums[index];\\n                lis.push_back(justBiggerIndex+1);\\n                //in this case justBiggerIndex+1 will be the length of LIS just less than the current element.\\n            }\\n        }\\n        return ans.size();\\n    }\\n    int minimumMountainRemovals(vector<int>& nums) \\n    {\\n        \\n        vector<int> lis;\\n        //this array stores the length of the LIS till each element of nums array (considering it as pivot = last element).(xth(x is the index) element tak LIS ka length kitna he.)\\n        vector<int> lds; //lds=longest decreasing subsequence.\\n\\n        LISbinarySearch(nums,lis);\\n        //this array stores the length of the LIS till each element of reversed nums array.works just like the lis array but for reversed nums array.\\n\\n        reverse(nums.begin(),nums.end());\\n\\n        LISbinarySearch(nums,lds);\\n\\n        //when we reverse the lds array we get the longest decreasing subsequence of the nums array.//considering each element as the pivot.(starting point)\\n        reverse(lds.begin(),lds.end());\\n\\n      \\n         int maximumLengthOfMountainArray=INT_MIN;\\n\\n        for(int k=0;k<nums.size();++k)\\n        {\\n            if(lis[k]==1 || lds[k]==1)\\n                continue;\\n            maximumLengthOfMountainArray=max(maximumLengthOfMountainArray,lis[k]+lds[k]-1); //as one element will be repeated twice in , once in lis array & once in lds array thus we subtract 1.\\n        }\\n\\n        int MinimumNumberofRemovals=nums.size()-maximumLengthOfMountainArray; //rest of the element need to be removed.\\n        return MinimumNumberofRemovals;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944808,
                "title": "prefix-and-suffix-lis-10ms-beats-96-04-runtimes",
                "content": "# Complexity\\n- Time complexity:\\nO(n + 2 * n * log(n)) ~ O(n * (1 + 2 * log(n))) ~ O(n * log(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n  private int findGreatestSmallerThan(int[] domain, int left, int right, int value) {\\n    int mid = left + (right - left) / 2;\\n\\n    if (left == right) {\\n      return mid;\\n    }\\n\\n    if (right == left + 1 && domain[mid] >= value) {\\n      return mid;\\n    }\\n\\n    if (domain[mid] >= value) {\\n      right = mid - 1;\\n    } else {\\n      left = mid + 1;\\n    }\\n\\n    return this.findGreatestSmallerThan(domain, left, right, value);\\n  }\\n\\n  private int update(int[] tails, int[] lisLengths, int rightMostIndex, int searchPosition, int index, int value) {\\n    if (value == tails[searchPosition]) {\\n      lisLengths[index] = searchPosition;\\n    } else if (searchPosition < rightMostIndex && value == tails[searchPosition + 1]) {\\n      lisLengths[index] = searchPosition + 1;\\n    } else if (searchPosition > 0 && value == tails[searchPosition - 1]) {\\n      lisLengths[index] = searchPosition - 1;\\n    } else if (value > tails[searchPosition]\\n        && (searchPosition == rightMostIndex || value < tails[searchPosition + 1])) {\\n      lisLengths[index] = searchPosition + 1;\\n      tails[searchPosition + 1] = value;\\n      rightMostIndex += searchPosition == rightMostIndex ? 1 : 0;\\n    } else if (value < tails[searchPosition] && (searchPosition == 0 || value > tails[searchPosition - 1])) {\\n      lisLengths[index] = searchPosition;\\n      tails[searchPosition] = value;\\n    }\\n\\n    return rightMostIndex;\\n  }\\n\\n  public int minimumMountainRemovals(int[] nums) {\\n    if (nums.length == 3 && nums[0] < nums[1] && nums[1] < nums[2]) {\\n      return 0;\\n    }\\n\\n    int[] trailingLIS = new int[nums.length];\\n    int[] leadingLIS = new int[nums.length];\\n\\n    int[] tails = new int[nums.length];\\n\\n    int rightMostIndex = 0;\\n    for (int i = 0; i < nums.length; i++) {\\n      if (i == 0) {\\n        tails[0] = nums[i];\\n        trailingLIS[i] = 0;\\n        continue;\\n      }\\n\\n      int pos = this.findGreatestSmallerThan(tails, 0, rightMostIndex, nums[i]);\\n      rightMostIndex = this.update(tails, trailingLIS, rightMostIndex, pos, i, nums[i]);\\n    }\\n\\n    Arrays.fill(tails, 0);\\n\\n    int minimumRemovalCount = Integer.MAX_VALUE;\\n    rightMostIndex = 0;\\n    for (int j = nums.length - 1; j >= 0; j--) {\\n      if (j == nums.length - 1) {\\n        tails[nums.length - 1 - j] = nums[nums.length - 1];\\n        leadingLIS[j] = nums.length - 1 - j;\\n        continue;\\n      }\\n\\n      int pos = this.findGreatestSmallerThan(tails, 0, rightMostIndex, nums[j]);\\n      rightMostIndex = this.update(tails, leadingLIS, rightMostIndex, pos, j, nums[j]);\\n\\nif (j > 0 && j < nums.length - 1 && trailingLIS[j] > 0 && leadingLIS[j] > 0) {\\n        minimumRemovalCount = Math.min(minimumRemovalCount,\\n            (j - trailingLIS[j]) + (nums.length - (j + 1 + leadingLIS[j])));\\n      }\\n    }\\n\\n    return minimumRemovalCount;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n  private int findGreatestSmallerThan(int[] domain, int left, int right, int value) {\\n    int mid = left + (right - left) / 2;\\n\\n    if (left == right) {\\n      return mid;\\n    }\\n\\n    if (right == left + 1 && domain[mid] >= value) {\\n      return mid;\\n    }\\n\\n    if (domain[mid] >= value) {\\n      right = mid - 1;\\n    } else {\\n      left = mid + 1;\\n    }\\n\\n    return this.findGreatestSmallerThan(domain, left, right, value);\\n  }\\n\\n  private int update(int[] tails, int[] lisLengths, int rightMostIndex, int searchPosition, int index, int value) {\\n    if (value == tails[searchPosition]) {\\n      lisLengths[index] = searchPosition;\\n    } else if (searchPosition < rightMostIndex && value == tails[searchPosition + 1]) {\\n      lisLengths[index] = searchPosition + 1;\\n    } else if (searchPosition > 0 && value == tails[searchPosition - 1]) {\\n      lisLengths[index] = searchPosition - 1;\\n    } else if (value > tails[searchPosition]\\n        && (searchPosition == rightMostIndex || value < tails[searchPosition + 1])) {\\n      lisLengths[index] = searchPosition + 1;\\n      tails[searchPosition + 1] = value;\\n      rightMostIndex += searchPosition == rightMostIndex ? 1 : 0;\\n    } else if (value < tails[searchPosition] && (searchPosition == 0 || value > tails[searchPosition - 1])) {\\n      lisLengths[index] = searchPosition;\\n      tails[searchPosition] = value;\\n    }\\n\\n    return rightMostIndex;\\n  }\\n\\n  public int minimumMountainRemovals(int[] nums) {\\n    if (nums.length == 3 && nums[0] < nums[1] && nums[1] < nums[2]) {\\n      return 0;\\n    }\\n\\n    int[] trailingLIS = new int[nums.length];\\n    int[] leadingLIS = new int[nums.length];\\n\\n    int[] tails = new int[nums.length];\\n\\n    int rightMostIndex = 0;\\n    for (int i = 0; i < nums.length; i++) {\\n      if (i == 0) {\\n        tails[0] = nums[i];\\n        trailingLIS[i] = 0;\\n        continue;\\n      }\\n\\n      int pos = this.findGreatestSmallerThan(tails, 0, rightMostIndex, nums[i]);\\n      rightMostIndex = this.update(tails, trailingLIS, rightMostIndex, pos, i, nums[i]);\\n    }\\n\\n    Arrays.fill(tails, 0);\\n\\n    int minimumRemovalCount = Integer.MAX_VALUE;\\n    rightMostIndex = 0;\\n    for (int j = nums.length - 1; j >= 0; j--) {\\n      if (j == nums.length - 1) {\\n        tails[nums.length - 1 - j] = nums[nums.length - 1];\\n        leadingLIS[j] = nums.length - 1 - j;\\n        continue;\\n      }\\n\\n      int pos = this.findGreatestSmallerThan(tails, 0, rightMostIndex, nums[j]);\\n      rightMostIndex = this.update(tails, leadingLIS, rightMostIndex, pos, j, nums[j]);\\n\\nif (j > 0 && j < nums.length - 1 && trailingLIS[j] > 0 && leadingLIS[j] > 0) {\\n        minimumRemovalCount = Math.min(minimumRemovalCount,\\n            (j - trailingLIS[j]) + (nums.length - (j + 1 + leadingLIS[j])));\\n      }\\n    }\\n\\n    return minimumRemovalCount;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939596,
                "title": "lis-way-of-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nas we know bitonic subsequence (increadsing ,decreasing ot both) \\nfind lis from right side and left side\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n`````\\n```\\n```\\ncode\\n```\\n```\\n`````\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    vector<int> findLis(vector<int>ans){\\n        \\n        int n=ans.size();\\n        \\n        vector<int>dp(n,1);\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            for(int prev=0;prev<i;prev++){\\n                \\n                if(ans[i]>ans[prev] && 1+dp[prev]>dp[i]){\\n                    dp[i]=1+dp[prev];\\n                }\\n            }\\n        }\\n        \\n        return dp;\\n    }\\n    \\n    vector<int> findReverseLis(vector<int>ans){\\n        int n=ans.size();\\n        \\n        vector<int>dp(n,1);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            \\n            for(int prev=n-1;prev>i;prev--){\\n                \\n                if(ans[i]>ans[prev] && 1+dp[prev]>dp[i]){\\n                    dp[i]=1+dp[prev];\\n                }\\n            }\\n        }\\n        \\n        return dp;\\n    }\\n\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n\\t    \\n\\t    vector<int>a=findLis(nums);\\n\\t    \\n\\t    vector<int>b=findReverseLis(nums);\\n\\t    \\n\\t    \\n\\t    int maxi=1;\\n\\t    \\n\\t    for(int i=0;i<n;i++){\\n            // it can\\'t be taken as we don\\'t want the mountain\\n        // to have a steep\\n            if (a[i] == 1 or b[i] == 1)\\n                continue;\\n\\t        \\n\\t        \\n\\t    \\n            maxi=max(maxi,a[i]+b[i]-1);\\n\\n        }\\n        // maxi means max size of mountain array so leftover will be the part to delete\\n\\n        return n-maxi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "`````\\n```\n```\\ncode\\n```\n```\\n```\n```\\nclass Solution {\\n    vector<int> findLis(vector<int>ans){\\n        \\n        int n=ans.size();\\n        \\n        vector<int>dp(n,1);\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            for(int prev=0;prev<i;prev++){\\n                \\n                if(ans[i]>ans[prev] && 1+dp[prev]>dp[i]){\\n                    dp[i]=1+dp[prev];\\n                }\\n            }\\n        }\\n        \\n        return dp;\\n    }\\n    \\n    vector<int> findReverseLis(vector<int>ans){\\n        int n=ans.size();\\n        \\n        vector<int>dp(n,1);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            \\n            for(int prev=n-1;prev>i;prev--){\\n                \\n                if(ans[i]>ans[prev] && 1+dp[prev]>dp[i]){\\n                    dp[i]=1+dp[prev];\\n                }\\n            }\\n        }\\n        \\n        return dp;\\n    }\\n\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n\\t    \\n\\t    vector<int>a=findLis(nums);\\n\\t    \\n\\t    vector<int>b=findReverseLis(nums);\\n\\t    \\n\\t    \\n\\t    int maxi=1;\\n\\t    \\n\\t    for(int i=0;i<n;i++){\\n            // it can\\'t be taken as we don\\'t want the mountain\\n        // to have a steep\\n            if (a[i] == 1 or b[i] == 1)\\n                continue;\\n\\t        \\n\\t        \\n\\t    \\n            maxi=max(maxi,a[i]+b[i]-1);\\n\\n        }\\n        // maxi means max size of mountain array so leftover will be the part to delete\\n\\n        return n-maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927073,
                "title": "c-100-binary-search-longest-increasing-subsequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLongest increasing subsequence\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmax mount = Longest increasing subsequence + longest decreaing subsequce\\n\\nminimum number of removals to make mountain array = size of array - max mount\\n\\n# Complexity\\n- Time complexity:n.log(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int optimalSol(vector<int> & nums, vector<int> &lis){\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n        vector<int> ans;\\n        lis.push_back(1);\\n        ans.push_back(nums[0]);\\n        for(int i = 1;i<nums.size();i++){\\n            if(nums[i]>ans.back()){\\n                ans.push_back(nums[i]);\\n                lis.push_back(ans.size());\\n            }else{\\n                int index = lower_bound(ans.begin(),ans.end(),nums[i])-ans.begin();\\n                ans[index] = nums[i];\\n                lis.push_back(index+1);\\n            }\\n        }\\n        return ans.size();\\n    }\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        vector<int> lis, lds;\\n        optimalSol(nums,lis);\\n        reverse(nums.begin(),nums.end());\\n        optimalSol(nums,lds);\\n\\n\\n        int longestMountain = INT_MIN;\\n        for(int i = 0;i<nums.size();i++){\\n            if(lis[i] ==1  || lds[nums.size()-i-1]==1) continue;\\n            longestMountain = max(longestMountain,lis[i]+lds[nums.size()-i-1]-1);\\n        }\\n        int minNum = nums.size()-longestMountain;\\n        return minNum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int optimalSol(vector<int> & nums, vector<int> &lis){\\n        if(nums.size()==0){\\n            return 0;\\n        }\\n        vector<int> ans;\\n        lis.push_back(1);\\n        ans.push_back(nums[0]);\\n        for(int i = 1;i<nums.size();i++){\\n            if(nums[i]>ans.back()){\\n                ans.push_back(nums[i]);\\n                lis.push_back(ans.size());\\n            }else{\\n                int index = lower_bound(ans.begin(),ans.end(),nums[i])-ans.begin();\\n                ans[index] = nums[i];\\n                lis.push_back(index+1);\\n            }\\n        }\\n        return ans.size();\\n    }\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        vector<int> lis, lds;\\n        optimalSol(nums,lis);\\n        reverse(nums.begin(),nums.end());\\n        optimalSol(nums,lds);\\n\\n\\n        int longestMountain = INT_MIN;\\n        for(int i = 0;i<nums.size();i++){\\n            if(lis[i] ==1  || lds[nums.size()-i-1]==1) continue;\\n            longestMountain = max(longestMountain,lis[i]+lds[nums.size()-i-1]-1);\\n        }\\n        int minNum = nums.size()-longestMountain;\\n        return minNum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919917,
                "title": "lis-based-easy-to-understand-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution is based on LIS problem. We try to find LIS from 0 to index for left side and n-1 to index for right side.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] a) {\\n        int n = a.length;\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=1; i<n-1; i++) {\\n            int left = delByLeft(i-1, a[i], a);\\n            int right = delByRight(i+1, a[i], a);\\n            if(left==i || right==n-i-1) continue;\\n            ans = Math.min(ans, left + right);\\n        }\\n        return ans;\\n    }\\n\\n    public int binarySearch(int ele, List<Integer> a) {\\n        int l = 0, r = a.size()-1;\\n        int idx = -1;\\n        while (l<=r) {\\n            int mid = l + (r-l)/2;\\n            if(a.get(mid)>=ele) {\\n                idx = mid;\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return idx;\\n    }\\n    public int delByLeft(int j, int ele, int[] a) {\\n        List<Integer> ans = new ArrayList<>();\\n        for(int i=0; i<=j; i++) {\\n            if(a[i]>=ele) continue;\\n\\n            if(ans.size()==0) {\\n                ans.add(a[i]);\\n            } else if(ans.get(ans.size()-1)<a[i]) {\\n                ans.add(a[i]);\\n            } else {\\n                int idx = binarySearch(a[i], ans);\\n                if(idx!=-1) {\\n                    ans.set(idx, a[i]);\\n                }\\n            }\\n        }\\n        return j - ans.size() + 1;\\n    }\\n\\n    public int delByRight(int j, int ele, int[] a) {\\n        int n = a.length;\\n        List<Integer> ans = new ArrayList<>();\\n        for(int i=n-1; i>=j; i--) {\\n            if(a[i]>=ele) continue;\\n\\n            if(ans.size()==0) {\\n                ans.add(a[i]);\\n            } else if(ans.get(ans.size()-1)<a[i]) {\\n                ans.add(a[i]);\\n            } else {\\n                int idx = binarySearch(a[i], ans);\\n                if(idx!=-1) {\\n                    ans.set(idx, a[i]);\\n                }\\n            }\\n        }\\n        return n - j - ans.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] a) {\\n        int n = a.length;\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=1; i<n-1; i++) {\\n            int left = delByLeft(i-1, a[i], a);\\n            int right = delByRight(i+1, a[i], a);\\n            if(left==i || right==n-i-1) continue;\\n            ans = Math.min(ans, left + right);\\n        }\\n        return ans;\\n    }\\n\\n    public int binarySearch(int ele, List<Integer> a) {\\n        int l = 0, r = a.size()-1;\\n        int idx = -1;\\n        while (l<=r) {\\n            int mid = l + (r-l)/2;\\n            if(a.get(mid)>=ele) {\\n                idx = mid;\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return idx;\\n    }\\n    public int delByLeft(int j, int ele, int[] a) {\\n        List<Integer> ans = new ArrayList<>();\\n        for(int i=0; i<=j; i++) {\\n            if(a[i]>=ele) continue;\\n\\n            if(ans.size()==0) {\\n                ans.add(a[i]);\\n            } else if(ans.get(ans.size()-1)<a[i]) {\\n                ans.add(a[i]);\\n            } else {\\n                int idx = binarySearch(a[i], ans);\\n                if(idx!=-1) {\\n                    ans.set(idx, a[i]);\\n                }\\n            }\\n        }\\n        return j - ans.size() + 1;\\n    }\\n\\n    public int delByRight(int j, int ele, int[] a) {\\n        int n = a.length;\\n        List<Integer> ans = new ArrayList<>();\\n        for(int i=n-1; i>=j; i--) {\\n            if(a[i]>=ele) continue;\\n\\n            if(ans.size()==0) {\\n                ans.add(a[i]);\\n            } else if(ans.get(ans.size()-1)<a[i]) {\\n                ans.add(a[i]);\\n            } else {\\n                int idx = binarySearch(a[i], ans);\\n                if(idx!=-1) {\\n                    ans.set(idx, a[i]);\\n                }\\n            }\\n        }\\n        return n - j - ans.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915439,
                "title": "striver-s-approach-java-longest-bitonic-subsequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse Longest Bitonic Increasing Subsequence.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind LBIS of the array and it\\'s reverse. Then add them and subtract 1(removing common element). Find the maximum of the array and subtract it from the length of the array. \\n\\n# Complexity\\n- Time complexity: O(n**2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int[] LIS(int[] nums)\\n    {\\n      int dp[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            dp[i]=1;\\n        }\\n        \\n        int maxi=-1;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    dp[i]=Math.max(dp[i],1+dp[j]);\\n                }\\n            }\\n            maxi=Math.max(maxi,dp[i]);\\n        }\\n        \\n        return dp;\\n    }    \\n\\n    public int minimumMountainRemovals(int[] nums) {\\n        \\n        int reverse_arr[]=new int[nums.length];\\n        int j=0;\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            reverse_arr[j++]=nums[i];\\n        }\\n        \\n        int dp1[]=LIS(nums);\\n        int dp2_reverse[]=LIS(reverse_arr);\\n        int dp2[]=new int[nums.length];\\n\\n        //Reverse dp2_reverse to align the elements to be added\\n        j=0;\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            dp2[j++]=dp2_reverse[i];\\n        }      \\n\\n        int maxi=1;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n        // The only different line of code is the below if\\n\\n        // This is the only extra part wherein if just single elements are there we skip it\\n             if(dp1[i]==1||dp2[i]==1) continue;\\n\\n            maxi=Math.max(maxi,dp1[i]+dp2[i]-1);\\n        }\\n        return nums.length-maxi;\\n        \\n  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n  public int[] LIS(int[] nums)\\n    {\\n      int dp[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            dp[i]=1;\\n        }\\n        \\n        int maxi=-1;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    dp[i]=Math.max(dp[i],1+dp[j]);\\n                }\\n            }\\n            maxi=Math.max(maxi,dp[i]);\\n        }\\n        \\n        return dp;\\n    }    \\n\\n    public int minimumMountainRemovals(int[] nums) {\\n        \\n        int reverse_arr[]=new int[nums.length];\\n        int j=0;\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            reverse_arr[j++]=nums[i];\\n        }\\n        \\n        int dp1[]=LIS(nums);\\n        int dp2_reverse[]=LIS(reverse_arr);\\n        int dp2[]=new int[nums.length];\\n\\n        //Reverse dp2_reverse to align the elements to be added\\n        j=0;\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            dp2[j++]=dp2_reverse[i];\\n        }      \\n\\n        int maxi=1;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n        // The only different line of code is the below if\\n\\n        // This is the only extra part wherein if just single elements are there we skip it\\n             if(dp1[i]==1||dp2[i]==1) continue;\\n\\n            maxi=Math.max(maxi,dp1[i]+dp2[i]-1);\\n        }\\n        return nums.length-maxi;\\n        \\n  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909548,
                "title": "c-clean-code-lis",
                "content": "Time Complexity    - $$O(n^2)$$\\nSpace Complexity   - $$O(n)$$\\n```\\nclass Solution {\\nprivate: \\n    #define all(x)      x.begin(), x.end()\\n    int n;\\n    // LIS will return dp[]\\n    // dp[i] -> LIS till ith ele\\n    vector<int> LIS(vector<int> &nums) {\\n        vector<int> dp(n, 1);\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < i; j++) {\\n                if(nums[i] > nums[j]) {\\n                    dp[i] = max(dp[i], dp[j] + 1);\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\npublic:\\n    int minimumMountainRemovals(vector<int> &nums) {\\n        n = nums.size();\\n        vector<int> dp1 = LIS(nums);\\n        reverse(all(nums));\\n        vector<int> dp2 = LIS(nums);\\n        reverse(all(dp2));\\n        int ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            // Both side should be > than 1 otherwise it is not mountain\\n            // It is a one sided slope\\n            if(dp1[i] > 1 && dp2[i] > 1) {\\n                // - 1 -> as current ele is included 2 times\\n                ans = max(ans, dp1[i] + dp2[i] - 1);\\n            }\\n        }\\n        return n - ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate: \\n    #define all(x)      x.begin(), x.end()\\n    int n;\\n    // LIS will return dp[]\\n    // dp[i] -> LIS till ith ele\\n    vector<int> LIS(vector<int> &nums) {\\n        vector<int> dp(n, 1);\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < i; j++) {\\n                if(nums[i] > nums[j]) {\\n                    dp[i] = max(dp[i], dp[j] + 1);\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\npublic:\\n    int minimumMountainRemovals(vector<int> &nums) {\\n        n = nums.size();\\n        vector<int> dp1 = LIS(nums);\\n        reverse(all(nums));\\n        vector<int> dp2 = LIS(nums);\\n        reverse(all(dp2));\\n        int ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            // Both side should be > than 1 otherwise it is not mountain\\n            // It is a one sided slope\\n            if(dp1[i] > 1 && dp2[i] > 1) {\\n                // - 1 -> as current ele is included 2 times\\n                ans = max(ans, dp1[i] + dp2[i] - 1);\\n            }\\n        }\\n        return n - ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908243,
                "title": "c-python-lis-solution-with-explanation",
                "content": "enumerate each number excluding first and last numbers to be top of mountain.\\nwe can calculate longest increasing sequence from left to right and right to left.\\nand get the size of moutain array in each position,\\nif length of lis is 1, it can not be one of side of  moutain array, skip it.\\n\\ntc is O(nlogn), sc is O(n).\\n\\n### python\\n```python\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        size = len(nums)\\n        lis1 = [0] * size\\n        lis2 = [0] * size\\n        \\n        piles = []\\n        for i, x in enumerate(nums):\\n            if not piles or x > piles[-1]:\\n                piles.append(x)\\n                lis1[i] = len(piles)\\n                continue\\n            left = bisect.bisect_left(piles, x)\\n            lis1[i] = left + 1\\n            piles[left] = x\\n        \\n        piles.clear()\\n        for i in range(size-1,-1,-1):\\n            x = nums[i]\\n            if not piles or x > piles[-1]:\\n                piles.append(x)\\n                lis2[i] = len(piles)\\n                continue\\n            left = bisect.bisect_left(piles, x)\\n            lis2[i] = left + 1\\n            piles[left] = x\\n        \\n        ans = size + 1\\n        for i in range(1, size-1):\\n            if lis1[i] == 1 or lis2[i] == 1: continue\\n            removed = size - (lis1[i] + lis2[i] - 1)\\n            ans = ans if ans < removed else removed\\n        return ans\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int size = nums.size();\\n        vector<int> lis1 (size), lis2 (size);\\n        vector<int> piles;\\n        for (int i = 0, left; i < size; i+=1) {\\n            int& x = nums[i];\\n            if (piles.empty() || x > piles.back()) {\\n                piles.emplace_back(x);\\n                lis1[i] = piles.size();\\n                continue;\\n            }\\n            left = lower_bound(piles.begin(), piles.end(), x) - piles.begin();\\n            lis1[i] = left + 1;\\n            piles[left] = x;\\n        }\\n        \\n        piles.clear();\\n        for (int i = size-1, left; i >= 0; i-=1) {\\n            int& x = nums[i];\\n            if (piles.empty() || x > piles.back()) {\\n                piles.emplace_back(x);\\n                lis2[i] = piles.size();\\n                continue;\\n            }\\n            left = lower_bound(piles.begin(), piles.end(), x) - piles.begin();\\n            lis2[i] = left + 1;\\n            piles[left] = x;\\n        }\\n        \\n        int ans = size + 1;\\n        for (int i = 1, removed; i < size - 1; i+=1) {\\n            if (lis1[i] == 1 or lis2[i] == 1) continue;\\n            removed = size - (lis1[i] + lis2[i] - 1);\\n            ans = ans < removed ? ans: removed;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        size = len(nums)\\n        lis1 = [0] * size\\n        lis2 = [0] * size\\n        \\n        piles = []\\n        for i, x in enumerate(nums):\\n            if not piles or x > piles[-1]:\\n                piles.append(x)\\n                lis1[i] = len(piles)\\n                continue\\n            left = bisect.bisect_left(piles, x)\\n            lis1[i] = left + 1\\n            piles[left] = x\\n        \\n        piles.clear()\\n        for i in range(size-1,-1,-1):\\n            x = nums[i]\\n            if not piles or x > piles[-1]:\\n                piles.append(x)\\n                lis2[i] = len(piles)\\n                continue\\n            left = bisect.bisect_left(piles, x)\\n            lis2[i] = left + 1\\n            piles[left] = x\\n        \\n        ans = size + 1\\n        for i in range(1, size-1):\\n            if lis1[i] == 1 or lis2[i] == 1: continue\\n            removed = size - (lis1[i] + lis2[i] - 1)\\n            ans = ans if ans < removed else removed\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int size = nums.size();\\n        vector<int> lis1 (size), lis2 (size);\\n        vector<int> piles;\\n        for (int i = 0, left; i < size; i+=1) {\\n            int& x = nums[i];\\n            if (piles.empty() || x > piles.back()) {\\n                piles.emplace_back(x);\\n                lis1[i] = piles.size();\\n                continue;\\n            }\\n            left = lower_bound(piles.begin(), piles.end(), x) - piles.begin();\\n            lis1[i] = left + 1;\\n            piles[left] = x;\\n        }\\n        \\n        piles.clear();\\n        for (int i = size-1, left; i >= 0; i-=1) {\\n            int& x = nums[i];\\n            if (piles.empty() || x > piles.back()) {\\n                piles.emplace_back(x);\\n                lis2[i] = piles.size();\\n                continue;\\n            }\\n            left = lower_bound(piles.begin(), piles.end(), x) - piles.begin();\\n            lis2[i] = left + 1;\\n            piles[left] = x;\\n        }\\n        \\n        int ans = size + 1;\\n        for (int i = 1, removed; i < size - 1; i+=1) {\\n            if (lis1[i] == 1 or lis2[i] == 1) continue;\\n            removed = size - (lis1[i] + lis2[i] - 1);\\n            ans = ans < removed ? ans: removed;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905525,
                "title": "best-soln-beats-75-12-longest-bitonic-subsequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        int LBS = 0 ; // LBS : Longest Bitonic Subssequence\\n        vector<int>dp1(n,1),dp2(n,1);\\n        for ( int i = 0 ; i<n ; i++)\\n        {\\n            for ( int p = 0 ; p < i ; p++ ) \\n            {\\n                if  ( nums[i] > nums[p] && 1 + dp1[p] > dp1[i] )\\n                dp1[i] = 1 + dp1[p] ;\\n            }\\n        }\\n        for ( int i = n-1 ; i>=0 ;i--)\\n        {\\n            for ( int p = n-1 ; p > i ; p-- )\\n            {\\n                if  ( nums[i] > nums[p] && 1 + dp2[p] > dp2[i] )\\n                dp2[i] = 1 + dp2[p] ;\\n            }\\n            if ( dp1[i]>1 && dp2[i]>1)\\n            LBS = max ( LBS , dp1[i]+dp2[i]-1);\\n        }\\n        return n - LBS ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        int LBS = 0 ; // LBS : Longest Bitonic Subssequence\\n        vector<int>dp1(n,1),dp2(n,1);\\n        for ( int i = 0 ; i<n ; i++)\\n        {\\n            for ( int p = 0 ; p < i ; p++ ) \\n            {\\n                if  ( nums[i] > nums[p] && 1 + dp1[p] > dp1[i] )\\n                dp1[i] = 1 + dp1[p] ;\\n            }\\n        }\\n        for ( int i = n-1 ; i>=0 ;i--)\\n        {\\n            for ( int p = n-1 ; p > i ; p-- )\\n            {\\n                if  ( nums[i] > nums[p] && 1 + dp2[p] > dp2[i] )\\n                dp2[i] = 1 + dp2[p] ;\\n            }\\n            if ( dp1[i]>1 && dp2[i]>1)\\n            LBS = max ( LBS , dp1[i]+dp2[i]-1);\\n        }\\n        return n - LBS ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905195,
                "title": "easy-lis-tweak-nlog-n",
                "content": "# Approach\\ngenerated LDS from LIS and checked sum at every index\\n\\n# Complexity\\n- Time complexity:\\nNlogN\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> lis(vector<int>& nums) {\\n        vector<int> ans, temp;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (temp.empty() || nums[i] > temp.back()) {\\n                temp.push_back(nums[i]);\\n            } else {\\n                auto it = lower_bound(temp.begin(), temp.end(), nums[i]);\\n                *it = nums[i];\\n            }\\n            ans.push_back(temp.size());\\n        }\\n        return ans;\\n    }\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> li, lds;\\n        li = lis(nums);\\n        reverse(nums.begin(), nums.end());\\n        lds = lis(nums);\\n        reverse(lds.begin(), lds.end());\\n\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if(li[i] > 1 && lds[i]>1)\\n            ans = max(ans, li[i] + lds[i] - 1);\\n        }\\n        return n - ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> lis(vector<int>& nums) {\\n        vector<int> ans, temp;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (temp.empty() || nums[i] > temp.back()) {\\n                temp.push_back(nums[i]);\\n            } else {\\n                auto it = lower_bound(temp.begin(), temp.end(), nums[i]);\\n                *it = nums[i];\\n            }\\n            ans.push_back(temp.size());\\n        }\\n        return ans;\\n    }\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> li, lds;\\n        li = lis(nums);\\n        reverse(nums.begin(), nums.end());\\n        lds = lis(nums);\\n        reverse(lds.begin(), lds.end());\\n\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            if(li[i] > 1 && lds[i]>1)\\n            ans = max(ans, li[i] + lds[i] - 1);\\n        }\\n        return n - ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880063,
                "title": "simlpest-approach-to-one-of-the-hard-questions",
                "content": "# Intuition\\nLongest increasing subsequence with a condition dp[i]>=2\\n\\n# Approach\\nLongest incresing subsequence from both side \\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n\\n        n=len(nums)\\n        arr=nums\\n        dp1=[1]*n\\n\\n        for i in range(n):\\n            for j in range(i):\\n                if (arr[i]>arr[j] and dp1[j]+1>dp1[i]):\\n                    dp1[i]=dp1[j]+1\\n\\n        dp2=[1]*n\\n        maxi=0\\n\\n        for i in range(n-1,-1,-1):\\n            for j in range(n-1,i,-1):\\n                if (arr[i]>arr[j] and dp2[j]+1>dp2[i]):\\n                    dp2[i]=dp2[j]+1 \\n\\n            if (dp1[i]>=2 and dp2[i]>=2):\\n                 maxi = max(maxi,dp1[i]+dp2[i]-1)\\n\\n\\n        return n-maxi\\n                                                                                                           \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n\\n        n=len(nums)\\n        arr=nums\\n        dp1=[1]*n\\n\\n        for i in range(n):\\n            for j in range(i):\\n                if (arr[i]>arr[j] and dp1[j]+1>dp1[i]):\\n                    dp1[i]=dp1[j]+1\\n\\n        dp2=[1]*n\\n        maxi=0\\n\\n        for i in range(n-1,-1,-1):\\n            for j in range(n-1,i,-1):\\n                if (arr[i]>arr[j] and dp2[j]+1>dp2[i]):\\n                    dp2[i]=dp2[j]+1 \\n\\n            if (dp1[i]>=2 and dp2[i]>=2):\\n                 maxi = max(maxi,dp1[i]+dp2[i]-1)\\n\\n\\n        return n-maxi\\n                                                                                                           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862435,
                "title": "easy-c-code-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& v) {\\n        int n=v.size();\\n        vector<int>left(n,0);\\n        vector<int>right(n,0);\\n        left[0]=1;\\n        for(int i=1;i<n;i++){\\n            int max=0;\\n            for(int j=0;j<i;j++){\\n                if(v[i]>v[j] and max<left[j]){\\n                    max=left[j];\\n                }\\n            }\\n            left[i]=max+1;\\n        }\\n        right[n-1]=1;\\n        for(int i=n-2;i>=0;i--){\\n            int max=0;\\n            for(int j=i+1;j<n;j++){\\n                if(v[i]>v[j] and max<right[j]){\\n                    max=right[j];\\n                }\\n            }\\n            right[i]=max+1;\\n        }\\n        int k=0;\\n        for(int i=1;i<n-1;i++){\\n            if(left[i]>1 and right[i]>1) k=max(k,right[i]+left[i]-1);\\n        }\\n        return n-k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& v) {\\n        int n=v.size();\\n        vector<int>left(n,0);\\n        vector<int>right(n,0);\\n        left[0]=1;\\n        for(int i=1;i<n;i++){\\n            int max=0;\\n            for(int j=0;j<i;j++){\\n                if(v[i]>v[j] and max<left[j]){\\n                    max=left[j];\\n                }\\n            }\\n            left[i]=max+1;\\n        }\\n        right[n-1]=1;\\n        for(int i=n-2;i>=0;i--){\\n            int max=0;\\n            for(int j=i+1;j<n;j++){\\n                if(v[i]>v[j] and max<right[j]){\\n                    max=right[j];\\n                }\\n            }\\n            right[i]=max+1;\\n        }\\n        int k=0;\\n        for(int i=1;i<n-1;i++){\\n            if(left[i]>1 and right[i]>1) k=max(k,right[i]+left[i]-1);\\n        }\\n        return n-k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850330,
                "title": "using-longest-increasing-subsequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& a) {\\n        int n=a.size();\\n        vector<int>ans(n,0),ans1(n,0);\\n        vector<int>store(a.begin(),a.end());\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            auto it=lower_bound(v.begin(),v.end(),a[i]);\\n            if(it==v.end()){\\n                v.push_back(a[i]);\\n            }\\n            else *it=a[i];\\n            auto it1=lower_bound(v.begin(),v.end(),a[i]);\\n            int len=it1-v.begin();\\n            ans[i]=len;\\n        }\\n        v.clear();\\n\\n        reverse(a.begin(),a.end());\\n        int id=n-1;\\n        for(int i=0;i<n;i++){\\n              auto it=lower_bound(v.begin(),v.end(),a[i]);\\n            if(it==v.end()){\\n                v.push_back(a[i]);\\n            }\\n            else *it=a[i];\\n            auto it1=lower_bound(v.begin(),v.end(),a[i]);\\n            int len=it1-v.begin();\\n            ans1[id]=len;\\n            id-=1;\\n\\n        }\\n              \\n            //   for(int i=0;i<n;i++){\\n            //       cout<<ans[i]<<\" \"<<ans1[i]<<\"  \";\\n            //   }\\n\\n            //     cout<<endl;\\n\\n\\n\\n            int mx=0;\\n        for(int i=1;i<n;i++){\\n            if(ans[i]>0&&ans1[i]>0){\\n                mx=max(mx,ans[i]+ans1[i]+1);\\n            }\\n        }\\n\\n        return n-mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& a) {\\n        int n=a.size();\\n        vector<int>ans(n,0),ans1(n,0);\\n        vector<int>store(a.begin(),a.end());\\n        vector<int>v;\\n        for(int i=0;i<n;i++){\\n            auto it=lower_bound(v.begin(),v.end(),a[i]);\\n            if(it==v.end()){\\n                v.push_back(a[i]);\\n            }\\n            else *it=a[i];\\n            auto it1=lower_bound(v.begin(),v.end(),a[i]);\\n            int len=it1-v.begin();\\n            ans[i]=len;\\n        }\\n        v.clear();\\n\\n        reverse(a.begin(),a.end());\\n        int id=n-1;\\n        for(int i=0;i<n;i++){\\n              auto it=lower_bound(v.begin(),v.end(),a[i]);\\n            if(it==v.end()){\\n                v.push_back(a[i]);\\n            }\\n            else *it=a[i];\\n            auto it1=lower_bound(v.begin(),v.end(),a[i]);\\n            int len=it1-v.begin();\\n            ans1[id]=len;\\n            id-=1;\\n\\n        }\\n              \\n            //   for(int i=0;i<n;i++){\\n            //       cout<<ans[i]<<\" \"<<ans1[i]<<\"  \";\\n            //   }\\n\\n            //     cout<<endl;\\n\\n\\n\\n            int mx=0;\\n        for(int i=1;i<n;i++){\\n            if(ans[i]>0&&ans1[i]>0){\\n                mx=max(mx,ans[i]+ans1[i]+1);\\n            }\\n        }\\n\\n        return n-mx;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3843408,
                "title": "easy-java-dp",
                "content": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        //n-  Longest Bitonic Subsequence \\n        int n= nums.length;\\n        return (n- longestBitonicSubsequence(nums, n));\\n    }\\n    public int longestBitonicSubsequence(int[] nums, int n){\\n        int max=0;\\n        int[] upHill= longestIncreasingSubsequence(nums, n);\\n        int[] downHill= longestDecreasingSubsequence(nums, n);\\n        for(int i=0;i<n; i++){\\n            if(upHill[i]>1 && downHill[i]>1) // we must have the v shape\\n            max= Math.max((upHill[i]+ downHill[i]-1), max);\\n        }\\n        return max;\\n    }\\n    public int[] longestIncreasingSubsequence(int[] nums, int n){\\n        int[] dp= new int[n];\\n        Arrays.fill(dp, 1);\\n        for(int i=1; i<n; i++){\\n            for(int j=0;j<i; j++){\\n                if(nums[j]<nums[i] && dp[i]<dp[j]+1){\\n                    dp[i]= dp[j]+1;\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\n\\n    public int[] longestDecreasingSubsequence(int[] nums, int n){\\n        int[] dp= new int[n];\\n        Arrays.fill(dp, 1);\\n        for(int i=n-2; i>=0; i--){\\n            for(int j=i+1;j<n; j++){\\n                if(nums[j]<nums[i] && dp[i]<dp[j]+1){\\n                    dp[i]= dp[j]+1;\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        //n-  Longest Bitonic Subsequence \\n        int n= nums.length;\\n        return (n- longestBitonicSubsequence(nums, n));\\n    }\\n    public int longestBitonicSubsequence(int[] nums, int n){\\n        int max=0;\\n        int[] upHill= longestIncreasingSubsequence(nums, n);\\n        int[] downHill= longestDecreasingSubsequence(nums, n);\\n        for(int i=0;i<n; i++){\\n            if(upHill[i]>1 && downHill[i]>1) // we must have the v shape\\n            max= Math.max((upHill[i]+ downHill[i]-1), max);\\n        }\\n        return max;\\n    }\\n    public int[] longestIncreasingSubsequence(int[] nums, int n){\\n        int[] dp= new int[n];\\n        Arrays.fill(dp, 1);\\n        for(int i=1; i<n; i++){\\n            for(int j=0;j<i; j++){\\n                if(nums[j]<nums[i] && dp[i]<dp[j]+1){\\n                    dp[i]= dp[j]+1;\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\n\\n    public int[] longestDecreasingSubsequence(int[] nums, int n){\\n        int[] dp= new int[n];\\n        Arrays.fill(dp, 1);\\n        for(int i=n-2; i>=0; i--){\\n            for(int j=i+1;j<n; j++){\\n                if(nums[j]<nums[i] && dp[i]<dp[j]+1){\\n                    dp[i]= dp[j]+1;\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840765,
                "title": "simple-java-solution-using-lis",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int LISpref[]=new int[nums.length];\\n        int LISsuf[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            LISpref[i]=1;\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    if(LISpref[j]+1>LISpref[i])\\n                    {\\n                       LISpref[i]= LISpref[j]+1;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            LISsuf[i]=1;\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    if(LISsuf[j]+1>LISsuf[i])\\n                    {\\n                       LISsuf[i]= LISsuf[j]+1;\\n                    }\\n                }\\n            }\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for(int i=1;i<nums.length-1;i++)\\n        {\\n            if(LISsuf[i]!=1 && LISpref[i]!=1)\\n            {\\n              int p=LISsuf[i]+LISpref[i]-1;\\n              if(nums.length-p<min)\\n              {\\n                  min=nums.length-p;\\n              }\\n            }\\n        }\\n\\n        return min;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int LISpref[]=new int[nums.length];\\n        int LISsuf[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            LISpref[i]=1;\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    if(LISpref[j]+1>LISpref[i])\\n                    {\\n                       LISpref[i]= LISpref[j]+1;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            LISsuf[i]=1;\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    if(LISsuf[j]+1>LISsuf[i])\\n                    {\\n                       LISsuf[i]= LISsuf[j]+1;\\n                    }\\n                }\\n            }\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for(int i=1;i<nums.length-1;i++)\\n        {\\n            if(LISsuf[i]!=1 && LISpref[i]!=1)\\n            {\\n              int p=LISsuf[i]+LISpref[i]-1;\\n              if(nums.length-p<min)\\n              {\\n                  min=nums.length-p;\\n              }\\n            }\\n        }\\n\\n        return min;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837294,
                "title": "similar-to-longest-bitonic-subsequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n < 3){\\n            return 0;\\n        }\\n        // lis\\n        vector<int>lis(n,1);\\n        for(int i = 1;i<n;i++){\\n            for(int j = 0;j<i;j++){\\n                if(arr[i]>arr[j] && lis[i] <lis[j] +1){\\n                    lis[i] = lis[j]+1;\\n                }\\n            }\\n        }\\n        // lds\\n        int ans =0;\\n        vector<int>lds(n,1);\\n        for(int i = n-2;i>=0;i--){\\n            for(int j = n-1;j>i;j--){\\n                if(arr[i]>arr[j] && lds[i] < lds[j]+1){\\n                    lds[i] = lds[j] +1;\\n                }\\n            }\\n            if(lds[i]>1 && lis[i]>1){\\n                ans = max(ans,lds[i]+lis[i]-1);\\n            }\\n        }\\n\\n       \\n        return n - ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n < 3){\\n            return 0;\\n        }\\n        // lis\\n        vector<int>lis(n,1);\\n        for(int i = 1;i<n;i++){\\n            for(int j = 0;j<i;j++){\\n                if(arr[i]>arr[j] && lis[i] <lis[j] +1){\\n                    lis[i] = lis[j]+1;\\n                }\\n            }\\n        }\\n        // lds\\n        int ans =0;\\n        vector<int>lds(n,1);\\n        for(int i = n-2;i>=0;i--){\\n            for(int j = n-1;j>i;j--){\\n                if(arr[i]>arr[j] && lds[i] < lds[j]+1){\\n                    lds[i] = lds[j] +1;\\n                }\\n            }\\n            if(lds[i]>1 && lis[i]>1){\\n                ans = max(ans,lds[i]+lis[i]-1);\\n            }\\n        }\\n\\n       \\n        return n - ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828840,
                "title": "approach-longest-bitonic-subseq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp1(n,1);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(dp1[i]<dp1[j]+1&&nums[i]>nums[j])\\n                {\\n                    dp1[i]=1+dp1[j];\\n                }\\n            }\\n        }\\n        vector<int>dp2(n,1);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=n-1;j>i;j--)\\n            {\\n                if(dp2[i]<dp2[j]+1&&nums[i]>nums[j])\\n                {\\n                    dp2[i]=1+dp2[j];\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if (dp1[i] > 1 && dp2[i] > 1) {\\n                ans = max(dp1[i] + dp2[i] - 1, ans);\\n            }\\n        }\\n\\n        return n-ans;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>dp1(n,1);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                if(dp1[i]<dp1[j]+1&&nums[i]>nums[j])\\n                {\\n                    dp1[i]=1+dp1[j];\\n                }\\n            }\\n        }\\n        vector<int>dp2(n,1);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=n-1;j>i;j--)\\n            {\\n                if(dp2[i]<dp2[j]+1&&nums[i]>nums[j])\\n                {\\n                    dp2[i]=1+dp2[j];\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if (dp1[i] > 1 && dp2[i] > 1) {\\n                ans = max(dp1[i] + dp2[i] - 1, ans);\\n            }\\n        }\\n\\n        return n-ans;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828053,
                "title": "c-easy-just-do-it",
                "content": "```\\nclass Solution {\\npublic:\\n    int my_lower_bound(vector<int>temp,int val)\\n    {\\n        int l = 0;\\n        int r = temp.size();\\n        while(l<r)\\n        {\\n            int mid = l+(r-l)/2;\\n            if(temp[mid]<val) l = mid+1;\\n            else r = mid;\\n        }\\n        return l;\\n    }\\n    int LIS(vector<int>&nums , vector<int> &dp1)\\n    {\\n        int n = nums.size();\\n        vector<int>temp;\\n        temp.push_back(nums[0]);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>temp.back()) temp.push_back(nums[i]);\\n            else\\n            {\\n                int pos = my_lower_bound(temp,nums[i]);\\n                temp[pos] = nums[i];\\n            }\\n            dp1[i] = temp.size(); \\n            // hum har index tak jitne increasing hai vo store kar rhe\\n        }\\n        cout<<endl<<\"LIS\"<<endl;\\n         for(auto i:temp) cout<<\"  \"<<i;\\n         cout<<endl;\\n         cout<<\"-------------------------\"<<endl;\\n        return temp.size();\\n    }\\n    int LDS(vector<int>&nums , vector<int> &dp2)\\n    {\\n        int n = nums.size();\\n        vector<int> temp;\\n        temp.push_back(nums[n-1]);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]>temp.back()) temp.push_back(nums[i]);\\n            else\\n            {\\n                int pos = my_lower_bound(temp,nums[i]);\\n                temp[pos] = nums[i];\\n            }\\n            dp2[i] = temp.size();\\n        }\\n        cout<<endl<<\"LDS\"<<endl;\\n         for(auto i:temp) cout<<\"  \"<<i;\\n         cout<<endl;\\n         cout<<\"-------------------------\"<<endl;\\n        return temp.size();\\n    }\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>dp1(n,0);\\n        int lis = LIS(nums,dp1);\\n        // this will tell how many are less to left of peak in sequence\\n        vector<int>dp2(n,0);\\n        int lds = LDS(nums,dp2);\\n        // this will tell how many are less to right of peak  in sequence\\n        int maximum = -1;\\n        for(auto i:nums) cout<<\"  \"<<i;\\n        cout<<endl;\\n        for(auto i:dp1) cout<<\"  \"<<i;\\n        cout<<endl;\\n        for(auto i:dp2) cout<<\"  \"<<i;\\n        cout<<endl;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp1[i]>1 && dp2[i]>1)\\n               maximum = max(maximum,dp1[i]+dp2[i]);\\n               // max value will be that pos that is biggest\\n               // as that is biggest \\n               //[2,1,7,1,5,2,3,1] in this case\\n               // dp1[i] = 2 (2 ele are lower to the left)\\n               // dp2[i] = 4 (4 ele are lower to right of this )\\n               //now if we do total - how many are lower to right left\\n               // then we will be left with those elemtns that are breaking\\n               // sequence and should be deleted \\n        }\\n        return n-maximum+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int my_lower_bound(vector<int>temp,int val)\\n    {\\n        int l = 0;\\n        int r = temp.size();\\n        while(l<r)\\n        {\\n            int mid = l+(r-l)/2;\\n            if(temp[mid]<val) l = mid+1;\\n            else r = mid;\\n        }\\n        return l;\\n    }\\n    int LIS(vector<int>&nums , vector<int> &dp1)\\n    {\\n        int n = nums.size();\\n        vector<int>temp;\\n        temp.push_back(nums[0]);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>temp.back()) temp.push_back(nums[i]);\\n            else\\n            {\\n                int pos = my_lower_bound(temp,nums[i]);\\n                temp[pos] = nums[i];\\n            }\\n            dp1[i] = temp.size(); \\n            // hum har index tak jitne increasing hai vo store kar rhe\\n        }\\n        cout<<endl<<\"LIS\"<<endl;\\n         for(auto i:temp) cout<<\"  \"<<i;\\n         cout<<endl;\\n         cout<<\"-------------------------\"<<endl;\\n        return temp.size();\\n    }\\n    int LDS(vector<int>&nums , vector<int> &dp2)\\n    {\\n        int n = nums.size();\\n        vector<int> temp;\\n        temp.push_back(nums[n-1]);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]>temp.back()) temp.push_back(nums[i]);\\n            else\\n            {\\n                int pos = my_lower_bound(temp,nums[i]);\\n                temp[pos] = nums[i];\\n            }\\n            dp2[i] = temp.size();\\n        }\\n        cout<<endl<<\"LDS\"<<endl;\\n         for(auto i:temp) cout<<\"  \"<<i;\\n         cout<<endl;\\n         cout<<\"-------------------------\"<<endl;\\n        return temp.size();\\n    }\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>dp1(n,0);\\n        int lis = LIS(nums,dp1);\\n        // this will tell how many are less to left of peak in sequence\\n        vector<int>dp2(n,0);\\n        int lds = LDS(nums,dp2);\\n        // this will tell how many are less to right of peak  in sequence\\n        int maximum = -1;\\n        for(auto i:nums) cout<<\"  \"<<i;\\n        cout<<endl;\\n        for(auto i:dp1) cout<<\"  \"<<i;\\n        cout<<endl;\\n        for(auto i:dp2) cout<<\"  \"<<i;\\n        cout<<endl;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dp1[i]>1 && dp2[i]>1)\\n               maximum = max(maximum,dp1[i]+dp2[i]);\\n               // max value will be that pos that is biggest\\n               // as that is biggest \\n               //[2,1,7,1,5,2,3,1] in this case\\n               // dp1[i] = 2 (2 ele are lower to the left)\\n               // dp2[i] = 4 (4 ele are lower to right of this )\\n               //now if we do total - how many are lower to right left\\n               // then we will be left with those elemtns that are breaking\\n               // sequence and should be deleted \\n        }\\n        return n-maximum+1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3825681,
                "title": "an-overkilling-o-nlogn-js-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/80ac58df-e9a0-487b-bbc0-10829efdcf26_1690487215.8326213.png)\\n\\n# Intuition\\nJust the classic LIS...\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```jsx\\n// The code below wasn\\'t writen to be readable, it is for runtime optimization.\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimumMountainRemovals = function (nums) {\\n  const n = nums.length;\\n  const nm1 = n - 1;\\n  const pre = Array(n).fill(0);\\n  const h = Array(n).fill(2e9);\\n\\n  let i, l, r, m, p;\\n  h[0] = nums[0];\\n  for (i = 1; i < n - 1; i++) {\\n    l = 0;\\n    p = 0;\\n    r = i;\\n\\n    while (l <= r) {\\n      m = (r + l) >> 1;\\n\\n      if (h[m] < nums[i]) {\\n        l = m + 1;\\n        p = l;\\n      } else r = m - 1;\\n    }\\n\\n    h[p] = nums[i];\\n    pre[i] = p;\\n  }\\n\\n  let lis = 0;\\n  h.fill(2e9);\\n  h[0] = nums[nm1];\\n  for (i = n - 2; i > 0; i--) {\\n    l = 0;\\n    p = 0;\\n    r = nm1 - i;\\n\\n    while (l <= r) {\\n      m = (r + l) >> 1;\\n\\n      if (h[m] < nums[i]) {\\n        l = m + 1;\\n        p = l;\\n      } else r = m - 1;\\n    }\\n\\n    h[p] = nums[i];\\n    if (p && pre[i]) lis = Math.max(lis, p + pre[i]);\\n  }\\n\\n  return nm1 - lis;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```jsx\\n// The code below wasn\\'t writen to be readable, it is for runtime optimization.\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimumMountainRemovals = function (nums) {\\n  const n = nums.length;\\n  const nm1 = n - 1;\\n  const pre = Array(n).fill(0);\\n  const h = Array(n).fill(2e9);\\n\\n  let i, l, r, m, p;\\n  h[0] = nums[0];\\n  for (i = 1; i < n - 1; i++) {\\n    l = 0;\\n    p = 0;\\n    r = i;\\n\\n    while (l <= r) {\\n      m = (r + l) >> 1;\\n\\n      if (h[m] < nums[i]) {\\n        l = m + 1;\\n        p = l;\\n      } else r = m - 1;\\n    }\\n\\n    h[p] = nums[i];\\n    pre[i] = p;\\n  }\\n\\n  let lis = 0;\\n  h.fill(2e9);\\n  h[0] = nums[nm1];\\n  for (i = n - 2; i > 0; i--) {\\n    l = 0;\\n    p = 0;\\n    r = nm1 - i;\\n\\n    while (l <= r) {\\n      m = (r + l) >> 1;\\n\\n      if (h[m] < nums[i]) {\\n        l = m + 1;\\n        p = l;\\n      } else r = m - 1;\\n    }\\n\\n    h[p] = nums[i];\\n    if (p && pre[i]) lis = Math.max(lis, p + pre[i]);\\n  }\\n\\n  return nm1 - lis;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3816171,
                "title": "longest-increasing-and-longest-decreasing-subsequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> LIS(n, 1);\\n        vector<int> LDS(n, 1);\\n        int maxMountain = 0;\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if  (nums[j] < nums[i]) LIS[i] = max(LIS[i], LIS[j] + 1);\\n            }\\n        }\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = n -1; j > i; j--) {\\n                if  (nums[j] < nums[i]) LDS[i] = max(LDS[i], LDS[j] + 1);\\n            }\\n        }\\n        for (int i = 1; i < n; i++) {\\n            if (LIS[i] == 1 || LDS[i] == 1) continue;\\n            maxMountain = max(maxMountain, LIS[i] + LDS[i] - 1);\\n        }\\n        return n - maxMountain;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> LIS(n, 1);\\n        vector<int> LDS(n, 1);\\n        int maxMountain = 0;\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if  (nums[j] < nums[i]) LIS[i] = max(LIS[i], LIS[j] + 1);\\n            }\\n        }\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = n -1; j > i; j--) {\\n                if  (nums[j] < nums[i]) LDS[i] = max(LDS[i], LDS[j] + 1);\\n            }\\n        }\\n        for (int i = 1; i < n; i++) {\\n            if (LIS[i] == 1 || LDS[i] == 1) continue;\\n            maxMountain = max(maxMountain, LIS[i] + LDS[i] - 1);\\n        }\\n        return n - maxMountain;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812902,
                "title": "c-lis-striver-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n= nums.size();\\n        vector<int> dp1(n,1);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(nums[j]< nums[i] and dp1[j]+1 > dp1[i]) dp1[i] = dp1[j] +1;\\n            }\\n        }\\n\\n        vector<int> dp(n,1);\\n        for(int i=n-1; i>=0; i--){\\n            for(int j=n-1; j>i ; j--){\\n                if(nums[j] < nums[i] and dp[j]+1 > dp[i]) dp[i] = dp[j]+1;\\n            }\\n        }\\n\\n        int longest=0;\\n        for(int i=0; i<n; i++){\\n            if(dp[i] >1 and dp1[i]>1){\\n                int len= dp[i] + dp1[i]-1;\\n                longest = max(longest,len);\\n            }\\n        }\\n        return n- longest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        int n= nums.size();\\n        vector<int> dp1(n,1);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<i; j++){\\n                if(nums[j]< nums[i] and dp1[j]+1 > dp1[i]) dp1[i] = dp1[j] +1;\\n            }\\n        }\\n\\n        vector<int> dp(n,1);\\n        for(int i=n-1; i>=0; i--){\\n            for(int j=n-1; j>i ; j--){\\n                if(nums[j] < nums[i] and dp[j]+1 > dp[i]) dp[i] = dp[j]+1;\\n            }\\n        }\\n\\n        int longest=0;\\n        for(int i=0; i<n; i++){\\n            if(dp[i] >1 and dp1[i]>1){\\n                int len= dp[i] + dp1[i]-1;\\n                longest = max(longest,len);\\n            }\\n        }\\n        return n- longest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812249,
                "title": "my-solution-using-longest-increasing-decreasing-sequence-using-dynamic-programming",
                "content": "### Code\\n```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        return nums.length - longestBitonicSequence(nums);\\n    }\\n\\n    public static int longestBitonicSequence(int[] nums) {\\n        int[] lis = lengthOfLIS(nums);\\n        reverse(nums);\\n        int[] lds = lengthOfLIS(nums);\\n        reverse(lds);\\n        int my_ans = 1;\\n        for (int i = 0; i < nums.length; i++){\\n            if(lis[i]>1 && lds[i]>1)\\n                my_ans = Math.max(my_ans, lis[i] + lds[i] - 1);\\n        }\\n        return my_ans;\\n    }\\n\\n    public static void reverse(int[] nums) {\\n        int lo = 0, hi = nums.length - 1;\\n        while (lo < hi) {\\n            int temp = nums[lo];\\n            nums[lo] = nums[hi];\\n            nums[hi] = temp;\\n            lo++;\\n            hi--;\\n        }\\n    }\\n\\n    public static int[] lengthOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int[] lis = new int[n];\\n        Arrays.fill(lis, 1);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++)\\n                if (nums[i] > nums[j])\\n                    lis[i] = Math.max(lis[i], lis[j] + 1);\\n        }\\n        return lis;\\n    }\\n}\\n```\\n\\n### Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n)$$",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        return nums.length - longestBitonicSequence(nums);\\n    }\\n\\n    public static int longestBitonicSequence(int[] nums) {\\n        int[] lis = lengthOfLIS(nums);\\n        reverse(nums);\\n        int[] lds = lengthOfLIS(nums);\\n        reverse(lds);\\n        int my_ans = 1;\\n        for (int i = 0; i < nums.length; i++){\\n            if(lis[i]>1 && lds[i]>1)\\n                my_ans = Math.max(my_ans, lis[i] + lds[i] - 1);\\n        }\\n        return my_ans;\\n    }\\n\\n    public static void reverse(int[] nums) {\\n        int lo = 0, hi = nums.length - 1;\\n        while (lo < hi) {\\n            int temp = nums[lo];\\n            nums[lo] = nums[hi];\\n            nums[hi] = temp;\\n            lo++;\\n            hi--;\\n        }\\n    }\\n\\n    public static int[] lengthOfLIS(int[] nums) {\\n        int n = nums.length;\\n        int[] lis = new int[n];\\n        Arrays.fill(lis, 1);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < i; j++)\\n                if (nums[i] > nums[j])\\n                    lis[i] = Math.max(lis[i], lis[j] + 1);\\n        }\\n        return lis;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810608,
                "title": "java-easy-solution-lis-approach",
                "content": "**NOTE**\\nSubsequence should be both increasing decreasing so for every index LIS and LDS > 1\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int dp[] = new int[nums.length];\\n        int dp2[] = new int[nums.length];\\n        Arrays.fill(dp, 1);\\n        Arrays.fill(dp2, 1);\\n        int ans = 0;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            for(int j = 0; j < i; j++){\\n                if(nums[j] < nums[i]){\\n                    if(dp[j] + 1 > dp[i]){\\n                        dp[i] = dp[j] + 1;\\n                    }\\n                }\\n                if(nums[nums.length - j - 1] < nums[nums.length - i - 1]){\\n                    if(dp2[nums.length - j - 1] + 1 > dp2[nums.length - i - 1]){\\n                        dp2[nums.length - i - 1] = dp2[nums.length - j - 1] + 1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(dp[i] > 1 && dp2[i] > 1){\\n                ans = Math.max(ans, dp[i] + dp2[i]);\\n            }\\n        }\\n\\n        return nums.length - (ans - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumMountainRemovals(int[] nums) {\\n        int dp[] = new int[nums.length];\\n        int dp2[] = new int[nums.length];\\n        Arrays.fill(dp, 1);\\n        Arrays.fill(dp2, 1);\\n        int ans = 0;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            for(int j = 0; j < i; j++){\\n                if(nums[j] < nums[i]){\\n                    if(dp[j] + 1 > dp[i]){\\n                        dp[i] = dp[j] + 1;\\n                    }\\n                }\\n                if(nums[nums.length - j - 1] < nums[nums.length - i - 1]){\\n                    if(dp2[nums.length - j - 1] + 1 > dp2[nums.length - i - 1]){\\n                        dp2[nums.length - i - 1] = dp2[nums.length - j - 1] + 1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(dp[i] > 1 && dp2[i] > 1){\\n                ans = Math.max(ans, dp[i] + dp2[i]);\\n            }\\n        }\\n\\n        return nums.length - (ans - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1887359,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Calculate the length of the Longest Increasing Subsequence (LIS) as well as the length of the Longest Decreasing Subsequence (LDS) for each index i and store them in two arrays.\n\nNow, if we consider each index as a potential peak of a mountain array, the answer for each index is given by `LIS[i] + LDS[i] - 1`.\n\nReturn nums.length - maximum answer obtained from all indices."
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "[@geekyshark](/geekyshark) yes did the same on it"
                    },
                    {
                        "username": "geekyshark",
                        "content": "also just check LIS[i] && LDS[i] both are not equal to one, as it will mean that the i considered as peak will make the array either strictly increasing (LDS[i]=1) or strictly increasing (LIS[i]=1)"
                    },
                    {
                        "username": "zamankansari",
                        "content": "[@Rachit_Agnihotri](/Rachit_Agnihotri) its already assured in the question that we can always make a mountain array\\n"
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "it will fail as the peak should be between the array. it will fail in case of purely increasing or decreasing sequence "
                    },
                    {
                        "username": "user7108Pz",
                        "content": "ans for this test case should be 1. 9,8,1,7,6,5,4,3,2,1]. if we remove 1, at 2nd index(0 based indexing)"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "[@bruteforce007](/bruteforce007) can you elaborate why we did that"
                    },
                    {
                        "username": "bruteforce007",
                        "content": "you should add one more condition while calculation the final answer \\nfor(int i = 0 ; i < nums.size() ; i++){\\n        if(dp1[i]==1||dp2[i]==1) continue; // This condition avoid bitonic subsequence\\n        ans = max(ans,dp1[i] + dp2[i] - 1);\\n}"
                    },
                    {
                        "username": "harshbeer18",
                        "content": "no thats true for a bitonic sequence but not true for a mountain array, mountain array will be 1 7 6 5 4 3 2 1"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The main part of this problem is to optimize the LIS algorithm which can be done in O(nlogn) and rest is easy."
                    },
                    {
                        "username": "ABugWithTheBigDreams",
                        "content": "a=Find longest increasing subsequence\\nx=Find longest decreasing subsequence\\n\\nans=number of elements in vector - (a+x-1)\\n\\na+x-1 = gives maximum length of bitonic array we want to find minimum nmumber of removals , so we can subtract maximum length from the size of the vector to get the number of removals."
                    },
                    {
                        "username": "aryan_gupta12",
                        "content": "Consider only the indices from i=1 to n-2 as specified in the question.\\nAlso consider only those left and right subsequences which have length greater than 1."
                    },
                    {
                        "username": "amit_9899",
                        "content": "Why for the input [1,1,1,2,2,3,3,3,4,5,8,4,3,2,1] answer is 5 instead of 7 ?\\nThe mountain should be [3,4,5,8,4,3,2,1]."
                    },
                    {
                        "username": "Abhay399",
                        "content": "The mountain should be [1,2,3,4,5,8,4,3,2,1],that\\'s why answer is 5."
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "While solving just remember : arr is a mountain array if and only if: arr.length >= 3....\\nand u have done it!!!!"
                    },
                    {
                        "username": "aakasheshwar",
                        "content": "class Solution {\npublic:\n     \n     int dp[1001][1002][3][2];\n    int f(int i,int j,vector<int> &a,int k,int flag){\n\n        if(i==a.size()){\n            if(flag==0){\n                return -1e5;\n            }\n            return 0;\n        }\n        if(dp[i][j+1][k][flag]!=-1) return dp[i][j+1][k][flag];\n        int pick=0;\n        if(j==-1){\n            pick=1+f(i+1,i,a,0,0);\n        }\n        \n       else{\n        if(k==0){\n            if(a[i]>a[j]) pick=1+max(f(i+1,i,a,0,flag),f(i+1,i,a,1,flag));\n        }\n        if(k==1){\n            if(a[i]<a[j]) pick=1+f(i+1,i,a,1,1);\n        }\n       }\n         int nopick=0+f(i+1,j,a,k,flag);\n        return dp[i][j+1][k][flag]=max(pick,nopick);\n\n\n    }\n    int minimumMountainRemovals(vector<int>& nums) {\n        \n        memset(dp,-1,sizeof(dp));\n        int maxi=f(0,-1,nums,0,0);\n\n         return nums.size()-maxi;\n\n    }\n};\n\n[1,2,1,3,4,4]\nfails for this test case.Can anyone please tell whats wrong in this code?\n\n\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone tell me whats wrong in my code ?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    int dp[1001][2][2];\\n\\n    int f(vector<int> &nums, int idx, bool incr, bool decr) {\\n\\n        if(idx == nums.size() - 1) {\\n            if(incr && decr) {\\n                return 0;\\n            } else {\\n                return INT_MAX/2;\\n            }\\n        }\\n\\n\\n        if(dp[idx][incr][decr] != -1) return dp[idx][incr][decr];\\n\\n        int remove_this = INT_MAX/2;\\n        \\n        if((!incr && !decr)) {\\n            remove_this = 1 + f(nums, idx + 1, incr, decr);\\n        }\\n\\n        int remove_between = INT_MAX/2;\\n\\n        for(int i = idx + 1; i < nums.size(); i++) {\\n            if(nums[i] > nums[idx] && !decr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, true, decr));\\n            } else if(nums[i] < nums[idx] && incr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, incr, true));\\n            } \\n        }\\n\\n        return dp[idx][incr][decr] = min(remove_this, remove_between);\\n\\n    }\\n\\n\\n\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < 1001; i++) {\\n            for(int j = 0; j < 2; j++) {\\n                for(int k = 0; k < 2; k++) {\\n                    dp[i][j][k] = -1;\\n                }\\n            }\\n        }  \\n\\n        return f(nums, 0, false, false);      \\n    }\\n\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Variant of  longest bitonic subsequence:\\n\\nFind the longest increasing subsequence count\\nFind the longest decreasing subsequence count\\nFind the longest bitonic subsequence count such that it should make mountain only when both increasing and decreasing numbers exists."
                    }
                ]
            },
            {
                "id": 1954835,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Calculate the length of the Longest Increasing Subsequence (LIS) as well as the length of the Longest Decreasing Subsequence (LDS) for each index i and store them in two arrays.\n\nNow, if we consider each index as a potential peak of a mountain array, the answer for each index is given by `LIS[i] + LDS[i] - 1`.\n\nReturn nums.length - maximum answer obtained from all indices."
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "[@geekyshark](/geekyshark) yes did the same on it"
                    },
                    {
                        "username": "geekyshark",
                        "content": "also just check LIS[i] && LDS[i] both are not equal to one, as it will mean that the i considered as peak will make the array either strictly increasing (LDS[i]=1) or strictly increasing (LIS[i]=1)"
                    },
                    {
                        "username": "zamankansari",
                        "content": "[@Rachit_Agnihotri](/Rachit_Agnihotri) its already assured in the question that we can always make a mountain array\\n"
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "it will fail as the peak should be between the array. it will fail in case of purely increasing or decreasing sequence "
                    },
                    {
                        "username": "user7108Pz",
                        "content": "ans for this test case should be 1. 9,8,1,7,6,5,4,3,2,1]. if we remove 1, at 2nd index(0 based indexing)"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "[@bruteforce007](/bruteforce007) can you elaborate why we did that"
                    },
                    {
                        "username": "bruteforce007",
                        "content": "you should add one more condition while calculation the final answer \\nfor(int i = 0 ; i < nums.size() ; i++){\\n        if(dp1[i]==1||dp2[i]==1) continue; // This condition avoid bitonic subsequence\\n        ans = max(ans,dp1[i] + dp2[i] - 1);\\n}"
                    },
                    {
                        "username": "harshbeer18",
                        "content": "no thats true for a bitonic sequence but not true for a mountain array, mountain array will be 1 7 6 5 4 3 2 1"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The main part of this problem is to optimize the LIS algorithm which can be done in O(nlogn) and rest is easy."
                    },
                    {
                        "username": "ABugWithTheBigDreams",
                        "content": "a=Find longest increasing subsequence\\nx=Find longest decreasing subsequence\\n\\nans=number of elements in vector - (a+x-1)\\n\\na+x-1 = gives maximum length of bitonic array we want to find minimum nmumber of removals , so we can subtract maximum length from the size of the vector to get the number of removals."
                    },
                    {
                        "username": "aryan_gupta12",
                        "content": "Consider only the indices from i=1 to n-2 as specified in the question.\\nAlso consider only those left and right subsequences which have length greater than 1."
                    },
                    {
                        "username": "amit_9899",
                        "content": "Why for the input [1,1,1,2,2,3,3,3,4,5,8,4,3,2,1] answer is 5 instead of 7 ?\\nThe mountain should be [3,4,5,8,4,3,2,1]."
                    },
                    {
                        "username": "Abhay399",
                        "content": "The mountain should be [1,2,3,4,5,8,4,3,2,1],that\\'s why answer is 5."
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "While solving just remember : arr is a mountain array if and only if: arr.length >= 3....\\nand u have done it!!!!"
                    },
                    {
                        "username": "aakasheshwar",
                        "content": "class Solution {\npublic:\n     \n     int dp[1001][1002][3][2];\n    int f(int i,int j,vector<int> &a,int k,int flag){\n\n        if(i==a.size()){\n            if(flag==0){\n                return -1e5;\n            }\n            return 0;\n        }\n        if(dp[i][j+1][k][flag]!=-1) return dp[i][j+1][k][flag];\n        int pick=0;\n        if(j==-1){\n            pick=1+f(i+1,i,a,0,0);\n        }\n        \n       else{\n        if(k==0){\n            if(a[i]>a[j]) pick=1+max(f(i+1,i,a,0,flag),f(i+1,i,a,1,flag));\n        }\n        if(k==1){\n            if(a[i]<a[j]) pick=1+f(i+1,i,a,1,1);\n        }\n       }\n         int nopick=0+f(i+1,j,a,k,flag);\n        return dp[i][j+1][k][flag]=max(pick,nopick);\n\n\n    }\n    int minimumMountainRemovals(vector<int>& nums) {\n        \n        memset(dp,-1,sizeof(dp));\n        int maxi=f(0,-1,nums,0,0);\n\n         return nums.size()-maxi;\n\n    }\n};\n\n[1,2,1,3,4,4]\nfails for this test case.Can anyone please tell whats wrong in this code?\n\n\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone tell me whats wrong in my code ?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    int dp[1001][2][2];\\n\\n    int f(vector<int> &nums, int idx, bool incr, bool decr) {\\n\\n        if(idx == nums.size() - 1) {\\n            if(incr && decr) {\\n                return 0;\\n            } else {\\n                return INT_MAX/2;\\n            }\\n        }\\n\\n\\n        if(dp[idx][incr][decr] != -1) return dp[idx][incr][decr];\\n\\n        int remove_this = INT_MAX/2;\\n        \\n        if((!incr && !decr)) {\\n            remove_this = 1 + f(nums, idx + 1, incr, decr);\\n        }\\n\\n        int remove_between = INT_MAX/2;\\n\\n        for(int i = idx + 1; i < nums.size(); i++) {\\n            if(nums[i] > nums[idx] && !decr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, true, decr));\\n            } else if(nums[i] < nums[idx] && incr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, incr, true));\\n            } \\n        }\\n\\n        return dp[idx][incr][decr] = min(remove_this, remove_between);\\n\\n    }\\n\\n\\n\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < 1001; i++) {\\n            for(int j = 0; j < 2; j++) {\\n                for(int k = 0; k < 2; k++) {\\n                    dp[i][j][k] = -1;\\n                }\\n            }\\n        }  \\n\\n        return f(nums, 0, false, false);      \\n    }\\n\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Variant of  longest bitonic subsequence:\\n\\nFind the longest increasing subsequence count\\nFind the longest decreasing subsequence count\\nFind the longest bitonic subsequence count such that it should make mountain only when both increasing and decreasing numbers exists."
                    }
                ]
            },
            {
                "id": 1671636,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Calculate the length of the Longest Increasing Subsequence (LIS) as well as the length of the Longest Decreasing Subsequence (LDS) for each index i and store them in two arrays.\n\nNow, if we consider each index as a potential peak of a mountain array, the answer for each index is given by `LIS[i] + LDS[i] - 1`.\n\nReturn nums.length - maximum answer obtained from all indices."
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "[@geekyshark](/geekyshark) yes did the same on it"
                    },
                    {
                        "username": "geekyshark",
                        "content": "also just check LIS[i] && LDS[i] both are not equal to one, as it will mean that the i considered as peak will make the array either strictly increasing (LDS[i]=1) or strictly increasing (LIS[i]=1)"
                    },
                    {
                        "username": "zamankansari",
                        "content": "[@Rachit_Agnihotri](/Rachit_Agnihotri) its already assured in the question that we can always make a mountain array\\n"
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "it will fail as the peak should be between the array. it will fail in case of purely increasing or decreasing sequence "
                    },
                    {
                        "username": "user7108Pz",
                        "content": "ans for this test case should be 1. 9,8,1,7,6,5,4,3,2,1]. if we remove 1, at 2nd index(0 based indexing)"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "[@bruteforce007](/bruteforce007) can you elaborate why we did that"
                    },
                    {
                        "username": "bruteforce007",
                        "content": "you should add one more condition while calculation the final answer \\nfor(int i = 0 ; i < nums.size() ; i++){\\n        if(dp1[i]==1||dp2[i]==1) continue; // This condition avoid bitonic subsequence\\n        ans = max(ans,dp1[i] + dp2[i] - 1);\\n}"
                    },
                    {
                        "username": "harshbeer18",
                        "content": "no thats true for a bitonic sequence but not true for a mountain array, mountain array will be 1 7 6 5 4 3 2 1"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The main part of this problem is to optimize the LIS algorithm which can be done in O(nlogn) and rest is easy."
                    },
                    {
                        "username": "ABugWithTheBigDreams",
                        "content": "a=Find longest increasing subsequence\\nx=Find longest decreasing subsequence\\n\\nans=number of elements in vector - (a+x-1)\\n\\na+x-1 = gives maximum length of bitonic array we want to find minimum nmumber of removals , so we can subtract maximum length from the size of the vector to get the number of removals."
                    },
                    {
                        "username": "aryan_gupta12",
                        "content": "Consider only the indices from i=1 to n-2 as specified in the question.\\nAlso consider only those left and right subsequences which have length greater than 1."
                    },
                    {
                        "username": "amit_9899",
                        "content": "Why for the input [1,1,1,2,2,3,3,3,4,5,8,4,3,2,1] answer is 5 instead of 7 ?\\nThe mountain should be [3,4,5,8,4,3,2,1]."
                    },
                    {
                        "username": "Abhay399",
                        "content": "The mountain should be [1,2,3,4,5,8,4,3,2,1],that\\'s why answer is 5."
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "While solving just remember : arr is a mountain array if and only if: arr.length >= 3....\\nand u have done it!!!!"
                    },
                    {
                        "username": "aakasheshwar",
                        "content": "class Solution {\npublic:\n     \n     int dp[1001][1002][3][2];\n    int f(int i,int j,vector<int> &a,int k,int flag){\n\n        if(i==a.size()){\n            if(flag==0){\n                return -1e5;\n            }\n            return 0;\n        }\n        if(dp[i][j+1][k][flag]!=-1) return dp[i][j+1][k][flag];\n        int pick=0;\n        if(j==-1){\n            pick=1+f(i+1,i,a,0,0);\n        }\n        \n       else{\n        if(k==0){\n            if(a[i]>a[j]) pick=1+max(f(i+1,i,a,0,flag),f(i+1,i,a,1,flag));\n        }\n        if(k==1){\n            if(a[i]<a[j]) pick=1+f(i+1,i,a,1,1);\n        }\n       }\n         int nopick=0+f(i+1,j,a,k,flag);\n        return dp[i][j+1][k][flag]=max(pick,nopick);\n\n\n    }\n    int minimumMountainRemovals(vector<int>& nums) {\n        \n        memset(dp,-1,sizeof(dp));\n        int maxi=f(0,-1,nums,0,0);\n\n         return nums.size()-maxi;\n\n    }\n};\n\n[1,2,1,3,4,4]\nfails for this test case.Can anyone please tell whats wrong in this code?\n\n\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone tell me whats wrong in my code ?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    int dp[1001][2][2];\\n\\n    int f(vector<int> &nums, int idx, bool incr, bool decr) {\\n\\n        if(idx == nums.size() - 1) {\\n            if(incr && decr) {\\n                return 0;\\n            } else {\\n                return INT_MAX/2;\\n            }\\n        }\\n\\n\\n        if(dp[idx][incr][decr] != -1) return dp[idx][incr][decr];\\n\\n        int remove_this = INT_MAX/2;\\n        \\n        if((!incr && !decr)) {\\n            remove_this = 1 + f(nums, idx + 1, incr, decr);\\n        }\\n\\n        int remove_between = INT_MAX/2;\\n\\n        for(int i = idx + 1; i < nums.size(); i++) {\\n            if(nums[i] > nums[idx] && !decr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, true, decr));\\n            } else if(nums[i] < nums[idx] && incr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, incr, true));\\n            } \\n        }\\n\\n        return dp[idx][incr][decr] = min(remove_this, remove_between);\\n\\n    }\\n\\n\\n\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < 1001; i++) {\\n            for(int j = 0; j < 2; j++) {\\n                for(int k = 0; k < 2; k++) {\\n                    dp[i][j][k] = -1;\\n                }\\n            }\\n        }  \\n\\n        return f(nums, 0, false, false);      \\n    }\\n\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Variant of  longest bitonic subsequence:\\n\\nFind the longest increasing subsequence count\\nFind the longest decreasing subsequence count\\nFind the longest bitonic subsequence count such that it should make mountain only when both increasing and decreasing numbers exists."
                    }
                ]
            },
            {
                "id": 1574814,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Calculate the length of the Longest Increasing Subsequence (LIS) as well as the length of the Longest Decreasing Subsequence (LDS) for each index i and store them in two arrays.\n\nNow, if we consider each index as a potential peak of a mountain array, the answer for each index is given by `LIS[i] + LDS[i] - 1`.\n\nReturn nums.length - maximum answer obtained from all indices."
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "[@geekyshark](/geekyshark) yes did the same on it"
                    },
                    {
                        "username": "geekyshark",
                        "content": "also just check LIS[i] && LDS[i] both are not equal to one, as it will mean that the i considered as peak will make the array either strictly increasing (LDS[i]=1) or strictly increasing (LIS[i]=1)"
                    },
                    {
                        "username": "zamankansari",
                        "content": "[@Rachit_Agnihotri](/Rachit_Agnihotri) its already assured in the question that we can always make a mountain array\\n"
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "it will fail as the peak should be between the array. it will fail in case of purely increasing or decreasing sequence "
                    },
                    {
                        "username": "user7108Pz",
                        "content": "ans for this test case should be 1. 9,8,1,7,6,5,4,3,2,1]. if we remove 1, at 2nd index(0 based indexing)"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "[@bruteforce007](/bruteforce007) can you elaborate why we did that"
                    },
                    {
                        "username": "bruteforce007",
                        "content": "you should add one more condition while calculation the final answer \\nfor(int i = 0 ; i < nums.size() ; i++){\\n        if(dp1[i]==1||dp2[i]==1) continue; // This condition avoid bitonic subsequence\\n        ans = max(ans,dp1[i] + dp2[i] - 1);\\n}"
                    },
                    {
                        "username": "harshbeer18",
                        "content": "no thats true for a bitonic sequence but not true for a mountain array, mountain array will be 1 7 6 5 4 3 2 1"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The main part of this problem is to optimize the LIS algorithm which can be done in O(nlogn) and rest is easy."
                    },
                    {
                        "username": "ABugWithTheBigDreams",
                        "content": "a=Find longest increasing subsequence\\nx=Find longest decreasing subsequence\\n\\nans=number of elements in vector - (a+x-1)\\n\\na+x-1 = gives maximum length of bitonic array we want to find minimum nmumber of removals , so we can subtract maximum length from the size of the vector to get the number of removals."
                    },
                    {
                        "username": "aryan_gupta12",
                        "content": "Consider only the indices from i=1 to n-2 as specified in the question.\\nAlso consider only those left and right subsequences which have length greater than 1."
                    },
                    {
                        "username": "amit_9899",
                        "content": "Why for the input [1,1,1,2,2,3,3,3,4,5,8,4,3,2,1] answer is 5 instead of 7 ?\\nThe mountain should be [3,4,5,8,4,3,2,1]."
                    },
                    {
                        "username": "Abhay399",
                        "content": "The mountain should be [1,2,3,4,5,8,4,3,2,1],that\\'s why answer is 5."
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "While solving just remember : arr is a mountain array if and only if: arr.length >= 3....\\nand u have done it!!!!"
                    },
                    {
                        "username": "aakasheshwar",
                        "content": "class Solution {\npublic:\n     \n     int dp[1001][1002][3][2];\n    int f(int i,int j,vector<int> &a,int k,int flag){\n\n        if(i==a.size()){\n            if(flag==0){\n                return -1e5;\n            }\n            return 0;\n        }\n        if(dp[i][j+1][k][flag]!=-1) return dp[i][j+1][k][flag];\n        int pick=0;\n        if(j==-1){\n            pick=1+f(i+1,i,a,0,0);\n        }\n        \n       else{\n        if(k==0){\n            if(a[i]>a[j]) pick=1+max(f(i+1,i,a,0,flag),f(i+1,i,a,1,flag));\n        }\n        if(k==1){\n            if(a[i]<a[j]) pick=1+f(i+1,i,a,1,1);\n        }\n       }\n         int nopick=0+f(i+1,j,a,k,flag);\n        return dp[i][j+1][k][flag]=max(pick,nopick);\n\n\n    }\n    int minimumMountainRemovals(vector<int>& nums) {\n        \n        memset(dp,-1,sizeof(dp));\n        int maxi=f(0,-1,nums,0,0);\n\n         return nums.size()-maxi;\n\n    }\n};\n\n[1,2,1,3,4,4]\nfails for this test case.Can anyone please tell whats wrong in this code?\n\n\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone tell me whats wrong in my code ?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    int dp[1001][2][2];\\n\\n    int f(vector<int> &nums, int idx, bool incr, bool decr) {\\n\\n        if(idx == nums.size() - 1) {\\n            if(incr && decr) {\\n                return 0;\\n            } else {\\n                return INT_MAX/2;\\n            }\\n        }\\n\\n\\n        if(dp[idx][incr][decr] != -1) return dp[idx][incr][decr];\\n\\n        int remove_this = INT_MAX/2;\\n        \\n        if((!incr && !decr)) {\\n            remove_this = 1 + f(nums, idx + 1, incr, decr);\\n        }\\n\\n        int remove_between = INT_MAX/2;\\n\\n        for(int i = idx + 1; i < nums.size(); i++) {\\n            if(nums[i] > nums[idx] && !decr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, true, decr));\\n            } else if(nums[i] < nums[idx] && incr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, incr, true));\\n            } \\n        }\\n\\n        return dp[idx][incr][decr] = min(remove_this, remove_between);\\n\\n    }\\n\\n\\n\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < 1001; i++) {\\n            for(int j = 0; j < 2; j++) {\\n                for(int k = 0; k < 2; k++) {\\n                    dp[i][j][k] = -1;\\n                }\\n            }\\n        }  \\n\\n        return f(nums, 0, false, false);      \\n    }\\n\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Variant of  longest bitonic subsequence:\\n\\nFind the longest increasing subsequence count\\nFind the longest decreasing subsequence count\\nFind the longest bitonic subsequence count such that it should make mountain only when both increasing and decreasing numbers exists."
                    }
                ]
            },
            {
                "id": 2072059,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Calculate the length of the Longest Increasing Subsequence (LIS) as well as the length of the Longest Decreasing Subsequence (LDS) for each index i and store them in two arrays.\n\nNow, if we consider each index as a potential peak of a mountain array, the answer for each index is given by `LIS[i] + LDS[i] - 1`.\n\nReturn nums.length - maximum answer obtained from all indices."
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "[@geekyshark](/geekyshark) yes did the same on it"
                    },
                    {
                        "username": "geekyshark",
                        "content": "also just check LIS[i] && LDS[i] both are not equal to one, as it will mean that the i considered as peak will make the array either strictly increasing (LDS[i]=1) or strictly increasing (LIS[i]=1)"
                    },
                    {
                        "username": "zamankansari",
                        "content": "[@Rachit_Agnihotri](/Rachit_Agnihotri) its already assured in the question that we can always make a mountain array\\n"
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "it will fail as the peak should be between the array. it will fail in case of purely increasing or decreasing sequence "
                    },
                    {
                        "username": "user7108Pz",
                        "content": "ans for this test case should be 1. 9,8,1,7,6,5,4,3,2,1]. if we remove 1, at 2nd index(0 based indexing)"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "[@bruteforce007](/bruteforce007) can you elaborate why we did that"
                    },
                    {
                        "username": "bruteforce007",
                        "content": "you should add one more condition while calculation the final answer \\nfor(int i = 0 ; i < nums.size() ; i++){\\n        if(dp1[i]==1||dp2[i]==1) continue; // This condition avoid bitonic subsequence\\n        ans = max(ans,dp1[i] + dp2[i] - 1);\\n}"
                    },
                    {
                        "username": "harshbeer18",
                        "content": "no thats true for a bitonic sequence but not true for a mountain array, mountain array will be 1 7 6 5 4 3 2 1"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The main part of this problem is to optimize the LIS algorithm which can be done in O(nlogn) and rest is easy."
                    },
                    {
                        "username": "ABugWithTheBigDreams",
                        "content": "a=Find longest increasing subsequence\\nx=Find longest decreasing subsequence\\n\\nans=number of elements in vector - (a+x-1)\\n\\na+x-1 = gives maximum length of bitonic array we want to find minimum nmumber of removals , so we can subtract maximum length from the size of the vector to get the number of removals."
                    },
                    {
                        "username": "aryan_gupta12",
                        "content": "Consider only the indices from i=1 to n-2 as specified in the question.\\nAlso consider only those left and right subsequences which have length greater than 1."
                    },
                    {
                        "username": "amit_9899",
                        "content": "Why for the input [1,1,1,2,2,3,3,3,4,5,8,4,3,2,1] answer is 5 instead of 7 ?\\nThe mountain should be [3,4,5,8,4,3,2,1]."
                    },
                    {
                        "username": "Abhay399",
                        "content": "The mountain should be [1,2,3,4,5,8,4,3,2,1],that\\'s why answer is 5."
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "While solving just remember : arr is a mountain array if and only if: arr.length >= 3....\\nand u have done it!!!!"
                    },
                    {
                        "username": "aakasheshwar",
                        "content": "class Solution {\npublic:\n     \n     int dp[1001][1002][3][2];\n    int f(int i,int j,vector<int> &a,int k,int flag){\n\n        if(i==a.size()){\n            if(flag==0){\n                return -1e5;\n            }\n            return 0;\n        }\n        if(dp[i][j+1][k][flag]!=-1) return dp[i][j+1][k][flag];\n        int pick=0;\n        if(j==-1){\n            pick=1+f(i+1,i,a,0,0);\n        }\n        \n       else{\n        if(k==0){\n            if(a[i]>a[j]) pick=1+max(f(i+1,i,a,0,flag),f(i+1,i,a,1,flag));\n        }\n        if(k==1){\n            if(a[i]<a[j]) pick=1+f(i+1,i,a,1,1);\n        }\n       }\n         int nopick=0+f(i+1,j,a,k,flag);\n        return dp[i][j+1][k][flag]=max(pick,nopick);\n\n\n    }\n    int minimumMountainRemovals(vector<int>& nums) {\n        \n        memset(dp,-1,sizeof(dp));\n        int maxi=f(0,-1,nums,0,0);\n\n         return nums.size()-maxi;\n\n    }\n};\n\n[1,2,1,3,4,4]\nfails for this test case.Can anyone please tell whats wrong in this code?\n\n\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone tell me whats wrong in my code ?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    int dp[1001][2][2];\\n\\n    int f(vector<int> &nums, int idx, bool incr, bool decr) {\\n\\n        if(idx == nums.size() - 1) {\\n            if(incr && decr) {\\n                return 0;\\n            } else {\\n                return INT_MAX/2;\\n            }\\n        }\\n\\n\\n        if(dp[idx][incr][decr] != -1) return dp[idx][incr][decr];\\n\\n        int remove_this = INT_MAX/2;\\n        \\n        if((!incr && !decr)) {\\n            remove_this = 1 + f(nums, idx + 1, incr, decr);\\n        }\\n\\n        int remove_between = INT_MAX/2;\\n\\n        for(int i = idx + 1; i < nums.size(); i++) {\\n            if(nums[i] > nums[idx] && !decr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, true, decr));\\n            } else if(nums[i] < nums[idx] && incr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, incr, true));\\n            } \\n        }\\n\\n        return dp[idx][incr][decr] = min(remove_this, remove_between);\\n\\n    }\\n\\n\\n\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < 1001; i++) {\\n            for(int j = 0; j < 2; j++) {\\n                for(int k = 0; k < 2; k++) {\\n                    dp[i][j][k] = -1;\\n                }\\n            }\\n        }  \\n\\n        return f(nums, 0, false, false);      \\n    }\\n\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Variant of  longest bitonic subsequence:\\n\\nFind the longest increasing subsequence count\\nFind the longest decreasing subsequence count\\nFind the longest bitonic subsequence count such that it should make mountain only when both increasing and decreasing numbers exists."
                    }
                ]
            },
            {
                "id": 1991211,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Calculate the length of the Longest Increasing Subsequence (LIS) as well as the length of the Longest Decreasing Subsequence (LDS) for each index i and store them in two arrays.\n\nNow, if we consider each index as a potential peak of a mountain array, the answer for each index is given by `LIS[i] + LDS[i] - 1`.\n\nReturn nums.length - maximum answer obtained from all indices."
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "[@geekyshark](/geekyshark) yes did the same on it"
                    },
                    {
                        "username": "geekyshark",
                        "content": "also just check LIS[i] && LDS[i] both are not equal to one, as it will mean that the i considered as peak will make the array either strictly increasing (LDS[i]=1) or strictly increasing (LIS[i]=1)"
                    },
                    {
                        "username": "zamankansari",
                        "content": "[@Rachit_Agnihotri](/Rachit_Agnihotri) its already assured in the question that we can always make a mountain array\\n"
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "it will fail as the peak should be between the array. it will fail in case of purely increasing or decreasing sequence "
                    },
                    {
                        "username": "user7108Pz",
                        "content": "ans for this test case should be 1. 9,8,1,7,6,5,4,3,2,1]. if we remove 1, at 2nd index(0 based indexing)"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "[@bruteforce007](/bruteforce007) can you elaborate why we did that"
                    },
                    {
                        "username": "bruteforce007",
                        "content": "you should add one more condition while calculation the final answer \\nfor(int i = 0 ; i < nums.size() ; i++){\\n        if(dp1[i]==1||dp2[i]==1) continue; // This condition avoid bitonic subsequence\\n        ans = max(ans,dp1[i] + dp2[i] - 1);\\n}"
                    },
                    {
                        "username": "harshbeer18",
                        "content": "no thats true for a bitonic sequence but not true for a mountain array, mountain array will be 1 7 6 5 4 3 2 1"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The main part of this problem is to optimize the LIS algorithm which can be done in O(nlogn) and rest is easy."
                    },
                    {
                        "username": "ABugWithTheBigDreams",
                        "content": "a=Find longest increasing subsequence\\nx=Find longest decreasing subsequence\\n\\nans=number of elements in vector - (a+x-1)\\n\\na+x-1 = gives maximum length of bitonic array we want to find minimum nmumber of removals , so we can subtract maximum length from the size of the vector to get the number of removals."
                    },
                    {
                        "username": "aryan_gupta12",
                        "content": "Consider only the indices from i=1 to n-2 as specified in the question.\\nAlso consider only those left and right subsequences which have length greater than 1."
                    },
                    {
                        "username": "amit_9899",
                        "content": "Why for the input [1,1,1,2,2,3,3,3,4,5,8,4,3,2,1] answer is 5 instead of 7 ?\\nThe mountain should be [3,4,5,8,4,3,2,1]."
                    },
                    {
                        "username": "Abhay399",
                        "content": "The mountain should be [1,2,3,4,5,8,4,3,2,1],that\\'s why answer is 5."
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "While solving just remember : arr is a mountain array if and only if: arr.length >= 3....\\nand u have done it!!!!"
                    },
                    {
                        "username": "aakasheshwar",
                        "content": "class Solution {\npublic:\n     \n     int dp[1001][1002][3][2];\n    int f(int i,int j,vector<int> &a,int k,int flag){\n\n        if(i==a.size()){\n            if(flag==0){\n                return -1e5;\n            }\n            return 0;\n        }\n        if(dp[i][j+1][k][flag]!=-1) return dp[i][j+1][k][flag];\n        int pick=0;\n        if(j==-1){\n            pick=1+f(i+1,i,a,0,0);\n        }\n        \n       else{\n        if(k==0){\n            if(a[i]>a[j]) pick=1+max(f(i+1,i,a,0,flag),f(i+1,i,a,1,flag));\n        }\n        if(k==1){\n            if(a[i]<a[j]) pick=1+f(i+1,i,a,1,1);\n        }\n       }\n         int nopick=0+f(i+1,j,a,k,flag);\n        return dp[i][j+1][k][flag]=max(pick,nopick);\n\n\n    }\n    int minimumMountainRemovals(vector<int>& nums) {\n        \n        memset(dp,-1,sizeof(dp));\n        int maxi=f(0,-1,nums,0,0);\n\n         return nums.size()-maxi;\n\n    }\n};\n\n[1,2,1,3,4,4]\nfails for this test case.Can anyone please tell whats wrong in this code?\n\n\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone tell me whats wrong in my code ?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    int dp[1001][2][2];\\n\\n    int f(vector<int> &nums, int idx, bool incr, bool decr) {\\n\\n        if(idx == nums.size() - 1) {\\n            if(incr && decr) {\\n                return 0;\\n            } else {\\n                return INT_MAX/2;\\n            }\\n        }\\n\\n\\n        if(dp[idx][incr][decr] != -1) return dp[idx][incr][decr];\\n\\n        int remove_this = INT_MAX/2;\\n        \\n        if((!incr && !decr)) {\\n            remove_this = 1 + f(nums, idx + 1, incr, decr);\\n        }\\n\\n        int remove_between = INT_MAX/2;\\n\\n        for(int i = idx + 1; i < nums.size(); i++) {\\n            if(nums[i] > nums[idx] && !decr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, true, decr));\\n            } else if(nums[i] < nums[idx] && incr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, incr, true));\\n            } \\n        }\\n\\n        return dp[idx][incr][decr] = min(remove_this, remove_between);\\n\\n    }\\n\\n\\n\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < 1001; i++) {\\n            for(int j = 0; j < 2; j++) {\\n                for(int k = 0; k < 2; k++) {\\n                    dp[i][j][k] = -1;\\n                }\\n            }\\n        }  \\n\\n        return f(nums, 0, false, false);      \\n    }\\n\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Variant of  longest bitonic subsequence:\\n\\nFind the longest increasing subsequence count\\nFind the longest decreasing subsequence count\\nFind the longest bitonic subsequence count such that it should make mountain only when both increasing and decreasing numbers exists."
                    }
                ]
            },
            {
                "id": 1984391,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Calculate the length of the Longest Increasing Subsequence (LIS) as well as the length of the Longest Decreasing Subsequence (LDS) for each index i and store them in two arrays.\n\nNow, if we consider each index as a potential peak of a mountain array, the answer for each index is given by `LIS[i] + LDS[i] - 1`.\n\nReturn nums.length - maximum answer obtained from all indices."
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "[@geekyshark](/geekyshark) yes did the same on it"
                    },
                    {
                        "username": "geekyshark",
                        "content": "also just check LIS[i] && LDS[i] both are not equal to one, as it will mean that the i considered as peak will make the array either strictly increasing (LDS[i]=1) or strictly increasing (LIS[i]=1)"
                    },
                    {
                        "username": "zamankansari",
                        "content": "[@Rachit_Agnihotri](/Rachit_Agnihotri) its already assured in the question that we can always make a mountain array\\n"
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "it will fail as the peak should be between the array. it will fail in case of purely increasing or decreasing sequence "
                    },
                    {
                        "username": "user7108Pz",
                        "content": "ans for this test case should be 1. 9,8,1,7,6,5,4,3,2,1]. if we remove 1, at 2nd index(0 based indexing)"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "[@bruteforce007](/bruteforce007) can you elaborate why we did that"
                    },
                    {
                        "username": "bruteforce007",
                        "content": "you should add one more condition while calculation the final answer \\nfor(int i = 0 ; i < nums.size() ; i++){\\n        if(dp1[i]==1||dp2[i]==1) continue; // This condition avoid bitonic subsequence\\n        ans = max(ans,dp1[i] + dp2[i] - 1);\\n}"
                    },
                    {
                        "username": "harshbeer18",
                        "content": "no thats true for a bitonic sequence but not true for a mountain array, mountain array will be 1 7 6 5 4 3 2 1"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The main part of this problem is to optimize the LIS algorithm which can be done in O(nlogn) and rest is easy."
                    },
                    {
                        "username": "ABugWithTheBigDreams",
                        "content": "a=Find longest increasing subsequence\\nx=Find longest decreasing subsequence\\n\\nans=number of elements in vector - (a+x-1)\\n\\na+x-1 = gives maximum length of bitonic array we want to find minimum nmumber of removals , so we can subtract maximum length from the size of the vector to get the number of removals."
                    },
                    {
                        "username": "aryan_gupta12",
                        "content": "Consider only the indices from i=1 to n-2 as specified in the question.\\nAlso consider only those left and right subsequences which have length greater than 1."
                    },
                    {
                        "username": "amit_9899",
                        "content": "Why for the input [1,1,1,2,2,3,3,3,4,5,8,4,3,2,1] answer is 5 instead of 7 ?\\nThe mountain should be [3,4,5,8,4,3,2,1]."
                    },
                    {
                        "username": "Abhay399",
                        "content": "The mountain should be [1,2,3,4,5,8,4,3,2,1],that\\'s why answer is 5."
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "While solving just remember : arr is a mountain array if and only if: arr.length >= 3....\\nand u have done it!!!!"
                    },
                    {
                        "username": "aakasheshwar",
                        "content": "class Solution {\npublic:\n     \n     int dp[1001][1002][3][2];\n    int f(int i,int j,vector<int> &a,int k,int flag){\n\n        if(i==a.size()){\n            if(flag==0){\n                return -1e5;\n            }\n            return 0;\n        }\n        if(dp[i][j+1][k][flag]!=-1) return dp[i][j+1][k][flag];\n        int pick=0;\n        if(j==-1){\n            pick=1+f(i+1,i,a,0,0);\n        }\n        \n       else{\n        if(k==0){\n            if(a[i]>a[j]) pick=1+max(f(i+1,i,a,0,flag),f(i+1,i,a,1,flag));\n        }\n        if(k==1){\n            if(a[i]<a[j]) pick=1+f(i+1,i,a,1,1);\n        }\n       }\n         int nopick=0+f(i+1,j,a,k,flag);\n        return dp[i][j+1][k][flag]=max(pick,nopick);\n\n\n    }\n    int minimumMountainRemovals(vector<int>& nums) {\n        \n        memset(dp,-1,sizeof(dp));\n        int maxi=f(0,-1,nums,0,0);\n\n         return nums.size()-maxi;\n\n    }\n};\n\n[1,2,1,3,4,4]\nfails for this test case.Can anyone please tell whats wrong in this code?\n\n\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone tell me whats wrong in my code ?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    int dp[1001][2][2];\\n\\n    int f(vector<int> &nums, int idx, bool incr, bool decr) {\\n\\n        if(idx == nums.size() - 1) {\\n            if(incr && decr) {\\n                return 0;\\n            } else {\\n                return INT_MAX/2;\\n            }\\n        }\\n\\n\\n        if(dp[idx][incr][decr] != -1) return dp[idx][incr][decr];\\n\\n        int remove_this = INT_MAX/2;\\n        \\n        if((!incr && !decr)) {\\n            remove_this = 1 + f(nums, idx + 1, incr, decr);\\n        }\\n\\n        int remove_between = INT_MAX/2;\\n\\n        for(int i = idx + 1; i < nums.size(); i++) {\\n            if(nums[i] > nums[idx] && !decr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, true, decr));\\n            } else if(nums[i] < nums[idx] && incr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, incr, true));\\n            } \\n        }\\n\\n        return dp[idx][incr][decr] = min(remove_this, remove_between);\\n\\n    }\\n\\n\\n\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < 1001; i++) {\\n            for(int j = 0; j < 2; j++) {\\n                for(int k = 0; k < 2; k++) {\\n                    dp[i][j][k] = -1;\\n                }\\n            }\\n        }  \\n\\n        return f(nums, 0, false, false);      \\n    }\\n\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Variant of  longest bitonic subsequence:\\n\\nFind the longest increasing subsequence count\\nFind the longest decreasing subsequence count\\nFind the longest bitonic subsequence count such that it should make mountain only when both increasing and decreasing numbers exists."
                    }
                ]
            },
            {
                "id": 1957008,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Calculate the length of the Longest Increasing Subsequence (LIS) as well as the length of the Longest Decreasing Subsequence (LDS) for each index i and store them in two arrays.\n\nNow, if we consider each index as a potential peak of a mountain array, the answer for each index is given by `LIS[i] + LDS[i] - 1`.\n\nReturn nums.length - maximum answer obtained from all indices."
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "[@geekyshark](/geekyshark) yes did the same on it"
                    },
                    {
                        "username": "geekyshark",
                        "content": "also just check LIS[i] && LDS[i] both are not equal to one, as it will mean that the i considered as peak will make the array either strictly increasing (LDS[i]=1) or strictly increasing (LIS[i]=1)"
                    },
                    {
                        "username": "zamankansari",
                        "content": "[@Rachit_Agnihotri](/Rachit_Agnihotri) its already assured in the question that we can always make a mountain array\\n"
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "it will fail as the peak should be between the array. it will fail in case of purely increasing or decreasing sequence "
                    },
                    {
                        "username": "user7108Pz",
                        "content": "ans for this test case should be 1. 9,8,1,7,6,5,4,3,2,1]. if we remove 1, at 2nd index(0 based indexing)"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "[@bruteforce007](/bruteforce007) can you elaborate why we did that"
                    },
                    {
                        "username": "bruteforce007",
                        "content": "you should add one more condition while calculation the final answer \\nfor(int i = 0 ; i < nums.size() ; i++){\\n        if(dp1[i]==1||dp2[i]==1) continue; // This condition avoid bitonic subsequence\\n        ans = max(ans,dp1[i] + dp2[i] - 1);\\n}"
                    },
                    {
                        "username": "harshbeer18",
                        "content": "no thats true for a bitonic sequence but not true for a mountain array, mountain array will be 1 7 6 5 4 3 2 1"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The main part of this problem is to optimize the LIS algorithm which can be done in O(nlogn) and rest is easy."
                    },
                    {
                        "username": "ABugWithTheBigDreams",
                        "content": "a=Find longest increasing subsequence\\nx=Find longest decreasing subsequence\\n\\nans=number of elements in vector - (a+x-1)\\n\\na+x-1 = gives maximum length of bitonic array we want to find minimum nmumber of removals , so we can subtract maximum length from the size of the vector to get the number of removals."
                    },
                    {
                        "username": "aryan_gupta12",
                        "content": "Consider only the indices from i=1 to n-2 as specified in the question.\\nAlso consider only those left and right subsequences which have length greater than 1."
                    },
                    {
                        "username": "amit_9899",
                        "content": "Why for the input [1,1,1,2,2,3,3,3,4,5,8,4,3,2,1] answer is 5 instead of 7 ?\\nThe mountain should be [3,4,5,8,4,3,2,1]."
                    },
                    {
                        "username": "Abhay399",
                        "content": "The mountain should be [1,2,3,4,5,8,4,3,2,1],that\\'s why answer is 5."
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "While solving just remember : arr is a mountain array if and only if: arr.length >= 3....\\nand u have done it!!!!"
                    },
                    {
                        "username": "aakasheshwar",
                        "content": "class Solution {\npublic:\n     \n     int dp[1001][1002][3][2];\n    int f(int i,int j,vector<int> &a,int k,int flag){\n\n        if(i==a.size()){\n            if(flag==0){\n                return -1e5;\n            }\n            return 0;\n        }\n        if(dp[i][j+1][k][flag]!=-1) return dp[i][j+1][k][flag];\n        int pick=0;\n        if(j==-1){\n            pick=1+f(i+1,i,a,0,0);\n        }\n        \n       else{\n        if(k==0){\n            if(a[i]>a[j]) pick=1+max(f(i+1,i,a,0,flag),f(i+1,i,a,1,flag));\n        }\n        if(k==1){\n            if(a[i]<a[j]) pick=1+f(i+1,i,a,1,1);\n        }\n       }\n         int nopick=0+f(i+1,j,a,k,flag);\n        return dp[i][j+1][k][flag]=max(pick,nopick);\n\n\n    }\n    int minimumMountainRemovals(vector<int>& nums) {\n        \n        memset(dp,-1,sizeof(dp));\n        int maxi=f(0,-1,nums,0,0);\n\n         return nums.size()-maxi;\n\n    }\n};\n\n[1,2,1,3,4,4]\nfails for this test case.Can anyone please tell whats wrong in this code?\n\n\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone tell me whats wrong in my code ?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    int dp[1001][2][2];\\n\\n    int f(vector<int> &nums, int idx, bool incr, bool decr) {\\n\\n        if(idx == nums.size() - 1) {\\n            if(incr && decr) {\\n                return 0;\\n            } else {\\n                return INT_MAX/2;\\n            }\\n        }\\n\\n\\n        if(dp[idx][incr][decr] != -1) return dp[idx][incr][decr];\\n\\n        int remove_this = INT_MAX/2;\\n        \\n        if((!incr && !decr)) {\\n            remove_this = 1 + f(nums, idx + 1, incr, decr);\\n        }\\n\\n        int remove_between = INT_MAX/2;\\n\\n        for(int i = idx + 1; i < nums.size(); i++) {\\n            if(nums[i] > nums[idx] && !decr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, true, decr));\\n            } else if(nums[i] < nums[idx] && incr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, incr, true));\\n            } \\n        }\\n\\n        return dp[idx][incr][decr] = min(remove_this, remove_between);\\n\\n    }\\n\\n\\n\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < 1001; i++) {\\n            for(int j = 0; j < 2; j++) {\\n                for(int k = 0; k < 2; k++) {\\n                    dp[i][j][k] = -1;\\n                }\\n            }\\n        }  \\n\\n        return f(nums, 0, false, false);      \\n    }\\n\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Variant of  longest bitonic subsequence:\\n\\nFind the longest increasing subsequence count\\nFind the longest decreasing subsequence count\\nFind the longest bitonic subsequence count such that it should make mountain only when both increasing and decreasing numbers exists."
                    }
                ]
            },
            {
                "id": 1931605,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Calculate the length of the Longest Increasing Subsequence (LIS) as well as the length of the Longest Decreasing Subsequence (LDS) for each index i and store them in two arrays.\n\nNow, if we consider each index as a potential peak of a mountain array, the answer for each index is given by `LIS[i] + LDS[i] - 1`.\n\nReturn nums.length - maximum answer obtained from all indices."
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "[@geekyshark](/geekyshark) yes did the same on it"
                    },
                    {
                        "username": "geekyshark",
                        "content": "also just check LIS[i] && LDS[i] both are not equal to one, as it will mean that the i considered as peak will make the array either strictly increasing (LDS[i]=1) or strictly increasing (LIS[i]=1)"
                    },
                    {
                        "username": "zamankansari",
                        "content": "[@Rachit_Agnihotri](/Rachit_Agnihotri) its already assured in the question that we can always make a mountain array\\n"
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "it will fail as the peak should be between the array. it will fail in case of purely increasing or decreasing sequence "
                    },
                    {
                        "username": "user7108Pz",
                        "content": "ans for this test case should be 1. 9,8,1,7,6,5,4,3,2,1]. if we remove 1, at 2nd index(0 based indexing)"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "[@bruteforce007](/bruteforce007) can you elaborate why we did that"
                    },
                    {
                        "username": "bruteforce007",
                        "content": "you should add one more condition while calculation the final answer \\nfor(int i = 0 ; i < nums.size() ; i++){\\n        if(dp1[i]==1||dp2[i]==1) continue; // This condition avoid bitonic subsequence\\n        ans = max(ans,dp1[i] + dp2[i] - 1);\\n}"
                    },
                    {
                        "username": "harshbeer18",
                        "content": "no thats true for a bitonic sequence but not true for a mountain array, mountain array will be 1 7 6 5 4 3 2 1"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The main part of this problem is to optimize the LIS algorithm which can be done in O(nlogn) and rest is easy."
                    },
                    {
                        "username": "ABugWithTheBigDreams",
                        "content": "a=Find longest increasing subsequence\\nx=Find longest decreasing subsequence\\n\\nans=number of elements in vector - (a+x-1)\\n\\na+x-1 = gives maximum length of bitonic array we want to find minimum nmumber of removals , so we can subtract maximum length from the size of the vector to get the number of removals."
                    },
                    {
                        "username": "aryan_gupta12",
                        "content": "Consider only the indices from i=1 to n-2 as specified in the question.\\nAlso consider only those left and right subsequences which have length greater than 1."
                    },
                    {
                        "username": "amit_9899",
                        "content": "Why for the input [1,1,1,2,2,3,3,3,4,5,8,4,3,2,1] answer is 5 instead of 7 ?\\nThe mountain should be [3,4,5,8,4,3,2,1]."
                    },
                    {
                        "username": "Abhay399",
                        "content": "The mountain should be [1,2,3,4,5,8,4,3,2,1],that\\'s why answer is 5."
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "While solving just remember : arr is a mountain array if and only if: arr.length >= 3....\\nand u have done it!!!!"
                    },
                    {
                        "username": "aakasheshwar",
                        "content": "class Solution {\npublic:\n     \n     int dp[1001][1002][3][2];\n    int f(int i,int j,vector<int> &a,int k,int flag){\n\n        if(i==a.size()){\n            if(flag==0){\n                return -1e5;\n            }\n            return 0;\n        }\n        if(dp[i][j+1][k][flag]!=-1) return dp[i][j+1][k][flag];\n        int pick=0;\n        if(j==-1){\n            pick=1+f(i+1,i,a,0,0);\n        }\n        \n       else{\n        if(k==0){\n            if(a[i]>a[j]) pick=1+max(f(i+1,i,a,0,flag),f(i+1,i,a,1,flag));\n        }\n        if(k==1){\n            if(a[i]<a[j]) pick=1+f(i+1,i,a,1,1);\n        }\n       }\n         int nopick=0+f(i+1,j,a,k,flag);\n        return dp[i][j+1][k][flag]=max(pick,nopick);\n\n\n    }\n    int minimumMountainRemovals(vector<int>& nums) {\n        \n        memset(dp,-1,sizeof(dp));\n        int maxi=f(0,-1,nums,0,0);\n\n         return nums.size()-maxi;\n\n    }\n};\n\n[1,2,1,3,4,4]\nfails for this test case.Can anyone please tell whats wrong in this code?\n\n\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone tell me whats wrong in my code ?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    int dp[1001][2][2];\\n\\n    int f(vector<int> &nums, int idx, bool incr, bool decr) {\\n\\n        if(idx == nums.size() - 1) {\\n            if(incr && decr) {\\n                return 0;\\n            } else {\\n                return INT_MAX/2;\\n            }\\n        }\\n\\n\\n        if(dp[idx][incr][decr] != -1) return dp[idx][incr][decr];\\n\\n        int remove_this = INT_MAX/2;\\n        \\n        if((!incr && !decr)) {\\n            remove_this = 1 + f(nums, idx + 1, incr, decr);\\n        }\\n\\n        int remove_between = INT_MAX/2;\\n\\n        for(int i = idx + 1; i < nums.size(); i++) {\\n            if(nums[i] > nums[idx] && !decr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, true, decr));\\n            } else if(nums[i] < nums[idx] && incr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, incr, true));\\n            } \\n        }\\n\\n        return dp[idx][incr][decr] = min(remove_this, remove_between);\\n\\n    }\\n\\n\\n\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < 1001; i++) {\\n            for(int j = 0; j < 2; j++) {\\n                for(int k = 0; k < 2; k++) {\\n                    dp[i][j][k] = -1;\\n                }\\n            }\\n        }  \\n\\n        return f(nums, 0, false, false);      \\n    }\\n\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Variant of  longest bitonic subsequence:\\n\\nFind the longest increasing subsequence count\\nFind the longest decreasing subsequence count\\nFind the longest bitonic subsequence count such that it should make mountain only when both increasing and decreasing numbers exists."
                    }
                ]
            },
            {
                "id": 1890117,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Calculate the length of the Longest Increasing Subsequence (LIS) as well as the length of the Longest Decreasing Subsequence (LDS) for each index i and store them in two arrays.\n\nNow, if we consider each index as a potential peak of a mountain array, the answer for each index is given by `LIS[i] + LDS[i] - 1`.\n\nReturn nums.length - maximum answer obtained from all indices."
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "[@geekyshark](/geekyshark) yes did the same on it"
                    },
                    {
                        "username": "geekyshark",
                        "content": "also just check LIS[i] && LDS[i] both are not equal to one, as it will mean that the i considered as peak will make the array either strictly increasing (LDS[i]=1) or strictly increasing (LIS[i]=1)"
                    },
                    {
                        "username": "zamankansari",
                        "content": "[@Rachit_Agnihotri](/Rachit_Agnihotri) its already assured in the question that we can always make a mountain array\\n"
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "it will fail as the peak should be between the array. it will fail in case of purely increasing or decreasing sequence "
                    },
                    {
                        "username": "user7108Pz",
                        "content": "ans for this test case should be 1. 9,8,1,7,6,5,4,3,2,1]. if we remove 1, at 2nd index(0 based indexing)"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "[@bruteforce007](/bruteforce007) can you elaborate why we did that"
                    },
                    {
                        "username": "bruteforce007",
                        "content": "you should add one more condition while calculation the final answer \\nfor(int i = 0 ; i < nums.size() ; i++){\\n        if(dp1[i]==1||dp2[i]==1) continue; // This condition avoid bitonic subsequence\\n        ans = max(ans,dp1[i] + dp2[i] - 1);\\n}"
                    },
                    {
                        "username": "harshbeer18",
                        "content": "no thats true for a bitonic sequence but not true for a mountain array, mountain array will be 1 7 6 5 4 3 2 1"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The main part of this problem is to optimize the LIS algorithm which can be done in O(nlogn) and rest is easy."
                    },
                    {
                        "username": "ABugWithTheBigDreams",
                        "content": "a=Find longest increasing subsequence\\nx=Find longest decreasing subsequence\\n\\nans=number of elements in vector - (a+x-1)\\n\\na+x-1 = gives maximum length of bitonic array we want to find minimum nmumber of removals , so we can subtract maximum length from the size of the vector to get the number of removals."
                    },
                    {
                        "username": "aryan_gupta12",
                        "content": "Consider only the indices from i=1 to n-2 as specified in the question.\\nAlso consider only those left and right subsequences which have length greater than 1."
                    },
                    {
                        "username": "amit_9899",
                        "content": "Why for the input [1,1,1,2,2,3,3,3,4,5,8,4,3,2,1] answer is 5 instead of 7 ?\\nThe mountain should be [3,4,5,8,4,3,2,1]."
                    },
                    {
                        "username": "Abhay399",
                        "content": "The mountain should be [1,2,3,4,5,8,4,3,2,1],that\\'s why answer is 5."
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "While solving just remember : arr is a mountain array if and only if: arr.length >= 3....\\nand u have done it!!!!"
                    },
                    {
                        "username": "aakasheshwar",
                        "content": "class Solution {\npublic:\n     \n     int dp[1001][1002][3][2];\n    int f(int i,int j,vector<int> &a,int k,int flag){\n\n        if(i==a.size()){\n            if(flag==0){\n                return -1e5;\n            }\n            return 0;\n        }\n        if(dp[i][j+1][k][flag]!=-1) return dp[i][j+1][k][flag];\n        int pick=0;\n        if(j==-1){\n            pick=1+f(i+1,i,a,0,0);\n        }\n        \n       else{\n        if(k==0){\n            if(a[i]>a[j]) pick=1+max(f(i+1,i,a,0,flag),f(i+1,i,a,1,flag));\n        }\n        if(k==1){\n            if(a[i]<a[j]) pick=1+f(i+1,i,a,1,1);\n        }\n       }\n         int nopick=0+f(i+1,j,a,k,flag);\n        return dp[i][j+1][k][flag]=max(pick,nopick);\n\n\n    }\n    int minimumMountainRemovals(vector<int>& nums) {\n        \n        memset(dp,-1,sizeof(dp));\n        int maxi=f(0,-1,nums,0,0);\n\n         return nums.size()-maxi;\n\n    }\n};\n\n[1,2,1,3,4,4]\nfails for this test case.Can anyone please tell whats wrong in this code?\n\n\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone tell me whats wrong in my code ?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    int dp[1001][2][2];\\n\\n    int f(vector<int> &nums, int idx, bool incr, bool decr) {\\n\\n        if(idx == nums.size() - 1) {\\n            if(incr && decr) {\\n                return 0;\\n            } else {\\n                return INT_MAX/2;\\n            }\\n        }\\n\\n\\n        if(dp[idx][incr][decr] != -1) return dp[idx][incr][decr];\\n\\n        int remove_this = INT_MAX/2;\\n        \\n        if((!incr && !decr)) {\\n            remove_this = 1 + f(nums, idx + 1, incr, decr);\\n        }\\n\\n        int remove_between = INT_MAX/2;\\n\\n        for(int i = idx + 1; i < nums.size(); i++) {\\n            if(nums[i] > nums[idx] && !decr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, true, decr));\\n            } else if(nums[i] < nums[idx] && incr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, incr, true));\\n            } \\n        }\\n\\n        return dp[idx][incr][decr] = min(remove_this, remove_between);\\n\\n    }\\n\\n\\n\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < 1001; i++) {\\n            for(int j = 0; j < 2; j++) {\\n                for(int k = 0; k < 2; k++) {\\n                    dp[i][j][k] = -1;\\n                }\\n            }\\n        }  \\n\\n        return f(nums, 0, false, false);      \\n    }\\n\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Variant of  longest bitonic subsequence:\\n\\nFind the longest increasing subsequence count\\nFind the longest decreasing subsequence count\\nFind the longest bitonic subsequence count such that it should make mountain only when both increasing and decreasing numbers exists."
                    }
                ]
            },
            {
                "id": 1887359,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Calculate the length of the Longest Increasing Subsequence (LIS) as well as the length of the Longest Decreasing Subsequence (LDS) for each index i and store them in two arrays.\n\nNow, if we consider each index as a potential peak of a mountain array, the answer for each index is given by `LIS[i] + LDS[i] - 1`.\n\nReturn nums.length - maximum answer obtained from all indices."
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "[@geekyshark](/geekyshark) yes did the same on it"
                    },
                    {
                        "username": "geekyshark",
                        "content": "also just check LIS[i] && LDS[i] both are not equal to one, as it will mean that the i considered as peak will make the array either strictly increasing (LDS[i]=1) or strictly increasing (LIS[i]=1)"
                    },
                    {
                        "username": "zamankansari",
                        "content": "[@Rachit_Agnihotri](/Rachit_Agnihotri) its already assured in the question that we can always make a mountain array\\n"
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "it will fail as the peak should be between the array. it will fail in case of purely increasing or decreasing sequence "
                    },
                    {
                        "username": "user7108Pz",
                        "content": "ans for this test case should be 1. 9,8,1,7,6,5,4,3,2,1]. if we remove 1, at 2nd index(0 based indexing)"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "[@bruteforce007](/bruteforce007) can you elaborate why we did that"
                    },
                    {
                        "username": "bruteforce007",
                        "content": "you should add one more condition while calculation the final answer \\nfor(int i = 0 ; i < nums.size() ; i++){\\n        if(dp1[i]==1||dp2[i]==1) continue; // This condition avoid bitonic subsequence\\n        ans = max(ans,dp1[i] + dp2[i] - 1);\\n}"
                    },
                    {
                        "username": "harshbeer18",
                        "content": "no thats true for a bitonic sequence but not true for a mountain array, mountain array will be 1 7 6 5 4 3 2 1"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The main part of this problem is to optimize the LIS algorithm which can be done in O(nlogn) and rest is easy."
                    },
                    {
                        "username": "ABugWithTheBigDreams",
                        "content": "a=Find longest increasing subsequence\\nx=Find longest decreasing subsequence\\n\\nans=number of elements in vector - (a+x-1)\\n\\na+x-1 = gives maximum length of bitonic array we want to find minimum nmumber of removals , so we can subtract maximum length from the size of the vector to get the number of removals."
                    },
                    {
                        "username": "aryan_gupta12",
                        "content": "Consider only the indices from i=1 to n-2 as specified in the question.\\nAlso consider only those left and right subsequences which have length greater than 1."
                    },
                    {
                        "username": "amit_9899",
                        "content": "Why for the input [1,1,1,2,2,3,3,3,4,5,8,4,3,2,1] answer is 5 instead of 7 ?\\nThe mountain should be [3,4,5,8,4,3,2,1]."
                    },
                    {
                        "username": "Abhay399",
                        "content": "The mountain should be [1,2,3,4,5,8,4,3,2,1],that\\'s why answer is 5."
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "While solving just remember : arr is a mountain array if and only if: arr.length >= 3....\\nand u have done it!!!!"
                    },
                    {
                        "username": "aakasheshwar",
                        "content": "class Solution {\npublic:\n     \n     int dp[1001][1002][3][2];\n    int f(int i,int j,vector<int> &a,int k,int flag){\n\n        if(i==a.size()){\n            if(flag==0){\n                return -1e5;\n            }\n            return 0;\n        }\n        if(dp[i][j+1][k][flag]!=-1) return dp[i][j+1][k][flag];\n        int pick=0;\n        if(j==-1){\n            pick=1+f(i+1,i,a,0,0);\n        }\n        \n       else{\n        if(k==0){\n            if(a[i]>a[j]) pick=1+max(f(i+1,i,a,0,flag),f(i+1,i,a,1,flag));\n        }\n        if(k==1){\n            if(a[i]<a[j]) pick=1+f(i+1,i,a,1,1);\n        }\n       }\n         int nopick=0+f(i+1,j,a,k,flag);\n        return dp[i][j+1][k][flag]=max(pick,nopick);\n\n\n    }\n    int minimumMountainRemovals(vector<int>& nums) {\n        \n        memset(dp,-1,sizeof(dp));\n        int maxi=f(0,-1,nums,0,0);\n\n         return nums.size()-maxi;\n\n    }\n};\n\n[1,2,1,3,4,4]\nfails for this test case.Can anyone please tell whats wrong in this code?\n\n\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone tell me whats wrong in my code ?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    int dp[1001][2][2];\\n\\n    int f(vector<int> &nums, int idx, bool incr, bool decr) {\\n\\n        if(idx == nums.size() - 1) {\\n            if(incr && decr) {\\n                return 0;\\n            } else {\\n                return INT_MAX/2;\\n            }\\n        }\\n\\n\\n        if(dp[idx][incr][decr] != -1) return dp[idx][incr][decr];\\n\\n        int remove_this = INT_MAX/2;\\n        \\n        if((!incr && !decr)) {\\n            remove_this = 1 + f(nums, idx + 1, incr, decr);\\n        }\\n\\n        int remove_between = INT_MAX/2;\\n\\n        for(int i = idx + 1; i < nums.size(); i++) {\\n            if(nums[i] > nums[idx] && !decr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, true, decr));\\n            } else if(nums[i] < nums[idx] && incr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, incr, true));\\n            } \\n        }\\n\\n        return dp[idx][incr][decr] = min(remove_this, remove_between);\\n\\n    }\\n\\n\\n\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < 1001; i++) {\\n            for(int j = 0; j < 2; j++) {\\n                for(int k = 0; k < 2; k++) {\\n                    dp[i][j][k] = -1;\\n                }\\n            }\\n        }  \\n\\n        return f(nums, 0, false, false);      \\n    }\\n\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Variant of  longest bitonic subsequence:\\n\\nFind the longest increasing subsequence count\\nFind the longest decreasing subsequence count\\nFind the longest bitonic subsequence count such that it should make mountain only when both increasing and decreasing numbers exists."
                    }
                ]
            },
            {
                "id": 1954835,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Calculate the length of the Longest Increasing Subsequence (LIS) as well as the length of the Longest Decreasing Subsequence (LDS) for each index i and store them in two arrays.\n\nNow, if we consider each index as a potential peak of a mountain array, the answer for each index is given by `LIS[i] + LDS[i] - 1`.\n\nReturn nums.length - maximum answer obtained from all indices."
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "[@geekyshark](/geekyshark) yes did the same on it"
                    },
                    {
                        "username": "geekyshark",
                        "content": "also just check LIS[i] && LDS[i] both are not equal to one, as it will mean that the i considered as peak will make the array either strictly increasing (LDS[i]=1) or strictly increasing (LIS[i]=1)"
                    },
                    {
                        "username": "zamankansari",
                        "content": "[@Rachit_Agnihotri](/Rachit_Agnihotri) its already assured in the question that we can always make a mountain array\\n"
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "it will fail as the peak should be between the array. it will fail in case of purely increasing or decreasing sequence "
                    },
                    {
                        "username": "user7108Pz",
                        "content": "ans for this test case should be 1. 9,8,1,7,6,5,4,3,2,1]. if we remove 1, at 2nd index(0 based indexing)"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "[@bruteforce007](/bruteforce007) can you elaborate why we did that"
                    },
                    {
                        "username": "bruteforce007",
                        "content": "you should add one more condition while calculation the final answer \\nfor(int i = 0 ; i < nums.size() ; i++){\\n        if(dp1[i]==1||dp2[i]==1) continue; // This condition avoid bitonic subsequence\\n        ans = max(ans,dp1[i] + dp2[i] - 1);\\n}"
                    },
                    {
                        "username": "harshbeer18",
                        "content": "no thats true for a bitonic sequence but not true for a mountain array, mountain array will be 1 7 6 5 4 3 2 1"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The main part of this problem is to optimize the LIS algorithm which can be done in O(nlogn) and rest is easy."
                    },
                    {
                        "username": "ABugWithTheBigDreams",
                        "content": "a=Find longest increasing subsequence\\nx=Find longest decreasing subsequence\\n\\nans=number of elements in vector - (a+x-1)\\n\\na+x-1 = gives maximum length of bitonic array we want to find minimum nmumber of removals , so we can subtract maximum length from the size of the vector to get the number of removals."
                    },
                    {
                        "username": "aryan_gupta12",
                        "content": "Consider only the indices from i=1 to n-2 as specified in the question.\\nAlso consider only those left and right subsequences which have length greater than 1."
                    },
                    {
                        "username": "amit_9899",
                        "content": "Why for the input [1,1,1,2,2,3,3,3,4,5,8,4,3,2,1] answer is 5 instead of 7 ?\\nThe mountain should be [3,4,5,8,4,3,2,1]."
                    },
                    {
                        "username": "Abhay399",
                        "content": "The mountain should be [1,2,3,4,5,8,4,3,2,1],that\\'s why answer is 5."
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "While solving just remember : arr is a mountain array if and only if: arr.length >= 3....\\nand u have done it!!!!"
                    },
                    {
                        "username": "aakasheshwar",
                        "content": "class Solution {\npublic:\n     \n     int dp[1001][1002][3][2];\n    int f(int i,int j,vector<int> &a,int k,int flag){\n\n        if(i==a.size()){\n            if(flag==0){\n                return -1e5;\n            }\n            return 0;\n        }\n        if(dp[i][j+1][k][flag]!=-1) return dp[i][j+1][k][flag];\n        int pick=0;\n        if(j==-1){\n            pick=1+f(i+1,i,a,0,0);\n        }\n        \n       else{\n        if(k==0){\n            if(a[i]>a[j]) pick=1+max(f(i+1,i,a,0,flag),f(i+1,i,a,1,flag));\n        }\n        if(k==1){\n            if(a[i]<a[j]) pick=1+f(i+1,i,a,1,1);\n        }\n       }\n         int nopick=0+f(i+1,j,a,k,flag);\n        return dp[i][j+1][k][flag]=max(pick,nopick);\n\n\n    }\n    int minimumMountainRemovals(vector<int>& nums) {\n        \n        memset(dp,-1,sizeof(dp));\n        int maxi=f(0,-1,nums,0,0);\n\n         return nums.size()-maxi;\n\n    }\n};\n\n[1,2,1,3,4,4]\nfails for this test case.Can anyone please tell whats wrong in this code?\n\n\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone tell me whats wrong in my code ?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    int dp[1001][2][2];\\n\\n    int f(vector<int> &nums, int idx, bool incr, bool decr) {\\n\\n        if(idx == nums.size() - 1) {\\n            if(incr && decr) {\\n                return 0;\\n            } else {\\n                return INT_MAX/2;\\n            }\\n        }\\n\\n\\n        if(dp[idx][incr][decr] != -1) return dp[idx][incr][decr];\\n\\n        int remove_this = INT_MAX/2;\\n        \\n        if((!incr && !decr)) {\\n            remove_this = 1 + f(nums, idx + 1, incr, decr);\\n        }\\n\\n        int remove_between = INT_MAX/2;\\n\\n        for(int i = idx + 1; i < nums.size(); i++) {\\n            if(nums[i] > nums[idx] && !decr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, true, decr));\\n            } else if(nums[i] < nums[idx] && incr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, incr, true));\\n            } \\n        }\\n\\n        return dp[idx][incr][decr] = min(remove_this, remove_between);\\n\\n    }\\n\\n\\n\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < 1001; i++) {\\n            for(int j = 0; j < 2; j++) {\\n                for(int k = 0; k < 2; k++) {\\n                    dp[i][j][k] = -1;\\n                }\\n            }\\n        }  \\n\\n        return f(nums, 0, false, false);      \\n    }\\n\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Variant of  longest bitonic subsequence:\\n\\nFind the longest increasing subsequence count\\nFind the longest decreasing subsequence count\\nFind the longest bitonic subsequence count such that it should make mountain only when both increasing and decreasing numbers exists."
                    }
                ]
            },
            {
                "id": 1671636,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Calculate the length of the Longest Increasing Subsequence (LIS) as well as the length of the Longest Decreasing Subsequence (LDS) for each index i and store them in two arrays.\n\nNow, if we consider each index as a potential peak of a mountain array, the answer for each index is given by `LIS[i] + LDS[i] - 1`.\n\nReturn nums.length - maximum answer obtained from all indices."
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "[@geekyshark](/geekyshark) yes did the same on it"
                    },
                    {
                        "username": "geekyshark",
                        "content": "also just check LIS[i] && LDS[i] both are not equal to one, as it will mean that the i considered as peak will make the array either strictly increasing (LDS[i]=1) or strictly increasing (LIS[i]=1)"
                    },
                    {
                        "username": "zamankansari",
                        "content": "[@Rachit_Agnihotri](/Rachit_Agnihotri) its already assured in the question that we can always make a mountain array\\n"
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "it will fail as the peak should be between the array. it will fail in case of purely increasing or decreasing sequence "
                    },
                    {
                        "username": "user7108Pz",
                        "content": "ans for this test case should be 1. 9,8,1,7,6,5,4,3,2,1]. if we remove 1, at 2nd index(0 based indexing)"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "[@bruteforce007](/bruteforce007) can you elaborate why we did that"
                    },
                    {
                        "username": "bruteforce007",
                        "content": "you should add one more condition while calculation the final answer \\nfor(int i = 0 ; i < nums.size() ; i++){\\n        if(dp1[i]==1||dp2[i]==1) continue; // This condition avoid bitonic subsequence\\n        ans = max(ans,dp1[i] + dp2[i] - 1);\\n}"
                    },
                    {
                        "username": "harshbeer18",
                        "content": "no thats true for a bitonic sequence but not true for a mountain array, mountain array will be 1 7 6 5 4 3 2 1"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The main part of this problem is to optimize the LIS algorithm which can be done in O(nlogn) and rest is easy."
                    },
                    {
                        "username": "ABugWithTheBigDreams",
                        "content": "a=Find longest increasing subsequence\\nx=Find longest decreasing subsequence\\n\\nans=number of elements in vector - (a+x-1)\\n\\na+x-1 = gives maximum length of bitonic array we want to find minimum nmumber of removals , so we can subtract maximum length from the size of the vector to get the number of removals."
                    },
                    {
                        "username": "aryan_gupta12",
                        "content": "Consider only the indices from i=1 to n-2 as specified in the question.\\nAlso consider only those left and right subsequences which have length greater than 1."
                    },
                    {
                        "username": "amit_9899",
                        "content": "Why for the input [1,1,1,2,2,3,3,3,4,5,8,4,3,2,1] answer is 5 instead of 7 ?\\nThe mountain should be [3,4,5,8,4,3,2,1]."
                    },
                    {
                        "username": "Abhay399",
                        "content": "The mountain should be [1,2,3,4,5,8,4,3,2,1],that\\'s why answer is 5."
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "While solving just remember : arr is a mountain array if and only if: arr.length >= 3....\\nand u have done it!!!!"
                    },
                    {
                        "username": "aakasheshwar",
                        "content": "class Solution {\npublic:\n     \n     int dp[1001][1002][3][2];\n    int f(int i,int j,vector<int> &a,int k,int flag){\n\n        if(i==a.size()){\n            if(flag==0){\n                return -1e5;\n            }\n            return 0;\n        }\n        if(dp[i][j+1][k][flag]!=-1) return dp[i][j+1][k][flag];\n        int pick=0;\n        if(j==-1){\n            pick=1+f(i+1,i,a,0,0);\n        }\n        \n       else{\n        if(k==0){\n            if(a[i]>a[j]) pick=1+max(f(i+1,i,a,0,flag),f(i+1,i,a,1,flag));\n        }\n        if(k==1){\n            if(a[i]<a[j]) pick=1+f(i+1,i,a,1,1);\n        }\n       }\n         int nopick=0+f(i+1,j,a,k,flag);\n        return dp[i][j+1][k][flag]=max(pick,nopick);\n\n\n    }\n    int minimumMountainRemovals(vector<int>& nums) {\n        \n        memset(dp,-1,sizeof(dp));\n        int maxi=f(0,-1,nums,0,0);\n\n         return nums.size()-maxi;\n\n    }\n};\n\n[1,2,1,3,4,4]\nfails for this test case.Can anyone please tell whats wrong in this code?\n\n\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone tell me whats wrong in my code ?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    int dp[1001][2][2];\\n\\n    int f(vector<int> &nums, int idx, bool incr, bool decr) {\\n\\n        if(idx == nums.size() - 1) {\\n            if(incr && decr) {\\n                return 0;\\n            } else {\\n                return INT_MAX/2;\\n            }\\n        }\\n\\n\\n        if(dp[idx][incr][decr] != -1) return dp[idx][incr][decr];\\n\\n        int remove_this = INT_MAX/2;\\n        \\n        if((!incr && !decr)) {\\n            remove_this = 1 + f(nums, idx + 1, incr, decr);\\n        }\\n\\n        int remove_between = INT_MAX/2;\\n\\n        for(int i = idx + 1; i < nums.size(); i++) {\\n            if(nums[i] > nums[idx] && !decr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, true, decr));\\n            } else if(nums[i] < nums[idx] && incr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, incr, true));\\n            } \\n        }\\n\\n        return dp[idx][incr][decr] = min(remove_this, remove_between);\\n\\n    }\\n\\n\\n\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < 1001; i++) {\\n            for(int j = 0; j < 2; j++) {\\n                for(int k = 0; k < 2; k++) {\\n                    dp[i][j][k] = -1;\\n                }\\n            }\\n        }  \\n\\n        return f(nums, 0, false, false);      \\n    }\\n\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Variant of  longest bitonic subsequence:\\n\\nFind the longest increasing subsequence count\\nFind the longest decreasing subsequence count\\nFind the longest bitonic subsequence count such that it should make mountain only when both increasing and decreasing numbers exists."
                    }
                ]
            },
            {
                "id": 1574814,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Calculate the length of the Longest Increasing Subsequence (LIS) as well as the length of the Longest Decreasing Subsequence (LDS) for each index i and store them in two arrays.\n\nNow, if we consider each index as a potential peak of a mountain array, the answer for each index is given by `LIS[i] + LDS[i] - 1`.\n\nReturn nums.length - maximum answer obtained from all indices."
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "[@geekyshark](/geekyshark) yes did the same on it"
                    },
                    {
                        "username": "geekyshark",
                        "content": "also just check LIS[i] && LDS[i] both are not equal to one, as it will mean that the i considered as peak will make the array either strictly increasing (LDS[i]=1) or strictly increasing (LIS[i]=1)"
                    },
                    {
                        "username": "zamankansari",
                        "content": "[@Rachit_Agnihotri](/Rachit_Agnihotri) its already assured in the question that we can always make a mountain array\\n"
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "it will fail as the peak should be between the array. it will fail in case of purely increasing or decreasing sequence "
                    },
                    {
                        "username": "user7108Pz",
                        "content": "ans for this test case should be 1. 9,8,1,7,6,5,4,3,2,1]. if we remove 1, at 2nd index(0 based indexing)"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "[@bruteforce007](/bruteforce007) can you elaborate why we did that"
                    },
                    {
                        "username": "bruteforce007",
                        "content": "you should add one more condition while calculation the final answer \\nfor(int i = 0 ; i < nums.size() ; i++){\\n        if(dp1[i]==1||dp2[i]==1) continue; // This condition avoid bitonic subsequence\\n        ans = max(ans,dp1[i] + dp2[i] - 1);\\n}"
                    },
                    {
                        "username": "harshbeer18",
                        "content": "no thats true for a bitonic sequence but not true for a mountain array, mountain array will be 1 7 6 5 4 3 2 1"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The main part of this problem is to optimize the LIS algorithm which can be done in O(nlogn) and rest is easy."
                    },
                    {
                        "username": "ABugWithTheBigDreams",
                        "content": "a=Find longest increasing subsequence\\nx=Find longest decreasing subsequence\\n\\nans=number of elements in vector - (a+x-1)\\n\\na+x-1 = gives maximum length of bitonic array we want to find minimum nmumber of removals , so we can subtract maximum length from the size of the vector to get the number of removals."
                    },
                    {
                        "username": "aryan_gupta12",
                        "content": "Consider only the indices from i=1 to n-2 as specified in the question.\\nAlso consider only those left and right subsequences which have length greater than 1."
                    },
                    {
                        "username": "amit_9899",
                        "content": "Why for the input [1,1,1,2,2,3,3,3,4,5,8,4,3,2,1] answer is 5 instead of 7 ?\\nThe mountain should be [3,4,5,8,4,3,2,1]."
                    },
                    {
                        "username": "Abhay399",
                        "content": "The mountain should be [1,2,3,4,5,8,4,3,2,1],that\\'s why answer is 5."
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "While solving just remember : arr is a mountain array if and only if: arr.length >= 3....\\nand u have done it!!!!"
                    },
                    {
                        "username": "aakasheshwar",
                        "content": "class Solution {\npublic:\n     \n     int dp[1001][1002][3][2];\n    int f(int i,int j,vector<int> &a,int k,int flag){\n\n        if(i==a.size()){\n            if(flag==0){\n                return -1e5;\n            }\n            return 0;\n        }\n        if(dp[i][j+1][k][flag]!=-1) return dp[i][j+1][k][flag];\n        int pick=0;\n        if(j==-1){\n            pick=1+f(i+1,i,a,0,0);\n        }\n        \n       else{\n        if(k==0){\n            if(a[i]>a[j]) pick=1+max(f(i+1,i,a,0,flag),f(i+1,i,a,1,flag));\n        }\n        if(k==1){\n            if(a[i]<a[j]) pick=1+f(i+1,i,a,1,1);\n        }\n       }\n         int nopick=0+f(i+1,j,a,k,flag);\n        return dp[i][j+1][k][flag]=max(pick,nopick);\n\n\n    }\n    int minimumMountainRemovals(vector<int>& nums) {\n        \n        memset(dp,-1,sizeof(dp));\n        int maxi=f(0,-1,nums,0,0);\n\n         return nums.size()-maxi;\n\n    }\n};\n\n[1,2,1,3,4,4]\nfails for this test case.Can anyone please tell whats wrong in this code?\n\n\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone tell me whats wrong in my code ?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    int dp[1001][2][2];\\n\\n    int f(vector<int> &nums, int idx, bool incr, bool decr) {\\n\\n        if(idx == nums.size() - 1) {\\n            if(incr && decr) {\\n                return 0;\\n            } else {\\n                return INT_MAX/2;\\n            }\\n        }\\n\\n\\n        if(dp[idx][incr][decr] != -1) return dp[idx][incr][decr];\\n\\n        int remove_this = INT_MAX/2;\\n        \\n        if((!incr && !decr)) {\\n            remove_this = 1 + f(nums, idx + 1, incr, decr);\\n        }\\n\\n        int remove_between = INT_MAX/2;\\n\\n        for(int i = idx + 1; i < nums.size(); i++) {\\n            if(nums[i] > nums[idx] && !decr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, true, decr));\\n            } else if(nums[i] < nums[idx] && incr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, incr, true));\\n            } \\n        }\\n\\n        return dp[idx][incr][decr] = min(remove_this, remove_between);\\n\\n    }\\n\\n\\n\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < 1001; i++) {\\n            for(int j = 0; j < 2; j++) {\\n                for(int k = 0; k < 2; k++) {\\n                    dp[i][j][k] = -1;\\n                }\\n            }\\n        }  \\n\\n        return f(nums, 0, false, false);      \\n    }\\n\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Variant of  longest bitonic subsequence:\\n\\nFind the longest increasing subsequence count\\nFind the longest decreasing subsequence count\\nFind the longest bitonic subsequence count such that it should make mountain only when both increasing and decreasing numbers exists."
                    }
                ]
            },
            {
                "id": 2072059,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Calculate the length of the Longest Increasing Subsequence (LIS) as well as the length of the Longest Decreasing Subsequence (LDS) for each index i and store them in two arrays.\n\nNow, if we consider each index as a potential peak of a mountain array, the answer for each index is given by `LIS[i] + LDS[i] - 1`.\n\nReturn nums.length - maximum answer obtained from all indices."
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "[@geekyshark](/geekyshark) yes did the same on it"
                    },
                    {
                        "username": "geekyshark",
                        "content": "also just check LIS[i] && LDS[i] both are not equal to one, as it will mean that the i considered as peak will make the array either strictly increasing (LDS[i]=1) or strictly increasing (LIS[i]=1)"
                    },
                    {
                        "username": "zamankansari",
                        "content": "[@Rachit_Agnihotri](/Rachit_Agnihotri) its already assured in the question that we can always make a mountain array\\n"
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "it will fail as the peak should be between the array. it will fail in case of purely increasing or decreasing sequence "
                    },
                    {
                        "username": "user7108Pz",
                        "content": "ans for this test case should be 1. 9,8,1,7,6,5,4,3,2,1]. if we remove 1, at 2nd index(0 based indexing)"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "[@bruteforce007](/bruteforce007) can you elaborate why we did that"
                    },
                    {
                        "username": "bruteforce007",
                        "content": "you should add one more condition while calculation the final answer \\nfor(int i = 0 ; i < nums.size() ; i++){\\n        if(dp1[i]==1||dp2[i]==1) continue; // This condition avoid bitonic subsequence\\n        ans = max(ans,dp1[i] + dp2[i] - 1);\\n}"
                    },
                    {
                        "username": "harshbeer18",
                        "content": "no thats true for a bitonic sequence but not true for a mountain array, mountain array will be 1 7 6 5 4 3 2 1"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The main part of this problem is to optimize the LIS algorithm which can be done in O(nlogn) and rest is easy."
                    },
                    {
                        "username": "ABugWithTheBigDreams",
                        "content": "a=Find longest increasing subsequence\\nx=Find longest decreasing subsequence\\n\\nans=number of elements in vector - (a+x-1)\\n\\na+x-1 = gives maximum length of bitonic array we want to find minimum nmumber of removals , so we can subtract maximum length from the size of the vector to get the number of removals."
                    },
                    {
                        "username": "aryan_gupta12",
                        "content": "Consider only the indices from i=1 to n-2 as specified in the question.\\nAlso consider only those left and right subsequences which have length greater than 1."
                    },
                    {
                        "username": "amit_9899",
                        "content": "Why for the input [1,1,1,2,2,3,3,3,4,5,8,4,3,2,1] answer is 5 instead of 7 ?\\nThe mountain should be [3,4,5,8,4,3,2,1]."
                    },
                    {
                        "username": "Abhay399",
                        "content": "The mountain should be [1,2,3,4,5,8,4,3,2,1],that\\'s why answer is 5."
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "While solving just remember : arr is a mountain array if and only if: arr.length >= 3....\\nand u have done it!!!!"
                    },
                    {
                        "username": "aakasheshwar",
                        "content": "class Solution {\npublic:\n     \n     int dp[1001][1002][3][2];\n    int f(int i,int j,vector<int> &a,int k,int flag){\n\n        if(i==a.size()){\n            if(flag==0){\n                return -1e5;\n            }\n            return 0;\n        }\n        if(dp[i][j+1][k][flag]!=-1) return dp[i][j+1][k][flag];\n        int pick=0;\n        if(j==-1){\n            pick=1+f(i+1,i,a,0,0);\n        }\n        \n       else{\n        if(k==0){\n            if(a[i]>a[j]) pick=1+max(f(i+1,i,a,0,flag),f(i+1,i,a,1,flag));\n        }\n        if(k==1){\n            if(a[i]<a[j]) pick=1+f(i+1,i,a,1,1);\n        }\n       }\n         int nopick=0+f(i+1,j,a,k,flag);\n        return dp[i][j+1][k][flag]=max(pick,nopick);\n\n\n    }\n    int minimumMountainRemovals(vector<int>& nums) {\n        \n        memset(dp,-1,sizeof(dp));\n        int maxi=f(0,-1,nums,0,0);\n\n         return nums.size()-maxi;\n\n    }\n};\n\n[1,2,1,3,4,4]\nfails for this test case.Can anyone please tell whats wrong in this code?\n\n\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone tell me whats wrong in my code ?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    int dp[1001][2][2];\\n\\n    int f(vector<int> &nums, int idx, bool incr, bool decr) {\\n\\n        if(idx == nums.size() - 1) {\\n            if(incr && decr) {\\n                return 0;\\n            } else {\\n                return INT_MAX/2;\\n            }\\n        }\\n\\n\\n        if(dp[idx][incr][decr] != -1) return dp[idx][incr][decr];\\n\\n        int remove_this = INT_MAX/2;\\n        \\n        if((!incr && !decr)) {\\n            remove_this = 1 + f(nums, idx + 1, incr, decr);\\n        }\\n\\n        int remove_between = INT_MAX/2;\\n\\n        for(int i = idx + 1; i < nums.size(); i++) {\\n            if(nums[i] > nums[idx] && !decr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, true, decr));\\n            } else if(nums[i] < nums[idx] && incr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, incr, true));\\n            } \\n        }\\n\\n        return dp[idx][incr][decr] = min(remove_this, remove_between);\\n\\n    }\\n\\n\\n\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < 1001; i++) {\\n            for(int j = 0; j < 2; j++) {\\n                for(int k = 0; k < 2; k++) {\\n                    dp[i][j][k] = -1;\\n                }\\n            }\\n        }  \\n\\n        return f(nums, 0, false, false);      \\n    }\\n\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Variant of  longest bitonic subsequence:\\n\\nFind the longest increasing subsequence count\\nFind the longest decreasing subsequence count\\nFind the longest bitonic subsequence count such that it should make mountain only when both increasing and decreasing numbers exists."
                    }
                ]
            },
            {
                "id": 1991211,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Calculate the length of the Longest Increasing Subsequence (LIS) as well as the length of the Longest Decreasing Subsequence (LDS) for each index i and store them in two arrays.\n\nNow, if we consider each index as a potential peak of a mountain array, the answer for each index is given by `LIS[i] + LDS[i] - 1`.\n\nReturn nums.length - maximum answer obtained from all indices."
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "[@geekyshark](/geekyshark) yes did the same on it"
                    },
                    {
                        "username": "geekyshark",
                        "content": "also just check LIS[i] && LDS[i] both are not equal to one, as it will mean that the i considered as peak will make the array either strictly increasing (LDS[i]=1) or strictly increasing (LIS[i]=1)"
                    },
                    {
                        "username": "zamankansari",
                        "content": "[@Rachit_Agnihotri](/Rachit_Agnihotri) its already assured in the question that we can always make a mountain array\\n"
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "it will fail as the peak should be between the array. it will fail in case of purely increasing or decreasing sequence "
                    },
                    {
                        "username": "user7108Pz",
                        "content": "ans for this test case should be 1. 9,8,1,7,6,5,4,3,2,1]. if we remove 1, at 2nd index(0 based indexing)"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "[@bruteforce007](/bruteforce007) can you elaborate why we did that"
                    },
                    {
                        "username": "bruteforce007",
                        "content": "you should add one more condition while calculation the final answer \\nfor(int i = 0 ; i < nums.size() ; i++){\\n        if(dp1[i]==1||dp2[i]==1) continue; // This condition avoid bitonic subsequence\\n        ans = max(ans,dp1[i] + dp2[i] - 1);\\n}"
                    },
                    {
                        "username": "harshbeer18",
                        "content": "no thats true for a bitonic sequence but not true for a mountain array, mountain array will be 1 7 6 5 4 3 2 1"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The main part of this problem is to optimize the LIS algorithm which can be done in O(nlogn) and rest is easy."
                    },
                    {
                        "username": "ABugWithTheBigDreams",
                        "content": "a=Find longest increasing subsequence\\nx=Find longest decreasing subsequence\\n\\nans=number of elements in vector - (a+x-1)\\n\\na+x-1 = gives maximum length of bitonic array we want to find minimum nmumber of removals , so we can subtract maximum length from the size of the vector to get the number of removals."
                    },
                    {
                        "username": "aryan_gupta12",
                        "content": "Consider only the indices from i=1 to n-2 as specified in the question.\\nAlso consider only those left and right subsequences which have length greater than 1."
                    },
                    {
                        "username": "amit_9899",
                        "content": "Why for the input [1,1,1,2,2,3,3,3,4,5,8,4,3,2,1] answer is 5 instead of 7 ?\\nThe mountain should be [3,4,5,8,4,3,2,1]."
                    },
                    {
                        "username": "Abhay399",
                        "content": "The mountain should be [1,2,3,4,5,8,4,3,2,1],that\\'s why answer is 5."
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "While solving just remember : arr is a mountain array if and only if: arr.length >= 3....\\nand u have done it!!!!"
                    },
                    {
                        "username": "aakasheshwar",
                        "content": "class Solution {\npublic:\n     \n     int dp[1001][1002][3][2];\n    int f(int i,int j,vector<int> &a,int k,int flag){\n\n        if(i==a.size()){\n            if(flag==0){\n                return -1e5;\n            }\n            return 0;\n        }\n        if(dp[i][j+1][k][flag]!=-1) return dp[i][j+1][k][flag];\n        int pick=0;\n        if(j==-1){\n            pick=1+f(i+1,i,a,0,0);\n        }\n        \n       else{\n        if(k==0){\n            if(a[i]>a[j]) pick=1+max(f(i+1,i,a,0,flag),f(i+1,i,a,1,flag));\n        }\n        if(k==1){\n            if(a[i]<a[j]) pick=1+f(i+1,i,a,1,1);\n        }\n       }\n         int nopick=0+f(i+1,j,a,k,flag);\n        return dp[i][j+1][k][flag]=max(pick,nopick);\n\n\n    }\n    int minimumMountainRemovals(vector<int>& nums) {\n        \n        memset(dp,-1,sizeof(dp));\n        int maxi=f(0,-1,nums,0,0);\n\n         return nums.size()-maxi;\n\n    }\n};\n\n[1,2,1,3,4,4]\nfails for this test case.Can anyone please tell whats wrong in this code?\n\n\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone tell me whats wrong in my code ?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    int dp[1001][2][2];\\n\\n    int f(vector<int> &nums, int idx, bool incr, bool decr) {\\n\\n        if(idx == nums.size() - 1) {\\n            if(incr && decr) {\\n                return 0;\\n            } else {\\n                return INT_MAX/2;\\n            }\\n        }\\n\\n\\n        if(dp[idx][incr][decr] != -1) return dp[idx][incr][decr];\\n\\n        int remove_this = INT_MAX/2;\\n        \\n        if((!incr && !decr)) {\\n            remove_this = 1 + f(nums, idx + 1, incr, decr);\\n        }\\n\\n        int remove_between = INT_MAX/2;\\n\\n        for(int i = idx + 1; i < nums.size(); i++) {\\n            if(nums[i] > nums[idx] && !decr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, true, decr));\\n            } else if(nums[i] < nums[idx] && incr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, incr, true));\\n            } \\n        }\\n\\n        return dp[idx][incr][decr] = min(remove_this, remove_between);\\n\\n    }\\n\\n\\n\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < 1001; i++) {\\n            for(int j = 0; j < 2; j++) {\\n                for(int k = 0; k < 2; k++) {\\n                    dp[i][j][k] = -1;\\n                }\\n            }\\n        }  \\n\\n        return f(nums, 0, false, false);      \\n    }\\n\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Variant of  longest bitonic subsequence:\\n\\nFind the longest increasing subsequence count\\nFind the longest decreasing subsequence count\\nFind the longest bitonic subsequence count such that it should make mountain only when both increasing and decreasing numbers exists."
                    }
                ]
            },
            {
                "id": 1984391,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Calculate the length of the Longest Increasing Subsequence (LIS) as well as the length of the Longest Decreasing Subsequence (LDS) for each index i and store them in two arrays.\n\nNow, if we consider each index as a potential peak of a mountain array, the answer for each index is given by `LIS[i] + LDS[i] - 1`.\n\nReturn nums.length - maximum answer obtained from all indices."
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "[@geekyshark](/geekyshark) yes did the same on it"
                    },
                    {
                        "username": "geekyshark",
                        "content": "also just check LIS[i] && LDS[i] both are not equal to one, as it will mean that the i considered as peak will make the array either strictly increasing (LDS[i]=1) or strictly increasing (LIS[i]=1)"
                    },
                    {
                        "username": "zamankansari",
                        "content": "[@Rachit_Agnihotri](/Rachit_Agnihotri) its already assured in the question that we can always make a mountain array\\n"
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "it will fail as the peak should be between the array. it will fail in case of purely increasing or decreasing sequence "
                    },
                    {
                        "username": "user7108Pz",
                        "content": "ans for this test case should be 1. 9,8,1,7,6,5,4,3,2,1]. if we remove 1, at 2nd index(0 based indexing)"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "[@bruteforce007](/bruteforce007) can you elaborate why we did that"
                    },
                    {
                        "username": "bruteforce007",
                        "content": "you should add one more condition while calculation the final answer \\nfor(int i = 0 ; i < nums.size() ; i++){\\n        if(dp1[i]==1||dp2[i]==1) continue; // This condition avoid bitonic subsequence\\n        ans = max(ans,dp1[i] + dp2[i] - 1);\\n}"
                    },
                    {
                        "username": "harshbeer18",
                        "content": "no thats true for a bitonic sequence but not true for a mountain array, mountain array will be 1 7 6 5 4 3 2 1"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The main part of this problem is to optimize the LIS algorithm which can be done in O(nlogn) and rest is easy."
                    },
                    {
                        "username": "ABugWithTheBigDreams",
                        "content": "a=Find longest increasing subsequence\\nx=Find longest decreasing subsequence\\n\\nans=number of elements in vector - (a+x-1)\\n\\na+x-1 = gives maximum length of bitonic array we want to find minimum nmumber of removals , so we can subtract maximum length from the size of the vector to get the number of removals."
                    },
                    {
                        "username": "aryan_gupta12",
                        "content": "Consider only the indices from i=1 to n-2 as specified in the question.\\nAlso consider only those left and right subsequences which have length greater than 1."
                    },
                    {
                        "username": "amit_9899",
                        "content": "Why for the input [1,1,1,2,2,3,3,3,4,5,8,4,3,2,1] answer is 5 instead of 7 ?\\nThe mountain should be [3,4,5,8,4,3,2,1]."
                    },
                    {
                        "username": "Abhay399",
                        "content": "The mountain should be [1,2,3,4,5,8,4,3,2,1],that\\'s why answer is 5."
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "While solving just remember : arr is a mountain array if and only if: arr.length >= 3....\\nand u have done it!!!!"
                    },
                    {
                        "username": "aakasheshwar",
                        "content": "class Solution {\npublic:\n     \n     int dp[1001][1002][3][2];\n    int f(int i,int j,vector<int> &a,int k,int flag){\n\n        if(i==a.size()){\n            if(flag==0){\n                return -1e5;\n            }\n            return 0;\n        }\n        if(dp[i][j+1][k][flag]!=-1) return dp[i][j+1][k][flag];\n        int pick=0;\n        if(j==-1){\n            pick=1+f(i+1,i,a,0,0);\n        }\n        \n       else{\n        if(k==0){\n            if(a[i]>a[j]) pick=1+max(f(i+1,i,a,0,flag),f(i+1,i,a,1,flag));\n        }\n        if(k==1){\n            if(a[i]<a[j]) pick=1+f(i+1,i,a,1,1);\n        }\n       }\n         int nopick=0+f(i+1,j,a,k,flag);\n        return dp[i][j+1][k][flag]=max(pick,nopick);\n\n\n    }\n    int minimumMountainRemovals(vector<int>& nums) {\n        \n        memset(dp,-1,sizeof(dp));\n        int maxi=f(0,-1,nums,0,0);\n\n         return nums.size()-maxi;\n\n    }\n};\n\n[1,2,1,3,4,4]\nfails for this test case.Can anyone please tell whats wrong in this code?\n\n\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone tell me whats wrong in my code ?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    int dp[1001][2][2];\\n\\n    int f(vector<int> &nums, int idx, bool incr, bool decr) {\\n\\n        if(idx == nums.size() - 1) {\\n            if(incr && decr) {\\n                return 0;\\n            } else {\\n                return INT_MAX/2;\\n            }\\n        }\\n\\n\\n        if(dp[idx][incr][decr] != -1) return dp[idx][incr][decr];\\n\\n        int remove_this = INT_MAX/2;\\n        \\n        if((!incr && !decr)) {\\n            remove_this = 1 + f(nums, idx + 1, incr, decr);\\n        }\\n\\n        int remove_between = INT_MAX/2;\\n\\n        for(int i = idx + 1; i < nums.size(); i++) {\\n            if(nums[i] > nums[idx] && !decr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, true, decr));\\n            } else if(nums[i] < nums[idx] && incr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, incr, true));\\n            } \\n        }\\n\\n        return dp[idx][incr][decr] = min(remove_this, remove_between);\\n\\n    }\\n\\n\\n\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < 1001; i++) {\\n            for(int j = 0; j < 2; j++) {\\n                for(int k = 0; k < 2; k++) {\\n                    dp[i][j][k] = -1;\\n                }\\n            }\\n        }  \\n\\n        return f(nums, 0, false, false);      \\n    }\\n\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Variant of  longest bitonic subsequence:\\n\\nFind the longest increasing subsequence count\\nFind the longest decreasing subsequence count\\nFind the longest bitonic subsequence count such that it should make mountain only when both increasing and decreasing numbers exists."
                    }
                ]
            },
            {
                "id": 1957008,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Calculate the length of the Longest Increasing Subsequence (LIS) as well as the length of the Longest Decreasing Subsequence (LDS) for each index i and store them in two arrays.\n\nNow, if we consider each index as a potential peak of a mountain array, the answer for each index is given by `LIS[i] + LDS[i] - 1`.\n\nReturn nums.length - maximum answer obtained from all indices."
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "[@geekyshark](/geekyshark) yes did the same on it"
                    },
                    {
                        "username": "geekyshark",
                        "content": "also just check LIS[i] && LDS[i] both are not equal to one, as it will mean that the i considered as peak will make the array either strictly increasing (LDS[i]=1) or strictly increasing (LIS[i]=1)"
                    },
                    {
                        "username": "zamankansari",
                        "content": "[@Rachit_Agnihotri](/Rachit_Agnihotri) its already assured in the question that we can always make a mountain array\\n"
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "it will fail as the peak should be between the array. it will fail in case of purely increasing or decreasing sequence "
                    },
                    {
                        "username": "user7108Pz",
                        "content": "ans for this test case should be 1. 9,8,1,7,6,5,4,3,2,1]. if we remove 1, at 2nd index(0 based indexing)"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "[@bruteforce007](/bruteforce007) can you elaborate why we did that"
                    },
                    {
                        "username": "bruteforce007",
                        "content": "you should add one more condition while calculation the final answer \\nfor(int i = 0 ; i < nums.size() ; i++){\\n        if(dp1[i]==1||dp2[i]==1) continue; // This condition avoid bitonic subsequence\\n        ans = max(ans,dp1[i] + dp2[i] - 1);\\n}"
                    },
                    {
                        "username": "harshbeer18",
                        "content": "no thats true for a bitonic sequence but not true for a mountain array, mountain array will be 1 7 6 5 4 3 2 1"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The main part of this problem is to optimize the LIS algorithm which can be done in O(nlogn) and rest is easy."
                    },
                    {
                        "username": "ABugWithTheBigDreams",
                        "content": "a=Find longest increasing subsequence\\nx=Find longest decreasing subsequence\\n\\nans=number of elements in vector - (a+x-1)\\n\\na+x-1 = gives maximum length of bitonic array we want to find minimum nmumber of removals , so we can subtract maximum length from the size of the vector to get the number of removals."
                    },
                    {
                        "username": "aryan_gupta12",
                        "content": "Consider only the indices from i=1 to n-2 as specified in the question.\\nAlso consider only those left and right subsequences which have length greater than 1."
                    },
                    {
                        "username": "amit_9899",
                        "content": "Why for the input [1,1,1,2,2,3,3,3,4,5,8,4,3,2,1] answer is 5 instead of 7 ?\\nThe mountain should be [3,4,5,8,4,3,2,1]."
                    },
                    {
                        "username": "Abhay399",
                        "content": "The mountain should be [1,2,3,4,5,8,4,3,2,1],that\\'s why answer is 5."
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "While solving just remember : arr is a mountain array if and only if: arr.length >= 3....\\nand u have done it!!!!"
                    },
                    {
                        "username": "aakasheshwar",
                        "content": "class Solution {\npublic:\n     \n     int dp[1001][1002][3][2];\n    int f(int i,int j,vector<int> &a,int k,int flag){\n\n        if(i==a.size()){\n            if(flag==0){\n                return -1e5;\n            }\n            return 0;\n        }\n        if(dp[i][j+1][k][flag]!=-1) return dp[i][j+1][k][flag];\n        int pick=0;\n        if(j==-1){\n            pick=1+f(i+1,i,a,0,0);\n        }\n        \n       else{\n        if(k==0){\n            if(a[i]>a[j]) pick=1+max(f(i+1,i,a,0,flag),f(i+1,i,a,1,flag));\n        }\n        if(k==1){\n            if(a[i]<a[j]) pick=1+f(i+1,i,a,1,1);\n        }\n       }\n         int nopick=0+f(i+1,j,a,k,flag);\n        return dp[i][j+1][k][flag]=max(pick,nopick);\n\n\n    }\n    int minimumMountainRemovals(vector<int>& nums) {\n        \n        memset(dp,-1,sizeof(dp));\n        int maxi=f(0,-1,nums,0,0);\n\n         return nums.size()-maxi;\n\n    }\n};\n\n[1,2,1,3,4,4]\nfails for this test case.Can anyone please tell whats wrong in this code?\n\n\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone tell me whats wrong in my code ?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    int dp[1001][2][2];\\n\\n    int f(vector<int> &nums, int idx, bool incr, bool decr) {\\n\\n        if(idx == nums.size() - 1) {\\n            if(incr && decr) {\\n                return 0;\\n            } else {\\n                return INT_MAX/2;\\n            }\\n        }\\n\\n\\n        if(dp[idx][incr][decr] != -1) return dp[idx][incr][decr];\\n\\n        int remove_this = INT_MAX/2;\\n        \\n        if((!incr && !decr)) {\\n            remove_this = 1 + f(nums, idx + 1, incr, decr);\\n        }\\n\\n        int remove_between = INT_MAX/2;\\n\\n        for(int i = idx + 1; i < nums.size(); i++) {\\n            if(nums[i] > nums[idx] && !decr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, true, decr));\\n            } else if(nums[i] < nums[idx] && incr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, incr, true));\\n            } \\n        }\\n\\n        return dp[idx][incr][decr] = min(remove_this, remove_between);\\n\\n    }\\n\\n\\n\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < 1001; i++) {\\n            for(int j = 0; j < 2; j++) {\\n                for(int k = 0; k < 2; k++) {\\n                    dp[i][j][k] = -1;\\n                }\\n            }\\n        }  \\n\\n        return f(nums, 0, false, false);      \\n    }\\n\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Variant of  longest bitonic subsequence:\\n\\nFind the longest increasing subsequence count\\nFind the longest decreasing subsequence count\\nFind the longest bitonic subsequence count such that it should make mountain only when both increasing and decreasing numbers exists."
                    }
                ]
            },
            {
                "id": 1931605,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Calculate the length of the Longest Increasing Subsequence (LIS) as well as the length of the Longest Decreasing Subsequence (LDS) for each index i and store them in two arrays.\n\nNow, if we consider each index as a potential peak of a mountain array, the answer for each index is given by `LIS[i] + LDS[i] - 1`.\n\nReturn nums.length - maximum answer obtained from all indices."
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "[@geekyshark](/geekyshark) yes did the same on it"
                    },
                    {
                        "username": "geekyshark",
                        "content": "also just check LIS[i] && LDS[i] both are not equal to one, as it will mean that the i considered as peak will make the array either strictly increasing (LDS[i]=1) or strictly increasing (LIS[i]=1)"
                    },
                    {
                        "username": "zamankansari",
                        "content": "[@Rachit_Agnihotri](/Rachit_Agnihotri) its already assured in the question that we can always make a mountain array\\n"
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "it will fail as the peak should be between the array. it will fail in case of purely increasing or decreasing sequence "
                    },
                    {
                        "username": "user7108Pz",
                        "content": "ans for this test case should be 1. 9,8,1,7,6,5,4,3,2,1]. if we remove 1, at 2nd index(0 based indexing)"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "[@bruteforce007](/bruteforce007) can you elaborate why we did that"
                    },
                    {
                        "username": "bruteforce007",
                        "content": "you should add one more condition while calculation the final answer \\nfor(int i = 0 ; i < nums.size() ; i++){\\n        if(dp1[i]==1||dp2[i]==1) continue; // This condition avoid bitonic subsequence\\n        ans = max(ans,dp1[i] + dp2[i] - 1);\\n}"
                    },
                    {
                        "username": "harshbeer18",
                        "content": "no thats true for a bitonic sequence but not true for a mountain array, mountain array will be 1 7 6 5 4 3 2 1"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The main part of this problem is to optimize the LIS algorithm which can be done in O(nlogn) and rest is easy."
                    },
                    {
                        "username": "ABugWithTheBigDreams",
                        "content": "a=Find longest increasing subsequence\\nx=Find longest decreasing subsequence\\n\\nans=number of elements in vector - (a+x-1)\\n\\na+x-1 = gives maximum length of bitonic array we want to find minimum nmumber of removals , so we can subtract maximum length from the size of the vector to get the number of removals."
                    },
                    {
                        "username": "aryan_gupta12",
                        "content": "Consider only the indices from i=1 to n-2 as specified in the question.\\nAlso consider only those left and right subsequences which have length greater than 1."
                    },
                    {
                        "username": "amit_9899",
                        "content": "Why for the input [1,1,1,2,2,3,3,3,4,5,8,4,3,2,1] answer is 5 instead of 7 ?\\nThe mountain should be [3,4,5,8,4,3,2,1]."
                    },
                    {
                        "username": "Abhay399",
                        "content": "The mountain should be [1,2,3,4,5,8,4,3,2,1],that\\'s why answer is 5."
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "While solving just remember : arr is a mountain array if and only if: arr.length >= 3....\\nand u have done it!!!!"
                    },
                    {
                        "username": "aakasheshwar",
                        "content": "class Solution {\npublic:\n     \n     int dp[1001][1002][3][2];\n    int f(int i,int j,vector<int> &a,int k,int flag){\n\n        if(i==a.size()){\n            if(flag==0){\n                return -1e5;\n            }\n            return 0;\n        }\n        if(dp[i][j+1][k][flag]!=-1) return dp[i][j+1][k][flag];\n        int pick=0;\n        if(j==-1){\n            pick=1+f(i+1,i,a,0,0);\n        }\n        \n       else{\n        if(k==0){\n            if(a[i]>a[j]) pick=1+max(f(i+1,i,a,0,flag),f(i+1,i,a,1,flag));\n        }\n        if(k==1){\n            if(a[i]<a[j]) pick=1+f(i+1,i,a,1,1);\n        }\n       }\n         int nopick=0+f(i+1,j,a,k,flag);\n        return dp[i][j+1][k][flag]=max(pick,nopick);\n\n\n    }\n    int minimumMountainRemovals(vector<int>& nums) {\n        \n        memset(dp,-1,sizeof(dp));\n        int maxi=f(0,-1,nums,0,0);\n\n         return nums.size()-maxi;\n\n    }\n};\n\n[1,2,1,3,4,4]\nfails for this test case.Can anyone please tell whats wrong in this code?\n\n\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone tell me whats wrong in my code ?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    int dp[1001][2][2];\\n\\n    int f(vector<int> &nums, int idx, bool incr, bool decr) {\\n\\n        if(idx == nums.size() - 1) {\\n            if(incr && decr) {\\n                return 0;\\n            } else {\\n                return INT_MAX/2;\\n            }\\n        }\\n\\n\\n        if(dp[idx][incr][decr] != -1) return dp[idx][incr][decr];\\n\\n        int remove_this = INT_MAX/2;\\n        \\n        if((!incr && !decr)) {\\n            remove_this = 1 + f(nums, idx + 1, incr, decr);\\n        }\\n\\n        int remove_between = INT_MAX/2;\\n\\n        for(int i = idx + 1; i < nums.size(); i++) {\\n            if(nums[i] > nums[idx] && !decr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, true, decr));\\n            } else if(nums[i] < nums[idx] && incr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, incr, true));\\n            } \\n        }\\n\\n        return dp[idx][incr][decr] = min(remove_this, remove_between);\\n\\n    }\\n\\n\\n\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < 1001; i++) {\\n            for(int j = 0; j < 2; j++) {\\n                for(int k = 0; k < 2; k++) {\\n                    dp[i][j][k] = -1;\\n                }\\n            }\\n        }  \\n\\n        return f(nums, 0, false, false);      \\n    }\\n\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Variant of  longest bitonic subsequence:\\n\\nFind the longest increasing subsequence count\\nFind the longest decreasing subsequence count\\nFind the longest bitonic subsequence count such that it should make mountain only when both increasing and decreasing numbers exists."
                    }
                ]
            },
            {
                "id": 1890117,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Calculate the length of the Longest Increasing Subsequence (LIS) as well as the length of the Longest Decreasing Subsequence (LDS) for each index i and store them in two arrays.\n\nNow, if we consider each index as a potential peak of a mountain array, the answer for each index is given by `LIS[i] + LDS[i] - 1`.\n\nReturn nums.length - maximum answer obtained from all indices."
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "[@geekyshark](/geekyshark) yes did the same on it"
                    },
                    {
                        "username": "geekyshark",
                        "content": "also just check LIS[i] && LDS[i] both are not equal to one, as it will mean that the i considered as peak will make the array either strictly increasing (LDS[i]=1) or strictly increasing (LIS[i]=1)"
                    },
                    {
                        "username": "zamankansari",
                        "content": "[@Rachit_Agnihotri](/Rachit_Agnihotri) its already assured in the question that we can always make a mountain array\\n"
                    },
                    {
                        "username": "Rachit_Agnihotri",
                        "content": "it will fail as the peak should be between the array. it will fail in case of purely increasing or decreasing sequence "
                    },
                    {
                        "username": "user7108Pz",
                        "content": "ans for this test case should be 1. 9,8,1,7,6,5,4,3,2,1]. if we remove 1, at 2nd index(0 based indexing)"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "[@bruteforce007](/bruteforce007) can you elaborate why we did that"
                    },
                    {
                        "username": "bruteforce007",
                        "content": "you should add one more condition while calculation the final answer \\nfor(int i = 0 ; i < nums.size() ; i++){\\n        if(dp1[i]==1||dp2[i]==1) continue; // This condition avoid bitonic subsequence\\n        ans = max(ans,dp1[i] + dp2[i] - 1);\\n}"
                    },
                    {
                        "username": "harshbeer18",
                        "content": "no thats true for a bitonic sequence but not true for a mountain array, mountain array will be 1 7 6 5 4 3 2 1"
                    },
                    {
                        "username": "code_is_in_my_veins",
                        "content": "The main part of this problem is to optimize the LIS algorithm which can be done in O(nlogn) and rest is easy."
                    },
                    {
                        "username": "ABugWithTheBigDreams",
                        "content": "a=Find longest increasing subsequence\\nx=Find longest decreasing subsequence\\n\\nans=number of elements in vector - (a+x-1)\\n\\na+x-1 = gives maximum length of bitonic array we want to find minimum nmumber of removals , so we can subtract maximum length from the size of the vector to get the number of removals."
                    },
                    {
                        "username": "aryan_gupta12",
                        "content": "Consider only the indices from i=1 to n-2 as specified in the question.\\nAlso consider only those left and right subsequences which have length greater than 1."
                    },
                    {
                        "username": "amit_9899",
                        "content": "Why for the input [1,1,1,2,2,3,3,3,4,5,8,4,3,2,1] answer is 5 instead of 7 ?\\nThe mountain should be [3,4,5,8,4,3,2,1]."
                    },
                    {
                        "username": "Abhay399",
                        "content": "The mountain should be [1,2,3,4,5,8,4,3,2,1],that\\'s why answer is 5."
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "While solving just remember : arr is a mountain array if and only if: arr.length >= 3....\\nand u have done it!!!!"
                    },
                    {
                        "username": "aakasheshwar",
                        "content": "class Solution {\npublic:\n     \n     int dp[1001][1002][3][2];\n    int f(int i,int j,vector<int> &a,int k,int flag){\n\n        if(i==a.size()){\n            if(flag==0){\n                return -1e5;\n            }\n            return 0;\n        }\n        if(dp[i][j+1][k][flag]!=-1) return dp[i][j+1][k][flag];\n        int pick=0;\n        if(j==-1){\n            pick=1+f(i+1,i,a,0,0);\n        }\n        \n       else{\n        if(k==0){\n            if(a[i]>a[j]) pick=1+max(f(i+1,i,a,0,flag),f(i+1,i,a,1,flag));\n        }\n        if(k==1){\n            if(a[i]<a[j]) pick=1+f(i+1,i,a,1,1);\n        }\n       }\n         int nopick=0+f(i+1,j,a,k,flag);\n        return dp[i][j+1][k][flag]=max(pick,nopick);\n\n\n    }\n    int minimumMountainRemovals(vector<int>& nums) {\n        \n        memset(dp,-1,sizeof(dp));\n        int maxi=f(0,-1,nums,0,0);\n\n         return nums.size()-maxi;\n\n    }\n};\n\n[1,2,1,3,4,4]\nfails for this test case.Can anyone please tell whats wrong in this code?\n\n\n"
                    },
                    {
                        "username": "Tushar_Tushar",
                        "content": "can anyone tell me whats wrong in my code ?\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    int dp[1001][2][2];\\n\\n    int f(vector<int> &nums, int idx, bool incr, bool decr) {\\n\\n        if(idx == nums.size() - 1) {\\n            if(incr && decr) {\\n                return 0;\\n            } else {\\n                return INT_MAX/2;\\n            }\\n        }\\n\\n\\n        if(dp[idx][incr][decr] != -1) return dp[idx][incr][decr];\\n\\n        int remove_this = INT_MAX/2;\\n        \\n        if((!incr && !decr)) {\\n            remove_this = 1 + f(nums, idx + 1, incr, decr);\\n        }\\n\\n        int remove_between = INT_MAX/2;\\n\\n        for(int i = idx + 1; i < nums.size(); i++) {\\n            if(nums[i] > nums[idx] && !decr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, true, decr));\\n            } else if(nums[i] < nums[idx] && incr) {\\n                remove_between = min(remove_between, (i - idx - 1) + f(nums, i, incr, true));\\n            } \\n        }\\n\\n        return dp[idx][incr][decr] = min(remove_this, remove_between);\\n\\n    }\\n\\n\\n\\n\\n    int minimumMountainRemovals(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < 1001; i++) {\\n            for(int j = 0; j < 2; j++) {\\n                for(int k = 0; k < 2; k++) {\\n                    dp[i][j][k] = -1;\\n                }\\n            }\\n        }  \\n\\n        return f(nums, 0, false, false);      \\n    }\\n\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Variant of  longest bitonic subsequence:\\n\\nFind the longest increasing subsequence count\\nFind the longest decreasing subsequence count\\nFind the longest bitonic subsequence count such that it should make mountain only when both increasing and decreasing numbers exists."
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Product of the Length of Two Palindromic Subsequences",
        "question_content": "<p>Given a string <code>s</code>, find two <strong>disjoint palindromic subsequences</strong> of <code>s</code> such that the <strong>product</strong> of their lengths is <strong>maximized</strong>. The two subsequences are <strong>disjoint</strong> if they do not both pick a character at the same index.</p>\n\n<p>Return <em>the <strong>maximum</strong> possible <strong>product</strong> of the lengths of the two palindromic subsequences</em>.</p>\n\n<p>A <strong>subsequence</strong> is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. A string is <strong>palindromic</strong> if it reads the same forward and backward.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"example-1\" src=\"https://assets.leetcode.com/uploads/2021/08/24/two-palindromic-subsequences.png\" style=\"width: 550px; height: 124px;\" />\n<pre>\n<strong>Input:</strong> s = &quot;leetcodecom&quot;\n<strong>Output:</strong> 9\n<strong>Explanation</strong>: An optimal solution is to choose &quot;ete&quot; for the 1<sup>st</sup> subsequence and &quot;cdc&quot; for the 2<sup>nd</sup> subsequence.\nThe product of their lengths is: 3 * 3 = 9.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;bb&quot;\n<strong>Output:</strong> 1\n<strong>Explanation</strong>: An optimal solution is to choose &quot;b&quot; (the first character) for the 1<sup>st</sup> subsequence and &quot;b&quot; (the second character) for the 2<sup>nd</sup> subsequence.\nThe product of their lengths is: 1 * 1 = 1.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;accbcaxxcxx&quot;\n<strong>Output:</strong> 25\n<strong>Explanation</strong>: An optimal solution is to choose &quot;accca&quot; for the 1<sup>st</sup> subsequence and &quot;xxcxx&quot; for the 2<sup>nd</sup> subsequence.\nThe product of their lengths is: 5 * 5 = 25.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= s.length &lt;= 12</code></li>\n\t<li><code>s</code> consists of lowercase English letters only.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1458499,
                "title": "c-backtrack-c-users-please-pass-string-by-reference-to-pass",
                "content": "My YouTube Channel - https://www.youtube.com/@codestorywithMIK\\n```\\n/*\\nSimple explanation :\\nif you notice I am trying all three possibilities :-\\n\\n    1) I pick s[i] for s1 but don\\'t pick s[i] for s2 (because they should be disjoint)\\n       - I explore this path and find the result (and then backtrack)\\n\\n    2) I pick s[i] for s2 but don\\'t pick s[i] for s1 (because they should be disjoint)\\n        - I explore this path and find the result (and then backtrack)\\n\\n    3) I don\\'t pick s[i] at all - I explore this path and find the result\\n        (and then backtrack)\\n\\nIn any of the path, if I get s1 and s2 both as palindrome we update our\\nresult with maximum length. It\\'s like a classic Backtrack approach.\\n*/\\n```\\n```\\nclass Solution {\\npublic:\\n    int result = 0;\\n    bool isPalin(string& s){\\n        int i = 0;\\n        int j = s.length() - 1;\\n \\n        while (i < j) {\\n            if (s[i] != s[j]) return false;\\n            i++;\\n            j--;\\n        }\\n \\n        return true;\\n    }\\n    \\n    void dfs(string& s, int i, string& s1, string& s2){\\n        \\n        if(i >= s.length()){\\n            if(isPalin(s1) && isPalin(s2))\\n                result = max(result, (int)s1.length()*(int)s2.length());\\n            return;\\n        }\\n        \\n        s1.push_back(s[i]);\\n        dfs(s, i+1, s1, s2);\\n        s1.pop_back();\\n        \\n        s2.push_back(s[i]);\\n        dfs(s, i+1, s1, s2);\\n        s2.pop_back();\\n        \\n        dfs(s, i+1, s1, s2);\\n    }\\n    \\n    int maxProduct(string s) {\\n        string s1 = \"\", s2 = \"\";\\n        dfs(s, 0, s1, s2);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nSimple explanation :\\nif you notice I am trying all three possibilities :-\\n\\n    1) I pick s[i] for s1 but don\\'t pick s[i] for s2 (because they should be disjoint)\\n       - I explore this path and find the result (and then backtrack)\\n\\n    2) I pick s[i] for s2 but don\\'t pick s[i] for s1 (because they should be disjoint)\\n        - I explore this path and find the result (and then backtrack)\\n\\n    3) I don\\'t pick s[i] at all - I explore this path and find the result\\n        (and then backtrack)\\n\\nIn any of the path, if I get s1 and s2 both as palindrome we update our\\nresult with maximum length. It\\'s like a classic Backtrack approach.\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    int result = 0;\\n    bool isPalin(string& s){\\n        int i = 0;\\n        int j = s.length() - 1;\\n \\n        while (i < j) {\\n            if (s[i] != s[j]) return false;\\n            i++;\\n            j--;\\n        }\\n \\n        return true;\\n    }\\n    \\n    void dfs(string& s, int i, string& s1, string& s2){\\n        \\n        if(i >= s.length()){\\n            if(isPalin(s1) && isPalin(s2))\\n                result = max(result, (int)s1.length()*(int)s2.length());\\n            return;\\n        }\\n        \\n        s1.push_back(s[i]);\\n        dfs(s, i+1, s1, s2);\\n        s1.pop_back();\\n        \\n        s2.push_back(s[i]);\\n        dfs(s, i+1, s1, s2);\\n        s2.pop_back();\\n        \\n        dfs(s, i+1, s1, s2);\\n    }\\n    \\n    int maxProduct(string s) {\\n        string s1 = \"\", s2 = \"\";\\n        dfs(s, 0, s1, s2);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458289,
                "title": "mask-dp",
                "content": "We have `2^n` possible palindromes, and each of them can be represented by a mask `[1 ... 4096]` (since `n` is limited to `12`).\\n\\nFirst, we check if a mask represents a valid palindrome, and if so, store the length (or, number of `1` bits) in `dp`.\\n\\nThen, we check all non-zero masks `m1` against all non-intersecting masks `m2` (`m1 & m2 == 0`), and track the largest product.\\n\\n>Update1: as suggested by [Gowe](https://leetcode.com/Gowe/), we can use more efficient enumeration for `m2` to only go through \"available\" bits (`mask ^ m1`). This speeds up C++ runtime from 44 to 22 ms!\\n\\n> Update 2: we can do pruning to skip masks with no potential to surpass the current maximum. The runtime is now reduced to 4ms!\\n\\n> Update 3: an alternative solution (proposed by [LVL99](https://leetcode.com/LVL99/)) is to not check all submasks, but instead run \"Largest Palindromic Subsequence\" algo for all unused bits. This potentially can reduce checks from `2 ^ n` to `n ^ 2`. It\\'s a longer solution, so posted it as a comment.\\n\\n**C++**\\n```cpp\\nint palSize(string &s, int mask) {\\n    int p1 = 0, p2 = s.size(), res = 0;\\n    while (p1 <= p2) {\\n        if ((mask & (1 << p1)) == 0)\\n            ++p1;\\n        else if ((mask & (1 << p2)) == 0)\\n            --p2;\\n        else if (s[p1] != s[p2])\\n            return 0;\\n        else\\n            res += 1 + (p1++ != p2--);\\n    }\\n    return res;\\n}\\nint maxProduct(string s) {\\n    int dp[4096] = {}, res = 0, mask = (1 << s.size()) - 1;\\n    for (int m = 1; m <= mask; ++m)\\n        dp[m] = palSize(s, m);\\n    for (int m1 = mask; m1; --m1)\\n        if (dp[m1] * (s.size() - dp[m1]) > res)\\n            for(int m2 = mask ^ m1; m2; m2 = (m2 - 1) & (mask ^ m1))\\n                res = max(res, dp[m1] * dp[m2]);\\n    return res;\\n}\\n```\\n**Java**\\nJava version courtesy of [amoghtewari](https://leetcode.com/amoghtewari/).\\n```java\\npublic int maxProduct(String s) {\\n    int[] dp = new int[4096];\\n    int res = 0, mask = (1 << s.length()) - 1;\\n    for (int m = 1; m <= mask; ++m)\\n        dp[m] = palSize(s, m);\\n    for (int m1 = mask; m1 > 0; --m1)\\n        if (dp[m1] * (s.length() - dp[m1]) > res)\\n            for(int m2 = mask ^ m1; m2 > 0; m2 = (m2 - 1) & (mask ^ m1))\\n                res = Math.max(res, dp[m1] * dp[m2]);\\n    return res;\\n}\\nprivate int palSize(String s, int mask) {\\n    int p1 = 0, p2 = s.length(), res = 0;\\n    while (p1 <= p2) {\\n        if ((mask & (1 << p1)) == 0)\\n            ++p1;\\n        else if ((mask & (1 << p2)) == 0)\\n            --p2;\\n        else if (s.charAt(p1) != s.charAt(p2))\\n            return 0;\\n        else\\n            res += 1 + (p1++ != p2-- ? 1 : 0);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nint palSize(string &s, int mask) {\\n    int p1 = 0, p2 = s.size(), res = 0;\\n    while (p1 <= p2) {\\n        if ((mask & (1 << p1)) == 0)\\n            ++p1;\\n        else if ((mask & (1 << p2)) == 0)\\n            --p2;\\n        else if (s[p1] != s[p2])\\n            return 0;\\n        else\\n            res += 1 + (p1++ != p2--);\\n    }\\n    return res;\\n}\\nint maxProduct(string s) {\\n    int dp[4096] = {}, res = 0, mask = (1 << s.size()) - 1;\\n    for (int m = 1; m <= mask; ++m)\\n        dp[m] = palSize(s, m);\\n    for (int m1 = mask; m1; --m1)\\n        if (dp[m1] * (s.size() - dp[m1]) > res)\\n            for(int m2 = mask ^ m1; m2; m2 = (m2 - 1) & (mask ^ m1))\\n                res = max(res, dp[m1] * dp[m2]);\\n    return res;\\n}\\n```\n```java\\npublic int maxProduct(String s) {\\n    int[] dp = new int[4096];\\n    int res = 0, mask = (1 << s.length()) - 1;\\n    for (int m = 1; m <= mask; ++m)\\n        dp[m] = palSize(s, m);\\n    for (int m1 = mask; m1 > 0; --m1)\\n        if (dp[m1] * (s.length() - dp[m1]) > res)\\n            for(int m2 = mask ^ m1; m2 > 0; m2 = (m2 - 1) & (mask ^ m1))\\n                res = Math.max(res, dp[m1] * dp[m2]);\\n    return res;\\n}\\nprivate int palSize(String s, int mask) {\\n    int p1 = 0, p2 = s.length(), res = 0;\\n    while (p1 <= p2) {\\n        if ((mask & (1 << p1)) == 0)\\n            ++p1;\\n        else if ((mask & (1 << p2)) == 0)\\n            --p2;\\n        else if (s.charAt(p1) != s.charAt(p2))\\n            return 0;\\n        else\\n            res += 1 + (p1++ != p2-- ? 1 : 0);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1458329,
                "title": "java-simple-recursion",
                "content": "```\\nclass Solution {\\n    \\n    int max = 0;\\n    public int maxProduct(String s) {\\n        \\n        char[] c = s.toCharArray();\\n        dfs(c, 0, \"\", \"\");\\n        \\n        return max;\\n    }\\n    \\n    public void dfs(char[] c, int i, String s1, String s2){\\n        \\n        if(i >= c.length){\\n            \\n            if(isPalin(s1) && isPalin(s2))\\n                max = Math.max(max, s1.length()*s2.length());\\n            return;\\n        }\\n        \\n        dfs(c, i+1, s1+c[i], s2);\\n        dfs(c, i+1, s1, s2+c[i]);\\n        dfs(c, i+1, s1, s2);\\n    }\\n    \\n     public boolean isPalin(String str){\\n \\n        int i = 0, j = str.length() - 1;\\n \\n        while (i < j) {\\n \\n            if (str.charAt(i) != str.charAt(j))\\n                return false;\\n            i++;\\n            j--;\\n        }\\n \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int max = 0;\\n    public int maxProduct(String s) {\\n        \\n        char[] c = s.toCharArray();\\n        dfs(c, 0, \"\", \"\");\\n        \\n        return max;\\n    }\\n    \\n    public void dfs(char[] c, int i, String s1, String s2){\\n        \\n        if(i >= c.length){\\n            \\n            if(isPalin(s1) && isPalin(s2))\\n                max = Math.max(max, s1.length()*s2.length());\\n            return;\\n        }\\n        \\n        dfs(c, i+1, s1+c[i], s2);\\n        dfs(c, i+1, s1, s2+c[i]);\\n        dfs(c, i+1, s1, s2);\\n    }\\n    \\n     public boolean isPalin(String str){\\n \\n        int i = 0, j = str.length() - 1;\\n \\n        while (i < j) {\\n \\n            if (str.charAt(i) != str.charAt(j))\\n                return false;\\n            i++;\\n            j--;\\n        }\\n \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458544,
                "title": "python-clean-simple-bitmask",
                "content": "```python\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        # n <= 12, which means the search space is small\\n        n = len(s)\\n        arr = []\\n        \\n        for mask in range(1, 1<<n):\\n            subseq = \\'\\'\\n            for i in range(n):\\n                # convert the bitmask to the actual subsequence\\n                if mask & (1 << i) > 0:\\n                    subseq += s[i]\\n            if subseq == subseq[::-1]:\\n                arr.append((mask, len(subseq)))\\n        \\n        result = 1\\n        for (mask1, len1), (mask2, len2) in product(arr, arr):\\n            # disjoint\\n            if mask1 & mask2 == 0:\\n                result = max(result, len1 * len2)\\n        return result\\n```\\n\\nA slightly improved version, to break early when checking the results\\n\\n```python\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        # n <= 12, which means the search space is small\\n        n = len(s)\\n        arr = []\\n        \\n        for mask in range(1, 1<<n):\\n            subseq = \\'\\'\\n            for i in range(n):\\n                # convert the bitmask to the actual subsequence\\n                if mask & (1 << i) > 0:\\n                    subseq += s[i]\\n            if subseq == subseq[::-1]:\\n                arr.append((mask, len(subseq)))\\n        \\n        arr.sort(key=lambda x: x[1], reverse=True)\\n        result = 1\\n        for i in range(len(arr)):\\n            mask1, len1 = arr[i]\\n            # break early\\n            if len1 ** 2 < result: break\\n            for j in range(i+1, len(arr)):\\n                mask2, len2 = arr[j]\\n                # disjoint\\n                if mask1 & mask2 == 0 and len1 * len2 > result:\\n                    result = len1 * len2\\n                    break\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        # n <= 12, which means the search space is small\\n        n = len(s)\\n        arr = []\\n        \\n        for mask in range(1, 1<<n):\\n            subseq = \\'\\'\\n            for i in range(n):\\n                # convert the bitmask to the actual subsequence\\n                if mask & (1 << i) > 0:\\n                    subseq += s[i]\\n            if subseq == subseq[::-1]:\\n                arr.append((mask, len(subseq)))\\n        \\n        result = 1\\n        for (mask1, len1), (mask2, len2) in product(arr, arr):\\n            # disjoint\\n            if mask1 & mask2 == 0:\\n                result = max(result, len1 * len2)\\n        return result\\n```\n```python\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        # n <= 12, which means the search space is small\\n        n = len(s)\\n        arr = []\\n        \\n        for mask in range(1, 1<<n):\\n            subseq = \\'\\'\\n            for i in range(n):\\n                # convert the bitmask to the actual subsequence\\n                if mask & (1 << i) > 0:\\n                    subseq += s[i]\\n            if subseq == subseq[::-1]:\\n                arr.append((mask, len(subseq)))\\n        \\n        arr.sort(key=lambda x: x[1], reverse=True)\\n        result = 1\\n        for i in range(len(arr)):\\n            mask1, len1 = arr[i]\\n            # break early\\n            if len1 ** 2 < result: break\\n            for j in range(i+1, len(arr)):\\n                mask2, len2 = arr[j]\\n                # disjoint\\n                if mask1 & mask2 == 0 and len1 * len2 > result:\\n                    result = len1 * len2\\n                    break\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460601,
                "title": "c-backtracking-solution-explained-accepted",
                "content": "**APPROACH:**\\nBy seeing the constraints, it can be inferred that brute force approach should work fine.\\nTo make disjoint subsequence we\\'ll use 2 strings . Now, at everry character i in string we have 3 choices:\\n1) include that char in first string\\n2) include that char in second string\\n3) exclude that char from both strings\\n\\nto achieve this we\\'ll use **backtracking** to generate all disjoint subsequences.\\nNow of these subsequences , we consider only those which are pallindromic and leave the rest. For the pallindromic subsequence pair we calculate product eachtime and comapre with our ans calculated so far and update it if the latter product is greater.\\n\\n**NOTE :**\\nMany code got TLE in same approach, that is because we have to pass every string by reference instead of pass by value, as in pass by value a copy of original string is made which takes time. So , to reduce that time and make ourcode faster we use backtracking instead of recursion  + pass by value.\\n\\n**CODE:**\\nThe code is given below and is pretty much self explanatory.\\n\\n```\\nlong long ans = 0;\\n    \\n    bool isPal(string &s)\\n    {\\n        int start=0, end = s.length()-1;\\n        while(start < end)\\n        {\\n            if(s[start] != s[end]) return false;\\n            start++; end--;\\n        }\\n        return true;\\n    }\\n    \\n    void recur(string &s,int idx,string &s1,string &s2)\\n    {\\n        if(idx == s.size())\\n        {\\n            if(isPal(s1) and isPal(s2))\\n            {\\n                long long val =(int) s1.length() * s2.length();\\n                ans = max(ans , val);\\n            }\\n            return;\\n        }\\n        \\n        s1.push_back(s[idx]);\\n        recur(s,idx+1,s1, s2);\\n        s1.pop_back();\\n        \\n        s2.push_back(s[idx]);\\n        recur(s,idx+1,s1,s2);\\n        s2.pop_back();\\n        \\n        recur(s,idx+1,s1,s2);\\n    }\\n\\t\\n\\tint maxProduct(string s) {\\n        string s1=\"\", s2 = \"\";\\n        recur(s,0,s1,s2);\\n        return ans;\\n    }\\n```\\n\\nDo upvote if it heps :)",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nlong long ans = 0;\\n    \\n    bool isPal(string &s)\\n    {\\n        int start=0, end = s.length()-1;\\n        while(start < end)\\n        {\\n            if(s[start] != s[end]) return false;\\n            start++; end--;\\n        }\\n        return true;\\n    }\\n    \\n    void recur(string &s,int idx,string &s1,string &s2)\\n    {\\n        if(idx == s.size())\\n        {\\n            if(isPal(s1) and isPal(s2))\\n            {\\n                long long val =(int) s1.length() * s2.length();\\n                ans = max(ans , val);\\n            }\\n            return;\\n        }\\n        \\n        s1.push_back(s[idx]);\\n        recur(s,idx+1,s1, s2);\\n        s1.pop_back();\\n        \\n        s2.push_back(s[idx]);\\n        recur(s,idx+1,s1,s2);\\n        s2.pop_back();\\n        \\n        recur(s,idx+1,s1,s2);\\n    }\\n\\t\\n\\tint maxProduct(string s) {\\n        string s1=\"\", s2 = \"\";\\n        recur(s,0,s1,s2);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1459193,
                "title": "python-true-o-2-n-dp-on-subsets-solution-explained",
                "content": "I saw several `dp` solution, which states that they have `O(2^n)` complexity, but they use bit manipulations, such as looking for first and last significant bit, which we can not say is truly `O(1)`. So I decided to write my own **true** `O(2^n)` solution.\\n\\nLet `dp(mask)` be the maximum length of palindrome if we allowed to use only non-zero bits from `mask`. In fact, this means, if we have `s = leetcode` and `mask = 01011001`, we can use only `etce` subsequence. How to evaluate `dp(mask)`?\\n\\n1. First option is we do not take last significant one, that is we work here with `01011000` and ask what is answer for this mask.\\n2. Second option is we do not take first significant bit, that is we work here with `00011001` mask here.\\n3. Final option is to take both first and last significant bits but it is allowed only if we have equal elements for them, that is we have mase `00011000` here and because `s[1] = s[7]` we can take this option.\\n\\nAlso what I calclate all first and last significant bits for all numbers in range `1, 1<<n`.\\n\\n#### Complexity\\nTime complexity is `O(2^n)`, space complexity also `O(2^n)` to keep `dp` cache and `last` and `first` arrays.\\n\\n```python\\nclass Solution:\\n    def maxProduct(self, s):\\n        n = len(s)\\n        \\n        first, last = [0]*(1<<n), [0]*(1<<n)\\n        \\n        for i in range(n):\\n            for j in range(1<<i, 1<<(i+1)):\\n                first[j] = i\\n\\n        for i in range(n):\\n            for j in range(1<<i, 1<<n, 1<<(i+1)):\\n                last[j] = i\\n        \\n        @lru_cache(None)\\n        def dp(m):\\n            if m & (m-1) == 0: return m != 0\\n            l, f = last[m], first[m]\\n            lb, fb = 1<<l, 1<<f\\n            return max(dp(m-lb), dp(m-fb), dp(m-lb-fb) + (s[l] == s[f]) * 2)\\n       \\n        ans = 0\\n        for m in range(1, 1<<n):\\n            ans = max(ans, dp(m)*dp((1<<n) - 1 - m))\\n            \\n        return ans\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def maxProduct(self, s):\\n        n = len(s)\\n        \\n        first, last = [0]*(1<<n), [0]*(1<<n)\\n        \\n        for i in range(n):\\n            for j in range(1<<i, 1<<(i+1)):\\n                first[j] = i\\n\\n        for i in range(n):\\n            for j in range(1<<i, 1<<n, 1<<(i+1)):\\n                last[j] = i\\n        \\n        @lru_cache(None)\\n        def dp(m):\\n            if m & (m-1) == 0: return m != 0\\n            l, f = last[m], first[m]\\n            lb, fb = 1<<l, 1<<f\\n            return max(dp(m-lb), dp(m-fb), dp(m-lb-fb) + (s[l] == s[f]) * 2)\\n       \\n        ans = 0\\n        for m in range(1, 1<<n):\\n            ans = max(ans, dp(m)*dp((1<<n) - 1 - m))\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458418,
                "title": "c-solution-lcs",
                "content": "[https://leetcode.com/problems/longest-palindromic-subsequence/](http://)\\n```\\nclass Solution {\\npublic:\\n    int lps(string &s)\\n    {\\n        int n=s.size();\\n        string s1=s;\\n        string s2=s;\\n        reverse(s2.begin(),s2.end());\\n        int dp[s.size()+1][s.size()+1];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                dp[i][j]=(s1[i-1]==s2[j-1])?1+dp[i-1][j-1]:max(dp[i][j-1],dp[i-1][j]);\\n            }\\n        }\\n        return dp[n][n];\\n    }\\n    int maxProduct(string s) \\n    {\\n        int ans=0;\\n        int n=s.size();\\n        for(int i=1;i<(1<<n)-1;i++)\\n        {\\n            string s1=\"\",s2=\"\";\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    s1.push_back(s[j]);\\n                }\\n                else\\n                {\\n                    s2.push_back(s[j]);\\n                }\\n            }\\n            ans=max(ans,lps(s1)*lps(s2));\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lps(string &s)\\n    {\\n        int n=s.size();\\n        string s1=s;\\n        string s2=s;\\n        reverse(s2.begin(),s2.end());\\n        int dp[s.size()+1][s.size()+1];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                dp[i][j]=(s1[i-1]==s2[j-1])?1+dp[i-1][j-1]:max(dp[i][j-1],dp[i-1][j]);\\n            }\\n        }\\n        return dp[n][n];\\n    }\\n    int maxProduct(string s) \\n    {\\n        int ans=0;\\n        int n=s.size();\\n        for(int i=1;i<(1<<n)-1;i++)\\n        {\\n            string s1=\"\",s2=\"\";\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    s1.push_back(s[j]);\\n                }\\n                else\\n                {\\n                    s2.push_back(s[j]);\\n                }\\n            }\\n            ans=max(ans,lps(s1)*lps(s2));\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458602,
                "title": "java-backtracking-solution",
                "content": "```\\nclass Solution {\\n    public int maxProduct(String s) {\\n        return dfs(s.toCharArray(),\"\",\"\",0,0);\\n    }\\n    \\n    public int dfs(char[] arr,String s,String p,int pos,int max){\\n        if(pos == arr.length){\\n            if(isValid(s) && isValid(p))max = Math.max(max,s.length() * p.length());\\n            return max;\\n        }\\n        return Math.max(dfs(arr,s + arr[pos],p,pos + 1,max),Math.max(dfs(arr,s,p + arr[pos],pos+1,max),dfs(arr,s,p,pos+1,max)));\\n    }\\n    \\n    public boolean isValid(String s){\\n        int i = 0,j = s.length()-1;\\n        while(i < j)if(s.charAt(i++) != s.charAt(j--))return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(String s) {\\n        return dfs(s.toCharArray(),\"\",\"\",0,0);\\n    }\\n    \\n    public int dfs(char[] arr,String s,String p,int pos,int max){\\n        if(pos == arr.length){\\n            if(isValid(s) && isValid(p))max = Math.max(max,s.length() * p.length());\\n            return max;\\n        }\\n        return Math.max(dfs(arr,s + arr[pos],p,pos + 1,max),Math.max(dfs(arr,s,p + arr[pos],pos+1,max),dfs(arr,s,p,pos+1,max)));\\n    }\\n    \\n    public boolean isValid(String s){\\n        int i = 0,j = s.length()-1;\\n        while(i < j)if(s.charAt(i++) != s.charAt(j--))return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458402,
                "title": "python-bitmask",
                "content": "```\\ndef maxProduct(self, s: str) -> int:\\n        mem = {}\\n        n = len(s)\\n        for i in range(1,1<<n):\\n            tmp = \"\"\\n            for j in range(n):\\n                if i>>j & 1 == 1:\\n                    tmp += s[j]\\n            if tmp == tmp[::-1]:\\n                mem[i] = len(tmp)\\n        res = 0\\n        for i,x in mem.items():\\n            for j,y in mem.items():\\n                if i&j == 0:\\n                    res = max(res,x*y)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxProduct(self, s: str) -> int:\\n        mem = {}\\n        n = len(s)\\n        for i in range(1,1<<n):\\n            tmp = \"\"\\n            for j in range(n):\\n                if i>>j & 1 == 1:\\n                    tmp += s[j]\\n            if tmp == tmp[::-1]:\\n                mem[i] = len(tmp)\\n        res = 0\\n        for i,x in mem.items():\\n            for j,y in mem.items():\\n                if i&j == 0:\\n                    res = max(res,x*y)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3392433,
                "title": "easy-understand-simple-method-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse mask to save all combination in hashmap and use \"&\" bit manipulation to check if two mask have repeated letter.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O((2^n)^2)$ => $O(4^n)$ \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe worst case is need save every combination, for example the string of length 12 that only contains one kind of letter.\\n$O(2^n)$\\n\\n# Code\\nMathod using bit mask\\n``` java []\\nclass Solution {\\n    public int maxProduct(String s) {\\n        char[] strArr = s.toCharArray();\\n        int n = strArr.length;\\n        Map<Integer, Integer> pali = new HashMap<>();\\n        // save all elligible combination into hashmap\\n        for (int mask = 0; mask < 1<<n; mask++){\\n            String subseq = \"\";\\n            for (int i = 0; i < 12; i++){\\n                if ((mask & 1<<i) > 0)\\n                    subseq += strArr[i];\\n            }\\n            if (isPalindromic(subseq))\\n                pali.put(mask, subseq.length());\\n        }\\n        // use & opertion between any two combination\\n        int res = 0;\\n        for (int mask1 : pali.keySet()){\\n            for (int mask2 : pali.keySet()){\\n                if ((mask1 & mask2) == 0)\\n                    res = Math.max(res, pali.get(mask1)*pali.get(mask2));\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    public boolean isPalindromic(String str){\\n        int j = str.length() - 1;\\n        char[] strArr = str.toCharArray();\\n        for (int i = 0; i < j; i ++){\\n            if (strArr[i] != strArr[j])\\n                return false;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```\\n``` python3 []\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        n, pali = len(s), {} # bitmask : length\\n        for mask in range(1, 1 << n):\\n            subseq = \"\"\\n            for i in range(n):\\n                if mask & (1 << i):\\n                    subseq += s[i]\\n            if subseq == subseq[::-1]: # valid is palindromic\\n                pali[mask] = len(subseq)\\n        res = 0\\n        for mask1, length1 in pali.items():\\n            for mask2, length2 in pali.items():\\n                if mask1 & mask2 == 0: \\n                    res = max(res, length1 * length2)\\n        return res\\n```\\n\\nThere is another method using recursion\\n``` java []\\nclass Solution {\\n    int res = 0;\\n    \\n    public int maxProduct(String s) {\\n        char[] strArr = s.toCharArray();\\n        dfs(strArr, 0, \"\", \"\");\\n        return res;\\n    }\\n\\n    public void dfs(char[] strArr, int i, String s1, String s2){\\n        if(i >= strArr.length){\\n            if(isPalindromic(s1) && isPalindromic(s2))\\n                res = Math.max(res, s1.length()*s2.length());\\n            return;\\n        }\\n        dfs(strArr, i+1, s1 + strArr[i], s2);\\n        dfs(strArr, i+1, s1, s2 + strArr[i]);\\n        dfs(strArr, i+1, s1, s2);\\n    }\\n\\n    public boolean isPalindromic(String str){\\n        int j = str.length() - 1;\\n        char[] strArr = str.toCharArray();\\n        for (int i = 0; i < j; i ++){\\n            if (strArr[i] != strArr[j])\\n                return false;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n**Please upvate if helpful!!**\\n\\n![image.png](https://assets.leetcode.com/users/images/4cfe106c-39c2-421d-90ca-53a7797ed7b5_1680845537.3804016.png)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int maxProduct(String s) {\\n        char[] strArr = s.toCharArray();\\n        int n = strArr.length;\\n        Map<Integer, Integer> pali = new HashMap<>();\\n        // save all elligible combination into hashmap\\n        for (int mask = 0; mask < 1<<n; mask++){\\n            String subseq = \"\";\\n            for (int i = 0; i < 12; i++){\\n                if ((mask & 1<<i) > 0)\\n                    subseq += strArr[i];\\n            }\\n            if (isPalindromic(subseq))\\n                pali.put(mask, subseq.length());\\n        }\\n        // use & opertion between any two combination\\n        int res = 0;\\n        for (int mask1 : pali.keySet()){\\n            for (int mask2 : pali.keySet()){\\n                if ((mask1 & mask2) == 0)\\n                    res = Math.max(res, pali.get(mask1)*pali.get(mask2));\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    public boolean isPalindromic(String str){\\n        int j = str.length() - 1;\\n        char[] strArr = str.toCharArray();\\n        for (int i = 0; i < j; i ++){\\n            if (strArr[i] != strArr[j])\\n                return false;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```\n``` python3 []\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        n, pali = len(s), {} # bitmask : length\\n        for mask in range(1, 1 << n):\\n            subseq = \"\"\\n            for i in range(n):\\n                if mask & (1 << i):\\n                    subseq += s[i]\\n            if subseq == subseq[::-1]: # valid is palindromic\\n                pali[mask] = len(subseq)\\n        res = 0\\n        for mask1, length1 in pali.items():\\n            for mask2, length2 in pali.items():\\n                if mask1 & mask2 == 0: \\n                    res = max(res, length1 * length2)\\n        return res\\n```\n``` java []\\nclass Solution {\\n    int res = 0;\\n    \\n    public int maxProduct(String s) {\\n        char[] strArr = s.toCharArray();\\n        dfs(strArr, 0, \"\", \"\");\\n        return res;\\n    }\\n\\n    public void dfs(char[] strArr, int i, String s1, String s2){\\n        if(i >= strArr.length){\\n            if(isPalindromic(s1) && isPalindromic(s2))\\n                res = Math.max(res, s1.length()*s2.length());\\n            return;\\n        }\\n        dfs(strArr, i+1, s1 + strArr[i], s2);\\n        dfs(strArr, i+1, s1, s2 + strArr[i]);\\n        dfs(strArr, i+1, s1, s2);\\n    }\\n\\n    public boolean isPalindromic(String str){\\n        int j = str.length() - 1;\\n        char[] strArr = str.toCharArray();\\n        for (int i = 0; i < j; i ++){\\n            if (strArr[i] != strArr[j])\\n                return false;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1459216,
                "title": "c-backtracking-solution-intuition-explained",
                "content": "**Intuition:**\\n\\nIdea is to form all combinations of subsequences that are palindromic, that are not overlapping i.e *first* string and *second* string should not have any common element from main string. Out of all possible *first* and *second* strings, we find product of `first.size() * second.size()` . In the end we return the maximum product. \\n\\nNext, looking at the size of given string i.e `1 <= n <= 12`. We can do a brute force over it and use **Backtracking** to get all possible combinations of *first* and *second* string that are subsequences of original string. \\n\\nNow, lets see how can we form *first* and *second* string? Think of possible choices at every index of the original string. What can we pick and what we can skip. Since, we are given that both the palindromic should not have any common element (non-overlapping and disjoint). Thus, we cannot include current element in both strings simultaneously.\\n\\nSo, we have actually 3 choices at every index.\\n1. Exclude the current element from both *first* and *second* string. \\n\\n2. Include the current element into *first* string  -> Backtracking, **include -> use -> remove**\\n\\n3. Include the current element into *second* string.  -> Backtracking, **include -> use -> remove**\\n\\n**Base Condition :** : When we reach the end of string, check if first and second string are palindrome or not. \\n* If not then return \\n* Else calculate the product of lengths `first.size() * second.size()` and update maximumProduct accordingly\\n \\nGo through the code, it is self explainatory and easy to understand. Just simple backtracking logic, nothing complex. \\n\\nNote: We are passing first and second strings by **reference**, so that in every function call new copies of string is not created. If we do not consider this, it will give a TLE. \\n\\n# Code : \\n```\\nint maxProd = 1, n;\\n    bool isPalindrome(const string& s)\\n    {\\n        int n = s.size();\\n        for(int i=0; i<n/2; i++)\\n            if(s[i] != s[n-1-i]) return false;\\n        return true;\\n    }\\n    \\n    void solve(string& s, string& first, string& second, int idx)\\n    {\\n        if(idx == n) \\n        {\\n\\t\\t\\t// Check if both strings are palindrome or not\\n\\t\\t\\t// If yes, then find product or their lengths\\n            if(isPalindrome(first) && isPalindrome(second))         \\n            {\\n                maxProd = max(maxProd, (int)(first.size() * second.size()));\\n            }\\n            return;\\n        }\\n        \\n        // Choice 1 : Exclude current element from both strings\\n        solve(s, first, second, idx+1);\\n        \\n        // Choice 2 : Include current element into first string\\n        first.push_back(s[idx]);\\n        solve(s, first, second, idx+1);\\n        first.pop_back();\\n        \\n        // Choice 3 : Include current element into second string\\n        second.push_back(s[idx]);\\n        solve(s, first, second, idx+1);\\n        second.pop_back();\\n    }\\n    \\n    int maxProduct(string s) {\\n        n = s.size();\\n        string first = \"\", second = \"\";\\n        solve(s, first, second, 0);                              // Start from 0th index\\n        return maxProd;\\n    }\\n```\\n\\n**Time : O(n * 3^n)** \\n* In each recursive call we have 3 choices so total **O(3^n)**\\n* and **O(n)** to check if both strings are palindrome or not \\n\\n***If you find this solution helpful, do give it an upvote :)***",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nint maxProd = 1, n;\\n    bool isPalindrome(const string& s)\\n    {\\n        int n = s.size();\\n        for(int i=0; i<n/2; i++)\\n            if(s[i] != s[n-1-i]) return false;\\n        return true;\\n    }\\n    \\n    void solve(string& s, string& first, string& second, int idx)\\n    {\\n        if(idx == n) \\n        {\\n\\t\\t\\t// Check if both strings are palindrome or not\\n\\t\\t\\t// If yes, then find product or their lengths\\n            if(isPalindrome(first) && isPalindrome(second))         \\n            {\\n                maxProd = max(maxProd, (int)(first.size() * second.size()));\\n            }\\n            return;\\n        }\\n        \\n        // Choice 1 : Exclude current element from both strings\\n        solve(s, first, second, idx+1);\\n        \\n        // Choice 2 : Include current element into first string\\n        first.push_back(s[idx]);\\n        solve(s, first, second, idx+1);\\n        first.pop_back();\\n        \\n        // Choice 3 : Include current element into second string\\n        second.push_back(s[idx]);\\n        solve(s, first, second, idx+1);\\n        second.pop_back();\\n    }\\n    \\n    int maxProduct(string s) {\\n        n = s.size();\\n        string first = \"\", second = \"\";\\n        solve(s, first, second, 0);                              // Start from 0th index\\n        return maxProd;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1458411,
                "title": "bit-masking",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProduct(string s) {\\n        int n = s.length();\\n        int p = pow(2,n);\\n        vector<pair<int,int> > vec;\\n        for(int i = 1;i < p;i++){\\n            int a = isPalindrome(s,i);\\n            if(a != -1)\\n            vec.push_back({i,a});   \\n        }\\n        int ans = 1;\\n        for(int i = 0;i < vec.size();i++)\\n        for(int j = i+1;j < vec.size();j++)\\n        if((vec[i].first & vec[j].first) == 0)\\n        ans = max(ans,vec[i].second * vec[j].second); \\n        return ans;\\n        \\n    }\\n  int isPalindrome(string& s,int p){\\n      vector<int> vec;\\n      for(int i = 0;i < s.length();i++)\\n      if(p & (1<<i))\\n      vec.push_back(i);   \\n      int index = vec.size()-1;\\n      for(int i = 0;i <= index;i++,index--)\\n      if(s[vec[i]] != s[vec[index]])\\n      return -1;\\n      return vec.size();\\n   }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(string s) {\\n        int n = s.length();\\n        int p = pow(2,n);\\n        vector<pair<int,int> > vec;\\n        for(int i = 1;i < p;i++){\\n            int a = isPalindrome(s,i);\\n            if(a != -1)\\n            vec.push_back({i,a});   \\n        }\\n        int ans = 1;\\n        for(int i = 0;i < vec.size();i++)\\n        for(int j = i+1;j < vec.size();j++)\\n        if((vec[i].first & vec[j].first) == 0)\\n        ans = max(ans,vec[i].second * vec[j].second); \\n        return ans;\\n        \\n    }\\n  int isPalindrome(string& s,int p){\\n      vector<int> vec;\\n      for(int i = 0;i < s.length();i++)\\n      if(p & (1<<i))\\n      vec.push_back(i);   \\n      int index = vec.size()-1;\\n      for(int i = 0;i <= index;i++,index--)\\n      if(s[vec[i]] != s[vec[index]])\\n      return -1;\\n      return vec.size();\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458788,
                "title": "c-dp-from-o-3-n-to-o-2-n",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Bitmask DP\\n\\nLet `dp[mask]` be the length of the longest palindromic subsequence within the subsequence represented by `mask`.\\n\\nThe answer is `max( dp[m] * dp[(1 << N) - 1 - m] | 1 <= m < 1 << N )`. (`(1 << N) - 1 - m)` is the complement subset of `m`.\\n\\nFor `dp[m]`, we can brute-forcely enumerate each of its subset, and compute the maximum length of its palindromic subsets.\\n\\n```\\ndp[m] = max( bitcount( sub ) | `sub` is a subset of `m`, and `sub` forms a palindrome )\\n```\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/\\n// Author: github.com/lzl124631x\\n// Time: O(N * 2^N + 3^N)\\n// Space: O(2^N)\\nclass Solution {\\n    bool isPalindrome(string &s, int mask) {\\n        vector<int> index;\\n        for (int i = 0; mask; mask >>= 1, ++i) {\\n            if (mask & 1) index.push_back(i);\\n        }\\n        for (int i = 0, j = index.size() - 1; i < j; ++i, --j) {\\n            if (s[index[i]] != s[index[j]]) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int maxProduct(string s) {\\n        int N = s.size();\\n        vector<int> dp(1 << N), pal(1 << N);\\n        for (int m = 1; m < 1 << N; ++m) {\\n            pal[m] = isPalindrome(s, m);\\n        }\\n        for (int m = 1; m < 1 << N; ++m) { // `m` is a subset of all the characters\\n            for (int sub = m; sub; sub = (sub - 1) & m) { // `sub` is a subset of `m`\\n                if (pal[sub]) dp[m] = max(dp[m], __builtin_popcount(sub)); // if this subset forms a palindrome, update the maximum length\\n            }\\n        }\\n        int ans = 0;\\n        for (int m = 1; m < 1 << N; ++m) {\\n            ans = max(ans, dp[m] * dp[(1 << N) - 1 - m]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 2. Bitmask DP\\n\\nIn Solution 1, filling the `pal` array takes `O(N * 2^N)` time. We can reduce the time to `O(2^N)` using DP.\\n\\n```\\npal[m] = s[lb] == s[hb] && pal[x]\\n         where `lb` and `hb` are the indexes of the lowest and highest bits of `m`, respectively,\\n            and `x` equals `m` removing the lowest and highest bits.\\n```\\n\\n```cpp\\nvector<bool> pal(1 << N);\\npal[0] = 1;\\nfor (int m = 1; m < 1 << N; ++m) {\\n    int lb = __builtin_ctz(m & -m), hb = 31 - __builtin_clz(m); \\n    pal[m] = s[lb] == s[hb] && pal[m & ~(1 << lb) & ~(1 << hb)];\\n}\\n```\\n\\nUsing the same DP idea, we can reduce the time complexity for filling the `dp` array from `O(3^N)` to `O(2^N)`, and we don\\'t even need the `pal` array.\\n\\n```\\n// if `m` is only a single bit 1\\ndp[m] = 1 \\n\\n// otherwise\\ndp[m] = max( \\n                dp[m - (1 << lb)], // if we exclude `s[lb]`\\n                dp[m - (1 << hb)], // if we exclude `s[hb]`\\n                dp[m - (1 << lb) - (1 << hb)] + (s[lb] == s[hb] ? 2 : 0) // If we exclude both `s[lb]` and `s[hb]` and plus 2 if `s[lb] == s[hb]`\\n            )\\n```\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/\\n// Author: github.com/lzl124631x\\n// Time: O(2^N)\\n// Space: O(2^N)\\nclass Solution {\\npublic:\\n    int maxProduct(string s) {\\n        int N = s.size();\\n        vector<int> dp(1 << N);\\n        for (int m = 1; m < 1 << N; ++m) {\\n            if (__builtin_popcount(m) == 1) dp[m] = 1; \\n            else {\\n                int lb = __builtin_ctz(m & -m), hb = 31 - __builtin_clz(m);\\n                dp[m] = max({ dp[m - (1 << lb)], dp[m - (1 << hb)], dp[m - (1 << lb) - (1 << hb)] + (s[lb] == s[hb] ? 2 : 0) });\\n            }\\n        }\\n        int ans = 0;\\n        for (int m = 1; m < 1 << N; ++m) {\\n            ans = max(ans, dp[m] * dp[(1 << N) - 1 - m]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndp[m] = max( bitcount( sub ) | `sub` is a subset of `m`, and `sub` forms a palindrome )\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/\\n// Author: github.com/lzl124631x\\n// Time: O(N * 2^N + 3^N)\\n// Space: O(2^N)\\nclass Solution {\\n    bool isPalindrome(string &s, int mask) {\\n        vector<int> index;\\n        for (int i = 0; mask; mask >>= 1, ++i) {\\n            if (mask & 1) index.push_back(i);\\n        }\\n        for (int i = 0, j = index.size() - 1; i < j; ++i, --j) {\\n            if (s[index[i]] != s[index[j]]) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int maxProduct(string s) {\\n        int N = s.size();\\n        vector<int> dp(1 << N), pal(1 << N);\\n        for (int m = 1; m < 1 << N; ++m) {\\n            pal[m] = isPalindrome(s, m);\\n        }\\n        for (int m = 1; m < 1 << N; ++m) { // `m` is a subset of all the characters\\n            for (int sub = m; sub; sub = (sub - 1) & m) { // `sub` is a subset of `m`\\n                if (pal[sub]) dp[m] = max(dp[m], __builtin_popcount(sub)); // if this subset forms a palindrome, update the maximum length\\n            }\\n        }\\n        int ans = 0;\\n        for (int m = 1; m < 1 << N; ++m) {\\n            ans = max(ans, dp[m] * dp[(1 << N) - 1 - m]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\npal[m] = s[lb] == s[hb] && pal[x]\\n         where `lb` and `hb` are the indexes of the lowest and highest bits of `m`, respectively,\\n            and `x` equals `m` removing the lowest and highest bits.\\n```\n```cpp\\nvector<bool> pal(1 << N);\\npal[0] = 1;\\nfor (int m = 1; m < 1 << N; ++m) {\\n    int lb = __builtin_ctz(m & -m), hb = 31 - __builtin_clz(m); \\n    pal[m] = s[lb] == s[hb] && pal[m & ~(1 << lb) & ~(1 << hb)];\\n}\\n```\n```\\n// if `m` is only a single bit 1\\ndp[m] = 1 \\n\\n// otherwise\\ndp[m] = max( \\n                dp[m - (1 << lb)], // if we exclude `s[lb]`\\n                dp[m - (1 << hb)], // if we exclude `s[hb]`\\n                dp[m - (1 << lb) - (1 << hb)] + (s[lb] == s[hb] ? 2 : 0) // If we exclude both `s[lb]` and `s[hb]` and plus 2 if `s[lb] == s[hb]`\\n            )\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/\\n// Author: github.com/lzl124631x\\n// Time: O(2^N)\\n// Space: O(2^N)\\nclass Solution {\\npublic:\\n    int maxProduct(string s) {\\n        int N = s.size();\\n        vector<int> dp(1 << N);\\n        for (int m = 1; m < 1 << N; ++m) {\\n            if (__builtin_popcount(m) == 1) dp[m] = 1; \\n            else {\\n                int lb = __builtin_ctz(m & -m), hb = 31 - __builtin_clz(m);\\n                dp[m] = max({ dp[m - (1 << lb)], dp[m - (1 << hb)], dp[m - (1 << lb) - (1 << hb)] + (s[lb] == s[hb] ? 2 : 0) });\\n            }\\n        }\\n        int ans = 0;\\n        for (int m = 1; m < 1 << N; ++m) {\\n            ans = max(ans, dp[m] * dp[(1 << N) - 1 - m]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458726,
                "title": "c-backtrack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    bool ispal(string &n){\\n        int i=0,j=n.length()-1;\\n        while(i<j){\\n            if(n[i]!=n[j]){\\n                return false;\\n            }\\n            i++,j--;\\n        }\\n        return true;\\n    }\\n   \\n    void temp(string &ori,int i,string a,string b){\\n        if(i==ori.length()){\\n            if(ispal(a) && ispal(b)){\\n                ans = max(ans,(int)(a.length()*b.length()));\\n            }\\n            return;\\n        }\\n        \\n        temp(ori,i+1,a+ori[i],b);\\n        temp(ori,i+1,a,b+ori[i]);\\n        temp(ori,i+1,a,b);\\n        \\n        \\n    }\\n    \\n    int maxProduct(string s) {\\n        temp(s,0,\"\",\"\");\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    bool ispal(string &n){\\n        int i=0,j=n.length()-1;\\n        while(i<j){\\n            if(n[i]!=n[j]){\\n                return false;\\n            }\\n            i++,j--;\\n        }\\n        return true;\\n    }\\n   \\n    void temp(string &ori,int i,string a,string b){\\n        if(i==ori.length()){\\n            if(ispal(a) && ispal(b)){\\n                ans = max(ans,(int)(a.length()*b.length()));\\n            }\\n            return;\\n        }\\n        \\n        temp(ori,i+1,a+ori[i],b);\\n        temp(ori,i+1,a,b+ori[i]);\\n        temp(ori,i+1,a,b);\\n        \\n        \\n    }\\n    \\n    int maxProduct(string s) {\\n        temp(s,0,\"\",\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458356,
                "title": "15-lines-of-code-easy-brutal-force-java-solution-o-3-12-12-backtrack-solution",
                "content": "As long as I see the constraint is 0<len<12, I try to use brutal force which is backtrack.\\nSo each position char can be either:\\n1) pick by s1\\n2) pick by s2\\n3) pick by nobody.\\n```\\nclass Solution {\\n    int max = 0;\\n    public int maxProduct(String s) {\\n        backtrack(s,0,\"\",\"\");\\n        return max;\\n    }\\n    \\n    private void backtrack(String s, int i,String s1, String s2){\\n        if(i == s.length()){\\n            if(isValid(s1) && isValid(s2)){\\n                max = Math.max(max, s1.length()*s2.length());\\n            }\\n            return;\\n        }\\n        backtrack(s,i+1,s1,s2);\\n        backtrack(s,i+1,s1+s.charAt(i),s2);\\n        backtrack(s,i+1,s1,s2+s.charAt(i));\\n    }\\n    private boolean isValid(String s){\\n        if(s == null) return false;\\n        for(int i = 0,j=s.length() - 1;i<j;i++,j--){\\n            if(s.charAt(i) != s.charAt(j)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n    public int maxProduct(String s) {\\n        backtrack(s,0,\"\",\"\");\\n        return max;\\n    }\\n    \\n    private void backtrack(String s, int i,String s1, String s2){\\n        if(i == s.length()){\\n            if(isValid(s1) && isValid(s2)){\\n                max = Math.max(max, s1.length()*s2.length());\\n            }\\n            return;\\n        }\\n        backtrack(s,i+1,s1,s2);\\n        backtrack(s,i+1,s1+s.charAt(i),s2);\\n        backtrack(s,i+1,s1,s2+s.charAt(i));\\n    }\\n    private boolean isValid(String s){\\n        if(s == null) return false;\\n        for(int i = 0,j=s.length() - 1;i<j;i++,j--){\\n            if(s.charAt(i) != s.charAt(j)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458751,
                "title": "python-dfs-solution",
                "content": "We have 3 possibilities i.e, \\n1) not considering the current char for either subsequence \\n2) considering it for first one \\n3) considering it for second subsequence\\n[Follow here](https://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/discuss/1458482/PYTHON-Simple-solution-backtracking)\\n```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        self.res = 0\\n        def isPalindrome(word):\\n            l, r = 0, len(word)-1\\n            while l < r:\\n                if word[l] != word[r]:\\n                    return False\\n                l += 1; r -= 1\\n            return True\\n        \\n        @functools.lru_cache(None)\\n        def dfs(i, word1, word2):\\n            if i >= len(s):\\n                if isPalindrome(word1) and isPalindrome(word2):\\n                    self.res = max(self.res, len(word1) * len(word2))\\n                return\\n            \\n\\t\\t\\tdfs(i + 1, word1, word2)             # 1st case \\n            dfs(i + 1, word1 + s[i], word2)    # 2nd case\\n            dfs(i + 1, word1, word2 + s[i])    # 3rd case\\n            \\n        dfs(0, \\'\\', \\'\\')\\n\\t\\t\\n        return self.res\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        self.res = 0\\n        def isPalindrome(word):\\n            l, r = 0, len(word)-1\\n            while l < r:\\n                if word[l] != word[r]:\\n                    return False\\n                l += 1; r -= 1\\n            return True\\n        \\n        @functools.lru_cache(None)\\n        def dfs(i, word1, word2):\\n            if i >= len(s):\\n                if isPalindrome(word1) and isPalindrome(word2):\\n                    self.res = max(self.res, len(word1) * len(word2))\\n                return\\n            \\n\\t\\t\\tdfs(i + 1, word1, word2)             # 1st case \\n            dfs(i + 1, word1 + s[i], word2)    # 2nd case\\n            dfs(i + 1, word1, word2 + s[i])    # 3rd case\\n            \\n        dfs(0, \\'\\', \\'\\')\\n\\t\\t\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458552,
                "title": "c-simple-solution-using-backtracking",
                "content": "\\n**2 Cases at each pos**, \\n1.  Not Pick that char in any string\\n2.  Pick that char, here 2 sub cases\\n\\ta. Pick in 1st String\\n\\tb. Pick in 2nd String\\n```\\nbool isPalin(string &s) {\\n\\tint i = 0, j = s.length() - 1;\\n\\twhile(i < j) {\\n\\t\\tif(s[i] != s[j]) return false;\\n\\t\\ti++;\\n\\t\\tj--;\\n\\t}\\n\\treturn true;\\n}\\n\\nvoid dfs(string &s, int p, string &s1, string &s2, int &ans) {\\n\\tif(p >= s.length()) {\\n\\t\\tif(isPalin(s1) && isPalin(s2)) {\\n\\t\\t\\tint tmp = s1.length() * s2.length();\\n\\t\\t\\tans = max(ans, tmp);\\n\\t\\t}\\n\\t\\treturn;\\n\\t}\\n\\t// Case 1: Not Pick\\n\\tdfs(s, p + 1, s1, s2, ans);\\n\\t\\n\\t// Case 2: Pick -> 2 cases\\n\\t// 2(a): Pick in 1st string\\n\\ts1.push_back(s[p]);\\n\\tdfs(s, p + 1, s1, s2, ans);\\n\\ts1.pop_back();\\n\\n\\t// 2(b): Pick in 2nd string\\n\\ts2.push_back(s[p]);\\n\\tdfs(s, p + 1, s1, s2, ans);\\n\\ts2.pop_back();\\n}\\n\\nint maxProduct(string s) {\\n\\tint ans = 0;\\n\\tstring s1 = \"\", s2 = \"\";\\n\\tdfs(s, 0, s1, s2, ans);\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nbool isPalin(string &s) {\\n\\tint i = 0, j = s.length() - 1;\\n\\twhile(i < j) {\\n\\t\\tif(s[i] != s[j]) return false;\\n\\t\\ti++;\\n\\t\\tj--;\\n\\t}\\n\\treturn true;\\n}\\n\\nvoid dfs(string &s, int p, string &s1, string &s2, int &ans) {\\n\\tif(p >= s.length()) {\\n\\t\\tif(isPalin(s1) && isPalin(s2)) {\\n\\t\\t\\tint tmp = s1.length() * s2.length();\\n\\t\\t\\tans = max(ans, tmp);\\n\\t\\t}\\n\\t\\treturn;\\n\\t}\\n\\t// Case 1: Not Pick\\n\\tdfs(s, p + 1, s1, s2, ans);\\n\\t\\n\\t// Case 2: Pick -> 2 cases\\n\\t// 2(a): Pick in 1st string\\n\\ts1.push_back(s[p]);\\n\\tdfs(s, p + 1, s1, s2, ans);\\n\\ts1.pop_back();\\n\\n\\t// 2(b): Pick in 2nd string\\n\\ts2.push_back(s[p]);\\n\\tdfs(s, p + 1, s1, s2, ans);\\n\\ts2.pop_back();\\n}\\n\\nint maxProduct(string s) {\\n\\tint ans = 0;\\n\\tstring s1 = \"\", s2 = \"\";\\n\\tdfs(s, 0, s1, s2, ans);\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2338630,
                "title": "c-bitmask-hashmap",
                "content": "If the string is n chars long, every possible string can be created in a loop from 0-2^n,\\nthe same way you generate all subsets. \\n\\nCreate the strings and reverse them, if its equal its a palidrome.\\n\\nThe binary version of the numbers in the loop from 0-2^n represents the char positions of each string created, store the palidromes with the outer loop number being the key, and the amount of bits being the value.\\n\\nLoop through the map in, and \\'&\\' each key value, if its 0, then they dont have any same bits, multiply them and keep track od the maximum.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(string s) {\\n        unordered_map <int, int> map;\\n        int n = s.size();\\n        for (int i = 0; i < (1 << n); i++) {\\n            string str = \"\";\\n            for (int j = 0; j < n; j++) {\\n                if ((i & (1 << j))) {\\n                    str += s[j];\\n                }\\n            }\\n            string str1(str);  \\n            reverse(str.begin(), str.end());\\n            if (str == str1) {\\n                map[i] = __builtin_popcount(i);\\n            }\\n        }\\n        int maxNum = 0;\\n        for (pair<int,int> i: map) {\\n            for (pair<int, int> j : map) {\\n                if (i != j) {\\n                    if ((i.first & j.first) == 0) {\\n                        maxNum = max((i.second * j.second), maxNum);\\n                    }\\n                }\\n            }\\n        }\\n        return maxNum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(string s) {\\n        unordered_map <int, int> map;\\n        int n = s.size();\\n        for (int i = 0; i < (1 << n); i++) {\\n            string str = \"\";\\n            for (int j = 0; j < n; j++) {\\n                if ((i & (1 << j))) {\\n                    str += s[j];\\n                }\\n            }\\n            string str1(str);  \\n            reverse(str.begin(), str.end());\\n            if (str == str1) {\\n                map[i] = __builtin_popcount(i);\\n            }\\n        }\\n        int maxNum = 0;\\n        for (pair<int,int> i: map) {\\n            for (pair<int, int> j : map) {\\n                if (i != j) {\\n                    if ((i.first & j.first) == 0) {\\n                        maxNum = max((i.second * j.second), maxNum);\\n                    }\\n                }\\n            }\\n        }\\n        return maxNum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458994,
                "title": "memoized-dp",
                "content": "We recursively generate two strings string_a , string_b from s.\\nIn this quetion at every index i of string s, we have 3 choices:\\n1.add s[i] to string_a\\n2.add s[i] to string_b\\n3.Do not add s[i] to string_a or string_b\\nWe take max of every 3 choices at every step.\\nWhen we i == length of s, we check is string_a and string_b generated are palindrome. If palindrome, return product of the length of two strings else return 0\\nOn careful observation it is found that recursively generated i,string_a, string_b are repeating and hence we memoize them.\\n```\\nmemo = {}\\ndef is_palindrome(string):\\n    (i,j) = (0,len(string)-1)\\n    while i < j:\\n        if string[i] != string[j]:\\n            return False\\n        i += 1\\n        j -= 1\\n    return True\\ndef recurse(s,i,string_a,string_b):\\n    global memo\\n    if i >= len(s):\\n        if is_palindrome(string_a) and is_palindrome(string_b):\\n            return len(string_a) * len(string_b)\\n        else:\\n            return 0\\n    elif (i,string_a,string_b) in memo:\\n        return memo[(i,string_a,string_b)]\\n    ans1 = recurse(s,i+1,string_a+ s[i],string_b)\\n    ans2 = recurse(s,i+1,string_a,string_b+ s[i])\\n    ans3 = recurse(s,i+1,string_a,string_b)\\n    ans =  max(ans1,ans2,ans3)\\n    memo[(i,string_a,string_b)] = ans\\n    return ans\\n        \\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        global memo\\n        memo = {}\\n        return recurse(s,0,\"\",\"\")\\n```",
                "solutionTags": [],
                "code": "```\\nmemo = {}\\ndef is_palindrome(string):\\n    (i,j) = (0,len(string)-1)\\n    while i < j:\\n        if string[i] != string[j]:\\n            return False\\n        i += 1\\n        j -= 1\\n    return True\\ndef recurse(s,i,string_a,string_b):\\n    global memo\\n    if i >= len(s):\\n        if is_palindrome(string_a) and is_palindrome(string_b):\\n            return len(string_a) * len(string_b)\\n        else:\\n            return 0\\n    elif (i,string_a,string_b) in memo:\\n        return memo[(i,string_a,string_b)]\\n    ans1 = recurse(s,i+1,string_a+ s[i],string_b)\\n    ans2 = recurse(s,i+1,string_a,string_b+ s[i])\\n    ans3 = recurse(s,i+1,string_a,string_b)\\n    ans =  max(ans1,ans2,ans3)\\n    memo[(i,string_a,string_b)] = ans\\n    return ans\\n        \\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        global memo\\n        memo = {}\\n        return recurse(s,0,\"\",\"\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458484,
                "title": "python-bruteforce",
                "content": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        subs = []\\n        n = len(s)\\n        def dfs(curr, ind, inds):\\n            if ind == n:\\n                if curr == curr[::-1]:\\n                    subs.append((curr, inds))\\n                return\\n            dfs(curr+s[ind], ind+1, inds|{ind})\\n            dfs(curr, ind+1, inds)\\n        \\n        dfs(\\'\\', 0, set())\\n        \\n        res = 0\\n        n = len(subs)\\n        for i in range(n):\\n            s1, i1 = subs[i]\\n            for j in range(i+1, n):\\n                s2, i2 = subs[j]\\n                if len(i1 & i2) == 0:\\n                    res = max(res, len(s1)*len(s2))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        subs = []\\n        n = len(s)\\n        def dfs(curr, ind, inds):\\n            if ind == n:\\n                if curr == curr[::-1]:\\n                    subs.append((curr, inds))\\n                return\\n            dfs(curr+s[ind], ind+1, inds|{ind})\\n            dfs(curr, ind+1, inds)\\n        \\n        dfs(\\'\\', 0, set())\\n        \\n        res = 0\\n        n = len(subs)\\n        for i in range(n):\\n            s1, i1 = subs[i]\\n            for j in range(i+1, n):\\n                s2, i2 = subs[j]\\n                if len(i1 & i2) == 0:\\n                    res = max(res, len(s1)*len(s2))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458283,
                "title": "c-bitmask-dp-time-o-n-3-n-space-o-2-n",
                "content": "```dp[mask]```represent the maximum length of palindrome if we used these characters.\\nThere are two cases:\\n1) If mask represent a palindrome subsequence, ```dp[mask]```= the length of that subsequence.\\n2) If mask is not a palindrome subsequence, we iterate through all its submasks and find the longest palindrome length\\n\\nFinally, we iterate through all masks and find the maximum product of ```dp[mask]``` and ```dp[~mask]```, which sums up to the whole string.\\n```\\nbool ispalin(const string& s) {\\n    int l = 0, r = s.size() - 1;\\n    while(l < r) {\\n        if(s[l] != s[r])\\n            return false;\\n        ++l, --r;\\n    }\\n    return true;\\n}\\n\\nclass Solution {\\npublic:\\n    int maxProduct(string s) {\\n        const int N = s.size();\\n        vector<int> dp(1 << N);\\n        for(int mask = 1; mask < (1 << N); ++mask) {\\n            string cur;\\n            for(int i = 0; i < N; ++i)\\n                if(mask & (1 << i))\\n                    cur += s[i];\\n            if(ispalin(cur))\\n                dp[mask] = cur.size();\\n            else {\\n                for(int sub = mask; sub; sub = (sub - 1) & mask)\\n                    dp[mask] = max(dp[mask], dp[sub]);\\n            }\\n        }\\n        int ans = 0;\\n        for(int mask = 0; mask < (1 << N); ++mask) {\\n            int a = dp[mask];\\n            int other = 0;\\n            for(int i = 0; i < N; ++i)\\n                if(!(mask & (1 << i)))\\n                    other |= 1 << i;\\n            int b = dp[other];\\n            ans = max(ans, a * b);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```dp[mask]```\n```dp[mask]```\n```dp[mask]```\n```dp[~mask]```\n```\\nbool ispalin(const string& s) {\\n    int l = 0, r = s.size() - 1;\\n    while(l < r) {\\n        if(s[l] != s[r])\\n            return false;\\n        ++l, --r;\\n    }\\n    return true;\\n}\\n\\nclass Solution {\\npublic:\\n    int maxProduct(string s) {\\n        const int N = s.size();\\n        vector<int> dp(1 << N);\\n        for(int mask = 1; mask < (1 << N); ++mask) {\\n            string cur;\\n            for(int i = 0; i < N; ++i)\\n                if(mask & (1 << i))\\n                    cur += s[i];\\n            if(ispalin(cur))\\n                dp[mask] = cur.size();\\n            else {\\n                for(int sub = mask; sub; sub = (sub - 1) & mask)\\n                    dp[mask] = max(dp[mask], dp[sub]);\\n            }\\n        }\\n        int ans = 0;\\n        for(int mask = 0; mask < (1 << N); ++mask) {\\n            int a = dp[mask];\\n            int other = 0;\\n            for(int i = 0; i < N; ++i)\\n                if(!(mask & (1 << i)))\\n                    other |= 1 << i;\\n            int b = dp[other];\\n            ans = max(ans, a * b);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2408751,
                "title": "java-bit-mask",
                "content": "```\\nclass Solution {\\n    public int maxProduct(String s) {\\n        HashMap<Integer,Integer> map=new HashMap<>(); // KEY=bit mask , VALUE= length of the string generated from that mask\\n        int n=s.length();\\n        for(int mask=0;mask<(1<<n);mask++){// generate bitmask from 1 to 2^n \\n            String temp=\"\";\\n            for(int i=0;i<n;i++){ \\n                if((mask & (1<<i)) !=0) // generate the string from the mask \\n                    temp+=s.charAt(i);\\n            }\\n            \\n            if(isPali(temp)){ // check if its a palindrome\\n                map.put(mask,temp.length()); \\n            }\\n        }\\n        \\n        int res=0;\\n        for(int i: map.keySet()){\\n            for(int j :map.keySet()){\\n                if((i&j)==0){ // if AND of two bitmask is zero means they are disjoint\\n                    res=Math.max(res, map.get(i)*map.get(j));\\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n        \\n        \\n        \\n    }\\n    \\n    private boolean isPali(String s){\\n        int i=0;\\n        int j=s.length()-1;\\n        while(i<j){\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(String s) {\\n        HashMap<Integer,Integer> map=new HashMap<>(); // KEY=bit mask , VALUE= length of the string generated from that mask\\n        int n=s.length();\\n        for(int mask=0;mask<(1<<n);mask++){// generate bitmask from 1 to 2^n \\n            String temp=\"\";\\n            for(int i=0;i<n;i++){ \\n                if((mask & (1<<i)) !=0) // generate the string from the mask \\n                    temp+=s.charAt(i);\\n            }\\n            \\n            if(isPali(temp)){ // check if its a palindrome\\n                map.put(mask,temp.length()); \\n            }\\n        }\\n        \\n        int res=0;\\n        for(int i: map.keySet()){\\n            for(int j :map.keySet()){\\n                if((i&j)==0){ // if AND of two bitmask is zero means they are disjoint\\n                    res=Math.max(res, map.get(i)*map.get(j));\\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n        \\n        \\n        \\n    }\\n    \\n    private boolean isPali(String s){\\n        int i=0;\\n        int j=s.length()-1;\\n        while(i<j){\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253784,
                "title": "easy-c-backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    bool pal(string &s){\\n        int l=s.length();\\n        for(int i=0;i<l-1-i;i++) \\n            if(s[i]!=s[l-1-i]) return false;\\n        return true;\\n    }\\n    void dfs(int curr,string &s1,string &s2,int l, string &s){\\n        if(curr==l){\\n            if(pal(s1) && pal(s2)){\\n                ans=max(ans,(int)s1.length()*(int)s2.length());\\n            }\\n            return;\\n        }\\n        s1.push_back(s[curr]);\\n        dfs(curr+1,s1,s2,l,s);\\n        s1.pop_back();\\n        \\n        s2.push_back(s[curr]);\\n        dfs(curr+1,s1,s2,l,s);\\n        s2.pop_back();\\n        \\n        dfs(curr+1,s1,s2,l,s);\\n    }\\n    int maxProduct(string &s) {\\n        int l=s.length();\\n        string s1,s2;\\n        dfs(0,s1,s2,l,s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    bool pal(string &s){\\n        int l=s.length();\\n        for(int i=0;i<l-1-i;i++) \\n            if(s[i]!=s[l-1-i]) return false;\\n        return true;\\n    }\\n    void dfs(int curr,string &s1,string &s2,int l, string &s){\\n        if(curr==l){\\n            if(pal(s1) && pal(s2)){\\n                ans=max(ans,(int)s1.length()*(int)s2.length());\\n            }\\n            return;\\n        }\\n        s1.push_back(s[curr]);\\n        dfs(curr+1,s1,s2,l,s);\\n        s1.pop_back();\\n        \\n        s2.push_back(s[curr]);\\n        dfs(curr+1,s1,s2,l,s);\\n        s2.pop_back();\\n        \\n        dfs(curr+1,s1,s2,l,s);\\n    }\\n    int maxProduct(string &s) {\\n        int l=s.length();\\n        string s1,s2;\\n        dfs(0,s1,s2,l,s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458660,
                "title": "simple-bitmasking-smart-bruteforce-75ms-java",
                "content": "Total possible subsequence n = 1 << string.length()-1\\n\\nFor each possible subsequence check if the string is palindrome or not.  If it\\'s palindrome then store it in a list. \\nNow Iterate through the each pair and check if this pair gives us the maximum result. \\n\\nBoth pair need to be disjoint to achieve it, we will store the binary representation of the subsequnce and use `&` to check if both palindrome has any same char index or not. \\n\\n\\n\\n\\n\\n    public int maxProduct(String s) {\\n        char[] chars = s.toCharArray();\\n        int n = 1 << chars.length;\\n        List<int[]> list = new ArrayList<int[]>();\\n\\t\\t// each number from 1 to n represent a unique subsequence \\n        for (int i = 1; i < n; i++) {\\n\\t\\t\\t// get the string for current subsequence and check if it\\'s palindrom\\n            if (isPalindrom(getString(i, chars))) {\\n\\t\\t\\t\\t// if it\\'s palindrome then store the binary representation fo the sequence and number of 1\\'s \\n\\t\\t\\t\\t// as it will be required to calculate the product of the two subsequence\\n                list.add(new int[]{i, countOnes(i)});\\n            }\\n        }\\n\\n        int max = 0;\\n        for (int i = list.size() - 1; i >= 0; i--) {\\n            int[] first = list.get(i);\\n            int v = first[1];\\n            for (int j = i - 1; j >= 0; j--) {\\n\\t\\t\\t\\t// check if both subsequence has any common char index or not\\n                if ((first[0] & list.get(j)[0]) == 0) {\\n                    max = Math.max(max, v * list.get(j)[1]);\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n\\n    private String getString(int num, char[] chars) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < chars.length; i++) {\\n            if ((num & (1 << i)) != 0) {\\n                sb.append(chars[i]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\n    private boolean isPalindrom(String s) {\\n        int i = 0, j = s.length() - 1;\\n        while (i < j) {\\n            if (s.charAt(i++) != s.charAt(j--)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private int countOnes(int v) {\\n        int i = 0;\\n        while (v != 0) {\\n            i++;\\n            v &= v - 1;\\n        }\\n        return i;\\n    }",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "Total possible subsequence n = 1 << string.length()-1\\n\\nFor each possible subsequence check if the string is palindrome or not.  If it\\'s palindrome then store it in a list. \\nNow Iterate through the each pair and check if this pair gives us the maximum result. \\n\\nBoth pair need to be disjoint to achieve it, we will store the binary representation of the subsequnce and use `&` to check if both palindrome has any same char index or not. \\n\\n\\n\\n\\n\\n    public int maxProduct(String s) {\\n        char[] chars = s.toCharArray();\\n        int n = 1 << chars.length;\\n        List<int[]> list = new ArrayList<int[]>();\\n\\t\\t// each number from 1 to n represent a unique subsequence \\n        for (int i = 1; i < n; i++) {\\n\\t\\t\\t// get the string for current subsequence and check if it\\'s palindrom\\n            if (isPalindrom(getString(i, chars))) {\\n\\t\\t\\t\\t// if it\\'s palindrome then store the binary representation fo the sequence and number of 1\\'s \\n\\t\\t\\t\\t// as it will be required to calculate the product of the two subsequence\\n                list.add(new int[]{i, countOnes(i)});\\n            }\\n        }\\n\\n        int max = 0;\\n        for (int i = list.size() - 1; i >= 0; i--) {\\n            int[] first = list.get(i);\\n            int v = first[1];\\n            for (int j = i - 1; j >= 0; j--) {\\n\\t\\t\\t\\t// check if both subsequence has any common char index or not\\n                if ((first[0] & list.get(j)[0]) == 0) {\\n                    max = Math.max(max, v * list.get(j)[1]);\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n\\n    private String getString(int num, char[] chars) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < chars.length; i++) {\\n            if ((num & (1 << i)) != 0) {\\n                sb.append(chars[i]);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\n    private boolean isPalindrom(String s) {\\n        int i = 0, j = s.length() - 1;\\n        while (i < j) {\\n            if (s.charAt(i++) != s.charAt(j--)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private int countOnes(int v) {\\n        int i = 0;\\n        while (v != 0) {\\n            i++;\\n            v &= v - 1;\\n        }\\n        return i;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1458400,
                "title": "python-dp-on-subsequences",
                "content": "Let `dp(sub)` be a DP that finds longest palindromic subsequence on a given string `sub`. Caching intermediate results, this is done in linear time.\\n\\nWe need to split into all possible subsets, on top of which we can apply DP. There are `2**12 = 4096` such splits at most, so we can cache the substrings.\\n\\nWe find the substrings using bitmask.\\nGo only half length as the remaining is covered by symmetry. This cuts runtime in half.\\n\\n```python\\nclass Solution:\\n    def maxProduct(self, s):\\n        @lru_cache(None)\\n        def dp(sub):\\n            if not sub:\\n                return 0\\n            if len(sub) == 1:\\n                return 1\\n            if len(sub) == 2:\\n                return 2 if sub[0] == sub[1] else 1\\n            if sub[0] == sub[-1]:\\n                return 2 + dp(sub[1:-1])\\n            return max(dp(sub[1:]), dp(sub[:-1]))\\n        \\n        ans = 0\\n        for mask in range(2**len(s) // 2):\\n            sub1 = \\'\\'\\n            sub2 = \\'\\'\\n            for j in range(len(s)):\\n                if (mask >> j) & 1:\\n                    sub1 += s[j]\\n                else:\\n                    sub2 += s[j]\\n            ans = max(ans, dp(sub1) * dp(sub2))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxProduct(self, s):\\n        @lru_cache(None)\\n        def dp(sub):\\n            if not sub:\\n                return 0\\n            if len(sub) == 1:\\n                return 1\\n            if len(sub) == 2:\\n                return 2 if sub[0] == sub[1] else 1\\n            if sub[0] == sub[-1]:\\n                return 2 + dp(sub[1:-1])\\n            return max(dp(sub[1:]), dp(sub[:-1]))\\n        \\n        ans = 0\\n        for mask in range(2**len(s) // 2):\\n            sub1 = \\'\\'\\n            sub2 = \\'\\'\\n            for j in range(len(s)):\\n                if (mask >> j) & 1:\\n                    sub1 += s[j]\\n                else:\\n                    sub2 += s[j]\\n            ans = max(ans, dp(sub1) * dp(sub2))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422048,
                "title": "java-dp-with-clear-explanation-o-n-2-n-beats-89",
                "content": "# Intuition\\nThere are multiple ways to approach this problem:\\n1. Find all subsequences, then for any 2, check if they overlap, get get product. Time complexity O(2^n * 2^n * n) = O(n * 4^n).\\n2. Divide s to 2 subsequences - for each character, either assign to seq1, or seq2, or discard. now for seq1 and seq2 check if they are palindrome and get product. Time complexity O(n * 3^n). We have 3^n because each character can be in seq1, seq2, or discarded.\\n3. Go through all 2^n subsequences. Everytime, for the remaining unpicked characters, treat them as string, then apply DP solution in LC516 \"Longest Palindromic Subsequence\". Time complexity is O(n^2 * 2^n).\\n4. Consolidate solving \"Longest Palindromic Subsequence\" of all 2^n subsequences together using DP (as a preprocessing). Then from this result we can easily get max product. Time complexity is O(n * 2^n). See details below.\\n\\n# Approach\\nFor all 2^n subsequences, calculate the longest palindromic subsequence of each.\\n\\nThis can be done with dynamic programming. For example, for s = \"leetcode\", for sequence 01100101, i.e. \"eeoe\", we have **recursive relationship**:\\n```\\npalSubSeq(01100101) = max{\\n    2 + palSubSeq(00100100),\\n    palSubSeq(00100101),\\n    palSubSeq(01100100),\\n}\\n```\\n\\nAfter we have palSubSeq[] for all 2^n subsequences, we can calculate max product in this way: go through all seq1 (from 0000000 to 1111111), note its flip-sequence is seq2 = 2^n - 1 - seq1. So product is `palSubSeq[seq1] * palSubSeq[2^n - 1 - seq1]`\\n\\nCoding-wise, mean challenge is to calculate the DP table palSubSeq[]. We use recursion + memoization here. First we use backtrack to get to all 2^n subsequences. Then for each subsequence, we apply the recursive relationship, and use memoization to avoid duplicate calculation.\\n\\n# Complexity\\n- Time complexity: `O(n * 2^n)`\\n\\n- Space complexity: `O(2^n)`\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProduct(String s) {\\n        // 2^n total possible subsequences\\n        // first calculate longest palindrome subseq for each possible subsequence\\n        // then calculate product\\n\\n        int length = s.length();    // this is n\\n        int count = (int)(Math.pow(2, length)); // this is 2^n\\n\\n        // the memoization table to store longest palindrome subseq, of all possible subseq\\n        // for example, for s=\"leetcode\", palSubSeq[00001011] stores the longest palindrome subseq of sequence \"cde\"\\n        // because there are totally 2^n possible subsequences, the table size is 2^n (note n<=12 so this size <= 4096)\\n        int[] palSubSeq = new int[count];\\n        // base case: single characters\\n        for (int bitIndex = 1; bitIndex < count; bitIndex *= 2) {\\n            palSubSeq[bitIndex] = 1;\\n        }\\n\\n        // use bitmask to do backtracking\\n        boolean[] bitmask = new boolean[length];\\n        for (int i = 0; i < length; i++) {\\n            bitmask[i] = false;\\n        }\\n        // calculate the palSubSeq[] table\\n        palSubSeqBacktrack(s, bitmask, 0, palSubSeq);\\n\\n        // get max product using palSubSeq[]\\n        // for any subsequence mask, its flip is 2^n - 1 - mask\\n        // for example, 00001011\\'s flip is 11110100\\n        int maxProduct = 0;\\n        for (int i = 0; i < count / 2; i++) {\\n            int product = palSubSeq[i] * palSubSeq[count - i - 1];\\n            if (product > maxProduct) {\\n                maxProduct = product;\\n            }\\n        }\\n        return maxProduct;\\n    }\\n\\n    // 2 stages of recursion calls\\n    // stage 1. use backtracking just to get to all 2^n subsequences\\n    private static void palSubSeqBacktrack(String s, boolean[] bitmask, int processingIndex, int[] palSubSeq) {\\n        if (processingIndex < bitmask.length) {\\n            // backtrack to bottom\\n            bitmask[processingIndex] = true;\\n            palSubSeqBacktrack(s, bitmask, processingIndex + 1, palSubSeq);\\n            bitmask[processingIndex] = false;\\n            palSubSeqBacktrack(s, bitmask, processingIndex + 1, palSubSeq);\\n            return;\\n        }\\n\\n        // at bottom, call stage 2\\n        palSubSeqRecur(s, bitmask, palSubSeq);\\n    }\\n\\n    // stage 2, for all subsequences, do recursion call + memoization. this could be changed to iterative\\n    private static int palSubSeqRecur(String s, boolean[] bitmask, int[] palSubSeq) {\\n        int bitIndex = bitmaskToIndex(bitmask);\\n        if (bitIndex == 0) {\\n            return 0;\\n        }\\n        if (palSubSeq[bitIndex] != 0) {\\n            return palSubSeq[bitIndex];\\n        }\\n\\n        // all-0\\'s should be handled above\\n        // single characters should have been filled in as base case\\n        // starting here it should have at least 2 characters (2 one\\'s in the bitmask)\\n        int firstOneIndex;\\n        for (firstOneIndex = 0; firstOneIndex < bitmask.length; firstOneIndex++) {\\n            if (bitmask[firstOneIndex]) {\\n                break;\\n            }\\n        }\\n        int lastOneIndex;\\n        for (lastOneIndex = bitmask.length - 1; lastOneIndex >= 0; lastOneIndex--) {\\n            if (bitmask[lastOneIndex]) {\\n                break;\\n            }\\n        }\\n\\n        int max = 0;\\n        // maxPalSubseq(001110011) = max{\\n        //   2 + maxPalSubseq(000110010) if s[2]==s[8],\\n        //   maxPalSubseq(000110011),\\n        //   maxPalSubseq(001110010),\\n        // }\\n        if (s.charAt(firstOneIndex) == s.charAt(lastOneIndex)) {\\n            bitmask[firstOneIndex] = false;\\n            bitmask[lastOneIndex] = false;\\n            max = 2 + palSubSeqRecur(s, bitmask, palSubSeq);\\n        }\\n\\n        bitmask[firstOneIndex] = false;\\n        bitmask[lastOneIndex] = true;\\n        int altMax1 = palSubSeqRecur(s, bitmask, palSubSeq);\\n\\n        bitmask[firstOneIndex] = true;\\n        bitmask[lastOneIndex] = false;\\n        int altMax2 = palSubSeqRecur(s, bitmask, palSubSeq);\\n\\n        bitmask[firstOneIndex] = true;\\n        bitmask[lastOneIndex] = true;\\n        if (altMax1 > max) {\\n            max = altMax1;\\n        }\\n        if (altMax2 > max) {\\n            max = altMax2;\\n        }\\n        palSubSeq[bitIndex] = max;\\n        return max;\\n    }\\n\\n    private static int bitmaskToIndex(boolean[] bitmask) {\\n        int length = bitmask.length;\\n        int number = 0;\\n        for (int i = 0; i < length; i++) {\\n            number = bitmask[i] ? (number * 2 + 1) : (number * 2);\\n        }\\n        return number;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\npalSubSeq(01100101) = max{\\n    2 + palSubSeq(00100100),\\n    palSubSeq(00100101),\\n    palSubSeq(01100100),\\n}\\n```\n```\\nclass Solution {\\n    public int maxProduct(String s) {\\n        // 2^n total possible subsequences\\n        // first calculate longest palindrome subseq for each possible subsequence\\n        // then calculate product\\n\\n        int length = s.length();    // this is n\\n        int count = (int)(Math.pow(2, length)); // this is 2^n\\n\\n        // the memoization table to store longest palindrome subseq, of all possible subseq\\n        // for example, for s=\"leetcode\", palSubSeq[00001011] stores the longest palindrome subseq of sequence \"cde\"\\n        // because there are totally 2^n possible subsequences, the table size is 2^n (note n<=12 so this size <= 4096)\\n        int[] palSubSeq = new int[count];\\n        // base case: single characters\\n        for (int bitIndex = 1; bitIndex < count; bitIndex *= 2) {\\n            palSubSeq[bitIndex] = 1;\\n        }\\n\\n        // use bitmask to do backtracking\\n        boolean[] bitmask = new boolean[length];\\n        for (int i = 0; i < length; i++) {\\n            bitmask[i] = false;\\n        }\\n        // calculate the palSubSeq[] table\\n        palSubSeqBacktrack(s, bitmask, 0, palSubSeq);\\n\\n        // get max product using palSubSeq[]\\n        // for any subsequence mask, its flip is 2^n - 1 - mask\\n        // for example, 00001011\\'s flip is 11110100\\n        int maxProduct = 0;\\n        for (int i = 0; i < count / 2; i++) {\\n            int product = palSubSeq[i] * palSubSeq[count - i - 1];\\n            if (product > maxProduct) {\\n                maxProduct = product;\\n            }\\n        }\\n        return maxProduct;\\n    }\\n\\n    // 2 stages of recursion calls\\n    // stage 1. use backtracking just to get to all 2^n subsequences\\n    private static void palSubSeqBacktrack(String s, boolean[] bitmask, int processingIndex, int[] palSubSeq) {\\n        if (processingIndex < bitmask.length) {\\n            // backtrack to bottom\\n            bitmask[processingIndex] = true;\\n            palSubSeqBacktrack(s, bitmask, processingIndex + 1, palSubSeq);\\n            bitmask[processingIndex] = false;\\n            palSubSeqBacktrack(s, bitmask, processingIndex + 1, palSubSeq);\\n            return;\\n        }\\n\\n        // at bottom, call stage 2\\n        palSubSeqRecur(s, bitmask, palSubSeq);\\n    }\\n\\n    // stage 2, for all subsequences, do recursion call + memoization. this could be changed to iterative\\n    private static int palSubSeqRecur(String s, boolean[] bitmask, int[] palSubSeq) {\\n        int bitIndex = bitmaskToIndex(bitmask);\\n        if (bitIndex == 0) {\\n            return 0;\\n        }\\n        if (palSubSeq[bitIndex] != 0) {\\n            return palSubSeq[bitIndex];\\n        }\\n\\n        // all-0\\'s should be handled above\\n        // single characters should have been filled in as base case\\n        // starting here it should have at least 2 characters (2 one\\'s in the bitmask)\\n        int firstOneIndex;\\n        for (firstOneIndex = 0; firstOneIndex < bitmask.length; firstOneIndex++) {\\n            if (bitmask[firstOneIndex]) {\\n                break;\\n            }\\n        }\\n        int lastOneIndex;\\n        for (lastOneIndex = bitmask.length - 1; lastOneIndex >= 0; lastOneIndex--) {\\n            if (bitmask[lastOneIndex]) {\\n                break;\\n            }\\n        }\\n\\n        int max = 0;\\n        // maxPalSubseq(001110011) = max{\\n        //   2 + maxPalSubseq(000110010) if s[2]==s[8],\\n        //   maxPalSubseq(000110011),\\n        //   maxPalSubseq(001110010),\\n        // }\\n        if (s.charAt(firstOneIndex) == s.charAt(lastOneIndex)) {\\n            bitmask[firstOneIndex] = false;\\n            bitmask[lastOneIndex] = false;\\n            max = 2 + palSubSeqRecur(s, bitmask, palSubSeq);\\n        }\\n\\n        bitmask[firstOneIndex] = false;\\n        bitmask[lastOneIndex] = true;\\n        int altMax1 = palSubSeqRecur(s, bitmask, palSubSeq);\\n\\n        bitmask[firstOneIndex] = true;\\n        bitmask[lastOneIndex] = false;\\n        int altMax2 = palSubSeqRecur(s, bitmask, palSubSeq);\\n\\n        bitmask[firstOneIndex] = true;\\n        bitmask[lastOneIndex] = true;\\n        if (altMax1 > max) {\\n            max = altMax1;\\n        }\\n        if (altMax2 > max) {\\n            max = altMax2;\\n        }\\n        palSubSeq[bitIndex] = max;\\n        return max;\\n    }\\n\\n    private static int bitmaskToIndex(boolean[] bitmask) {\\n        int length = bitmask.length;\\n        int number = 0;\\n        for (int i = 0; i < length; i++) {\\n            number = bitmask[i] ? (number * 2 + 1) : (number * 2);\\n        }\\n        return number;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415238,
                "title": "c-beginner-friendly-recursive-solution-explained-in-detail",
                "content": "**Time Taken : 1732ms Faster than 28.54%**\\nNOTE : Please someone help me detrmine the time complexity of the given code\\n\\n**APPROACH :**\\n* Generating all possible palindromic subsequence of the given string BUT instead of storing the string, I am storing the index of the subsequence thus formed into a vector.\\n* For checking whether the subsequence is a PALINDROME or not , I can just use the index from the vector.\\n* Storing the vector [ containing index of palindromic subsequence] into a 2D vector.\\n* All possible cases are generated.\\n* If two subsequences are valid and their product are greater than our maxProduct then we update our maxProduct.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ar;\\n    bool check(vector<int>&a,vector<int>&b){       \\n        for(int i=0;i<a.size();i++)\\n            for(int j=0;j<b.size();j++)\\n                if(a[i]==b[j]) return false;\\n        return true;\\n    }\\n    bool isPalin(string &s,vector<int>&ans){\\n        int a=0,b=ans.size()-1;\\n        while(a<=b){\\n            if(s[ans[a]]!=s[ans[b]]) return false;\\n            a++;\\n            b--;\\n        }\\n        return true;    \\n    }\\n    void calc(string &s,vector<int>&ans,int i){\\n        if(isPalin(s,ans))\\n           ar.push_back(ans);\\n        \\n        if(i>=s.length()) return;\\n        ans.push_back(i);\\n        calc(s,ans,i+1);\\n        ans.pop_back();\\n        calc(s,ans,i+1);\\n    }\\n    int maxProduct(string s) {\\n        int ans=0;\\n        vector<int>a;\\n        calc(s,a,0);\\n        for(int i=0;i<ar.size();i++){\\n            for(int j=i+1;j<ar.size();j++){              \\n                int x=(int)ar[i].size()*ar[j].size();\\n                if(x>ans&&check(ar[i],ar[j]))                   \\n                    ans=x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ar;\\n    bool check(vector<int>&a,vector<int>&b){       \\n        for(int i=0;i<a.size();i++)\\n            for(int j=0;j<b.size();j++)\\n                if(a[i]==b[j]) return false;\\n        return true;\\n    }\\n    bool isPalin(string &s,vector<int>&ans){\\n        int a=0,b=ans.size()-1;\\n        while(a<=b){\\n            if(s[ans[a]]!=s[ans[b]]) return false;\\n            a++;\\n            b--;\\n        }\\n        return true;    \\n    }\\n    void calc(string &s,vector<int>&ans,int i){\\n        if(isPalin(s,ans))\\n           ar.push_back(ans);\\n        \\n        if(i>=s.length()) return;\\n        ans.push_back(i);\\n        calc(s,ans,i+1);\\n        ans.pop_back();\\n        calc(s,ans,i+1);\\n    }\\n    int maxProduct(string s) {\\n        int ans=0;\\n        vector<int>a;\\n        calc(s,a,0);\\n        for(int i=0;i<ar.size();i++){\\n            for(int j=i+1;j<ar.size();j++){              \\n                int x=(int)ar[i].size()*ar[j].size();\\n                if(x>ans&&check(ar[i],ar[j]))                   \\n                    ans=x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077259,
                "title": "java-memoization-optimal-solution-easy-soltion",
                "content": "\\n```\\nclass Solution {\\n    \\n    int ans =  1;\\n    \\n    public int maxProduct(String s) {\\n        \\n        int[][] dp = new int[s.length() + 1][s.length() + 1];\\n        \\n        for(int[] d: dp)\\n            Arrays.fill(d, -1);\\n        \\n        int res = solve(s, \"\", \"\", 0, dp);\\n        \\n        return res;\\n        \\n    }\\n    public int solve(String s, String s1, String s2, int i, int[][] dp)\\n    {\\n        int s1l = s1.length();\\n        int s2l = s2.length();\\n        \\n        \\n\\n        if(isPali(s1) && isPali(s2))\\n        {\\n            ans = Math.max(ans, s1.length()*s2.length());\\n        }\\n        \\n        dp[s1l][s2l] = ans;\\n        \\n        \\n        if(i >= s.length())\\n        {\\n            return dp[s1l][s2l];\\n        }\\n           \\n        int op1 = solve(s, s1 + s.charAt(i), s2, i + 1, dp);\\n        int op2 = solve(s, s1, s2 + s.charAt(i), i + 1, dp);\\n        int op3 = solve(s, s1, s2, i + 1, dp);\\n        \\n        return dp[s1l][s2l];\\n    }\\n    public boolean isPali(String s)\\n    {\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while(i < j)\\n        {\\n            if(s.charAt(i) != s.charAt(j))\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int ans =  1;\\n    \\n    public int maxProduct(String s) {\\n        \\n        int[][] dp = new int[s.length() + 1][s.length() + 1];\\n        \\n        for(int[] d: dp)\\n            Arrays.fill(d, -1);\\n        \\n        int res = solve(s, \"\", \"\", 0, dp);\\n        \\n        return res;\\n        \\n    }\\n    public int solve(String s, String s1, String s2, int i, int[][] dp)\\n    {\\n        int s1l = s1.length();\\n        int s2l = s2.length();\\n        \\n        \\n\\n        if(isPali(s1) && isPali(s2))\\n        {\\n            ans = Math.max(ans, s1.length()*s2.length());\\n        }\\n        \\n        dp[s1l][s2l] = ans;\\n        \\n        \\n        if(i >= s.length())\\n        {\\n            return dp[s1l][s2l];\\n        }\\n           \\n        int op1 = solve(s, s1 + s.charAt(i), s2, i + 1, dp);\\n        int op2 = solve(s, s1, s2 + s.charAt(i), i + 1, dp);\\n        int op3 = solve(s, s1, s2, i + 1, dp);\\n        \\n        return dp[s1l][s2l];\\n    }\\n    public boolean isPali(String s)\\n    {\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while(i < j)\\n        {\\n            if(s.charAt(i) != s.charAt(j))\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013997,
                "title": "c-backtrack",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    void dfs(int i, string& s, string& s1, string& s2){\\n        \\n        if(i == size(s)){\\n            \\n            ans = max(ans, (isPal(s1) * isPal(s2)) );\\n            \\n            return;\\n        }\\n        \\n        // choose ith character for s1 (not for s2)\\n        \\n        s1.push_back(s[i]);\\n        dfs(i+1, s, s1, s2);\\n        \\n        //backtrack\\n        \\n        s1.pop_back();\\n        \\n        // choose ith character for s2 (not for s1)\\n        \\n        s2.push_back(s[i]);\\n        dfs(i+1, s, s1, s2);\\n        s2.pop_back();\\n        dfs(i+1, s, s1, s2);\\n    }\\n    int maxProduct(string& s) {\\n        \\n        ans = 0;\\n        string s1 = \"\",s2 = \"\";\\n        dfs(0, s, s1, s2);\\n        \\n        return ans;\\n        \\n    }\\n    private:\\n        int isPal(string& s) {\\n        \\n        int n = size(s);\\n        int i = 0, j = n-1;\\n            \\n        while(i <= j){\\n            \\n            if(s[i++] != s[j--]){\\n                \\n                return 0;\\n            }\\n        }\\n            \\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    void dfs(int i, string& s, string& s1, string& s2){\\n        \\n        if(i == size(s)){\\n            \\n            ans = max(ans, (isPal(s1) * isPal(s2)) );\\n            \\n            return;\\n        }\\n        \\n        // choose ith character for s1 (not for s2)\\n        \\n        s1.push_back(s[i]);\\n        dfs(i+1, s, s1, s2);\\n        \\n        //backtrack\\n        \\n        s1.pop_back();\\n        \\n        // choose ith character for s2 (not for s1)\\n        \\n        s2.push_back(s[i]);\\n        dfs(i+1, s, s1, s2);\\n        s2.pop_back();\\n        dfs(i+1, s, s1, s2);\\n    }\\n    int maxProduct(string& s) {\\n        \\n        ans = 0;\\n        string s1 = \"\",s2 = \"\";\\n        dfs(0, s, s1, s2);\\n        \\n        return ans;\\n        \\n    }\\n    private:\\n        int isPal(string& s) {\\n        \\n        int n = size(s);\\n        int i = 0, j = n-1;\\n            \\n        while(i <= j){\\n            \\n            if(s[i++] != s[j--]){\\n                \\n                return 0;\\n            }\\n        }\\n            \\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2728715,
                "title": "c-backtrack-c-users-please-pass-string-by-reference-to-pass",
                "content": "```\\nclass Solution {\\npublic:\\nint ans=INT_MIN;\\nint maxProduct(string s) \\n{\\n\\t//im trying to get all the disjoint subsequences\\n\\t\\n    //the ith char can be in none of the string\\n\\t//the ith char can be in the first string\\n\\t//the ith cahr can be in the second string\\n\\t\\n\\tint idx=0;\\n\\tstring s1=\"\";\\n\\tstring s2=\"\";\\n    fun(s,idx,s1,s2);\\n\\treturn ans;\\n}\\nvoid fun(string &s,int idx,string &s1,string &s2)\\n{\\n\\tif(idx >= s.length())\\n\\t{\\n\\t\\tif(ispalin(s1)==true and ispalin(s2)==true)\\n\\t\\t{\\n\\t\\t\\tint temp = s1.length() * s2.length();\\n\\t\\t\\tans=max(ans,temp);\\n\\t\\t}\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\tchar ch = s[idx];\\n\\t\\n\\t//if the currchar got include in the first string s1\\n\\ts1.push_back(ch);\\n\\tfun(s,idx+1,s1,s2);\\n\\ts1.pop_back();\\n\\t\\n\\ts2.push_back(ch);\\n\\tfun(s,idx+1,s1,s2);\\n    s2.pop_back();\\n\\t\\n\\tfun(s,idx+1,s1,s2);\\n}\\nbool ispalin(string &s)\\n{\\n\\tint i = 0;\\n        int j = s.length() - 1;\\n \\n        while (i < j) {\\n            if (s[i] != s[j]) return false;\\n            i++;\\n            j--;\\n        }\\n \\n        return true;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint ans=INT_MIN;\\nint maxProduct(string s) \\n{\\n\\t//im trying to get all the disjoint subsequences\\n\\t\\n    //the ith char can be in none of the string\\n\\t//the ith char can be in the first string\\n\\t//the ith cahr can be in the second string\\n\\t\\n\\tint idx=0;\\n\\tstring s1=\"\";\\n\\tstring s2=\"\";\\n    fun(s,idx,s1,s2);\\n\\treturn ans;\\n}\\nvoid fun(string &s,int idx,string &s1,string &s2)\\n{\\n\\tif(idx >= s.length())\\n\\t{\\n\\t\\tif(ispalin(s1)==true and ispalin(s2)==true)\\n\\t\\t{\\n\\t\\t\\tint temp = s1.length() * s2.length();\\n\\t\\t\\tans=max(ans,temp);\\n\\t\\t}\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\tchar ch = s[idx];\\n\\t\\n\\t//if the currchar got include in the first string s1\\n\\ts1.push_back(ch);\\n\\tfun(s,idx+1,s1,s2);\\n\\ts1.pop_back();\\n\\t\\n\\ts2.push_back(ch);\\n\\tfun(s,idx+1,s1,s2);\\n    s2.pop_back();\\n\\t\\n\\tfun(s,idx+1,s1,s2);\\n}\\nbool ispalin(string &s)\\n{\\n\\tint i = 0;\\n        int j = s.length() - 1;\\n \\n        while (i < j) {\\n            if (s[i] != s[j]) return false;\\n            i++;\\n            j--;\\n        }\\n \\n        return true;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2624729,
                "title": "java-bitmask-hashmap-solution",
                "content": "```\\nclass Solution {\\n\\n    //using bitmask\\n   public int maxProduct(String s) {\\n      \\n      if(s.length() == 2) {\\n         return 1;\\n      }\\n      \\n      int n = s.length();\\n      char[] ch = s.toCharArray();\\n   \\n      //bitmask to the length map\\n      Map<Integer, Integer> bitMasktoLengthMap = new HashMap<>();\\n      \\n      //using bitmask , calculate all the bitmask for 1 to 2^N\\n      // 1, 2, 3,............2024 ( 2 ^ 11 )\\n      for(int bitmask = 1 ; bitmask< Math.pow(2, n) ;bitmask++){\\n          \\n          //find all the subsequence(s) in the string using bitmask\\n          StringBuilder subsequence = new StringBuilder();\\n          for(int j = 0; j < n; j++ ){\\n   \\n             //if one of the bit is set to 1, then append that character to the subsequence.\\n             if(( bitmask & (1 << j ) ) != 0) { \\n                subsequence.append(ch[j]);  //constructing subsequence of different length\\n             }\\n          }\\n          \\n          //if the sequence constructed above is a palindrome,\\n         // then store the mask and its length .\\n          if(isPalindrome(subsequence.toString().toCharArray())){\\n             bitMasktoLengthMap.put(bitmask, subsequence.length());\\n          }\\n      }\\n      \\n      Set<Integer> allBitMasks = bitMasktoLengthMap.keySet();\\n      \\n      int maxProduct = Integer.MIN_VALUE;\\n      for( int mask1 : allBitMasks){\\n         \\n         for( int mask2 : allBitMasks){\\n   \\n            //product of lengths of 2 disjoint palindromic subsequence(s)\\n            //if product of AND operation is 0 then subsequnce(s) are DIS-JOINT\\n             if(( mask1 & mask2 ) == 0){\\n                int product = bitMasktoLengthMap.get(mask1) * bitMasktoLengthMap.get(mask2);\\n                maxProduct = Math.max(maxProduct, product);\\n             }\\n         }\\n      }\\n      \\n      \\n      return maxProduct;\\n   }\\n   \\n   private boolean isPalindrome( char[] chars ) {\\n      \\n      int i = 0;\\n      int j = chars.length - 1;\\n      \\n      if(i == j)\\n         return true;\\n      \\n      while(i < j){\\n         if(chars[i] != chars[j]){\\n            return false;\\n         }\\n         i++;\\n         j--;\\n      }\\n      \\n      return true;\\n   }\\n}\\n```\\n\\nSteps :\\n\\n1. In order to find all the subsequence , we will use the bitmask from 1 to 2^ N .\\n2. We will do AND operation to find the bit which is set ( bitmask & (1 << j ) ) != 0)  then it means bit is SET.\\n3. We will construct all the subsequence in this way for a sting of lengt N.\\n4. Then we will check if the string is palindrome ( same from backward and forward ).\\n5. If string is palindrome, then add the \"bitmask\" and its length to the map.\\n6. At end , we need to check ( key1 & key2 ) gives a zero , which means palindromic subsequence is disjoint i.e. they have no bit in common to each other.  \\n7. If ( key1 & key2 ) == 0 , then we calculate product of their length ( value1 * value 2 ).\\n8. We find the maximum value from  multiple set(s) of ( value1 * value 2 ).\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n\\n    //using bitmask\\n   public int maxProduct(String s) {\\n      \\n      if(s.length() == 2) {\\n         return 1;\\n      }\\n      \\n      int n = s.length();\\n      char[] ch = s.toCharArray();\\n   \\n      //bitmask to the length map\\n      Map<Integer, Integer> bitMasktoLengthMap = new HashMap<>();\\n      \\n      //using bitmask , calculate all the bitmask for 1 to 2^N\\n      // 1, 2, 3,............2024 ( 2 ^ 11 )\\n      for(int bitmask = 1 ; bitmask< Math.pow(2, n) ;bitmask++){\\n          \\n          //find all the subsequence(s) in the string using bitmask\\n          StringBuilder subsequence = new StringBuilder();\\n          for(int j = 0; j < n; j++ ){\\n   \\n             //if one of the bit is set to 1, then append that character to the subsequence.\\n             if(( bitmask & (1 << j ) ) != 0) { \\n                subsequence.append(ch[j]);  //constructing subsequence of different length\\n             }\\n          }\\n          \\n          //if the sequence constructed above is a palindrome,\\n         // then store the mask and its length .\\n          if(isPalindrome(subsequence.toString().toCharArray())){\\n             bitMasktoLengthMap.put(bitmask, subsequence.length());\\n          }\\n      }\\n      \\n      Set<Integer> allBitMasks = bitMasktoLengthMap.keySet();\\n      \\n      int maxProduct = Integer.MIN_VALUE;\\n      for( int mask1 : allBitMasks){\\n         \\n         for( int mask2 : allBitMasks){\\n   \\n            //product of lengths of 2 disjoint palindromic subsequence(s)\\n            //if product of AND operation is 0 then subsequnce(s) are DIS-JOINT\\n             if(( mask1 & mask2 ) == 0){\\n                int product = bitMasktoLengthMap.get(mask1) * bitMasktoLengthMap.get(mask2);\\n                maxProduct = Math.max(maxProduct, product);\\n             }\\n         }\\n      }\\n      \\n      \\n      return maxProduct;\\n   }\\n   \\n   private boolean isPalindrome( char[] chars ) {\\n      \\n      int i = 0;\\n      int j = chars.length - 1;\\n      \\n      if(i == j)\\n         return true;\\n      \\n      while(i < j){\\n         if(chars[i] != chars[j]){\\n            return false;\\n         }\\n         i++;\\n         j--;\\n      }\\n      \\n      return true;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2605389,
                "title": "python-3-without-bitmask-simple-backtracking-dp-approach",
                "content": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        sz, ans, s1, s2 = len(s), 0, \\'\\', \\'\\'\\n        \\n        @lru_cache(None)\\n        def solve(i: int, s1: str, s2: str) -> None:\\n            nonlocal ans, s\\n            if i >= sz:\\n                if s1 == s1[::-1] and s2 == s2[::-1]:\\n                    ans = max(ans, len(s1) * len(s2))\\n                return\\n            solve(i + 1, s1, s2)\\n            s1_pick, s2_pick = s1 + s[i], s2 + s[i]\\n            solve(i + 1, s1_pick, s2)\\n            solve(i + 1, s1, s2_pick)\\n            \\n        solve(0, s1, s2)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        sz, ans, s1, s2 = len(s), 0, \\'\\', \\'\\'\\n        \\n        @lru_cache(None)\\n        def solve(i: int, s1: str, s2: str) -> None:\\n            nonlocal ans, s\\n            if i >= sz:\\n                if s1 == s1[::-1] and s2 == s2[::-1]:\\n                    ans = max(ans, len(s1) * len(s2))\\n                return\\n            solve(i + 1, s1, s2)\\n            s1_pick, s2_pick = s1 + s[i], s2 + s[i]\\n            solve(i + 1, s1_pick, s2)\\n            solve(i + 1, s1, s2_pick)\\n            \\n        solve(0, s1, s2)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434061,
                "title": "c-simple-c-code",
                "content": "\\n\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int n, ans = -1;\\n    bool isPalindrome(string &p)\\n    {\\n        int i = 0, j = p.size()-1;\\n        while(i <= j)\\n        {\\n            if(p[i] == p[j])\\n            {\\n                i++;\\n                j--;\\n            }\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n    void dfs(string &s, string &a, string &b, int idx)\\n    {\\n        if(idx == n)\\n        {\\n            if(isPalindrome(a) && isPalindrome(b)){\\n                int val = a.size()*b.size();\\n                ans = max(val, ans);\\n            }\\n            return;\\n        }\\n        a.push_back(s[idx]);\\n        dfs(s, a, b, idx+1);\\n        a.pop_back();\\n        b.push_back(s[idx]);\\n        dfs(s, a, b, idx+1);\\n        b.pop_back();\\n        dfs(s, a, b, idx+1);\\n    }\\npublic:\\n    int maxProduct(string s) {\\n        n = s.size();\\n        string a = \"\", b = \"\";\\n        dfs(s, a, b, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int n, ans = -1;\\n    bool isPalindrome(string &p)\\n    {\\n        int i = 0, j = p.size()-1;\\n        while(i <= j)\\n        {\\n            if(p[i] == p[j])\\n            {\\n                i++;\\n                j--;\\n            }\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n    void dfs(string &s, string &a, string &b, int idx)\\n    {\\n        if(idx == n)\\n        {\\n            if(isPalindrome(a) && isPalindrome(b)){\\n                int val = a.size()*b.size();\\n                ans = max(val, ans);\\n            }\\n            return;\\n        }\\n        a.push_back(s[idx]);\\n        dfs(s, a, b, idx+1);\\n        a.pop_back();\\n        b.push_back(s[idx]);\\n        dfs(s, a, b, idx+1);\\n        b.pop_back();\\n        dfs(s, a, b, idx+1);\\n    }\\npublic:\\n    int maxProduct(string s) {\\n        n = s.size();\\n        string a = \"\", b = \"\";\\n        dfs(s, a, b, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277403,
                "title": "c-bitmasking",
                "content": "class Solution {\\npublic:\\n    int maxProduct(string s) {\\n        map<int ,int> m; //<bitmask,length>\\n            int n=s.length();\\n        \\n            for(int mask=1;mask<(1<<n);mask++)\\n            {\\n                string subseq=\"\";\\n                for(int i=0;i<n;i++)\\n                {\\n                    if(mask &  (1<<i))\\n                    {\\n                        subseq+=s[i];\\n                    }\\n                }\\n                string chk=subseq;\\n                reverse(chk.begin(),chk.end());\\n                if((subseq)==chk)\\n                {\\n                    m[mask]=subseq.length();\\n                }\\n                \\n            }\\n        int ans=0;\\n        for(auto m1:m)\\n        {\\n            for(auto m2:m)\\n            {\\n                if(((m1.first)&(m2.first))==0)\\n                    ans=max(ans,(m1.second)*(m2.second));\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    int maxProduct(string s) {\\n        map<int ,int> m; //<bitmask,length>\\n            int n=s.length();\\n        \\n            for(int mask=1;mask<(1<<n);mask++)\\n            {\\n                string subseq=\"\";\\n                for(int i=0;i<n;i++)\\n                {\\n                    if(mask &  (1<<i))\\n                    {\\n                        subseq+=s[i];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2257917,
                "title": "c-backtracking-explained",
                "content": "```\\n/*\\nwe will try out all possibilities through recursion \\nbase condition will be where we would have \\ntraversed through the whole string , \\nthis is the point where we will check whether\\nour 2 subsequences are palindromic , and \\nif yes , then we will compare the product \\nof the lengths of 2 strings with our ans\\n\\n\\nrecurrence realation will contain three recursive calls , \\nfirst for not inlcuding s[i] in both the strings \\nsecond for inlcuding s[i] in the string s1\\nthird for inlcuding s[i] in the string s2\\n\\nand we will get our ans recursively\\n\\n*/\\nclass Solution {\\npublic:\\n    bool ispalindrome(string s){\\n    int i = 0,j = s.size()-1;\\n    while(i<j){\\n        if(s[i]!=s[j]) return false;\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n    \\n    void solve(string &s , string &s1 , string &s2 , int i , int &ans){\\n        if(i>=s.size()){\\n            if(ispalindrome(s1) && ispalindrome(s2)){\\n                int x=s1.size()*s2.size();\\n                ans=max(ans,x);\\n                \\n            }\\n            return ;\\n        }\\n        \\n//*******************************************************************************  \\n        \\n        // here we have not used backtracking , \\n        //but here we will not able to use &s1/&s2  ,\\n        //ie reference based addressing , and \\n        //therefore a new copy of s1 and s2 will be made each time\\n        //, resulting in TLE\\n        \\n//         // we dont add in either of the strings\\n//         solve(s,s1,s2,i+1,ans);\\n        \\n//         // adding in s1;\\n//         solve(s,s1+s[i],s2,i+1,ans);\\n        \\n//         // adding in s2\\n//         solve(s,s1,s2+s[i],i+1,ans);\\n//*******************************************************************************     \\n\\n           // we dont add in either of the strings\\n            solve(s,s1,s2,i+1,ans);\\n    \\n            //pic in first string s1\\n            s1.push_back(s[i]);\\n            solve(s,s1,s2,i+1,ans);\\n            s1.pop_back();\\n\\n            //pic in second string s2\\n            s2.push_back(s[i]);\\n            solve(s,s1,s2,i+1,ans);\\n            s2.pop_back();\\n    \\n    }\\n\\n    int maxProduct(string s) {\\n        string s1=\"\";\\n        string s2=\"\";\\n        int ans=0;\\n        solve(s,s1,s2,0,ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    bool ispalindrome(string s){\\n    int i = 0,j = s.size()-1;\\n    while(i<j){\\n        if(s[i]!=s[j]) return false;\\n        i++;\\n        j--;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2156274,
                "title": "c-lps-and-brute-force",
                "content": "***upvote if you find it helpful :)***\\n```\\nclass Solution {\\npublic:\\n    \\n    int LPS(string s){ //To find the longest palindrome of a given string\\n        \\n        if( s.size() == 1 ) return 1;\\n        int n = s.size();\\n        int dp[n][n];\\n        memset(dp,0,sizeof(dp));\\n        \\n        for(int i = 0; i < n; i++) dp[i][i]=1;\\n         \\n        for(int i = 1; i < n; i++){\\n            for(int j = 0,k = i; j < n-i; j++){\\n                k = i+j;\\n                if( s[j] == s[k] )\\n                    dp[j][k] = dp[j+1][k-1]+2;\\n                else\\n                    dp[j][k] = max(dp[j][k-1],dp[j+1][k]);\\n            }\\n        }\\n        \\n        return dp[0][n-1];\\n    }\\n    int maxProduct(string s) {\\n        int ans = 0, len = s.size();\\n        // Generate all subsequences of the String\\n        for(int i = 1; i < pow(2,len-1); i++){\\n            string p = \"\", q = \"\";\\n            for(int j = 0; j < len; j++){\\n                if( i & 1<<j ) p+=s[j];\\n                else q+=s[j];\\n            }\\n            ans = max(ans, LPS(p)*LPS(q));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int LPS(string s){ //To find the longest palindrome of a given string\\n        \\n        if( s.size() == 1 ) return 1;\\n        int n = s.size();\\n        int dp[n][n];\\n        memset(dp,0,sizeof(dp));\\n        \\n        for(int i = 0; i < n; i++) dp[i][i]=1;\\n         \\n        for(int i = 1; i < n; i++){\\n            for(int j = 0,k = i; j < n-i; j++){\\n                k = i+j;\\n                if( s[j] == s[k] )\\n                    dp[j][k] = dp[j+1][k-1]+2;\\n                else\\n                    dp[j][k] = max(dp[j][k-1],dp[j+1][k]);\\n            }\\n        }\\n        \\n        return dp[0][n-1];\\n    }\\n    int maxProduct(string s) {\\n        int ans = 0, len = s.size();\\n        // Generate all subsequences of the String\\n        for(int i = 1; i < pow(2,len-1); i++){\\n            string p = \"\", q = \"\";\\n            for(int j = 0; j < len; j++){\\n                if( i & 1<<j ) p+=s[j];\\n                else q+=s[j];\\n            }\\n            ans = max(ans, LPS(p)*LPS(q));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860445,
                "title": "all-3-solutions-brute-optimizations-clean-and-concise-bits",
                "content": "#### **1. Using Bits as a visitied array total brute force**\\n\\n```\\nclass Solution {\\npublic:\\n    bool check(string &s){\\n        int i=0,j=s.size()-1;\\n        \\n        while(i < j){\\n            if(s[i] != s[j])  return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    int fun2(int i,int vis_,int vis,string &s){\\n        \\n        if(i == s.size()){\\n            \\n            string tmp;\\n            \\n            for(int i=0;i<s.size();i++){\\n                int mask = (1 << i);\\n                if((mask & vis_) != 0){\\n                    tmp.push_back(s[i]);\\n                }\\n            }\\n            if(check(tmp)) return tmp.size();\\n            return 0;\\n        }\\n        \\n        \\n        int mask = (1 << i);\\n        \\n        if((mask & vis) == 0){\\n            int left = fun2(i+1,vis_|mask,vis|mask,s);\\n            int right = fun2(i+1,vis_,vis,s);\\n            return max(left,right);\\n        }\\n        return fun2(i+1,vis_,vis,s);\\n    }\\n    \\n    int fun1(int i,int vis,string &s){\\n        \\n        int n = s.size();\\n        if(i == n){\\n            \\n            int len = fun2(0,0,vis,s);\\n            \\n            string tmp;\\n            \\n            for(int i=0;i<s.size();i++){\\n                int mask = (1 << i);\\n                if((mask & vis) != 0){\\n                    tmp.push_back(s[i]);\\n                }\\n            }\\n            if(check(tmp)){\\n                return (len)*(tmp.size());   \\n            }\\n            return 0;\\n        } \\n        \\n        \\n        int mask = (1 << i);\\n        int left = fun1(i+1,mask | vis,s);\\n        int right = fun1(i+1,vis,s);\\n        \\n        return max(left,right);\\n    \\n    }\\n    \\n    int maxProduct(string s) {\\n        return fun1(0,0,s);\\n        \\n    }\\n\\t\\n```\\n\\n### 2. Using Longest Common Subsequence\\n\\n```\\n\\tclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int LCS(int i,int j,string &s1,string &s2){\\n        \\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        \\n        if(i == n1 or j == n2){\\n            return 0;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s1[i] == s2[j]){\\n            return dp[i][j] = 1 + LCS(i+1,j+1,s1,s2);\\n        }\\n        \\n        return dp[i][j] = max(LCS(i+1,j,s1,s2),LCS(i,j+1,s1,s2));\\n        \\n    }\\n    \\n    int LPS(string &s){\\n        string t = s;\\n        reverse(s.begin(),s.end());\\n        dp = vector<vector<int>> (s.size(),vector<int> (s.size(),-1));\\n        return LCS(0,0,s,t);\\n    }\\n\\n    int fun1(int i,int vis,string &s){\\n        \\n        int n = s.size();\\n        if(i == n){\\n            string s1,s2;\\n            for(int j=0;j<n;j++){\\n                int mask = (1 << j);\\n                if((vis & mask ) == 0){\\n                    s2.push_back(s[j]);\\n                }else{\\n                    s1.push_back(s[j]);\\n                }\\n            }        \\n            return LPS(s1)*LPS(s2);\\n        } \\n        \\n        int mask = (1 << i);\\n        int left = fun1(i+1,mask | vis,s);\\n        int right = fun1(i+1,vis,s);\\n        \\n        return max(left,right);\\n    \\n    }\\n    \\n    int maxProduct(string s) {\\n        int n = s.size();\\n        return fun1(0,0,s);\\n    }\\n};\\n\\n```\\n\\n### 3. Using Longest Palindromic Subsequence\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    \\n    int LPS_(int i,int j,string &s){\\n        \\n        if(i > j) return 0;\\n        if(i==j) return 1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s[i] == s[j]){\\n            return dp[i][j] = 2 + LPS_(i+1,j-1,s);\\n        }\\n        return dp[i][j] = max(LPS_(i+1,j,s),LPS_(i,j-1,s));\\n    }\\n    \\n    int LPS(string &s){\\n        dp = vector<vector<int>> (s.size(),vector<int> (s.size(),-1));\\n        return LPS_(0,s.size()-1,s);\\n    }\\n\\n    int fun1(int i,int vis,string &s){\\n        \\n        int n = s.size();\\n        if(i == n){\\n            string s1,s2;\\n            for(int j=0;j<n;j++){\\n                int mask = (1 << j);\\n                if((vis & mask ) == 0){\\n                    s2.push_back(s[j]);\\n                }else{\\n                    s1.push_back(s[j]);\\n                }\\n            }        \\n            return LPS(s1)*LPS(s2);\\n        } \\n        \\n        int mask = (1 << i);\\n        int left = fun1(i+1,mask | vis,s);\\n        int right = fun1(i+1,vis,s);\\n        \\n        return max(left,right);\\n    \\n    }\\n    \\n    int maxProduct(string s) {\\n        int n = s.size();\\n        return fun1(0,0,s);\\n    }\\n};\\n\\t\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string &s){\\n        int i=0,j=s.size()-1;\\n        \\n        while(i < j){\\n            if(s[i] != s[j])  return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    int fun2(int i,int vis_,int vis,string &s){\\n        \\n        if(i == s.size()){\\n            \\n            string tmp;\\n            \\n            for(int i=0;i<s.size();i++){\\n                int mask = (1 << i);\\n                if((mask & vis_) != 0){\\n                    tmp.push_back(s[i]);\\n                }\\n            }\\n            if(check(tmp)) return tmp.size();\\n            return 0;\\n        }\\n        \\n        \\n        int mask = (1 << i);\\n        \\n        if((mask & vis) == 0){\\n            int left = fun2(i+1,vis_|mask,vis|mask,s);\\n            int right = fun2(i+1,vis_,vis,s);\\n            return max(left,right);\\n        }\\n        return fun2(i+1,vis_,vis,s);\\n    }\\n    \\n    int fun1(int i,int vis,string &s){\\n        \\n        int n = s.size();\\n        if(i == n){\\n            \\n            int len = fun2(0,0,vis,s);\\n            \\n            string tmp;\\n            \\n            for(int i=0;i<s.size();i++){\\n                int mask = (1 << i);\\n                if((mask & vis) != 0){\\n                    tmp.push_back(s[i]);\\n                }\\n            }\\n            if(check(tmp)){\\n                return (len)*(tmp.size());   \\n            }\\n            return 0;\\n        } \\n        \\n        \\n        int mask = (1 << i);\\n        int left = fun1(i+1,mask | vis,s);\\n        int right = fun1(i+1,vis,s);\\n        \\n        return max(left,right);\\n    \\n    }\\n    \\n    int maxProduct(string s) {\\n        return fun1(0,0,s);\\n        \\n    }\\n\\t\\n```\n```\\n\\tclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int LCS(int i,int j,string &s1,string &s2){\\n        \\n        int n1 = s1.size();\\n        int n2 = s2.size();\\n        \\n        if(i == n1 or j == n2){\\n            return 0;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s1[i] == s2[j]){\\n            return dp[i][j] = 1 + LCS(i+1,j+1,s1,s2);\\n        }\\n        \\n        return dp[i][j] = max(LCS(i+1,j,s1,s2),LCS(i,j+1,s1,s2));\\n        \\n    }\\n    \\n    int LPS(string &s){\\n        string t = s;\\n        reverse(s.begin(),s.end());\\n        dp = vector<vector<int>> (s.size(),vector<int> (s.size(),-1));\\n        return LCS(0,0,s,t);\\n    }\\n\\n    int fun1(int i,int vis,string &s){\\n        \\n        int n = s.size();\\n        if(i == n){\\n            string s1,s2;\\n            for(int j=0;j<n;j++){\\n                int mask = (1 << j);\\n                if((vis & mask ) == 0){\\n                    s2.push_back(s[j]);\\n                }else{\\n                    s1.push_back(s[j]);\\n                }\\n            }        \\n            return LPS(s1)*LPS(s2);\\n        } \\n        \\n        int mask = (1 << i);\\n        int left = fun1(i+1,mask | vis,s);\\n        int right = fun1(i+1,vis,s);\\n        \\n        return max(left,right);\\n    \\n    }\\n    \\n    int maxProduct(string s) {\\n        int n = s.size();\\n        return fun1(0,0,s);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764675,
                "title": "dfs-c-backtracking",
                "content": "class Solution {\\npublic:\\n    void dfs(string &s,int i,string &s1,string &s2,int &c){ \\n       \\n\\t   if(i>=s.size()){\\n            if(ispalindrome(s1) && ispalindrome(s2)){\\n                int x = s1.size()*s2.size();\\n                c = max(x,c);\\n            }\\n            return;\\n        }\\n        //not pic any \\n        dfs(s,i+1,s1,s2,c);\\n        \\n        //pic in first string s1\\n        s1.push_back(s[i]);\\n        dfs(s,i+1,s1,s2,c);\\n        s1.pop_back();\\n        \\n        //pic in second string s2\\n        s2.push_back(s[i]);\\n        dfs(s,i+1,s1,s2,c);\\n        s2.pop_back();\\n        \\n    }\\n    bool ispalindrome(string s){\\n        int i = 0,j = s.size()-1;\\n        while(i<j){\\n            if(s[i]!=s[j]) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    int maxProduct(string s) {\\n        string s1 = \"\",s2 = \"\";\\n        int c = 0;\\n        dfs(s,0,s1,s2,c);\\n        return c;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    void dfs(string &s,int i,string &s1,string &s2,int &c){ \\n       \\n\\t   if(i>=s.size()){\\n            if(ispalindrome(s1) && ispalindrome(s2)){\\n                int x = s1.size()*s2.size();\\n                c = max(x,c);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1487213,
                "title": "c-backtracking-solution",
                "content": "```\\n\\n#include<bits/stdc++.h>\\nusing namespace std;\\nint ans;\\n\\nbool ispal(string &s)\\n{\\n    int i = 0 , j = s.length() - 1;\\n    while(i < j){\\n        if(s[i] != s[j]) return false;\\n        ++i;\\n        --j;\\n    }\\n    return true;\\n}\\n\\nvoid solve(int index , string &s , string &s1, string &s2)\\n{\\n\\n    /// add this char to s1 or s2 or skip.\\n    if(ispal(s1) and ispal(s2))\\n    {\\n        int len1 = s1.length();\\n        int len2 = s2.length();\\n        int len  = len1 * len2;\\n        ans = max(ans , len);\\n    }\\n    if(index == s.length()) return;\\n    s1 = s1 + s[index];\\n    solve(index + 1 , s , s1 , s2);\\n    s1.pop_back();\\n    s2 = s2 + s[index];\\n    solve(index + 1, s , s1 , s2);\\n    s2.pop_back();\\n    solve(index + 1 , s , s1 , s2);\\n}\\n\\nclass Solution {\\npublic:\\n    int maxProduct(string s) {\\n        ans = 0;\\n        string s1 = \"\" , s2 = \"\" ;\\n        solve(0 , s, s1 , s2);\\n        return ans; \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n#include<bits/stdc++.h>\\nusing namespace std;\\nint ans;\\n\\nbool ispal(string &s)\\n{\\n    int i = 0 , j = s.length() - 1;\\n    while(i < j){\\n        if(s[i] != s[j]) return false;\\n        ++i;\\n        --j;\\n    }\\n    return true;\\n}\\n\\nvoid solve(int index , string &s , string &s1, string &s2)\\n{\\n\\n    /// add this char to s1 or s2 or skip.\\n    if(ispal(s1) and ispal(s2))\\n    {\\n        int len1 = s1.length();\\n        int len2 = s2.length();\\n        int len  = len1 * len2;\\n        ans = max(ans , len);\\n    }\\n    if(index == s.length()) return;\\n    s1 = s1 + s[index];\\n    solve(index + 1 , s , s1 , s2);\\n    s1.pop_back();\\n    s2 = s2 + s[index];\\n    solve(index + 1, s , s1 , s2);\\n    s2.pop_back();\\n    solve(index + 1 , s , s1 , s2);\\n}\\n\\nclass Solution {\\npublic:\\n    int maxProduct(string s) {\\n        ans = 0;\\n        string s1 = \"\" , s2 = \"\" ;\\n        solve(0 , s, s1 , s2);\\n        return ans; \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1463790,
                "title": "backtracking-explained-solution-c",
                "content": "just see the constraint for this question its very small so this signifies that this will be a backtracking question.\\n\\nlets assume my s1 will have the 1st palindrome string and s2 will have the second one.\\n\\ni am finding the max of a,b,c where a denotes when i am not not adding any values.\\nb denotes i am pushing value in s1 \\nc denotes i am pushing value in s2;\\n\\nthe required answer will be the max of (a,b,c)\\n\\n\\n\\n\\n```\\n int palinlen (string &a)\\n   {\\n       int i=0;\\n       int j=a.length()-1;\\n       while(i<j)\\n       {\\n           if(a[i]!=a[j])return 0;\\n           i++;\\n           j--;\\n       }\\n       return a.length();\\n   }\\n    \\n    \\n    int helper(string &a,string &b,string &s,int i)\\n    {\\n        if(i>=s.length())return palinlen(a)*palinlen(b);\\n        \\n        int x=helper(a,b,s,i+1);\\n        \\n        a.push_back(s[i]);\\n        int y=helper(a,b,s,i+1);\\n        a.pop_back();\\n        \\n        b.push_back(s[i]);\\n        int z=helper(a,b,s,i+1);\\n        b.pop_back();\\n        return max(x,max(y,z));\\n        \\n    }\\n    int maxProduct(string s) {\\n        string a=\"\";\\n        string b=\"\";\\n        return helper(a,b,s,0);\\n    }\\n```\\n\\n\\nplease upvote if you liked my solution.\\n#happy_coding",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n int palinlen (string &a)\\n   {\\n       int i=0;\\n       int j=a.length()-1;\\n       while(i<j)\\n       {\\n           if(a[i]!=a[j])return 0;\\n           i++;\\n           j--;\\n       }\\n       return a.length();\\n   }\\n    \\n    \\n    int helper(string &a,string &b,string &s,int i)\\n    {\\n        if(i>=s.length())return palinlen(a)*palinlen(b);\\n        \\n        int x=helper(a,b,s,i+1);\\n        \\n        a.push_back(s[i]);\\n        int y=helper(a,b,s,i+1);\\n        a.pop_back();\\n        \\n        b.push_back(s[i]);\\n        int z=helper(a,b,s,i+1);\\n        b.pop_back();\\n        return max(x,max(y,z));\\n        \\n    }\\n    int maxProduct(string s) {\\n        string a=\"\";\\n        string b=\"\";\\n        return helper(a,b,s,0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1461312,
                "title": "a-few-solutions",
                "content": "Let `A` and `B` be the first and second candidate palindrome strings correspondingly.  Perform DFS + BT considering all possibilities for each character `s[i]`:\\n\\n1. `s[i]` is included in `A`\\n2. `s[i]` is included in `B`\\n3. `s[i]` is *not* included in `A` or `B`\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maxProduct(s: String): Int {\\n        var best = 0\\n        var ok = { A: MutableList<Char> -> A == A.reversed() }\\n        fun go(i: Int = 0, A: MutableList<Char> = mutableListOf<Char>(), B: MutableList<Char> = mutableListOf<Char>()) {\\n            if (ok(A) && ok(B))\\n                best = Math.max(best, A.size * B.size)\\n            if (i == s.length)\\n                return\\n            A.add(s[i])\\n            go(i + 1, A, B)\\n            A.removeAt(A.lastIndex)\\n            B.add(s[i])\\n            go(i + 1, A, B)\\n            B.removeAt(B.lastIndex)\\n            go(i + 1, A, B)\\n        }\\n        go()\\n        return best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maxProduct = (s, best = 0) => {\\n    let ok = A => A.join(\\'\\') == [...A].reverse().join(\\'\\');\\n    let go = (i = 0, A = [], B = []) => {\\n        if (ok(A) && ok(B))\\n            best = Math.max(best, A.length * B.length);\\n        if (i == s.length)\\n            return;\\n        A.push(s[i]);\\n        go(i + 1, A, B);\\n        A.pop();\\n        B.push(s[i]);\\n        go(i + 1, A, B);\\n        B.pop();\\n        go(i + 1, A, B);\\n    };\\n    go();\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maxProduct(self, s: str, best = 0) -> int:\\n        ok = lambda A: A == A[::-1]\\n        def go(i = 0, A = [], B = []):\\n            nonlocal best\\n            if ok(A) and ok(B):\\n                best = max(best, len(A) * len(B))\\n            if i == len(s):\\n                return\\n            A.append(s[i])\\n            go(i + 1, A, B)\\n            A.pop()\\n            B.append(s[i])\\n            go(i + 1, A, B)\\n            B.pop()\\n            go(i + 1, A, B)\\n        go()\\n        return best\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using fun = function<void(int, string&&, string&&)>;\\n    int maxProduct(string s, int best = 0) {\\n        auto ok = [](auto& s) {\\n            int N = s.size(),\\n                i = 0,\\n                j = N - 1;\\n            while (i < j && s[i] == s[j])\\n                ++i, --j;\\n            return j <= i;\\n        };\\n        fun go = [&](auto i, auto&& A, auto&& B) {\\n            if (ok(A) && ok(B))\\n                best = max(best, int(A.size() * B.size()));\\n            if (i == s.size())\\n                return;\\n            A.push_back(s[i]);\\n            go(i + 1, move(A), move(B));\\n            A.pop_back();\\n            B.push_back(s[i]);\\n            go(i + 1, move(A), move(B));\\n            B.pop_back();\\n            go(i + 1, move(A), move(B));\\n        };\\n        go(0, {}, {});\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maxProduct(s: String): Int {\\n        var best = 0\\n        var ok = { A: MutableList<Char> -> A == A.reversed() }\\n        fun go(i: Int = 0, A: MutableList<Char> = mutableListOf<Char>(), B: MutableList<Char> = mutableListOf<Char>()) {\\n            if (ok(A) && ok(B))\\n                best = Math.max(best, A.size * B.size)\\n            if (i == s.length)\\n                return\\n            A.add(s[i])\\n            go(i + 1, A, B)\\n            A.removeAt(A.lastIndex)\\n            B.add(s[i])\\n            go(i + 1, A, B)\\n            B.removeAt(B.lastIndex)\\n            go(i + 1, A, B)\\n        }\\n        go()\\n        return best\\n    }\\n}\\n```\n```\\nlet maxProduct = (s, best = 0) => {\\n    let ok = A => A.join(\\'\\') == [...A].reverse().join(\\'\\');\\n    let go = (i = 0, A = [], B = []) => {\\n        if (ok(A) && ok(B))\\n            best = Math.max(best, A.length * B.length);\\n        if (i == s.length)\\n            return;\\n        A.push(s[i]);\\n        go(i + 1, A, B);\\n        A.pop();\\n        B.push(s[i]);\\n        go(i + 1, A, B);\\n        B.pop();\\n        go(i + 1, A, B);\\n    };\\n    go();\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def maxProduct(self, s: str, best = 0) -> int:\\n        ok = lambda A: A == A[::-1]\\n        def go(i = 0, A = [], B = []):\\n            nonlocal best\\n            if ok(A) and ok(B):\\n                best = max(best, len(A) * len(B))\\n            if i == len(s):\\n                return\\n            A.append(s[i])\\n            go(i + 1, A, B)\\n            A.pop()\\n            B.append(s[i])\\n            go(i + 1, A, B)\\n            B.pop()\\n            go(i + 1, A, B)\\n        go()\\n        return best\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<void(int, string&&, string&&)>;\\n    int maxProduct(string s, int best = 0) {\\n        auto ok = [](auto& s) {\\n            int N = s.size(),\\n                i = 0,\\n                j = N - 1;\\n            while (i < j && s[i] == s[j])\\n                ++i, --j;\\n            return j <= i;\\n        };\\n        fun go = [&](auto i, auto&& A, auto&& B) {\\n            if (ok(A) && ok(B))\\n                best = max(best, int(A.size() * B.size()));\\n            if (i == s.size())\\n                return;\\n            A.push_back(s[i]);\\n            go(i + 1, move(A), move(B));\\n            A.pop_back();\\n            B.push_back(s[i]);\\n            go(i + 1, move(A), move(B));\\n            B.pop_back();\\n            go(i + 1, move(A), move(B));\\n        };\\n        go(0, {}, {});\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1459133,
                "title": "c-recursion-backtracking-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint ans = 0;\\n\\tint n;\\n\\t//function for checking is given string is Palindrome\\n\\tbool palindrome(string s)\\n\\t{\\n\\t\\tint i = 0;\\n\\t\\tint j = s.size() - 1;\\n\\t\\twhile (i <= j)\\n\\t\\t{\\n\\t\\t\\tif (s[i++] != s[j--])\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tvoid solve(int index, string &s, string &s1, string &s2)\\n\\t{\\n\\t\\t//If index >= n (where n = s.size()) then return\\n\\t\\tif (index >= n)\\n\\t\\t{\\n\\t\\t\\t//If both s1 and s2 are palindrome then this is as required in problem\\n\\t\\t\\t//so update ans with ans = max(ans, s1.size() * s2.size());\\n\\t\\t\\tif (palindrome(s1) && palindrome(s2))\\n\\t\\t\\t{\\n\\t\\t\\t\\tans = max(ans, (int)s1.size() * (int)s2.size());\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t//1. include s[index]\\n\\t\\t\\t//1.(i) adding s[index] in string s1\\n\\t\\t\\ts1.push_back(s[index]);\\n\\t\\t\\tsolve(index + 1, s, s1, s2);\\n\\t\\t\\ts1.pop_back();\\n\\t\\t\\t//1.(ii) adding s[index] in string s2\\n\\t\\t\\ts2.push_back(s[index]);\\n\\t\\t\\tsolve(index + 1, s, s1, s2);\\n\\t\\t\\ts2.pop_back();\\n\\n\\t\\t//2. not including s[index] in string generation\\n\\t\\tsolve(index + 1, s, s1, s2);\\n\\t}\\n\\n\\tint maxProduct(string s) {\\n\\t\\tint index = 0;\\n\\t\\tn = s.size();\\n\\t\\tstring s1 = \"\";\\n\\t\\tstring s2 = \"\";\\n\\t\\tsolve(index, s, s1, s2);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n\\n**If find Helpful *Upvote It* \\uD83D\\uDC4D**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint ans = 0;\\n\\tint n;\\n\\t//function for checking is given string is Palindrome\\n\\tbool palindrome(string s)\\n\\t{\\n\\t\\tint i = 0;\\n\\t\\tint j = s.size() - 1;\\n\\t\\twhile (i <= j)\\n\\t\\t{\\n\\t\\t\\tif (s[i++] != s[j--])\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tvoid solve(int index, string &s, string &s1, string &s2)\\n\\t{\\n\\t\\t//If index >= n (where n = s.size()) then return\\n\\t\\tif (index >= n)\\n\\t\\t{\\n\\t\\t\\t//If both s1 and s2 are palindrome then this is as required in problem\\n\\t\\t\\t//so update ans with ans = max(ans, s1.size() * s2.size());\\n\\t\\t\\tif (palindrome(s1) && palindrome(s2))\\n\\t\\t\\t{\\n\\t\\t\\t\\tans = max(ans, (int)s1.size() * (int)s2.size());\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t//1. include s[index]\\n\\t\\t\\t//1.(i) adding s[index] in string s1\\n\\t\\t\\ts1.push_back(s[index]);\\n\\t\\t\\tsolve(index + 1, s, s1, s2);\\n\\t\\t\\ts1.pop_back();\\n\\t\\t\\t//1.(ii) adding s[index] in string s2\\n\\t\\t\\ts2.push_back(s[index]);\\n\\t\\t\\tsolve(index + 1, s, s1, s2);\\n\\t\\t\\ts2.pop_back();\\n\\n\\t\\t//2. not including s[index] in string generation\\n\\t\\tsolve(index + 1, s, s1, s2);\\n\\t}\\n\\n\\tint maxProduct(string s) {\\n\\t\\tint index = 0;\\n\\t\\tn = s.size();\\n\\t\\tstring s1 = \"\";\\n\\t\\tstring s2 = \"\";\\n\\t\\tsolve(index, s, s1, s2);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458546,
                "title": "dp-in-python",
                "content": "We may use dp to enumerate the first palindromic sequence. Since the maximum length of the original string is only 12 - the iteration goes up to `2**12=4096` times. Actually, small sized problem should always remind you to think about brute force.\\n\\nAfter that, just try to find the longest palindromic subsequence in the rest characters. That\\'s a classic problem. You can find the exact same problem here https://leetcode.com/problems/longest-palindromic-subsequence/.\\n```\\nclass Solution:\\n    def maxPalindrome(self, s):\\n        n = len(s)\\n        dp = [[0] * n for _ in range(n)]\\n        for i in range(n):\\n            dp[i][i] = 1\\n        for i in range(n - 1, -1, -1):\\n            for j in range(i + 1, n):\\n                if s[i] == s[j]:\\n                    dp[i][j] = dp[i+1][j-1]+2\\n                else:\\n                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])\\n        return dp[0][n-1]\\n\\n    def maxProduct(self, s: str) -> int:\\n        ans = 1\\n        for i in range(1, 2**len(s)+1):\\n            first = \\'\\'\\n            remain = \\'\\'\\n            for j in range(len(s)):\\n                if i & (2**j):\\n                    first += s[j]\\n                else:\\n                    remain += s[j]\\n            if first != first[::-1] or not remain:\\n                continue\\n            ans = max(ans, len(first) * self.maxPalindrome(remain))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxPalindrome(self, s):\\n        n = len(s)\\n        dp = [[0] * n for _ in range(n)]\\n        for i in range(n):\\n            dp[i][i] = 1\\n        for i in range(n - 1, -1, -1):\\n            for j in range(i + 1, n):\\n                if s[i] == s[j]:\\n                    dp[i][j] = dp[i+1][j-1]+2\\n                else:\\n                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])\\n        return dp[0][n-1]\\n\\n    def maxProduct(self, s: str) -> int:\\n        ans = 1\\n        for i in range(1, 2**len(s)+1):\\n            first = \\'\\'\\n            remain = \\'\\'\\n            for j in range(len(s)):\\n                if i & (2**j):\\n                    first += s[j]\\n                else:\\n                    remain += s[j]\\n            if first != first[::-1] or not remain:\\n                continue\\n            ans = max(ans, len(first) * self.maxPalindrome(remain))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458487,
                "title": "simple-java-dp-solution-top-down-recursion",
                "content": "```\\nclass Solution {\\n    public int maxProduct(String s) {\\n        return maxProduct(s, 0, \"\",\"\");\\n    }\\n    Map<String, Integer> dp = new HashMap<>();\\n    public int maxProduct(String s, int ci, String s1, String s2) {\\n        int max = 0;\\n        String key = ci+\"_\"+s1 +\"_\"+s2;\\n        \\n        if(dp.containsKey(key))\\n            return dp.get(key);\\n        if(ci==s.length()){\\n            if(s1.length()>0 && s2.length()>0 && isPalindrome(s1) && isPalindrome(s2)){\\n                return s1.length()*s2.length();\\n            }\\n            return max;\\n        }\\n        max = Math.max(Math.max(maxProduct(s, ci+1, s1+s.charAt(ci), s2),\\n        maxProduct(s, ci+1, s1, s2+s.charAt(ci))), maxProduct(s, ci+1, s1, s2));\\n        dp.put(key, max);\\n        return max;\\n    }\\n    boolean isPalindrome(String s){\\n        int start = 0, end = s.length()-1;\\n        while(start<end){\\n            if(s.charAt(start)!=s.charAt(end))\\n                return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProduct(String s) {\\n        return maxProduct(s, 0, \"\",\"\");\\n    }\\n    Map<String, Integer> dp = new HashMap<>();\\n    public int maxProduct(String s, int ci, String s1, String s2) {\\n        int max = 0;\\n        String key = ci+\"_\"+s1 +\"_\"+s2;\\n        \\n        if(dp.containsKey(key))\\n            return dp.get(key);\\n        if(ci==s.length()){\\n            if(s1.length()>0 && s2.length()>0 && isPalindrome(s1) && isPalindrome(s2)){\\n                return s1.length()*s2.length();\\n            }\\n            return max;\\n        }\\n        max = Math.max(Math.max(maxProduct(s, ci+1, s1+s.charAt(ci), s2),\\n        maxProduct(s, ci+1, s1, s2+s.charAt(ci))), maxProduct(s, ci+1, s1, s2));\\n        dp.put(key, max);\\n        return max;\\n    }\\n    boolean isPalindrome(String s){\\n        int start = 0, end = s.length()-1;\\n        while(start<end){\\n            if(s.charAt(start)!=s.charAt(end))\\n                return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458482,
                "title": "python-simple-solution-backtracking",
                "content": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        self.answer = 0\\n        \\n        def dfs(i, word, word2):\\n            if i >= len(s):\\n                if word == word[::-1] and word2 == word2[::-1]:\\n                    self.answer = max(len(word) * len(word2), self.answer)\\n                return\\n            \\n            dfs(i + 1, word + s[i], word2)\\n            dfs(i + 1, word, word2 + s[i])\\n            dfs(i + 1, word, word2)\\n            \\n        dfs(0, \\'\\', \\'\\')\\n        \\n        return self.answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        self.answer = 0\\n        \\n        def dfs(i, word, word2):\\n            if i >= len(s):\\n                if word == word[::-1] and word2 == word2[::-1]:\\n                    self.answer = max(len(word) * len(word2), self.answer)\\n                return\\n            \\n            dfs(i + 1, word + s[i], word2)\\n            dfs(i + 1, word, word2 + s[i])\\n            dfs(i + 1, word, word2)\\n            \\n        dfs(0, \\'\\', \\'\\')\\n        \\n        return self.answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458376,
                "title": "easy-brute-force-solution-in-c",
                "content": "\\n\\n```\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(string str)\\n    {\\n        // Start from leftmost and rightmost corners of str\\n        int l = 0;\\n        int h = str.size()-1;\\n\\n        // Keep comparing characters while they are same\\n        while (h > l)\\n        {\\n            if (str[l++] != str[h--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int maxProduct(string s) {\\n        vector<pair<string,long long>> v;\\n        \\n        long long n = s.size();\\n        long long power = pow(2,n);\\n\\t\\t\\n\\t\\t\\n        for(int i=0;i<power;i++){\\n            string ans=\"\";\\n            for(int j=0;j<n;j++){\\n                if(i&1<<j){\\n                    ans = ans + s[j];\\n                }\\n            }\\n            if(isPalindrome(ans)){\\n                v.push_back({ans,i});\\n            }\\n        }\\n        long long val=1;\\n        for(int i=0;i<v.size()-1;i++){\\n            for(int j=1;j<v.size();j++){\\n                if((v[i].second & v[j].second)==0){\\n                    \\n                        long long ik = v[i].first.size();\\n                        long long jk = v[j].first.size();\\n                       \\n                        if(ik*jk>val){\\n                            val = ik*jk;\\n                        }\\n     \\n                }\\n            }\\n        }\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool isPalindrome(string str)\\n    {\\n        // Start from leftmost and rightmost corners of str\\n        int l = 0;\\n        int h = str.size()-1;\\n\\n        // Keep comparing characters while they are same\\n        while (h > l)\\n        {\\n            if (str[l++] != str[h--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int maxProduct(string s) {\\n        vector<pair<string,long long>> v;\\n        \\n        long long n = s.size();\\n        long long power = pow(2,n);\\n\\t\\t\\n\\t\\t\\n        for(int i=0;i<power;i++){\\n            string ans=\"\";\\n            for(int j=0;j<n;j++){\\n                if(i&1<<j){\\n                    ans = ans + s[j];\\n                }\\n            }\\n            if(isPalindrome(ans)){\\n                v.push_back({ans,i});\\n            }\\n        }\\n        long long val=1;\\n        for(int i=0;i<v.size()-1;i++){\\n            for(int j=1;j<v.size();j++){\\n                if((v[i].second & v[j].second)==0){\\n                    \\n                        long long ik = v[i].first.size();\\n                        long long jk = v[j].first.size();\\n                       \\n                        if(ik*jk>val){\\n                            val = ik*jk;\\n                        }\\n     \\n                }\\n            }\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458287,
                "title": "recursion-c-explanation",
                "content": "I think the commented code is enough for the explanation.\\nfor n <= 12:\\n* we have 3 option for every position\\nso we can simply use recursion with a Time-Complexity of **O(n * 3^n)**\\n\\n* we have maximum of (length(a)+length(b)) length string in any path in the recursion\\nso Space Complexity: **O(n)**\\n\\n**Note**: Don\\'t mess up with pass by reference(&)\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string &a) {\\n        int i = 0, j = a.length()-1;\\n        while(i <= j) {\\n            if(a[i++] != a[j--]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    void solve(string &s, int i, int n, string &a, string &b, int &res) {\\n        if(isPalindrome(a) && isPalindrome(b)) { // both subsequences are palindrome\\n            res = max(res, (int)a.length()*(int)b.length()); // take maximum of product of their length\\n        }\\n        if(i >= n) return ; // base case\\n        \\n        // case I: if we don\\'t choose to add the current char to any of the subsequences\\n        solve(s, i+1, n, a, b, res);\\n        \\n        // case II: if we choose to add the current char to a\\n        a += s[i];\\n        solve(s, i+1, n, a, b, res);\\n        a.pop_back(); // backtrack\\n        \\n        // case III: if we choose to add the current char to b\\n        b += s[i];\\n        solve(s, i+1, n, a, b, res); \\n        b.pop_back(); // backtrack\\n    }\\n    \\n    int maxProduct(string s) {\\n        int n = s.length();\\n        string a = \"\", b = \"\";\\n        int res = 1;\\n        solve(s, 0, n, a, b, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string &a) {\\n        int i = 0, j = a.length()-1;\\n        while(i <= j) {\\n            if(a[i++] != a[j--]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    void solve(string &s, int i, int n, string &a, string &b, int &res) {\\n        if(isPalindrome(a) && isPalindrome(b)) { // both subsequences are palindrome\\n            res = max(res, (int)a.length()*(int)b.length()); // take maximum of product of their length\\n        }\\n        if(i >= n) return ; // base case\\n        \\n        // case I: if we don\\'t choose to add the current char to any of the subsequences\\n        solve(s, i+1, n, a, b, res);\\n        \\n        // case II: if we choose to add the current char to a\\n        a += s[i];\\n        solve(s, i+1, n, a, b, res);\\n        a.pop_back(); // backtrack\\n        \\n        // case III: if we choose to add the current char to b\\n        b += s[i];\\n        solve(s, i+1, n, a, b, res); \\n        b.pop_back(); // backtrack\\n    }\\n    \\n    int maxProduct(string s) {\\n        int n = s.length();\\n        string a = \"\", b = \"\";\\n        int res = 1;\\n        solve(s, 0, n, a, b, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811360,
                "title": "bitmask-hashing-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    priority_queue<int, vector<int>, greater<int>> pq;\\npublic:\\n    bool isPalindrome(string& s){\\n        int l=0, r = s.size()-1;\\n        while(l <= r){\\n            if(s[l] != s[r]) return false;\\n            l++;\\n            r--;\\n        }\\n        return true;\\n    }\\n    int maxProduct(string s) {\\n       int n = s.size();\\n       unordered_map<int, int> mp;\\n       for(int i=1; i<(1<<n); i++){\\n          string t;\\n          for(int j=0; j<n; j++){\\n              if(i&(1<<j))t.push_back(s[j]);\\n          }\\n          if(isPalindrome(t)) mp[i] = t.size();\\n       }\\n       int res = 0;\\n       for(auto& x : mp){\\n           for(auto& y : mp){\\n             if((x.first & y.first) == 0) res = max(res, x.second* y.second);\\n           }\\n       }\\n       return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    priority_queue<int, vector<int>, greater<int>> pq;\\npublic:\\n    bool isPalindrome(string& s){\\n        int l=0, r = s.size()-1;\\n        while(l <= r){\\n            if(s[l] != s[r]) return false;\\n            l++;\\n            r--;\\n        }\\n        return true;\\n    }\\n    int maxProduct(string s) {\\n       int n = s.size();\\n       unordered_map<int, int> mp;\\n       for(int i=1; i<(1<<n); i++){\\n          string t;\\n          for(int j=0; j<n; j++){\\n              if(i&(1<<j))t.push_back(s[j]);\\n          }\\n          if(isPalindrome(t)) mp[i] = t.size();\\n       }\\n       int res = 0;\\n       for(auto& x : mp){\\n           for(auto& y : mp){\\n             if((x.first & y.first) == 0) res = max(res, x.second* y.second);\\n           }\\n       }\\n       return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329699,
                "title": "brute-force-appro",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        N,pali = len(s),{} # bitmask = length\\n\\n        for mask in range(1,1<<N): # 1 << N == 2**N\\n            subseq = \"\"\\n            for i in range(N):\\n                if mask & (1<<i):\\n                    subseq+=s[i]\\n\\n            if subseq == subseq[::-1]:\\n                pali[mask] = len(subseq)\\n\\n            \\n        res = 0\\n        for m1 in pali:\\n            for m2 in pali:\\n                if m1 & m2 == 0:\\n                    res = max(res,pali[m1]*pali[m2])\\n\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        N,pali = len(s),{} # bitmask = length\\n\\n        for mask in range(1,1<<N): # 1 << N == 2**N\\n            subseq = \"\"\\n            for i in range(N):\\n                if mask & (1<<i):\\n                    subseq+=s[i]\\n\\n            if subseq == subseq[::-1]:\\n                pali[mask] = len(subseq)\\n\\n            \\n        res = 0\\n        for m1 in pali:\\n            for m2 in pali:\\n                if m1 & m2 == 0:\\n                    res = max(res,pali[m1]*pali[m2])\\n\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844906,
                "title": "python-3-bitmask",
                "content": "\\tclass Solution:\\n\\t\\tdef maxProduct(self, s: str) -> int:\\n\\t\\t\\tdef create_string(v):\\n\\t\\t\\t\\tres=[]\\n\\t\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\t\\tif 1<<i&v:\\n\\t\\t\\t\\t\\t\\tres.append(s[i])\\n\\t\\t\\t\\tif res==res[::-1]:\\n\\t\\t\\t\\t\\tpal[v]=len(res)\\n\\t\\t\\tpal=dict()\\n\\t\\t\\tn=len(s)\\n\\t\\t\\tfor i in range(1,pow(2,n)):\\n\\t\\t\\t\\tcreate_string(i)\\n\\t\\t\\tres=0\\n\\t\\t\\tfor x in pal:\\n\\t\\t\\t\\tfor y in pal:\\n\\t\\t\\t\\t\\tif not x&y:\\n\\t\\t\\t\\t\\t\\tres=max(res,pal[x]*pal[y])\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Python3",
                    "Bitmask"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef maxProduct(self, s: str) -> int:\\n\\t\\t\\tdef create_string(v):\\n\\t\\t\\t\\tres=[]\\n\\t\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\t\\tif 1<<i&v:\\n\\t\\t\\t\\t\\t\\tres.append(s[i])\\n\\t\\t\\t\\tif res==res[::-1]:\\n\\t\\t\\t\\t\\tpal[v]=len(res)\\n\\t\\t\\tpal=dict()\\n\\t\\t\\tn=len(s)\\n\\t\\t\\tfor i in range(1,pow(2,n)):\\n\\t\\t\\t\\tcreate_string(i)\\n\\t\\t\\tres=0\\n\\t\\t\\tfor x in pal:\\n\\t\\t\\t\\tfor y in pal:\\n\\t\\t\\t\\t\\tif not x&y:\\n\\t\\t\\t\\t\\t\\tres=max(res,pal[x]*pal[y])\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2510665,
                "title": "c-not-sure-how-dp-is-used-in-my-soln",
                "content": "TC: O( 3 ^N )\\nSC: O(1) +  Auxiliary Stack Space O(N)\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string &str){\\n        int i=0,j=str.size()-1;\\n        while(i<j){\\n            if(str[i]!=str[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    void solve(int i,string &s1,string &s2,string &s,int &ans){\\n        //base case\\n        if(i>=s.size()){\\n            if(isPalindrome(s1) && isPalindrome(s2)){\\n                int prod=s1.size()*s2.size();\\n                ans= max(ans,prod);\\n            }\\n            return;\\n        }\\n        //dont pick\\n        solve(i+1,s1,s2,s,ans);\\n        \\n        //pick\\n        s1+=s[i];\\n        solve(i+1,s1,s2,s,ans);\\n        s1.pop_back();\\n        s2+=s[i];\\n        solve(i+1,s1,s2,s,ans);\\n        s2.pop_back();\\n    }\\n    \\n    int maxProduct(string s) {\\n        int n=s.size();\\n        int ans=0;\\n        string s1=\"\",s2=\"\";\\n        solve(0,s1,s2,s,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string &str){\\n        int i=0,j=str.size()-1;\\n        while(i<j){\\n            if(str[i]!=str[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    void solve(int i,string &s1,string &s2,string &s,int &ans){\\n        //base case\\n        if(i>=s.size()){\\n            if(isPalindrome(s1) && isPalindrome(s2)){\\n                int prod=s1.size()*s2.size();\\n                ans= max(ans,prod);\\n            }\\n            return;\\n        }\\n        //dont pick\\n        solve(i+1,s1,s2,s,ans);\\n        \\n        //pick\\n        s1+=s[i];\\n        solve(i+1,s1,s2,s,ans);\\n        s1.pop_back();\\n        s2+=s[i];\\n        solve(i+1,s1,s2,s,ans);\\n        s2.pop_back();\\n    }\\n    \\n    int maxProduct(string s) {\\n        int n=s.size();\\n        int ans=0;\\n        string s1=\"\",s2=\"\";\\n        solve(0,s1,s2,s,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313736,
                "title": "c-backtracking-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long res;\\n    bool ispal(string &s)\\n    {\\n        int start=0,end=s.size()-1;\\n        while(start<end)\\n        {\\n            if(s[start]!=s[end])\\n                return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n    void backtrack(string s,int idx,string &s1,string &s2)\\n    {\\n        if(idx>=s.size())\\n        {\\n            if(ispal(s1)&&ispal(s2))\\n            {\\n                long long val=s1.size()*s2.size();\\n                res=max(val,res);\\n            }\\n            return ;\\n        }\\n        s1.push_back(s[idx]);\\n        backtrack(s,idx+1,s1,s2);\\n        s1.pop_back();\\n        \\n        s2.push_back(s[idx]);\\n        backtrack(s,idx+1,s1,s2);\\n        s2.pop_back();\\n        \\n        backtrack(s,idx+1,s1,s2);\\n    }\\n    int maxProduct(string s)\\n    {\\n        string s1=\"\",s2=\"\";\\n        backtrack(s,0,s1,s2);\\n        return res;\\n        \\n    }\\n};\\n// if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    long long res;\\n    bool ispal(string &s)\\n    {\\n        int start=0,end=s.size()-1;\\n        while(start<end)\\n        {\\n            if(s[start]!=s[end])\\n                return false;\\n            start++;\\n            end--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2173467,
                "title": "eayc-c-code-o-n-2-2-n",
                "content": "```\\n int maxProduct(string s) {\\n        int n=s.length();\\n        int ans=0;\\n        for(int k=1;k<pow(2,n)-1;k++)\\n        {\\n            string unused=\"\";\\n            string used=\"\";\\n            for(int j=0;j<n;j++)\\n            {\\n                if(k&1<<j)\\n                {\\n                    used+=s[j];\\n                }\\n                else \\n                {\\n                    unused+=s[j];\\n                }\\n            }\\n            \\n            int check=1;\\n            for(int j=0;j<used.length()/2;j++)\\n            {\\n                if(used[j]!=used[used.length()-j-1])\\n                {\\n                    check=0;\\n                    break;\\n                }\\n            }\\n            \\n            if(!check)continue;\\n            int m=unused.length();\\n            vector<vector<int>>dp(m+1,vector<int>(m+1,0));\\n            \\n            for(int i=0;i<m;i++)dp[i][i]=1;\\n            for(int i=0;i<m-1;i++)\\n            {\\n                if(unused[i]==unused[i+1])dp[i][i+1]=2;\\n                else dp[i][i+1]=1;\\n            }\\n            for(int j=3;j<=m;j++)\\n            {\\n                for(int i=0;i<=m-j;i++)\\n                {\\n                    if(unused[i]==unused[i+j-1])dp[i][i+j-1]=dp[i+1][i+j-2]+2;\\n                    else dp[i][i+j-1]=max(dp[i][i+j-2],dp[i+1][i+j-1]);\\n                }\\n            }\\n            int u=used.length();            \\n            ans=max(ans,u*dp[0][m-1]);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\n int maxProduct(string s) {\\n        int n=s.length();\\n        int ans=0;\\n        for(int k=1;k<pow(2,n)-1;k++)\\n        {\\n            string unused=\"\";\\n            string used=\"\";\\n            for(int j=0;j<n;j++)\\n            {\\n                if(k&1<<j)\\n                {\\n                    used+=s[j];\\n                }\\n                else \\n                {\\n                    unused+=s[j];\\n                }\\n            }\\n            \\n            int check=1;\\n            for(int j=0;j<used.length()/2;j++)\\n            {\\n                if(used[j]!=used[used.length()-j-1])\\n                {\\n                    check=0;\\n                    break;\\n                }\\n            }\\n            \\n            if(!check)continue;\\n            int m=unused.length();\\n            vector<vector<int>>dp(m+1,vector<int>(m+1,0));\\n            \\n            for(int i=0;i<m;i++)dp[i][i]=1;\\n            for(int i=0;i<m-1;i++)\\n            {\\n                if(unused[i]==unused[i+1])dp[i][i+1]=2;\\n                else dp[i][i+1]=1;\\n            }\\n            for(int j=3;j<=m;j++)\\n            {\\n                for(int i=0;i<=m-j;i++)\\n                {\\n                    if(unused[i]==unused[i+j-1])dp[i][i+j-1]=dp[i+1][i+j-2]+2;\\n                    else dp[i][i+j-1]=max(dp[i][i+j-2],dp[i+1][i+j-1]);\\n                }\\n            }\\n            int u=used.length();            \\n            ans=max(ans,u*dp[0][m-1]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2128879,
                "title": "c-dp-with-bitamask-longest-palindromic-subsequence",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check_palindrom(int m,string s){\\n        int i=0;\\n        string temp=\"\";\\n        while(m>0){\\n            if(m&1){\\n                temp+=s[i];\\n            }\\n            m=m>>1;\\n            i++;\\n        }\\n        int start=0;\\n        int end=temp.length()-1;\\n        while(start<=end){\\n            if(temp[start]!=temp[end])return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n    int find_ans(int m,string s){\\n        int n=s.length();\\n        string temp=\"\";\\n        for(int i=0;i<n;i++){\\n            if((m&(1<<i))==0){\\n                temp+=s[i];\\n            }\\n        }\\n        int l=temp.length();\\n        if(l==0)return 0;\\n        vector<vector<int>>dp(l,vector<int>(l,0));\\n        for(int i=0;i<l;i++)dp[i][i]=1;\\n        for(int len=2;len<=l;len++){\\n            for(int i=0;i+len-1<l;i++){\\n                int j=i+len-1;\\n                if(len==2){\\n                    if(temp[i]==temp[j])dp[i][j]=2;\\n                    else dp[i][j]=1;\\n                }\\n                else{\\n                    if(temp[i]==temp[j])dp[i][j]=2+dp[i+1][j-1];\\n                    else dp[i][j]=max(dp[i+1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return dp[0][l-1];\\n        \\n    }\\n    int maxProduct(string s) {\\n        int n=s.length();\\n        int ans=0;\\n\\t\\t//firstly finding each subsequence of string s \\n        for(int i=1;i<(1<<n);i++){\\n            bool flag=check_palindrom(i,s); //checking the current subsequence is palindrome \\n            if(!flag)continue;//if it is not palindrome continue to remaining subsequence\\n            int len1=__builtin_popcount(i);\\n            int len2=find_ans(i,s);//finding the maximum length subsequence which is palindrome in remaining string \\n            ans=max(len1*len2,ans);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check_palindrom(int m,string s){\\n        int i=0;\\n        string temp=\"\";\\n        while(m>0){\\n            if(m&1){\\n                temp+=s[i];\\n            }\\n            m=m>>1;\\n            i++;\\n        }\\n        int start=0;\\n        int end=temp.length()-1;\\n        while(start<=end){\\n            if(temp[start]!=temp[end])return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n    int find_ans(int m,string s){\\n        int n=s.length();\\n        string temp=\"\";\\n        for(int i=0;i<n;i++){\\n            if((m&(1<<i))==0){\\n                temp+=s[i];\\n            }\\n        }\\n        int l=temp.length();\\n        if(l==0)return 0;\\n        vector<vector<int>>dp(l,vector<int>(l,0));\\n        for(int i=0;i<l;i++)dp[i][i]=1;\\n        for(int len=2;len<=l;len++){\\n            for(int i=0;i+len-1<l;i++){\\n                int j=i+len-1;\\n                if(len==2){\\n                    if(temp[i]==temp[j])dp[i][j]=2;\\n                    else dp[i][j]=1;\\n                }\\n                else{\\n                    if(temp[i]==temp[j])dp[i][j]=2+dp[i+1][j-1];\\n                    else dp[i][j]=max(dp[i+1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return dp[0][l-1];\\n        \\n    }\\n    int maxProduct(string s) {\\n        int n=s.length();\\n        int ans=0;\\n\\t\\t//firstly finding each subsequence of string s \\n        for(int i=1;i<(1<<n);i++){\\n            bool flag=check_palindrom(i,s); //checking the current subsequence is palindrome \\n            if(!flag)continue;//if it is not palindrome continue to remaining subsequence\\n            int len1=__builtin_popcount(i);\\n            int len2=find_ans(i,s);//finding the maximum length subsequence which is palindrome in remaining string \\n            ans=max(len1*len2,ans);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2055954,
                "title": "c-bactracking-easy-to-understand",
                "content": "```\\nint ans=0;\\n    bool isPal(string& s)\\n    {\\n        int i=0,j=s.length()-1;\\n        while(i<=j)\\n        {\\n            if(s[i]!=s[j])\\n            return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    void helper(string& s,string& s1,string& s2,int i)\\n    {\\n        if(i>=s.size())\\n        {\\n            if(isPal(s1)&&isPal(s2))\\n            {\\n                ans=max(ans,(int)(s1.size())*(int)(s2.size()));\\n                \\n            }\\n            return;\\n        }\\n        \\n        s1+=s[i];\\n        helper(s,s1,s2,i+1);\\n        s1.pop_back();\\n        \\n        s2+=s[i];\\n        helper(s,s1,s2,i+1);\\n        s2.pop_back();\\n        \\n        helper(s,s1,s2,i+1);\\n    }\\n    int maxProduct(string s) \\n    {\\n        string s1=\"\",s2=\"\";\\n        int i=0;\\n        helper(s,s1,s2,i);\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint ans=0;\\n    bool isPal(string& s)\\n    {\\n        int i=0,j=s.length()-1;\\n        while(i<=j)\\n        {\\n            if(s[i]!=s[j])\\n            return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    void helper(string& s,string& s1,string& s2,int i)\\n    {\\n        if(i>=s.size())\\n        {\\n            if(isPal(s1)&&isPal(s2))\\n            {\\n                ans=max(ans,(int)(s1.size())*(int)(s2.size()));\\n                \\n            }\\n            return;\\n        }\\n        \\n        s1+=s[i];\\n        helper(s,s1,s2,i+1);\\n        s1.pop_back();\\n        \\n        s2+=s[i];\\n        helper(s,s1,s2,i+1);\\n        s2.pop_back();\\n        \\n        helper(s,s1,s2,i+1);\\n    }\\n    int maxProduct(string s) \\n    {\\n        string s1=\"\",s2=\"\";\\n        int i=0;\\n        helper(s,s1,s2,i);\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1969034,
                "title": "python-dynamic-programming-memoization",
                "content": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        \\n        N = len(s)\\n        memo = {}\\n        \\n        def isValidPalindrom(word):\\n            left, right = 0, len(word)-1\\n            while (left < right):\\n                if word[left] != word[right]: return False\\n                left += 1\\n                right -= 1\\n            \\n            return True\\n        \\n        def backTrack(i, word1, word2):\\n            \\n            if i > N: return float(\\'-inf\\')\\n            \\n            if i == N:\\n                isBothValidPalindrome = isValidPalindrom(word1) and isValidPalindrom(word2)\\n                return len(word1)*len(word2) if isBothValidPalindrome else float(\\'-inf\\')\\n            \\n            key = (i,word1, word2)\\n            \\n            if key in memo: return memo[key]\\n            \\n            memo[key] = max([\\n                backTrack(i+1, word1+s[i], word2),\\n                backTrack(i+1, word1, word2+s[i]), \\n                backTrack(i+1, word1, word2)\\n            ])\\n            \\n            return memo[key]\\n        \\n        return backTrack(0,\"\",\"\")\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        \\n        N = len(s)\\n        memo = {}\\n        \\n        def isValidPalindrom(word):\\n            left, right = 0, len(word)-1\\n            while (left < right):\\n                if word[left] != word[right]: return False\\n                left += 1\\n                right -= 1\\n            \\n            return True\\n        \\n        def backTrack(i, word1, word2):\\n            \\n            if i > N: return float(\\'-inf\\')\\n            \\n            if i == N:\\n                isBothValidPalindrome = isValidPalindrom(word1) and isValidPalindrom(word2)\\n                return len(word1)*len(word2) if isBothValidPalindrome else float(\\'-inf\\')\\n            \\n            key = (i,word1, word2)\\n            \\n            if key in memo: return memo[key]\\n            \\n            memo[key] = max([\\n                backTrack(i+1, word1+s[i], word2),\\n                backTrack(i+1, word1, word2+s[i]), \\n                backTrack(i+1, word1, word2)\\n            ])\\n            \\n            return memo[key]\\n        \\n        return backTrack(0,\"\",\"\")\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926020,
                "title": "c-easy-to-understand-simple-solution-using-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    bool isPalin(string& s)\\n    {\\n        int i=0,j=s.length()-1;\\n        while(i<=j)\\n        {\\n            if(s[i]!=s[j])\\n            return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    void dfs(string& s,string& s1,string& s2,int i)\\n    {\\n        if(i>=s.length())\\n        {\\n            if(isPalin(s1)&&isPalin(s2))\\n            {\\n                ans=max(ans,((int)s1.length())*((int)s2.length()));\\n            }\\n            return;\\n        }\\n        s1+=s[i];\\n        dfs(s,s1,s2,i+1);\\n        s1.pop_back();\\n        \\n        s2+=s[i];\\n        dfs(s,s1,s2,i+1);\\n        s2.pop_back();\\n        \\n        dfs(s,s1,s2,i+1);\\n    }\\n    int maxProduct(string s) {\\n        string s1=\"\",s2=\"\";\\n        int i=0;\\n        dfs(s,s1,s2,i);\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    bool isPalin(string& s)\\n    {\\n        int i=0,j=s.length()-1;\\n        while(i<=j)\\n        {\\n            if(s[i]!=s[j])\\n            return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    void dfs(string& s,string& s1,string& s2,int i)\\n    {\\n        if(i>=s.length())\\n        {\\n            if(isPalin(s1)&&isPalin(s2))\\n            {\\n                ans=max(ans,((int)s1.length())*((int)s2.length()));\\n            }\\n            return;\\n        }\\n        s1+=s[i];\\n        dfs(s,s1,s2,i+1);\\n        s1.pop_back();\\n        \\n        s2+=s[i];\\n        dfs(s,s1,s2,i+1);\\n        s2.pop_back();\\n        \\n        dfs(s,s1,s2,i+1);\\n    }\\n    int maxProduct(string s) {\\n        string s1=\"\",s2=\"\";\\n        int i=0;\\n        dfs(s,s1,s2,i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867588,
                "title": "js-slow-but-simple-without-bitmask",
                "content": "Only possible since s.length <= 12 and we can basically check every possible variant.\\n\\nBased on this Python solution:\\nhttps://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/discuss/1458751/Python-DFS-solution\\n\\n```\\nconst isPalindrome = (str) => {\\n    for (let i = 0, j = str.length - 1; i < j; i++, j--) {\\n        if (str[i] !== str[j]) return false;\\n    }\\n    return true;\\n}\\n\\nfunction maxProduct(s) {\\n    function cb(letterIndex, word1, word2) {\\n        if (letterIndex > s.length) {\\n            return isPalindrome(word1) && isPalindrome(word2)\\n                ? word1.length * word2.length\\n                : 0;\\n        }\\n        \\n        const char = s[letterIndex];\\n        const newIndex = letterIndex + 1;\\n        \\n        return Math.max(\\n            cb(newIndex, word1, word2),\\n            cb(newIndex, `${word1}${char}`, word2),\\n            cb(newIndex, word1, `${word2}${char}`)\\n        );\\n    }\\n    \\n    return cb(0, \\'\\', \\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst isPalindrome = (str) => {\\n    for (let i = 0, j = str.length - 1; i < j; i++, j--) {\\n        if (str[i] !== str[j]) return false;\\n    }\\n    return true;\\n}\\n\\nfunction maxProduct(s) {\\n    function cb(letterIndex, word1, word2) {\\n        if (letterIndex > s.length) {\\n            return isPalindrome(word1) && isPalindrome(word2)\\n                ? word1.length * word2.length\\n                : 0;\\n        }\\n        \\n        const char = s[letterIndex];\\n        const newIndex = letterIndex + 1;\\n        \\n        return Math.max(\\n            cb(newIndex, word1, word2),\\n            cb(newIndex, `${word1}${char}`, word2),\\n            cb(newIndex, word1, `${word2}${char}`)\\n        );\\n    }\\n    \\n    return cb(0, \\'\\', \\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1806334,
                "title": "c-easy-recursion-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans =-1;\\n    bool ispal(vector<char>&a)\\n    {\\n        int n=a.size();\\n        for(int i=0;i<n/2;i++)\\n        {\\n            if(a[i] != a[n-1-i])return false;\\n        }\\n        return true;\\n    }\\n    void solve(string s,vector<char>&s1,vector<char>&s2,int i)\\n    {\\n        // base case \\n        if(i >= s.size())\\n        {\\n            if(ispal(s1) && ispal(s2))\\n            {\\n             int p = (s1.size()*s2.size());\\n                if(ans < p)ans=p;\\n                return ;\\n            }\\n            else\\n                return   ;\\n        }\\n        solve(s,s1,s2,i+1);\\n        \\n        s1.push_back(s[i]);\\n        solve(s,s1,s2,i+1);\\n        s1.pop_back();\\n        \\n         s2.push_back(s[i]);\\n        solve(s,s1,s2,i+1);\\n        s2.pop_back();\\n    }\\n    int maxProduct(string s) {\\n        vector<char>s1,s2 ; \\n        solve(s,s1,s2,0);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    int ans =-1;\\n    bool ispal(vector<char>&a)\\n    {\\n        int n=a.size();\\n        for(int i=0;i<n/2;i++)\\n        {\\n            if(a[i] != a[n-1-i])return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1699117,
                "title": "c-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool isPalindrome(string s){\\n        if(s.size() == 1) return true;\\n        string tmp = s;\\n        reverse(tmp.begin(),tmp.end());\\n        return tmp == s;\\n    }\\n    \\n    int maxProduct(string s) {\\n           int n = s.size();\\n           map<int,int> mp;\\n           for(int mask=1; mask < (1<<n); mask++){\\n                string subseq;\\n                for(int i=0; i<n; i++){\\n                    if((mask & 1<<i))\\n                        subseq += s[i];\\n                }\\n                \\n                 if(isPalindrome(subseq)){\\n                     mp[mask] = subseq.size();\\n                 }\\n           }\\n           \\n            int ans = INT_MIN;\\n         \\n         for(auto it1 = mp.begin(); it1 != mp.end(); it1++){\\n             for(auto it2 = mp.begin(); it2 != mp.end(); it2++){\\n                 if( (it1->first & it2->first) == 0){\\n                     ans = max(ans, it1->second * it2->second);\\n                 }\\n             }\\n         }\\n        \\n          return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool isPalindrome(string s){\\n        if(s.size() == 1) return true;\\n        string tmp = s;\\n        reverse(tmp.begin(),tmp.end());\\n        return tmp == s;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1692253,
                "title": "maximum-product-of-the-length-of-two-palindromic-subsequences-c-lps",
                "content": "LPS : Longest Palindromic Subsequence\\n```\\nclass Solution {\\npublic:\\n    int LPS(string& s1) {\\n        string s2 = s1;\\n        reverse(s2.begin(), s2.end());\\n        \\n        int n = s1.size();\\n        int dp[n + 1][n + 1];\\n        for(int i = 0; i < n; i++) dp[i][0] = 0, dp[0][i] = 0;\\n        \\n        for(int i = 1; i <= n; i++){\\n            for(int j = 1; j <= n; j++){\\n                if(s1[i - 1] == s2[j - 1]){\\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\\n                }\\n                else dp[i][j] = max(dp[i - 1][j],dp[i][j - 1]);\\n            }\\n        }\\n        return dp[n][n];\\n    }\\n\\n    int maxProduct(string s) {\\n        int ans = 0, n = s.size();\\n        for(int mask = 1; mask < (1 << n) - 1; mask++){\\n            string a = \"\", b = \"\";\\n            for(int i = 0; i < n; i++){\\n                if(mask & (1 << i)) a += s[i];\\n                else b += s[i];\\n            }\\n            ans = max(ans, LPS(a) * LPS(b));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int LPS(string& s1) {\\n        string s2 = s1;\\n        reverse(s2.begin(), s2.end());\\n        \\n        int n = s1.size();\\n        int dp[n + 1][n + 1];\\n        for(int i = 0; i < n; i++) dp[i][0] = 0, dp[0][i] = 0;\\n        \\n        for(int i = 1; i <= n; i++){\\n            for(int j = 1; j <= n; j++){\\n                if(s1[i - 1] == s2[j - 1]){\\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\\n                }\\n                else dp[i][j] = max(dp[i - 1][j],dp[i][j - 1]);\\n            }\\n        }\\n        return dp[n][n];\\n    }\\n\\n    int maxProduct(string s) {\\n        int ans = 0, n = s.size();\\n        for(int mask = 1; mask < (1 << n) - 1; mask++){\\n            string a = \"\", b = \"\";\\n            for(int i = 0; i < n; i++){\\n                if(mask & (1 << i)) a += s[i];\\n                else b += s[i];\\n            }\\n            ans = max(ans, LPS(a) * LPS(b));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682411,
                "title": "faster-than-93-69-less-than-94-86-c-simple-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProduct(string s) {\\n        int n=s.size();\\n        int maskMax=1<<n-1;\\n        \\n        int ret=0;\\n        for(int mask=1;mask<maskMax;mask++){\\n            string s1,s2;\\n            for(int i=0;i<s.size();i++){\\n                if(mask & 1<<i)\\n                    s1+=s[i];\\n                else\\n                    s2+=s[i];\\n            }\\n            int MaxLen1=helper(s1, 0, s1.size()-1);\\n            int MaxLen2=helper(s2, 0, s2.size()-1);\\n            ret=max(ret, MaxLen1*MaxLen2);\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    int helper(string& s, int l, int r){\\n        if(l>r)\\n            return 0;\\n        if(l==r)\\n            return 1;\\n        if(s[l]==s[r])\\n            return 2+helper(s, l+1, r-1);\\n        else\\n            return max(helper(s, l+1, r), helper(s, l, r-1));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(string s) {\\n        int n=s.size();\\n        int maskMax=1<<n-1;\\n        \\n        int ret=0;\\n        for(int mask=1;mask<maskMax;mask++){\\n            string s1,s2;\\n            for(int i=0;i<s.size();i++){\\n                if(mask & 1<<i)\\n                    s1+=s[i];\\n                else\\n                    s2+=s[i];\\n            }\\n            int MaxLen1=helper(s1, 0, s1.size()-1);\\n            int MaxLen2=helper(s2, 0, s2.size()-1);\\n            ret=max(ret, MaxLen1*MaxLen2);\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    int helper(string& s, int l, int r){\\n        if(l>r)\\n            return 0;\\n        if(l==r)\\n            return 1;\\n        if(s[l]==s[r])\\n            return 2+helper(s, l+1, r-1);\\n        else\\n            return max(helper(s, l+1, r), helper(s, l, r-1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491954,
                "title": "my-java-solution-using-recursion",
                "content": "```\\nclass Solution {\\n    \\n    private int maxProduct = -1;\\n    \\n    public int maxProduct(String s) {\\n        if (s == null || s.length() <= 1) {\\n            return 0;\\n        }\\n        int length = s.length();\\n        if (length == 1) {\\n            return 1;\\n        }\\n        List<Character> word1 = new ArrayList<>();\\n        List<Character> word2 = new ArrayList<>();\\n        recursionHelper(s, 0, word1, word2);\\n        return maxProduct;\\n    }\\n    \\n    public void recursionHelper(String s, int currentIndex, List<Character> word1, List<Character> word2) {\\n        if (currentIndex >= s.length()) {\\n            // update the maxProduct by checking the palindrome\\n            if (isPalindrome(word1) && isPalindrome(word2)) {\\n                int length1 = word1.size();\\n                int length2 = word2.size();\\n                maxProduct = Math.max(maxProduct, length1 * length2);\\n            }\\n            return;\\n        }\\n        // otherwise consider other cases\\n        word1.add(s.charAt(currentIndex));\\n        recursionHelper(s, currentIndex + 1, word1, word2);\\n        // undo\\n        word1.remove(word1.size() - 1);\\n        // try the other possiblity with word2\\n        word2.add(s.charAt(currentIndex));\\n        recursionHelper(s, currentIndex + 1, word1, word2);\\n        // undo\\n        word2.remove(word2.size() - 1);\\n        // try possiblity without adding the char at index to both word1 and word2\\n        recursionHelper(s, currentIndex + 1, word1, word2);\\n    }\\n    \\n    public boolean isPalindrome(List<Character> word) {\\n        int size = word.size();\\n        int left = 0;\\n        int right = size - 1;\\n        while (left < right) {\\n            if (word.get(left++) != word.get(right--)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int maxProduct = -1;\\n    \\n    public int maxProduct(String s) {\\n        if (s == null || s.length() <= 1) {\\n            return 0;\\n        }\\n        int length = s.length();\\n        if (length == 1) {\\n            return 1;\\n        }\\n        List<Character> word1 = new ArrayList<>();\\n        List<Character> word2 = new ArrayList<>();\\n        recursionHelper(s, 0, word1, word2);\\n        return maxProduct;\\n    }\\n    \\n    public void recursionHelper(String s, int currentIndex, List<Character> word1, List<Character> word2) {\\n        if (currentIndex >= s.length()) {\\n            // update the maxProduct by checking the palindrome\\n            if (isPalindrome(word1) && isPalindrome(word2)) {\\n                int length1 = word1.size();\\n                int length2 = word2.size();\\n                maxProduct = Math.max(maxProduct, length1 * length2);\\n            }\\n            return;\\n        }\\n        // otherwise consider other cases\\n        word1.add(s.charAt(currentIndex));\\n        recursionHelper(s, currentIndex + 1, word1, word2);\\n        // undo\\n        word1.remove(word1.size() - 1);\\n        // try the other possiblity with word2\\n        word2.add(s.charAt(currentIndex));\\n        recursionHelper(s, currentIndex + 1, word1, word2);\\n        // undo\\n        word2.remove(word2.size() - 1);\\n        // try possiblity without adding the char at index to both word1 and word2\\n        recursionHelper(s, currentIndex + 1, word1, word2);\\n    }\\n    \\n    public boolean isPalindrome(List<Character> word) {\\n        int size = word.size();\\n        int left = 0;\\n        int right = size - 1;\\n        while (left < right) {\\n            if (word.get(left++) != word.get(right--)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490331,
                "title": "java-simple-backtracking",
                "content": "```\\npublic int maxProduct(String s) {\\n        solve(s, \"\", \"\", 0);\\n        return ans;\\n    }\\n    int ans;\\n    void solve(String s, String s1, String s2, int start) {\\n        if(start == s.length()) {\\n            if(isPal(s1) && isPal(s2)) {\\n                int val = s1.length()*s2.length();\\n                ans = Math.max(ans, val);\\n            }\\n            return;\\n        }\\n        char ch = s.charAt(start);\\n        solve(s, s1+ch, s2, start+1);\\n        solve(s, s1, s2+ch, start+1);\\n        solve(s, s1, s2, start+1);\\n    }\\n    \\n    boolean isPal(String s) {\\n        int i = 0;\\n        int j = s.length() -1;\\n        while(i<j) {\\n            if(s.charAt(i) != s.charAt(j)) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\npublic int maxProduct(String s) {\\n        solve(s, \"\", \"\", 0);\\n        return ans;\\n    }\\n    int ans;\\n    void solve(String s, String s1, String s2, int start) {\\n        if(start == s.length()) {\\n            if(isPal(s1) && isPal(s2)) {\\n                int val = s1.length()*s2.length();\\n                ans = Math.max(ans, val);\\n            }\\n            return;\\n        }\\n        char ch = s.charAt(start);\\n        solve(s, s1+ch, s2, start+1);\\n        solve(s, s1, s2+ch, start+1);\\n        solve(s, s1, s2, start+1);\\n    }\\n    \\n    boolean isPal(String s) {\\n        int i = 0;\\n        int j = s.length() -1;\\n        while(i<j) {\\n            if(s.charAt(i) != s.charAt(j)) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1470456,
                "title": "c-creating-all-subsets-and-storing-them",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string str){\\n        int i=0,j = str.length()-1;\\n        while(i<j){\\n            if(str[i]!=str[j])return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    int maxProduct(string s) {\\n        int n = s.length();\\n        vector<int>pal;\\n        for(int i=1;i<((1<<n)-1);i++){\\n            string str = \"\";\\n            for(int j=0;j<n;j++){\\n                if((1<<j)&i){\\n                    str+=s[j];\\n                }\\n            }\\n            if(isPalindrome(str)){\\n                pal.push_back(i);\\n            }\\n        }\\n        int ans = INT_MIN;\\n        int n2 = pal.size();\\n        for(int i = 0;i<n2-1;i++){\\n            for(int j = i+1;j<n2;j++){\\n                if(((pal[i]&pal[j])==0)){\\n                int a = __builtin_popcount(pal[i]);\\n                int b = __builtin_popcount(pal[j]);\\n                ans = max(ans,a*b);}\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string str){\\n        int i=0,j = str.length()-1;\\n        while(i<j){\\n            if(str[i]!=str[j])return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    int maxProduct(string s) {\\n        int n = s.length();\\n        vector<int>pal;\\n        for(int i=1;i<((1<<n)-1);i++){\\n            string str = \"\";\\n            for(int j=0;j<n;j++){\\n                if((1<<j)&i){\\n                    str+=s[j];\\n                }\\n            }\\n            if(isPalindrome(str)){\\n                pal.push_back(i);\\n            }\\n        }\\n        int ans = INT_MIN;\\n        int n2 = pal.size();\\n        for(int i = 0;i<n2-1;i++){\\n            for(int j = i+1;j<n2;j++){\\n                if(((pal[i]&pal[j])==0)){\\n                int a = __builtin_popcount(pal[i]);\\n                int b = __builtin_popcount(pal[j]);\\n                ans = max(ans,a*b);}\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1464800,
                "title": "disjoint-subsequence-bitmasking-dp-c",
                "content": "```\\nint max_palindrome(string a)\\n    {\\n        int n = a.size();\\n        if(n==0)\\n            return 0;\\n         vector<vector<int>> dp(n, vector<int>(n,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i][i] = 1;\\n        }\\n\\t\\t\\n\\t\\t// dist is the distance between i and j pointer...\\n        for(int dist = 1; dist < n;dist++)\\n        {\\n            for(int i = 0; i<n-1;i++)\\n            {\\n\\t\\t\\t\\t// j =  i +dist...\\n\\t\\t\\t\\t// if j >= n, j is pointing to any valid char in string... So break...\\n                if(i+dist>=n)\\n                    break;\\n                else\\n                {\\n                    int j = i+dist;\\n                    if(a[i]==a[j])\\n                        dp[i][j] = dp[i+1][j-1]+2;\\n                    else\\n                        dp[i][j] = max(dp[i][j-1],dp[i+1][j]);\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n    int maxProduct(string s) {\\n        int n = s.length();\\n\\t\\t\\n\\t\\t// say if s = \"abcd\", mask = 1111, where each 1 corresponds to char at that place\\n\\t\\t// So mask = 1011 corresponds to string \"acd\", neglecting \\'b\\' as its bit is turned off.\\n\\t\\t\\n        int mask = pow(2,n)-1;\\n        long long max = 0;\\n        string final_a,final_b;\\n        for(int i = 0;i<=mask;i++)\\n        {\\n            string a=\"\",b=\"\";\\n\\t\\t\\t\\n\\t\\t\\t// i is mask for string a..\\n\\t\\t\\t// mask2 is for string b..\\n\\t\\t\\t\\n\\t\\t\\t// mask2 = mask^i will turn in those bits for those characters which are not in a..\\n\\t\\t\\t// like say a = \"abd\" then i = 1101, then mask2 will become 1111^1101 = 0010 --> c\\n\\t\\t\\t\\n            int mask2 = mask^i;\\n\\t\\t\\t\\n\\t\\t\\t// constructing a...\\n            for(int j=0;j<n;j++)\\n            {\\n                if(1<<j & i)\\n                    a += s[j];\\n            }\\n\\t\\t\\t//constructing b\\n            for(int j=0;j<n;j++)\\n            {\\n                if(1<<j & mask2)\\n                    b += s[j];\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//finding max palidrome for each subsequence...\\n            long long max_a = max_palindrome(a), max_b = max_palindrome(b);\\n\\t\\t\\t\\n\\t\\t\\t\\n            if(max_a*max_b > max )\\n            {\\n                max = max_a*max_b;\\n            }\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nint max_palindrome(string a)\\n    {\\n        int n = a.size();\\n        if(n==0)\\n            return 0;\\n         vector<vector<int>> dp(n, vector<int>(n,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i][i] = 1;\\n        }\\n\\t\\t\\n\\t\\t// dist is the distance between i and j pointer...\\n        for(int dist = 1; dist < n;dist++)\\n        {\\n            for(int i = 0; i<n-1;i++)\\n            {\\n\\t\\t\\t\\t// j =  i +dist...\\n\\t\\t\\t\\t// if j >= n, j is pointing to any valid char in string... So break...\\n                if(i+dist>=n)\\n                    break;\\n                else\\n                {\\n                    int j = i+dist;\\n                    if(a[i]==a[j])\\n                        dp[i][j] = dp[i+1][j-1]+2;\\n                    else\\n                        dp[i][j] = max(dp[i][j-1],dp[i+1][j]);\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n    int maxProduct(string s) {\\n        int n = s.length();\\n\\t\\t\\n\\t\\t// say if s = \"abcd\", mask = 1111, where each 1 corresponds to char at that place\\n\\t\\t// So mask = 1011 corresponds to string \"acd\", neglecting \\'b\\' as its bit is turned off.\\n\\t\\t\\n        int mask = pow(2,n)-1;\\n        long long max = 0;\\n        string final_a,final_b;\\n        for(int i = 0;i<=mask;i++)\\n        {\\n            string a=\"\",b=\"\";\\n\\t\\t\\t\\n\\t\\t\\t// i is mask for string a..\\n\\t\\t\\t// mask2 is for string b..\\n\\t\\t\\t\\n\\t\\t\\t// mask2 = mask^i will turn in those bits for those characters which are not in a..\\n\\t\\t\\t// like say a = \"abd\" then i = 1101, then mask2 will become 1111^1101 = 0010 --> c\\n\\t\\t\\t\\n            int mask2 = mask^i;\\n\\t\\t\\t\\n\\t\\t\\t// constructing a...\\n            for(int j=0;j<n;j++)\\n            {\\n                if(1<<j & i)\\n                    a += s[j];\\n            }\\n\\t\\t\\t//constructing b\\n            for(int j=0;j<n;j++)\\n            {\\n                if(1<<j & mask2)\\n                    b += s[j];\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//finding max palidrome for each subsequence...\\n            long long max_a = max_palindrome(a), max_b = max_palindrome(b);\\n\\t\\t\\t\\n\\t\\t\\t\\n            if(max_a*max_b > max )\\n            {\\n                max = max_a*max_b;\\n            }\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1461805,
                "title": "c-2002-maximum-product-of-the-length-of-two-palindromic-subsequences",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(string s) {\\n        int n = s.size(); \\n        vector<int> dp(1 << n); \\n        for (int mask = 1; mask < (1 << n); ++mask) \\n            if ((mask & mask-1) == 0) dp[mask] = 1; \\n            else {\\n                int lo = log2(mask & ~(mask-1)), hi = log2(mask); \\n                if (s[lo] == s[hi]) dp[mask] = 2 + dp[mask^(1<<lo)^(1<<hi)]; \\n                else dp[mask] = max(dp[mask^(1<<lo)], dp[mask^(1<<hi)]);\\n            }\\n        \\n        int ans = 0; \\n        for (int mask = 0; mask < (1 << n); ++mask) {\\n            int comp = (1 << n) - 1 ^ mask; \\n            ans = max(ans, dp[mask] * dp[comp]); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(string s) {\\n        int n = s.size(); \\n        vector<int> dp(1 << n); \\n        for (int mask = 1; mask < (1 << n); ++mask) \\n            if ((mask & mask-1) == 0) dp[mask] = 1; \\n            else {\\n                int lo = log2(mask & ~(mask-1)), hi = log2(mask); \\n                if (s[lo] == s[hi]) dp[mask] = 2 + dp[mask^(1<<lo)^(1<<hi)]; \\n                else dp[mask] = max(dp[mask^(1<<lo)], dp[mask^(1<<hi)]);\\n            }\\n        \\n        int ans = 0; \\n        for (int mask = 0; mask < (1 << n); ++mask) {\\n            int comp = (1 << n) - 1 ^ mask; \\n            ans = max(ans, dp[mask] * dp[comp]); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461446,
                "title": "python3-bitmask-dp",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/0de189059bd6af4dabe23d9066dde1655f3334fc) for solutions of weekly 258. \\n```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        \\n        @cache\\n        def lps(mask): \\n            \"\"\"Return length of longest palindromic sequence.\"\"\"\\n            if not mask: return 0\\n            if not mask & (mask-1): return 1\\n            lo = int(log2(mask & ~(mask-1))) # least significant set bit\\n            hi = int(log2(mask)) # most significant set bit \\n            if s[lo] == s[hi]: return 2 + lps(mask^(1<<lo)^(1<<hi))\\n            return max(lps(mask^(1<<lo)), lps(mask^(1<<hi)))\\n        \\n        ans = 0\\n        for mask in range(1 << len(s)): \\n            comp = (1 << len(s)) - 1 ^ mask\\n            ans = max(ans, lps(mask) * lps(comp))\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        \\n        @cache\\n        def lps(mask): \\n            \"\"\"Return length of longest palindromic sequence.\"\"\"\\n            if not mask: return 0\\n            if not mask & (mask-1): return 1\\n            lo = int(log2(mask & ~(mask-1))) # least significant set bit\\n            hi = int(log2(mask)) # most significant set bit \\n            if s[lo] == s[hi]: return 2 + lps(mask^(1<<lo)^(1<<hi))\\n            return max(lps(mask^(1<<lo)), lps(mask^(1<<hi)))\\n        \\n        ans = 0\\n        for mask in range(1 << len(s)): \\n            comp = (1 << len(s)) - 1 ^ mask\\n            ans = max(ans, lps(mask) * lps(comp))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1459828,
                "title": "not-2-n-o-n-2-o-p-2-where-n-is-length-of-string-and-p-is-number-of-palindromes",
                "content": "```\\n/*\\n\\tO(n^2) + O(plogp) where p is number of palindromes\\n\\n\\tAlgorithm: for each posible palindrome starting charactera look at each possible palindrome end character, and if valid, add it\\'s length and mask of bits, set corresponding to which positions were used by the palindrome, to a list of palindromes \\n\\n\\tThen sort the list from longest to shortest palindrome and check to see which two, lengths multiplied together, are the maximum value.\\n\\n*/\\nvar maxProduct = function(s) {\\n    let seen = [];\\n    function dfs(lo, hi, len, used) {\\n        for (let i = lo; i < hi; ++i) {\\n            for (let j = hi; j >= i; --j) {\\n                if (s[i] === s[j]) {\\n                    if (i === j) {\\n                        if (len > 0) {\\n                            seen.push([len + 1, used | (1 << i)]);\\n                        }\\n                    } else if (i === j - 1) {\\n                        seen.push([len + 2, used | (1 << i) | (1 << j)]);\\n                    } else if (i === j - 2) {\\n                        seen.push([len + 3, used | (1 << i) | (1 << j) | (1 << (i + 1))]);       \\n                        seen.push([len + 2, used | (1 << i) | (1 << j)]);  \\n                    } else {\\n                        seen.push([len + 2, used | (1 << i) | (1 << j)]);                          \\n                        dfs(i + 1, j - 1, len + 2, used | (1 << i) | (1 << j));\\n                    }\\n                } else if (len > 0) {\\n                    seen.push([len + 1, used | (1 << j)]);\\n                }\\n            }\\n        }\\n    }\\n    for (let i = 0; i < s.length; ++i) {\\n        seen.push([1, 1 << i]);\\n    }\\n    dfs(0, s.length - 1, 0, 0);\\n    seen.sort( (a,b) => b[0] - a[0] );\\n    let ans = 1;\\n    for (let i = 0; i < seen.length; ++i) {\\n        for (let j = i + 1; j < seen.length; ++j) {\\n            if ((seen[i][1] & seen[j][1]) === 0) {\\n                let num = seen[i][0] * seen[j][0];\\n                if (num < ans) {\\n                    break;\\n                }\\n                ans = num;\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\tO(n^2) + O(plogp) where p is number of palindromes\\n\\n\\tAlgorithm: for each posible palindrome starting charactera look at each possible palindrome end character, and if valid, add it\\'s length and mask of bits, set corresponding to which positions were used by the palindrome, to a list of palindromes \\n\\n\\tThen sort the list from longest to shortest palindrome and check to see which two, lengths multiplied together, are the maximum value.\\n\\n*/\\nvar maxProduct = function(s) {\\n    let seen = [];\\n    function dfs(lo, hi, len, used) {\\n        for (let i = lo; i < hi; ++i) {\\n            for (let j = hi; j >= i; --j) {\\n                if (s[i] === s[j]) {\\n                    if (i === j) {\\n                        if (len > 0) {\\n                            seen.push([len + 1, used | (1 << i)]);\\n                        }\\n                    } else if (i === j - 1) {\\n                        seen.push([len + 2, used | (1 << i) | (1 << j)]);\\n                    } else if (i === j - 2) {\\n                        seen.push([len + 3, used | (1 << i) | (1 << j) | (1 << (i + 1))]);       \\n                        seen.push([len + 2, used | (1 << i) | (1 << j)]);  \\n                    } else {\\n                        seen.push([len + 2, used | (1 << i) | (1 << j)]);                          \\n                        dfs(i + 1, j - 1, len + 2, used | (1 << i) | (1 << j));\\n                    }\\n                } else if (len > 0) {\\n                    seen.push([len + 1, used | (1 << j)]);\\n                }\\n            }\\n        }\\n    }\\n    for (let i = 0; i < s.length; ++i) {\\n        seen.push([1, 1 << i]);\\n    }\\n    dfs(0, s.length - 1, 0, 0);\\n    seen.sort( (a,b) => b[0] - a[0] );\\n    let ans = 1;\\n    for (let i = 0; i < seen.length; ++i) {\\n        for (let j = i + 1; j < seen.length; ++j) {\\n            if ((seen[i][1] & seen[j][1]) === 0) {\\n                let num = seen[i][0] * seen[j][0];\\n                if (num < ans) {\\n                    break;\\n                }\\n                ans = num;\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1459440,
                "title": "much-faster-than-bitmask-100ms-100",
                "content": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        \\n        @lru_cache(None)\\n        def findBigPalLen(x): #O(n^2)\\n            if len(x) <= 1: return len(x)\\n            if x[0] == x[-1]: return 2 + findBigPalLen(x[1:-1])\\n            return max(findBigPalLen(x[1:]), findBigPalLen(x[:-1]))\\n        \\n        @lru_cache(None)\\n        def findAllPal(x): #Fast pruning\\n            if len(x) == 0: \\n                return [\"\"], [x]\\n            \\n            Idx = defaultdict(list)\\n            for i,l in enumerate(x): \\n                Idx[l].append(i)\\n            \\n            X, Y = [\"\"], [x]\\n            for i in range(len(x)):\\n                X.append(x[i])\\n                Y.append(x[:i] + x[i + 1:])\\n                for j in Idx[x[i]]:\\n                    if j > i:\\n                        X1, Y1 = findAllPal(x[i + 1 : j])\\n                        for k in range(len(X1)):\\n                            X.append(x[i] + X1[k] + x[j])\\n                            Y.append(x[:i] + Y1[k] + x[j + 1:])\\n            return X,Y\\n        X, Y = findAllPal(s)\\n        return max(len(X[i]) * findBigPalLen(Y[i]) for i in range(len(X)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        \\n        @lru_cache(None)\\n        def findBigPalLen(x): #O(n^2)\\n            if len(x) <= 1: return len(x)\\n            if x[0] == x[-1]: return 2 + findBigPalLen(x[1:-1])\\n            return max(findBigPalLen(x[1:]), findBigPalLen(x[:-1]))\\n        \\n        @lru_cache(None)\\n        def findAllPal(x): #Fast pruning\\n            if len(x) == 0: \\n                return [\"\"], [x]\\n            \\n            Idx = defaultdict(list)\\n            for i,l in enumerate(x): \\n                Idx[l].append(i)\\n            \\n            X, Y = [\"\"], [x]\\n            for i in range(len(x)):\\n                X.append(x[i])\\n                Y.append(x[:i] + x[i + 1:])\\n                for j in Idx[x[i]]:\\n                    if j > i:\\n                        X1, Y1 = findAllPal(x[i + 1 : j])\\n                        for k in range(len(X1)):\\n                            X.append(x[i] + X1[k] + x[j])\\n                            Y.append(x[:i] + Y1[k] + x[j + 1:])\\n            return X,Y\\n        X, Y = findAllPal(s)\\n        return max(len(X[i]) * findBigPalLen(Y[i]) for i in range(len(X)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1459046,
                "title": "c-bottom-up-dp-mask",
                "content": "Let dp[mask] denotes the longest length of palindromic subsequence in the string \"mask\" specifies. For example, mask = \"11010\", s = \"abcad\", mask has the sequence of \"a, b, a\", and dp[mask] = 3; other code is exactly to find the longest length of palindromic. \\n\\n\\n\\'\\'\\'\\n\\n        int maxProduct(string s) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tvector<int> dp(1<<n, 0);\\n\\t\\t\\t//calculated only one letter in the subsequence, it obviously equals to 1.\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\tdp[1<<i] = 1;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int mask = 1; mask < (1 << n); mask++) {\\n\\t\\t\\t\\tint left = 0, right = 0;\\n\\t\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\t\\tif (mask & (1 << i)) {\\n\\t\\t\\t\\t\\t\\tleft = i;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\t\\t\\tif (mask & (1 << i)) {\\n\\t\\t\\t\\t\\t\\tright = i;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//we must make sure mask has at least two \"1\", since only one \"1\" is calculated.\\n\\t\\t\\t\\tif (left == right) continue;\\n\\n\\t\\t\\t\\tint newmask = mask - (1<<left) - (1 << right);\\n\\t\\t\\t\\tif (s[left] == s[right]) dp[mask] = dp[newmask] + 2;\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tdp[mask] = max(dp[mask - (1<<left)], dp[mask - (1<<right)]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint res = -1;\\n\\t\\t\\tint allones = (1<<n) - 1;\\n\\t\\t\\tfor (int mask = 1; mask < (1 << n); mask++) {\\n\\t\\t\\t\\tres = max(res, dp[mask] * dp[allones - mask]);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n    }\\n\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "Let dp[mask] denotes the longest length of palindromic subsequence in the string \"mask\" specifies. For example, mask = \"11010\", s = \"abcad\", mask has the sequence of \"a, b, a\", and dp[mask] = 3; other code is exactly to find the longest length of palindromic. \\n\\n\\n\\'\\'\\'\\n\\n        int maxProduct(string s) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tvector<int> dp(1<<n, 0);\\n\\t\\t\\t//calculated only one letter in the subsequence, it obviously equals to 1.\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\tdp[1<<i] = 1;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int mask = 1; mask < (1 << n); mask++) {\\n\\t\\t\\t\\tint left = 0, right = 0;\\n\\t\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\t\\tif (mask & (1 << i)) {\\n\\t\\t\\t\\t\\t\\tleft = i;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\t\\t\\tif (mask & (1 << i)) {\\n\\t\\t\\t\\t\\t\\tright = i;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//we must make sure mask has at least two \"1\", since only one \"1\" is calculated.\\n\\t\\t\\t\\tif (left == right) continue;\\n\\n\\t\\t\\t\\tint newmask = mask - (1<<left) - (1 << right);\\n\\t\\t\\t\\tif (s[left] == s[right]) dp[mask] = dp[newmask] + 2;\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tdp[mask] = max(dp[mask - (1<<left)], dp[mask - (1<<right)]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint res = -1;\\n\\t\\t\\tint allones = (1<<n) - 1;\\n\\t\\t\\tfor (int mask = 1; mask < (1 << n); mask++) {\\n\\t\\t\\t\\tres = max(res, dp[mask] * dp[allones - mask]);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n    }\\n\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1458613,
                "title": "python-dfs-memorisation",
                "content": "Intuition: similar to LCS, we loop through every possible combination of parlimdromic subsequences, but also introduce two extra parameter, `exclude` which is the indexes of first palindromic subsequences, `num` indicating the number of palindromic subsequences e.g. 0 means first subsequence, 1 means second subsequence.\\n\\n\\n```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        n = len(s)\\n        @cache\\n        def dfs(i: int, j: int, exclude: Tuple[int], num: int) -> int:\\n            if i > j:\\n\\t\\t\\t\\t# we found the first palindromic subsequence, go start find the second one, then  return the product\\n                if num == 0:\\n                    ret = dfs(0, n-1, exclude, 1)\\n                    return ret * len(exclude)\\n                return 0\\n            if num == 1 and i in exclude:\\n                return dfs(i+1, j, exclude, num)\\n            if num == 1 and j in exclude:\\n                return dfs(i, j-1, exclude, num)\\n            if s[i] == s[j]:\\n                add = 1 if i == j else 2\\n                e2 = exclude\\n                if num == 0:\\n                    if i == j:\\n                        e2 = exclude + (i,)\\n                    else:\\n                        e2 = exclude + (i, j)\\n\\t\\t\\t\\t\\t# We only return the length of second subsequence, first subsequence length can be retrieved with len(exclude)\\n                    add = 0\\n                r1 = dfs(i+1, j-1, e2, num) + add\\n\\t\\t\\t\\t# putting (n, 0) so we can treat the current exclude as the first subsequence, force dfs to start find the second subsequence\\n                r2 = dfs(n, 0, e2, num)\\n                r3 = dfs(n, 0, exclude + (j,), num)\\n                r4 = dfs(n, 0, exclude + (i,), num)\\n                r5 = dfs(i+1, j-1, exclude, num)\\n                return max(r1, r2, r3, r4, r5)\\n            else:\\n                r1 = dfs(i+1, j, exclude, num)\\n                r2 = dfs(i, j-1, exclude, num)\\n                r3 = dfs(i+1, j-1, exclude, num)\\n                r4 = dfs(n, 0, exclude + (j,), num)\\n                r5 = dfs(n, 0, exclude + (i,), num)\\n                return max(r1, r2, r3, r4, r5)\\n            \\n        return dfs(0, n - 1, tuple(), 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        n = len(s)\\n        @cache\\n        def dfs(i: int, j: int, exclude: Tuple[int], num: int) -> int:\\n            if i > j:\\n\\t\\t\\t\\t# we found the first palindromic subsequence, go start find the second one, then  return the product\\n                if num == 0:\\n                    ret = dfs(0, n-1, exclude, 1)\\n                    return ret * len(exclude)\\n                return 0\\n            if num == 1 and i in exclude:\\n                return dfs(i+1, j, exclude, num)\\n            if num == 1 and j in exclude:\\n                return dfs(i, j-1, exclude, num)\\n            if s[i] == s[j]:\\n                add = 1 if i == j else 2\\n                e2 = exclude\\n                if num == 0:\\n                    if i == j:\\n                        e2 = exclude + (i,)\\n                    else:\\n                        e2 = exclude + (i, j)\\n\\t\\t\\t\\t\\t# We only return the length of second subsequence, first subsequence length can be retrieved with len(exclude)\\n                    add = 0\\n                r1 = dfs(i+1, j-1, e2, num) + add\\n\\t\\t\\t\\t# putting (n, 0) so we can treat the current exclude as the first subsequence, force dfs to start find the second subsequence\\n                r2 = dfs(n, 0, e2, num)\\n                r3 = dfs(n, 0, exclude + (j,), num)\\n                r4 = dfs(n, 0, exclude + (i,), num)\\n                r5 = dfs(i+1, j-1, exclude, num)\\n                return max(r1, r2, r3, r4, r5)\\n            else:\\n                r1 = dfs(i+1, j, exclude, num)\\n                r2 = dfs(i, j-1, exclude, num)\\n                r3 = dfs(i+1, j-1, exclude, num)\\n                r4 = dfs(n, 0, exclude + (j,), num)\\n                r5 = dfs(n, 0, exclude + (i,), num)\\n                return max(r1, r2, r3, r4, r5)\\n            \\n        return dfs(0, n - 1, tuple(), 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458590,
                "title": "isn-t-this-insane-how-a-small-change-pass-by-reference-allows-tle-to-become-ac",
                "content": "Isn\\'t this insane how this small change allows the same solution to pass? Shouldn\\'t leetcode be able to discern this is not some major change and allow both?\\n\\nAccepted\\n```\\nclass Solution {\\npublic:\\n    int res, n;\\n    string str;\\n    bool isPalin(string s, int n) {\\n        for (int i=0; i<n/2; i++) {\\n            if (s[i] != s[n-1-i]) return false;\\n        }\\n        return true;\\n    }\\n    int max(int a, int b) {\\n        if (a >= b) {\\n            return a;\\n        }\\n        return b;\\n    }\\n    int max(int a, int b, int c) {\\n        int m = max(a,b);\\n        return max(m,c);\\n    }\\n    int go(int idx, string &s1, string &s2) {\\n        if (idx == n) {\\n            int l1 = s1.size();\\n            int l2 = s2.size();\\n            if (isPalin(s1, l1) && isPalin(s2, l2)) {\\n                res = max(res, l1*l2);\\n            }\\n            return res;\\n        }\\n        string s3 = s1 + str[idx];\\n        string s4 = s2 + str[idx];\\n        return max(go(idx+1, s1, s2), go(idx+1, s3, s2), go(idx+1, s1, s4));\\n    }\\n    int maxProduct(string s) {\\n        n = s.size();\\n        res = 0;\\n        str = s;\\n        string s1 = \"\";\\n        string s2 = \"\";\\n        return max(go(0,s1,s2), res);\\n    }\\n};\\n```\\n\\nTLE:\\n```\\nclass Solution {\\npublic:\\n    int res, n;\\n    string str;\\n    bool isPalin(string s, int n) {\\n        for (int i=0; i<n/2; i++) {\\n            if (s[i] != s[n-1-i]) return false;\\n        }\\n        return true;\\n    }\\n    int max(int a, int b) {\\n        if (a >= b) {\\n            return a;\\n        }\\n        return b;\\n    }\\n    int max(int a, int b, int c) {\\n        int m = max(a,b);\\n        return max(m,c);\\n    }\\n    int go(int idx, string s1, string s2) {\\n        if (idx == n) {\\n            int l1 = s1.size();\\n            int l2 = s2.size();\\n            if (isPalin(s1, l1) && isPalin(s2, l2)) {\\n                res = max(res, l1*l2);\\n            }\\n            return res;\\n        }\\n        return max(go(idx+1, s1, s2), go(idx+1, s1 + str[idx], s2), go(idx+1, s1, s2 + str[idx]));\\n    }\\n    int maxProduct(string s) {\\n        n = s.size();\\n        res = 0;\\n        str = s;\\n        return max(go(0,\"\",\"\"), res);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int res, n;\\n    string str;\\n    bool isPalin(string s, int n) {\\n        for (int i=0; i<n/2; i++) {\\n            if (s[i] != s[n-1-i]) return false;\\n        }\\n        return true;\\n    }\\n    int max(int a, int b) {\\n        if (a >= b) {\\n            return a;\\n        }\\n        return b;\\n    }\\n    int max(int a, int b, int c) {\\n        int m = max(a,b);\\n        return max(m,c);\\n    }\\n    int go(int idx, string &s1, string &s2) {\\n        if (idx == n) {\\n            int l1 = s1.size();\\n            int l2 = s2.size();\\n            if (isPalin(s1, l1) && isPalin(s2, l2)) {\\n                res = max(res, l1*l2);\\n            }\\n            return res;\\n        }\\n        string s3 = s1 + str[idx];\\n        string s4 = s2 + str[idx];\\n        return max(go(idx+1, s1, s2), go(idx+1, s3, s2), go(idx+1, s1, s4));\\n    }\\n    int maxProduct(string s) {\\n        n = s.size();\\n        res = 0;\\n        str = s;\\n        string s1 = \"\";\\n        string s2 = \"\";\\n        return max(go(0,s1,s2), res);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int res, n;\\n    string str;\\n    bool isPalin(string s, int n) {\\n        for (int i=0; i<n/2; i++) {\\n            if (s[i] != s[n-1-i]) return false;\\n        }\\n        return true;\\n    }\\n    int max(int a, int b) {\\n        if (a >= b) {\\n            return a;\\n        }\\n        return b;\\n    }\\n    int max(int a, int b, int c) {\\n        int m = max(a,b);\\n        return max(m,c);\\n    }\\n    int go(int idx, string s1, string s2) {\\n        if (idx == n) {\\n            int l1 = s1.size();\\n            int l2 = s2.size();\\n            if (isPalin(s1, l1) && isPalin(s2, l2)) {\\n                res = max(res, l1*l2);\\n            }\\n            return res;\\n        }\\n        return max(go(idx+1, s1, s2), go(idx+1, s1 + str[idx], s2), go(idx+1, s1, s2 + str[idx]));\\n    }\\n    int maxProduct(string s) {\\n        n = s.size();\\n        res = 0;\\n        str = s;\\n        return max(go(0,\"\",\"\"), res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458558,
                "title": "c-check-all-subsequences",
                "content": "Check All subsequences\\nand check their lps.\\nthen finally return the max possible ans.\\n```\\nclass Solution {\\npublic:\\n    int ans=1;\\n    unordered_map<string,int>um;\\n    void func(string s,string x,string y,int i){\\n        \\n        if(i==s.length()){\\n            ans=max(ans,functiontofindlps(x)*functiontofindlps(y));\\n            return ;\\n        }\\n        func(s,x+s[i],y,i+1);\\n        func(s,x,y+s[i],i+1);\\n    }\\n    int functiontofindlps(string s){\\n        int n=s.length();\\n        if(n==0)return 0;\\n        if(um.count(s))return um[s];\\n        vector<vector<int>>dp(n+1,vector<int>(n+1));\\n        string r=s;\\n        reverse(s.begin(),s.end());\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=n;j++){\\n                if(s[i-1]==r[j-1]){\\n                    dp[i][j]=dp[i-1][j-1]+1;\\n                }else{\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return um[s]=dp[n][n];\\n    }\\n    int maxProduct(string s) {\\n        func(s,\"\",\"\",0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=1;\\n    unordered_map<string,int>um;\\n    void func(string s,string x,string y,int i){\\n        \\n        if(i==s.length()){\\n            ans=max(ans,functiontofindlps(x)*functiontofindlps(y));\\n            return ;\\n        }\\n        func(s,x+s[i],y,i+1);\\n        func(s,x,y+s[i],i+1);\\n    }\\n    int functiontofindlps(string s){\\n        int n=s.length();\\n        if(n==0)return 0;\\n        if(um.count(s))return um[s];\\n        vector<vector<int>>dp(n+1,vector<int>(n+1));\\n        string r=s;\\n        reverse(s.begin(),s.end());\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=n;j++){\\n                if(s[i-1]==r[j-1]){\\n                    dp[i][j]=dp[i-1][j-1]+1;\\n                }else{\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return um[s]=dp[n][n];\\n    }\\n    int maxProduct(string s) {\\n        func(s,\"\",\"\",0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458555,
                "title": "java-solution-standard-recursion-and-backtracking",
                "content": "**Idea**\\nFirst you need to find the first pallin subsequence string then you need to remove that string from the original string and finding the another pallin subsequence string.\\n```\\nclass Solution {\\n\\tint max=Integer.MIN_VALUE;\\n\\tvoid recur(String str,int n,int ind,String s,List<Integer> list)\\n\\t{\\n\\t\\tif(ind==n)\\n        {   \\n           if(isPallin(str))\\n           {\\n\\t           \\tString st=\"\";\\n\\t           \\tfor(int i=0;i<n;i++)\\n\\t           \\t\\tif(!list.contains(i))\\n\\t           \\t\\t\\tst+=s.charAt(i);\\n                recur1(\"\", st.length(), 0, st,str);\\n           }\\n           return;\\n        }\\n\\t\\trecur(str,n,ind+1,s,new ArrayList(list));\\n\\t\\tstr+=s.charAt(ind);\\n\\t\\tlist.add(ind);\\n\\t\\trecur(str,n,ind+1,s,new ArrayList(list));\\n\\t}\\n\\tvoid recur1(String str,int n,int ind,String s,String st)\\n\\t{\\n\\t\\tif(ind==n)\\n        {\\n            if(isPallin(str))\\n                max=Math.max(max,st.length()*str.length());\\n            return;\\n        }\\n\\t\\trecur1(str,n,ind+1,s,st);\\n\\t\\tstr+=s.charAt(ind);\\n\\t\\trecur1(str,n,ind+1,s,st);\\n\\t}\\n\\tboolean isPallin(String s)\\n\\t{\\n\\t\\tint i=0,j=s.length()-1;\\n\\t\\twhile(i<j)\\n\\t\\t{\\n\\t\\t\\tif(s.charAt(i)!=s.charAt(j))\\n\\t\\t\\t\\treturn false;\\n            i++;\\n            j--;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n    public int maxProduct(String s) {\\n    \\t\\n        recur(\"\",s.length(),0,s,new ArrayList());\\n        return max;\\n    }\\n}\\n```\\nAny Questions??\\nelse\\nPlease do upvote:))",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n\\tint max=Integer.MIN_VALUE;\\n\\tvoid recur(String str,int n,int ind,String s,List<Integer> list)\\n\\t{\\n\\t\\tif(ind==n)\\n        {   \\n           if(isPallin(str))\\n           {\\n\\t           \\tString st=\"\";\\n\\t           \\tfor(int i=0;i<n;i++)\\n\\t           \\t\\tif(!list.contains(i))\\n\\t           \\t\\t\\tst+=s.charAt(i);\\n                recur1(\"\", st.length(), 0, st,str);\\n           }\\n           return;\\n        }\\n\\t\\trecur(str,n,ind+1,s,new ArrayList(list));\\n\\t\\tstr+=s.charAt(ind);\\n\\t\\tlist.add(ind);\\n\\t\\trecur(str,n,ind+1,s,new ArrayList(list));\\n\\t}\\n\\tvoid recur1(String str,int n,int ind,String s,String st)\\n\\t{\\n\\t\\tif(ind==n)\\n        {\\n            if(isPallin(str))\\n                max=Math.max(max,st.length()*str.length());\\n            return;\\n        }\\n\\t\\trecur1(str,n,ind+1,s,st);\\n\\t\\tstr+=s.charAt(ind);\\n\\t\\trecur1(str,n,ind+1,s,st);\\n\\t}\\n\\tboolean isPallin(String s)\\n\\t{\\n\\t\\tint i=0,j=s.length()-1;\\n\\t\\twhile(i<j)\\n\\t\\t{\\n\\t\\t\\tif(s.charAt(i)!=s.charAt(j))\\n\\t\\t\\t\\treturn false;\\n            i++;\\n            j--;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n    public int maxProduct(String s) {\\n    \\t\\n        recur(\"\",s.length(),0,s,new ArrayList());\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458502,
                "title": "javascript-bitmask-brute-force-1239ms",
                "content": "Main idea:\\n(1) get all palindrome subsequence\\n(2) parse all ways of picking two of them, if disjoint, max the product in result.\\n```\\nconst isPalindrome = (s) => { let n = s.length; let i = 0; let j = n - 1; while (i < j) { if (s[i++] != s[j--]) return false; } return true; };\\n\\nconst maxProduct = (s) => {\\n    let a = [];\\n    let n = s.length;\\n    let N = 2 ** n; // equal to 1 << n \\n    for (let i = 0; i < N; i++) { // mask\\n        let sub = \\'\\';\\n        let idx = new Set();\\n        for (let j = 0; j < n; j++) {\\n            if (i & (1 << j)) {\\n                sub += s[j];\\n                idx.add(j);\\n            }\\n        }\\n        if (isPalindrome(sub)) { // save all palindrome subsequence with index Set\\n            a.push([sub, idx]);\\n        }\\n    }\\n    let an = a.length;\\n    let res = 0;\\n    for (let i = 0; i < an; i++) {\\n        for (let j = i + 1; j < an; j++) {\\n            if (isDisjoint(a[i][0], a[j][0], a[i][1], a[j][1])) {\\n                let len = a[i][0].length * a[j][0].length; // product\\n                res = Math.max(res, len);\\n            }\\n        }\\n    }\\n    return res;\\n};\\n\\nconst isDisjoint = (s, t, is, it) => { // two subsequence index Set should be different, no same index\\n    for(const i of is) {\\n        if (it.has(i)) return false;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bitmask"
                ],
                "code": "```\\nconst isPalindrome = (s) => { let n = s.length; let i = 0; let j = n - 1; while (i < j) { if (s[i++] != s[j--]) return false; } return true; };\\n\\nconst maxProduct = (s) => {\\n    let a = [];\\n    let n = s.length;\\n    let N = 2 ** n; // equal to 1 << n \\n    for (let i = 0; i < N; i++) { // mask\\n        let sub = \\'\\';\\n        let idx = new Set();\\n        for (let j = 0; j < n; j++) {\\n            if (i & (1 << j)) {\\n                sub += s[j];\\n                idx.add(j);\\n            }\\n        }\\n        if (isPalindrome(sub)) { // save all palindrome subsequence with index Set\\n            a.push([sub, idx]);\\n        }\\n    }\\n    let an = a.length;\\n    let res = 0;\\n    for (let i = 0; i < an; i++) {\\n        for (let j = i + 1; j < an; j++) {\\n            if (isDisjoint(a[i][0], a[j][0], a[i][1], a[j][1])) {\\n                let len = a[i][0].length * a[j][0].length; // product\\n                res = Math.max(res, len);\\n            }\\n        }\\n    }\\n    return res;\\n};\\n\\nconst isDisjoint = (s, t, is, it) => { // two subsequence index Set should be different, no same index\\n    for(const i of is) {\\n        if (it.has(i)) return false;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1458443,
                "title": "c-backtracking-solution",
                "content": "```\\nclass Solution {\\n    int ans;\\n    // Check for palindrome\\n    bool isPalindrome(string& temp){\\n        int i=0,j = temp.length() - 1;\\n        while(i<j){\\n            if(temp[i]!=temp[j]){\\n                return false;\\n            }\\n            i++,j--;\\n        }\\n        return true;\\n    }\\n    \\n    void helper(int i,string& str,string temp,int prev,vector<bool> &vis){\\n        if(i==str.length()){\\n            if(isPalindrome(temp)){\\n\\t\\t\\t\\t// If we have already found 1 palindromic subsequence\\n                if(prev!=-1){\\n                    int s = temp.length();\\n                    ans=max(ans,prev*s);\\n                }\\n                else{ // Search for another palindromic subsequence\\n                    helper(0,str,\"\",temp.length(),vis);\\n                }\\n            }\\n            return ; \\n        }\\n        helper(i+1,str,temp,prev,vis);\\n        if(!vis[i]){\\n            vis[i]=true;\\n            helper(i+1,str,temp+str[i],prev,vis);\\n            vis[i]=false;\\n        }\\n    }\\n    \\npublic:\\n    int maxProduct(string s) {\\n        ans = 0;\\n        vector<bool> vis(s.length(),false);\\n        helper(0,s,\"\",-1,vis);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int ans;\\n    // Check for palindrome\\n    bool isPalindrome(string& temp){\\n        int i=0,j = temp.length() - 1;\\n        while(i<j){\\n            if(temp[i]!=temp[j]){\\n                return false;\\n            }\\n            i++,j--;\\n        }\\n        return true;\\n    }\\n    \\n    void helper(int i,string& str,string temp,int prev,vector<bool> &vis){\\n        if(i==str.length()){\\n            if(isPalindrome(temp)){\\n\\t\\t\\t\\t// If we have already found 1 palindromic subsequence\\n                if(prev!=-1){\\n                    int s = temp.length();\\n                    ans=max(ans,prev*s);\\n                }\\n                else{ // Search for another palindromic subsequence\\n                    helper(0,str,\"\",temp.length(),vis);\\n                }\\n            }\\n            return ; \\n        }\\n        helper(i+1,str,temp,prev,vis);\\n        if(!vis[i]){\\n            vis[i]=true;\\n            helper(i+1,str,temp+str[i],prev,vis);\\n            vis[i]=false;\\n        }\\n    }\\n    \\npublic:\\n    int maxProduct(string s) {\\n        ans = 0;\\n        vector<bool> vis(s.length(),false);\\n        helper(0,s,\"\",-1,vis);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458407,
                "title": "brute-force-bitmask-longest-palindromic-subsequence",
                "content": "Generate all possible splits of s into two sequences of minimum 1 character (using bitmask).\\nRun the[ longest palindromic subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/) algorithm on both parts and return the max encountered product.\\n\\n```\\nclass Solution {\\n    public int maxProduct(String s) {\\n        char[] ca= s.toCharArray();\\n        int n= ca.length, k= 1 << n, max= 1;\\n        char[] seq1= new char[12], seq2= new char[12];\\n        for(int i=1; i<k-1; i++){\\n            int n1= 0, n2= 0;\\n            for(int j= 0; j<n; ++j){\\n                if((i & (1<<j)) != 0) seq1[n1++]= ca[j];\\n                else seq2[n2++]= ca[j];\\n            }\\n            int lps1= lps(seq1, 0, n1-1), lps2= lps(seq2, 0, n2-1);\\n            max= Math.max(max, lps1*lps2);\\n        }\\n        return max;\\n    }\\n\\n    int lps(char[] seq, int i, int j) {\\n        if(i==j) return 1;\\n        if(seq[i]==seq[j] && i+1 == j) return 2;\\n        if(seq[i]==seq[j]) return lps(seq, i+1, j-1) + 2;\\n        return Math.max(lps(seq, i, j-1), lps(seq, i+1, j));\\n    }\\n}",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "class Solution {\\n    public int maxProduct(String s) {\\n        char[] ca= s.toCharArray();\\n        int n= ca.length, k= 1 << n, max= 1;\\n        char[] seq1= new char[12], seq2= new char[12];\\n        for(int i=1; i<k-1; i++){\\n            int n1= 0, n2= 0;\\n            for(int j= 0; j<n; ++j){\\n                if((i & (1<<j)) != 0) seq1[n1++]= ca[j];\\n                else seq2[n2++]= ca[j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1458385,
                "title": "java-backtracking",
                "content": "```\\n\\nclass Solution {\\n    private int maxProduct;\\n\\n    public int maxProduct(String s) {\\n        maxProduct = 0;\\n        populateMaxProduct(s, new StringBuilder(), new StringBuilder(), 0);\\n        return maxProduct;\\n    }\\n\\n    private void populateMaxProduct(String s, StringBuilder s1, StringBuilder s2, int pos) {\\n        int length = s.length();\\n        if(pos == length) {\\n            if(isPalindrome(s1.toString()) && isPalindrome(s2.toString())) {\\n                maxProduct = Math.max(maxProduct, (s1.length() * s2.length()));\\n            }\\n            return;\\n        }\\n        char ch = s.charAt(pos);\\n        s1.append(ch);\\n        populateMaxProduct(s, s1, s2, (pos + 1));\\n        s1.deleteCharAt(s1.length() - 1);\\n        s2.append(ch);\\n        populateMaxProduct(s, s1, s2, (pos + 1));\\n        s2.deleteCharAt(s2.length() - 1);\\n        populateMaxProduct(s, s1, s2, (pos + 1));\\n    }\\n\\n    private boolean isPalindrome(String s) {\\n        int low = 0, high = (s.length() - 1);\\n        while(low < high) {\\n            if(s.charAt(low) != s.charAt(high)) {\\n                return false;\\n            }\\n            low++;\\n            high--;\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    private int maxProduct;\\n\\n    public int maxProduct(String s) {\\n        maxProduct = 0;\\n        populateMaxProduct(s, new StringBuilder(), new StringBuilder(), 0);\\n        return maxProduct;\\n    }\\n\\n    private void populateMaxProduct(String s, StringBuilder s1, StringBuilder s2, int pos) {\\n        int length = s.length();\\n        if(pos == length) {\\n            if(isPalindrome(s1.toString()) && isPalindrome(s2.toString())) {\\n                maxProduct = Math.max(maxProduct, (s1.length() * s2.length()));\\n            }\\n            return;\\n        }\\n        char ch = s.charAt(pos);\\n        s1.append(ch);\\n        populateMaxProduct(s, s1, s2, (pos + 1));\\n        s1.deleteCharAt(s1.length() - 1);\\n        s2.append(ch);\\n        populateMaxProduct(s, s1, s2, (pos + 1));\\n        s2.deleteCharAt(s2.length() - 1);\\n        populateMaxProduct(s, s1, s2, (pos + 1));\\n    }\\n\\n    private boolean isPalindrome(String s) {\\n        int low = 0, high = (s.length() - 1);\\n        while(low < high) {\\n            if(s.charAt(low) != s.charAt(high)) {\\n                return false;\\n            }\\n            low++;\\n            high--;\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458377,
                "title": "python-simple-soln-brute-force",
                "content": "```\\n    def maxProduct(self, s: str) -> int:\\n        def largestP(s):\\n            n = len(s)\\n            dp = [1] * n\\n            for j in range(1, len(s)):\\n                pre = dp[j]\\n                for i in reversed(range(0, j)):\\n                    tmp = dp[i]\\n                    if s[i] == s[j]:\\n                        dp[i] = 2 + pre if i + 1 <= j - 1 else 2\\n                    else:\\n                        dp[i] = max(dp[i + 1], dp[i])\\n                    pre = tmp\\n            return dp[0]\\n        \\n        l = len(s)\\n        output = 1\\n        for i in range(1, (2**(l-1)):\\n            r = \\'\\'\\n            m = \\'\\'\\n            for j in range(l):\\n                if i & (1<< j):\\n                    r += s[j]\\n                else:\\n                    m += s[j]\\n            output = max((largestP(r) * largestP(m)), output)\\n        return output\\n            \\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\n    def maxProduct(self, s: str) -> int:\\n        def largestP(s):\\n            n = len(s)\\n            dp = [1] * n\\n            for j in range(1, len(s)):\\n                pre = dp[j]\\n                for i in reversed(range(0, j)):\\n                    tmp = dp[i]\\n                    if s[i] == s[j]:\\n                        dp[i] = 2 + pre if i + 1 <= j - 1 else 2\\n                    else:\\n                        dp[i] = max(dp[i + 1], dp[i])\\n                    pre = tmp\\n            return dp[0]\\n        \\n        l = len(s)\\n        output = 1\\n        for i in range(1, (2**(l-1)):\\n            r = \\'\\'\\n            m = \\'\\'\\n            for j in range(l):\\n                if i & (1<< j):\\n                    r += s[j]\\n                else:\\n                    m += s[j]\\n            output = max((largestP(r) * largestP(m)), output)\\n        return output\\n            \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1458331,
                "title": "brute-force-with-bitmask",
                "content": "# 1. Calculattion of length: Precompute palindrome length of every possible string subsequence\\nIterate through every possible string subsequence, if it is palindrome then it has longest palindrome length of its current size, if it is not palindrome then it is zero.\\n```\\n        int len[1<<n];\\n        for(int mask=0;mask<(1<<n);mask++) {\\n            string a=\"\";\\n            for(int i=0;i<n;i++){\\n                if(mask&(1<<i))\\n                    a+=s[i];\\n            }    \\n            if(isPalindrome(a))\\n                len[mask]=a.size();\\n            else len[mask]=0;\\n        }\\n```\\n# 2. Taking maximum:\\nChecking two mask one by one, if is not overlapping then we take maximum with ans.\\n    Basically,\\n```\\n     for(int mask1=0;mask1<(1<<n);mask1++)\\n\\t {\\n\\t     for(int mask2=0;mask2<(1<<n);mask2++)\\n\\t\\t {\\n\\t\\t     if(mask1&mask2)==0)   //donot have overlapping index\\n\\t\\t\\t     ans=max(ans,len[mask1]*len[mask2]);\\n\\t\\t } \\n\\t } \\n```\\n#  My solution:\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string &s){\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n            if(s[i]!=s[n-i-1])\\n                return false;\\n        return true;\\n    }\\n    int maxProduct(string s) {\\n        int n=s.size();\\n        int len[1<<n];\\n        for(int Bit=0;Bit<(1<<n);Bit++) {\\n            string a=\"\";\\n            for(int i=0;i<n;i++){\\n                if(Bit&(1<<i))\\n                    a+=s[i];\\n            }    \\n            if(isPalindrome(a))\\n                len[Bit]=a.size();\\n            else len[Bit]=0;\\n        }\\n        int ans=0;\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            for(int j=0;j<(1<<n);j++)\\n            {\\n                if((i&j)==0)\\n                    ans=max(ans,(len[i]*len[j]));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\n        int len[1<<n];\\n        for(int mask=0;mask<(1<<n);mask++) {\\n            string a=\"\";\\n            for(int i=0;i<n;i++){\\n                if(mask&(1<<i))\\n                    a+=s[i];\\n            }    \\n            if(isPalindrome(a))\\n                len[mask]=a.size();\\n            else len[mask]=0;\\n        }\\n```\n```\\n     for(int mask1=0;mask1<(1<<n);mask1++)\\n\\t {\\n\\t     for(int mask2=0;mask2<(1<<n);mask2++)\\n\\t\\t {\\n\\t\\t     if(mask1&mask2)==0)   //donot have overlapping index\\n\\t\\t\\t     ans=max(ans,len[mask1]*len[mask2]);\\n\\t\\t } \\n\\t } \\n```\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string &s){\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n            if(s[i]!=s[n-i-1])\\n                return false;\\n        return true;\\n    }\\n    int maxProduct(string s) {\\n        int n=s.size();\\n        int len[1<<n];\\n        for(int Bit=0;Bit<(1<<n);Bit++) {\\n            string a=\"\";\\n            for(int i=0;i<n;i++){\\n                if(Bit&(1<<i))\\n                    a+=s[i];\\n            }    \\n            if(isPalindrome(a))\\n                len[Bit]=a.size();\\n            else len[Bit]=0;\\n        }\\n        int ans=0;\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            for(int j=0;j<(1<<n);j++)\\n            {\\n                if((i&j)==0)\\n                    ans=max(ans,(len[i]*len[j]));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458326,
                "title": "brute-force-c-easy-with-comments",
                "content": "\\n\\n  \\n    // I also tried the overlap function using unordered_set, but it doesn\\'t work -> gives TLE\\n//        bool overlap(vector<int> &a, vector<int> &b){\\n//         unordered_set<int> st;\\n//         for(int curr:a)st.insert(curr);\\n//         for(int curr:b)st.insert(curr);\\n        \\n//         if(st.size()==a.size() + b.size())return 1;\\n//         return 0;\\n//     }\\n\\nclass Solution {\\npublic:\\n    \\n    // If the two arrays overlap, it returns 0, else returns 1\\n    bool overlap(vector<int> &a, vector<int> &b){\\n        \\n        int i = 0, j = 0;\\n        int n = a.size(), m = b.size();\\n        \\n        while(i<n and j<m)\\n        {\\n            if(a[i]==b[j])return 0;\\n            else if(a[i]<b[j])i++;\\n            else j++;\\n        }\\n        return 1;\\n    }\\n    \\n    int maxProduct(string s) {\\n        \\n        int n = s.size();\\n        \\n        unordered_set<char> st;\\n        for(char curr:s)st.insert(curr);\\n        \\n        // If the string contains only single character\\n        if(st.size()==1)\\n        {\\n            return (n/2)*((n+1)/2);\\n        }\\n        \\n        \\n        // Generate all the subsequences and store the indices of those\\n        // Indices will help us to find which subsequences overlap\\n        vector<vector<int>> allsub;\\n        \\n        // Generate all using bitwise\\n        for(int i = 0; i<pow(2,n); i++)\\n        {\\n            vector<int> temp;\\n            for(int j = 0; j<n; j++){\\n                if(i&(1<<j))temp.push_back(j);\\n            }\\n            \\n            // Check if the generated subsequence is palindrome or not\\n            int pali = 1;\\n            int l = 0, r = temp.size() - 1;\\n            while(r>l){\\n                if(s[temp[l]]!=s[temp[r]]){\\n                    pali = 0;break;\\n                }\\n                else l++,r--;\\n            }\\n            \\n            // If palindrome, add it to allsub\\n            if(pali==1)allsub.push_back(temp);\\n            \\n        }\\n        \\n        // Store maximum answer\\n        int maxans = 0;\\n        \\n        // Use double loop\\n        for(int i = 0; i<allsub.size(); i++){\\n            for(int j = i+1; j<allsub.size(); j++){\\n                int a = allsub[i].size();\\n                int b = allsub[j].size();\\n                // If both doesn\\'t overlap, take the product\\n                if(overlap(allsub[i],allsub[j]))\\n                    maxans = max(maxans, a*b);\\n            }\\n            \\n            \\n        }\\n        \\n        return maxans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    // If the two arrays overlap, it returns 0, else returns 1\\n    bool overlap(vector<int> &a, vector<int> &b){\\n        \\n        int i = 0, j = 0;\\n        int n = a.size(), m = b.size();\\n        \\n        while(i<n and j<m)\\n        {\\n            if(a[i]==b[j])return 0;\\n            else if(a[i]<b[j])i++;\\n            else j++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1458319,
                "title": "python-binary",
                "content": "Binary\\n- Step 1: find all palindromic subsequences\\n- Step 2: for each pair of palindromic string, if there is no disjoint, calculate the product, update the max product value\\n\\nTips to improve performance:\\nUse binary to generate all possible subsequences,\\ncache both the binary represent and length of the word\\nif two word binary and is zero, there is no overlap\\n\\nfor exampe: for word \"abcd\"\\n\\n0100 means \"b\"\\n0010 means \"c\"\\n\\n0100 & 0010 = 0, therefore, there is no overlap\\n\\nsame logic\\n0100 means \"b\"\\n0110 means \"bc\"\\n0100 & 0110 != 0, thereforem, there is overlap\\n\\n```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        all_palindromic_subsequences = []\\n        \\n        n = len(s)\\n        \\n        def isPalindromic(word):\\n            l, r = 0, len(word) - 1\\n            while l <= r:\\n                if word[l] != word[r]:\\n                    return False\\n                l += 1\\n                r -= 1\\n            return True\\n        \\n        for i in range(1 << n):\\n            cur = \"\"\\n            for j in range(n):\\n                if i & (1 << j) != 0:\\n                    cur += s[j]\\n            if cur and isPalindromic(cur):\\n                all_palindromic_subsequences.append((i, len(cur)))\\n        \\n        mx = 0\\n        n = len(all_palindromic_subsequences)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                b1, len1 = all_palindromic_subsequences[i]\\n                b2, len2 = all_palindromic_subsequences[j]\\n                if b1 & b2  == 0:  \\n                    cur_prod = len1 * len2\\n                    mx = max(mx, cur_prod)\\n        return mx\\n            \\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        all_palindromic_subsequences = []\\n        \\n        n = len(s)\\n        \\n        def isPalindromic(word):\\n            l, r = 0, len(word) - 1\\n            while l <= r:\\n                if word[l] != word[r]:\\n                    return False\\n                l += 1\\n                r -= 1\\n            return True\\n        \\n        for i in range(1 << n):\\n            cur = \"\"\\n            for j in range(n):\\n                if i & (1 << j) != 0:\\n                    cur += s[j]\\n            if cur and isPalindromic(cur):\\n                all_palindromic_subsequences.append((i, len(cur)))\\n        \\n        mx = 0\\n        n = len(all_palindromic_subsequences)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                b1, len1 = all_palindromic_subsequences[i]\\n                b2, len2 = all_palindromic_subsequences[j]\\n                if b1 & b2  == 0:  \\n                    cur_prod = len1 * len2\\n                    mx = max(mx, cur_prod)\\n        return mx\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100110,
                "title": "dp-bitmask-recurssion-c-94-18-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Initially check all LCS in the string.\\n- Create a mask of every LCS possible.\\n- Using the mask take the LCS of unset indexes.\\n- Then take the maximum of the product of both for each LCS. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int dp[1<<12][12][12];\\n    int help(string &s, int i, int j, int mask){\\n        if(i >= j){\\n            if(i == j && !(mask&(1<<i)))\\n                return 1;\\n            return 0;\\n        }\\n        \\n        if(dp[mask][i][j] != -1)\\n            return dp[mask][i][j];\\n\\n        int a = 0;\\n        if((mask&(1<<i)) || (mask&(1<<j))){\\n            if((mask&(1<<i)))\\n                a = max(a, help(s, i+1, j, mask));\\n            if(mask&(1<<j))\\n                a = max(a, help(s, i, j-1, mask));\\n        }\\n        else{\\n            if(s[i] == s[j])\\n                a = max(a, help(s, i+1, j-1, mask) + 2); \\n            a = max(a, help(s, i+1, j, mask));\\n            a = max(a, help(s, i, j-1, mask));\\n        }\\n\\n        return dp[mask][i][j] = a;\\n    }\\n    void solve(string &s, int i, int j, int len, int mask){\\n        if(i >= j){\\n            int a = 0, n = 0;\\n            if(i == j){\\n                a = 1;\\n                n = n | (1<<i);\\n            }\\n            if((mask | n) != (1<<s.length())-1)\\n                ans = max(ans, (len + a)*help(s, 0, s.length()-1, mask|n));\\n            if(mask != (1<<s.length())-1)\\n                ans = max(ans, len*help(s, 0, s.length()-1, mask));\\n\\n            return ;\\n        }\\n        \\n        if(s[i] == s[j]){\\n            int n = 0;\\n            n = n | (1<<i);\\n            n = n | (1<<j);\\n            solve(s, i+1, j-1, len+2, mask | n);\\n        }\\n\\n        solve(s, i+1, j, len, mask);\\n        solve(s, i, j-1, len, mask);\\n\\n        return;\\n    }\\n    int maxProduct(string s) {\\n        int mask = 0;\\n        memset(dp, -1, sizeof dp);\\n        solve(s, 0, s.length()-1, 0, mask);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int dp[1<<12][12][12];\\n    int help(string &s, int i, int j, int mask){\\n        if(i >= j){\\n            if(i == j && !(mask&(1<<i)))\\n                return 1;\\n            return 0;\\n        }\\n        \\n        if(dp[mask][i][j] != -1)\\n            return dp[mask][i][j];\\n\\n        int a = 0;\\n        if((mask&(1<<i)) || (mask&(1<<j))){\\n            if((mask&(1<<i)))\\n                a = max(a, help(s, i+1, j, mask));\\n            if(mask&(1<<j))\\n                a = max(a, help(s, i, j-1, mask));\\n        }\\n        else{\\n            if(s[i] == s[j])\\n                a = max(a, help(s, i+1, j-1, mask) + 2); \\n            a = max(a, help(s, i+1, j, mask));\\n            a = max(a, help(s, i, j-1, mask));\\n        }\\n\\n        return dp[mask][i][j] = a;\\n    }\\n    void solve(string &s, int i, int j, int len, int mask){\\n        if(i >= j){\\n            int a = 0, n = 0;\\n            if(i == j){\\n                a = 1;\\n                n = n | (1<<i);\\n            }\\n            if((mask | n) != (1<<s.length())-1)\\n                ans = max(ans, (len + a)*help(s, 0, s.length()-1, mask|n));\\n            if(mask != (1<<s.length())-1)\\n                ans = max(ans, len*help(s, 0, s.length()-1, mask));\\n\\n            return ;\\n        }\\n        \\n        if(s[i] == s[j]){\\n            int n = 0;\\n            n = n | (1<<i);\\n            n = n | (1<<j);\\n            solve(s, i+1, j-1, len+2, mask | n);\\n        }\\n\\n        solve(s, i+1, j, len, mask);\\n        solve(s, i, j-1, len, mask);\\n\\n        return;\\n    }\\n    int maxProduct(string s) {\\n        int mask = 0;\\n        memset(dp, -1, sizeof dp);\\n        solve(s, 0, s.length()-1, 0, mask);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090590,
                "title": "python-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        res = 0\\n        def pali(arr):\\n            s = \"\".join(arr)\\n            return s == s[::-1]\\n        \\n        def dfs(idx, a, b):\\n            nonlocal res\\n            if idx >= len(s):\\n                if pali(a) and pali(b):\\n                    res = max(res, len(a) * len(b))\\n                return\\n            \\n            a.append(s[idx])\\n            dfs(idx + 1, a, b)\\n            a.pop()\\n\\n            b.append(s[idx])\\n            dfs(idx + 1, a, b)\\n            b.pop()\\n\\n            dfs(idx + 1, a, b)\\n        dfs(0, [], [])\\n        return res\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        res = 0\\n        def pali(arr):\\n            s = \"\".join(arr)\\n            return s == s[::-1]\\n        \\n        def dfs(idx, a, b):\\n            nonlocal res\\n            if idx >= len(s):\\n                if pali(a) and pali(b):\\n                    res = max(res, len(a) * len(b))\\n                return\\n            \\n            a.append(s[idx])\\n            dfs(idx + 1, a, b)\\n            a.pop()\\n\\n            b.append(s[idx])\\n            dfs(idx + 1, a, b)\\n            b.pop()\\n\\n            dfs(idx + 1, a, b)\\n        dfs(0, [], [])\\n        return res\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056262,
                "title": "c-brute-force-bit-mask-and-2-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(2^{2N}\\\\cdot N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\n    bool palindrome(int x, string& s) {\\n        int l = 0, r = s.size()-1;\\n        while( l < r ) {\\n            if( ((1 << l) & x) == 0 ) \\n                l++;\\n\\n            if( ((1 << r) & x) == 0 )\\n                r--;\\n\\n            if( l < r && ((1 << l) & x) != 0 && ((1 << r) & x) != 0 ) {\\n                if( s[l] != s[r] )\\n                    return false;\\n\\n                l++;\\n                r--;\\n            }\\n\\n        }\\n\\n        return true;\\n    }\\n\\npublic:\\n    int maxProduct(string s) {\\n        int ans = 1;\\n        for( int a = 1 ; a < (1 << s.size()) ; a++ ) {\\n            if( !palindrome(a, s) )\\n                continue; // check a is palindrome\\n\\n            // int bit = s.size() - popcount(a);\\n            for( int b = 1 ; b < (1 << s.size()) ; b++ ) {\\n                if( (a & b) != 0 || !palindrome(b, s) ) \\n                    continue; // not disjoint, not palindrome\\n                \\n                ans = max(ans, __builtin_popcount(a) * __builtin_popcount(b));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    bool palindrome(int x, string& s) {\\n        int l = 0, r = s.size()-1;\\n        while( l < r ) {\\n            if( ((1 << l) & x) == 0 ) \\n                l++;\\n\\n            if( ((1 << r) & x) == 0 )\\n                r--;\\n\\n            if( l < r && ((1 << l) & x) != 0 && ((1 << r) & x) != 0 ) {\\n                if( s[l] != s[r] )\\n                    return false;\\n\\n                l++;\\n                r--;\\n            }\\n\\n        }\\n\\n        return true;\\n    }\\n\\npublic:\\n    int maxProduct(string s) {\\n        int ans = 1;\\n        for( int a = 1 ; a < (1 << s.size()) ; a++ ) {\\n            if( !palindrome(a, s) )\\n                continue; // check a is palindrome\\n\\n            // int bit = s.size() - popcount(a);\\n            for( int b = 1 ; b < (1 << s.size()) ; b++ ) {\\n                if( (a & b) != 0 || !palindrome(b, s) ) \\n                    continue; // not disjoint, not palindrome\\n                \\n                ans = max(ans, __builtin_popcount(a) * __builtin_popcount(b));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039142,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    bool palin(string &s)\\n    {\\n        for(int i=0;i<s.size()/2;i++)\\n        {\\n            if(s[i]!=s[s.size()-1-i])\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    void dfs(string &s,string &s1,string &s2,int index,int &ans)\\n    {\\n        if(index>=s.size())\\n        {\\n            if(palin(s1) && palin(s2))\\n            {\\n                ans=max(ans,(int)s1.size()*(int)s2.size());\\n            }\\n\\n            return;\\n        }\\n\\n        s1.push_back(s[index]);\\n        dfs(s,s1,s2,index+1,ans);\\n        s1.pop_back();\\n\\n        s2.push_back(s[index]);\\n        dfs(s,s1,s2,index+1,ans);\\n        s2.pop_back();\\n\\n        dfs(s,s1,s2,index+1,ans);\\n    }\\n\\n    int maxProduct(string s) \\n    {\\n        int ans;\\n        ans=1;\\n\\n        string s1,s2;\\n        s1=\"\";\\n        s2=\"\";\\n\\n        dfs(s,s1,s2,0,ans);\\n\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool palin(string &s)\\n    {\\n        for(int i=0;i<s.size()/2;i++)\\n        {\\n            if(s[i]!=s[s.size()-1-i])\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    void dfs(string &s,string &s1,string &s2,int index,int &ans)\\n    {\\n        if(index>=s.size())\\n        {\\n            if(palin(s1) && palin(s2))\\n            {\\n                ans=max(ans,(int)s1.size()*(int)s2.size());\\n            }\\n\\n            return;\\n        }\\n\\n        s1.push_back(s[index]);\\n        dfs(s,s1,s2,index+1,ans);\\n        s1.pop_back();\\n\\n        s2.push_back(s[index]);\\n        dfs(s,s1,s2,index+1,ans);\\n        s2.pop_back();\\n\\n        dfs(s,s1,s2,index+1,ans);\\n    }\\n\\n    int maxProduct(string s) \\n    {\\n        int ans;\\n        ans=1;\\n\\n        string s1,s2;\\n        s1=\"\";\\n        s2=\"\";\\n\\n        dfs(s,s1,s2,0,ans);\\n\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017839,
                "title": "making-use-of-longest-palindromic-subsequences-bitmasking-and-dp",
                "content": "Here, we first try to generate all possible subsequences, and then for each generated subsequence we check whether we can find two disjoing longest palindromic subsequences, and if we can form we find the max product possible.\\n\\n\\n\\n\\n\\t\\tdef longestpalSubseq(s):\\n\\t\\t\\t\\tt = s[::-1]\\n\\n\\t\\t\\t\\tn,m=len(s),len(t)\\n\\n\\t\\t\\t\\tdp=[[0]*(m+1) for _ in range(n+1)]\\n\\n\\t\\t\\t\\tfor i in range(n+1):\\n\\t\\t\\t\\t\\tdp[i][0]=0\\n\\n\\t\\t\\t\\tfor j in range(m+1):\\n\\t\\t\\t\\t\\tdp[0][j]=0\\n\\n\\t\\t\\t\\tfor i in range(1,n+1):\\n\\t\\t\\t\\t\\tfor j in range(1,m+1):\\n\\n\\t\\t\\t\\t\\t\\tif s[i-1]==t[j-1]:\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j]=1+dp[i-1][j-1]\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j] = max(dp[i-1][j], dp[i][j-1])\\n\\n\\t\\t\\t\\treturn dp[n][m]\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef maxProduct(self, s: str) -> int:\\n\\t\\t\\t\\tans =0\\n\\t\\t\\t\\tdef cnt_length_palindrome(m):\\n\\t\\t\\t\\t\\tnonlocal ans\\n\\t\\t\\t\\t\\tval =0\\n\\t\\t\\t\\t\\tstring1=\"\"\\n\\t\\t\\t\\t\\tstring2=\"\"\\n\\t\\t\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\t\\t\\tif m&(1<<i):\\n\\t\\t\\t\\t\\t\\t\\tstring1+=s[i]\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tstring2+=s[i]\\n\\t\\t\\t\\t\\tif string1 and string2:\\n\\t\\t\\t\\t\\t\\tans = max(ans,longestpalSubseq(string1)*longestpalSubseq(string2))\\n\\n\\t\\t\\t\\tmask = 0\\n\\t\\t\\t\\tn=len(s)\\n\\t\\t\\t\\tcnt=0\\n\\n\\t\\t\\t\\tdef recur(idx,mask):\\n\\t\\t\\t\\t\\tnonlocal cnt\\n\\t\\t\\t\\t\\tif idx>=n:\\n\\t\\t\\t\\t\\t\\tcnt+=1\\n\\t\\t\\t\\t\\t\\tif mask!=0 or mask!=((1<<n)-1):\\n\\t\\t\\t\\t\\t\\t\\tcnt_length_palindrome(mask)\\n\\t\\t\\t\\t\\t\\treturn mask\\n\\t\\t\\t\\t\\tfor i in range(idx,n):\\n\\t\\t\\t\\t\\t\\tmask ^= (1<<i)\\n\\t\\t\\t\\t\\t\\trecur(i+1,mask)\\n\\t\\t\\t\\t\\t\\tmask ^= (1<<i)\\n\\n\\n\\t\\t\\t\\trecur(0,0)\\n\\t\\t\\t\\treturn ans\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Recursion",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "Here, we first try to generate all possible subsequences, and then for each generated subsequence we check whether we can find two disjoing longest palindromic subsequences, and if we can form we find the max product possible.\\n\\n\\n\\n\\n\\t\\tdef longestpalSubseq(s):\\n\\t\\t\\t\\tt = s[::-1]\\n\\n\\t\\t\\t\\tn,m=len(s),len(t)\\n\\n\\t\\t\\t\\tdp=[[0]*(m+1) for _ in range(n+1)]\\n\\n\\t\\t\\t\\tfor i in range(n+1):\\n\\t\\t\\t\\t\\tdp[i][0]=0\\n\\n\\t\\t\\t\\tfor j in range(m+1):\\n\\t\\t\\t\\t\\tdp[0][j]=0\\n\\n\\t\\t\\t\\tfor i in range(1,n+1):\\n\\t\\t\\t\\t\\tfor j in range(1,m+1):\\n\\n\\t\\t\\t\\t\\t\\tif s[i-1]==t[j-1]:\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j]=1+dp[i-1][j-1]\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j] = max(dp[i-1][j], dp[i][j-1])\\n\\n\\t\\t\\t\\treturn dp[n][m]\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef maxProduct(self, s: str) -> int:\\n\\t\\t\\t\\tans =0\\n\\t\\t\\t\\tdef cnt_length_palindrome(m):\\n\\t\\t\\t\\t\\tnonlocal ans\\n\\t\\t\\t\\t\\tval =0\\n\\t\\t\\t\\t\\tstring1=\"\"\\n\\t\\t\\t\\t\\tstring2=\"\"\\n\\t\\t\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\t\\t\\tif m&(1<<i):\\n\\t\\t\\t\\t\\t\\t\\tstring1+=s[i]\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tstring2+=s[i]\\n\\t\\t\\t\\t\\tif string1 and string2:\\n\\t\\t\\t\\t\\t\\tans = max(ans,longestpalSubseq(string1)*longestpalSubseq(string2))\\n\\n\\t\\t\\t\\tmask = 0\\n\\t\\t\\t\\tn=len(s)\\n\\t\\t\\t\\tcnt=0\\n\\n\\t\\t\\t\\tdef recur(idx,mask):\\n\\t\\t\\t\\t\\tnonlocal cnt\\n\\t\\t\\t\\t\\tif idx>=n:\\n\\t\\t\\t\\t\\t\\tcnt+=1\\n\\t\\t\\t\\t\\t\\tif mask!=0 or mask!=((1<<n)-1):\\n\\t\\t\\t\\t\\t\\t\\tcnt_length_palindrome(mask)\\n\\t\\t\\t\\t\\t\\treturn mask\\n\\t\\t\\t\\t\\tfor i in range(idx,n):\\n\\t\\t\\t\\t\\t\\tmask ^= (1<<i)\\n\\t\\t\\t\\t\\t\\trecur(i+1,mask)\\n\\t\\t\\t\\t\\t\\tmask ^= (1<<i)\\n\\n\\n\\t\\t\\t\\trecur(0,0)\\n\\t\\t\\t\\treturn ans\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 3979754,
                "title": "c-solution-using-hashmap-and-bit-manipulation",
                "content": "class Solution {\\npublic:\\n    int maxProduct(string s) {\\n        \\n        int n = s.size();\\n        \\n        unordered_map<int , int> pali;\\n        \\n        for(int mask = 1; mask < (1 << n) ; mask++){\\n            string subseq = \"\";\\n            \\n            for(int i=0;i<n;i++){\\n                if(mask & (1<<i)){\\n                    subseq += s[i];\\n                }\\n            }\\n            if(subseq == string(subseq.rbegin() , subseq.rend())){\\n                pali[mask] = subseq.size();\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(auto m1 : pali){\\n            for(auto m2 : pali){\\n                if((m1.first & m2.first) == 0){\\n                    res = max(res , m1.second * m2.second);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n/*\\nint main() {\\n    Solution solution;\\n\\n    // Define the input string\\n    string input_string = \"ababbb\";\\n\\n    // Call the maxProduct method with the input and print the result\\n    int result = solution.maxProduct(input_string);\\n    cout << result << endl;\\n\\n    return 0;\\n}\\n*/",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    int maxProduct(string s) {\\n        \\n        int n = s.size();\\n        \\n        unordered_map<int , int> pali;\\n        \\n        for(int mask = 1; mask < (1 << n) ; mask++){\\n            string subseq = \"\";\\n            \\n            for(int i=0;i<n;i++){\\n                if(mask & (1<<i)){\\n                    subseq += s[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3979726,
                "title": "python3-solution-using-hashmap-and-bitmanipulation",
                "content": "## time: o(2^n)\\n## space: o(2^n)\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        \\n        n = len(s);\\n        \\n        ##create a hashmap as follows\\n        \\n        pali = {} # bitmask of sub pailndrome : length of that palindrome\\n        \\n        for mask in range(1 , 1<<n): # 1<<n == 1<<2**n\\n            \\n            ## create an empyty string to convert back the bitmask\\n            subseq = \"\"\\n            for i in range(n):\\n                \\n                ## the above line inidcates that and operation gives 1 \\n                if(mask & (1<<i)):\\n                    subseq += s[i];\\n            ## check if the subsequnce string is palindrome        \\n            if subseq == subseq[::-1]:\\n                ##then assing the key and value in hashmap\\n                pali[mask] = len(subseq)\\n                \\n                \\n        res = 0\\n        \\n        for m1 in pali:\\n            for m2 in pali:\\n                if(m1 & m2) == 0: #disjoint\\n                    res = max(res , pali[m1] * pali[m2])\\n        return res         \\n                \\n        \\n# Create an instance of the Solution class\\n#solution = Solution()\\n\\n# Define the input string\\n#input_string = \"ababbb\"\\n\\n# Call the maxProduct method with the input and print the result\\n#result = solution.maxProduct(input_string)\\n#print(result)#",
                "solutionTags": [
                    "Python3",
                    "Bitmask"
                ],
                "code": "class Solution:\\n    def maxProduct(self, s: str) -> int:\\n        \\n        n = len(s);\\n        \\n        ##create a hashmap as follows\\n        \\n        pali = {}",
                "codeTag": "Java"
            },
            {
                "id": 3972200,
                "title": "recursion-backtracking-and-bitmasking",
                "content": "1. First generate all subsequences of the string using take, not take approach and backtracking.\\n2. Then check if each subsequence is palindrome.\\n3. If palindrome then find bitmask of that palindrome subsequence and store the length of that palindrome in hashmap.\\n4. Then iterate through every pair of the hashmap item and if no common index between them then store the max product.\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int,int> palLength;\\nprivate:\\n    int n = 0;\\npublic:\\n    int maxProduct(string s) {\\n        this->n = s.length();\\n        vector<int> sub;\\n        recursion(s, 0, sub);\\n        \\n        int result = 1;\\n        for(auto pal1 : palLength) {\\n            for(auto pal2 : palLength) {\\n                if((pal1.first & pal2.first) == 0) {\\n                    int current = pal1.second * pal2.second;\\n                    result = max(result, current);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\nprivate:\\n    void recursion(string s, int index, vector<int>& sub) {\\n        if(index == n) {\\n            if(isPalindrome(s, sub)) {\\n                int mask = getMask(sub);\\n                palLength[mask] = sub.size();\\n            }\\n            \\n            return;\\n        }\\n        \\n        // Not take the current\\n        recursion(s, index + 1, sub);\\n        \\n        // Take the current\\n        sub.push_back(index);\\n        recursion(s, index + 1, sub);\\n        \\n        // Backtrack\\n        sub.pop_back();\\n    }\\n    \\nprivate:\\n    bool isPalindrome(string& s, vector<int>& sub) {\\n        int i = 0;\\n        int j = sub.size() - 1;\\n        \\n        while(i < j) {\\n            if(s[sub[i]] != s[sub[j]]) {\\n                return false;\\n            }\\n            \\n            i++;\\n            j--;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int getMask(vector<int>& sub) {\\n        int mask = 0;\\n        for(int index : sub) {\\n            mask = mask | (1 << index);\\n        }\\n        \\n        return mask;\\n    }\\n};\\n\\n// Time Complexity: (4^N)\\n// Space Complexity: O(4^N) + call stack\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_map<int,int> palLength;\\nprivate:\\n    int n = 0;\\npublic:\\n    int maxProduct(string s) {\\n        this->n = s.length();\\n        vector<int> sub;\\n        recursion(s, 0, sub);\\n        \\n        int result = 1;\\n        for(auto pal1 : palLength) {\\n            for(auto pal2 : palLength) {\\n                if((pal1.first & pal2.first) == 0) {\\n                    int current = pal1.second * pal2.second;\\n                    result = max(result, current);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\nprivate:\\n    void recursion(string s, int index, vector<int>& sub) {\\n        if(index == n) {\\n            if(isPalindrome(s, sub)) {\\n                int mask = getMask(sub);\\n                palLength[mask] = sub.size();\\n            }\\n            \\n            return;\\n        }\\n        \\n        // Not take the current\\n        recursion(s, index + 1, sub);\\n        \\n        // Take the current\\n        sub.push_back(index);\\n        recursion(s, index + 1, sub);\\n        \\n        // Backtrack\\n        sub.pop_back();\\n    }\\n    \\nprivate:\\n    bool isPalindrome(string& s, vector<int>& sub) {\\n        int i = 0;\\n        int j = sub.size() - 1;\\n        \\n        while(i < j) {\\n            if(s[sub[i]] != s[sub[j]]) {\\n                return false;\\n            }\\n            \\n            i++;\\n            j--;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int getMask(vector<int>& sub) {\\n        int mask = 0;\\n        for(int index : sub) {\\n            mask = mask | (1 << index);\\n        }\\n        \\n        return mask;\\n    }\\n};\\n\\n// Time Complexity: (4^N)\\n// Space Complexity: O(4^N) + call stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970596,
                "title": "bitmasking-java",
                "content": "# Intuition\\nGenerate all subsequences of the `string` and make sure that they are \\n`disjoint` using the `bitmasking` which gives the speed to this approach. \\n\\n# Approach\\nFind store the mask of the string with there length in a HashMap so to make operation of getting faster.\\n\\nEg.\\n\\n`apple`\\nsubsequence \"al\" in bitmap\\n`10010`\\n\\n# Complexity\\n- Time complexity:\\nO(2 ^ len(s))\\n\\n- Space complexity:\\nO(2 ^ len(s))\\n\\nThis makes sense as the input of the problem is restricted by \\n12.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProduct(String s) {\\n        int N = s.length();\\n        HashMap<Integer, Integer> palindromes = new HashMap<>();\\n\\n        for (int mask = 1; mask < 1 << N; ++mask) {\\n            StringBuilder sb = new StringBuilder(\"\");\\n            for (int j = 0; j < N; ++j) {\\n                if ((mask & (1 << j)) > 0) { // finding a subsequence\\n                    sb.append(s.charAt(j));\\n                }\\n            }\\n            String curr = sb.toString();\\n            String rev = sb.reverse().toString();\\n            if (rev.equals(curr)) {\\n                palindromes.put(mask, rev.length());\\n            }\\n        }\\n\\n        int result = 0; \\n        for (Map.Entry<Integer, Integer> it : palindromes.entrySet()) {\\n            for (Map.Entry<Integer, Integer> jt : palindromes.entrySet()) {\\n                if ((it.getKey() & jt.getKey()) == 0) { // if disjoint\\n                    result = Math.max(result, it.getValue() * jt.getValue());\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n#Python\\n\\n```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        N, pali = len(s), {}\\n\\n        for mask in range(1, 1 << N):\\n            subseq = \"\"\\n            for i in range(N):\\n                if mask & (1 << i):\\n                    subseq += s[i]\\n            \\n            if subseq == subseq[::-1]:\\n                pali[mask] = len(subseq)\\n        \\n        res = 0\\n\\n        for k1 in pali:\\n            for k2 in pali:\\n                if k1 & k2 == 0:\\n                    res = max(res, pali[k1] * pali[k2])\\n        \\n        return res\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(String s) {\\n        int N = s.length();\\n        HashMap<Integer, Integer> palindromes = new HashMap<>();\\n\\n        for (int mask = 1; mask < 1 << N; ++mask) {\\n            StringBuilder sb = new StringBuilder(\"\");\\n            for (int j = 0; j < N; ++j) {\\n                if ((mask & (1 << j)) > 0) { // finding a subsequence\\n                    sb.append(s.charAt(j));\\n                }\\n            }\\n            String curr = sb.toString();\\n            String rev = sb.reverse().toString();\\n            if (rev.equals(curr)) {\\n                palindromes.put(mask, rev.length());\\n            }\\n        }\\n\\n        int result = 0; \\n        for (Map.Entry<Integer, Integer> it : palindromes.entrySet()) {\\n            for (Map.Entry<Integer, Integer> jt : palindromes.entrySet()) {\\n                if ((it.getKey() & jt.getKey()) == 0) { // if disjoint\\n                    result = Math.max(result, it.getValue() * jt.getValue());\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        N, pali = len(s), {}\\n\\n        for mask in range(1, 1 << N):\\n            subseq = \"\"\\n            for i in range(N):\\n                if mask & (1 << i):\\n                    subseq += s[i]\\n            \\n            if subseq == subseq[::-1]:\\n                pali[mask] = len(subseq)\\n        \\n        res = 0\\n\\n        for k1 in pali:\\n            for k2 in pali:\\n                if k1 & k2 == 0:\\n                    res = max(res, pali[k1] * pali[k2])\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969604,
                "title": "two-bad-approaches-very-easy-python3-backtracking",
                "content": "Everyone here writes perfect and optimized code. I am here to mix things up with my pretty bad code. Here are two approaches that are both very bad.\\n\\n\\n# Approach 1\\nThe code is pretty self explanatory but I will try to give a high level summary in the following points:\\n- First I have taken 4 variables `first, rev_first, second, rev_second`. I use these to store first subsequence, reverse of first subsequence, second subsequence and reverse of second subsequence.\\n- I am traversing through the string recursively and choosing for every index if it should go in first or it should go in second subsequence. I am also maintaining the reverse of both of these substrings by adding to the back of a deque so that in the end I could compare first with rev_first and second with rev_second and find out if both of these constructed subsequences are palindromes.\\n- The nature of backtracking makes sure that these subsequences are disjoint subsequences. And we check for if they are palindromes later. That completes our formation of dijoint plaindromic subsequences and we just check if what we have now is greater than our current stores answer in the line `self.ret = max(self.ret, len(first)*len(second))`\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        N = len(s)\\n        self.ret = 1\\n        def backtrack(idx):\\n            if idx >= N:\\n                if first == rev_first and second == rev_second:\\n                    self.ret = max(self.ret, len(first)*len(second))\\n                return \\n            backtrack(idx+1)\\n            first.append(s[idx])\\n            rev_first.appendleft(s[idx])\\n            backtrack(idx+1)\\n            first.pop()\\n            rev_first.popleft()\\n            second.append(s[idx])\\n            rev_second.appendleft(s[idx])\\n            backtrack(idx+1)\\n            second.pop()\\n            rev_second.popleft()\\n        first, second = deque([]), deque([])\\n        rev_first, rev_second = deque([]), deque([])\\n        backtrack(0)\\n        return self.ret\\n            \\n```\\n\\n# Approach 2\\nWe do everything same as approach 1 but instead of maintaining a rev_first and a rev_second we just call isPali function on first and second which checks if they are palindromes or not. \\n\\n```\\n\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        def isPali(seq):\\n            i, j = 0, len(seq)-1\\n            while i<j:\\n                if seq[i] != seq[j]:\\n                    return False\\n                i += 1\\n                j -= 1\\n            return True\\n        N = len(s)\\n        self.ret = 1\\n        def backtrack(idx):\\n            if idx >= N:\\n                if isPali(first) and isPali(second):\\n                    self.ret = max(self.ret, len(first)*len(second))\\n                return \\n            backtrack(idx+1)\\n            # calling after adding to first subsequence\\n            first.append(s[idx])\\n            backtrack(idx+1)\\n            first.pop()\\n            #calling after adding to second subsequence\\n            second.append(s[idx])\\n            backtrack(idx+1)\\n            second.pop()\\n        first, second = [], []\\n        backtrack(0)\\n        return self.ret\\n\\n\\n```\\n\\n# Time and space = ?\\nidk, I guess it should be (3^n) * 2n.\\nBecause, there are a total of 3^n possibilities that we go into and in each one of them we check if first and second are palindromes which is O(n) for both.\\n\\nI think, time = O(3^n * 2n)\\nWhich truncates to O(3^n)\\n\\nI am not sure though. Upvote if you also like simple solutions like me and are easily intimidated by stuff like bitmask that other people have effortlessly used in other solutions here. LOL. Happy Coding !!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        N = len(s)\\n        self.ret = 1\\n        def backtrack(idx):\\n            if idx >= N:\\n                if first == rev_first and second == rev_second:\\n                    self.ret = max(self.ret, len(first)*len(second))\\n                return \\n            backtrack(idx+1)\\n            first.append(s[idx])\\n            rev_first.appendleft(s[idx])\\n            backtrack(idx+1)\\n            first.pop()\\n            rev_first.popleft()\\n            second.append(s[idx])\\n            rev_second.appendleft(s[idx])\\n            backtrack(idx+1)\\n            second.pop()\\n            rev_second.popleft()\\n        first, second = deque([]), deque([])\\n        rev_first, rev_second = deque([]), deque([])\\n        backtrack(0)\\n        return self.ret\\n            \\n```\n```\\n\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        def isPali(seq):\\n            i, j = 0, len(seq)-1\\n            while i<j:\\n                if seq[i] != seq[j]:\\n                    return False\\n                i += 1\\n                j -= 1\\n            return True\\n        N = len(s)\\n        self.ret = 1\\n        def backtrack(idx):\\n            if idx >= N:\\n                if isPali(first) and isPali(second):\\n                    self.ret = max(self.ret, len(first)*len(second))\\n                return \\n            backtrack(idx+1)\\n            # calling after adding to first subsequence\\n            first.append(s[idx])\\n            backtrack(idx+1)\\n            first.pop()\\n            #calling after adding to second subsequence\\n            second.append(s[idx])\\n            backtrack(idx+1)\\n            second.pop()\\n        first, second = [], []\\n        backtrack(0)\\n        return self.ret\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943660,
                "title": "c-easy-solution-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int max(int a, int b )\\n    {\\n        if(a>=b)\\n            return a; \\n        return b ; \\n    }\\n    \\n    bool ispal( int &a , string &s )\\n    {\\n        string res=\"\"; \\n        \\n        for(int i =0 ; i<s.length(); i++ )\\n        {\\n            if(a&(1<<i))\\n            {\\n                res+=s[i] ;\\n            }\\n        }\\n        \\n        string ss =res; \\n        reverse(begin(ss), end(ss)) ;\\n        \\n      return ss== res ; \\n     }\\n    \\n\\n    \\n    int  cal(int i , string &s ,  int s1 , int s2 )\\n    {\\n        \\n        if(i==s.length())\\n        {\\n            if(s1!=0 && s2!=0 )\\n            {\\n                if(ispal(s1 ,s) && ispal(s2 ,s ))\\n                    return (__builtin_popcount(s1))*(__builtin_popcount(s2)) ;\\n            }\\n        return 0 ; \\n        }\\n        \\n       int x = cal(i+1 , s , s1|(1<<i) , s2 ) ; \\n       int y =  cal(i+1 , s , s1 , s2|(1<<i) ) ; \\n        int z = cal(i+1, s , s1 , s2 ) ;\\n     \\n        return  max( max(x,y ), z ) ;\\n    }\\n    \\n    int maxProduct(string s) {\\n    \\n      \\n     return   cal(0 , s , 0 , 0  ) ; \\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int max(int a, int b )\\n    {\\n        if(a>=b)\\n            return a; \\n        return b ; \\n    }\\n    \\n    bool ispal( int &a , string &s )\\n    {\\n        string res=\"\"; \\n        \\n        for(int i =0 ; i<s.length(); i++ )\\n        {\\n            if(a&(1<<i))\\n            {\\n                res+=s[i] ;\\n            }\\n        }\\n        \\n        string ss =res; \\n        reverse(begin(ss), end(ss)) ;\\n        \\n      return ss== res ; \\n     }\\n    \\n\\n    \\n    int  cal(int i , string &s ,  int s1 , int s2 )\\n    {\\n        \\n        if(i==s.length())\\n        {\\n            if(s1!=0 && s2!=0 )\\n            {\\n                if(ispal(s1 ,s) && ispal(s2 ,s ))\\n                    return (__builtin_popcount(s1))*(__builtin_popcount(s2)) ;\\n            }\\n        return 0 ; \\n        }\\n        \\n       int x = cal(i+1 , s , s1|(1<<i) , s2 ) ; \\n       int y =  cal(i+1 , s , s1 , s2|(1<<i) ) ; \\n        int z = cal(i+1, s , s1 , s2 ) ;\\n     \\n        return  max( max(x,y ), z ) ;\\n    }\\n    \\n    int maxProduct(string s) {\\n    \\n      \\n     return   cal(0 , s , 0 , 0  ) ; \\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885684,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func maxProduct(_ s: String) -> Int {\\n\\n        let s = Array(s)\\n\\n        func pals(_ l: Int = 0, _ r: Int = s.count - 1) -> [[Int]] {\\n            guard l <= r else { return [[]] }\\n            var res: [[Int]] = [[]] + (l...r).map { [$0] }\\n            var b = l\\n            while b < r {\\n                var e = r\\n                while b < e {\\n                    while b < e, s[b] != s[e] { e -= 1 }\\n                    if b < e { res += pals(b + 1, e - 1).map { [b] + $0 + [e] } }\\n                    e -= 1\\n                }\\n                b += 1\\n            }\\n            return res\\n        }\\n\\n        var res = 0\\n        let vars = pals()\\n            .map(Set.init)\\n            .sorted { $0.count > $1.count }\\n\\n        for i in 0..<vars.count - 1 {\\n            if vars[i].count * vars[i].count < res { break }\\n            for j in 1 + i..<vars.count {\\n                if vars[i].count * vars[j].count < res { break }\\n                if vars[i].intersection(vars[j]).isEmpty {\\n                    res = max(res, vars[i].count * vars[j].count)\\n                }\\n            }\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxProduct(_ s: String) -> Int {\\n\\n        let s = Array(s)\\n\\n        func pals(_ l: Int = 0, _ r: Int = s.count - 1) -> [[Int]] {\\n            guard l <= r else { return [[]] }\\n            var res: [[Int]] = [[]] + (l...r).map { [$0] }\\n            var b = l\\n            while b < r {\\n                var e = r\\n                while b < e {\\n                    while b < e, s[b] != s[e] { e -= 1 }\\n                    if b < e { res += pals(b + 1, e - 1).map { [b] + $0 + [e] } }\\n                    e -= 1\\n                }\\n                b += 1\\n            }\\n            return res\\n        }\\n\\n        var res = 0\\n        let vars = pals()\\n            .map(Set.init)\\n            .sorted { $0.count > $1.count }\\n\\n        for i in 0..<vars.count - 1 {\\n            if vars[i].count * vars[i].count < res { break }\\n            for j in 1 + i..<vars.count {\\n                if vars[i].count * vars[j].count < res { break }\\n                if vars[i].intersection(vars[j]).isEmpty {\\n                    res = max(res, vars[i].count * vars[j].count)\\n                }\\n            }\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858405,
                "title": "simplest-solution-with-explanation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // To check whether a string is palindrome or not.\\n    bool isPalindrome(string s) {\\n        int n = s.size();\\n        for (int i = 0; i < n / 2; i++) {\\n            if (s[i] != s[n-i-1]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int maxProduct(int i, string s1, string s2, string &s) {\\n        // If we have traversed the whole string, we check the two strings picked on the way whether they are\\n        // palindrome or not. If they are, we can return their product.\\n        if (i == s.size()) {\\n\\n            if (isPalindrome(s1) && isPalindrome(s2)) {\\n                return (s1.size()) * (s2.size());\\n            }\\n            return 0;\\n        }\\n\\n        // We have two options for every index either not pick it or pick it.\\n        // If we want to pick it we can add it to string1 or string2 but not both simultaneously.\\n        int notTake = maxProduct(i + 1, s1, s2, s); \\n        int take1 = maxProduct(i + 1, s1 + s[i], s2, s);\\n        int take2 = maxProduct(i + 1, s1, s2 + s[i], s);\\n\\n        // Finally we take max of all options.\\n        return max({notTake, take1, take2});\\n    }\\n    int maxProduct(string s) {\\n        return maxProduct(0, \"\", \"\", s); // [index, string1, string2, string]\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // To check whether a string is palindrome or not.\\n    bool isPalindrome(string s) {\\n        int n = s.size();\\n        for (int i = 0; i < n / 2; i++) {\\n            if (s[i] != s[n-i-1]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int maxProduct(int i, string s1, string s2, string &s) {\\n        // If we have traversed the whole string, we check the two strings picked on the way whether they are\\n        // palindrome or not. If they are, we can return their product.\\n        if (i == s.size()) {\\n\\n            if (isPalindrome(s1) && isPalindrome(s2)) {\\n                return (s1.size()) * (s2.size());\\n            }\\n            return 0;\\n        }\\n\\n        // We have two options for every index either not pick it or pick it.\\n        // If we want to pick it we can add it to string1 or string2 but not both simultaneously.\\n        int notTake = maxProduct(i + 1, s1, s2, s); \\n        int take1 = maxProduct(i + 1, s1 + s[i], s2, s);\\n        int take2 = maxProduct(i + 1, s1, s2 + s[i], s);\\n\\n        // Finally we take max of all options.\\n        return max({notTake, take1, take2});\\n    }\\n    int maxProduct(string s) {\\n        return maxProduct(0, \"\", \"\", s); // [index, string1, string2, string]\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849882,
                "title": "c-all-possible-palindromic-subsequence-bit-mask-string",
                "content": "# Intuition\\nwe can generate all possible subsequences of the given string and check if each subsequence is a palindrome. Then, we can find two non-intersecting subsequences with the maximum product of their lengths.\\n\\n# Approach\\nThe given code provides a solution using a brute force approach. It defines a class `Solution` with a function `maxProduct` that takes the input string `s` and returns the maximum product of the lengths of two non-intersecting palindromic subsequences.\\n\\nThe steps of the approach are as follows:\\n1. Define an `unordered_map` named `allPalSubseq` to store the lengths of all palindromic subsequences in the given string.\\n2. Define a helper function `isPal` to check if a given string is a palindrome or not.\\n3. Generate all subsequences of the input string and check if each subsequence is a palindrome using the `isPal` function. Store the lengths of palindromic subsequences and their respective bitmask in the `allPalSubseq` map.\\n4. Iterate through all pairs of subsequences in the `allPalSubseq` map and find two subsequences that are non-intersecting (i.e., their bitmasks have a bitwise AND equal to 0). Calculate the product of their lengths and keep track of the maximum product found so far.\\n\\n# Complexity\\n- Time complexity: The time complexity is dominated by the generation of all subsequences, which is done using bit manipulation. Generating all subsequences will take O(2^n) time, where n is the size of the input string. The `isPal` function\\'s time complexity is O(n/2) on average, where n is the length of the input string. Therefore, the overall time complexity is O(2^n * 2^n) as we need to find product for all disjoint subsequence.\\n- Space complexity: The space complexity is O(2^n) as we need to store all subsequences and their respective lengths in the `allPalSubseq` map. Additionally, the space complexity of the `isPal` function is O(1) as it uses only a constant amount of extra space. Therefore, the overall space complexity is O(2^n).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> allPalSubseq; \\n\\n    bool isPal(string str){\\n        int i = 0 , j = str.size()-1; \\n        while(i<=j){\\n            if(str[i] != str[j]){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    void generateAllPalindromicSeq(string s){\\n        int sz = s.size();\\n        int allseqcnt = (1 << sz) - 1;\\n\\n        for(int i = 1 ; i <= allseqcnt ; ++i){\\n            string str = \"\";\\n            for(int j = 0 ; j < sz ; ++j){\\n                if((i & (1 << j)))\\n                    str.push_back(s[j]);\\n            }\\n            if(isPal(str)){\\n                allPalSubseq[i] = str.size();\\n            }\\n        }\\n    }\\n\\n    int maxProduct(string s) {\\n\\n        int result = -1;\\n        generateAllPalindromicSeq(s);\\n\\n        for(auto each : allPalSubseq){\\n            for(auto each1: allPalSubseq){\\n                if( (each.first & each1.first) == 0){\\n                    int prod = each.second * each1.second;\\n                    result = max(result, prod);\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> allPalSubseq; \\n\\n    bool isPal(string str){\\n        int i = 0 , j = str.size()-1; \\n        while(i<=j){\\n            if(str[i] != str[j]){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    void generateAllPalindromicSeq(string s){\\n        int sz = s.size();\\n        int allseqcnt = (1 << sz) - 1;\\n\\n        for(int i = 1 ; i <= allseqcnt ; ++i){\\n            string str = \"\";\\n            for(int j = 0 ; j < sz ; ++j){\\n                if((i & (1 << j)))\\n                    str.push_back(s[j]);\\n            }\\n            if(isPal(str)){\\n                allPalSubseq[i] = str.size();\\n            }\\n        }\\n    }\\n\\n    int maxProduct(string s) {\\n\\n        int result = -1;\\n        generateAllPalindromicSeq(s);\\n\\n        for(auto each : allPalSubseq){\\n            for(auto each1: allPalSubseq){\\n                if( (each.first & each1.first) == 0){\\n                    int prod = each.second * each1.second;\\n                    result = max(result, prod);\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818352,
                "title": "backtracking-bitmask-62ms-beats-85-in-time",
                "content": "# Code\\n```\\nclass Solution {\\n  private boolean isPalindrome(String s) {\\n    int i = 0, j = s.length() - 1;\\n    while (i <= j && s.charAt(i) == s.charAt(j)) {\\n      i++;\\n      j--;\\n    }\\n\\n    return j < i;\\n  }\\n\\n  private void generatePalSubseq(\\n    String s, String subseq, int curIndex, int mask, Map < Integer, List < Integer >> maskCache\\n  ) {\\n    if (curIndex == s.length()) {\\n      return;\\n    }\\n\\n    String currS = subseq + s.substring(curIndex, curIndex + 1);\\n    Integer currM = mask | (1 << curIndex);\\n    List < Integer > ml = null;\\n\\n    if (currS.length() == 1) {\\n      if (maskCache.containsKey(1)) {\\n        maskCache.get(1).add(currM);\\n      } else {\\n        ml = new ArrayList < > ();\\n        ml.add(currM);\\n        maskCache.put(1, ml);\\n      }\\n    }\\n\\n    if (currS.length() > 1 &&\\n      currS.charAt(0) == currS.charAt(currS.length() - 1) &&\\n      this.isPalindrome(currS)\\n    ) {\\n      ml = maskCache.get(currS.length());\\n      if (ml != null) {\\n        ml.add(currM);\\n      } else {\\n        ml = new ArrayList < Integer > ();\\n        ml.add(currM);\\n        maskCache.put(currS.length(), ml);\\n      }\\n    }\\n\\n    // include current Index\\n    this.generatePalSubseq(\\n      s,\\n      currS,\\n      curIndex + 1,\\n      currM,\\n      maskCache\\n    );\\n\\n    // exclude current Index\\n    this.generatePalSubseq(s, subseq, curIndex + 1, mask, maskCache);\\n  }\\n\\n  public int maxProduct(String s) {\\n    if (s.length() == 2) {\\n      return 1;\\n    }\\n\\n    Map < Integer, List < Integer >> palMasks = new HashMap < > ();\\n    this.generatePalSubseq(s, \"\", 0, 0, palMasks);\\n    int maxP = 1;\\n\\n    for (int i = s.length() - 1; i >= 1; i--) {\\n      if (palMasks.containsKey(i)) {\\n        int lim = maxP / i;\\n        if (lim > i) {\\n          continue;\\n        }\\n\\n        List < Integer > cndList = null;\\n        List < Integer > maskleni = palMasks.get(i);\\n        for (Integer l: maskleni) {\\n          int m = i;\\n          while (m <= i && m >= lim) {\\n            if (palMasks.containsKey(m)) {\\n              cndList = palMasks.get(m);\\n              for (Integer c: cndList) {\\n                if (c != l && (c & l) == 0) {\\n                  maxP = Math.max(maxP, i * m);\\n                  break;\\n                }\\n              }\\n            }\\n            m--;\\n          }\\n        }\\n      }\\n    }\\n\\n    return maxP;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n  private boolean isPalindrome(String s) {\\n    int i = 0, j = s.length() - 1;\\n    while (i <= j && s.charAt(i) == s.charAt(j)) {\\n      i++;\\n      j--;\\n    }\\n\\n    return j < i;\\n  }\\n\\n  private void generatePalSubseq(\\n    String s, String subseq, int curIndex, int mask, Map < Integer, List < Integer >> maskCache\\n  ) {\\n    if (curIndex == s.length()) {\\n      return;\\n    }\\n\\n    String currS = subseq + s.substring(curIndex, curIndex + 1);\\n    Integer currM = mask | (1 << curIndex);\\n    List < Integer > ml = null;\\n\\n    if (currS.length() == 1) {\\n      if (maskCache.containsKey(1)) {\\n        maskCache.get(1).add(currM);\\n      } else {\\n        ml = new ArrayList < > ();\\n        ml.add(currM);\\n        maskCache.put(1, ml);\\n      }\\n    }\\n\\n    if (currS.length() > 1 &&\\n      currS.charAt(0) == currS.charAt(currS.length() - 1) &&\\n      this.isPalindrome(currS)\\n    ) {\\n      ml = maskCache.get(currS.length());\\n      if (ml != null) {\\n        ml.add(currM);\\n      } else {\\n        ml = new ArrayList < Integer > ();\\n        ml.add(currM);\\n        maskCache.put(currS.length(), ml);\\n      }\\n    }\\n\\n    // include current Index\\n    this.generatePalSubseq(\\n      s,\\n      currS,\\n      curIndex + 1,\\n      currM,\\n      maskCache\\n    );\\n\\n    // exclude current Index\\n    this.generatePalSubseq(s, subseq, curIndex + 1, mask, maskCache);\\n  }\\n\\n  public int maxProduct(String s) {\\n    if (s.length() == 2) {\\n      return 1;\\n    }\\n\\n    Map < Integer, List < Integer >> palMasks = new HashMap < > ();\\n    this.generatePalSubseq(s, \"\", 0, 0, palMasks);\\n    int maxP = 1;\\n\\n    for (int i = s.length() - 1; i >= 1; i--) {\\n      if (palMasks.containsKey(i)) {\\n        int lim = maxP / i;\\n        if (lim > i) {\\n          continue;\\n        }\\n\\n        List < Integer > cndList = null;\\n        List < Integer > maskleni = palMasks.get(i);\\n        for (Integer l: maskleni) {\\n          int m = i;\\n          while (m <= i && m >= lim) {\\n            if (palMasks.containsKey(m)) {\\n              cndList = palMasks.get(m);\\n              for (Integer c: cndList) {\\n                if (c != l && (c & l) == 0) {\\n                  maxP = Math.max(maxP, i * m);\\n                  break;\\n                }\\n              }\\n            }\\n            m--;\\n          }\\n        }\\n      }\\n    }\\n\\n    return maxP;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759087,
                "title": "easy-detailed-sol-c-backtracking",
                "content": "# Intuition\\nas the constraints are too small we can look for generating all possible subsequences and then check whether they are distinct or not and calculate the answer \\n\\n# Approach\\nso what i did was to first i made all subsequences using bitmask and then i pushed the bitmask of the string which is a palindrome in a vector v after that i iterated over v vector and checked every pair which are distinct and updated the ans\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the given code is O(2^N * N^2), where N is the length of the input string \\'s\\'.\\n\\n- Space complexity:\\nThe space complexity of the given code is O(2^N * N), where N is the length of the input string \\'s\\'.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(string &s){\\n        if(s.size()==0){\\n            return false;\\n        }\\n        int i=0;\\n        int n=s.size();\\n        int j=n-1;\\n        while(i<j){\\n            if(s[i]!=s[j]){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    int maxProduct(string s) {\\n        int n=s.size();\\n        int tot=(1<<n)-1;\\n        vector<int> v;\\n        for(int bitmask=0; bitmask<=tot; bitmask++){\\n            string temp=\"\";\\n           for(int j=0;j<n; j++){\\n               if(bitmask & (1<<j)){\\n                   temp+=s[j];\\n               }\\n           }\\n           if(check(temp)){\\n               v.push_back(bitmask);\\n           }\\n        }\\n        int ans=0;\\n        for(int i=0; i<v.size(); i++){\\n            for(int j=i+1; j<v.size(); j++){\\n                if((v[i] & v[j])==0){\\n                    int a=__builtin_popcount(v[i]);\\n                    int b=__builtin_popcount(v[j]);\\n                    ans=max(ans,a*b);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string &s){\\n        if(s.size()==0){\\n            return false;\\n        }\\n        int i=0;\\n        int n=s.size();\\n        int j=n-1;\\n        while(i<j){\\n            if(s[i]!=s[j]){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    int maxProduct(string s) {\\n        int n=s.size();\\n        int tot=(1<<n)-1;\\n        vector<int> v;\\n        for(int bitmask=0; bitmask<=tot; bitmask++){\\n            string temp=\"\";\\n           for(int j=0;j<n; j++){\\n               if(bitmask & (1<<j)){\\n                   temp+=s[j];\\n               }\\n           }\\n           if(check(temp)){\\n               v.push_back(bitmask);\\n           }\\n        }\\n        int ans=0;\\n        for(int i=0; i<v.size(); i++){\\n            for(int j=i+1; j<v.size(); j++){\\n                if((v[i] & v[j])==0){\\n                    int a=__builtin_popcount(v[i]);\\n                    int b=__builtin_popcount(v[j]);\\n                    ans=max(ans,a*b);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749100,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(string s) {\\n        // vector<int>ans;\\n        int n=s.size();\\n        vector<pair<int,int>>vec;\\n        for(int i=0;i<(1<<n);i++){\\n            string sub=\"\";\\n            for(int j=0;j<n;j++){\\n                if(i&(1<<j)){\\n                    sub+=s[j];\\n                }\\n            }\\n            string sub2=sub;\\n            reverse(sub2.begin(),sub2.end());\\n            if(sub==sub2){\\n               vec.push_back({i,sub.size()});\\n                }\\n\\n        }\\n        int ans=0;\\n        for(int i=0;i<vec.size();i++){\\n            for(int j=i+1;j<vec.size();j++){\\n                if((vec[i].first & vec[j].first)==0){\\n                    ans=max(ans,vec[i].second*vec[j].second);\\n                }\\n            }\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(string s) {\\n        // vector<int>ans;\\n        int n=s.size();\\n        vector<pair<int,int>>vec;\\n        for(int i=0;i<(1<<n);i++){\\n            string sub=\"\";\\n            for(int j=0;j<n;j++){\\n                if(i&(1<<j)){\\n                    sub+=s[j];\\n                }\\n            }\\n            string sub2=sub;\\n            reverse(sub2.begin(),sub2.end());\\n            if(sub==sub2){\\n               vec.push_back({i,sub.size()});\\n                }\\n\\n        }\\n        int ans=0;\\n        for(int i=0;i<vec.size();i++){\\n            for(int j=i+1;j<vec.size();j++){\\n                if((vec[i].first & vec[j].first)==0){\\n                    ans=max(ans,vec[i].second*vec[j].second);\\n                }\\n            }\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714682,
                "title": "python-backtrack",
                "content": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        N = len(s)\\n        ans = 0\\n\\n        @cache\\n        def backTrack(index, cur1, cur2):\\n            nonlocal N, ans\\n\\n            if index == N:\\n                if cur1 == cur1[::-1] and cur2 == cur2[::-1]:\\n                    return len(cur1) * len(cur2)\\n                    \\n                else:\\n                    return 0\\n\\n            best = backTrack(index + 1, cur1, cur2)\\n\\n            best = max(best, backTrack(index + 1, cur1 + s[index], cur2))\\n\\n\\n            best = max(best, backTrack(index + 1, cur1, cur2 + s[index]))\\n\\n\\n            return best\\n\\n\\n\\n\\n\\n        return backTrack(0, \"\", \"\")\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        N = len(s)\\n        ans = 0\\n\\n        @cache\\n        def backTrack(index, cur1, cur2):\\n            nonlocal N, ans\\n\\n            if index == N:\\n                if cur1 == cur1[::-1] and cur2 == cur2[::-1]:\\n                    return len(cur1) * len(cur2)\\n                    \\n                else:\\n                    return 0\\n\\n            best = backTrack(index + 1, cur1, cur2)\\n\\n            best = max(best, backTrack(index + 1, cur1 + s[index], cur2))\\n\\n\\n            best = max(best, backTrack(index + 1, cur1, cur2 + s[index]))\\n\\n\\n            return best\\n\\n\\n\\n\\n\\n        return backTrack(0, \"\", \"\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699662,
                "title": "best-c-solution-using-bit-masking-fully-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find all possible palindromic subsequences and choose a pair of subsequence such that none of their indices match.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe generate all possible subsequences using bit-mask. If the string is of length `n` then total number of subsequences will be `2^n`. We store only those subsequences in the hash-map which are palindromes, with their `bit-mask as key` and `length as values`.\\n\\nThen we iterate through every pair of palindromic subsequence and find their product if the `AND` of their bitmask is 0.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(4^n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2^n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool palindrome(string s)\\n    {\\n        int i=0, j=s.size()-1;\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    int maxProduct(string s) {\\n        int N=s.size();\\n        map<int, int> pals;\\n\\n        for(int mask=1; mask < (1<<N); mask++)\\n        {\\n            string subseq=\"\";\\n            for(int i=0;i<N;i++)\\n            {\\n                if(mask & (1<<i))\\n                    subseq += s[i];\\n            }\\n            if(palindrome(subseq))\\n                pals[mask] = subseq.length();\\n        }\\n\\n        int ans=INT_MIN;\\n        for(auto k:pals)\\n        {\\n            for(auto j:pals)\\n            {\\n                if((k.first&j.first)==0)\\n                    ans = max(ans, k.second*j.second);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool palindrome(string s)\\n    {\\n        int i=0, j=s.size()-1;\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    int maxProduct(string s) {\\n        int N=s.size();\\n        map<int, int> pals;\\n\\n        for(int mask=1; mask < (1<<N); mask++)\\n        {\\n            string subseq=\"\";\\n            for(int i=0;i<N;i++)\\n            {\\n                if(mask & (1<<i))\\n                    subseq += s[i];\\n            }\\n            if(palindrome(subseq))\\n                pals[mask] = subseq.length();\\n        }\\n\\n        int ans=INT_MIN;\\n        for(auto k:pals)\\n        {\\n            for(auto j:pals)\\n            {\\n                if((k.first&j.first)==0)\\n                    ans = max(ans, k.second*j.second);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657074,
                "title": "can-anyone-tell-me-why-this-code-is-getting-accepted",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(string s){\\n        int i = 0, j = s.size()-1;\\n        while(i<j){\\n            if(s[i++]!=s[j--])  return false;\\n        }\\n        return true;\\n    }\\n    int maxProduct(string s) {\\n        int n = s.size();\\n        vector<pair<int,int>> vp;\\n        for(int i=0; i<(1<<n); i++){\\n            string temp;\\n            int mask = i;\\n            for(int j=0;j<n;j++){\\n                if(mask & (1<<j))   temp += s[j]; \\n            }\\n            reverse(temp.begin(),temp.end());\\n            if(check(temp)){\\n                vp.push_back({mask,temp.size()});\\n            }\\n        }\\n\\n        int ans = 1;\\n        for(int i=0;i<vp.size();i++){\\n            for(int j=i+1;j<vp.size();j++){\\n                if((vp[i].first & vp[j].first) == 0){\\n                    ans = max(ans,vp[i].second * vp[j].second);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string s){\\n        int i = 0, j = s.size()-1;\\n        while(i<j){\\n            if(s[i++]!=s[j--])  return false;\\n        }\\n        return true;\\n    }\\n    int maxProduct(string s) {\\n        int n = s.size();\\n        vector<pair<int,int>> vp;\\n        for(int i=0; i<(1<<n); i++){\\n            string temp;\\n            int mask = i;\\n            for(int j=0;j<n;j++){\\n                if(mask & (1<<j))   temp += s[j]; \\n            }\\n            reverse(temp.begin(),temp.end());\\n            if(check(temp)){\\n                vp.push_back({mask,temp.size()});\\n            }\\n        }\\n\\n        int ans = 1;\\n        for(int i=0;i<vp.size();i++){\\n            for(int j=i+1;j<vp.size();j++){\\n                if((vp[i].first & vp[j].first) == 0){\\n                    ans = max(ans,vp[i].second * vp[j].second);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651162,
                "title": "maximum-product-of-palindromic-substrings",
                "content": "# Intuition\\nWe recursively explore all possible combinations of splitting the input string \\'s\\' into two substrings. We start with empty strings as the initial substrings and iterate through each character in \\'s\\'. At each position, we have three options: add the character to the first substring, add it to the second substring, or don\\'t add it to either substring. We update the maximum product of lengths if both substrings formed are palindromes. We continue this exploration until we reach the end of the input string. Finally, we return the maximum product of lengths obtained.\\n# Approach\\nStep-by-step approach:\\n\\n1. Start with the main function maxProduct that takes the input string s as a parameter.\\n\\n2. Convert the string s into a character array using the toCharArray method.\\n\\n3. Call the helper function dfs with initial values: empty strings for str1 and str2, position 0, and maximum 0.\\n\\n4. In the dfs function:\\n    * Check if the position is at the end of the character array charArray.\\n    * If so, check if both str1 and str2 are valid palindromes using the isValid function.\\n    * If both strings are valid, update the maximum by calculating the product of their lengths and taking the maximum value.\\n    * Return the updated maximum.\\n    * If the position is not at the end, continue the exploration:\\n        - Call dfs recursively with str1 appended with charArray[position], keeping str2 unchanged.\\n        - Call dfs recursively with str2 appended with charArray[position], keeping str1 unchanged.\\n        - Call dfs recursively with both str1 and str2 unchanged.\\n        - Take the maximum value among the three recursive calls and return it.\\n\\n5. Implement the isValid function:\\n    * Initialize i to 0 and j to the length of the string str minus 1.\\n    * Use a while loop to iterate while i is less than j.\\n    * Inside the loop, check if the characters at indices i and j are not equal. If so, return false.\\n    * After the loop, return true.\\n\\n6. Return the final maximum value obtained from the dfs function in the maxProduct function.\\n# Complexity\\n- Time complexity: O(2^N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n  public int maxProduct(String s) {\\n    return dfs(s.toCharArray(), \"\", \"\", 0, 0); // call dfs with initial values\\n  }\\n\\n  public int dfs( // dfs function\\n    char[] charArray,\\n    String str1,\\n    String str2,\\n    int position,\\n    int maximum\\n  ) {\\n    if (position == charArray.length) { // if position is at the end of charArray\\n      if (isValid(str1) && isValid(str2)) { // if both strings are valid\\n        maximum = Math.max(maximum, str1.length() * str2.length()); // update maximum\\n      }\\n      return maximum; // return maximum\\n    }\\n    return Math.max(\\n      dfs(charArray, str1 + charArray[position], str2, position + 1, maximum), // call dfs with str1 + charArray[position]\\n      Math.max(\\n        dfs(charArray, str1, str2 + charArray[position], position + 1, maximum), // call dfs with str2 + charArray[position]\\n        dfs(charArray, str1, str2, position + 1, maximum) // call dfs with charArray[position] not added to either string\\n      )\\n    );\\n  }\\n\\n  public boolean isValid(String str) {\\n    int i = 0; // initialize i to 0\\n    int j = str.length() - 1; // initialize j to str.length() - 1\\n    while (i < j) { // loop through str\\n      if (str.charAt(i++) != str.charAt(j--)) { // if characters at i and j are not equal\\n        return false; // return false\\n      }\\n    }\\n    return true; // return true\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  public int maxProduct(String s) {\\n    return dfs(s.toCharArray(), \"\", \"\", 0, 0); // call dfs with initial values\\n  }\\n\\n  public int dfs( // dfs function\\n    char[] charArray,\\n    String str1,\\n    String str2,\\n    int position,\\n    int maximum\\n  ) {\\n    if (position == charArray.length) { // if position is at the end of charArray\\n      if (isValid(str1) && isValid(str2)) { // if both strings are valid\\n        maximum = Math.max(maximum, str1.length() * str2.length()); // update maximum\\n      }\\n      return maximum; // return maximum\\n    }\\n    return Math.max(\\n      dfs(charArray, str1 + charArray[position], str2, position + 1, maximum), // call dfs with str1 + charArray[position]\\n      Math.max(\\n        dfs(charArray, str1, str2 + charArray[position], position + 1, maximum), // call dfs with str2 + charArray[position]\\n        dfs(charArray, str1, str2, position + 1, maximum) // call dfs with charArray[position] not added to either string\\n      )\\n    );\\n  }\\n\\n  public boolean isValid(String str) {\\n    int i = 0; // initialize i to 0\\n    int j = str.length() - 1; // initialize j to str.length() - 1\\n    while (i < j) { // loop through str\\n      if (str.charAt(i++) != str.charAt(j--)) { // if characters at i and j are not equal\\n        return false; // return false\\n      }\\n    }\\n    return true; // return true\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600005,
                "title": "c-bitmask",
                "content": "# Intuition\\nCheck all the subsequences to find all the polyndromes. For each pair of palindromes check if they do not overlap and then update the result accordingly.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxProduct(string s) \\n    {\\n        var n = s.Length;\\n        var palindromes = new Dictionary<int, int>();\\n\\n        for(int i = 1; i <= (1 << n); ++i)\\n        {\\n            var sb = new StringBuilder();\\n            var count = 0;\\n            for(int j = 0; j < n; ++j)\\n            {\\n                if((i & (1 << j)) != 0)\\n                {\\n                    sb.Append(s[j]);\\n                    ++count;\\n                }\\n            }\\n\\n            if(IsPalindrome(sb))\\n            {\\n                palindromes.Add(i, count);\\n            }\\n        }\\n\\n        var result = 0;\\n        foreach(var (first, firstCount) in palindromes)\\n        {\\n            foreach(var (second, secondCount) in palindromes)\\n            {\\n                if((first & second) == 0)\\n                {\\n                    result = Math.Max(result, firstCount * secondCount);\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    public bool IsPalindrome(StringBuilder sb)\\n    {\\n        var m = sb.Length;\\n        for(int j = 0; 2*j < m; ++j)\\n        {\\n            if(sb[j] != sb[m - j - 1])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxProduct(string s) \\n    {\\n        var n = s.Length;\\n        var palindromes = new Dictionary<int, int>();\\n\\n        for(int i = 1; i <= (1 << n); ++i)\\n        {\\n            var sb = new StringBuilder();\\n            var count = 0;\\n            for(int j = 0; j < n; ++j)\\n            {\\n                if((i & (1 << j)) != 0)\\n                {\\n                    sb.Append(s[j]);\\n                    ++count;\\n                }\\n            }\\n\\n            if(IsPalindrome(sb))\\n            {\\n                palindromes.Add(i, count);\\n            }\\n        }\\n\\n        var result = 0;\\n        foreach(var (first, firstCount) in palindromes)\\n        {\\n            foreach(var (second, secondCount) in palindromes)\\n            {\\n                if((first & second) == 0)\\n                {\\n                    result = Math.Max(result, firstCount * secondCount);\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    public bool IsPalindrome(StringBuilder sb)\\n    {\\n        var m = sb.Length;\\n        for(int j = 0; 2*j < m; ++j)\\n        {\\n            if(sb[j] != sb[m - j - 1])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594297,
                "title": "python-bitmask-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O((2**n)*2n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(2**n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        # number of subsequences 2**n\\n        # from bitmask --> subsequence\\n        # logic & --> disjoint palindrome subsequnces \\n\\n        n = len(s)\\n        maskToLength = {} # bitmask : length\\n        maxProduct = 0\\n        \\n        def getSubsequence(mask):\\n            subseq = \"\"\\n            for i in range(n):\\n                if mask & (1 << i):\\n                    subseq += s[n-1-i]\\n            return subseq\\n        \\n        def isPalindrome(s):\\n            return s == s[::-1]\\n\\n        for mask in range(1, 1 << n):\\n            subseq = getSubsequence(mask)\\n            if isPalindrome(subseq):\\n                maskToLength[mask] = len(subseq)\\n        \\n        for mask1, length1 in maskToLength.items():\\n            for mask2, length2 in maskToLength.items():\\n                if mask1 & mask2 == 0:\\n                    maxProduct = max(maxProduct, length1*length2)\\n        return maxProduct\\n        \\n        \\n\\n\\n        \\n\\n            \\n                \\n\\n\\n        \\n        \\n            \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        # number of subsequences 2**n\\n        # from bitmask --> subsequence\\n        # logic & --> disjoint palindrome subsequnces \\n\\n        n = len(s)\\n        maskToLength = {} # bitmask : length\\n        maxProduct = 0\\n        \\n        def getSubsequence(mask):\\n            subseq = \"\"\\n            for i in range(n):\\n                if mask & (1 << i):\\n                    subseq += s[n-1-i]\\n            return subseq\\n        \\n        def isPalindrome(s):\\n            return s == s[::-1]\\n\\n        for mask in range(1, 1 << n):\\n            subseq = getSubsequence(mask)\\n            if isPalindrome(subseq):\\n                maskToLength[mask] = len(subseq)\\n        \\n        for mask1, length1 in maskToLength.items():\\n            for mask2, length2 in maskToLength.items():\\n                if mask1 & mask2 == 0:\\n                    maxProduct = max(maxProduct, length1*length2)\\n        return maxProduct\\n        \\n        \\n\\n\\n        \\n\\n            \\n                \\n\\n\\n        \\n        \\n            \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576279,
                "title": "python-simple-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProduct(self, s):\\n        n = len(s)\\n\\n        @lru_cache(None)\\n        def backtrack(idx,path1,path2):\\n            if idx == n:\\n                if path1 == path1[::-1] and path2 == path2[::-1]:\\n                    res.append(len(path1)*len(path2))\\n\\n            for i in range(idx,n):\\n                backtrack(i+1,path1+s[i],path2)\\n                backtrack(i+1,path1,path2+s[i])\\n                backtrack(i+1,path1,path2)\\n\\n        res = []\\n        backtrack(0,\"\",\"\")\\n        return max(res)\\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s):\\n        n = len(s)\\n\\n        @lru_cache(None)\\n        def backtrack(idx,path1,path2):\\n            if idx == n:\\n                if path1 == path1[::-1] and path2 == path2[::-1]:\\n                    res.append(len(path1)*len(path2))\\n\\n            for i in range(idx,n):\\n                backtrack(i+1,path1+s[i],path2)\\n                backtrack(i+1,path1,path2+s[i])\\n                backtrack(i+1,path1,path2)\\n\\n        res = []\\n        backtrack(0,\"\",\"\")\\n        return max(res)\\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576254,
                "title": "bit-array-bit-masking-dictionary-c-brute-force",
                "content": "\\n```\\npublic class Solution {\\n    public int MaxProduct(string s) \\n    {\\n        int N = s.Length;\\n        char[] arr = s.ToCharArray();\\n        Dictionary<int, int> dic = new ();    // palindrome, count\\n\\n        for (int i = 1; i < Math.Pow(2, N) - 1; i++)\\n        {\\n            byte[] bytes = BitConverter.GetBytes(i);\\n            BitArray bitArray = new BitArray(bytes);\\n\\n            string localString = string.Empty;\\n\\n            for (int k = 0; k < N; k++)\\n            {\\n                if (bitArray.Get(k) == true)\\n                {\\n                    localString += arr[k];\\n                }\\n            }\\n\\n            if (localString == string.Empty)\\n            {\\n                continue;\\n            }\\n\\n            char[] charArray = localString.ToCharArray();\\n            Array.Reverse(charArray);\\n            string reverse = new (charArray);\\n\\n            if (localString == reverse)\\n            {\\n                dic.TryAdd(i, 0);\\n                dic[i] = localString.Length;\\n            }\\n        }\\n\\n        int result = 0;\\n\\n        foreach (int key1 in dic.Keys)\\n        {\\n            foreach (int key2 in dic.Keys)\\n            {\\n                if ((key1 & key2) == 0)\\n                {\\n                    result = Math.Max(dic[key1] * dic[key2], result);\\n                }\\n            }\\n        }\\n\\n        return result; \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxProduct(string s) \\n    {\\n        int N = s.Length;\\n        char[] arr = s.ToCharArray();\\n        Dictionary<int, int> dic = new ();    // palindrome, count\\n\\n        for (int i = 1; i < Math.Pow(2, N) - 1; i++)\\n        {\\n            byte[] bytes = BitConverter.GetBytes(i);\\n            BitArray bitArray = new BitArray(bytes);\\n\\n            string localString = string.Empty;\\n\\n            for (int k = 0; k < N; k++)\\n            {\\n                if (bitArray.Get(k) == true)\\n                {\\n                    localString += arr[k];\\n                }\\n            }\\n\\n            if (localString == string.Empty)\\n            {\\n                continue;\\n            }\\n\\n            char[] charArray = localString.ToCharArray();\\n            Array.Reverse(charArray);\\n            string reverse = new (charArray);\\n\\n            if (localString == reverse)\\n            {\\n                dic.TryAdd(i, 0);\\n                dic[i] = localString.Length;\\n            }\\n        }\\n\\n        int result = 0;\\n\\n        foreach (int key1 in dic.Keys)\\n        {\\n            foreach (int key2 in dic.Keys)\\n            {\\n                if ((key1 & key2) == 0)\\n                {\\n                    result = Math.Max(dic[key1] * dic[key2], result);\\n                }\\n            }\\n        }\\n\\n        return result; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565666,
                "title": "c-solution-with-explanation-in-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(string s) {\\n        // We considering subsequences as bitwise masks, so since 0 length\\n        // subsequence will never be palindrome, we start from 1 & go till \\n        // 2^N -1(which will denote all elements to be included- all 1s)\\n        // to check what substring corresponds to a bitmask, we try to \\n        // AND the bitmask, with masks having one at each index of string.\\n        // corresponding to 1 << i, so at all places we have char in bitmask,\\n        // the ANd will be 1, and we can deduce the current subsequence,\\n        // check whether it\\'s a palindrome- compare it with reverse\\n        // if yes, add in a map, bitmask vs length,\\n        // so for pairs of bitmask in this map whose AND is 1, \\n        // we can multiply the lengths & track the max \\n\\n        unordered_map<int, int> mp;\\n        int n = s.length();\\n        for(int mask = 1; mask < (1 << n); mask++){\\n            string subSeq = \"\";\\n            for(int i = 0; i < n; i++){\\n                if(mask & (1<< i)){\\n                    subSeq += s[i];\\n                }\\n            }\\n            string revSub = subSeq;\\n            reverse(revSub.begin(), revSub.end());\\n            if(subSeq == revSub){\\n                mp[mask] = subSeq.length();\\n            }\\n        }\\n        int maxProd = 1;\\n        \\n        cout << endl;\\n        for(auto it: mp){\\n            for(auto it2: mp){\\n                if((it.first & it2.first) == 0){\\n                    maxProd = max(maxProd, it.second*it2.second);\\n                }\\n            }\\n        }\\n\\n        return maxProd;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(string s) {\\n        // We considering subsequences as bitwise masks, so since 0 length\\n        // subsequence will never be palindrome, we start from 1 & go till \\n        // 2^N -1(which will denote all elements to be included- all 1s)\\n        // to check what substring corresponds to a bitmask, we try to \\n        // AND the bitmask, with masks having one at each index of string.\\n        // corresponding to 1 << i, so at all places we have char in bitmask,\\n        // the ANd will be 1, and we can deduce the current subsequence,\\n        // check whether it\\'s a palindrome- compare it with reverse\\n        // if yes, add in a map, bitmask vs length,\\n        // so for pairs of bitmask in this map whose AND is 1, \\n        // we can multiply the lengths & track the max \\n\\n        unordered_map<int, int> mp;\\n        int n = s.length();\\n        for(int mask = 1; mask < (1 << n); mask++){\\n            string subSeq = \"\";\\n            for(int i = 0; i < n; i++){\\n                if(mask & (1<< i)){\\n                    subSeq += s[i];\\n                }\\n            }\\n            string revSub = subSeq;\\n            reverse(revSub.begin(), revSub.end());\\n            if(subSeq == revSub){\\n                mp[mask] = subSeq.length();\\n            }\\n        }\\n        int maxProd = 1;\\n        \\n        cout << endl;\\n        for(auto it: mp){\\n            for(auto it2: mp){\\n                if((it.first & it2.first) == 0){\\n                    maxProd = max(maxProd, it.second*it2.second);\\n                }\\n            }\\n        }\\n\\n        return maxProd;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3549577,
                "title": "for-beginners-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind all the subsequences which are plaindrome in the given string in the form of bits and after all apply and operation(so that they are distinct) and find the maximum product of 2 substrings \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2^n)\\n# Code\\n```\\nclass Solution {\\n    public int maxProduct(String s) {\\n        char[] strArr = s.toCharArray();\\n        int n = strArr.length;\\n        Map<Integer, Integer> pali = new HashMap<>();\\n        // save all elligible combination into hashmap\\n        for (int mask = 0; mask < 1<<n; mask++){\\n            String subseq = \"\";\\n            for (int i = 0; i < 12; i++){\\n                if ((mask & 1<<i) > 0)\\n                    subseq += strArr[i];\\n            }\\n            if (isPalindromic(subseq))\\n                pali.put(mask, subseq.length());\\n        }\\n        // use & opertion between any two combination\\n        int res = 0;\\n        for (int mask1 : pali.keySet()){\\n            for (int mask2 : pali.keySet()){\\n                if ((mask1 & mask2) == 0)\\n                    res = Math.max(res, pali.get(mask1)*pali.get(mask2));\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    public boolean isPalindromic(String str){\\n        int j = str.length() - 1;\\n        char[] strArr = str.toCharArray();\\n        for (int i = 0; i < j; i ++){\\n            if (strArr[i] != strArr[j])\\n                return false;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(String s) {\\n        char[] strArr = s.toCharArray();\\n        int n = strArr.length;\\n        Map<Integer, Integer> pali = new HashMap<>();\\n        // save all elligible combination into hashmap\\n        for (int mask = 0; mask < 1<<n; mask++){\\n            String subseq = \"\";\\n            for (int i = 0; i < 12; i++){\\n                if ((mask & 1<<i) > 0)\\n                    subseq += strArr[i];\\n            }\\n            if (isPalindromic(subseq))\\n                pali.put(mask, subseq.length());\\n        }\\n        // use & opertion between any two combination\\n        int res = 0;\\n        for (int mask1 : pali.keySet()){\\n            for (int mask2 : pali.keySet()){\\n                if ((mask1 & mask2) == 0)\\n                    res = Math.max(res, pali.get(mask1)*pali.get(mask2));\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    public boolean isPalindromic(String str){\\n        int j = str.length() - 1;\\n        char[] strArr = str.toCharArray();\\n        for (int i = 0; i < j; i ++){\\n            if (strArr[i] != strArr[j])\\n                return false;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530922,
                "title": "kotlin-bitmask-with-explanation",
                "content": "# Approach\\nSince we know that `2 <= s.length <= 12` we can use a bitmask to represent which characters from s we can/cannot use to build a string.\\n\\nTraverse all possible `bitmasks` from `1` until $$2^n$$, for each `bitmask`, build a `string subsequence`. The bitmask will help us to exclude characters.\\n\\nFor each `string subsequence`, if its reverse is equal to it, it means that we have a palindrome and we can add it to a hashmap where we ***map bitmask to palindrom length***.\\n\\nThen, we check all palindromes in our hashmap, if two palindromes are ***disjoint palindromic subsequences***, then we can try to update our `max` result with the product of their length.\\n\\n\\n- ***Time complexity:*** $O(2^n * len(s))$\\n\\n- ***Space complexity:*** $O(2^n)$\\n\\n# Code\\n```\\nclass Solution {\\n    fun maxProduct(s: String): Int {\\n        val hm = HashMap<Int, Int>()\\n\\n        for (mask in 1 until (1 shl s.length)) {\\n            val sb = StringBuilder()\\n\\n            for (i in 0 until s.length) {\\n                if (mask and (1 shl i) > 0) {\\n                    sb.append(s[i])\\n                } \\n            }\\n\\n            val p = sb.toString()\\n            if (p == p.reversed()) {\\n                hm.put(mask, p.length)\\n            }\\n        }\\n\\n        var max = 0\\n        for (mask1 in hm.keys) {\\n            for (mask2 in hm.keys) {\\n                if (mask1 and mask2 == 0) {\\n                    max = maxOf(\\n                        max,\\n                        hm[mask1]!! * hm[mask2]!!\\n                    )\\n                }\\n            }\\n        }\\n\\n        return max\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    fun maxProduct(s: String): Int {\\n        val hm = HashMap<Int, Int>()\\n\\n        for (mask in 1 until (1 shl s.length)) {\\n            val sb = StringBuilder()\\n\\n            for (i in 0 until s.length) {\\n                if (mask and (1 shl i) > 0) {\\n                    sb.append(s[i])\\n                } \\n            }\\n\\n            val p = sb.toString()\\n            if (p == p.reversed()) {\\n                hm.put(mask, p.length)\\n            }\\n        }\\n\\n        var max = 0\\n        for (mask1 in hm.keys) {\\n            for (mask2 in hm.keys) {\\n                if (mask1 and mask2 == 0) {\\n                    max = maxOf(\\n                        max,\\n                        hm[mask1]!! * hm[mask2]!!\\n                    )\\n                }\\n            }\\n        }\\n\\n        return max\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481699,
                "title": "python-dp-recursion-backtracking-tuple",
                "content": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        ans = 1\\n        \\n        dp = dict()\\n        def check(seq):\\n            if seq in dp:\\n                return dp[seq]\\n            lo, hi = 0, len(seq) - 1\\n            while lo < hi and seq[lo] == seq[hi]:\\n                lo += 1\\n                hi -= 1\\n            if hi <= lo: # if current seq is polindrom, than we can include polidroms excluding cahrs from  left and right\\n                lo, hi = 0, len(seq)\\n                while lo <= hi:\\n                    new_seq = seq[lo:hi]\\n                    if new_seq in dp:\\n                        break\\n                    dp[new_seq] = True\\n                    lo += 1\\n                    hi -= 1\\n                return True\\n            dp[seq] = False\\n            return dp[seq]\\n            \\n        def dfs(n, s1, s2):\\n            nonlocal ans\\n            if n == len(s):\\n                if check(tuple(s1)) and check(tuple(s2)):\\n                    ans = max(ans, len(s1) * len(s2))\\n            else:\\n                dfs(n + 1, s1, s2)\\n                s1.append(s[n])\\n                dfs(n + 1, s1, s2)\\n                s1.pop()\\n                s2.append(s[n])\\n                dfs(n + 1, s1, s2)\\n                s2.pop()\\n            return\\n        dfs(0, [], [])\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        ans = 1\\n        \\n        dp = dict()\\n        def check(seq):\\n            if seq in dp:\\n                return dp[seq]\\n            lo, hi = 0, len(seq) - 1\\n            while lo < hi and seq[lo] == seq[hi]:\\n                lo += 1\\n                hi -= 1\\n            if hi <= lo: # if current seq is polindrom, than we can include polidroms excluding cahrs from  left and right\\n                lo, hi = 0, len(seq)\\n                while lo <= hi:\\n                    new_seq = seq[lo:hi]\\n                    if new_seq in dp:\\n                        break\\n                    dp[new_seq] = True\\n                    lo += 1\\n                    hi -= 1\\n                return True\\n            dp[seq] = False\\n            return dp[seq]\\n            \\n        def dfs(n, s1, s2):\\n            nonlocal ans\\n            if n == len(s):\\n                if check(tuple(s1)) and check(tuple(s2)):\\n                    ans = max(ans, len(s1) * len(s2))\\n            else:\\n                dfs(n + 1, s1, s2)\\n                s1.append(s[n])\\n                dfs(n + 1, s1, s2)\\n                s1.pop()\\n                s2.append(s[n])\\n                dfs(n + 1, s1, s2)\\n                s2.pop()\\n            return\\n        dfs(0, [], [])\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477066,
                "title": "bitmask-with-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc maxProduct(s string) int {\\n\\tvar IsPelindrom func(s string, pKnowledge map[string]bool) bool\\n\\tIsPelindrom = func(s string, pKnowledge map[string]bool) bool {\\n\\t\\tif v, ok := pKnowledge[s]; ok {\\n\\t\\t\\treturn v\\n\\t\\t}\\n\\t\\ti, j := 0, len(s)-1\\n\\t\\tfor i < j {\\n\\t\\t\\tif s[i] != s[j] {\\n\\t\\t\\t\\tpKnowledge[s] = false\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t\\ti++\\n\\t\\t\\tj--\\n\\t\\t}\\n\\n\\t\\tpKnowledge[s] = true\\n\\t\\treturn true\\n\\t}\\n\\tvar SubsequencesGenerator func(idx int, s []byte, current []byte, knowledge map[int]string, bitmask []byte, pknowledge map[string]bool)\\n\\tSubsequencesGenerator = func(start int, s []byte, current []byte, knowledge map[int]string, bitmask []byte, pknowledge map[string]bool) {\\n\\t\\tif start > len(s) {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tif len(current) > 0 {\\n\\t\\t\\tdigit, _ := strconv.ParseInt(string(bitmask), 2, 32)\\n\\t\\t\\tif _, ok := knowledge[int(digit)]; !ok && IsPelindrom(string(current), pknowledge) {\\n\\t\\t\\t\\tknowledge[int(digit)] = string(current)\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tfor i := start; i < len(s); i++ {\\n\\t\\t\\tbitmask[i] = \\'1\\'\\n\\t\\t\\tcurrent := append(current, s[i])\\n\\t\\t\\tif i == start {\\n\\t\\t\\t\\tSubsequencesGenerator(i+1, s, current, knowledge, bitmask, pknowledge)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ts[i], s[start] = s[start], s[i]\\n\\t\\t\\t\\tSubsequencesGenerator(i+1, s, current, knowledge, bitmask, pknowledge)\\n\\t\\t\\t\\ts[i], s[start] = s[start], s[i]\\n\\t\\t\\t}\\n\\t\\t\\tbitmask[i] = \\'0\\'\\n\\t\\t\\tcurrent = current[:len(current)-1]\\n\\t\\t}\\n\\t}\\n\\n\\tknowledge := make(map[int]string)\\n\\tbitmask := make([]byte, len(s))\\n\\tfor idx, _ := range s {\\n\\t\\tbitmask[idx] = \\'0\\'\\n\\t}\\n\\tSubsequencesGenerator(0, []byte(s), []byte{}, knowledge, bitmask, map[string]bool{})\\n\\tproduct := 0\\n\\n\\tBitAnd := func(a, b int) bool {\\n\\t\\treturn a&b == 0\\n\\t}\\n\\tfor k, v := range knowledge {\\n\\t\\tfor k2, v2 := range knowledge {\\n\\t\\t\\tif !BitAnd(k, k2) {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif product < len(v2)*len(v) {\\n\\t\\t\\t\\tproduct = len(v2) * len(v)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\treturn product\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxProduct(s string) int {\\n\\tvar IsPelindrom func(s string, pKnowledge map[string]bool) bool\\n\\tIsPelindrom = func(s string, pKnowledge map[string]bool) bool {\\n\\t\\tif v, ok := pKnowledge[s]; ok {\\n\\t\\t\\treturn v\\n\\t\\t}\\n\\t\\ti, j := 0, len(s)-1\\n\\t\\tfor i < j {\\n\\t\\t\\tif s[i] != s[j] {\\n\\t\\t\\t\\tpKnowledge[s] = false\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t\\ti++\\n\\t\\t\\tj--\\n\\t\\t}\\n\\n\\t\\tpKnowledge[s] = true\\n\\t\\treturn true\\n\\t}\\n\\tvar SubsequencesGenerator func(idx int, s []byte, current []byte, knowledge map[int]string, bitmask []byte, pknowledge map[string]bool)\\n\\tSubsequencesGenerator = func(start int, s []byte, current []byte, knowledge map[int]string, bitmask []byte, pknowledge map[string]bool) {\\n\\t\\tif start > len(s) {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tif len(current) > 0 {\\n\\t\\t\\tdigit, _ := strconv.ParseInt(string(bitmask), 2, 32)\\n\\t\\t\\tif _, ok := knowledge[int(digit)]; !ok && IsPelindrom(string(current), pknowledge) {\\n\\t\\t\\t\\tknowledge[int(digit)] = string(current)\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tfor i := start; i < len(s); i++ {\\n\\t\\t\\tbitmask[i] = \\'1\\'\\n\\t\\t\\tcurrent := append(current, s[i])\\n\\t\\t\\tif i == start {\\n\\t\\t\\t\\tSubsequencesGenerator(i+1, s, current, knowledge, bitmask, pknowledge)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ts[i], s[start] = s[start], s[i]\\n\\t\\t\\t\\tSubsequencesGenerator(i+1, s, current, knowledge, bitmask, pknowledge)\\n\\t\\t\\t\\ts[i], s[start] = s[start], s[i]\\n\\t\\t\\t}\\n\\t\\t\\tbitmask[i] = \\'0\\'\\n\\t\\t\\tcurrent = current[:len(current)-1]\\n\\t\\t}\\n\\t}\\n\\n\\tknowledge := make(map[int]string)\\n\\tbitmask := make([]byte, len(s))\\n\\tfor idx, _ := range s {\\n\\t\\tbitmask[idx] = \\'0\\'\\n\\t}\\n\\tSubsequencesGenerator(0, []byte(s), []byte{}, knowledge, bitmask, map[string]bool{})\\n\\tproduct := 0\\n\\n\\tBitAnd := func(a, b int) bool {\\n\\t\\treturn a&b == 0\\n\\t}\\n\\tfor k, v := range knowledge {\\n\\t\\tfor k2, v2 := range knowledge {\\n\\t\\t\\tif !BitAnd(k, k2) {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif product < len(v2)*len(v) {\\n\\t\\t\\t\\tproduct = len(v2) * len(v)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\treturn product\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3427982,
                "title": "c-backtrack-bitmask-and-o-2-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere I have used simple backtrack to cover the first pal sub and then finding its second disjoint pal sub trying all possible comb \\nall sub are chcked for being pal or not since n->12 2^12->4096 almost 5000 sq-> 25000000 1e7 order thi will get accepted but a improvement can be done here using bitmask which turned TC from 400ms -> 70ms knowing the fact that if I have hecked for a string as the 1 dis pal sub then I dont need to chk for the same string in the second chance.\\nlets say a(first pal sub) and b(second pal sub)\\nnow I have to check for all possible sub in s and for all pal sub I have to chk all possible disjont pal sub as my b the max prouct of sizes of both is my ans\\nNow if I have chk for a possible pal sub as my a (say \"aba\") two cases if it is a pal then I must have chk all the pos dis sub for this so tis is also chked for all the sub seq conversely now I dont need to chk it as b for any other a it is something like if I have chked 3 no for its mul with 1->10 then I dont need to chk for any no in 1->10 with 3\\nnow if that a is not a pal sub then also I dont need to chk for it in my b  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dp[8000]={};\\nbool chk(string& s){\\n    int n=s.size();\\n    int i=0;\\n    int j=n-1;\\n    while(i<j && s[i]==s[j]) {\\n        i++;\\n        j--;\\n    }\\n    return i>=j;\\n}\\nint answer=1;\\nvoid f1(int x,int ind,string& str,string& s,int ind_mask,int mask){\\n    if(ind==s.size()) return;\\n    if(dp[ind_mask]) return;\\n    int inc=0;\\n    f1(x,ind+1,str,s,ind_mask,mask);\\n    if((mask & (1<<ind))==0){\\n        str+=s[ind];\\n        f1(x,ind+1,str,s,ind_mask | (1<<ind),mask);\\n        if(chk(str)){\\n            answer=max(answer,(int)(x*str.size()));\\n            dp[mask | ind_mask]=1;\\n        }\\n        str.pop_back();\\n    }\\n}\\nvoid f(int ind,string& str,string& s,int mask){\\n    if(ind==s.size()) return;\\n    str+=s[ind];\\n    f(ind+1,str,s,mask | (1<<ind));\\n    if(chk(str)){\\n        string ref=\"\";\\n        f1(str.size(),0,ref,s,0,mask | (1<<ind));\\n    }\\n    str.pop_back();\\n    f(ind+1,str,s,mask);\\n    dp[mask]=1;\\n    return ;\\n}\\n    int maxProduct(string s) {\\n        string str=\"\";\\n        f(0,str,s,0);\\n        return answer;\\n    }\\n};\\n```\\nO(2^n) solution \\nevaluate the pal sub in one go \\nand then deal with thos trings in O(n^2) where n-> no of pal strings in that string\\n```\\nCode block\\nclass Solution {\\npublic:\\nbool chk(string& s){\\n    int n=s.size();\\n    int i=0;\\n    int j=n-1;\\n    while(i<j && s[i]==s[j]) {\\n        i++;\\n        j--;\\n    }\\n    return i>=j;\\n}\\nvoid f(int ind,string& str,string& s,vector<int>& pal_strings,vector<int>& arr,int mask){\\n    if(ind==s.size()) return;\\n    str+=s[ind];\\n    if(chk(str)){\\n        pal_strings.push_back(mask  | (1<<ind));\\n        arr.push_back(str.size());\\n    }\\n    f(ind+1,str,s,pal_strings,arr,mask | (1<<ind));\\n    str.pop_back();\\n    f(ind+1,str,s,pal_strings,arr,mask);\\n}\\n    int maxProduct(string s) {\\n        int answer=1;\\n        vector<int> pal_strings;\\n        vector<int> arr;\\n        string str=\"\";\\n        f(0,str,s,pal_strings,arr,0);\\n        int n=pal_strings.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                if((pal_strings[j] & pal_strings[i])==0){\\n                    answer=max(answer,arr[i]*arr[j]);\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dp[8000]={};\\nbool chk(string& s){\\n    int n=s.size();\\n    int i=0;\\n    int j=n-1;\\n    while(i<j && s[i]==s[j]) {\\n        i++;\\n        j--;\\n    }\\n    return i>=j;\\n}\\nint answer=1;\\nvoid f1(int x,int ind,string& str,string& s,int ind_mask,int mask){\\n    if(ind==s.size()) return;\\n    if(dp[ind_mask]) return;\\n    int inc=0;\\n    f1(x,ind+1,str,s,ind_mask,mask);\\n    if((mask & (1<<ind))==0){\\n        str+=s[ind];\\n        f1(x,ind+1,str,s,ind_mask | (1<<ind),mask);\\n        if(chk(str)){\\n            answer=max(answer,(int)(x*str.size()));\\n            dp[mask | ind_mask]=1;\\n        }\\n        str.pop_back();\\n    }\\n}\\nvoid f(int ind,string& str,string& s,int mask){\\n    if(ind==s.size()) return;\\n    str+=s[ind];\\n    f(ind+1,str,s,mask | (1<<ind));\\n    if(chk(str)){\\n        string ref=\"\";\\n        f1(str.size(),0,ref,s,0,mask | (1<<ind));\\n    }\\n    str.pop_back();\\n    f(ind+1,str,s,mask);\\n    dp[mask]=1;\\n    return ;\\n}\\n    int maxProduct(string s) {\\n        string str=\"\";\\n        f(0,str,s,0);\\n        return answer;\\n    }\\n};\\n```\n```\\nCode block\\nclass Solution {\\npublic:\\nbool chk(string& s){\\n    int n=s.size();\\n    int i=0;\\n    int j=n-1;\\n    while(i<j && s[i]==s[j]) {\\n        i++;\\n        j--;\\n    }\\n    return i>=j;\\n}\\nvoid f(int ind,string& str,string& s,vector<int>& pal_strings,vector<int>& arr,int mask){\\n    if(ind==s.size()) return;\\n    str+=s[ind];\\n    if(chk(str)){\\n        pal_strings.push_back(mask  | (1<<ind));\\n        arr.push_back(str.size());\\n    }\\n    f(ind+1,str,s,pal_strings,arr,mask | (1<<ind));\\n    str.pop_back();\\n    f(ind+1,str,s,pal_strings,arr,mask);\\n}\\n    int maxProduct(string s) {\\n        int answer=1;\\n        vector<int> pal_strings;\\n        vector<int> arr;\\n        string str=\"\";\\n        f(0,str,s,pal_strings,arr,0);\\n        int n=pal_strings.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                if((pal_strings[j] & pal_strings[i])==0){\\n                    answer=max(answer,arr[i]*arr[j]);\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417248,
                "title": "c-easy-solution-recursion-backtraking-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //TC=O(POW(3,N)*N)\\n    //SC=O(N+N)+O(M) M=STACK SPACE\\n    int find(int index,string& f,string& se,string& s,int n){\\n        if(index==n){\\n            bool one=true,two=true;\\n            int i=0,j=f.size()-1;\\n            while(i<=j){\\n                if(f[i]==f[j]){\\n                    i++;j--;\\n                }else{\\n                    one=false;\\n                    break;\\n                }\\n            }\\n            i=0,j=se.size()-1;\\n            while(i<=j){\\n                if(se[i]==se[j]){\\n                    i++;j--;\\n                }else{\\n                    two=false;\\n                    break;\\n                }\\n            }\\n          \\n            if(one && two){\\n                return f.size()*se.size();\\n            }\\n            return 1;\\n        }\\n        int first=0,second=0,not_take=0;\\n        f+=s[index];\\n        first=find(index+1,f,se,s,n);\\n        f.pop_back();\\n        se+=s[index];\\n        second=find(index+1,f,se,s,n);\\n        se.pop_back();\\n        not_take=find(index+1,f,se,s,n);\\n        return max(first,max(second,not_take));\\n    }\\n    int maxProduct(string s) {\\n        int n=s.size();\\n        string f=\"\",se=\"\";\\n        return find(0,f,se,s,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //TC=O(POW(3,N)*N)\\n    //SC=O(N+N)+O(M) M=STACK SPACE\\n    int find(int index,string& f,string& se,string& s,int n){\\n        if(index==n){\\n            bool one=true,two=true;\\n            int i=0,j=f.size()-1;\\n            while(i<=j){\\n                if(f[i]==f[j]){\\n                    i++;j--;\\n                }else{\\n                    one=false;\\n                    break;\\n                }\\n            }\\n            i=0,j=se.size()-1;\\n            while(i<=j){\\n                if(se[i]==se[j]){\\n                    i++;j--;\\n                }else{\\n                    two=false;\\n                    break;\\n                }\\n            }\\n          \\n            if(one && two){\\n                return f.size()*se.size();\\n            }\\n            return 1;\\n        }\\n        int first=0,second=0,not_take=0;\\n        f+=s[index];\\n        first=find(index+1,f,se,s,n);\\n        f.pop_back();\\n        se+=s[index];\\n        second=find(index+1,f,se,s,n);\\n        se.pop_back();\\n        not_take=find(index+1,f,se,s,n);\\n        return max(first,max(second,not_take));\\n    }\\n    int maxProduct(string s) {\\n        int n=s.size();\\n        string f=\"\",se=\"\";\\n        return find(0,f,se,s,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416829,
                "title": "c-short-concise-dp-bitmask-tc-o-2-2-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int IsPal(vector<int> &dp, string &s, int mask)\\n    {\\n        if(dp[mask]!=-1)return dp[mask];\\n        string x = \"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if((mask&(1<<i)) > 0)x += s[i];\\n        }\\n        int l=0, r = x.size()-1;\\n        while(l<r){\\n            if(x[l]!=x[r])return dp[mask] = 0;\\n            l++;r--;\\n        }\\n        return dp[mask] = 1;\\n    }\\n    int maxProduct(string s){\\n        int n = s.size(), ans = 1;\\n        vector<int> dp((1<<n), -1);\\n        for(int i=1;i<(1<<n);i++)\\n            for(int j=1;j<(1<<n);j++)\\n                if((i&j) == 0 && IsPal(dp,s,i) && IsPal(dp,s,j))\\n                    ans = max(ans, __builtin_popcount(i)*__builtin_popcount(j));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int IsPal(vector<int> &dp, string &s, int mask)\\n    {\\n        if(dp[mask]!=-1)return dp[mask];\\n        string x = \"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if((mask&(1<<i)) > 0)x += s[i];\\n        }\\n        int l=0, r = x.size()-1;\\n        while(l<r){\\n            if(x[l]!=x[r])return dp[mask] = 0;\\n            l++;r--;\\n        }\\n        return dp[mask] = 1;\\n    }\\n    int maxProduct(string s){\\n        int n = s.size(), ans = 1;\\n        vector<int> dp((1<<n), -1);\\n        for(int i=1;i<(1<<n);i++)\\n            for(int j=1;j<(1<<n);j++)\\n                if((i&j) == 0 && IsPal(dp,s,i) && IsPal(dp,s,j))\\n                    ans = max(ans, __builtin_popcount(i)*__builtin_popcount(j));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415436,
                "title": "python-easy-to-read-and-understand-recursion-memo",
                "content": "**RECURSION**\\n```\\nclass Solution:\\n    def solve(self, s, i, s1, s2):\\n        if s1 == s1[::-1] and s2 == s2[::-1]:\\n            #print(s1, s2)\\n            self.ans = max(self.ans, len(s1)*len(s2))\\n        if i == len(s):\\n            return\\n        self.solve(s, i+1, s1+s[i], s2)\\n        self.solve(s, i+1, s1, s2+s[i])\\n        self.solve(s, i+1, s1, s2)\\n    \\n    def maxProduct(self, s: str) -> int:\\n        self.ans = 0\\n        self.solve(s, 0, \\'\\', \\'\\')\\n        return self.ans\\n```\\n\\n**MEMOIZATION**\\n```\\nclass Solution:\\n    def solve(self, s, i, s1, s2):\\n        if s1 == s1[::-1] and s2 == s2[::-1]:\\n            #print(s1, s2)\\n            self.ans = max(self.ans, len(s1)*len(s2))\\n        if i == len(s):\\n            return\\n        if (i, s1, s2) in self.d:\\n            return\\n        self.d.add((i, s1, s2))\\n        self.solve(s, i+1, s1+s[i], s2)\\n        self.solve(s, i+1, s1, s2+s[i])\\n        self.solve(s, i+1, s1, s2)\\n    \\n    def maxProduct(self, s: str) -> int:\\n        self.ans = 0\\n        self.d = set()\\n        self.solve(s, 0, \\'\\', \\'\\')\\n        return self.ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def solve(self, s, i, s1, s2):\\n        if s1 == s1[::-1] and s2 == s2[::-1]:\\n            #print(s1, s2)\\n            self.ans = max(self.ans, len(s1)*len(s2))\\n        if i == len(s):\\n            return\\n        self.solve(s, i+1, s1+s[i], s2)\\n        self.solve(s, i+1, s1, s2+s[i])\\n        self.solve(s, i+1, s1, s2)\\n    \\n    def maxProduct(self, s: str) -> int:\\n        self.ans = 0\\n        self.solve(s, 0, \\'\\', \\'\\')\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393032,
                "title": "c-golang-bitmask",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\n    bool isPalindrome(string &s) {\\n        for(int i = 0, j = s.length() - 1; i < j; i++, j--) {\\n            if(s[i] != s[j]) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int maxProduct(string s) {\\n        int n = 1 << s.length();\\n        vector<pair<int, int>> Map;\\n        for(int i = 0; i < n; i++) {\\n            string seq = \"\";\\n            for(int j = 0; j < s.length(); j++) {\\n                if((i >> j) & 1) {\\n                    seq += s[j];\\n                }\\n            }\\n            if(isPalindrome(seq)) Map.push_back({i, seq.length()});\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < Map.size(); i++) {\\n            for(int j = i + 1; j < Map.size(); j++) {\\n                if((Map[i].first & Map[j].first) == 0) {\\n                    ans = max(Map[i].second * Map[j].second, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc isPalindrome(s string) bool {\\n    for i, j := 0, len(s) - 1; i < j; i, j = i + 1, j - 1 {\\n        if s[i] != s[j] {return false}\\n    }\\n    return true\\n}\\n\\nfunc maxProduct(s string) int {\\n    var n int = 1 << len(s)\\n    Map := [][]int{}\\n    for i := 0; i < n; i++ {\\n        seq := \"\"\\n        for j := 0; j < len(s); j++ {\\n            if ((i >> j) & 1) == 1 {\\n                seq += string(s[j])\\n            }\\n        }\\n        if isPalindrome(seq) {Map = append(Map, []int{i, len(seq)})};\\n    }\\n    var ans int = 0\\n    for i := 0; i < len(Map); i++ {\\n        for j := i + 1; j < len(Map); j++ {\\n            if (Map[i][0] & Map[j][0]) == 0 {\\n                if Map[i][1] * Map[j][1] > ans {\\n                    ans = Map[i][1] * Map[j][1]\\n                }\\n            }\\n        }\\n    }\\n    return ans\\n}        \\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "String",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\n// C++\\nclass Solution {\\n    bool isPalindrome(string &s) {\\n        for(int i = 0, j = s.length() - 1; i < j; i++, j--) {\\n            if(s[i] != s[j]) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int maxProduct(string s) {\\n        int n = 1 << s.length();\\n        vector<pair<int, int>> Map;\\n        for(int i = 0; i < n; i++) {\\n            string seq = \"\";\\n            for(int j = 0; j < s.length(); j++) {\\n                if((i >> j) & 1) {\\n                    seq += s[j];\\n                }\\n            }\\n            if(isPalindrome(seq)) Map.push_back({i, seq.length()});\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < Map.size(); i++) {\\n            for(int j = i + 1; j < Map.size(); j++) {\\n                if((Map[i].first & Map[j].first) == 0) {\\n                    ans = max(Map[i].second * Map[j].second, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc isPalindrome(s string) bool {\\n    for i, j := 0, len(s) - 1; i < j; i, j = i + 1, j - 1 {\\n        if s[i] != s[j] {return false}\\n    }\\n    return true\\n}\\n\\nfunc maxProduct(s string) int {\\n    var n int = 1 << len(s)\\n    Map := [][]int{}\\n    for i := 0; i < n; i++ {\\n        seq := \"\"\\n        for j := 0; j < len(s); j++ {\\n            if ((i >> j) & 1) == 1 {\\n                seq += string(s[j])\\n            }\\n        }\\n        if isPalindrome(seq) {Map = append(Map, []int{i, len(seq)})};\\n    }\\n    var ans int = 0\\n    for i := 0; i < len(Map); i++ {\\n        for j := i + 1; j < len(Map); j++ {\\n            if (Map[i][0] & Map[j][0]) == 0 {\\n                if Map[i][1] * Map[j][1] > ans {\\n                    ans = Map[i][1] * Map[j][1]\\n                }\\n            }\\n        }\\n    }\\n    return ans\\n}        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389735,
                "title": "javascript-with-bit-mask",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar maxProduct = function(s) {\\n    const len = s.length\\n    const m = {} // hashmap for palindrome, ex: { 1: 1, 2:1, ... , 128: 1, 130, 2 }\\n\\n    for (let mask=1;mask<(1<<len);mask++) { // iterate all cases \\n        let subseq = \"\" // temporary palindrome subsequence string\\n        for (let i=0;i<len;i++) { // iterate the total length of string\\n            if (mask & (1 << i)) { // if true, found a character index for the mask\\n                subseq += s[i] // append the character to the subsequence\\n            }\\n        }\\n        if (subseq == [...subseq].reverse().join(\\'\\')) { // check whether or not subseq is palindrome string\\n            m[mask] = subseq.length // if it\\'s palindrome, add it to the hashmap\\n        }\\n    }\\n    \\n    let res = 0\\n    // iterate nested loop to find the max product\\n    for (const [m1,] of Object.entries(m)) { \\n        for (const [m2,] of Object.entries(m)) {\\n            if ((+m1 & +m2) == 0) { // found disjoint subseq\\n               res = Math.max(res, m[m1] * m[m2])\\n            }\\n        }\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar maxProduct = function(s) {\\n    const len = s.length\\n    const m = {} // hashmap for palindrome, ex: { 1: 1, 2:1, ... , 128: 1, 130, 2 }\\n\\n    for (let mask=1;mask<(1<<len);mask++) { // iterate all cases \\n        let subseq = \"\" // temporary palindrome subsequence string\\n        for (let i=0;i<len;i++) { // iterate the total length of string\\n            if (mask & (1 << i)) { // if true, found a character index for the mask\\n                subseq += s[i] // append the character to the subsequence\\n            }\\n        }\\n        if (subseq == [...subseq].reverse().join(\\'\\')) { // check whether or not subseq is palindrome string\\n            m[mask] = subseq.length // if it\\'s palindrome, add it to the hashmap\\n        }\\n    }\\n    \\n    let res = 0\\n    // iterate nested loop to find the max product\\n    for (const [m1,] of Object.entries(m)) { \\n        for (const [m2,] of Object.entries(m)) {\\n            if ((+m1 & +m2) == 0) { // found disjoint subseq\\n               res = Math.max(res, m[m1] * m[m2])\\n            }\\n        }\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3382458,
                "title": "bruetforce-backtrack-solution-cpp",
                "content": "# Intuition and Approach\\n* first write the backtrack code which will create two disjoint subsequence of the given string.\\n* when reach to base condition check wheather formed two strings are palindrome or not.\\n* if yes then return product of their length,else return 0.\\n* return the max of all returning values.\\n\\n# Complexity\\n- Time complexity:O(3^n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int check(string s,string s1,string s2,int i,int n){\\n        if(i==n){\\n            int n1=s1.length();\\n            int n2=s2.length();\\n            if(n1==0 || n2==0)return 0;\\n            int l=0;\\n            int r=n1-1;\\n            while(l<=r){\\n                if(s1[l]!=s1[r])return 0;\\n                else{\\n                    l++;\\n                    r--;\\n                }\\n            }\\n            l=0;\\n            r=n2-1;\\n            while(l<=r){\\n                if(s2[l]!=s2[r])return 0;\\n                else{\\n                    l++;\\n                    r--;\\n                }\\n            }\\n            // cout<<s1<<\"--\"<<s2<<\"\\\\n\";\\n            return n1*n2;\\n        }\\n        else{\\n            return max(check(s,s1,s2,i+1,n),max(check(s,s1+s[i],s2,i+1,n),check(s,s1,s2+s[i],i+1,n)));\\n        }\\n    }\\n\\n    int maxProduct(string s) {\\n        int n=s.length();\\n        return check(s,\"\",\"\",0,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int check(string s,string s1,string s2,int i,int n){\\n        if(i==n){\\n            int n1=s1.length();\\n            int n2=s2.length();\\n            if(n1==0 || n2==0)return 0;\\n            int l=0;\\n            int r=n1-1;\\n            while(l<=r){\\n                if(s1[l]!=s1[r])return 0;\\n                else{\\n                    l++;\\n                    r--;\\n                }\\n            }\\n            l=0;\\n            r=n2-1;\\n            while(l<=r){\\n                if(s2[l]!=s2[r])return 0;\\n                else{\\n                    l++;\\n                    r--;\\n                }\\n            }\\n            // cout<<s1<<\"--\"<<s2<<\"\\\\n\";\\n            return n1*n2;\\n        }\\n        else{\\n            return max(check(s,s1,s2,i+1,n),max(check(s,s1+s[i],s2,i+1,n),check(s,s1,s2+s[i],i+1,n)));\\n        }\\n    }\\n\\n    int maxProduct(string s) {\\n        int n=s.length();\\n        return check(s,\"\",\"\",0,n);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3360345,
                "title": "generate-all-subsequences-backtracking-easy-to-understand-c-solution",
                "content": "\\n# Approach\\nStore all the subsequences of indices which will result into a palindrome. Then check for each pair of subsequence whether they are disjoint or not (the indices present in the pair of subsequences should be different). \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<vector<int>>ans;\\nbool isPalindrome(vector<int>&p, string str) {\\n    sort(p.begin(), p.end());\\n    int len = p.size();\\n    for(int i=0; i<len/2; i++) {\\n        if(str[p[i]] != str[p[len-i-1]]) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n    void printSubSeqRec(string &str, int n, int index, vector<int>indices = {}){\\n        // base case\\n        if (index == n)\\n            return;\\n    \\n        if (!indices.empty()) {\\n            if(isPalindrome(indices, str)) {\\n                ans.push_back(indices);\\n            }\\n        }\\n    \\n        for (int i = index+1; i < n; i++) {\\n            indices.push_back(i);\\n            printSubSeqRec(str, n, i,  indices);\\n            indices.pop_back();\\n        }\\n        return;\\n    }\\n    bool isDisjoint(vector<int>&s, vector<int>&t) {\\n        int i=0;\\n        int j =0 ;\\n        int n= s.size();\\n        int m = t.size();\\n        while(i < n && j < m) {\\n            if(s[i] == t[j]) {\\n                return false;\\n            }\\n            if(s[i] < t[j]) {\\n                i++;\\n            }\\n            else {\\n                j++;\\n            }\\n        }\\n        return true;\\n    }\\n    int maxProduct(string s) {\\n       printSubSeqRec(s, s.size(), -1,{});\\n        // for(auto it: ans ) {\\n        //     for(auto it1: it) {\\n        //         cout <<it1<< endl;\\n        //     }\\n        // }\\n        int len = ans.size();\\n       // cout << len << endl;\\n        int ansi = 0;\\n        for(int i=0; i<len; i++) {\\n            for(int j= i+1; j < len; j++) {\\n                if(isDisjoint(ans[i], ans[j])) {\\n                    ansi = max(ansi, (int)ans[i].size()*(int)ans[j].size());\\n                }\\n            }\\n        }\\n        return ansi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<vector<int>>ans;\\nbool isPalindrome(vector<int>&p, string str) {\\n    sort(p.begin(), p.end());\\n    int len = p.size();\\n    for(int i=0; i<len/2; i++) {\\n        if(str[p[i]] != str[p[len-i-1]]) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n    void printSubSeqRec(string &str, int n, int index, vector<int>indices = {}){\\n        // base case\\n        if (index == n)\\n            return;\\n    \\n        if (!indices.empty()) {\\n            if(isPalindrome(indices, str)) {\\n                ans.push_back(indices);\\n            }\\n        }\\n    \\n        for (int i = index+1; i < n; i++) {\\n            indices.push_back(i);\\n            printSubSeqRec(str, n, i,  indices);\\n            indices.pop_back();\\n        }\\n        return;\\n    }\\n    bool isDisjoint(vector<int>&s, vector<int>&t) {\\n        int i=0;\\n        int j =0 ;\\n        int n= s.size();\\n        int m = t.size();\\n        while(i < n && j < m) {\\n            if(s[i] == t[j]) {\\n                return false;\\n            }\\n            if(s[i] < t[j]) {\\n                i++;\\n            }\\n            else {\\n                j++;\\n            }\\n        }\\n        return true;\\n    }\\n    int maxProduct(string s) {\\n       printSubSeqRec(s, s.size(), -1,{});\\n        // for(auto it: ans ) {\\n        //     for(auto it1: it) {\\n        //         cout <<it1<< endl;\\n        //     }\\n        // }\\n        int len = ans.size();\\n       // cout << len << endl;\\n        int ansi = 0;\\n        for(int i=0; i<len; i++) {\\n            for(int j= i+1; j < len; j++) {\\n                if(isDisjoint(ans[i], ans[j])) {\\n                    ansi = max(ansi, (int)ans[i].size()*(int)ans[j].size());\\n                }\\n            }\\n        }\\n        return ansi;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3345526,
                "title": "o-4-n-bitmask",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(4 ^ n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func maxProduct(_ s: String) -> Int {\\n        var string = Array(s)\\n        var N = s.count\\n        var palindromHash = Dictionary<Int, Int>() //mask: lenght\\n        \\n        // leet code com0\\n        // 0000 0000 0001\\n        for mask in 1..<(1 << N) { // 1 -> 2 ^ N\\n            var paliCandidate = [Character]()\\n            for i in 0..<N {\\n                if mask & (1 << i) != 0 {\\n                    paliCandidate.append(string[i])\\n                }\\n            }\\n            \\n            if paliCandidate == paliCandidate.reversed() {\\n                palindromHash[mask] = paliCandidate.count\\n            }\\n        }\\n        \\n        var result = 0\\n        \\n        for (mask1, lenght1) in palindromHash {\\n            for (mask2, lenght2)  in palindromHash {\\n                if mask1 & mask2 == 0 {\\n                    result = max(result, lenght1 * lenght2)\\n                }\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxProduct(_ s: String) -> Int {\\n        var string = Array(s)\\n        var N = s.count\\n        var palindromHash = Dictionary<Int, Int>() //mask: lenght\\n        \\n        // leet code com0\\n        // 0000 0000 0001\\n        for mask in 1..<(1 << N) { // 1 -> 2 ^ N\\n            var paliCandidate = [Character]()\\n            for i in 0..<N {\\n                if mask & (1 << i) != 0 {\\n                    paliCandidate.append(string[i])\\n                }\\n            }\\n            \\n            if paliCandidate == paliCandidate.reversed() {\\n                palindromHash[mask] = paliCandidate.count\\n            }\\n        }\\n        \\n        var result = 0\\n        \\n        for (mask1, lenght1) in palindromHash {\\n            for (mask2, lenght2)  in palindromHash {\\n                if mask1 & mask2 == 0 {\\n                    result = max(result, lenght1 * lenght2)\\n                }\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303743,
                "title": "c-brute-force-with-number-of-iterations-analysis",
                "content": "```\\nclass Solution {\\npublic:\\n    // string of size 12, make 2 decisions at each index\\n    // 2 ^ 12 = 4096\\n    // then when reach end, take 2 ^ 12 to find longest palidrome within string, = 4096\\n    // = 4096 * 4096 = 16777216\\n    // memoization is optional for a such a short string\\n\\t// if memoization becomes 4096 * 12 * 12\\n    int m(string& s, int l, int r){\\n        if (l >= r) return l == r;\\n        if (s[l] == s[r]) return 2 + m(s, l + 1, r - 1);\\n        return max(m(s, l + 1, r), m(s, l, r - 1));\\n    }\\n    int dfs(string& a, string& b, string& s, int i){\\n        if (i == s.size())\\n            return m(a, 0, a.size() - 1) * m(b, 0, b.size() - 1);\\n            int ans = dfs(a += s[i], b, s, i + 1);\\n            a.pop_back();\\n            ans = max(ans, dfs(a, b += s[i], s, i + 1));\\n            b.pop_back();\\n            return ans;\\n    }\\n    int maxProduct(string s) {\\n        string a = \"\", b = \"\";\\n        return dfs(a, b, s, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // string of size 12, make 2 decisions at each index\\n    // 2 ^ 12 = 4096\\n    // then when reach end, take 2 ^ 12 to find longest palidrome within string, = 4096\\n    // = 4096 * 4096 = 16777216\\n    // memoization is optional for a such a short string\\n\\t// if memoization becomes 4096 * 12 * 12\\n    int m(string& s, int l, int r){\\n        if (l >= r) return l == r;\\n        if (s[l] == s[r]) return 2 + m(s, l + 1, r - 1);\\n        return max(m(s, l + 1, r), m(s, l, r - 1));\\n    }\\n    int dfs(string& a, string& b, string& s, int i){\\n        if (i == s.size())\\n            return m(a, 0, a.size() - 1) * m(b, 0, b.size() - 1);\\n            int ans = dfs(a += s[i], b, s, i + 1);\\n            a.pop_back();\\n            ans = max(ans, dfs(a, b += s[i], s, i + 1));\\n            b.pop_back();\\n            return ans;\\n    }\\n    int maxProduct(string s) {\\n        string a = \"\", b = \"\";\\n        return dfs(a, b, s, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293840,
                "title": "c",
                "content": "```\\nclass Solution {\\nprivate:\\n    int ret = 0 ;\\n    bool isPalindrome(string& s){\\n        int n = s.length() ;\\n        for(int i = 0; i < n/2 ; i++){\\n            if(s[i] != s[n-1-i])\\n                return false ;\\n        }\\n        return true ;\\n    }\\n    \\n    void dfs(const string& s, int cur, string& s1, string& s2){\\n        if(cur == s.size()){\\n            if(isPalindrome(s1) && isPalindrome(s2)){\\n                ret = fmax(ret , s1.size() * s2.size()) ;\\n            }    \\n            return ;\\n        }\\n        \\n        s1.push_back(s[cur]) ;\\n        dfs(s, cur+1, s1, s2) ;\\n        s1.pop_back() ;\\n        \\n        s2.push_back(s[cur]) ;\\n        dfs(s, cur+1, s1, s2) ;\\n        s2.pop_back() ;\\n        \\n        dfs(s, cur+1, s1, s2) ;\\n    }\\npublic:\\n    int maxProduct(string s) {\\n        string s1, s2 ;\\n        dfs(s, 0, s1, s2);\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int ret = 0 ;\\n    bool isPalindrome(string& s){\\n        int n = s.length() ;\\n        for(int i = 0; i < n/2 ; i++){\\n            if(s[i] != s[n-1-i])\\n                return false ;\\n        }\\n        return true ;\\n    }\\n    \\n    void dfs(const string& s, int cur, string& s1, string& s2){\\n        if(cur == s.size()){\\n            if(isPalindrome(s1) && isPalindrome(s2)){\\n                ret = fmax(ret , s1.size() * s2.size()) ;\\n            }    \\n            return ;\\n        }\\n        \\n        s1.push_back(s[cur]) ;\\n        dfs(s, cur+1, s1, s2) ;\\n        s1.pop_back() ;\\n        \\n        s2.push_back(s[cur]) ;\\n        dfs(s, cur+1, s1, s2) ;\\n        s2.pop_back() ;\\n        \\n        dfs(s, cur+1, s1, s2) ;\\n    }\\npublic:\\n    int maxProduct(string s) {\\n        string s1, s2 ;\\n        dfs(s, 0, s1, s2);\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280127,
                "title": "go-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nl: s.length\\nr: number of palindrome\\n- Time complexity: $$O(2^l+r^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(r)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npackage main\\n\\nfunc isPalin(s string) bool {\\n\\tfor i := 0; i < len(s)/2; i++ {\\n\\t\\tif s[i] != s[len(s)-1-i] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\nfunc maxProduct(s string) int {\\n\\tm := map[int]int{}\\n\\tp := map[string]bool{}\\n\\tvar gen func(i int, t string, ti int) bool\\n\\tgen = func(i int, t string, ti int) bool {\\n\\t\\tif i >= len(s) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\n\\t\\tnewT := t + s[i:i+1]\\n\\t\\tnewTi := ti | (1 << i)\\n\\t\\tif p[newT] || isPalin(newT) {\\n\\t\\t\\tp[newT] = true\\n\\t\\t\\tm[newTi] = len(newT)\\n\\t\\t}\\n\\n\\t\\t// choose i\\n\\t\\tgen(i+1, newT, newTi)\\n\\t\\t// not choose i\\n\\t\\tgen(i+1, t, ti)\\n\\n\\t\\treturn false\\n\\t}\\n\\tgen(0, \"\", 0)\\n\\n\\tres := 0\\n\\tfor k1, v1 := range m {\\n\\t\\tfor k2, v2 := range m {\\n\\t\\t\\tif k1&k2 == 0 && v1*v2 > res {\\n\\t\\t\\t\\tres = v1 * v2\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\nfunc isPalin(s string) bool {\\n\\tfor i := 0; i < len(s)/2; i++ {\\n\\t\\tif s[i] != s[len(s)-1-i] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\nfunc maxProduct(s string) int {\\n\\tm := map[int]int{}\\n\\tp := map[string]bool{}\\n\\tvar gen func(i int, t string, ti int) bool\\n\\tgen = func(i int, t string, ti int) bool {\\n\\t\\tif i >= len(s) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\n\\t\\tnewT := t + s[i:i+1]\\n\\t\\tnewTi := ti | (1 << i)\\n\\t\\tif p[newT] || isPalin(newT) {\\n\\t\\t\\tp[newT] = true\\n\\t\\t\\tm[newTi] = len(newT)\\n\\t\\t}\\n\\n\\t\\t// choose i\\n\\t\\tgen(i+1, newT, newTi)\\n\\t\\t// not choose i\\n\\t\\tgen(i+1, t, ti)\\n\\n\\t\\treturn false\\n\\t}\\n\\tgen(0, \"\", 0)\\n\\n\\tres := 0\\n\\tfor k1, v1 := range m {\\n\\t\\tfor k2, v2 := range m {\\n\\t\\t\\tif k1&k2 == 0 && v1*v2 > res {\\n\\t\\t\\t\\tres = v1 * v2\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3254114,
                "title": "javascript-2002-maximum-product-of-the-length-of-two-palindromic-subsequences",
                "content": "# Intuition\\nIt is better if we use a faster bit mask algorithm\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nvar maxProduct = function (s) {\\n    function isapalin(a) {\\n        let temp = [...a];\\n        let temps = temp.join(\"\");\\n        let tempsrev = temp.reverse().join(\"\");\\n        return temps === tempsrev;\\n    }\\n\\n    let max = -Infinity;\\n\\n    function bt(start = 0, ar1 = [], ar2 = []) {\\n        if (start === s.length) {\\n            if (isapalin(ar1) && isapalin(ar2)) {\\n                let m = ar1.length;\\n                let n = ar2.length;\\n                max = Math.max(max, m * n);\\n            }\\n            return;\\n        }\\n\\n        ar1.push(s[start]);\\n        bt(start + 1, ar1, ar2);\\n        ar1.pop();\\n\\n        ar2.push(s[start]);\\n        bt(start + 1, ar1, ar2);\\n        ar2.pop();\\n\\n        bt(start + 1, ar1, ar2);\\n    }\\n\\n    bt();\\n    return max;\\n};\\n```\\n\\n2\\n```\\nvar maxProduct = function (s) {\\n    function isapalin(a, i = 0, j = a.length - 1) {\\n        for (; i <= j && a[i] === a[j]; i++, j--) {}\\n        return i > j;\\n    }\\n    function isbpalin(m, a) {\\n        let temp = [];\\n        for (let i = s.length - 1; m > 0; i--, m = m >> 1) {\\n            if (m & 1) {\\n                temp.push(a[i]);\\n            }\\n        }\\n        return [isapalin(temp), temp.length];\\n    }\\n\\n    let max = -Infinity;\\n    let m1 = 0;\\n    let m2 = 0;\\n\\n    function bt(start = 0) {\\n        if (start === s.length) {\\n            let [is1, m] = isbpalin(m1, s);\\n            if (is1) {\\n                let [is2, n] = isbpalin(m2, s);\\n                if (is2) {\\n                    max = Math.max(max, m * n);\\n                }\\n            }\\n            return;\\n        }\\n\\n        m1 = m1 | (1 << start);\\n        bt(start + 1);\\n        m1 = m1 & ~(1 << start);\\n\\n        m2 = m2 | (1 << start);\\n        bt(start + 1);\\n        m2 = m2 & ~(1 << start);\\n\\n        bt(start + 1);\\n    }\\n\\n    bt();\\n    return max;\\n};\\n```\\n\\n3\\n```\\nconst maxProduct = (s) => {\\n    function ispalin(a, i = 0, j = a.length - 1) {\\n        for (; i <= j && a[i] === a[j]; i++, j--) {}\\n        return i > j;\\n    }\\n    const isdisjoint = (set1, set2) => {\\n        for (const e of set1)\\n            if (set2.has(e)) {\\n                return false;\\n            }\\n        return true;\\n    };\\n\\n    let n = s.length;\\n    let aa = [];\\n    for (let ss = 0; ss < 1 << n; ss++) {\\n        let sseq_s = \"\",\\n            sseq_idx_set = new Set();\\n        for (let bm = 1, i = 0; bm <= ss; bm <<= 1, i++) {\\n            if (ss & bm) {\\n                sseq_s += s[i];\\n                sseq_idx_set.add(i);\\n            }\\n        }\\n        if (ispalin(sseq_s)) {\\n            aa.push([sseq_s.length, sseq_idx_set]);\\n        }\\n    }\\n\\n    let m = aa.length;\\n    let max = 0;\\n    for (let i = 0; i < m; i++) {\\n        for (let j = i + 1; j < m; j++) {\\n            let [len1, sseq_idx_set1] = aa[i];\\n            let [len2, sseq_idx_set2] = aa[j];\\n            if (isdisjoint(sseq_idx_set1, sseq_idx_set2)) {\\n                max = Math.max(max, len1 * len2);\\n            }\\n        }\\n    }\\n    return max;\\n};\\n```\\n\\n4\\n```\\nvar maxProduct = function (s) {\\n    const ispalin = (s) => s && s === s.split(\"\").reverse().join(\"\");\\n\\n    const n = s.length;\\n    const subPal = {};\\n    const dfs = (i, str, pick) => {\\n        if (i === n) {\\n            if (ispalin(str)) {\\n                subPal[pick] = str;\\n            }\\n            return;\\n        }\\n        dfs(i + 1, str + s[i], pick | (1 << i));\\n        dfs(i + 1, str, pick);\\n    };\\n    dfs(0, \"\", 0);\\n\\n    const a_ss = Object.keys(subPal).map((k) => +k);\\n    let max = 0;\\n    for (let i = 0; i < a_ss.length; ++i) {\\n        INNER: for (let j = 0; j < a_ss.length; ++j) {\\n            const ss1 = a_ss[i];\\n            const ss2 = a_ss[j];\\n            for (let k = 0; k < n; ++k) {\\n                if (\\n                    ss1 & (1 << k) && //\\n                    ss2 & (1 << k)\\n                )\\n                    continue INNER;\\n            }\\n\\n            const subPal1 = subPal[ss1];\\n            const subPal2 = subPal[ss2];\\n            max = Math.max(max, subPal1.length * subPal2.length);\\n        }\\n    }\\n    return max;\\n};\\n```\\n\\n5\\n```\\nvar maxProduct = function (s) {\\n    function ispalin(a, i = 0, j = a.length - 1) {\\n        for (; i <= j && a[i] === a[j]; i++, j--) {}\\n        return i > j;\\n    }\\n    let max = 1;\\n    const dfs = (idx, s1, s2) => {\\n        if (idx === s.length) {\\n            if (ispalin(s1) && ispalin(s2)) {\\n                max = Math.max(max, s1.length * s2.length);\\n            }\\n            return;\\n        }\\n        dfs(idx + 1, s1 + s[idx], s2);\\n        dfs(idx + 1, s1, s2 + s[idx]);\\n        dfs(idx + 1, s1, s2);\\n    };\\n    dfs(0, \"\", \"\");\\n    return max;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxProduct = function (s) {\\n    function isapalin(a) {\\n        let temp = [...a];\\n        let temps = temp.join(\"\");\\n        let tempsrev = temp.reverse().join(\"\");\\n        return temps === tempsrev;\\n    }\\n\\n    let max = -Infinity;\\n\\n    function bt(start = 0, ar1 = [], ar2 = []) {\\n        if (start === s.length) {\\n            if (isapalin(ar1) && isapalin(ar2)) {\\n                let m = ar1.length;\\n                let n = ar2.length;\\n                max = Math.max(max, m * n);\\n            }\\n            return;\\n        }\\n\\n        ar1.push(s[start]);\\n        bt(start + 1, ar1, ar2);\\n        ar1.pop();\\n\\n        ar2.push(s[start]);\\n        bt(start + 1, ar1, ar2);\\n        ar2.pop();\\n\\n        bt(start + 1, ar1, ar2);\\n    }\\n\\n    bt();\\n    return max;\\n};\\n```\n```\\nvar maxProduct = function (s) {\\n    function isapalin(a, i = 0, j = a.length - 1) {\\n        for (; i <= j && a[i] === a[j]; i++, j--) {}\\n        return i > j;\\n    }\\n    function isbpalin(m, a) {\\n        let temp = [];\\n        for (let i = s.length - 1; m > 0; i--, m = m >> 1) {\\n            if (m & 1) {\\n                temp.push(a[i]);\\n            }\\n        }\\n        return [isapalin(temp), temp.length];\\n    }\\n\\n    let max = -Infinity;\\n    let m1 = 0;\\n    let m2 = 0;\\n\\n    function bt(start = 0) {\\n        if (start === s.length) {\\n            let [is1, m] = isbpalin(m1, s);\\n            if (is1) {\\n                let [is2, n] = isbpalin(m2, s);\\n                if (is2) {\\n                    max = Math.max(max, m * n);\\n                }\\n            }\\n            return;\\n        }\\n\\n        m1 = m1 | (1 << start);\\n        bt(start + 1);\\n        m1 = m1 & ~(1 << start);\\n\\n        m2 = m2 | (1 << start);\\n        bt(start + 1);\\n        m2 = m2 & ~(1 << start);\\n\\n        bt(start + 1);\\n    }\\n\\n    bt();\\n    return max;\\n};\\n```\n```\\nconst maxProduct = (s) => {\\n    function ispalin(a, i = 0, j = a.length - 1) {\\n        for (; i <= j && a[i] === a[j]; i++, j--) {}\\n        return i > j;\\n    }\\n    const isdisjoint = (set1, set2) => {\\n        for (const e of set1)\\n            if (set2.has(e)) {\\n                return false;\\n            }\\n        return true;\\n    };\\n\\n    let n = s.length;\\n    let aa = [];\\n    for (let ss = 0; ss < 1 << n; ss++) {\\n        let sseq_s = \"\",\\n            sseq_idx_set = new Set();\\n        for (let bm = 1, i = 0; bm <= ss; bm <<= 1, i++) {\\n            if (ss & bm) {\\n                sseq_s += s[i];\\n                sseq_idx_set.add(i);\\n            }\\n        }\\n        if (ispalin(sseq_s)) {\\n            aa.push([sseq_s.length, sseq_idx_set]);\\n        }\\n    }\\n\\n    let m = aa.length;\\n    let max = 0;\\n    for (let i = 0; i < m; i++) {\\n        for (let j = i + 1; j < m; j++) {\\n            let [len1, sseq_idx_set1] = aa[i];\\n            let [len2, sseq_idx_set2] = aa[j];\\n            if (isdisjoint(sseq_idx_set1, sseq_idx_set2)) {\\n                max = Math.max(max, len1 * len2);\\n            }\\n        }\\n    }\\n    return max;\\n};\\n```\n```\\nvar maxProduct = function (s) {\\n    const ispalin = (s) => s && s === s.split(\"\").reverse().join(\"\");\\n\\n    const n = s.length;\\n    const subPal = {};\\n    const dfs = (i, str, pick) => {\\n        if (i === n) {\\n            if (ispalin(str)) {\\n                subPal[pick] = str;\\n            }\\n            return;\\n        }\\n        dfs(i + 1, str + s[i], pick | (1 << i));\\n        dfs(i + 1, str, pick);\\n    };\\n    dfs(0, \"\", 0);\\n\\n    const a_ss = Object.keys(subPal).map((k) => +k);\\n    let max = 0;\\n    for (let i = 0; i < a_ss.length; ++i) {\\n        INNER: for (let j = 0; j < a_ss.length; ++j) {\\n            const ss1 = a_ss[i];\\n            const ss2 = a_ss[j];\\n            for (let k = 0; k < n; ++k) {\\n                if (\\n                    ss1 & (1 << k) && //\\n                    ss2 & (1 << k)\\n                )\\n                    continue INNER;\\n            }\\n\\n            const subPal1 = subPal[ss1];\\n            const subPal2 = subPal[ss2];\\n            max = Math.max(max, subPal1.length * subPal2.length);\\n        }\\n    }\\n    return max;\\n};\\n```\n```\\nvar maxProduct = function (s) {\\n    function ispalin(a, i = 0, j = a.length - 1) {\\n        for (; i <= j && a[i] === a[j]; i++, j--) {}\\n        return i > j;\\n    }\\n    let max = 1;\\n    const dfs = (idx, s1, s2) => {\\n        if (idx === s.length) {\\n            if (ispalin(s1) && ispalin(s2)) {\\n                max = Math.max(max, s1.length * s2.length);\\n            }\\n            return;\\n        }\\n        dfs(idx + 1, s1 + s[idx], s2);\\n        dfs(idx + 1, s1, s2 + s[idx]);\\n        dfs(idx + 1, s1, s2);\\n    };\\n    dfs(0, \"\", \"\");\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3240825,
                "title": "bit-mask-brute-force-without-dp-o-2-n",
                "content": "### Approach\\n\\n- First thing we have to do is find if the strings are disjoint. The easiest way to do this is to use Bit Masking instead of while loops.\\n\\n- We will have one spot in the the input for each character. Let input be leetcodecom. We have 11 characters and each subsequence will be represented by a bit mask. Eg **ete -> 01010001000 and cdc -> 00001010100**\\n\\n- Now if we run a logical and on the above bit masks, we can see that all will be 0 -> 00000000000. So the strings are disjoint.\\n\\n- We will have to go through every single subsquence in the string using backtracking.\\n\\n- So now for 11 characters, we can see that each combination can be made by changing some digits to 1.\\n\\n- We can run a for loop from 1 to 2^11 not including 2^11 because 2^11 is not in the range of values we can get by using 11 bits [100000000000] says that we dont include any character.\\n\\n- For every single subsequence, how do we know if its a palindrome?\\n\\n- If we do AND operation and get a 1 then we are basically choosing that character. So we add it to the subsequence string. Then we shift one from extreme right to extreme left 11 times.\\n\\n- Then we can check if the string in the previous step is a palindrome.\\n\\n- To keep a track of the length of the palindromic strings, we maintain a HashMap where the key of the hashMap will be the bit masked value and the value would be the length of the string.\\n\\n- The Time Complexity is O(2^n) but we run a nested for loop to calculate the product, so the TC is aactually O(4^n).\\n\\n### Code\\n```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        N,pali = len(s),{}\\n\\n        for mask in range(1, 2 << N):\\n            subseq = \"\"\\n            for i in range(N):\\n                if mask & (1 << i):\\n                    subseq += s[N - i - 1] # we are adding characters starting from right to left\\n            if subseq == subseq[::-1]:\\n                pali[mask] = len(subseq)\\n        res = 0\\n        for m1 in pali:\\n            for m2 in pali:\\n                if m1 & m2 == 0: # they are disjoint\\n                    res = max(res,pali[m1]*pali[m2])\\n        return res\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        N,pali = len(s),{}\\n\\n        for mask in range(1, 2 << N):\\n            subseq = \"\"\\n            for i in range(N):\\n                if mask & (1 << i):\\n                    subseq += s[N - i - 1] # we are adding characters starting from right to left\\n            if subseq == subseq[::-1]:\\n                pali[mask] = len(subseq)\\n        res = 0\\n        for m1 in pali:\\n            for m2 in pali:\\n                if m1 & m2 == 0: # they are disjoint\\n                    res = max(res,pali[m1]*pali[m2])\\n        return res\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227906,
                "title": "mask-dp-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint maxPalindromic(char *str){\\n    if(strlen(str)==1) return 1;\\n    int len = strlen(str);\\n    int dp[len][len];\\n    \\n    dp[0][0] = 1;\\n    for(int i=1; i<len; ++i){\\n        dp[i][i] = 1;\\n        dp[i-1][i] = str[i]==str[i-1] ? 2 : 1;\\n    }\\n\\n    for(int i=2; i<len; ++i){\\n        for(int j=0; i+j<len; ++j){\\n            int head = j, tail = i+j;\\n            dp[head][tail] = str[head]==str[tail] ? dp[head+1][tail-1]+2 : fmax(dp[head+1][tail], dp[head][tail-1]);\\n        }\\n    }\\n\\n    return dp[0][len-1];\\n}\\n\\nint maxProduct(char * s){\\n    int res = 0, mask = (1<<strlen(s))-1;\\n    \\n    for(int i=1; i<mask; ++i){\\n        int cnt1 = 0, cnt2 = 0;\\n        char tmp1[strlen(s)], tmp2[strlen(s)]; \\n        for(int j=strlen(s)-1; j>=0; --j){\\n            if(1<<j & i)\\n                tmp1[cnt1++] = s[j];\\n            else\\n                tmp2[cnt2++] = s[j];\\n        }\\n\\n        tmp1[cnt1] = \\'\\\\0\\';\\n        tmp2[cnt2] = \\'\\\\0\\';\\n        int len1 = maxPalindromic(tmp1), len2 = maxPalindromic(tmp2);\\n        res = fmax(res, len1*len2);\\n    }\\n\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxPalindromic(char *str){\\n    if(strlen(str)==1) return 1;\\n    int len = strlen(str);\\n    int dp[len][len];\\n    \\n    dp[0][0] = 1;\\n    for(int i=1; i<len; ++i){\\n        dp[i][i] = 1;\\n        dp[i-1][i] = str[i]==str[i-1] ? 2 : 1;\\n    }\\n\\n    for(int i=2; i<len; ++i){\\n        for(int j=0; i+j<len; ++j){\\n            int head = j, tail = i+j;\\n            dp[head][tail] = str[head]==str[tail] ? dp[head+1][tail-1]+2 : fmax(dp[head+1][tail], dp[head][tail-1]);\\n        }\\n    }\\n\\n    return dp[0][len-1];\\n}\\n\\nint maxProduct(char * s){\\n    int res = 0, mask = (1<<strlen(s))-1;\\n    \\n    for(int i=1; i<mask; ++i){\\n        int cnt1 = 0, cnt2 = 0;\\n        char tmp1[strlen(s)], tmp2[strlen(s)]; \\n        for(int j=strlen(s)-1; j>=0; --j){\\n            if(1<<j & i)\\n                tmp1[cnt1++] = s[j];\\n            else\\n                tmp2[cnt2++] = s[j];\\n        }\\n\\n        tmp1[cnt1] = \\'\\\\0\\';\\n        tmp2[cnt2] = \\'\\\\0\\';\\n        int len1 = maxPalindromic(tmp1), len2 = maxPalindromic(tmp2);\\n        res = fmax(res, len1*len2);\\n    }\\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3215454,
                "title": "rust-solution",
                "content": "# Approach\\nIn the context of the given code, a mask is an integer that encodes which characters of the input string `s` are included in the current subsequence being examined. In the loop for mask in `1..1<<s.len()`, each mask is an integer between 1 and 2^n - 1. \\nThe binary representation of each mask has a 1 in the i-th position if the i-th character of the input string is included in the current subsequence and a 0 otherwise.\\n    \\nFor example, if `s` is \"abc\", then the mask 5 (which is 101 in binary) would indicate that the subsequence being examined includes the first and third characters of `s`.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn max_product(s: String) -> i32 {\\n        // Create a vector of tuples containing the mask and length of each palindrome subsequence\\n        let mut pali_len: Vec<(usize, usize)> = (1..1 << s.len())\\n            .filter_map(|mask| {\\n                // Create the subsequence using the mask\\n                let subseq: String = (0..s.len()) // for each index in the input string\\n                    .filter(|i| mask & (1 << i) > 0) // if the bit corresponding to `i` is set in the mask\\n                    .map(|i| s.chars().nth(i).unwrap()) // append the character at that index to the subsequence\\n                    .collect();\\n\\n                // Check if the subsequence is a palindrome\\n                if subseq == subseq.chars().rev().collect::<String>() {\\n                    // if it is, return a tuple containing the mask and subsequence length\\n                    Some((mask, subseq.len())) \\n                } else {\\n                    None \\n                }\\n            })\\n            .collect();\\n\\n        // Sort the palindrome subsequence vector by length, descending\\n        pali_len.sort_by(|a, b| b.1.cmp(&a.1));\\n\\n        let mut res = 1;\\n        // Loop through the palindrome subsequence vector\\n        for i in 0..pali_len.len() {\\n            let (m1, l1) = pali_len[i];\\n            // If the length of the current subsequence squared is less than the current result, \\n            // we can break out of the loop since our palidromes are sorted in descending order by length.\\n            if l1.pow(2) < res {\\n                break;\\n            }\\n            // Loop through the rest of the palindrome subsequence vector\\n            for j in (i+1)..pali_len.len() {\\n                let (m2, l2) = pali_len[j];\\n                // If the two subsequence masks are disjoint and their lengths multiply to a \\n                // value greater than the current result, update the result and \\n                // break out of the inner loop\\n                if m1 & m2 == 0 && l1 * l2 > res {\\n                    res = l1 * l2;\\n                    break;\\n                }\\n            }\\n        }\\n        res as i32 \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_product(s: String) -> i32 {\\n        // Create a vector of tuples containing the mask and length of each palindrome subsequence\\n        let mut pali_len: Vec<(usize, usize)> = (1..1 << s.len())\\n            .filter_map(|mask| {\\n                // Create the subsequence using the mask\\n                let subseq: String = (0..s.len()) // for each index in the input string\\n                    .filter(|i| mask & (1 << i) > 0) // if the bit corresponding to `i` is set in the mask\\n                    .map(|i| s.chars().nth(i).unwrap()) // append the character at that index to the subsequence\\n                    .collect();\\n\\n                // Check if the subsequence is a palindrome\\n                if subseq == subseq.chars().rev().collect::<String>() {\\n                    // if it is, return a tuple containing the mask and subsequence length\\n                    Some((mask, subseq.len())) \\n                } else {\\n                    None \\n                }\\n            })\\n            .collect();\\n\\n        // Sort the palindrome subsequence vector by length, descending\\n        pali_len.sort_by(|a, b| b.1.cmp(&a.1));\\n\\n        let mut res = 1;\\n        // Loop through the palindrome subsequence vector\\n        for i in 0..pali_len.len() {\\n            let (m1, l1) = pali_len[i];\\n            // If the length of the current subsequence squared is less than the current result, \\n            // we can break out of the loop since our palidromes are sorted in descending order by length.\\n            if l1.pow(2) < res {\\n                break;\\n            }\\n            // Loop through the rest of the palindrome subsequence vector\\n            for j in (i+1)..pali_len.len() {\\n                let (m2, l2) = pali_len[j];\\n                // If the two subsequence masks are disjoint and their lengths multiply to a \\n                // value greater than the current result, update the result and \\n                // break out of the inner loop\\n                if m1 & m2 == 0 && l1 * l2 > res {\\n                    res = l1 * l2;\\n                    break;\\n                }\\n            }\\n        }\\n        res as i32 \\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3170904,
                "title": "c-code-for-beginners-easy-to-understand",
                "content": "# BRUTE FORCE\\n![image](https://assets.leetcode.com/users/images/31ccb050-c9ac-4e7e-b591-dd56a41c82fb_1676100059.819968.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int palindromeLen(string &str){\\n        int low=0;\\n        int high=str.size()-1;\\n        while(low<=high){\\n            if(str[low]!=str[high]){\\n                return 0;\\n            }\\n            low++;\\n            high--;\\n        }\\n        return str.size();\\n    }\\n    int generate_Subsequences(string &s, int curr, string str1, string str2){\\n        if(curr==s.size()){\\n            return palindromeLen(str1)*palindromeLen(str2);\\n        }\\n        \\n        str1+=s[curr];\\n        int ans1=generate_Subsequences(s,curr+1,str1,str2);\\n        str1.pop_back();\\n        \\n        str2+=s[curr];\\n        int ans2=generate_Subsequences(s,curr+1,str1,str2);\\n        str2.pop_back();\\n        \\n        int ans3=generate_Subsequences(s,curr+1,str1,str2);  // IGNORE\\n        \\n        return max(ans1,max(ans2,ans3));\\n    }\\n    int maxProduct(string s) {\\n        return generate_Subsequences(s,0,\"\",\"\");\\n    }\\n}; // O(3^n)\\n```\\n\\n# Optimised Solution\\n![image](https://assets.leetcode.com/users/images/a9fd2cfb-38de-4f88-9288-7f7b5d0adcd7_1676100251.5495672.png)\\n\\n\\nHere we first generate all subsequences and their masks which are palindromic. This will take O(2^n) time. Now we iterate over these masks and two masks are disjoint if their AND (&) is 0. Then we can use STL popcount, to get length and take maximum\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> palindromicMask;  // palindromic mask\\n    \\n    bool isPalin(string &build){\\n        int i=0;\\n        int j=build.size()-1;\\n        while(i<j){\\n            if(build[i]!=build[j]){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    void generate(string &s, int curr, string build, int mask){\\n        if(curr==s.size()){\\n            if(build!=\"\" && isPalin(build)==true){\\n                palindromicMask.push_back(mask);\\n            }\\n            return;\\n        }\\n        generate(s,curr+1,build+s[curr],mask | (1<<curr));\\n        generate(s,curr+1,build,mask);\\n    }\\n    \\n    int maxProduct(string s) {\\n        generate(s,0,\"\",0);\\n\\t\\t\\n        int res=0;\\n\\t\\t\\n        for(int i=0;i<palindromicMask.size();i++){\\n            for(int j=i+1;j<palindromicMask.size();j++){\\n                if((palindromicMask[i] & palindromicMask[j])==0){  // NON OVERLAPPING\\n                    int l1=__builtin_popcount(palindromicMask[i]);\\n                    int l2=__builtin_popcount(palindromicMask[j]);\\n                    res=max(res,l1*l2);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}; \\n```\\n",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int palindromeLen(string &str){\\n        int low=0;\\n        int high=str.size()-1;\\n        while(low<=high){\\n            if(str[low]!=str[high]){\\n                return 0;\\n            }\\n            low++;\\n            high--;\\n        }\\n        return str.size();\\n    }\\n    int generate_Subsequences(string &s, int curr, string str1, string str2){\\n        if(curr==s.size()){\\n            return palindromeLen(str1)*palindromeLen(str2);\\n        }\\n        \\n        str1+=s[curr];\\n        int ans1=generate_Subsequences(s,curr+1,str1,str2);\\n        str1.pop_back();\\n        \\n        str2+=s[curr];\\n        int ans2=generate_Subsequences(s,curr+1,str1,str2);\\n        str2.pop_back();\\n        \\n        int ans3=generate_Subsequences(s,curr+1,str1,str2);  // IGNORE\\n        \\n        return max(ans1,max(ans2,ans3));\\n    }\\n    int maxProduct(string s) {\\n        return generate_Subsequences(s,0,\"\",\"\");\\n    }\\n}; // O(3^n)\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> palindromicMask;  // palindromic mask\\n    \\n    bool isPalin(string &build){\\n        int i=0;\\n        int j=build.size()-1;\\n        while(i<j){\\n            if(build[i]!=build[j]){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    void generate(string &s, int curr, string build, int mask){\\n        if(curr==s.size()){\\n            if(build!=\"\" && isPalin(build)==true){\\n                palindromicMask.push_back(mask);\\n            }\\n            return;\\n        }\\n        generate(s,curr+1,build+s[curr],mask | (1<<curr));\\n        generate(s,curr+1,build,mask);\\n    }\\n    \\n    int maxProduct(string s) {\\n        generate(s,0,\"\",0);\\n\\t\\t\\n        int res=0;\\n\\t\\t\\n        for(int i=0;i<palindromicMask.size();i++){\\n            for(int j=i+1;j<palindromicMask.size();j++){\\n                if((palindromicMask[i] & palindromicMask[j])==0){  // NON OVERLAPPING\\n                    int l1=__builtin_popcount(palindromicMask[i]);\\n                    int l2=__builtin_popcount(palindromicMask[j]);\\n                    res=max(res,l1*l2);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143127,
                "title": "c-simple-efficient-brute-force-traversal-of-decision-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy looking at the constraints of this problem, we see that s will always be of size <= 12. This is a hint that the solution is probably inefficient and some kind of brute force.\\n\\nThe idea is the following: at each letter in s, we have the decision of adding the letter to either string 1 or string 2, or none at all. We can imagine these decisions at a decision tree, and we must therefore write a solution that traverses all possible paths of this decision tree.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can approach this problem with a recursive helper function that traverses the decision tree previously described. We take in the current index, the two strings we are building, and our best answer so far.\\n\\nAt each letter we have 3 subproblems: add the letter to s1, add the letter to s2, or skip entirely. Therefore we have 3 recursive calls for each index.\\n\\nOnce we finish going through all of string s, we check if the two strings we have are palindromes, and if so, check if we have found a larger product for our answer.\\n\\n\\n# Complexity\\n- Time complexity: O(3^N) - N = length of s\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(3^N) stack space used.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(string s) {\\n        // Brute force idea - generate all possible pairs of disjoint subsequences and see which solution has the best product.\\n        // Subproblem: either give the current letter to subsequence 1 or subsequence 2, or none at all. Once we have no letters left to consider,\\n        // we check if we have a new answer if both strings end up being palindromes.\\n\\n        int ans = 0;\\n        string s1 = \"\", s2 = \"\";\\n        DFS(s, 0, s1, s2, ans);\\n        return ans;\\n    }\\n\\n    void DFS(string& s, int index, string& s1, string& s2, int& ans) {\\n        if (index >= s.size()) {\\n            if (is_palindrome(s1) && is_palindrome(s2)) {\\n                ans = max(ans, int(s1.size()) * int(s2.size()));\\n            }\\n            return;\\n        }\\n\\n        // Try adding to s1\\n        s1 += s[index];\\n        DFS(s, index + 1, s1, s2, ans);\\n        s1.erase(s1.size() - 1);\\n\\n        // Try adding to s2\\n        s2 += s[index];\\n        DFS(s, index + 1, s1, s2, ans);\\n        s2.erase(s2.size() - 1);\\n\\n        // Try not adding to any of s1 or s2\\n        DFS(s, index + 1, s1, s2, ans);\\n    }\\n\\n    bool is_palindrome(const string& s) {\\n        int l = 0;\\n        int r = s.size() - 1;\\n        while (l <= r) {\\n            if (s[l] != s[r]) {\\n                return false;\\n            }\\n            l++;\\n            r--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(string s) {\\n        // Brute force idea - generate all possible pairs of disjoint subsequences and see which solution has the best product.\\n        // Subproblem: either give the current letter to subsequence 1 or subsequence 2, or none at all. Once we have no letters left to consider,\\n        // we check if we have a new answer if both strings end up being palindromes.\\n\\n        int ans = 0;\\n        string s1 = \"\", s2 = \"\";\\n        DFS(s, 0, s1, s2, ans);\\n        return ans;\\n    }\\n\\n    void DFS(string& s, int index, string& s1, string& s2, int& ans) {\\n        if (index >= s.size()) {\\n            if (is_palindrome(s1) && is_palindrome(s2)) {\\n                ans = max(ans, int(s1.size()) * int(s2.size()));\\n            }\\n            return;\\n        }\\n\\n        // Try adding to s1\\n        s1 += s[index];\\n        DFS(s, index + 1, s1, s2, ans);\\n        s1.erase(s1.size() - 1);\\n\\n        // Try adding to s2\\n        s2 += s[index];\\n        DFS(s, index + 1, s1, s2, ans);\\n        s2.erase(s2.size() - 1);\\n\\n        // Try not adding to any of s1 or s2\\n        DFS(s, index + 1, s1, s2, ans);\\n    }\\n\\n    bool is_palindrome(const string& s) {\\n        int l = 0;\\n        int r = s.size() - 1;\\n        while (l <= r) {\\n            if (s[l] != s[r]) {\\n                return false;\\n            }\\n            l++;\\n            r--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093940,
                "title": "c-backtracking-concept-will-blow-out-your-mind-must-know-concept",
                "content": "```\\nclass Solution {\\npublic:\\n    int isPalindrome(string &str)\\n    {\\n        int n=str.size();\\n        int i=0,j=n-1;\\n        while(i<=j)\\n        {\\n            if(str[i]!=str[j])\\n                return 0;\\n            i++;j--;\\n        }\\n        return n;\\n    }\\n    void solve(int i,string &s,string &s1,string &s2,int &ans)\\n    {\\n        if(i>=s.size())\\n        {\\n            ans=max(ans,(isPalindrome(s1))*(isPalindrome(s2)));\\n            return;\\n        }\\n        s1.push_back(s[i]);\\n        solve(i+1,s,s1,s2,ans);\\n        s1.pop_back();\\n        s2.push_back(s[i]);\\n        solve(i+1,s,s1,s2,ans);\\n        s2.pop_back();\\n        solve(i+1,s,s1,s2,ans);\\n    }\\n    int maxProduct(string &s) {\\n        int ans=INT_MIN;\\n        string s1=\"\",s2=\"\";\\n        solve(0,s,s1,s2,ans);\\n        return ans;\\n    }\\n};\\n```\\n\\nAN UPVOTE FROM YOUR SIDE IS HIGHLY APPRECIATED :)",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPalindrome(string &str)\\n    {\\n        int n=str.size();\\n        int i=0,j=n-1;\\n        while(i<=j)\\n        {\\n            if(str[i]!=str[j])\\n                return 0;\\n            i++;j--;\\n        }\\n        return n;\\n    }\\n    void solve(int i,string &s,string &s1,string &s2,int &ans)\\n    {\\n        if(i>=s.size())\\n        {\\n            ans=max(ans,(isPalindrome(s1))*(isPalindrome(s2)));\\n            return;\\n        }\\n        s1.push_back(s[i]);\\n        solve(i+1,s,s1,s2,ans);\\n        s1.pop_back();\\n        s2.push_back(s[i]);\\n        solve(i+1,s,s1,s2,ans);\\n        s2.pop_back();\\n        solve(i+1,s,s1,s2,ans);\\n    }\\n    int maxProduct(string &s) {\\n        int ans=INT_MIN;\\n        string s1=\"\",s2=\"\";\\n        solve(0,s,s1,s2,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093572,
                "title": "sample-backtracking-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(3^N)\\n\\n# Code\\n```\\nclass Solution {\\n      public int maxProduct(String s) {\\n         return maxProdPalind(s, 0, \"\", \"\");\\n    }\\n\\n    boolean checkPalin4(String str) {\\n        for(int i=0; i<str.length()/2; i++) {\\n            int len = str.length()-1-i;\\n            if(str.charAt(i) != str.charAt(len)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int maxProdPalind(String s, int start, String first, String second) {\\n         if(start >= s.length()) {\\n             return (!first.isEmpty() && checkPalin4(first) ? first.length() : 0) * (!second.isEmpty() && checkPalin4(second) ? second.length() : 0);\\n         }\\n         int val2  = maxProdPalind(s, start+1, first.concat(String.valueOf(s.charAt(start))), second);\\n         int val4  =  maxProdPalind(s, start+1, first, second.concat(String.valueOf(s.charAt(start))));\\n         int val3 = maxProdPalind(s, start+1, first, second);\\n         return Math.max(val2, Math.max(val3, val4));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n      public int maxProduct(String s) {\\n         return maxProdPalind(s, 0, \"\", \"\");\\n    }\\n\\n    boolean checkPalin4(String str) {\\n        for(int i=0; i<str.length()/2; i++) {\\n            int len = str.length()-1-i;\\n            if(str.charAt(i) != str.charAt(len)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int maxProdPalind(String s, int start, String first, String second) {\\n         if(start >= s.length()) {\\n             return (!first.isEmpty() && checkPalin4(first) ? first.length() : 0) * (!second.isEmpty() && checkPalin4(second) ? second.length() : 0);\\n         }\\n         int val2  = maxProdPalind(s, start+1, first.concat(String.valueOf(s.charAt(start))), second);\\n         int val4  =  maxProdPalind(s, start+1, first, second.concat(String.valueOf(s.charAt(start))));\\n         int val3 = maxProdPalind(s, start+1, first, second);\\n         return Math.max(val2, Math.max(val3, val4));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042695,
                "title": "easy-faster-efficient-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProduct(String s) {\\n        int n = s.length();\\n        int ans = 0;\\n        for(int i = 0; i <= (1 << n); i++){\\n            String x = \"\", y = \"\";\\n            for(int j = 0; j < n; j++){\\n                if(((1 << j) & i) > 0){\\n                    x += s.charAt(j);\\n                } else {\\n                    y += s.charAt(j);\\n                }\\n            }\\n            ans = Math.max(ans, helper(x) * helper(y));\\n        }\\n        return ans;\\n    }\\n    private int helper(String s){\\n        String str = \"\";\\n        for(int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            str = ch + str;\\n        }\\n        return lcs(s, str);\\n    }\\n    private int lcs(String a, String b){\\n        int n = a.length(), m = b.length();\\n        int [][] dp = new int[n + 1][m + 1];\\n        for(int i = 0; i <= n; i++){\\n            for(int j = 0; j < m + 1; j++){\\n                if(i == 0 || j == 0){\\n                    dp[i][j] = 0;\\n                } else if(a.charAt(i - 1) == b.charAt(j - 1)){\\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(String s) {\\n        int n = s.length();\\n        int ans = 0;\\n        for(int i = 0; i <= (1 << n); i++){\\n            String x = \"\", y = \"\";\\n            for(int j = 0; j < n; j++){\\n                if(((1 << j) & i) > 0){\\n                    x += s.charAt(j);\\n                } else {\\n                    y += s.charAt(j);\\n                }\\n            }\\n            ans = Math.max(ans, helper(x) * helper(y));\\n        }\\n        return ans;\\n    }\\n    private int helper(String s){\\n        String str = \"\";\\n        for(int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            str = ch + str;\\n        }\\n        return lcs(s, str);\\n    }\\n    private int lcs(String a, String b){\\n        int n = a.length(), m = b.length();\\n        int [][] dp = new int[n + 1][m + 1];\\n        for(int i = 0; i <= n; i++){\\n            for(int j = 0; j < m + 1; j++){\\n                if(i == 0 || j == 0){\\n                    dp[i][j] = 0;\\n                } else if(a.charAt(i - 1) == b.charAt(j - 1)){\\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038964,
                "title": "python-bitmask-max-subpalindrome",
                "content": "# Code\\n```\\nimport sys\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        def maxPalindrome(A):\\n            @cache\\n            def dfs(i,j):\\n                if i == j: return 1\\n                if i > j: return 0\\n                if A[i] == A[j]:\\n                    return 2 + dfs(i+1, j-1)\\n                return max(dfs(i+1,j), dfs(i,j-1))\\n            return dfs(0,len(A)-1)\\n        n = len(s)\\n        MAX = pow(2,n)\\n        \\n        res = 0\\n        for i in range(MAX):\\n            A, B = [], []\\n            for j in range(n):\\n                if i&(1<<j):\\n                    A.append(s[j])\\n                else:\\n                    B.append(s[j])\\n            res = max(res, maxPalindrome(A) * maxPalindrome(B))\\n        return res\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport sys\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        def maxPalindrome(A):\\n            @cache\\n            def dfs(i,j):\\n                if i == j: return 1\\n                if i > j: return 0\\n                if A[i] == A[j]:\\n                    return 2 + dfs(i+1, j-1)\\n                return max(dfs(i+1,j), dfs(i,j-1))\\n            return dfs(0,len(A)-1)\\n        n = len(s)\\n        MAX = pow(2,n)\\n        \\n        res = 0\\n        for i in range(MAX):\\n            A, B = [], []\\n            for j in range(n):\\n                if i&(1<<j):\\n                    A.append(s[j])\\n                else:\\n                    B.append(s[j])\\n            res = max(res, maxPalindrome(A) * maxPalindrome(B))\\n        return res\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028220,
                "title": "c-bit-manipulation-and-longest-palindromic-subsequence-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    \\n    int longest_p_s(string &str){\\n        int n=str.length();\\n        string str1=str;\\n        string str2=str;\\n        reverse(str1.begin(),str1.end());\\n        int dp[n+1][n+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<n+1;j++){\\n                if(i==0 || j==0){\\n                    dp[i][j]=0;\\n                }else if(str1[i-1]==str2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                }else{\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return dp[n][n];\\n    }\\n    \\n    \\n    int maxProduct(string s){\\n        int ans=0;\\n        int n=s.size();\\n        for(int i=1;i<(1<<n)-1;i++){   //generate all substrings except 0 length and s.length()\\n            string s1=\"\",s2=\"\";\\n            for(int j=0;j<n;j++){\\n                if(i&(1<<j)){\\n                    s1.push_back(s[j]);  // push set bit in s1\\n                }else{\\n                    s2.push_back(s[j]);  // push unset bit in s2\\n                }\\n            }\\n            ans=max(ans,longest_p_s(s1)*longest_p_s(s2));\\n        }\\n        return ans;\\n    }\\n    \\n};\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int longest_p_s(string &str){\\n        int n=str.length();\\n        string str1=str;\\n        string str2=str;\\n        reverse(str1.begin(),str1.end());\\n        int dp[n+1][n+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<n+1;j++){\\n                if(i==0 || j==0){\\n                    dp[i][j]=0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3013592,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        n = len(s)\\n        maskToLengthMap = {}\\n        res = 0\\n\\n        def createSubseqStringFromMask(mask):\\n            word = \\'\\'\\n            for i in range(n):\\n                if(1<<i & mask):\\n                    word+=s[n-i-1]\\n            return word\\n\\n        def checkPalindrome(s):\\n            return s==s[::-1]\\n\\n        for i in range(1, 1<<n):\\n            subsequence = createSubseqStringFromMask(i)\\n\\n            if checkPalindrome(subsequence):\\n                maskToLengthMap[i]=bin(i).count(\\'1\\')\\n\\n        for mask1, len1 in maskToLengthMap.items():\\n            for mask2, len2 in maskToLengthMap.items():\\n                if not (mask1 & mask2):\\n                    res = max(res, len1*len2)\\n\\n        return res\\n\\n\\n\\n            \\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        n = len(s)\\n        maskToLengthMap = {}\\n        res = 0\\n\\n        def createSubseqStringFromMask(mask):\\n            word = \\'\\'\\n            for i in range(n):\\n                if(1<<i & mask):\\n                    word+=s[n-i-1]\\n            return word\\n\\n        def checkPalindrome(s):\\n            return s==s[::-1]\\n\\n        for i in range(1, 1<<n):\\n            subsequence = createSubseqStringFromMask(i)\\n\\n            if checkPalindrome(subsequence):\\n                maskToLengthMap[i]=bin(i).count(\\'1\\')\\n\\n        for mask1, len1 in maskToLengthMap.items():\\n            for mask2, len2 in maskToLengthMap.items():\\n                if not (mask1 & mask2):\\n                    res = max(res, len1*len2)\\n\\n        return res\\n\\n\\n\\n            \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001289,
                "title": "python-3-o-2-n-n-2-time-o-n-space",
                "content": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        n = len(s)\\n        res = 0\\n        for mask in range(1, (1 << n) - 1):\\n            sub1, sub2 = [], []\\n            for i in range(n):\\n                if mask & 1:\\n                    sub1.append(i)\\n                else:\\n                    sub2.append(i)\\n                mask >>= 1\\n            if self.isPal(s, sub1):\\n                res = max(res, len(sub1) * self.longestPalSub(s, sub2))\\n        return res\\n    \\n    def isPal(self, s, sub):\\n        return all(s[sub[i]] == s[sub[~i]] for i in range(len(sub) >> 1))\\n        \\n    def longestPalSub(self, s, sub):\\n        n = len(sub)\\n        dp = [0] * n\\n        for left in range(n - 1, -1, -1):\\n            prev = 1\\n            for right in range(left + 1, n):\\n                if s[sub[left]] == s[sub[right]]:\\n                    cur = 2 + dp[right - 1]\\n                else:\\n                    cur = max(dp[right], prev)\\n                dp[right - 1] = prev\\n                prev = cur\\n            dp[n - 1] = prev\\n        return dp[n - 1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        n = len(s)\\n        res = 0\\n        for mask in range(1, (1 << n) - 1):\\n            sub1, sub2 = [], []\\n            for i in range(n):\\n                if mask & 1:\\n                    sub1.append(i)\\n                else:\\n                    sub2.append(i)\\n                mask >>= 1\\n            if self.isPal(s, sub1):\\n                res = max(res, len(sub1) * self.longestPalSub(s, sub2))\\n        return res\\n    \\n    def isPal(self, s, sub):\\n        return all(s[sub[i]] == s[sub[~i]] for i in range(len(sub) >> 1))\\n        \\n    def longestPalSub(self, s, sub):\\n        n = len(sub)\\n        dp = [0] * n\\n        for left in range(n - 1, -1, -1):\\n            prev = 1\\n            for right in range(left + 1, n):\\n                if s[sub[left]] == s[sub[right]]:\\n                    cur = 2 + dp[right - 1]\\n                else:\\n                    cur = max(dp[right], prev)\\n                dp[right - 1] = prev\\n                prev = cur\\n            dp[n - 1] = prev\\n        return dp[n - 1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976148,
                "title": "without-dp-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    static bool cmp(vector<ll>&v1,vector<ll>&v2){\\n        return v1.size()>v2.size();\\n    }\\n\\n    bool is_pali(string &temp){\\n        ll start=0,end=temp.length()-1;\\n        while(start<=end){\\n            if(temp[start++]!=temp[end--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int maxProduct(string s) {\\n        ll n=s.length(),answer=INT_MIN;\\n        vector<vector<ll>>container;\\n        for(ll i=1;i<(1LL<<n);i++){\\n            string temp=\"\";\\n            vector<ll>current;\\n            for(ll j=0;j<n;j++){\\n                if(i&(1LL<<j)){\\n                    temp+=s[j];\\n                    current.push_back(j);\\n                }\\n            }\\n            if(is_pali(temp)){\\n                container.push_back(current);\\n            }\\n        }\\n        sort(container.begin(),container.end(),cmp);\\n        // for(auto &x:container){\\n        //     for(auto &y:x){\\n        //         cout<<y<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        ll m=container.size();\\n        for(ll i=0;i<m;i++){\\n            bool now=true;\\n            for(ll j=0;j<m && now;j++){\\n                ll p=container[i].size(),q=container[j].size();\\n                if((p*q)<answer){\\n                    now=false;\\n                    continue;\\n                }\\n                bool condition=true;\\n                for(ll k=0;k<container[i].size() && condition;k++){\\n                    for(ll l=0;l<container[j].size() && condition;l++){\\n                        if(container[i][k]==container[j][l]){\\n                            condition=false;\\n                        }\\n                    }\\n                }\\n                if(condition){\\n                    answer=max(answer,(ll)container[i].size()*(ll)container[j].size());\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    static bool cmp(vector<ll>&v1,vector<ll>&v2){\\n        return v1.size()>v2.size();\\n    }\\n\\n    bool is_pali(string &temp){\\n        ll start=0,end=temp.length()-1;\\n        while(start<=end){\\n            if(temp[start++]!=temp[end--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int maxProduct(string s) {\\n        ll n=s.length(),answer=INT_MIN;\\n        vector<vector<ll>>container;\\n        for(ll i=1;i<(1LL<<n);i++){\\n            string temp=\"\";\\n            vector<ll>current;\\n            for(ll j=0;j<n;j++){\\n                if(i&(1LL<<j)){\\n                    temp+=s[j];\\n                    current.push_back(j);\\n                }\\n            }\\n            if(is_pali(temp)){\\n                container.push_back(current);\\n            }\\n        }\\n        sort(container.begin(),container.end(),cmp);\\n        // for(auto &x:container){\\n        //     for(auto &y:x){\\n        //         cout<<y<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        ll m=container.size();\\n        for(ll i=0;i<m;i++){\\n            bool now=true;\\n            for(ll j=0;j<m && now;j++){\\n                ll p=container[i].size(),q=container[j].size();\\n                if((p*q)<answer){\\n                    now=false;\\n                    continue;\\n                }\\n                bool condition=true;\\n                for(ll k=0;k<container[i].size() && condition;k++){\\n                    for(ll l=0;l<container[j].size() && condition;l++){\\n                        if(container[i][k]==container[j][l]){\\n                            condition=false;\\n                        }\\n                    }\\n                }\\n                if(condition){\\n                    answer=max(answer,(ll)container[i].size()*(ll)container[j].size());\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2921968,
                "title": "python-backtracking",
                "content": "#### Intuition\\nClassic backtracking. First looking for one pal than for other.\\n\\n#### Code\\n```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        used = [False for i in range(0, 13)]\\n        ans = 0\\n        cur = \"\"\\n        previous_len = 0\\n\\n        def solve(i):\\n            nonlocal used, ans, cur, previous_len, s\\n            if len(cur) > 0 and cur == cur[::-1]:\\n                if previous_len != 0:\\n                    ans = max(ans, len(cur) * previous_len)\\n                else:\\n                    previous_len, t, cur = len(cur), cur, \"\"\\n                    solve(0)\\n                    previous_len, cur = 0, t\\n\\n            for j in range(i, len(s)):\\n                if used[j] == False:\\n                    used[j], cur = True, cur + s[j]\\n                    solve(j + 1)\\n                    used[j], cur = False, cur[:-1]\\n        \\n        solve(0)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        used = [False for i in range(0, 13)]\\n        ans = 0\\n        cur = \"\"\\n        previous_len = 0\\n\\n        def solve(i):\\n            nonlocal used, ans, cur, previous_len, s\\n            if len(cur) > 0 and cur == cur[::-1]:\\n                if previous_len != 0:\\n                    ans = max(ans, len(cur) * previous_len)\\n                else:\\n                    previous_len, t, cur = len(cur), cur, \"\"\\n                    solve(0)\\n                    previous_len, cur = 0, t\\n\\n            for j in range(i, len(s)):\\n                if used[j] == False:\\n                    used[j], cur = True, cur + s[j]\\n                    solve(j + 1)\\n                    used[j], cur = False, cur[:-1]\\n        \\n        solve(0)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882464,
                "title": "python-bitmasking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        N,pali = len(s),{}\\n        res = 0 \\n        for mask in range(1, 1 << N):\\n            subseq = \"\"\\n            for i in range(N):\\n                if mask & (1 << i):\\n                    subseq += s[i]\\n            if subseq == subseq[::-1]:\\n                pali[mask] = len(subseq)\\n        for m1 in pali:\\n            for m2 in pali:\\n                if m1 & m2 == 0:\\n                    res = max(res,pali[m1] * pali[m2])\\n        return res \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        N,pali = len(s),{}\\n        res = 0 \\n        for mask in range(1, 1 << N):\\n            subseq = \"\"\\n            for i in range(N):\\n                if mask & (1 << i):\\n                    subseq += s[i]\\n            if subseq == subseq[::-1]:\\n                pali[mask] = len(subseq)\\n        for m1 in pali:\\n            for m2 in pali:\\n                if m1 & m2 == 0:\\n                    res = max(res,pali[m1] * pali[m2])\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2817974,
                "title": "java-easy-to-understand",
                "content": "```\\nchar[] arr;\\nList<Integer> palindromes;\\nprivate boolean checkPalindrome(int bitMask){\\n\\tint n = arr.length;\\n\\tStringBuilder s = new StringBuilder();\\n\\tfor(int i = 0; i < n; i++){\\n\\t\\tif((bitMask & (1 << i)) != 0) s.append(arr[i]);\\n\\t}\\n\\tString reverse = s.toString();\\n\\treturn reverse.equals(s.reverse().toString());\\n}\\nprivate void createSubsequences(int n, int bit){\\n\\tif(n == arr.length) {\\n\\t\\tif(checkPalindrome(bit))\\n\\t\\t\\tpalindromes.add(bit);\\n\\t\\treturn;\\n\\t}\\n\\tcreateSubsequences(n + 1, bit | (1 << n));\\n\\tcreateSubsequences(n + 1, bit);\\n}\\nprivate int countSetBit(int bit){\\n\\tint count = 0;\\n\\tfor(int i = 0; i < 12; i++)\\n\\t\\tif((bit & (1 << i)) != 0) count++;\\n\\treturn count;\\n}\\npublic int maxProduct(String s) {\\n\\tpalindromes = new ArrayList<>();\\n\\tarr = s.toCharArray();\\n\\tcreateSubsequences(0, 0);\\n\\tint max = 0;\\n\\tfor(int i = 0; i < palindromes.size(); i++){\\n\\t\\tfor(int j = i + 1; j < palindromes.size(); j++){\\n\\t\\t\\tif((palindromes.get(i) & palindromes.get(j)) == 0){\\n\\t\\t\\t\\tmax = Math.max(max, countSetBit(palindromes.get(i)) * countSetBit(palindromes.get(j)));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn max;\\n}",
                "solutionTags": [
                    "String",
                    "Backtracking",
                    "Bit Manipulation",
                    "Depth-First Search"
                ],
                "code": "```\\nchar[] arr;\\nList<Integer> palindromes;\\nprivate boolean checkPalindrome(int bitMask){\\n\\tint n = arr.length;\\n\\tStringBuilder s = new StringBuilder();\\n\\tfor(int i = 0; i < n; i++){\\n\\t\\tif((bitMask & (1 << i)) != 0) s.append(arr[i]);\\n\\t}\\n\\tString reverse = s.toString();\\n\\treturn reverse.equals(s.reverse().toString());\\n}\\nprivate void createSubsequences(int n, int bit){\\n\\tif(n == arr.length) {\\n\\t\\tif(checkPalindrome(bit))\\n\\t\\t\\tpalindromes.add(bit);\\n\\t\\treturn;\\n\\t}\\n\\tcreateSubsequences(n + 1, bit | (1 << n));\\n\\tcreateSubsequences(n + 1, bit);\\n}\\nprivate int countSetBit(int bit){\\n\\tint count = 0;\\n\\tfor(int i = 0; i < 12; i++)\\n\\t\\tif((bit & (1 << i)) != 0) count++;\\n\\treturn count;\\n}\\npublic int maxProduct(String s) {\\n\\tpalindromes = new ArrayList<>();\\n\\tarr = s.toCharArray();\\n\\tcreateSubsequences(0, 0);\\n\\tint max = 0;\\n\\tfor(int i = 0; i < palindromes.size(); i++){\\n\\t\\tfor(int j = i + 1; j < palindromes.size(); j++){\\n\\t\\t\\tif((palindromes.get(i) & palindromes.get(j)) == 0){\\n\\t\\t\\t\\tmax = Math.max(max, countSetBit(palindromes.get(i)) * countSetBit(palindromes.get(j)));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn max;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2815145,
                "title": "c-backtracking-maintaining-two-paths",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // We take two paths and use backtracking.\\n    // At each level \\n    // we append the current character \\n    // 1.in path1 and recurse\\n    // 2.in path2 and recurse \\n    // 3.do not append the current character\\n\\n    // At the end of the string we check if both the paths are palindrome and check the maximum product\\n    string path1;\\n    string path2;\\n\\n    int ans = -1e9;\\n    \\n    int max(int a, int b)\\n    {\\n        if(a>b)\\n        return a;\\n        return b;\\n    }\\n    bool check(string &str)\\n    {\\n        int i = 0, j = str.length()-1;\\n        while(i<j)\\n        {\\n            if(str[i++]!=str[j--])\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    void rec(string &str, int level)\\n    {\\n        if(level==str.length())\\n        {\\n            if(check(path1)&&check(path2))\\n            ans = max(ans,path1.length()*path2.length());\\n            return;\\n        }\\n\\n        path1+=str[level];\\n        rec(str,level+1);\\n        path1.pop_back();\\n\\n        path2+=str[level];\\n        rec(str,level+1);\\n        path2.pop_back();\\n\\n        rec(str,level+1);\\n    }\\n\\n    int maxProduct(string s) {\\n\\n            rec(s,0);\\n\\n            return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // We take two paths and use backtracking.\\n    // At each level \\n    // we append the current character \\n    // 1.in path1 and recurse\\n    // 2.in path2 and recurse \\n    // 3.do not append the current character\\n\\n    // At the end of the string we check if both the paths are palindrome and check the maximum product\\n    string path1;\\n    string path2;\\n\\n    int ans = -1e9;\\n    \\n    int max(int a, int b)\\n    {\\n        if(a>b)\\n        return a;\\n        return b;\\n    }\\n    bool check(string &str)\\n    {\\n        int i = 0, j = str.length()-1;\\n        while(i<j)\\n        {\\n            if(str[i++]!=str[j--])\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    void rec(string &str, int level)\\n    {\\n        if(level==str.length())\\n        {\\n            if(check(path1)&&check(path2))\\n            ans = max(ans,path1.length()*path2.length());\\n            return;\\n        }\\n\\n        path1+=str[level];\\n        rec(str,level+1);\\n        path1.pop_back();\\n\\n        path2+=str[level];\\n        rec(str,level+1);\\n        path2.pop_back();\\n\\n        rec(str,level+1);\\n    }\\n\\n    int maxProduct(string s) {\\n\\n            rec(s,0);\\n\\n            return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749255,
                "title": "c-backtracking-simple-solution",
                "content": "class Solution {\\npublic:\\n    int ans=0;\\n    bool ispalindrome(string &s)\\n    {\\n        int low=0;\\n        int high=s.size()-1;\\n        while(low<=high)\\n        {\\n            if(s[low]!=s[high])\\n            {\\n                return false;\\n            }\\n            low++;high--;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    void solve(string&s,string&s1,string&s2,int ind)\\n    {\\n        if(ind==s.size())\\n        {\\n            //cout<<s1<<\" \"<<s2<<endl;\\n            if(ispalindrome(s1)==true && ispalindrome(s2)==true)\\n            {\\n                int res=s1.size()*s2.size();\\n                ans=max(ans,res);\\n            }\\n            return;\\n        }\\n        else\\n        {\\n            s1.push_back(s[ind]);\\n            solve(s,s1,s2,ind+1);\\n            s1.pop_back();\\n            s2.push_back(s[ind]);\\n            solve(s,s1,s2,ind+1);\\n            s2.pop_back();\\n            solve(s,s1,s2,ind+1);\\n            \\n        }\\n    }\\n    int maxProduct(string s) {\\n        \\n        string s1=\"\";\\n        string s2=\"\";\\n        solve(s,s1,s2,0);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    int ans=0;\\n    bool ispalindrome(string &s)\\n    {\\n        int low=0;\\n        int high=s.size()-1;\\n        while(low<=high)\\n        {\\n            if(s[low]!=s[high])\\n            {\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2733638,
                "title": "java-recursion-backtracking",
                "content": "```\\nclass Solution {\\n \\n    int maxLen=0;\\n    public int maxProduct(String s) {\\n        StringBuilder sb1 = new StringBuilder();\\n        StringBuilder sb2 = new StringBuilder();\\n        helper(s, sb1, sb2, 0);\\n            return maxLen;\\n    }\\n    \\n    public void helper(String s,StringBuilder sb1, StringBuilder sb2, int index)\\n    {\\n        \\n        if(index >=s.length())\\n        {\\n           if(isPalindrome(sb1.toString()) && isPalindrome(sb2.toString()))\\n           {\\n               String s1 =sb1.toString();\\n               String s2 =sb2.toString();\\n               maxLen = Math.max(maxLen, s1.length() *s2.length());\\n           }\\n            return;\\n        }\\n        sb1.append(s.charAt(index));\\n        helper(s, sb1, sb2, index+1);\\n        sb1.deleteCharAt(sb1.length()-1);\\n        \\n        sb2.append(s.charAt(index));\\n        helper(s, sb1, sb2, index+1);\\n        sb2.deleteCharAt(sb2.length()-1);\\n        \\n        \\n        helper(s, sb1, sb2, index+1);\\n        \\n    }\\n    \\n    public boolean isPalindrome(String str)\\n    {\\n        if(str==\"\")\\n            return false;\\n            \\n        int start =0; int end =str.length()-1;\\n\\n            while(start<end)\\n            {\\n                if(str.charAt(start)!= str.charAt(end))\\n                {\\n                    return false;\\n                }\\n                start++;\\n                end--;\\n            }\\n\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n \\n    int maxLen=0;\\n    public int maxProduct(String s) {\\n        StringBuilder sb1 = new StringBuilder();\\n        StringBuilder sb2 = new StringBuilder();\\n        helper(s, sb1, sb2, 0);\\n            return maxLen;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2732023,
                "title": "java-clean-solution-backtracking-stringbuilder",
                "content": "```\\nclass Solution {\\n    private final int K = 2;\\n    \\n    int res = 1;\\n    List<StringBuilder> v = new ArrayList<>(K);\\n    public int maxProduct(String s) {\\n        for(int i = 0; i < K; i++)\\n            v.add(new StringBuilder());\\n        \\n        recur(s, 0);\\n        \\n        return res;\\n    }\\n    \\n    private void recur(String s, int start) {\\n        if(start == s.length()) {\\n            if(v.get(0).length() == 0 || v.get(1).length() == 0)\\n                return;\\n            if(isPalindrome(v.get(0)) && isPalindrome(v.get(1)))\\n                res = Math.max(res, v.get(0).length() * v.get(1).length());\\n            \\n            return;\\n        }\\n        \\n        for(int i = 0; i < K; i++) {\\n            v.get(i).append(s.charAt(start));\\n            recur(s, start + 1);\\n            v.get(i).deleteCharAt(v.get(i).length() - 1);\\n        }\\n        \\n        // Dont pick s.charAt(start) at all\\n        recur(s, start + 1);\\n    }\\n    \\n    private boolean isPalindrome(StringBuilder sb) {\\n        int i = 0, j = sb.length() - 1;\\n        \\n        while(i < j){\\n            if(sb.charAt(i++) != sb.charAt(j--))\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private final int K = 2;\\n    \\n    int res = 1;\\n    List<StringBuilder> v = new ArrayList<>(K);\\n    public int maxProduct(String s) {\\n        for(int i = 0; i < K; i++)\\n            v.add(new StringBuilder());\\n        \\n        recur(s, 0);\\n        \\n        return res;\\n    }\\n    \\n    private void recur(String s, int start) {\\n        if(start == s.length()) {\\n            if(v.get(0).length() == 0 || v.get(1).length() == 0)\\n                return;\\n            if(isPalindrome(v.get(0)) && isPalindrome(v.get(1)))\\n                res = Math.max(res, v.get(0).length() * v.get(1).length());\\n            \\n            return;\\n        }\\n        \\n        for(int i = 0; i < K; i++) {\\n            v.get(i).append(s.charAt(start));\\n            recur(s, start + 1);\\n            v.get(i).deleteCharAt(v.get(i).length() - 1);\\n        }\\n        \\n        // Dont pick s.charAt(start) at all\\n        recur(s, start + 1);\\n    }\\n    \\n    private boolean isPalindrome(StringBuilder sb) {\\n        int i = 0, j = sb.length() - 1;\\n        \\n        while(i < j){\\n            if(sb.charAt(i++) != sb.charAt(j--))\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699603,
                "title": "simple-brute-force-java",
                "content": "Time ~ O(3^n)\\nSpace ~ O(n) (excluding the stack calls)\\nThough we can probably memoize the result of recursion or terminate the recursion when we know it is going to be smaller than max product to improve run time but not much benifit here.\\n```\\nclass Solution { \\n    boolean isPalindrome(StringBuilder s){\\n        int n = s.length();\\n        for(int i=0;i<n/2;i++){\\n            if(s.charAt(i)!=s.charAt(n-i-1)) return false;\\n        }\\n        return true;\\n    }\\n    int solve(String s,int i,StringBuilder left,StringBuilder right){\\n        int n = s.length();\\n        if(i>=n) {\\n            if(isPalindrome(left) && isPalindrome(right)) return left.length()*right.length();\\n            return 0;\\n        }\\n        int wo = solve(s, i+1, left, right);\\n        right.append(s.charAt(i));\\n        int r = solve(s, i+1, left, right);\\n        right.deleteCharAt(right.length()-1);\\n        left.append(s.charAt(i));\\n        int l = solve(s, i+1, left, right);\\n        left.deleteCharAt(left.length()-1);\\n        return Math.max(Math.max(r, l),wo);\\n        \\n    }\\n    public int maxProduct(String s) {\\n        return solve(s, 0, new StringBuilder(), new StringBuilder());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution { \\n    boolean isPalindrome(StringBuilder s){\\n        int n = s.length();\\n        for(int i=0;i<n/2;i++){\\n            if(s.charAt(i)!=s.charAt(n-i-1)) return false;\\n        }\\n        return true;\\n    }\\n    int solve(String s,int i,StringBuilder left,StringBuilder right){\\n        int n = s.length();\\n        if(i>=n) {\\n            if(isPalindrome(left) && isPalindrome(right)) return left.length()*right.length();\\n            return 0;\\n        }\\n        int wo = solve(s, i+1, left, right);\\n        right.append(s.charAt(i));\\n        int r = solve(s, i+1, left, right);\\n        right.deleteCharAt(right.length()-1);\\n        left.append(s.charAt(i));\\n        int l = solve(s, i+1, left, right);\\n        left.deleteCharAt(left.length()-1);\\n        return Math.max(Math.max(r, l),wo);\\n        \\n    }\\n    public int maxProduct(String s) {\\n        return solve(s, 0, new StringBuilder(), new StringBuilder());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694262,
                "title": "c-bitmask",
                "content": "# Complexity\\n- Time complexity:\\n$$O(4^n)$$ -> `n` is the length of string `s`.\\n\\n- Space complexity:\\n$$O(2^n)$$ -> `n` is the length of string `s`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static int maxProduct(const string& s) {\\n        const int n = size(s);\\n        if (n < 2 || n > 12)\\n            return 0;\\n        vector<int> dp(1 << n);\\n\\n        auto isPalin = [&] (int mask)->int {\\n            int i = 1, j = 1 << n, i_idx = 0, j_idx = n;\\n            int res = 0;\\n            while (i < j) {\\n                if (0 == (mask & i)) {\\n                    ++i_idx;\\n                    i <<= 1;\\n                } else if (0 == (mask & j)) {\\n                    --j_idx;\\n                    j >>= 1;\\n                } else if (s[i_idx] != s[j_idx]) {\\n                    return 0;\\n                } else {\\n                    ++i_idx;\\n                    i <<= 1;\\n                    --j_idx;\\n                    j >>= 1;\\n                }\\n            }\\n            return __builtin_popcount(mask);\\n        };\\n\\n        int mask = (1 << n) - 1;\\n        for (int i = mask; i; --i)\\n            dp[i] = isPalin(i); \\n        int res = 0;\\n        for (int m1 = mask; m1 > 0; --m1)\\n            if (dp[m1] * (n - dp[m1]) > res) {\\n                auto m2_upper = mask ^ m1;\\n                for (int m2 = m2_upper; m2 > 0; m2 = (m2 - 1) & m2_upper)\\n                    res = max(res, dp[m1] * dp[m2]);\\n            }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int maxProduct(const string& s) {\\n        const int n = size(s);\\n        if (n < 2 || n > 12)\\n            return 0;\\n        vector<int> dp(1 << n);\\n\\n        auto isPalin = [&] (int mask)->int {\\n            int i = 1, j = 1 << n, i_idx = 0, j_idx = n;\\n            int res = 0;\\n            while (i < j) {\\n                if (0 == (mask & i)) {\\n                    ++i_idx;\\n                    i <<= 1;\\n                } else if (0 == (mask & j)) {\\n                    --j_idx;\\n                    j >>= 1;\\n                } else if (s[i_idx] != s[j_idx]) {\\n                    return 0;\\n                } else {\\n                    ++i_idx;\\n                    i <<= 1;\\n                    --j_idx;\\n                    j >>= 1;\\n                }\\n            }\\n            return __builtin_popcount(mask);\\n        };\\n\\n        int mask = (1 << n) - 1;\\n        for (int i = mask; i; --i)\\n            dp[i] = isPalin(i); \\n        int res = 0;\\n        for (int m1 = mask; m1 > 0; --m1)\\n            if (dp[m1] * (n - dp[m1]) > res) {\\n                auto m2_upper = mask ^ m1;\\n                for (int m2 = m2_upper; m2 > 0; m2 = (m2 - 1) & m2_upper)\\n                    res = max(res, dp[m1] * dp[m2]);\\n            }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685660,
                "title": "python-solution-with-explanation",
                "content": "```check(string)``` is to find lengh of the longest palindromic string in the ```string```\\n the basic idea is that enumerating all subsequence```preSeq``` and its disjoint subsequence```postSeq``` (```preSeq+postSeq=s```) and find the longest palindromic string in both sequence.\\ntc of ```check(string)``` is ```O(len(string)**2) = O(144)```\\n\\nso total tc is ```O(2**len(s))```, sc is the same as tc\\n\\n```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        \\n        @cache\\n        def check(string):\\n            if not string:\\n                return 0\\n            n = len(string)\\n            dp = [[0] * n for _ in range(n)]\\n            for i in range(n - 1, -1, -1):\\n                dp[i][i] = 1\\n                if i + 1 < n:\\n                    dp[i][i + 1] = int(string[i + 1] == string[i]) + 1\\n                for j in range(i + 2, n):\\n                    if string[i] == string[j]:\\n                        dp[i][j] = dp[i + 1][j - 1] + 2 if dp[i +1][j - 1] + 2 > dp[i][j] else dp[i][j]\\n                    dp[i][j] = dp[i + 1][j] if dp[i + 1][j] > dp[i][j] else dp[i][j]\\n                    dp[i][j] = dp[i][j - 1] if dp[i][j -1] > dp[i][j] else dp[i][j]\\n            return dp[0][n - 1] \\n        n = len(s)\\n        ans = 0\\n        for mask in range(1 << n):\\n            preSeq = \"\"\\n            postSeq = \"\"\\n            for j in range(n):\\n                if mask & (1 << j):\\n                    preSeq += s[j]\\n                else:\\n                    postSeq += s[j]\\n            cur = check(preSeq) * check(postSeq)\\n            ans = ans if ans > cur else cur\\n        return ans\\n```\\n\\nand there is a improvement,  ```mask >=2 ** (n-1)``` is redundant, the combination of both sequence has been enumerated.\\nso total tc is ```O(2**(len(s)-1))```, sc is the same as tc.\\n\\n```python\\n# Runtime: 710 ms, faster than 97.35% of Python3 online submissions for Maximum Product of the Length of Two Palindromic Subsequences.\\n# Memory Usage: 14.3 MB, less than 70.80% of Python3 online submissions for Maximum Product of the Length of Two Palindromic Subsequences.\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        \\n        @cache\\n        def check(string):\\n            if not string:\\n                return 0\\n            n = len(string)\\n            dp = [[0] * n for _ in range(n)]\\n            for i in range(n - 1, -1, -1):\\n                dp[i][i] = 1\\n                if i + 1 < n:\\n                    dp[i][i + 1] = int(string[i + 1] == string[i]) + 1\\n                for j in range(i + 2, n):\\n                    if string[i] == string[j]:\\n                        dp[i][j] = dp[i + 1][j - 1] + 2 if dp[i +1][j - 1] + 2 > dp[i][j] else dp[i][j]\\n                    dp[i][j] = dp[i + 1][j] if dp[i + 1][j] > dp[i][j] else dp[i][j]\\n                    dp[i][j] = dp[i][j - 1] if dp[i][j -1] > dp[i][j] else dp[i][j]\\n            return dp[0][n - 1] \\n        n = len(s)\\n        ans = 0\\n        for mask in range(1 << (n-1)):\\n            preSeq = \"\"\\n            postSeq = \"\"\\n            for j in range(n):\\n                if mask & (1 << j):\\n                    preSeq += s[j]\\n                else:\\n                    postSeq += s[j]\\n            cur = check(preSeq) * check(postSeq)\\n            ans = ans if ans > cur else cur\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```check(string)```\n```string```\n```preSeq```\n```postSeq```\n```preSeq+postSeq=s```\n```check(string)```\n```O(len(string)**2) = O(144)```\n```O(2**len(s))```\n```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        \\n        @cache\\n        def check(string):\\n            if not string:\\n                return 0\\n            n = len(string)\\n            dp = [[0] * n for _ in range(n)]\\n            for i in range(n - 1, -1, -1):\\n                dp[i][i] = 1\\n                if i + 1 < n:\\n                    dp[i][i + 1] = int(string[i + 1] == string[i]) + 1\\n                for j in range(i + 2, n):\\n                    if string[i] == string[j]:\\n                        dp[i][j] = dp[i + 1][j - 1] + 2 if dp[i +1][j - 1] + 2 > dp[i][j] else dp[i][j]\\n                    dp[i][j] = dp[i + 1][j] if dp[i + 1][j] > dp[i][j] else dp[i][j]\\n                    dp[i][j] = dp[i][j - 1] if dp[i][j -1] > dp[i][j] else dp[i][j]\\n            return dp[0][n - 1] \\n        n = len(s)\\n        ans = 0\\n        for mask in range(1 << n):\\n            preSeq = \"\"\\n            postSeq = \"\"\\n            for j in range(n):\\n                if mask & (1 << j):\\n                    preSeq += s[j]\\n                else:\\n                    postSeq += s[j]\\n            cur = check(preSeq) * check(postSeq)\\n            ans = ans if ans > cur else cur\\n        return ans\\n```\n```mask >=2 ** (n-1)```\n```O(2**(len(s)-1))```\n```python\\n# Runtime: 710 ms, faster than 97.35% of Python3 online submissions for Maximum Product of the Length of Two Palindromic Subsequences.\\n# Memory Usage: 14.3 MB, less than 70.80% of Python3 online submissions for Maximum Product of the Length of Two Palindromic Subsequences.\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        \\n        @cache\\n        def check(string):\\n            if not string:\\n                return 0\\n            n = len(string)\\n            dp = [[0] * n for _ in range(n)]\\n            for i in range(n - 1, -1, -1):\\n                dp[i][i] = 1\\n                if i + 1 < n:\\n                    dp[i][i + 1] = int(string[i + 1] == string[i]) + 1\\n                for j in range(i + 2, n):\\n                    if string[i] == string[j]:\\n                        dp[i][j] = dp[i + 1][j - 1] + 2 if dp[i +1][j - 1] + 2 > dp[i][j] else dp[i][j]\\n                    dp[i][j] = dp[i + 1][j] if dp[i + 1][j] > dp[i][j] else dp[i][j]\\n                    dp[i][j] = dp[i][j - 1] if dp[i][j -1] > dp[i][j] else dp[i][j]\\n            return dp[0][n - 1] \\n        n = len(s)\\n        ans = 0\\n        for mask in range(1 << (n-1)):\\n            preSeq = \"\"\\n            postSeq = \"\"\\n            for j in range(n):\\n                if mask & (1 << j):\\n                    preSeq += s[j]\\n                else:\\n                    postSeq += s[j]\\n            cur = check(preSeq) * check(postSeq)\\n            ans = ans if ans > cur else cur\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682985,
                "title": "simple-recursion-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    int check(string &a)\\n    {\\n        string b = a;\\n        reverse(b.begin(),b.end());\\n        return b==a;\\n    }\\n    \\n    void solve(string &s,string &a,string &b,int i)\\n    {\\n        if(i==s.size())\\n        {\\n            if(check(a) and check(b))\\n            {\\n                int x = a.size();\\n                int y = b.size();\\n                ans = max(ans,x*y);\\n            }\\n            return;\\n        }\\n        solve(s,a,b,i+1);\\n        a.push_back(s[i]);\\n        solve(s,a,b,i+1);\\n        a.pop_back();\\n        \\n        b.push_back(s[i]);\\n        solve(s,a,b,i+1);\\n        b.pop_back();\\n    }\\n    int maxProduct(string s) {\\n        string a = \"\";\\n        string b = \"\";\\n        solve(s,a,b,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    int check(string &a)\\n    {\\n        string b = a;\\n        reverse(b.begin(),b.end());\\n        return b==a;\\n    }\\n    \\n    void solve(string &s,string &a,string &b,int i)\\n    {\\n        if(i==s.size())\\n        {\\n            if(check(a) and check(b))\\n            {\\n                int x = a.size();\\n                int y = b.size();\\n                ans = max(ans,x*y);\\n            }\\n            return;\\n        }\\n        solve(s,a,b,i+1);\\n        a.push_back(s[i]);\\n        solve(s,a,b,i+1);\\n        a.pop_back();\\n        \\n        b.push_back(s[i]);\\n        solve(s,a,b,i+1);\\n        b.pop_back();\\n    }\\n    int maxProduct(string s) {\\n        string a = \"\";\\n        string b = \"\";\\n        solve(s,a,b,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1713772,
                "content": [
                    {
                        "username": "Real1236",
                        "content": "this should definitely be rated \\'hard\\'"
                    },
                    {
                        "username": "juancibarrac93",
                        "content": "I don\\'t think `Medium` is the right category for this problem. "
                    },
                    {
                        "username": "kmp1084",
                        "content": "People with no idea learn from DFS. People with good idea, implement DFS. People who are very learned implement DP!"
                    },
                    {
                        "username": "leetcode_dafu",
                        "content": "Generate all possible cases and compare the results\\n\\'\\'\\'\\n\\n\\tres={(\\'\\',\\'\\')}\\n\\tfor k in s:\\n\\t\\tres|={m for (i,j) in res for m in {(i+k,j),(i,k+j)}}\\n\\treturn max(len(i)*len(j) for i,j in res if i==i[::-1] and j==j[::-1])\\n\\'\\'\\'"
                    },
                    {
                        "username": "VanshKiit",
                        "content": "perfect medium problem"
                    },
                    {
                        "username": "kunal98p",
                        "content": "Reasonable solution hint: generate all the palindromic subsequences using recursion and backtracking. Mark the index as visited and then find the longest Palindromic subsequence in the remaining unvisited string using the concept of LCS/DP starting from the longest with break condition.\n\nT: O((N^2)*(2^N))  "
                    },
                    {
                        "username": "layyy",
                        "content": "passing by reference is a must in such problems"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Longest Common Subsequence is a Medium\\nLongest Palindromic Subsequence is a Medium, that consists of LCS\\nThis problem, that consists of LPS, is also a Medium"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Why O(2^24) code is getting accepted?"
                    },
                    {
                        "username": "Star_Drift",
                        "content": "[@kunal98p](/kunal98p) your math isn't good my friend\n"
                    },
                    {
                        "username": "kunal98p",
                        "content": "because thats just 4096. Way within the bounds."
                    },
                    {
                        "username": "Nihal_S",
                        "content": "no it isn\\'t"
                    }
                ]
            },
            {
                "id": 1815758,
                "content": [
                    {
                        "username": "Real1236",
                        "content": "this should definitely be rated \\'hard\\'"
                    },
                    {
                        "username": "juancibarrac93",
                        "content": "I don\\'t think `Medium` is the right category for this problem. "
                    },
                    {
                        "username": "kmp1084",
                        "content": "People with no idea learn from DFS. People with good idea, implement DFS. People who are very learned implement DP!"
                    },
                    {
                        "username": "leetcode_dafu",
                        "content": "Generate all possible cases and compare the results\\n\\'\\'\\'\\n\\n\\tres={(\\'\\',\\'\\')}\\n\\tfor k in s:\\n\\t\\tres|={m for (i,j) in res for m in {(i+k,j),(i,k+j)}}\\n\\treturn max(len(i)*len(j) for i,j in res if i==i[::-1] and j==j[::-1])\\n\\'\\'\\'"
                    },
                    {
                        "username": "VanshKiit",
                        "content": "perfect medium problem"
                    },
                    {
                        "username": "kunal98p",
                        "content": "Reasonable solution hint: generate all the palindromic subsequences using recursion and backtracking. Mark the index as visited and then find the longest Palindromic subsequence in the remaining unvisited string using the concept of LCS/DP starting from the longest with break condition.\n\nT: O((N^2)*(2^N))  "
                    },
                    {
                        "username": "layyy",
                        "content": "passing by reference is a must in such problems"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Longest Common Subsequence is a Medium\\nLongest Palindromic Subsequence is a Medium, that consists of LCS\\nThis problem, that consists of LPS, is also a Medium"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Why O(2^24) code is getting accepted?"
                    },
                    {
                        "username": "Star_Drift",
                        "content": "[@kunal98p](/kunal98p) your math isn't good my friend\n"
                    },
                    {
                        "username": "kunal98p",
                        "content": "because thats just 4096. Way within the bounds."
                    },
                    {
                        "username": "Nihal_S",
                        "content": "no it isn\\'t"
                    }
                ]
            },
            {
                "id": 1765091,
                "content": [
                    {
                        "username": "Real1236",
                        "content": "this should definitely be rated \\'hard\\'"
                    },
                    {
                        "username": "juancibarrac93",
                        "content": "I don\\'t think `Medium` is the right category for this problem. "
                    },
                    {
                        "username": "kmp1084",
                        "content": "People with no idea learn from DFS. People with good idea, implement DFS. People who are very learned implement DP!"
                    },
                    {
                        "username": "leetcode_dafu",
                        "content": "Generate all possible cases and compare the results\\n\\'\\'\\'\\n\\n\\tres={(\\'\\',\\'\\')}\\n\\tfor k in s:\\n\\t\\tres|={m for (i,j) in res for m in {(i+k,j),(i,k+j)}}\\n\\treturn max(len(i)*len(j) for i,j in res if i==i[::-1] and j==j[::-1])\\n\\'\\'\\'"
                    },
                    {
                        "username": "VanshKiit",
                        "content": "perfect medium problem"
                    },
                    {
                        "username": "kunal98p",
                        "content": "Reasonable solution hint: generate all the palindromic subsequences using recursion and backtracking. Mark the index as visited and then find the longest Palindromic subsequence in the remaining unvisited string using the concept of LCS/DP starting from the longest with break condition.\n\nT: O((N^2)*(2^N))  "
                    },
                    {
                        "username": "layyy",
                        "content": "passing by reference is a must in such problems"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Longest Common Subsequence is a Medium\\nLongest Palindromic Subsequence is a Medium, that consists of LCS\\nThis problem, that consists of LPS, is also a Medium"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Why O(2^24) code is getting accepted?"
                    },
                    {
                        "username": "Star_Drift",
                        "content": "[@kunal98p](/kunal98p) your math isn't good my friend\n"
                    },
                    {
                        "username": "kunal98p",
                        "content": "because thats just 4096. Way within the bounds."
                    },
                    {
                        "username": "Nihal_S",
                        "content": "no it isn\\'t"
                    }
                ]
            },
            {
                "id": 1570600,
                "content": [
                    {
                        "username": "Real1236",
                        "content": "this should definitely be rated \\'hard\\'"
                    },
                    {
                        "username": "juancibarrac93",
                        "content": "I don\\'t think `Medium` is the right category for this problem. "
                    },
                    {
                        "username": "kmp1084",
                        "content": "People with no idea learn from DFS. People with good idea, implement DFS. People who are very learned implement DP!"
                    },
                    {
                        "username": "leetcode_dafu",
                        "content": "Generate all possible cases and compare the results\\n\\'\\'\\'\\n\\n\\tres={(\\'\\',\\'\\')}\\n\\tfor k in s:\\n\\t\\tres|={m for (i,j) in res for m in {(i+k,j),(i,k+j)}}\\n\\treturn max(len(i)*len(j) for i,j in res if i==i[::-1] and j==j[::-1])\\n\\'\\'\\'"
                    },
                    {
                        "username": "VanshKiit",
                        "content": "perfect medium problem"
                    },
                    {
                        "username": "kunal98p",
                        "content": "Reasonable solution hint: generate all the palindromic subsequences using recursion and backtracking. Mark the index as visited and then find the longest Palindromic subsequence in the remaining unvisited string using the concept of LCS/DP starting from the longest with break condition.\n\nT: O((N^2)*(2^N))  "
                    },
                    {
                        "username": "layyy",
                        "content": "passing by reference is a must in such problems"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Longest Common Subsequence is a Medium\\nLongest Palindromic Subsequence is a Medium, that consists of LCS\\nThis problem, that consists of LPS, is also a Medium"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Why O(2^24) code is getting accepted?"
                    },
                    {
                        "username": "Star_Drift",
                        "content": "[@kunal98p](/kunal98p) your math isn't good my friend\n"
                    },
                    {
                        "username": "kunal98p",
                        "content": "because thats just 4096. Way within the bounds."
                    },
                    {
                        "username": "Nihal_S",
                        "content": "no it isn\\'t"
                    }
                ]
            },
            {
                "id": 2075474,
                "content": [
                    {
                        "username": "Real1236",
                        "content": "this should definitely be rated \\'hard\\'"
                    },
                    {
                        "username": "juancibarrac93",
                        "content": "I don\\'t think `Medium` is the right category for this problem. "
                    },
                    {
                        "username": "kmp1084",
                        "content": "People with no idea learn from DFS. People with good idea, implement DFS. People who are very learned implement DP!"
                    },
                    {
                        "username": "leetcode_dafu",
                        "content": "Generate all possible cases and compare the results\\n\\'\\'\\'\\n\\n\\tres={(\\'\\',\\'\\')}\\n\\tfor k in s:\\n\\t\\tres|={m for (i,j) in res for m in {(i+k,j),(i,k+j)}}\\n\\treturn max(len(i)*len(j) for i,j in res if i==i[::-1] and j==j[::-1])\\n\\'\\'\\'"
                    },
                    {
                        "username": "VanshKiit",
                        "content": "perfect medium problem"
                    },
                    {
                        "username": "kunal98p",
                        "content": "Reasonable solution hint: generate all the palindromic subsequences using recursion and backtracking. Mark the index as visited and then find the longest Palindromic subsequence in the remaining unvisited string using the concept of LCS/DP starting from the longest with break condition.\n\nT: O((N^2)*(2^N))  "
                    },
                    {
                        "username": "layyy",
                        "content": "passing by reference is a must in such problems"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Longest Common Subsequence is a Medium\\nLongest Palindromic Subsequence is a Medium, that consists of LCS\\nThis problem, that consists of LPS, is also a Medium"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Why O(2^24) code is getting accepted?"
                    },
                    {
                        "username": "Star_Drift",
                        "content": "[@kunal98p](/kunal98p) your math isn't good my friend\n"
                    },
                    {
                        "username": "kunal98p",
                        "content": "because thats just 4096. Way within the bounds."
                    },
                    {
                        "username": "Nihal_S",
                        "content": "no it isn\\'t"
                    }
                ]
            },
            {
                "id": 2069864,
                "content": [
                    {
                        "username": "Real1236",
                        "content": "this should definitely be rated \\'hard\\'"
                    },
                    {
                        "username": "juancibarrac93",
                        "content": "I don\\'t think `Medium` is the right category for this problem. "
                    },
                    {
                        "username": "kmp1084",
                        "content": "People with no idea learn from DFS. People with good idea, implement DFS. People who are very learned implement DP!"
                    },
                    {
                        "username": "leetcode_dafu",
                        "content": "Generate all possible cases and compare the results\\n\\'\\'\\'\\n\\n\\tres={(\\'\\',\\'\\')}\\n\\tfor k in s:\\n\\t\\tres|={m for (i,j) in res for m in {(i+k,j),(i,k+j)}}\\n\\treturn max(len(i)*len(j) for i,j in res if i==i[::-1] and j==j[::-1])\\n\\'\\'\\'"
                    },
                    {
                        "username": "VanshKiit",
                        "content": "perfect medium problem"
                    },
                    {
                        "username": "kunal98p",
                        "content": "Reasonable solution hint: generate all the palindromic subsequences using recursion and backtracking. Mark the index as visited and then find the longest Palindromic subsequence in the remaining unvisited string using the concept of LCS/DP starting from the longest with break condition.\n\nT: O((N^2)*(2^N))  "
                    },
                    {
                        "username": "layyy",
                        "content": "passing by reference is a must in such problems"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Longest Common Subsequence is a Medium\\nLongest Palindromic Subsequence is a Medium, that consists of LCS\\nThis problem, that consists of LPS, is also a Medium"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Why O(2^24) code is getting accepted?"
                    },
                    {
                        "username": "Star_Drift",
                        "content": "[@kunal98p](/kunal98p) your math isn't good my friend\n"
                    },
                    {
                        "username": "kunal98p",
                        "content": "because thats just 4096. Way within the bounds."
                    },
                    {
                        "username": "Nihal_S",
                        "content": "no it isn\\'t"
                    }
                ]
            },
            {
                "id": 2055853,
                "content": [
                    {
                        "username": "Real1236",
                        "content": "this should definitely be rated \\'hard\\'"
                    },
                    {
                        "username": "juancibarrac93",
                        "content": "I don\\'t think `Medium` is the right category for this problem. "
                    },
                    {
                        "username": "kmp1084",
                        "content": "People with no idea learn from DFS. People with good idea, implement DFS. People who are very learned implement DP!"
                    },
                    {
                        "username": "leetcode_dafu",
                        "content": "Generate all possible cases and compare the results\\n\\'\\'\\'\\n\\n\\tres={(\\'\\',\\'\\')}\\n\\tfor k in s:\\n\\t\\tres|={m for (i,j) in res for m in {(i+k,j),(i,k+j)}}\\n\\treturn max(len(i)*len(j) for i,j in res if i==i[::-1] and j==j[::-1])\\n\\'\\'\\'"
                    },
                    {
                        "username": "VanshKiit",
                        "content": "perfect medium problem"
                    },
                    {
                        "username": "kunal98p",
                        "content": "Reasonable solution hint: generate all the palindromic subsequences using recursion and backtracking. Mark the index as visited and then find the longest Palindromic subsequence in the remaining unvisited string using the concept of LCS/DP starting from the longest with break condition.\n\nT: O((N^2)*(2^N))  "
                    },
                    {
                        "username": "layyy",
                        "content": "passing by reference is a must in such problems"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Longest Common Subsequence is a Medium\\nLongest Palindromic Subsequence is a Medium, that consists of LCS\\nThis problem, that consists of LPS, is also a Medium"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Why O(2^24) code is getting accepted?"
                    },
                    {
                        "username": "Star_Drift",
                        "content": "[@kunal98p](/kunal98p) your math isn't good my friend\n"
                    },
                    {
                        "username": "kunal98p",
                        "content": "because thats just 4096. Way within the bounds."
                    },
                    {
                        "username": "Nihal_S",
                        "content": "no it isn\\'t"
                    }
                ]
            },
            {
                "id": 1977049,
                "content": [
                    {
                        "username": "Real1236",
                        "content": "this should definitely be rated \\'hard\\'"
                    },
                    {
                        "username": "juancibarrac93",
                        "content": "I don\\'t think `Medium` is the right category for this problem. "
                    },
                    {
                        "username": "kmp1084",
                        "content": "People with no idea learn from DFS. People with good idea, implement DFS. People who are very learned implement DP!"
                    },
                    {
                        "username": "leetcode_dafu",
                        "content": "Generate all possible cases and compare the results\\n\\'\\'\\'\\n\\n\\tres={(\\'\\',\\'\\')}\\n\\tfor k in s:\\n\\t\\tres|={m for (i,j) in res for m in {(i+k,j),(i,k+j)}}\\n\\treturn max(len(i)*len(j) for i,j in res if i==i[::-1] and j==j[::-1])\\n\\'\\'\\'"
                    },
                    {
                        "username": "VanshKiit",
                        "content": "perfect medium problem"
                    },
                    {
                        "username": "kunal98p",
                        "content": "Reasonable solution hint: generate all the palindromic subsequences using recursion and backtracking. Mark the index as visited and then find the longest Palindromic subsequence in the remaining unvisited string using the concept of LCS/DP starting from the longest with break condition.\n\nT: O((N^2)*(2^N))  "
                    },
                    {
                        "username": "layyy",
                        "content": "passing by reference is a must in such problems"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Longest Common Subsequence is a Medium\\nLongest Palindromic Subsequence is a Medium, that consists of LCS\\nThis problem, that consists of LPS, is also a Medium"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Why O(2^24) code is getting accepted?"
                    },
                    {
                        "username": "Star_Drift",
                        "content": "[@kunal98p](/kunal98p) your math isn't good my friend\n"
                    },
                    {
                        "username": "kunal98p",
                        "content": "because thats just 4096. Way within the bounds."
                    },
                    {
                        "username": "Nihal_S",
                        "content": "no it isn\\'t"
                    }
                ]
            },
            {
                "id": 1935982,
                "content": [
                    {
                        "username": "Real1236",
                        "content": "this should definitely be rated \\'hard\\'"
                    },
                    {
                        "username": "juancibarrac93",
                        "content": "I don\\'t think `Medium` is the right category for this problem. "
                    },
                    {
                        "username": "kmp1084",
                        "content": "People with no idea learn from DFS. People with good idea, implement DFS. People who are very learned implement DP!"
                    },
                    {
                        "username": "leetcode_dafu",
                        "content": "Generate all possible cases and compare the results\\n\\'\\'\\'\\n\\n\\tres={(\\'\\',\\'\\')}\\n\\tfor k in s:\\n\\t\\tres|={m for (i,j) in res for m in {(i+k,j),(i,k+j)}}\\n\\treturn max(len(i)*len(j) for i,j in res if i==i[::-1] and j==j[::-1])\\n\\'\\'\\'"
                    },
                    {
                        "username": "VanshKiit",
                        "content": "perfect medium problem"
                    },
                    {
                        "username": "kunal98p",
                        "content": "Reasonable solution hint: generate all the palindromic subsequences using recursion and backtracking. Mark the index as visited and then find the longest Palindromic subsequence in the remaining unvisited string using the concept of LCS/DP starting from the longest with break condition.\n\nT: O((N^2)*(2^N))  "
                    },
                    {
                        "username": "layyy",
                        "content": "passing by reference is a must in such problems"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Longest Common Subsequence is a Medium\\nLongest Palindromic Subsequence is a Medium, that consists of LCS\\nThis problem, that consists of LPS, is also a Medium"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Why O(2^24) code is getting accepted?"
                    },
                    {
                        "username": "Star_Drift",
                        "content": "[@kunal98p](/kunal98p) your math isn't good my friend\n"
                    },
                    {
                        "username": "kunal98p",
                        "content": "because thats just 4096. Way within the bounds."
                    },
                    {
                        "username": "Nihal_S",
                        "content": "no it isn\\'t"
                    }
                ]
            }
        ]
    }
]