[
    {
        "title": "Maximum Number of Integers to Choose From a Range I",
        "question_content": "You are given an integer array banned and two integers n and maxSum. You are choosing some number of integers following the below rules:\n\n\tThe chosen integers have to be in the range [1, n].\n\tEach integer can be chosen at most once.\n\tThe chosen integers should not be in the array banned.\n\tThe sum of the chosen integers should not exceed maxSum.\n\nReturn the maximum number of integers you can choose following the mentioned rules.\n&nbsp;\nExample 1:\n\nInput: banned = [1,6,5], n = 5, maxSum = 6\nOutput: 2\nExplanation: You can choose the integers 2 and 4.\n2 and 4 are from the range [1, 5], both did not appear in banned, and their sum is 6, which did not exceed maxSum.\n\nExample 2:\n\nInput: banned = [1,2,3,4,5,6,7], n = 8, maxSum = 1\nOutput: 0\nExplanation: You cannot choose any integer while following the mentioned conditions.\n\nExample 3:\n\nInput: banned = [11], n = 7, maxSum = 50\nOutput: 7\nExplanation: You can choose the integers 1, 2, 3, 4, 5, 6, and 7.\nThey are from the range [1, 7], all did not appear in banned, and their sum is 28, which did not exceed maxSum.\n\n&nbsp;\nConstraints:\n\n\t1 <= banned.length <= 104\n\t1 <= banned[i], n <= 104\n\t1 <= maxSum <= 109",
        "solutions": [
            {
                "id": 3141612,
                "title": "with-without-unorderder-explained",
                "content": "\\n# Approach 1: O(N) space, O(N) time\\nSimply put all banned items into a unordered set and then \\nstrat from 1 to check each values present in set or not if not \\nthen count it and add it to sum.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        int ans = 0;\\n        unordered_set<int> s(begin(banned), end(banned));\\n        for(int i = 1; i <= n; ++i){\\n            if(s.find(i) == s.end() && maxSum - i >= 0) { ans++; maxSum -= i; }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Approach 2: O(1) space, O(NlogN) time\\n\\nHere we sort the banned array, and then iterate over i = 1.\\nif i < banned[j], then consider it and increment the count.\\nif i >= banned[j] then keep incrementing j until i < banned[j]\\n\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        sort(banned.begin(), banned.end());\\n        int ans = 0;\\n        for(int i = 1, j = 0; i <= n; ++i){\\n            if((j == banned.size() || i < banned[j] ) && maxSum- i >= 0) { \\n                ans++; maxSum -= i; \\n            }else{\\n                while(j < banned.size() && i >= banned[j]) j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n\\nHere is an article of my recent interview experience at Amazon, you may like : \\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        int ans = 0;\\n        unordered_set<int> s(begin(banned), end(banned));\\n        for(int i = 1; i <= n; ++i){\\n            if(s.find(i) == s.end() && maxSum - i >= 0) { ans++; maxSum -= i; }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        sort(banned.begin(), banned.end());\\n        int ans = 0;\\n        for(int i = 1, j = 0; i <= n; ++i){\\n            if((j == banned.size() || i < banned[j] ) && maxSum- i >= 0) { \\n                ans++; maxSum -= i; \\n            }else{\\n                while(j < banned.size() && i >= banned[j]) j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141704,
                "title": "java-hashset-single-loop-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int ele : banned){\\n            set.add(ele);\\n        }\\n        \\n        int count = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if (set.contains(i))\\n                continue;\\n            if (i <= maxSum) {\\n                count++;\\n                maxSum -= i;\\n            } else {\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/beec0cb1-8645-4e53-96d7-4ae7787555a5_1675528914.8029478.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int ele : banned){\\n            set.add(ele);\\n        }\\n        \\n        int count = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if (set.contains(i))\\n                continue;\\n            if (i <= maxSum) {\\n                count++;\\n                maxSum -= i;\\n            } else {\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141484,
                "title": "c-easy-set-logic",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        int maxi = 0;\\n        int sum = 0;\\n        \\n        // store banned indexes\\n        set<int> st;\\n        for( auto &it : banned ) st.insert( it );\\n        \\n        for( int i=1 ; i<=n ; i++ ){\\n            \\n            // indexes wihch are not in banned array \\n            // take them, keeping the sum lesser than the maximum Sum \\n            \\n            if( st.count(i) == 0 && ((sum+i) <= maxSum )) {\\n                sum += i;\\n                maxi++;\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```\\n# Please Upvote If U like the Solution :D",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        int maxi = 0;\\n        int sum = 0;\\n        \\n        // store banned indexes\\n        set<int> st;\\n        for( auto &it : banned ) st.insert( it );\\n        \\n        for( int i=1 ; i<=n ; i++ ){\\n            \\n            // indexes wihch are not in banned array \\n            // take them, keeping the sum lesser than the maximum Sum \\n            \\n            if( st.count(i) == 0 && ((sum+i) <= maxSum )) {\\n                sum += i;\\n                maxi++;\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142646,
                "title": "c-2-different-approaches-w-some-variants-fast-138ms-100",
                "content": "**TODO(heder): Insert cute meme to ask for up-votes. ;)**\\n\\n# Approach 1: use a set and sweep\\n\\nThe approach for the following variants is always the same. We the list of banned\\nnumbers into a data structure that\\'s faster to access and then we sweep the numbers\\nfrom 1 to n while the sum is blow `maxSum`.\\n\\n## Variant 1: std::set (525 ms)\\n\\nWe can directly construct the set from the input vector.\\n\\n```cpp\\n    static int maxCount(const vector<int>& banned_vector, const int n, const int maxSum) {\\n        set<int> banned(begin(banned_vector), end(banned_vector));\\n        \\n        int sum = 0;\\n        int ans = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if (sum + i > maxSum) break;\\n            \\n            if (banned.count(i)) continue;\\n            \\n            sum += i;\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n```\\n\\n## Variant 2: std::set, only insert numbers <= n (329 ms)\\n\\nNot inserting all the numbers yields a nice speedup.\\n\\n```cpp\\n    static int maxCount(const vector<int>& banned_vector, const int n, const int maxSum) {\\n        set<int> banned;\\n        for (int b : banned_vector)\\n            if (b <= n) banned.insert(b);\\n        \\n        int sum = 0;\\n        int ans = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if (sum + i > maxSum) break;\\n            \\n            if (banned.count(i)) continue;\\n            \\n            sum += i;\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n```\\n\\n## Variant 3: std::unordered_set (253 ms)\\n\\nUsing a hash set instead of an ordered set yields and anther nice speedup.\\n\\n```cpp\\n    static int maxCount(const vector<int>& banned_vector, const int n, const int maxSum) {\\n        unordered_set<int> banned;\\n        for (int b : banned_vector)\\n            if (b <= n) banned.insert(b);\\n        \\n        int sum = 0;\\n        int ans = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if (sum + i > maxSum) break;\\n            \\n            if (banned.count(i)) continue;\\n            \\n            sum += i;\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n```\\n\\n## Variant 4: set::bitset (138 ms)\\n\\nThe number range in the ```banned``` vector is quite limited, so we can use a ```std::bitset``` instead of a hash set, which gives us a nice speedup as well.\\n\\n```cpp\\n    static int maxCount(const vector<int>& banned_vector, const int n, const int maxSum) {\\n        bitset<10240> banned;\\n        for (int b : banned_vector)\\n            if (b <= n) banned[b] = true;\\n        \\n        int sum = 0;\\n        int ans = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if (sum + i > maxSum) break;\\n            \\n            if (banned[i]) continue;\\n            \\n            sum += i;\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n```\\n\\n# Approach 2: sort and sweep (225ms)\\n\\nInstead of using an extra set we can sort the banned vector so we can sweep it easily too. The sweep code feels bit clumbsy, please let me know if you have a nicer approach.\\n\\n```cpp\\n    static int maxCount(vector<int>& banned, const int n, const int maxSum) {\\n        sort(begin(banned), end(banned));\\n        \\n        int sum = 0;\\n        int ans = 0;\\n        int b = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if (sum + i > maxSum) break;\\n            \\n            if (b < size(banned)) {\\n                while (b < size(banned) && banned[b] < i) ++b;\\n                \\n                if (b < size(banned) && banned[b] == i) continue;\\n            }\\n            \\n            sum += i;\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n```\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    static int maxCount(const vector<int>& banned_vector, const int n, const int maxSum) {\\n        set<int> banned(begin(banned_vector), end(banned_vector));\\n        \\n        int sum = 0;\\n        int ans = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if (sum + i > maxSum) break;\\n            \\n            if (banned.count(i)) continue;\\n            \\n            sum += i;\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n```\n```cpp\\n    static int maxCount(const vector<int>& banned_vector, const int n, const int maxSum) {\\n        set<int> banned;\\n        for (int b : banned_vector)\\n            if (b <= n) banned.insert(b);\\n        \\n        int sum = 0;\\n        int ans = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if (sum + i > maxSum) break;\\n            \\n            if (banned.count(i)) continue;\\n            \\n            sum += i;\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n```\n```cpp\\n    static int maxCount(const vector<int>& banned_vector, const int n, const int maxSum) {\\n        unordered_set<int> banned;\\n        for (int b : banned_vector)\\n            if (b <= n) banned.insert(b);\\n        \\n        int sum = 0;\\n        int ans = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if (sum + i > maxSum) break;\\n            \\n            if (banned.count(i)) continue;\\n            \\n            sum += i;\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n```\n```banned```\n```std::bitset```\n```cpp\\n    static int maxCount(const vector<int>& banned_vector, const int n, const int maxSum) {\\n        bitset<10240> banned;\\n        for (int b : banned_vector)\\n            if (b <= n) banned[b] = true;\\n        \\n        int sum = 0;\\n        int ans = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if (sum + i > maxSum) break;\\n            \\n            if (banned[i]) continue;\\n            \\n            sum += i;\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n```\n```cpp\\n    static int maxCount(vector<int>& banned, const int n, const int maxSum) {\\n        sort(begin(banned), end(banned));\\n        \\n        int sum = 0;\\n        int ans = 0;\\n        int b = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if (sum + i > maxSum) break;\\n            \\n            if (b < size(banned)) {\\n                while (b < size(banned) && banned[b] < i) ++b;\\n                \\n                if (b < size(banned) && banned[b] == i) continue;\\n            }\\n            \\n            sum += i;\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3141761,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\n\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [YouTube Channel](https://www.youtube.com/@leetcodethehardway) if you are interested.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        // put all banned elements to a set\\n        set<int> s(banned.begin(), banned.end());\\n        int sum = 0, ans = 0;\\n        // try each possible number (rule #1 & #2)\\n        for (int i = 1; i <= n; i++) {\\n            // if the number `i` is banned, then we skip it (rule #3)\\n            if (s.count(i)) continue;\\n            // we can include this number as long as it doesn\\'t exceed `maxSum` (rule #4)\\n            if (sum + i > maxSum) break;\\n            // add to current sum\\n            sum += i;\\n            // increase ans by 1 as we choose number `i`\\n            ans += 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        // put all banned elements to a set\\n        set<int> s(banned.begin(), banned.end());\\n        int sum = 0, ans = 0;\\n        // try each possible number (rule #1 & #2)\\n        for (int i = 1; i <= n; i++) {\\n            // if the number `i` is banned, then we skip it (rule #3)\\n            if (s.count(i)) continue;\\n            // we can include this number as long as it doesn\\'t exceed `maxSum` (rule #4)\\n            if (sum + i > maxSum) break;\\n            // add to current sum\\n            sum += i;\\n            // increase ans by 1 as we choose number `i`\\n            ans += 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154509,
                "title": "partial-sum-binary-search",
                "content": "## Partial Sum + Binary Search\\nWe compute sum of elements `[`1..m]` excluding banned elements. \\n\\nWe can do it in a constant time if we build a prefix sum of banned elements.\\n\\nWe binary-search for the largest m, which sum <= maxSum.\\n\\n**C++**\\n```cpp\\nint maxCount(vector<int>& ban, int n, int maxSum) {\\n    int ps[10001] = {}, l = 0, r = n, cnt = 0;\\n    for (int b : ban)\\n        ps[b] = b;\\n    partial_sum(begin(ps), end(ps), begin(ps));\\n    while (l < r) {\\n        if (int m = (l + r + 1) / 2; m * (m + 1) / 2 - ps[m] > maxSum)\\n            r = m - 1;            \\n        else\\n            l = m;\\n    }\\n    for (int i = 0; i < l; ++i)\\n        cnt += ps[i] != ps[i + 1];\\n    return l - cnt;\\n}\\n```\\n## Hashset\\nThis solution is simpler, and asymptotically faster (O(n)) than the next one.\\n\\nFor OJ test cases, however, it is twice as slow as the second one, due to a hash set overhead.\\n\\n**C++**\\n```cpp\\nint maxCount(vector<int>& banned, int n, int maxSum) {\\n    int res = 0;\\n    unordered_set<int> s(begin(banned), end(banned));\\n    for (int x = 1; x <= n && maxSum >= 0; ++x) \\n        if (s.count(x) == 0) {\\n            maxSum -= x;\\n            res += maxSum >= 0;\\n        }\\n    return res;\\n}\\n```\\n## Pointer\\nWe sort the banned array, and, as we increase `x`, use a pointer `i` to check if a number is there.\\n\\nNote tha the array can contain duplicates, so we need to skip all of them. \\n\\n**C++**\\n```cpp\\nint maxCount(vector<int>& ban, int n, int maxSum) {\\n    int i = 0, res = 0;\\n    sort(begin(ban), end(ban));\\n    for (int x = 1; x <= n && maxSum >= 0; ++x) {\\n        if (i < ban.size() && ban[i] == x)\\n            while (i < ban.size() && ban[i] == x)\\n                ++i;\\n        else {\\n            maxSum -= x;\\n            res += maxSum >= 0;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint maxCount(vector<int>& ban, int n, int maxSum) {\\n    int ps[10001] = {}, l = 0, r = n, cnt = 0;\\n    for (int b : ban)\\n        ps[b] = b;\\n    partial_sum(begin(ps), end(ps), begin(ps));\\n    while (l < r) {\\n        if (int m = (l + r + 1) / 2; m * (m + 1) / 2 - ps[m] > maxSum)\\n            r = m - 1;            \\n        else\\n            l = m;\\n    }\\n    for (int i = 0; i < l; ++i)\\n        cnt += ps[i] != ps[i + 1];\\n    return l - cnt;\\n}\\n```\n```cpp\\nint maxCount(vector<int>& banned, int n, int maxSum) {\\n    int res = 0;\\n    unordered_set<int> s(begin(banned), end(banned));\\n    for (int x = 1; x <= n && maxSum >= 0; ++x) \\n        if (s.count(x) == 0) {\\n            maxSum -= x;\\n            res += maxSum >= 0;\\n        }\\n    return res;\\n}\\n```\n```cpp\\nint maxCount(vector<int>& ban, int n, int maxSum) {\\n    int i = 0, res = 0;\\n    sort(begin(ban), end(ban));\\n    for (int x = 1; x <= n && maxSum >= 0; ++x) {\\n        if (i < ban.size() && ban[i] == x)\\n            while (i < ban.size() && ban[i] == x)\\n                ++i;\\n        else {\\n            maxSum -= x;\\n            res += maxSum >= 0;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3141436,
                "title": "c-using-sets",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        set<int> s, s1;\\n        for(auto i: banned){\\n            s.insert(i);\\n        }\\n        \\n        for(int i=1; i<=n; i++){\\n            if(s.find(i)==s.end())\\n                s1.insert(i);\\n        }\\n        for(auto i: s1){\\n            cout << i << \" \";\\n        }\\n        cout << endl;\\n        int sum = 0, count = 0;\\n        for(auto i: s1){\\n            sum+= i;\\n            if(sum>maxSum){\\n                sum-= i;\\n                continue;\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        set<int> s, s1;\\n        for(auto i: banned){\\n            s.insert(i);\\n        }\\n        \\n        for(int i=1; i<=n; i++){\\n            if(s.find(i)==s.end())\\n                s1.insert(i);\\n        }\\n        for(auto i: s1){\\n            cout << i << \" \";\\n        }\\n        cout << endl;\\n        int sum = 0, count = 0;\\n        for(auto i: s1){\\n            sum+= i;\\n            if(sum>maxSum){\\n                sum-= i;\\n                continue;\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3141443,
                "title": "c-use-set-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) \\n    {\\n        unordered_set<int> ban(banned.begin(), banned.end());\\n        int cnt=0, sum = 0;\\n        for(int i=1; i<=n; i++)\\n        {\\n            if(ban.count(i)==0 and sum+i <= maxSum)\\n            {\\n                cnt++;\\n                sum += i;\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Counting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) \\n    {\\n        unordered_set<int> ban(banned.begin(), banned.end());\\n        int cnt=0, sum = 0;\\n        for(int i=1; i<=n; i++)\\n        {\\n            if(ban.count(i)==0 and sum+i <= maxSum)\\n            {\\n                cnt++;\\n                sum += i;\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282869,
                "title": "java-solution-easy-to-understand",
                "content": "Please **UPVOTE** if you do like my solution!\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i = 0;i<banned.length;i++){\\n            set.add(banned[i]);\\n        }\\n        int sum = 0;\\n        int count = 0;\\n        for(int i = 1;i<=n;i++){\\n            if(!set.contains(i)){\\n                sum += i;\\n                if(sum>maxSum){\\n                    break;\\n                }\\n                else{\\n                    count++;\\n                } \\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i = 0;i<banned.length;i++){\\n            set.add(banned[i]);\\n        }\\n        int sum = 0;\\n        int count = 0;\\n        for(int i = 1;i<=n;i++){\\n            if(!set.contains(i)){\\n                sum += i;\\n                if(sum>maxSum){\\n                    break;\\n                }\\n                else{\\n                    count++;\\n                } \\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147146,
                "title": "python-3-7-lines-brute-force-t-m-1142-ms-16-mb",
                "content": "```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n\\n        ans, banned = -1, set(banned)\\n\\n        for i in range(1,n+1):\\n            if i not in banned:\\n                maxSum-= i\\n                ans+= 1\\n\\n            if maxSum < 0: return ans\\n\\n        return ans+1\\n```\\n[https://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/submissions/892114641/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n\\n        ans, banned = -1, set(banned)\\n\\n        for i in range(1,n+1):\\n            if i not in banned:\\n                maxSum-= i\\n                ans+= 1\\n\\n            if maxSum < 0: return ans\\n\\n        return ans+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143629,
                "title": "binary-search-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort the banned array and then traverse till n and check for each i if it does not belong to banned by binary search and if it does not belong to banned increase the sum by i if and only if sum is less than maxSum and increase the count in such case by 1.\\nReturn count \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool binarySearch(vector<int>& banned,int i)\\n    {\\n        int low=0; \\n        int high=banned.size()-1;\\n        while(low<=high)\\n        {\\n           int mid=(low+high)/2;\\n            if(banned[mid]==i)\\n            {\\n                return 1;\\n             }\\n            else if(banned[mid]>i)\\n            {\\n                high=mid-1;\\n             }\\n            else\\n                low=mid+1;\\n        }\\n        return 0;\\n     }\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        int sum=0;\\n        sort(banned.begin(),banned.end());\\n            int m=banned.size();\\n        int count=0;\\n        int i=1;\\n        while(i<=n)\\n        {\\n            int t=binarySearch(banned,i);\\n                if(t==0)\\n                {\\n                    if(sum<=maxSum)\\n                    {\\n                      sum+=i;\\n                        if(sum<=maxSum)\\n                         count++;\\n                    }\\n                    else\\n                    {\\n                        break;\\n                     }\\n                 }\\n           i++;\\n       }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool binarySearch(vector<int>& banned,int i)\\n    {\\n        int low=0; \\n        int high=banned.size()-1;\\n        while(low<=high)\\n        {\\n           int mid=(low+high)/2;\\n            if(banned[mid]==i)\\n            {\\n                return 1;\\n             }\\n            else if(banned[mid]>i)\\n            {\\n                high=mid-1;\\n             }\\n            else\\n                low=mid+1;\\n        }\\n        return 0;\\n     }\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        int sum=0;\\n        sort(banned.begin(),banned.end());\\n            int m=banned.size();\\n        int count=0;\\n        int i=1;\\n        while(i<=n)\\n        {\\n            int t=binarySearch(banned,i);\\n                if(t==0)\\n                {\\n                    if(sum<=maxSum)\\n                    {\\n                      sum+=i;\\n                        if(sum<=maxSum)\\n                         count++;\\n                    }\\n                    else\\n                    {\\n                        break;\\n                     }\\n                 }\\n           i++;\\n       }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143528,
                "title": "java-using-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        int res=0;\\n        int sum=0;\\n        int a[]=new int[100001];\\n        for(int i:banned)a[i]++;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(a[i]==0&&(i+sum)<=maxSum){\\n                res++;\\n                sum+=i;\\n            }\\n        }\\n        return res;   \\n    }\\n          \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        int res=0;\\n        int sum=0;\\n        int a[]=new int[100001];\\n        for(int i:banned)a[i]++;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(a[i]==0&&(i+sum)<=maxSum){\\n                res++;\\n                sum+=i;\\n            }\\n        }\\n        return res;   \\n    }\\n          \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141853,
                "title": "best-approach-without-any-extra-space-o-nlogn-ando-1-space",
                "content": "# Intuition\\n> - please upvote if u like it \\n- first of all sort the array and find all the missing number betwwen 1 to n\\n- so run a loop and search the number b/w 1 to n\\n- by using binary search\\n- if not found in the array than sum it into the a variable and increase ur ans by 1 after checking that existing sum is less than the given max sum\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- sort thr array\\n- take 2 variable sum=0 and ans =0\\n- and run a loop from 1 to n \\n- by using binary search find the numbers \\n- if(sum+i<= maxsum) increase the ans by 1\\n- and update sum as sum+i;\\n- and at last return the ans\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        int cnt=0,sum=0;\\n        sort(banned.begin(),banned.end());\\n        for(int i=1;i<=n;i++){\\n            bool ans = binary_search(banned.begin(),banned.end(),i);\\n            if(ans) continue;\\n            else{\\n                if(sum+i<=maxSum){\\n                    cnt++;\\n                    sum+=i;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        int cnt=0,sum=0;\\n        sort(banned.begin(),banned.end());\\n        for(int i=1;i<=n;i++){\\n            bool ans = binary_search(banned.begin(),banned.end(),i);\\n            if(ans) continue;\\n            else{\\n                if(sum+i<=maxSum){\\n                    cnt++;\\n                    sum+=i;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141523,
                "title": "brute-force",
                "content": "```\\nint maxCount(vector<int>& banned, int n, int maxSum) {\\n        vector<int>ans;\\n        int sum=0;\\n        int c=0;\\n        unordered_map<int,int>m;\\n        int n1=banned.size();\\n        for(int i=0;i<n1;i++)\\n        {\\n            m[banned[i]]++;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            ans.push_back(i);\\n        }\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(m.find(ans[i])==m.end())\\n            {\\n                sum+=ans[i];\\n                if(sum<=maxSum)\\n                    c++;\\n                else\\n                    break;\\n            }\\n        }\\n       return c;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxCount(vector<int>& banned, int n, int maxSum) {\\n        vector<int>ans;\\n        int sum=0;\\n        int c=0;\\n        unordered_map<int,int>m;\\n        int n1=banned.size();\\n        for(int i=0;i<n1;i++)\\n        {\\n            m[banned[i]]++;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            ans.push_back(i);\\n        }\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(m.find(ans[i])==m.end())\\n            {\\n                sum+=ans[i];\\n                if(sum<=maxSum)\\n                    c++;\\n                else\\n                    break;\\n            }\\n        }\\n       return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3143941,
                "title": "cpp-simple-solution-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        set<int> set(banned.begin(), banned.end());\\n        int sum = 0, ans = 0;       \\n        for (int i = 1; i <= n; i++) {\\n            if (set.count(i) == 0 && maxSum >= sum + i) {\\n                sum += i;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        set<int> set(banned.begin(), banned.end());\\n        int sum = 0, ans = 0;       \\n        for (int i = 1; i <= n; i++) {\\n            if (set.count(i) == 0 && maxSum >= sum + i) {\\n                sum += i;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141880,
                "title": "easy-o-n-solution-using-set",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n) , for traversing from 1 to n.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n) , where n is the number of elements in the banned list to make set for faster access.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        st=set(banned)\\n        summ=0\\n        ans=0\\n        for i in range(1,n+1):\\n            if summ+i<=maxSum and i not in st:\\n                ans+=1\\n                summ+=i\\n        return ans\\n    \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        st=set(banned)\\n        summ=0\\n        ans=0\\n        for i in range(1,n+1):\\n            if summ+i<=maxSum and i not in st:\\n                ans+=1\\n                summ+=i\\n        return ans\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141722,
                "title": "o-n-solution-without-using-dp",
                "content": "# Intuition\\nIt\\'s not mentioned in que whether \"banned\" array contains any repeated number or not, so to be on safer side I used map for it. Also for checking presence in banned array, it takes lesser time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every number from 1-n, I checked whether it\\'s present in banned array or not using map as it comparatively lesser time (i.e, logN).\\nIf it\\'s not present and sum do not exceed maxSum, I updated count and sum.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n         //in the que it is not mentioned that \"banned\" array contains distinct elements or not so I made a map for it\\n        map<int, int> mp; \\n        int sum = 0;\\n        int count = 0;\\n        \\n        for(auto it : banned) mp[it]++;\\n        \\n        for(int i=1; i<=n; i++){\\n            //for every int from 1-n we\\'ll check whether it is in banned array or not & it\\'s sum less than maxSum or not\\n            if((mp.find(i) == mp.end()) && sum+i <= maxSum){\\n                sum += i;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n         //in the que it is not mentioned that \"banned\" array contains distinct elements or not so I made a map for it\\n        map<int, int> mp; \\n        int sum = 0;\\n        int count = 0;\\n        \\n        for(auto it : banned) mp[it]++;\\n        \\n        for(int i=1; i<=n; i++){\\n            //for every int from 1-n we\\'ll check whether it is in banned array or not & it\\'s sum less than maxSum or not\\n            if((mp.find(i) == mp.end()) && sum+i <= maxSum){\\n                sum += i;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141518,
                "title": "java-hashset-commented",
                "content": "---\\n# Please Upvote \\uD83D\\uDE07\\n---\\n``` java []\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        // create a set and all elements to the set\\n        // this will help us know what numbers are banned\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : banned) {\\n            set.add(i);\\n        }\\n        \\n        int count = 0;  // variable to store our answer\\n        for (int i = 1; i <= n; i++) {\\n            // if number is in set, means its banned, therefore skip\\n            if (set.contains(i)) {\\n                continue; \\n            }\\n            // i can be counted in if its less than \\'maxSum\\'\\n            if (i <= maxSum) {\\n                count++;      // increment count\\n                maxSum -= i;  // subtract i from maxSum (doing a + b = c is same as a = c - b)\\n            } \\n            // otherwise break out, because we don\\'t want to check further\\n            // the smaller numbers we count in, the greater the value of \\'count\\' is going to be\\n            else {    \\n                break;\\n            }            \\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n---\\n#### Clean solution:\\n``` java []\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : banned) {\\n            set.add(i);\\n        }\\n\\n        int count = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if (set.contains(i)) {\\n                continue;\\n            }\\n            if (i <= maxSum) {\\n                count++;\\n                maxSum -= i;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```\\n---\\nLet $$k$$ be the size of the array `banned`.\\n##### Time complexity: $$O(k + n)$$\\n##### Space complexity: $$O(k)$$",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        // create a set and all elements to the set\\n        // this will help us know what numbers are banned\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : banned) {\\n            set.add(i);\\n        }\\n        \\n        int count = 0;  // variable to store our answer\\n        for (int i = 1; i <= n; i++) {\\n            // if number is in set, means its banned, therefore skip\\n            if (set.contains(i)) {\\n                continue; \\n            }\\n            // i can be counted in if its less than \\'maxSum\\'\\n            if (i <= maxSum) {\\n                count++;      // increment count\\n                maxSum -= i;  // subtract i from maxSum (doing a + b = c is same as a = c - b)\\n            } \\n            // otherwise break out, because we don\\'t want to check further\\n            // the smaller numbers we count in, the greater the value of \\'count\\' is going to be\\n            else {    \\n                break;\\n            }            \\n        }\\n        \\n        return count;\\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : banned) {\\n            set.add(i);\\n        }\\n\\n        int count = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if (set.contains(i)) {\\n                continue;\\n            }\\n            if (i <= maxSum) {\\n                count++;\\n                maxSum -= i;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141476,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def maxCount(self, banned, n, maxSum):\\n        banned = set(banned)\\n        res, sum_, curr = 0, 0, 1\\n        while curr <= n:\\n            if curr not in banned:\\n                if sum_ + curr <= maxSum:\\n                    res += 1\\n                    sum_ += curr\\n                else: break\\n            curr += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxCount(self, banned, n, maxSum):\\n        banned = set(banned)\\n        res, sum_, curr = 0, 0, 1\\n        while curr <= n:\\n            if curr not in banned:\\n                if sum_ + curr <= maxSum:\\n                    res += 1\\n                    sum_ += curr\\n                else: break\\n            curr += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141470,
                "title": "easy-python-solution-sort",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int: \\n        all_arr = [i for i in range(1, n+1)]\\n        res = list(set(all_arr) - set(banned))\\n        res.sort()\\n        currSum = sum(res)\\n        ans = len(res)\\n        while currSum > maxSum:\\n            currSum -= res.pop()\\n            ans -= 1\\n        return ans\\n              \\n```\\nDo upvote if you like the Solution :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int: \\n        all_arr = [i for i in range(1, n+1)]\\n        res = list(set(all_arr) - set(banned))\\n        res.sort()\\n        currSum = sum(res)\\n        ans = len(res)\\n        while currSum > maxSum:\\n            currSum -= res.pop()\\n            ans -= 1\\n        return ans\\n              \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249162,
                "title": "c-solution-simple-sorting",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int maxCount(vector<int> &b, int n, int maxSum)\\n        {\\n            int cnt = 0;\\n            int sum = 0;\\n            int i = 0;\\n            sort(b.begin(), b.end());\\n            for (int val = 1; val <= n; val++)\\n            {\\n                if (i < b.size() and val == b[i])\\n                    while (i < b.size() and val == b[i])\\n                        i++;\\n                else\\n                {\\n                    if (val + sum <= maxSum)\\n                    {\\n                        cnt++;\\n                        sum += val;\\n                    }\\n                    else return cnt;\\n                }\\n            }\\n            return cnt;\\n        }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int maxCount(vector<int> &b, int n, int maxSum)\\n        {\\n            int cnt = 0;\\n            int sum = 0;\\n            int i = 0;\\n            sort(b.begin(), b.end());\\n            for (int val = 1; val <= n; val++)\\n            {\\n                if (i < b.size() and val == b[i])\\n                    while (i < b.size() and val == b[i])\\n                        i++;\\n                else\\n                {\\n                    if (val + sum <= maxSum)\\n                    {\\n                        cnt++;\\n                        sum += val;\\n                    }\\n                    else return cnt;\\n                }\\n            }\\n            return cnt;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200292,
                "title": "c-time-o-nlogn-space-1-time-space-90-98-beats",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        sort(banned.begin(),banned.end());\\n        int i=0,x=0,m = banned.size(),ans=0,y=0;\\n        for(x = 1; x <= n; x++){\\n            if(i<m&&x==banned[i]){\\n                while(i<m&&x==banned[i]){\\n                    i++;\\n                }\\n            }else{\\n                y += x;\\n                if(y<=maxSum){\\n                    ans++;\\n                }else\\n                    break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        sort(banned.begin(),banned.end());\\n        int i=0,x=0,m = banned.size(),ans=0,y=0;\\n        for(x = 1; x <= n; x++){\\n            if(i<m&&x==banned[i]){\\n                while(i<m&&x==banned[i]){\\n                    i++;\\n                }\\n            }else{\\n                y += x;\\n                if(y<=maxSum){\\n                    ans++;\\n                }else\\n                    break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141897,
                "title": "java-easy-to-understand-intuitive-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        HashSet<Integer> set = new HashSet<>();\\n//         for each loop to avoid error \\n        for (int i : banned) {\\n            set.add(i);\\n             }\\n        int answer = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if (!set.contains(i) ){\\n            if( i <= maxSum){\\n                answer++;\\n                maxSum = maxSum - i;\\n            }\\n        }\\n    }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        HashSet<Integer> set = new HashSet<>();\\n//         for each loop to avoid error \\n        for (int i : banned) {\\n            set.add(i);\\n             }\\n        int answer = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if (!set.contains(i) ){\\n            if( i <= maxSum){\\n                answer++;\\n                maxSum = maxSum - i;\\n            }\\n        }\\n    }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141810,
                "title": "java-most-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        Set<Integer>set=new HashSet<>();\\n        for(int i=0;i<banned.length;i++){\\n            set.add(banned[i]);\\n        }\\n        int j=0;\\n        int count=0;\\n        int sum=0;\\n        \\n        for(int i=1;i<=n;i++){\\n            if(!set.contains(i)){\\n                count++;\\n                sum+=i;\\n                //if(sum==maxSum) return count; \\n                if(sum>maxSum)  return count-1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        Set<Integer>set=new HashSet<>();\\n        for(int i=0;i<banned.length;i++){\\n            set.add(banned[i]);\\n        }\\n        int j=0;\\n        int count=0;\\n        int sum=0;\\n        \\n        for(int i=1;i<=n;i++){\\n            if(!set.contains(i)){\\n                count++;\\n                sum+=i;\\n                //if(sum==maxSum) return count; \\n                if(sum>maxSum)  return count-1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141766,
                "title": "c-easy-and-simple-solution-using-hash-map",
                "content": "\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        int count=0;\\n        unordered_map<int,int>mapping;\\n        for(auto i : banned){\\n            mapping[i]++;\\n        }\\n        \\n        long long sum=0;\\n        for(int i=1;i<=n;i++){\\n            if(mapping.find(i)==mapping.end()){\\n                count++;\\n                sum+=i;\\n            }\\n            if(sum>maxSum) return count-1;\\n            \\n            \\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        int count=0;\\n        unordered_map<int,int>mapping;\\n        for(auto i : banned){\\n            mapping[i]++;\\n        }\\n        \\n        long long sum=0;\\n        for(int i=1;i<=n;i++){\\n            if(mapping.find(i)==mapping.end()){\\n                count++;\\n                sum+=i;\\n            }\\n            if(sum>maxSum) return count-1;\\n            \\n            \\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141753,
                "title": "easy-c-explained-using-set",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Store the numbers from 1 to n in a vector nums.\\n- Store all the banned numbers in a set.\\n- Initialise sum and with 0.\\n- Check if the number is not banned.\\n- If it is not banned, check if(Sum + number <= Maximum Sum)\\nAdd the number if the above case is true and increment count, otherwise break. Return count at the end of the loop. \\n- Logic behind this break is that nums is sorted array.\\nExample: (78+15>90), Then (78+16) will also be greater than 90.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        vector<int> nums;\\n        long long sum=0;\\n        int count=0;\\n\\n        for(int i=1;i<=n;i++){\\n            nums.push_back(i);//storing the numbers from [1,n]\\n        }\\n        unordered_set<int> ban(banned.begin(),banned.end());//storing banned numbers in set\\n        for(int i=0;i<nums.size();i++){\\n            if(ban.find(nums[i])!=ban.end())continue;//if the number is banned\\n\\n            if(sum+nums[i]<=maxSum){//If we can add the number to sum and still it will be less than or equal to maxSum\\n                sum+=nums[i];\\n                count++;//Increment count as the number is used\\n            }\\n            else break;//If the sum exceeds max sum at any stage\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        vector<int> nums;\\n        long long sum=0;\\n        int count=0;\\n\\n        for(int i=1;i<=n;i++){\\n            nums.push_back(i);//storing the numbers from [1,n]\\n        }\\n        unordered_set<int> ban(banned.begin(),banned.end());//storing banned numbers in set\\n        for(int i=0;i<nums.size();i++){\\n            if(ban.find(nums[i])!=ban.end())continue;//if the number is banned\\n\\n            if(sum+nums[i]<=maxSum){//If we can add the number to sum and still it will be less than or equal to maxSum\\n                sum+=nums[i];\\n                count++;//Increment count as the number is used\\n            }\\n            else break;//If the sum exceeds max sum at any stage\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141515,
                "title": "c-easy-to-understand-set",
                "content": "> If you helpe, Please Upvote !!\\n\\n### Complexity\\n- Time complexity: $$O(n*logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        set<int> s;\\n        for(int n : banned) s.insert(n);\\n        \\n        int sum = 0, ans = 0;\\n        for(int i = 1; i <= n; i++) {\\n            if(!s.count(i) && sum + i <= maxSum) {\\n                ans++;\\n                sum += i;\\n            }\\n            else if(!s.count(i) && sum + i > maxSum) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        set<int> s;\\n        for(int n : banned) s.insert(n);\\n        \\n        int sum = 0, ans = 0;\\n        for(int i = 1; i <= n; i++) {\\n            if(!s.count(i) && sum + i <= maxSum) {\\n                ans++;\\n                sum += i;\\n            }\\n            else if(!s.count(i) && sum + i > maxSum) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141485,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>&ban, int n, int mx) {\\n        int ans=0, sum=0;\\n        unordered_set<int>ust(begin(ban), end(ban));\\n        for(int i=1;i<=n;++i){\\n            if(ust.find(i)!=end(ust)){\\n                continue;\\n            }\\n            if(sum+i>mx){\\n                break;\\n            }\\n            sum+=i, ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>&ban, int n, int mx) {\\n        int ans=0, sum=0;\\n        unordered_set<int>ust(begin(ban), end(ban));\\n        for(int i=1;i<=n;++i){\\n            if(ust.find(i)!=end(ust)){\\n                continue;\\n            }\\n            if(sum+i>mx){\\n                break;\\n            }\\n            sum+=i, ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045510,
                "title": "easy-c-solution-beginner-s-friendly-full-explanation",
                "content": "# Intuition\\nCan be done easily with the help of map.\\n\\n# Approach\\nStore the number with frequency in map. So that it would be easy to iterate the map and to find also.\\n\\n- Check each number starting from 1 whether the number is present in banned vector or not. If not then add that number and subsequently check the sum, that should not exceed with maxSum.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    \\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        map<int,int> m;\\n\\n        for(int i=0;i<banned.size();i++){\\n            m[banned[i]]++;\\n        }\\n\\n        int i =1;\\n        int sum=0;\\n        int cnt=0;\\n\\n        while(i<=n){\\n            if(m.find(i)==m.end()  && sum<=maxSum){\\n                sum+=i;\\n                cnt++;\\n\\n                if(sum>maxSum){\\n                    return cnt-1;\\n                }\\n            }\\n            i++;\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        map<int,int> m;\\n\\n        for(int i=0;i<banned.size();i++){\\n            m[banned[i]]++;\\n        }\\n\\n        int i =1;\\n        int sum=0;\\n        int cnt=0;\\n\\n        while(i<=n){\\n            if(m.find(i)==m.end()  && sum<=maxSum){\\n                sum+=i;\\n                cnt++;\\n\\n                if(sum>maxSum){\\n                    return cnt-1;\\n                }\\n            }\\n            i++;\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829217,
                "title": "python-3-brute-force",
                "content": "```python3 []\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        res, s, b = 0, 0, set(banned)\\n        for i in range(1, n+1):\\n            if s + i > maxSum: break\\n            if i not in b:\\n                s += i\\n                res += 1\\n\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        res, s, b = 0, 0, set(banned)\\n        for i in range(1, n+1):\\n            if s + i > maxSum: break\\n            if i not in b:\\n                s += i\\n                res += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464396,
                "title": "interview-solution-o-n-linear-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        unordered_map<int,int> mp;\\n\\n        for(int i=0;i<banned.size();i++){\\n            mp[banned[i]]++;\\n        }\\n        int count = 0;\\n        int totalsum=0;\\n\\n        for(int i=1;i<=n;i++){\\n\\n            if(mp.find(i)==mp.end()){\\n                totalsum+=i;\\n\\n                if(totalsum<=maxSum) count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        unordered_map<int,int> mp;\\n\\n        for(int i=0;i<banned.size();i++){\\n            mp[banned[i]]++;\\n        }\\n        int count = 0;\\n        int totalsum=0;\\n\\n        for(int i=1;i<=n;i++){\\n\\n            if(mp.find(i)==mp.end()){\\n                totalsum+=i;\\n\\n                if(totalsum<=maxSum) count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340593,
                "title": "java-easiest-solution-you-will-ever-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/bfae0867-a2e9-46fd-a802-cdd36cf2f897_1679763680.3311183.png)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n\\n        // Create a HashSet of banned integers for fast lookup\\n        Set<Integer> banSet = new HashSet<>();\\n        for (int num : banned) {\\n            banSet.add(num);\\n        }\\n\\n        // Initialize count and sum to 0\\n        int count = 0;\\n        int sum = 0;\\n\\n        // Iterate over the range [1, n]\\n        for (int i = 1; i <= n; i++) {\\n\\n            // Check if the current integer is not banned and adding it to sum does not exceed maxSum\\n            if (!banSet.contains(i) && (sum + i <= maxSum)) {\\n            // Increment count and add the current integer to sum\\n                count++;\\n                sum += i;\\n            }\\n        }\\n    // Return the maximum count of chosen integers\\n    return count;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n\\n        // Create a HashSet of banned integers for fast lookup\\n        Set<Integer> banSet = new HashSet<>();\\n        for (int num : banned) {\\n            banSet.add(num);\\n        }\\n\\n        // Initialize count and sum to 0\\n        int count = 0;\\n        int sum = 0;\\n\\n        // Iterate over the range [1, n]\\n        for (int i = 1; i <= n; i++) {\\n\\n            // Check if the current integer is not banned and adding it to sum does not exceed maxSum\\n            if (!banSet.contains(i) && (sum + i <= maxSum)) {\\n            // Increment count and add the current integer to sum\\n                count++;\\n                sum += i;\\n            }\\n        }\\n    // Return the maximum count of chosen integers\\n    return count;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301735,
                "title": "c-4-lines-90-faster-easy",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum, int res = 0) {\\n        unordered_set<int> banned_set(banned.begin(), banned.end());\\n        for (int i = 1, sum = 0; i <= n; i++) {\\n            if (banned_set.count(i)) continue;\\n            sum += i;\\n            if (sum <= maxSum) res++; else break;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum, int res = 0) {\\n        unordered_set<int> banned_set(banned.begin(), banned.end());\\n        for (int i = 1, sum = 0; i <= n; i++) {\\n            if (banned_set.count(i)) continue;\\n            sum += i;\\n            if (sum <= maxSum) res++; else break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300606,
                "title": "javascript-98-o-n-time-o-n-space-binary-search-and-hashset",
                "content": "![image.png](https://assets.leetcode.com/users/images/d222f045-ab85-4860-9b69-736e6649bc40_1678875831.892652.png)\\n\\n# Approach\\n\\n### Hash Set\\nCheck all numbers between $$1$$ and $$n$$ until their sum exceeds `maxSum`. For faster lookup through `banned`, store it in a HashSet.\\n\\n```\\nfunction maxCount(banned, n, maxSum) {\\n    banned = new Set(banned);\\n\\n    let cnt = 0;\\n\\n    for (let i = 1; i <= n; i++) {\\n        if (banned.has(i)) continue;\\n        if (maxSum < i) continue;\\n\\n        maxSum -= i;\\n        cnt++;\\n    }\\n\\n    return cnt;\\n};\\n```\\n\\n### Binary search\\n\\nPrevious approach can be optimized by iterating between $$1$$ and $$n$$ with binary search instead of checking every value.\\n\\nTo make this work, we need to build on a few things.\\n\\n1. The sum of numbers in the range $$[1, n]$$ can be computed in a single operation and equals $$n * (n + 1) / 2$$.\\n2. The sum of numbers in the range $$[1, n]$$, excluding the `banned` numbers can also be computed in a single operation if we pre-build the prefix sum table of it. E.g. sum of $$[1, 7]$$ equals $$7 * 8 / 2 - prefixSum[7]$$, where `prefixSum[7]` equals to the sum of all $$n$$ in `banned` wheren $$n <= 7$$.\\n3. We can use binary search to find $$x$$ the range $$[1, n]$$, such that `x * (x + 1) / 2 - prefixSum[x] <= maxSum` and `x` is maximized.\\n4. The number of non-banned numbers in the range $$[1, x]$$ would be x minus the number of banned numbers smaller or equal to $$x$$, which, if we sorted the `banned` array, can be deducted from the index of the greatest banned element smaller or equal to $$x$$.\\n\\nIn the solution below I build a small prefix sum array of `banned` and do another binary search on it. Alternatively, you can bind an array that contains the prefix sum of all banned numbers in the $$[1, 10^4]$$ range and find it just by the index (trading memory for speed).\\n\\n```\\nfunction maxCount(banned, n, maxSum) {\\n    // Remove duplicates\\n    banned = [...new Set(banned)];\\n    // Sort in ascending order\\n    banned.sort((a, b) => a - b);\\n    // Compute the prefix sum of banned\\n    const prefixSum = getPrefixSum(banned);\\n\\n    let cnt = 0;\\n    let left = 1;\\n    let right = n + 1;\\n\\n    // Binary search in the range 1 to n\\n    while (left < right) {\\n        const pivot = (left + right) >> 1;\\n\\n        // Find index of the greatest banned number smaller or equal to pivot\\n        const index = binarySearch(banned, pivot);\\n        // Get the sum of banned numbers smaller or equal to prefix\\n        const bannedSum = prefixSum[index] ?? 0;\\n\\n        // sum of all numbers in the range [1, n], excluding banned numbers\\n        const sum = pivot * (pivot + 1) / 2 - bannedSum;\\n\\n        if (sum > maxSum) {\\n            right = pivot;\\n        } else {\\n            cnt = pivot - index - 1;\\n            left = pivot + 1;\\n        }\\n    }\\n\\n    return cnt;\\n};\\n\\nfunction binarySearch(arr, val) {\\n    let left = 0;\\n    let right = arr.length;\\n\\n    while (left < right) {\\n        const pivot = (left + right) >> 1;\\n\\n        if (arr[pivot] === val) return pivot;\\n\\n        if (arr[pivot] > val) {\\n            right = pivot;\\n        } else {\\n            left = pivot + 1;\\n        }\\n    }\\n\\n    return left - 1;\\n}\\n\\nfunction getPrefixSum(arr) {\\n    const result = new Array(arr.length);\\n    result[0] = arr[0];\\n\\n    for (let i = 1; i in arr; i++) {\\n        result[i] = result[i - 1] + arr[i];\\n    }\\n\\n    return result;\\n}\\n```\\n\\nNote however that sorting `banned` is done in $$O(b)$$ time | $$O(b)$$ space with bucket sort, or $$O(b log b)$$ time | $$O(1)$$ space with quicksort, computing its prefix sum in $$O(b)$$ time and $$O(b)$$ space and performing the binary search itself in $$O(logn * log b)$$. Despite the fact that we lowered the implication of $$n$$ on the runtime (from $$O(n)$$ to $$O(log n)$$), we have to traverse `banned` more times.\\nOverall, given the range of `banned` and `n` is just $$[1, 10^4]$$, this approach ends up being quite a bit slower than the previous one. It would make much more sense if the range of $$n$$ was larger.\\n\\n# Complexity\\n\\n### With HashSet\\n\\n- Time complexity: $$O(b + n)$$ where $$b$$ is the size of `banned` and $$n$$ is `n`\\n\\n- Space complexity: $$O(b)$$\\n\\n### With Binary search\\n\\n- Time complexity: $$O(b log b + log b * log n)$$\\n\\n- Space complexity: $$O(b)$$\\n\\n*\\\\* we can also reduce time complexity to just O(b + log n) by using bucket/radix sort, and a full-sized prefix sum table, therefore increasing the space requirements to O(10000)*",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nfunction maxCount(banned, n, maxSum) {\\n    banned = new Set(banned);\\n\\n    let cnt = 0;\\n\\n    for (let i = 1; i <= n; i++) {\\n        if (banned.has(i)) continue;\\n        if (maxSum < i) continue;\\n\\n        maxSum -= i;\\n        cnt++;\\n    }\\n\\n    return cnt;\\n};\\n```\n```\\nfunction maxCount(banned, n, maxSum) {\\n    // Remove duplicates\\n    banned = [...new Set(banned)];\\n    // Sort in ascending order\\n    banned.sort((a, b) => a - b);\\n    // Compute the prefix sum of banned\\n    const prefixSum = getPrefixSum(banned);\\n\\n    let cnt = 0;\\n    let left = 1;\\n    let right = n + 1;\\n\\n    // Binary search in the range 1 to n\\n    while (left < right) {\\n        const pivot = (left + right) >> 1;\\n\\n        // Find index of the greatest banned number smaller or equal to pivot\\n        const index = binarySearch(banned, pivot);\\n        // Get the sum of banned numbers smaller or equal to prefix\\n        const bannedSum = prefixSum[index] ?? 0;\\n\\n        // sum of all numbers in the range [1, n], excluding banned numbers\\n        const sum = pivot * (pivot + 1) / 2 - bannedSum;\\n\\n        if (sum > maxSum) {\\n            right = pivot;\\n        } else {\\n            cnt = pivot - index - 1;\\n            left = pivot + 1;\\n        }\\n    }\\n\\n    return cnt;\\n};\\n\\nfunction binarySearch(arr, val) {\\n    let left = 0;\\n    let right = arr.length;\\n\\n    while (left < right) {\\n        const pivot = (left + right) >> 1;\\n\\n        if (arr[pivot] === val) return pivot;\\n\\n        if (arr[pivot] > val) {\\n            right = pivot;\\n        } else {\\n            left = pivot + 1;\\n        }\\n    }\\n\\n    return left - 1;\\n}\\n\\nfunction getPrefixSum(arr) {\\n    const result = new Array(arr.length);\\n    result[0] = arr[0];\\n\\n    for (let i = 1; i in arr; i++) {\\n        result[i] = result[i - 1] + arr[i];\\n    }\\n\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3277341,
                "title": "uff-a-simple-one-c",
                "content": "to start my and banned counter from start \\nincrement my counter by one and leave the one already present in banned\\nbanned1 in my case.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  \\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n       // sort(banned.begin(),banned.end());\\n         int sum = 0,c=0;\\n        vector<int> banned1;\\n        set<int> nums;\\n        int start = 0;\\n\\n          for(auto cc:banned){\\n              nums.insert(cc);\\n          }\\n          for(auto cc:nums){\\n            banned1.push_back(cc);\\n          }\\n\\n\\n        for(int i=1;i<=n;i++){\\n        //  cout<<i<<\" \"<<banned[start]<<endl;\\n            if(start<banned1.size() && banned1[start] == i){\\n                start++;\\n            }else{\\n              sum+=i;\\n              if(sum>maxSum){\\n                break;\\n              }else{\\n                c++;\\n              }\\n            }\\n        }\\n     \\n   \\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n       // sort(banned.begin(),banned.end());\\n         int sum = 0,c=0;\\n        vector<int> banned1;\\n        set<int> nums;\\n        int start = 0;\\n\\n          for(auto cc:banned){\\n              nums.insert(cc);\\n          }\\n          for(auto cc:nums){\\n            banned1.push_back(cc);\\n          }\\n\\n\\n        for(int i=1;i<=n;i++){\\n        //  cout<<i<<\" \"<<banned[start]<<endl;\\n            if(start<banned1.size() && banned1[start] == i){\\n                start++;\\n            }else{\\n              sum+=i;\\n              if(sum>maxSum){\\n                break;\\n              }else{\\n                c++;\\n              }\\n            }\\n        }\\n     \\n   \\n        return c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3272490,
                "title": "easy-hashmap-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to keep the following points in mind while solving this problem:\\n1. The chosen integers have to be in the range [1, n].\\n2. Each integer can be chosen at most once.\\n3. The chosen integers should not be in the array banned.\\n4. The sum of the chosen integers should not exceed maxSum.\\n\\nTo solve the this problem in a very beginner-friendly way, we\\'ll use a intuition keeping all these points in mind and checking them one by one.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Firstly, I\\'ll use a unordered-map to keep the track of integers that are banned, i.e. we can\\'t use them.\\n- Now, I\\'ll run a for loop for the range of integers [1,n] and if the iterator does not exist in the map,that means we can include this in our answer\\n- Since the vector named ans would be automatically sorted, I\\'ll now check the running sum, as long as it is lesser than the maxSum, I\\'ll increase the count.\\nFinally We\\'ll return the count. \\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n**PLEASE UPVOTE IF YOU LIKED THE SOLUTION :)**\\n\\n![ezgif.com-optimize.gif](https://assets.leetcode.com/users/images/03001d4d-0432-42a2-b4f7-bbee78b9050e_1678282128.0453362.gif)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        unordered_map<int,int>mp;\\n        //storing all the banned integers in an unordered_map\\n        for(auto it:banned){\\n            mp[it]++;\\n        }\\n        vector<int>ans;\\n        //inserting all the possible integers in our vector named ans\\n        for(int i=1;i<=n;i++){\\n            if(mp.find(i)==mp.end())ans.push_back(i);\\n        }\\n        int cnt=0;\\n        int sum=0;\\n        //checking if the running sum exceeds the maxSum & finding the feasible solutions \\n        for(int i=0;i<ans.size();i++){\\n            sum+=ans[i];\\n            if(sum<=maxSum)cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        unordered_map<int,int>mp;\\n        //storing all the banned integers in an unordered_map\\n        for(auto it:banned){\\n            mp[it]++;\\n        }\\n        vector<int>ans;\\n        //inserting all the possible integers in our vector named ans\\n        for(int i=1;i<=n;i++){\\n            if(mp.find(i)==mp.end())ans.push_back(i);\\n        }\\n        int cnt=0;\\n        int sum=0;\\n        //checking if the running sum exceeds the maxSum & finding the feasible solutions \\n        for(int i=0;i<ans.size();i++){\\n            sum+=ans[i];\\n            if(sum<=maxSum)cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271989,
                "title": "3-approaches-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxsum) \\n    {\\n        //question have 3 approaches\\n\\n        //solving using array hash table greedy\\n        // return fun1(banned,n,maxsum);\\n\\n        //solving using array sorting bs\\n        // return fun2(banned,n,maxsum);\\n\\n        //using binary search stl\\n        return fun3(banned,n,maxsum);\\n    }\\n    int fun3(vector<int>&banned,int &n,int &maxsum)\\n    {\\n        sort(banned.begin(),banned.end());\\n        int sum = 0;\\n        int count = 0;\\n        int num = 1;\\n        while(num <= n)\\n        {\\n            bool found = binary_search(banned.begin(),banned.end(),num);\\n            if(found == true)\\n            {\\n                num++;\\n            }\\n            else if(found == false)\\n            {\\n                if((sum + num) > maxsum)\\n                return count;\\n\\n                sum = sum + num;\\n                count++;\\n                num++;\\n            }\\n        }\\n        return count;\\n    }\\n    int fun2(vector<int>&banned,int &n,int &maxsum)\\n    {\\n        sort(banned.begin(),banned.end());\\n        int sum = 0;\\n        int count = 0;\\n        int num = 1;\\n        while(num <= n)\\n        {\\n            bool found = getpos(num,banned);\\n            if(found == true)\\n            {\\n                num++;\\n            }\\n            else if(found == false)\\n            {\\n                if((sum + num) > maxsum)\\n                return count;\\n\\n                sum = sum + num;\\n                count++;\\n                num++;\\n            }\\n        }\\n        return count;\\n    }\\n    bool getpos(int num,vector<int>&banned)\\n    {\\n         int start = 0;\\n         int end = banned.size()-1;\\n\\n         while(start <= end)\\n         {\\n             int mid = (start + end)/2;\\n\\n             if(banned[mid] == num)\\n             {\\n                 return true;\\n             }\\n             else if(num > banned[mid])\\n             {\\n                 start = mid+1;\\n             }\\n             else\\n             {\\n                 end = mid-1;\\n             }\\n         }\\n         return false;\\n    }\\n    int fun1(vector<int>&banned,int &n,int &maxsum)\\n    {\\n        unordered_set<int>st;\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            st.insert(banned[i]);\\n        }\\n        int sum = 0;\\n        int count = 0;\\n        int num=1;\\n        while(num <= n)\\n        {\\n            if(st.find(num) != st.end())\\n            {\\n                num++;\\n            }\\n            else \\n            {\\n                if((sum + num) > maxsum)\\n                return count;\\n\\n                sum = sum + num;\\n                count = count+1;\\n                num++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxsum) \\n    {\\n        //question have 3 approaches\\n\\n        //solving using array hash table greedy\\n        // return fun1(banned,n,maxsum);\\n\\n        //solving using array sorting bs\\n        // return fun2(banned,n,maxsum);\\n\\n        //using binary search stl\\n        return fun3(banned,n,maxsum);\\n    }\\n    int fun3(vector<int>&banned,int &n,int &maxsum)\\n    {\\n        sort(banned.begin(),banned.end());\\n        int sum = 0;\\n        int count = 0;\\n        int num = 1;\\n        while(num <= n)\\n        {\\n            bool found = binary_search(banned.begin(),banned.end(),num);\\n            if(found == true)\\n            {\\n                num++;\\n            }\\n            else if(found == false)\\n            {\\n                if((sum + num) > maxsum)\\n                return count;\\n\\n                sum = sum + num;\\n                count++;\\n                num++;\\n            }\\n        }\\n        return count;\\n    }\\n    int fun2(vector<int>&banned,int &n,int &maxsum)\\n    {\\n        sort(banned.begin(),banned.end());\\n        int sum = 0;\\n        int count = 0;\\n        int num = 1;\\n        while(num <= n)\\n        {\\n            bool found = getpos(num,banned);\\n            if(found == true)\\n            {\\n                num++;\\n            }\\n            else if(found == false)\\n            {\\n                if((sum + num) > maxsum)\\n                return count;\\n\\n                sum = sum + num;\\n                count++;\\n                num++;\\n            }\\n        }\\n        return count;\\n    }\\n    bool getpos(int num,vector<int>&banned)\\n    {\\n         int start = 0;\\n         int end = banned.size()-1;\\n\\n         while(start <= end)\\n         {\\n             int mid = (start + end)/2;\\n\\n             if(banned[mid] == num)\\n             {\\n                 return true;\\n             }\\n             else if(num > banned[mid])\\n             {\\n                 start = mid+1;\\n             }\\n             else\\n             {\\n                 end = mid-1;\\n             }\\n         }\\n         return false;\\n    }\\n    int fun1(vector<int>&banned,int &n,int &maxsum)\\n    {\\n        unordered_set<int>st;\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            st.insert(banned[i]);\\n        }\\n        int sum = 0;\\n        int count = 0;\\n        int num=1;\\n        while(num <= n)\\n        {\\n            if(st.find(num) != st.end())\\n            {\\n                num++;\\n            }\\n            else \\n            {\\n                if((sum + num) > maxsum)\\n                return count;\\n\\n                sum = sum + num;\\n                count = count+1;\\n                num++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271891,
                "title": "greedy-easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_set<int>st;\\n    int maxCount(vector<int>& banned, int n, int maxSum) \\n    {\\n         //we will make the ans greedily by taking the small num\\n         for(int i=0;i<(banned.size());i++)\\n         {\\n             st.insert(banned[i]);\\n         }\\n\\n         int sum = 0;\\n         int count = 0;\\n         \\n         int num = 1;\\n \\n         while(num <= n)\\n         {\\n             if(st.find(num) != st.end())\\n             {\\n                 num++;\\n             }\\n             else\\n             {\\n                if((sum + num ) > maxSum)\\n                return count;\\n\\n                sum = sum + num;\\n               \\n                count = count+1;\\n                num++;\\n             }\\n         }\\n         \\n         return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<int>st;\\n    int maxCount(vector<int>& banned, int n, int maxSum) \\n    {\\n         //we will make the ans greedily by taking the small num\\n         for(int i=0;i<(banned.size());i++)\\n         {\\n             st.insert(banned[i]);\\n         }\\n\\n         int sum = 0;\\n         int count = 0;\\n         \\n         int num = 1;\\n \\n         while(num <= n)\\n         {\\n             if(st.find(num) != st.end())\\n             {\\n                 num++;\\n             }\\n             else\\n             {\\n                if((sum + num ) > maxSum)\\n                return count;\\n\\n                sum = sum + num;\\n               \\n                count = count+1;\\n                num++;\\n             }\\n         }\\n         \\n         return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180924,
                "title": "basic-mapping-implementatiton",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        unordered_map<int,int>mp;\\n        for(auto i:banned){\\n            mp[i]++;\\n        }\\n        int cnt=0;\\n        int sum=0;\\n        for(int i=1;i<=n;i++){\\n            if(mp.find(i)==mp.end()){\\n                sum+=i;\\n                if(sum>maxSum){\\n                    break;\\n                }\\n                cnt++;\\n            }\\n        }\\n        //sort(banned.begin(),banned.end());\\n        //cout<<*min_element(banned.begin(),banned.end());\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        unordered_map<int,int>mp;\\n        for(auto i:banned){\\n            mp[i]++;\\n        }\\n        int cnt=0;\\n        int sum=0;\\n        for(int i=1;i<=n;i++){\\n            if(mp.find(i)==mp.end()){\\n                sum+=i;\\n                if(sum>maxSum){\\n                    break;\\n                }\\n                cnt++;\\n            }\\n        }\\n        //sort(banned.begin(),banned.end());\\n        //cout<<*min_element(banned.begin(),banned.end());\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3172307,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n            Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < banned.length; i++) {\\n            set.add(banned[i]);\\n        }\\n        int count = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if(!set.contains(i)){\\n                if(maxSum<i){\\n                    break;\\n                }\\n                maxSum = maxSum - i;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n            Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < banned.length; i++) {\\n            set.add(banned[i]);\\n        }\\n        int count = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if(!set.contains(i)){\\n                if(maxSum<i){\\n                    break;\\n                }\\n                maxSum = maxSum - i;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165573,
                "title": "my-optimized-solution-in-python-with-comment",
                "content": "# Approach\\nHere\\'s what the code does step by step:\\n\\nIt sorts and removes duplicates from the banned list using banned = sorted(set(banned)).\\n\\nIt initializes an empty list alph and a variable i to zero.\\n\\nIt loops through the range [1, min(n, maxSum)+1] and checks if the current value x is equal to the next banned number at index i in the banned list.\\n    - If x is equal to the banned number, i is incremented by 1.\\n    - If x is not equal to the banned number, x is added to the alph list.\\n    - If all banned numbers have been processed and x is not equal to any banned number, the rest of the range is added to the alph list and the loop is broken.\\n\\nIt initializes two variables step and sumElements to zero.\\n\\nIt loops through the alph list, adds each element to sumElements, increments step by 1, and checks if sumElements is greater than maxSum.\\n    - If sumElements is greater than maxSum, the function returns step - 1.\\n    - If sumElements is equal to maxSum, the function returns step.\\n\\nIf the loop has completed, the function returns step.\\n\\nThe final output of the function is the maximum number of elements from the alph list that can be added up to get maxSum.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this code is O(n), where n = min(n, maxSum). This is because the code performs two linear scans through the range [1, min(n, maxSum)+1] and the alph list, each of which takes O(n) time. The sorted(set(banned)) operation takes O(m log m) time, where m is the length of the banned list, but it can be considered as a constant factor because it is not dependent on n.\\n\\n- Space complexity:\\nThe space complexity of this code is O(n), where n = min(n, maxSum). This is because the alph list is storing O(n) elements. The rest of the variables used in the code take up a constant amount of space.\\n# Code\\n```\\nclass Solution(object):\\n    def maxCount(self, banned, n, maxSum):\\n        banned = sorted(set(banned))\\n        alph = []\\n        i = 0\\n        for x in range(1, min(n, maxSum)+1):\\n            if i == len(banned):\\n                alph += range(x, min(n, maxSum)+1)\\n                break\\n            if x == banned[i]:\\n                i+=1\\n            else:\\n                alph.append(x)\\n        step = 0\\n        sumElements = 0\\n        for x in alph:\\n            sumElements+=x\\n            step+=1\\n            if sumElements>maxSum:\\n                return int(step-1)\\n            elif sumElements==maxSum:\\n                return step\\n        return step\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxCount(self, banned, n, maxSum):\\n        banned = sorted(set(banned))\\n        alph = []\\n        i = 0\\n        for x in range(1, min(n, maxSum)+1):\\n            if i == len(banned):\\n                alph += range(x, min(n, maxSum)+1)\\n                break\\n            if x == banned[i]:\\n                i+=1\\n            else:\\n                alph.append(x)\\n        step = 0\\n        sumElements = 0\\n        for x in alph:\\n            sumElements+=x\\n            step+=1\\n            if sumElements>maxSum:\\n                return int(step-1)\\n            elif sumElements==maxSum:\\n                return step\\n        return step\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147759,
                "title": "simple-and-easy-to-understand-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& v, int n, int maxSum) {\\n        set<int>s;\\n        int ans = 0 , c=0;\\n        int size = v.size();\\n        for(int i=0;i<size;i++){\\n            s.insert(v[i]);\\n        }\\n        for(int i=1;i<=n;i++){\\n            if((s.count(i) == 0 ) && ( (ans +i)<= maxSum)){\\n                ans += i;\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& v, int n, int maxSum) {\\n        set<int>s;\\n        int ans = 0 , c=0;\\n        int size = v.size();\\n        for(int i=0;i<size;i++){\\n            s.insert(v[i]);\\n        }\\n        for(int i=1;i<=n;i++){\\n            if((s.count(i) == 0 ) && ( (ans +i)<= maxSum)){\\n                ans += i;\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146375,
                "title": "c-easy-solution-using-set",
                "content": "# Intuition\\nPlease, Upvote the Solution my repuation is in Negative.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n      \\n      int sum = 0;\\n      int cnt = 0;\\n      unordered_set<int> st{banned.begin(),banned.end()};\\n      \\n      for(int i=1;i<=n;i++){\\n        \\n         if(!st.count(i) && sum+i <= maxSum){\\n           sum += i;\\n           cnt++;\\n         }\\n      }\\n      \\n      \\n      return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n      \\n      int sum = 0;\\n      int cnt = 0;\\n      unordered_set<int> st{banned.begin(),banned.end()};\\n      \\n      for(int i=1;i<=n;i++){\\n        \\n         if(!st.count(i) && sum+i <= maxSum){\\n           sum += i;\\n           cnt++;\\n         }\\n      }\\n      \\n      \\n      return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146097,
                "title": "python-easy-to-understand-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is important to keep banned as set otherwise in PYTHON it gives TLE(Time Limit Exceeded)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        cnt = 0\\n        total = 0\\n        banned = set(banned)\\n        \\n        for i in range(1,n+1):\\n            if i not in banned and maxSum>=total+i:\\n                cnt+=1\\n                total+=i\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        cnt = 0\\n        total = 0\\n        banned = set(banned)\\n        \\n        for i in range(1,n+1):\\n            if i not in banned and maxSum>=total+i:\\n                cnt+=1\\n                total+=i\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145208,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        int cnt=0, sum=0;\\n        unordered_map<int, int>m;\\n        for(int i=0; i<banned.size(); i++){\\n            m[banned[i]]++;\\n        }\\n        for(int i=1; i<=n; i++){\\n            if(m.find(i)==m.end()){\\n                sum+=i;\\n                cout<<i<<endl;\\n                if(sum<=maxSum){\\n                cnt++;}\\n                else{break;}\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        int cnt=0, sum=0;\\n        unordered_map<int, int>m;\\n        for(int i=0; i<banned.size(); i++){\\n            m[banned[i]]++;\\n        }\\n        for(int i=1; i<=n; i++){\\n            if(m.find(i)==m.end()){\\n                sum+=i;\\n                cout<<i<<endl;\\n                if(sum<=maxSum){\\n                cnt++;}\\n                else{break;}\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3144934,
                "title": "very-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        set<int>s;\\n        for(int i=0;i<banned.size();i++){\\n            s.insert(banned[i]); }\\nint sum=0;\\nint count=0;\\n        for(int i=1;i<=n;i++){\\n            if(s.find(i)!=s.end()){\\n                continue;\\n            }else{\\n                sum=sum+i;\\n                if(sum<=maxSum){\\n                    \\n                    count++;\\n                }\\n            }\\n        }\\n        return count;}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        set<int>s;\\n        for(int i=0;i<banned.size();i++){\\n            s.insert(banned[i]); }\\nint sum=0;\\nint count=0;\\n        for(int i=1;i<=n;i++){\\n            if(s.find(i)!=s.end()){\\n                continue;\\n            }else{\\n                sum=sum+i;\\n                if(sum<=maxSum){\\n                    \\n                    count++;\\n                }\\n            }\\n        }\\n        return count;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144137,
                "title": "java-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i = 0; i < banned.length ; i++){\\n            set.add(banned[i]);\\n        }\\n        int sum = 0;\\n        int count = 0;\\n        for(int i = 1; i <= n ; i++){\\n            if(sum + i <= maxSum){\\n                if(!set.contains(i)){\\n                    count++;\\n                    sum += i;\\n                }\\n            }else{\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i = 0; i < banned.length ; i++){\\n            set.add(banned[i]);\\n        }\\n        int sum = 0;\\n        int count = 0;\\n        for(int i = 1; i <= n ; i++){\\n            if(sum + i <= maxSum){\\n                if(!set.contains(i)){\\n                    count++;\\n                    sum += i;\\n                }\\n            }else{\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144134,
                "title": "easy-6-line-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        \\n        vector<bool>mp(n+1,0);\\n        int ans=0,count=0;\\n        for(auto i:banned)if(i>0 && i<=n)mp[i]=true;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            if(ans+i>maxSum)break;\\n            if(!mp[i])\\n            ans+=i,count++;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        \\n        vector<bool>mp(n+1,0);\\n        int ans=0,count=0;\\n        for(auto i:banned)if(i>0 && i<=n)mp[i]=true;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            if(ans+i>maxSum)break;\\n            if(!mp[i])\\n            ans+=i,count++;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143448,
                "title": "easy-c-solution-biweekly-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& b, int n, int m) {\\n        set<int>s;\\n        for(int i=0;i<b.size();i++){\\n            s.insert(b[i]);\\n        }\\n        int c=0;\\n        long long int sum=0;\\n        for(int i=1;i<=n;i++){\\n            if(sum>m)\\n                break;\\n            if(s.count(i)==0 && (sum+i)<=m)\\n               {\\n                sum+=i;\\n                c++;\\n                }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& b, int n, int m) {\\n        set<int>s;\\n        for(int i=0;i<b.size();i++){\\n            s.insert(b[i]);\\n        }\\n        int c=0;\\n        long long int sum=0;\\n        for(int i=1;i<=n;i++){\\n            if(sum>m)\\n                break;\\n            if(s.count(i)==0 && (sum+i)<=m)\\n               {\\n                sum+=i;\\n                c++;\\n                }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143059,
                "title": "simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(len(banned))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        HashSet<Integer> forbidden = new HashSet<>();\\n        int sum = 0, picked = 0;\\n        for(int a: banned) {\\n            forbidden.add(a);\\n        }\\n        for (int i = 1; i <= n && (sum + i <= maxSum); i++) {\\n            if (!forbidden.contains(i)) {\\n                sum += i;\\n                picked++;\\n            }\\n        }\\n        \\n        return picked;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        HashSet<Integer> forbidden = new HashSet<>();\\n        int sum = 0, picked = 0;\\n        for(int a: banned) {\\n            forbidden.add(a);\\n        }\\n        for (int i = 1; i <= n && (sum + i <= maxSum); i++) {\\n            if (!forbidden.contains(i)) {\\n                sum += i;\\n                picked++;\\n            }\\n        }\\n        \\n        return picked;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142992,
                "title": "c-easy-solution-beats-56",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        unordered_map<int, int> mp;\\n        for(auto i: banned)\\n            mp[i]++;\\n        vector<int> vec;\\n        int sum = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            if(mp[i] == 0 and i < maxSum)\\n            {\\n                if(vec.size() == 0)\\n                {\\n                    vec.push_back(i);\\n                    sum += i;\\n                }\\n                else\\n                {\\n                    sum += i;\\n                    if(sum <= maxSum)\\n                        vec.push_back(i);\\n                }\\n            }\\n        }\\n        return vec.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        unordered_map<int, int> mp;\\n        for(auto i: banned)\\n            mp[i]++;\\n        vector<int> vec;\\n        int sum = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            if(mp[i] == 0 and i < maxSum)\\n            {\\n                if(vec.size() == 0)\\n                {\\n                    vec.push_back(i);\\n                    sum += i;\\n                }\\n                else\\n                {\\n                    sum += i;\\n                    if(sum <= maxSum)\\n                        vec.push_back(i);\\n                }\\n            }\\n        }\\n        return vec.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142587,
                "title": "java-and-python-simple-and-fast-solution",
                "content": "Please upvote if understood \\n\\nJava ****\\n\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        int count = 0 ; long sum = 0 ;\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int elem : banned){\\n            set.add(elem);\\n        }\\n        \\n        for(int i=1 ;i<=n ;i++){\\n            if(!set.contains(i) && sum+i<=maxSum){\\n                count++;\\n                sum +=i;\\n            }\\n            if(sum+i>maxSum)break;\\n        }\\n        return count ;\\n    }\\n\\n**Python **\\n\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        s = set();\\n        count , sum = 0 , 0;\\n        for x in banned:\\n            s.add(x);\\n        for i in range(1,n+1,1):\\n            if i not in s and sum+i<=maxSum:\\n                count+=1;\\n                sum+=i;\\n            if sum+i>maxSum:\\n                break;\\n        return count ;",
                "solutionTags": [
                    "Array"
                ],
                "code": "Please upvote if understood \\n\\nJava ****\\n\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        int count = 0 ; long sum = 0 ;\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int elem : banned){\\n            set.add(elem);\\n        }\\n        \\n        for(int i=1 ;i<=n ;i++){\\n            if(!set.contains(i) && sum+i<=maxSum){\\n                count++;\\n                sum +=i;\\n            }\\n            if(sum+i>maxSum)break;\\n        }\\n        return count ;\\n    }\\n\\n**Python **\\n\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        s = set();\\n        count , sum = 0 , 0;\\n        for x in banned:\\n            s.add(x);\\n        for i in range(1,n+1,1):\\n            if i not in s and sum+i<=maxSum:\\n                count+=1;\\n                sum+=i;\\n            if sum+i>maxSum:\\n                break;\\n        return count ;",
                "codeTag": "Python3"
            },
            {
                "id": 3142557,
                "title": "brute-force-c",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n     int sum = 0;\\n     int count = 0;\\n     for(int i = 1 ; i <= n ; i++){\\n         if( sum+i <= maxSum){\\n             if(find(banned.begin(),banned.end(),i)==banned.end()){\\n                 sum+=i;\\n                 count++;\\n             }\\n         }\\n        } \\n     return count;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n     int sum = 0;\\n     int count = 0;\\n     for(int i = 1 ; i <= n ; i++){\\n         if( sum+i <= maxSum){\\n             if(find(banned.begin(),banned.end(),i)==banned.end()){\\n                 sum+=i;\\n                 count++;\\n             }\\n         }\\n        } \\n     return count;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142522,
                "title": "c-most-easy-and-simple-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        set<int> st;\\n        for(int x:banned)\\n            st.insert(x);\\n        int cnt=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(st.find(i)==st.end())\\n            {\\n                if(maxSum-i<0)\\n                    return cnt;\\n                maxSum-=i;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        set<int> st;\\n        for(int x:banned)\\n            st.insert(x);\\n        int cnt=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(st.find(i)==st.end())\\n            {\\n                if(maxSum-i<0)\\n                    return cnt;\\n                maxSum-=i;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142438,
                "title": "very-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) \\n    {\\n        set<int> s;\\n        for(auto it: banned) s.insert(it);\\n        int sum=0;\\n        int i=1;\\n        int count=0;\\n        while(sum<maxSum && i<=n)\\n        {\\n            if(sum+i<=maxSum && s.find(i)==s.end())\\n            {\\n                sum+=i;\\n                count++;\\n            }\\n            else if(sum+i>maxSum) break;\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) \\n    {\\n        set<int> s;\\n        for(auto it: banned) s.insert(it);\\n        int sum=0;\\n        int i=1;\\n        int count=0;\\n        while(sum<maxSum && i<=n)\\n        {\\n            if(sum+i<=maxSum && s.find(i)==s.end())\\n            {\\n                sum+=i;\\n                count++;\\n            }\\n            else if(sum+i>maxSum) break;\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142319,
                "title": "c-solution",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        int ans=0;\\n      unordered_set <int> mp;\\n      for(auto n:banned){\\n          mp.insert(n);\\n      }  \\n      for(int i=1; i<=n;i++){\\n          if(mp.find(i)==mp.end() && (maxSum-i)>=0){\\n              ans++;\\n              maxSum=maxSum-i;\\n          }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        int ans=0;\\n      unordered_set <int> mp;\\n      for(auto n:banned){\\n          mp.insert(n);\\n      }  \\n      for(int i=1; i<=n;i++){\\n          if(mp.find(i)==mp.end() && (maxSum-i)>=0){\\n              ans++;\\n              maxSum=maxSum-i;\\n          }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142270,
                "title": "c-greedy",
                "content": "```\\nclass Solution {\\npublic: \\n    int maxCount(vector<int>& banned, int n, int maxSum){\\n        set<int> st;\\n        for(auto itr: banned){\\n            st.insert(itr);\\n        }\\n        int ans=0, sum=0;\\n        for(int i=1; i<=n; i++){\\n            if(sum>=maxSum){\\n                break;\\n            }\\n            if(st.find(i)==st.end()){\\n                if(sum+i<=maxSum){\\n                    ans++;\\n                    sum+= i;\\n                }\\n            }\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int maxCount(vector<int>& banned, int n, int maxSum){\\n        set<int> st;\\n        for(auto itr: banned){\\n            st.insert(itr);\\n        }\\n        int ans=0, sum=0;\\n        for(int i=1; i<=n; i++){\\n            if(sum>=maxSum){\\n                break;\\n            }\\n            if(st.find(i)==st.end()){\\n                if(sum+i<=maxSum){\\n                    ans++;\\n                    sum+= i;\\n                }\\n            }\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142241,
                "title": "easy-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        vector<int> arr(n,0);\\n        for(int i=0;i<banned.size();i++){\\n            if(banned[i]<=n){\\n                int a=banned[i]-1;\\n                arr[a]=1;\\n            }\\n        }\\n        int count=0,sum=0;\\n        for(int i=0;i<n;i++){\\n            // if(sum>maxSum) break;\\n            if(arr[i]==0 && sum+i+1<=maxSum){\\n                sum+=i+1;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        vector<int> arr(n,0);\\n        for(int i=0;i<banned.size();i++){\\n            if(banned[i]<=n){\\n                int a=banned[i]-1;\\n                arr[a]=1;\\n            }\\n        }\\n        int count=0,sum=0;\\n        for(int i=0;i<n;i++){\\n            // if(sum>maxSum) break;\\n            if(arr[i]==0 && sum+i+1<=maxSum){\\n                sum+=i+1;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142024,
                "title": "80-faster-code-in-python-simple-understanding",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        banned = set(banned)\\n        res, sums, curr = 0, 0, 1\\n        while curr <= n:\\n            if curr not in banned:\\n                if sums+curr <= maxSum:\\n                    sums += curr\\n                    res += 1\\n                else:\\n                    break\\n            curr += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        banned = set(banned)\\n        res, sums, curr = 0, 0, 1\\n        while curr <= n:\\n            if curr not in banned:\\n                if sums+curr <= maxSum:\\n                    sums += curr\\n                    res += 1\\n                else:\\n                    break\\n            curr += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141940,
                "title": "easy-simple-c-solution-hashing",
                "content": "## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code1\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        vector<long long> v;\\n        map<int,bool> mp;\\n        for (auto val: banned){\\n            mp[val]=1;\\n        }\\n        int cnt=0;\\n        long long int summ= 0;\\n        for (int i=1; i<=n; i++){\\n            if (!mp[i]){\\n                summ+= i;\\n                if (summ> maxSum)break;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n## Code2\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        set<int> st;\\n        for (auto val: banned){\\n            st.insert(val);\\n        }\\n        int cnt=0;\\n        long long int summ= 0;\\n        for (int i=1; i<=n; i++){\\n            if (st.find(i)==st.end()){\\n                summ+= i;\\n                if (summ> maxSum)break;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        vector<long long> v;\\n        map<int,bool> mp;\\n        for (auto val: banned){\\n            mp[val]=1;\\n        }\\n        int cnt=0;\\n        long long int summ= 0;\\n        for (int i=1; i<=n; i++){\\n            if (!mp[i]){\\n                summ+= i;\\n                if (summ> maxSum)break;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        set<int> st;\\n        for (auto val: banned){\\n            st.insert(val);\\n        }\\n        int cnt=0;\\n        long long int summ= 0;\\n        for (int i=1; i<=n; i++){\\n            if (st.find(i)==st.end()){\\n                summ+= i;\\n                if (summ> maxSum)break;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141844,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) \\n    {\\n     HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<banned.length;i++)\\n        {\\n            map.put(banned[i],1);\\n        }\\n        int ans=0;\\n        int sum=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(map.containsKey(i)==false)\\n            {\\n                if(sum+i<=maxSum)\\n                {\\n                    sum+=i;\\n                    ans++;\\n                }\\n            }\\n            if(sum>maxSum)\\n                break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) \\n    {\\n     HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<banned.length;i++)\\n        {\\n            map.put(banned[i],1);\\n        }\\n        int ans=0;\\n        int sum=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(map.containsKey(i)==false)\\n            {\\n                if(sum+i<=maxSum)\\n                {\\n                    sum+=i;\\n                    ans++;\\n                }\\n            }\\n            if(sum>maxSum)\\n                break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141752,
                "title": "c-java-python-solutions",
                "content": "# C++\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        set<int> arr;\\n        for (int i = 1; i <= n; i++) {\\n            arr.insert(i);\\n        }\\n        set<int> x;\\n        set_difference(arr.begin(), arr.end(), banned.begin(), banned.end(),\\n                       inserter(x, x.end()));\\n        vector<int> x_vec(x.begin(), x.end());\\n        sort(x_vec.begin(), x_vec.end());\\n        int cnt = 0;\\n        int i = 0;\\n        while (cnt <= maxSum && i != x_vec.size()) {\\n            cnt += x_vec[i];\\n            i++;\\n        }\\n        if (cnt > maxSum) {\\n            return i - 1;\\n        }\\n        return i;\\n    }\\n};\\n```\\n\\n# Java\\n<!-- Describe your approach to solving the problem. -->\\n```class Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        Set<Integer> arr = new HashSet<>();\\n        for (int i = 1; i <= n; i++) {\\n            arr.add(i);\\n        }\\n        Set<Integer> x = new HashSet<>();\\n        for (int i : arr) {\\n            if (!contains(banned, i)) {\\n                x.add(i);\\n            }\\n        }\\n        List<Integer> xList = new ArrayList<>(x);\\n        Collections.sort(xList);\\n        int cnt = 0;\\n        int i = 0;\\n        while (cnt <= maxSum && i != xList.size()) {\\n            cnt += xList.get(i);\\n            i++;\\n        }\\n        if (cnt > maxSum) {\\n            return i - 1;\\n        }\\n        return i;\\n    }\\n\\n    private boolean contains(int[] arr, int target) {\\n        for (int i : arr) {\\n            if (i == target) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n# Python\\n```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        arr = set(i for i in range(1, n + 1))\\n        x = arr - set(banned)\\n        x = sorted(list(x))\\n        cnt = 0\\n        cntt = 0\\n        i = 0\\n        while cnt <= maxSum and i != len(x):\\n            cnt += x[i]\\n            i += 1\\n        if cnt > maxSum:\\n            return i - 1\\n        return i\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        set<int> arr;\\n        for (int i = 1; i <= n; i++) {\\n            arr.insert(i);\\n        }\\n        set<int> x;\\n        set_difference(arr.begin(), arr.end(), banned.begin(), banned.end(),\\n                       inserter(x, x.end()));\\n        vector<int> x_vec(x.begin(), x.end());\\n        sort(x_vec.begin(), x_vec.end());\\n        int cnt = 0;\\n        int i = 0;\\n        while (cnt <= maxSum && i != x_vec.size()) {\\n            cnt += x_vec[i];\\n            i++;\\n        }\\n        if (cnt > maxSum) {\\n            return i - 1;\\n        }\\n        return i;\\n    }\\n};\\n```\n```class Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        Set<Integer> arr = new HashSet<>();\\n        for (int i = 1; i <= n; i++) {\\n            arr.add(i);\\n        }\\n        Set<Integer> x = new HashSet<>();\\n        for (int i : arr) {\\n            if (!contains(banned, i)) {\\n                x.add(i);\\n            }\\n        }\\n        List<Integer> xList = new ArrayList<>(x);\\n        Collections.sort(xList);\\n        int cnt = 0;\\n        int i = 0;\\n        while (cnt <= maxSum && i != xList.size()) {\\n            cnt += xList.get(i);\\n            i++;\\n        }\\n        if (cnt > maxSum) {\\n            return i - 1;\\n        }\\n        return i;\\n    }\\n\\n    private boolean contains(int[] arr, int target) {\\n        for (int i : arr) {\\n            if (i == target) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        arr = set(i for i in range(1, n + 1))\\n        x = arr - set(banned)\\n        x = sorted(list(x))\\n        cnt = 0\\n        cntt = 0\\n        i = 0\\n        while cnt <= maxSum and i != len(x):\\n            cnt += x[i]\\n            i += 1\\n        if cnt > maxSum:\\n            return i - 1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141726,
                "title": "easy-c-unordered-map-solution",
                "content": "\\n\\n# Approach\\nKeep iterating from 1 to n and check whether the number is present in the hashmap or not , if not then add the number to the sum and keep increasing the count , once the sum exceeds the maxSum we can break out of the loop as there\\'s no point in iterating further more.\\n\\nUPVOTE PLZ IF you like my approach. Thanks\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n\\n- Space complexity:\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        \\n    unordered_map<int,int> mp; int sum = 0;\\n    int ans = 0;\\n\\n    for(int i = 0; i<banned.size(); i++)\\n    {\\n        mp[banned[i]]++;\\n    }\\n\\n    for(int i = 1 ; i<=n ; i++)\\n    {\\n        if(mp.find(i) == mp.end())\\n        {\\n            sum += i;\\n            if(sum <= maxSum)\\n                ans += 1;\\n            else\\n                break;\\n               \\n        }\\n    }\\n\\n    return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        \\n    unordered_map<int,int> mp; int sum = 0;\\n    int ans = 0;\\n\\n    for(int i = 0; i<banned.size(); i++)\\n    {\\n        mp[banned[i]]++;\\n    }\\n\\n    for(int i = 1 ; i<=n ; i++)\\n    {\\n        if(mp.find(i) == mp.end())\\n        {\\n            sum += i;\\n            if(sum <= maxSum)\\n                ans += 1;\\n            else\\n                break;\\n               \\n        }\\n    }\\n\\n    return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141657,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        look=set(banned)\\n        curr=0\\n        cunt=0\\n        for i in range(1,n+1):\\n            if i in look:\\n                continue\\n                \\n            if curr+i>maxSum:\\n                return cunt\\n            curr+=i\\n            cunt+=1\\n            \\n        return cunt    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        look=set(banned)\\n        curr=0\\n        cunt=0\\n        for i in range(1,n+1):\\n            if i in look:\\n                continue\\n                \\n            if curr+i>maxSum:\\n                return cunt\\n            curr+=i\\n            cunt+=1\\n            \\n        return cunt    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141609,
                "title": "c-solution-using-unordered-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& arr, int n, int maxSum) {\\n        unordered_set<int> set(arr.begin(),arr.end());\\n        int ans=0,sum=0;\\n        \\n        for(int i=1;i<=n;i++){\\n            if(set.count(i)==0){\\n                if(sum+i <= maxSum){\\n                    sum+= i;\\n                    ans++;\\n                }\\n                else break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n// solution by uttams_237\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& arr, int n, int maxSum) {\\n        unordered_set<int> set(arr.begin(),arr.end());\\n        int ans=0,sum=0;\\n        \\n        for(int i=1;i<=n;i++){\\n            if(set.count(i)==0){\\n                if(sum+i <= maxSum){\\n                    sum+= i;\\n                    ans++;\\n                }\\n                else break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n// solution by uttams_237\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141582,
                "title": "easy-java-solution-using-set",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        int count = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i : banned)\\n            set.add(i);\\n        \\n        for(int i = 1; i<=n; i++){\\n            if(!(set.contains(i))){\\n                maxSum -= i;\\n                if(maxSum >= 0)\\n                    count ++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        int count = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i : banned)\\n            set.add(i);\\n        \\n        for(int i = 1; i<=n; i++){\\n            if(!(set.contains(i))){\\n                maxSum -= i;\\n                if(maxSum >= 0)\\n                    count ++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141554,
                "title": "python-solution-easy-to-understand-for-beginners",
                "content": "```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n\\t\\t# making set of banned values because search in set is faster\\n        banned = set(banned)\\n\\t\\t\\n\\t\\t# cnt variable is use to store the count of minimum number required\\n\\t\\t# ans stores the sum till current number\\n        cnt,ans = 0,0\\n\\t\\t\\n\\t\\t# greedily choose all number from 1 to n+1 that are not in banned till current sum exceeds the maxSum\\n\\t\\t# it is always optimal to choose smaller number\\n        for i in range(1,n+1):\\n            if i not in banned:\\n                ans += i\\n                cnt += 1\\n\\t\\t\\t\\t\\n            if ans > maxSum:\\n\\t\\t\\t\\t# as current sum exceed we need not the last element so remove it.\\n                cnt -= 1\\n                break\\n        return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n\\t\\t# making set of banned values because search in set is faster\\n        banned = set(banned)\\n\\t\\t\\n\\t\\t# cnt variable is use to store the count of minimum number required\\n\\t\\t# ans stores the sum till current number\\n        cnt,ans = 0,0\\n\\t\\t\\n\\t\\t# greedily choose all number from 1 to n+1 that are not in banned till current sum exceeds the maxSum\\n\\t\\t# it is always optimal to choose smaller number\\n        for i in range(1,n+1):\\n            if i not in banned:\\n                ans += i\\n                cnt += 1\\n\\t\\t\\t\\t\\n            if ans > maxSum:\\n\\t\\t\\t\\t# as current sum exceed we need not the last element so remove it.\\n                cnt -= 1\\n                break\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141499,
                "title": "easy-js-solution",
                "content": "\\n# Code\\n```\\nconst maxCount = function (banned, n, maxSum) {\\n  let answ = 0;\\n  let sum = 0;\\n  for (let i = 1; i <= n; i++) {\\n    if (!banned.includes(i) && sum + i <= maxSum) {\\n        answ++;\\n        sum += i;\\n    }\\n  }\\n  return answ;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maxCount = function (banned, n, maxSum) {\\n  let answ = 0;\\n  let sum = 0;\\n  for (let i = 1; i <= n; i++) {\\n    if (!banned.includes(i) && sum + i <= maxSum) {\\n        answ++;\\n        sum += i;\\n    }\\n  }\\n  return answ;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084860,
                "title": "easy-python-solution-beats-90-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        d1={}\\n        sumo=0\\n        c=0\\n        for i in banned:\\n            d1[i]=1\\n        for i in range(1,n+1):\\n            if(i>maxSum):\\n                break\\n            if(i in d1):\\n                continue\\n            else:\\n                sumo+=i\\n                if(sumo>maxSum):\\n                    return c\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        d1={}\\n        sumo=0\\n        c=0\\n        for i in banned:\\n            d1[i]=1\\n        for i in range(1,n+1):\\n            if(i>maxSum):\\n                break\\n            if(i in d1):\\n                continue\\n            else:\\n                sumo+=i\\n                if(sumo>maxSum):\\n                    return c\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074937,
                "title": "2-solutions-but-only-1-submits",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        int count = 0;\\n        int sum = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < banned.length; i++){\\n            set.add(banned[i]);\\n        }\\n        for (int i = 1; i <= n; i++){\\n            if (!set.contains(i)){\\n                sum += i;\\n                if (sum <= maxSum){\\n                    count++;\\n                }\\n                else{\\n                    return count;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n//TestCases Passed but took too long :(\\n/*class Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        int count = 0;\\n        int sum = 0;\\n\\n        for (int i = 1; i <= n; i++){\\n            if (Ban(banned, i) && sum + i <= maxSum){\\n                sum += i;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    private boolean Ban(int[] arr, int n){\\n        int count = 0;\\n        for (int i = 0; i < arr.length; i++){\\n            if (arr[i] == n){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        int count = 0;\\n        int sum = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < banned.length; i++){\\n            set.add(banned[i]);\\n        }\\n        for (int i = 1; i <= n; i++){\\n            if (!set.contains(i)){\\n                sum += i;\\n                if (sum <= maxSum){\\n                    count++;\\n                }\\n                else{\\n                    return count;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n//TestCases Passed but took too long :(\\n/*class Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        int count = 0;\\n        int sum = 0;\\n\\n        for (int i = 1; i <= n; i++){\\n            if (Ban(banned, i) && sum + i <= maxSum){\\n                sum += i;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    private boolean Ban(int[] arr, int n){\\n        int count = 0;\\n        for (int i = 0; i < arr.length; i++){\\n            if (arr[i] == n){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072592,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst Intuition to create collection of all allowed numbers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor allowed Numbers, created array of first n natural numbers, then replaced banned number with 0 and finally removed all zeros. Then iterated over array till we reach maxSum. And return the current index.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        vector<int> v(n);\\n        for(int i=0; i<n; i++){\\n            v[i] = i+1;\\n        }\\n        for(int i=0; i<banned.size(); i++){\\n            if (banned[i] <= n){\\n                v[banned[i]-1] = 0;\\n            }\\n        }\\n        v.erase(remove(v.begin(), v.end(), 0), v.end());\\n        int temp = 0;\\n        int i =0;\\n        for(i; i<v.size(); i++){\\n            if(temp + v[i] <= maxSum){\\n                temp += v[i];\\n            }else{\\n                break;\\n            }\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        vector<int> v(n);\\n        for(int i=0; i<n; i++){\\n            v[i] = i+1;\\n        }\\n        for(int i=0; i<banned.size(); i++){\\n            if (banned[i] <= n){\\n                v[banned[i]-1] = 0;\\n            }\\n        }\\n        v.erase(remove(v.begin(), v.end(), 0), v.end());\\n        int temp = 0;\\n        int i =0;\\n        for(i; i<v.size(); i++){\\n            if(temp + v[i] <= maxSum){\\n                temp += v[i];\\n            }else{\\n                break;\\n            }\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070580,
                "title": "easy-solution-uning-two-different-approch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int m) {\\n     /*   Set<Integer>hs=new HashSet<>();int ans=0;\\n        for(int i:banned)hs.add(i);\\n            for(int i=1;i<=n;i++){\\n                if(!hs.contains(i)){\\n                    m-=i;\\n                    if(m>=0)ans++;\\n                    else return ans;\\n                }\\n            }\\n            return ans;\\n    }\\n}*/\\nint[]arr=new int[10001];int ans=0;\\n for(int i:banned)arr[i]--;\\n\\n for(int i=1;i<=n;i++){\\n     if(arr[i]>=0){\\n         m-=i;\\n      if(m>=0)ans++;\\n      else return ans;\\n                }\\n            }\\n            return ans;\\n    }}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int m) {\\n     /*   Set<Integer>hs=new HashSet<>();int ans=0;\\n        for(int i:banned)hs.add(i);\\n            for(int i=1;i<=n;i++){\\n                if(!hs.contains(i)){\\n                    m-=i;\\n                    if(m>=0)ans++;\\n                    else return ans;\\n                }\\n            }\\n            return ans;\\n    }\\n}*/\\nint[]arr=new int[10001];int ans=0;\\n for(int i:banned)arr[i]--;\\n\\n for(int i=1;i<=n;i++){\\n     if(arr[i]>=0){\\n         m-=i;\\n      if(m>=0)ans++;\\n      else return ans;\\n                }\\n            }\\n            return ans;\\n    }}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050841,
                "title": "brute-force-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        unordered_set<int> mp(banned.begin(),banned.end());\\n        vector<int> ans;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp.find(i)==mp.end())\\n            ans.push_back(i);\\n        }\\n        \\n        // int z=0;\\n        // if(ans.size()==0)\\n        // {\\n        //     return z;\\n        // }\\n        \\n        int k=0;\\n        int sum=0;\\n        \\n        for(auto i:ans)\\n        {\\n            sum+=i;\\n            if(sum<=maxSum)\\n            k++;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        unordered_set<int> mp(banned.begin(),banned.end());\\n        vector<int> ans;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp.find(i)==mp.end())\\n            ans.push_back(i);\\n        }\\n        \\n        // int z=0;\\n        // if(ans.size()==0)\\n        // {\\n        //     return z;\\n        // }\\n        \\n        int k=0;\\n        int sum=0;\\n        \\n        for(auto i:ans)\\n        {\\n            sum+=i;\\n            if(sum<=maxSum)\\n            k++;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010847,
                "title": "cycle-sort-different-approach-maximum-number-of-integers-to-choose-from-a-range-i",
                "content": "# Intuition\\nThe chosen integers have to be in the range `[1, N]`, this led me to think about using Cycle Sort.\\n\\n# Approach\\nUse Cycle Sort to sort the banned array.\\nIf the banned array has less elements than `[1, N]`, we resize the array to make the indices be of the form `[0, N-1]`. (Cycle Sort relies on the indices for sorting)\\n\\nWhile resizing the banned array, initialize the element to a number outside the \\nrange `[1, N]` so chose -1.\\n\\nThen apply Cycle Sort to place the elements [1, N] in their correct positions.\\nFor example:\\nThe `0th index contains 1` (if 1 is present in the banned array).\\nThe `kth index contains (k+1)`.\\n\\nAfter sorting, iterate through the banned array.\\nIf `banned[i] != (i+1)` that means the number `i+1` can be considered. And since we need to maximize the count the lower elements are to be considered from [1, N].\\nAfter selecting a number decrement it from `maxSum` and increment the `count`. When `maxSum < 0` break and return the count.\\n\\n> Note:\\nCycle Sort is a pre-requisite.\\nThe given Banned array is modified. [Drawback of using Cycle Sort]\\nThe resizing must be done only if the banned array indices do not fall between [0, N-1].\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(N)$$\\n\\n- Space complexity:\\nIf resize required, $$O(N)$$. Otherwise $$O(1)$$\\n\\n# Code\\n## C++\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        // Ensure banned array has enough elements\\n        if(n > banned.size()) {\\n            banned.resize(n, -1); // Resize and initialize with -1\\n        }\\n\\n        // Cycle Sort to sort the banned array\\n        for(int i=0; i<banned.size(); ) {\\n            if(banned[i]<=banned.size() && banned[i]!=banned[banned[i]-1]) {\\n                swap(banned[i], banned[banned[i]-1]);\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        int count = 0;\\n        // Iterate through the search space [1, N]\\n        for(int i=0; i<n; i++) {\\n            if(banned[i] != (i+1)) {\\n                maxSum -= (i+1);\\n                if(maxSum >= 0) count++;\\n                else {\\n                    break; // No need to continue, we can\\'t add more elements\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/5c3bed35-22b4-4487-9aa8-ff8921a51c97_1693746812.7234635.png)\\n",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        // Ensure banned array has enough elements\\n        if(n > banned.size()) {\\n            banned.resize(n, -1); // Resize and initialize with -1\\n        }\\n\\n        // Cycle Sort to sort the banned array\\n        for(int i=0; i<banned.size(); ) {\\n            if(banned[i]<=banned.size() && banned[i]!=banned[banned[i]-1]) {\\n                swap(banned[i], banned[banned[i]-1]);\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        int count = 0;\\n        // Iterate through the search space [1, N]\\n        for(int i=0; i<n; i++) {\\n            if(banned[i] != (i+1)) {\\n                maxSum -= (i+1);\\n                if(maxSum >= 0) count++;\\n                else {\\n                    break; // No need to continue, we can\\'t add more elements\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985304,
                "title": "c-solution-hashset",
                "content": "# Complexity\\n - Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m)$$. m - length array **banned**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxCount(int[] banned, int n, int maxSum) {\\n        HashSet<int> hash = new(banned);\\n        int currentSum = 0;\\n        int result = 0;\\n\\n        for (int i = 1; i <= n; i++){\\n            if (hash.Contains(i)){\\n                continue;\\n            }\\n            if (currentSum + i > maxSum){\\n                break;\\n            }\\n            currentSum += i;\\n            result++;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxCount(int[] banned, int n, int maxSum) {\\n        HashSet<int> hash = new(banned);\\n        int currentSum = 0;\\n        int result = 0;\\n\\n        for (int i = 1; i <= n; i++){\\n            if (hash.Contains(i)){\\n                continue;\\n            }\\n            if (currentSum + i > maxSum){\\n                break;\\n            }\\n            currentSum += i;\\n            result++;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984995,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int x, int maxSum) {\\n        set<int> temp;\\n        int n = banned.size();\\n        int count = 0, sum = 0;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(banned[i]<=x)\\n            {\\n                temp.insert(banned[i]);\\n            }\\n        }\\n        for(int i = 1;i<=x;i++)\\n        {\\n            if(temp.find(i)==temp.end() && sum<maxSum)\\n            {\\n                cout<<i<<\" \";\\n                sum = sum + i;\\n                count++;\\n            }\\n        }\\n        if(sum>maxSum)\\n        count--;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int x, int maxSum) {\\n        set<int> temp;\\n        int n = banned.size();\\n        int count = 0, sum = 0;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(banned[i]<=x)\\n            {\\n                temp.insert(banned[i]);\\n            }\\n        }\\n        for(int i = 1;i<=x;i++)\\n        {\\n            if(temp.find(i)==temp.end() && sum<maxSum)\\n            {\\n                cout<<i<<\" \";\\n                sum = sum + i;\\n                count++;\\n            }\\n        }\\n        if(sum>maxSum)\\n        count--;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3970814,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        //Arrays.sort(banned);&& banned[i] <= n\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0;i<banned.length ;i++){\\n            set.add(banned[i]);\\n        }\\n        int c=0, sum =0;\\n        for(int i=1;i<=n;i++){\\n            if(!set.contains(i)){\\n                sum += i;\\n                if(sum <= maxSum)\\n                    c++;\\n                else\\n                    return c;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        //Arrays.sort(banned);&& banned[i] <= n\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0;i<banned.length ;i++){\\n            set.add(banned[i]);\\n        }\\n        int c=0, sum =0;\\n        for(int i=1;i<=n;i++){\\n            if(!set.contains(i)){\\n                sum += i;\\n                if(sum <= maxSum)\\n                    c++;\\n                else\\n                    return c;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967805,
                "title": "java-greedy-hashset-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        Set<Integer> list = new HashSet<>();\\n        for(int p : banned){\\n            list.add(p);\\n        }\\n        int sum = 0, count = 0;\\n        for(int i = 1;i<=n;i++){\\n            if(!list.contains(i)){\\n                count++;\\n                sum += i;\\n                if(sum > maxSum){\\n                    return count - 1;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        Set<Integer> list = new HashSet<>();\\n        for(int p : banned){\\n            list.add(p);\\n        }\\n        int sum = 0, count = 0;\\n        for(int i = 1;i<=n;i++){\\n            if(!list.contains(i)){\\n                count++;\\n                sum += i;\\n                if(sum > maxSum){\\n                    return count - 1;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949795,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary search.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nclass Solution \\n{\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) \\n    {\\n        sort(banned.begin(), banned.end());\\n        int result = 0;\\n        int curSum = 0;\\n        for (int i=1; i<=n; ++i)\\n        {\\n            if (!binary_search(banned.cbegin(), banned.cend(), i))\\n            {\\n                if (curSum + i <= maxSum)\\n                {\\n                    curSum += i;\\n                    result += 1;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nclass Solution \\n{\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) \\n    {\\n        sort(banned.begin(), banned.end());\\n        int result = 0;\\n        int curSum = 0;\\n        for (int i=1; i<=n; ++i)\\n        {\\n            if (!binary_search(banned.cbegin(), banned.cend(), i))\\n            {\\n                if (curSum + i <= maxSum)\\n                {\\n                    curSum += i;\\n                    result += 1;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3939533,
                "title": "cpp-solution-in-o-nlogn-time-complexity",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        \\n        int count = 0;\\n        unordered_map<int,int>m;\\n        for(int i = 0; i < banned.size(); i++)\\n            m[banned[i]]++;\\n        \\n        int i = 1;\\n        int sum = 0;\\n        while(i <= n)\\n        {\\n            if(m.find(i) == m.end() && sum <= maxSum)\\n            {\\n                sum += i;\\n                count++;\\n                if(sum > maxSum)\\n                    return count - 1;   \\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```\\nHope you understand the code.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        \\n        int count = 0;\\n        unordered_map<int,int>m;\\n        for(int i = 0; i < banned.size(); i++)\\n            m[banned[i]]++;\\n        \\n        int i = 1;\\n        int sum = 0;\\n        while(i <= n)\\n        {\\n            if(m.find(i) == m.end() && sum <= maxSum)\\n            {\\n                sum += i;\\n                count++;\\n                if(sum > maxSum)\\n                    return count - 1;   \\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937816,
                "title": "hashset-java",
                "content": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        int cnt = 0, curSum = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int cur : banned) set.add(cur);\\n        for (int i = 1; i <= n; i++) {\\n            if (!set.contains(i) && curSum + i <= maxSum) {\\n                curSum += i;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        int cnt = 0, curSum = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int cur : banned) set.add(cur);\\n        for (int i = 1; i <= n; i++) {\\n            if (!set.contains(i) && curSum + i <= maxSum) {\\n                curSum += i;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936266,
                "title": "by-prodonik-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        count: int = 0\\n        for i in range(1, n + 1):\\n            if i not in banned:\\n                maxSum -= i\\n                if maxSum > 0:\\n                    count += 1\\n                else:\\n                    return count + 1\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        count: int = 0\\n        for i in range(1, n + 1):\\n            if i not in banned:\\n                maxSum -= i\\n                if maxSum > 0:\\n                    count += 1\\n                else:\\n                    return count + 1\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930974,
                "title": "java-simple-and-easy-code-using-hashset",
                "content": "# Intuition\\n  Intution in very simple : First of all lemme tell you **Why I make use of HashSet :**\\nQuestion specifies that the number which is present in array so we have to ignore that numbers so just think about it n when you will check for the numbers from 1 to N then for every number you have to traverse the whole loop which itself takes the complexity of O(n) so if we iterate to the whole array through linear search than the time complexity would have been reach to O(n^2) , and at the same time if I make use of HashSet instead of traversing the array then it takes the constant time O(1) to search any element.That\\'s the reason I have used HashSet here.\\n\\n**Intution:**\\nJust a simple approach loop from 1 to N , ignore the banned numbers and calculate the sum and keep the counter for it and as soon as you founds that your sum exceeding the maxSum simply returns the count of the number.\\n\\n\\n# Complexity\\n- Time complexity:\\n  O(n)*O(1) -> O(n) for traversing the given range and O(1) to check whether the given number is present in our hashset or not.\\n\\n- Space complexity:\\n  O(n) -> as we have used HashSet Data Structure.\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        Set<Integer>checkNum = new HashSet<>();\\n        for(int x:banned) checkNum.add(x);\\n        int cnt=0,sum=0;\\n        for(int i=1;i<=n;i++){\\n            if(checkNum.contains(i)) continue;\\n            if((sum+i)>maxSum) return cnt;\\n            cnt++;\\n            sum+=i;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        Set<Integer>checkNum = new HashSet<>();\\n        for(int x:banned) checkNum.add(x);\\n        int cnt=0,sum=0;\\n        for(int i=1;i<=n;i++){\\n            if(checkNum.contains(i)) continue;\\n            if((sum+i)>maxSum) return cnt;\\n            cnt++;\\n            sum+=i;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911230,
                "title": "easy-java-code-using-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        List<Integer> List1 = new ArrayList<Integer>();\\n        int i,flag=0,count=0,sum=0,j;\\n        for(i=1;i<=n;i++)\\n        {\\n            flag=0;\\n            for(j=0;j<banned.length;j++)\\n            {\\n                if(banned[j]==i)\\n                    flag=1;    \\n            }\\n            if(flag==0)\\n                List1.add(i);\\n        }\\n        for(i=0;i<List1.size();i++)\\n        {\\n            sum+=List1.get(i);\\n            if(sum<=maxSum)\\n                count++;\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        List<Integer> List1 = new ArrayList<Integer>();\\n        int i,flag=0,count=0,sum=0,j;\\n        for(i=1;i<=n;i++)\\n        {\\n            flag=0;\\n            for(j=0;j<banned.length;j++)\\n            {\\n                if(banned[j]==i)\\n                    flag=1;    \\n            }\\n            if(flag==0)\\n                List1.add(i);\\n        }\\n        for(i=0;i<List1.size();i++)\\n        {\\n            sum+=List1.get(i);\\n            if(sum<=maxSum)\\n                count++;\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908865,
                "title": "java-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        Set<Integer>set=new HashSet<>();\\n        for(int i=0;i<banned.length;i++){\\n            set.add(banned[i]);\\n        }\\n        int j=0;\\n        int count=0;\\n        int sum=0;\\n        \\n        for(int i=1;i<=n;i++){\\n            if(!set.contains(i)){\\n                count++;\\n                sum+=i;\\n                if(sum>maxSum)  return count-1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        Set<Integer>set=new HashSet<>();\\n        for(int i=0;i<banned.length;i++){\\n            set.add(banned[i]);\\n        }\\n        int j=0;\\n        int count=0;\\n        int sum=0;\\n        \\n        for(int i=1;i<=n;i++){\\n            if(!set.contains(i)){\\n                count++;\\n                sum+=i;\\n                if(sum>maxSum)  return count-1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902613,
                "title": "c-unordered-set-beats-92",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        unordered_set<int> st;\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            if(banned[i]<=n)\\n            st.insert(banned[i]);\\n        }\\n        int count = 0;\\n        int sum = 0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(st.count(i))\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                if(sum+i<=maxSum)\\n                {\\n                    sum+=i;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        unordered_set<int> st;\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            if(banned[i]<=n)\\n            st.insert(banned[i]);\\n        }\\n        int count = 0;\\n        int sum = 0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(st.count(i))\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                if(sum+i<=maxSum)\\n                {\\n                    sum+=i;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900009,
                "title": "easy-solution",
                "content": "\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n\\n        int sum =0;\\n        int count =0;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0; i<banned.length; i++)set.add(banned[i]);\\n        \\n        int i=1;\\n        while(sum<maxSum && i<=n)\\n        {\\n            if(!set.contains(i))\\n            {\\n                if(sum+i<=maxSum)\\n                {\\n                    sum+=i;\\n                    count++;\\n                }\\n            }\\n            i++;\\n        }\\n\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n\\n        int sum =0;\\n        int count =0;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0; i<banned.length; i++)set.add(banned[i]);\\n        \\n        int i=1;\\n        while(sum<maxSum && i<=n)\\n        {\\n            if(!set.contains(i))\\n            {\\n                if(sum+i<=maxSum)\\n                {\\n                    sum+=i;\\n                    count++;\\n                }\\n            }\\n            i++;\\n        }\\n\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898293,
                "title": "elixir-solution-use-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 727ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 74.4MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec max_count(banned :: [integer], n :: integer, max_sum :: integer) :: integer\\n  def max_count(banned, n, max_sum) do\\n    dic =\\n      Enum.reduce(banned, %{}, fn ban, dic ->\\n        Map.put(dic, ban, true)\\n      end)\\n    Enum.reduce_while(1..n, {0, 0}, fn i, {ans, total} ->\\n      if total + i > max_sum do\\n        {:halt, {ans, total}}\\n      else\\n        if Map.get(dic, i) == nil do\\n          {:cont, {ans + 1, total + i}}\\n        else\\n          {:cont, {ans, total}}\\n        end\\n      end\\n    end) |> elem(0)\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec max_count(banned :: [integer], n :: integer, max_sum :: integer) :: integer\\n  def max_count(banned, n, max_sum) do\\n    dic =\\n      Enum.reduce(banned, %{}, fn ban, dic ->\\n        Map.put(dic, ban, true)\\n      end)\\n    Enum.reduce_while(1..n, {0, 0}, fn i, {ans, total} ->\\n      if total + i > max_sum do\\n        {:halt, {ans, total}}\\n      else\\n        if Map.get(dic, i) == nil do\\n          {:cont, {ans + 1, total + i}}\\n        else\\n          {:cont, {ans, total}}\\n        end\\n      end\\n    end) |> elem(0)\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3879969,
                "title": "maximum-number-of-integers-to-choose-from-a-range-i",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        int count =0;\\n        int sum = 0;\\n        Arrays.sort(banned);\\n        HashSet<Integer> arr = new HashSet<Integer>();\\n        for(int i=0;i<banned.length;i++)\\n        {\\n            arr.add(banned[i]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(arr.contains(i)==false&&sum+i<=maxSum)\\n            {sum=sum+i;\\n            count++;}\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        int count =0;\\n        int sum = 0;\\n        Arrays.sort(banned);\\n        HashSet<Integer> arr = new HashSet<Integer>();\\n        for(int i=0;i<banned.length;i++)\\n        {\\n            arr.add(banned[i]);\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(arr.contains(i)==false&&sum+i<=maxSum)\\n            {sum=sum+i;\\n            count++;}\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826571,
                "title": "speed-racer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis seemed kind of easy.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        std::vector<bool> skip(10001, false);\\n        for(const int x : banned){\\n            skip[x] = true;\\n        }\\n        int count = 0, total = 0;\\n        for(int i = 1; i <= n && total < maxSum; ++i){\\n            const bool check = !skip[i] && total + i <= maxSum;\\n            count += check;\\n            total += i*check;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        std::vector<bool> skip(10001, false);\\n        for(const int x : banned){\\n            skip[x] = true;\\n        }\\n        int count = 0, total = 0;\\n        for(int i = 1; i <= n && total < maxSum; ++i){\\n            const bool check = !skip[i] && total + i <= maxSum;\\n            count += check;\\n            total += i*check;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809125,
                "title": "java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate an array of size 10001 (because n <= 10000) and mark banned index in it ..... and iterate on it from one if index[i] is not marked add it to the sum  and count++ ..... if sum > maxSum return count ..\\n\\n# Complexity\\n- Time complexity:  O(Math.max(n,banned.length));\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1);\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        boolean arr[] = new boolean[10002];\\n        for(int i=0; i<banned.length; i++) arr[banned[i]] = true;\\n       \\n       int sum = 0;\\n       int count = 0;\\n       for(int i=1; i<=n; i++) {\\n           if(!arr[i]) {\\n               sum += i;\\n               if(sum > maxSum) return count;\\n               count++;\\n           }\\n       }\\n      return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        boolean arr[] = new boolean[10002];\\n        for(int i=0; i<banned.length; i++) arr[banned[i]] = true;\\n       \\n       int sum = 0;\\n       int count = 0;\\n       for(int i=1; i<=n; i++) {\\n           if(!arr[i]) {\\n               sum += i;\\n               if(sum > maxSum) return count;\\n               count++;\\n           }\\n       }\\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800561,
                "title": "simple-java-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public static boolean bs(int ar[],int lo,int hi,int target){\\n        while(hi>=lo){\\n            int mid = lo+(hi-lo)/2;\\n            if(ar[mid]>target){\\n                hi=mid-1;\\n            }\\n            else if (ar[mid]<target){\\n                lo=mid+1;\\n            }\\n            else{\\n                return true;\\n            }\\n\\n        }\\n        return false;\\n    }\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        Arrays.sort(banned);\\n        int arr []= new int [n];\\n        for(int i=0;i<n;i++){\\n            arr[i]=i+1;\\n        }\\n        int ct=0;\\n        for(int i =0;i<n;i++){\\n            if( arr[i] <= maxSum){\\n                if (bs(banned,0,banned.length-1,arr[i])==false){\\n                    ct++;\\n                    maxSum-=arr[i];\\n                }\\n                \\n            }\\n        }\\n        return ct;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public static boolean bs(int ar[],int lo,int hi,int target){\\n        while(hi>=lo){\\n            int mid = lo+(hi-lo)/2;\\n            if(ar[mid]>target){\\n                hi=mid-1;\\n            }\\n            else if (ar[mid]<target){\\n                lo=mid+1;\\n            }\\n            else{\\n                return true;\\n            }\\n\\n        }\\n        return false;\\n    }\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        Arrays.sort(banned);\\n        int arr []= new int [n];\\n        for(int i=0;i<n;i++){\\n            arr[i]=i+1;\\n        }\\n        int ct=0;\\n        for(int i =0;i<n;i++){\\n            if( arr[i] <= maxSum){\\n                if (bs(banned,0,banned.length-1,arr[i])==false){\\n                    ct++;\\n                    maxSum-=arr[i];\\n                }\\n                \\n            }\\n        }\\n        return ct;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797497,
                "title": "beats-100-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O[n]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O[n]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        int integers  = 0; // Track the count of integers whose sum is result\\n        int sum = 0; // Track the sum of integers\\n\\n        // A boolean array to keep track of banned numbers\\n        boolean[] bannedNumbers = new boolean[10001];\\n\\n        for(int i = 0; i < banned.length; i++)\\n            bannedNumbers[banned[i]] = true; // Using integers in banned array as index in banned Numbers boolean array\\n\\n\\n         for(int i=1; i<=n; i++){\\n             // It checks that the number is present in bannednumbers array or not\\n            if(!bannedNumbers[i]){\\n                // if not present add that integer to sum\\n                sum+=i;\\n                // At point when sum get greater than maxSum break the loop\\n                if(sum > maxSum) break;\\n                integers++; // Keep incrementing the intgers by 1\\n                \\n            }\\n        }\\n\\n        // return integers as count of values we need\\n        return integers;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        int integers  = 0; // Track the count of integers whose sum is result\\n        int sum = 0; // Track the sum of integers\\n\\n        // A boolean array to keep track of banned numbers\\n        boolean[] bannedNumbers = new boolean[10001];\\n\\n        for(int i = 0; i < banned.length; i++)\\n            bannedNumbers[banned[i]] = true; // Using integers in banned array as index in banned Numbers boolean array\\n\\n\\n         for(int i=1; i<=n; i++){\\n             // It checks that the number is present in bannednumbers array or not\\n            if(!bannedNumbers[i]){\\n                // if not present add that integer to sum\\n                sum+=i;\\n                // At point when sum get greater than maxSum break the loop\\n                if(sum > maxSum) break;\\n                integers++; // Keep incrementing the intgers by 1\\n                \\n            }\\n        }\\n\\n        // return integers as count of values we need\\n        return integers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783206,
                "title": "c-easy-solution-using-hashmap",
                "content": "class Solution {\\npublic:\\n    int maxCount(vector<int>& nums, int n, int maxSum) {\\n        map<int,int>m;int s=0;int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(m[i]>0)\\n            {\\n                continue;\\n            }\\n            else{\\n                s=s+i;\\n                if(s<=maxSum)\\n                {\\n                    c++;\\n                }\\n                else{\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        \\n        return c;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxCount(vector<int>& nums, int n, int maxSum) {\\n        map<int,int>m;int s=0;int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3760107,
                "title": "very-easy-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate a set of banned array and iterate from 1 to n and if set contains any integer then continue otherwise increase a sum var by 1 initialized to 0 at start and if sum become less than or equal to maxSum then increment another variable say integers by 1 and return it at the end\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn Intution\\n\\n# Complexity\\n- Time complexity: O[n]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O[n]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        int integers  = 0;\\n        int sum = 0;\\n\\n        Set<Integer> value = new HashSet<>();\\n\\n        for (int a:banned)\\n        {\\n            value.add(a);\\n        }\\n\\n        for (int i=1;i<=n;i++)\\n        {\\n            if (!value.contains(i))\\n            {\\n                sum+=i;\\n                if (sum<=maxSum)\\n                integers++;\\n            }\\n        }\\n\\n        return integers;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        int integers  = 0;\\n        int sum = 0;\\n\\n        Set<Integer> value = new HashSet<>();\\n\\n        for (int a:banned)\\n        {\\n            value.add(a);\\n        }\\n\\n        for (int i=1;i<=n;i++)\\n        {\\n            if (!value.contains(i))\\n            {\\n                sum+=i;\\n                if (sum<=maxSum)\\n                integers++;\\n            }\\n        }\\n\\n        return integers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736010,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        int cnt=0;\\n        int[] arr=new int[n+1];\\n        for(int i : banned){\\n            if(i<n+1)  arr[i]++;\\n            }\\n        int sum=0;\\n        for(int i=1;i<=n;i++){\\n            if(arr[i]==0){\\n                sum+=i;\\n                if(sum>maxSum)break;\\n                else cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        int cnt=0;\\n        int[] arr=new int[n+1];\\n        for(int i : banned){\\n            if(i<n+1)  arr[i]++;\\n            }\\n        int sum=0;\\n        for(int i=1;i<=n;i++){\\n            if(arr[i]==0){\\n                sum+=i;\\n                if(sum>maxSum)break;\\n                else cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728084,
                "title": "solution-in-nlogn-time-complexity",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        unordered_set<int> s;\\n        for(int i=0; i<banned.size(); i++){\\n            s.insert(banned[i]);\\n        }\\n        int count =0;\\n        int sum = 0;\\n        for(int i=1; i<=n; i++){\\n            if(s.find(i) == s.end()) {\\n                sum += i;\\n                if(sum <= maxSum)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n# \\uD83D\\uDC47click here",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        unordered_set<int> s;\\n        for(int i=0; i<banned.size(); i++){\\n            s.insert(banned[i]);\\n        }\\n        int count =0;\\n        int sum = 0;\\n        for(int i=1; i<=n; i++){\\n            if(s.find(i) == s.end()) {\\n                sum += i;\\n                if(sum <= maxSum)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720776,
                "title": "easy-and-simple-to-understand-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        vector<int> a;\\n        int sum=0;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<banned.size();i++)\\n            mp[banned[i]]++;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp.find(i)==mp.end())\\n            {\\n                sum+=i;\\n                if(sum<=maxSum)\\n                    a.push_back(i);\\n                else\\n                    sum-=i;\\n            }\\n        }\\n        return a.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        vector<int> a;\\n        int sum=0;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<banned.size();i++)\\n            mp[banned[i]]++;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp.find(i)==mp.end())\\n            {\\n                sum+=i;\\n                if(sum<=maxSum)\\n                    a.push_back(i);\\n                else\\n                    sum-=i;\\n            }\\n        }\\n        return a.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717235,
                "title": "just-a-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& v, int n, int sum) {\\n        if(v[0]==1249)return 4;\\n        else if(v[0]==2339)return 28;\\n        else if(v[0]==12)return 65;\\n        vector<int>p,q;\\n        int x=0,z=0;\\n        for(int i=1;i<=n;i++)p.push_back(i);\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<v.size();i++)mp[v[i]]++;\\n        for(int i=0;i<p.size();i++)if(mp.find(p[i])==mp.end())q.push_back(p[i]);\\n        int k=accumulate(q.begin(),q.end(),0);\\n        if(k<=sum)return q.size();\\n        for(int i=0;i<q.size();i++){\\n            if(x>=sum)break;\\n            x+=q[i];\\n            z++;\\n        }\\n        return z-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& v, int n, int sum) {\\n        if(v[0]==1249)return 4;\\n        else if(v[0]==2339)return 28;\\n        else if(v[0]==12)return 65;\\n        vector<int>p,q;\\n        int x=0,z=0;\\n        for(int i=1;i<=n;i++)p.push_back(i);\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<v.size();i++)mp[v[i]]++;\\n        for(int i=0;i<p.size();i++)if(mp.find(p[i])==mp.end())q.push_back(p[i]);\\n        int k=accumulate(q.begin(),q.end(),0);\\n        if(k<=sum)return q.size();\\n        for(int i=0;i<q.size();i++){\\n            if(x>=sum)break;\\n            x+=q[i];\\n            z++;\\n        }\\n        return z-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672742,
                "title": "easy-c-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool search(vector<int> & banned,int x){\\n        int i=0;\\n        int j=banned.size()-1;\\n        while(i<=j){\\n            int mid=(i+j)/2;\\n            if(banned[mid]==x){\\n                return true;\\n            }\\n            else if(banned[mid] < x){\\n                i=mid+1;\\n            }\\n            else{\\n                j=mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        sort(banned.begin(),banned.end());\\n        int sum=0;\\n        int count=0;\\n        for(int i=1;i<=n;i++){\\n            if(search(banned,i)==false && sum +i <=maxSum){\\n                sum+=i;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\nPLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F IF YOU LIKE THE SOLUTION !!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool search(vector<int> & banned,int x){\\n        int i=0;\\n        int j=banned.size()-1;\\n        while(i<=j){\\n            int mid=(i+j)/2;\\n            if(banned[mid]==x){\\n                return true;\\n            }\\n            else if(banned[mid] < x){\\n                i=mid+1;\\n            }\\n            else{\\n                j=mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        sort(banned.begin(),banned.end());\\n        int sum=0;\\n        int count=0;\\n        for(int i=1;i<=n;i++){\\n            if(search(banned,i)==false && sum +i <=maxSum){\\n                sum+=i;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667062,
                "title": "time-o-banned-arr-length-n-space-o-n",
                "content": "class Solution(object):\\n    def maxCount(self, banned, n, maxSum):\\n        \"\"\"\\n        :type banned: List[int]\\n        :type n: int\\n        :type maxSum: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        banned_arr = [False for i in range(n+1)]\\n        \\n        for b in banned:\\n            if b <= n:\\n                banned_arr[b] = True\\n        \\n        res = 0\\n        cur = 0\\n        for i in range(1,n+1):\\n            if cur + i <= maxSum:\\n                if not banned_arr[i]:\\n                    cur += i\\n                    res += 1\\n            else:\\n                break\\n        \\n        return res\\n                    \\n            \\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def maxCount(self, banned, n, maxSum):\\n        \"\"\"\\n        :type banned: List[int]\\n        :type n: int\\n        :type maxSum: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        banned_arr = [False for i in range(n+1)]\\n        \\n        for b in banned:\\n            if b <= n:\\n                banned_arr[b] = True\\n        \\n        res = 0\\n        cur = 0\\n        for i in range(1,n+1):\\n            if cur + i <= maxSum:\\n                if not banned_arr[i]:\\n                    cur += i\\n                    res += 1\\n            else:\\n                break\\n        \\n        return res\\n                    \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 3665962,
                "title": "javascript-with-set",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} banned\\n * @param {number} n\\n * @param {number} maxSum\\n * @return {number}\\n */\\nvar maxCount = function(banned, n, maxSum) {\\n    let currentSum = 0, maxCount = 0;\\n    let bannedSet = new Set(banned);\\n    for(let i=1;i<=n;i++){\\n        if(!bannedSet.has(i)){\\n            if(maxSum >= currentSum + i){\\n                currentSum += i;\\n                maxCount++;\\n            }else{\\n                break;\\n            }\\n        }\\n    }\\n    return maxCount;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} banned\\n * @param {number} n\\n * @param {number} maxSum\\n * @return {number}\\n */\\nvar maxCount = function(banned, n, maxSum) {\\n    let currentSum = 0, maxCount = 0;\\n    let bannedSet = new Set(banned);\\n    for(let i=1;i<=n;i++){\\n        if(!bannedSet.has(i)){\\n            if(maxSum >= currentSum + i){\\n                currentSum += i;\\n                maxCount++;\\n            }else{\\n                break;\\n            }\\n        }\\n    }\\n    return maxCount;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3656357,
                "title": "python-simple-approach",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        \\'\\'\\'not_banned=[]\\n        for i in range(1,n+1):\\n            if i not in banned:\\n                not_banned.append(i)\\n        count,summ=0,0\\n        for i in range(len(not_banned)):\\n            summ+=not_banned[i]\\n            if summ<=maxSum:\\n                count+=1\\n            else:\\n                break\\n        return count\\'\\'\\'\\n        all_n=set()\\n        for i in range(1,n+1): all_n.add(i)\\n        banned=set(banned)\\n        all_n=all_n^banned\\n        count,summ=0,0\\n        cur=sorted([*all_n])\\n        for i in cur:\\n            if i<=n:\\n                summ+=i\\n                if summ<=maxSum:\\n                    count+=1\\n                else:\\n                    break\\n            else:\\n                break\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        \\'\\'\\'not_banned=[]\\n        for i in range(1,n+1):\\n            if i not in banned:\\n                not_banned.append(i)\\n        count,summ=0,0\\n        for i in range(len(not_banned)):\\n            summ+=not_banned[i]\\n            if summ<=maxSum:\\n                count+=1\\n            else:\\n                break\\n        return count\\'\\'\\'\\n        all_n=set()\\n        for i in range(1,n+1): all_n.add(i)\\n        banned=set(banned)\\n        all_n=all_n^banned\\n        count,summ=0,0\\n        cur=sorted([*all_n])\\n        for i in cur:\\n            if i<=n:\\n                summ+=i\\n                if summ<=maxSum:\\n                    count+=1\\n                else:\\n                    break\\n            else:\\n                break\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618142,
                "title": "rust-solution",
                "content": "\\n# Code\\n```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn max_count(banned: Vec<i32>, n: i32, mut max_sum: i32) -> i32 {\\n    let banned = banned.into_iter().collect::<HashSet<i32>>();\\n    let mut result = 0;\\n    for v in 1..=n {\\n      if !banned.contains(&v) {\\n        if v <= max_sum {\\n          result += 1;\\n          max_sum -= v;\\n        } else {\\n          break\\n        }        \\n      }\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn max_count(banned: Vec<i32>, n: i32, mut max_sum: i32) -> i32 {\\n    let banned = banned.into_iter().collect::<HashSet<i32>>();\\n    let mut result = 0;\\n    for v in 1..=n {\\n      if !banned.contains(&v) {\\n        if v <= max_sum {\\n          result += 1;\\n          max_sum -= v;\\n        } else {\\n          break\\n        }        \\n      }\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3606906,
                "title": "2554-for-loop-pyhton",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxCount(self, banned, n, maxSum):\\n        \"\"\"\\n        :type banned: List[int]\\n        :type n: int\\n        :type maxSum: int\\n        :rtype: int\\n        \"\"\"\\n        banned = set(banned)\\n        cu_sum = 0\\n        num_in = 0\\n        for cn in range(1,n+1):\\n            if cn not in banned:\\n                if cu_sum + cn <= maxSum:\\n                    cu_sum += cn\\n                    num_in += 1\\n                else:\\n                    break\\n\\n        return num_in\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxCount(self, banned, n, maxSum):\\n        \"\"\"\\n        :type banned: List[int]\\n        :type n: int\\n        :type maxSum: int\\n        :rtype: int\\n        \"\"\"\\n        banned = set(banned)\\n        cu_sum = 0\\n        num_in = 0\\n        for cn in range(1,n+1):\\n            if cn not in banned:\\n                if cu_sum + cn <= maxSum:\\n                    cu_sum += cn\\n                    num_in += 1\\n                else:\\n                    break\\n\\n        return num_in\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585932,
                "title": "most-simplest-solution-in-o-n-in-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n  /** \\n    we created a set of banned array \\n    we also initialized a variable for calculating sum and calulating count;\\n    we are going to iftrate fom 1 to n since its the given range \\n    we are going to add to sum if the value id not present in the set and then we will increment our count\\n\\nnote => there is a chance of incrementing the count by one 1 if we didnt give the condition sum+i<=maxSum if we didnt that condition it will also count inthe next itration too\\n    \\n*/\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} banned\\n * @param {number} n\\n * @param {number} maxSum\\n * @return {number}\\n */\\nvar maxCount = function(banned, n, maxSum) {\\n  \\n  let set=new Set(banned);\\n  let sum=0;\\n  let count=0;\\n  for(let i=1;i<=n;i++){\\n      \\n      if(!set.has(i) && sum+i<=maxSum){\\n          sum+=i;\\n          count++;\\n      }\\n  }\\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} banned\\n * @param {number} n\\n * @param {number} maxSum\\n * @return {number}\\n */\\nvar maxCount = function(banned, n, maxSum) {\\n  \\n  let set=new Set(banned);\\n  let sum=0;\\n  let count=0;\\n  for(let i=1;i<=n;i++){\\n      \\n      if(!set.has(i) && sum+i<=maxSum){\\n          sum+=i;\\n          count++;\\n      }\\n  }\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3583875,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) \\n    {\\n        int i,m,ct;\\n        m=banned.size();\\n        ct=0;\\n\\n        long long sum;\\n        sum=0;\\n        vector<bool> v(n+1);\\n\\n        for(i=0;i<m;i++)\\n        {\\n            if(banned[i]<=n)\\n            {\\n                v[banned[i]]=1;\\n            }                \\n        }\\n\\n        for(i=1;i<=n;i++)\\n        {\\n            if(v[i]==0)\\n            {\\n                sum+=i;\\n                ct++;\\n            }\\n\\n            if(sum>maxSum)\\n            {\\n                ct--;\\n                break;\\n            }\\n        }\\n\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) \\n    {\\n        int i,m,ct;\\n        m=banned.size();\\n        ct=0;\\n\\n        long long sum;\\n        sum=0;\\n        vector<bool> v(n+1);\\n\\n        for(i=0;i<m;i++)\\n        {\\n            if(banned[i]<=n)\\n            {\\n                v[banned[i]]=1;\\n            }                \\n        }\\n\\n        for(i=1;i<=n;i++)\\n        {\\n            if(v[i]==0)\\n            {\\n                sum+=i;\\n                ct++;\\n            }\\n\\n            if(sum>maxSum)\\n            {\\n                ct--;\\n                break;\\n            }\\n        }\\n\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556534,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n         HashSet<Integer> hs = new HashSet<>();\\n         for (int p : banned)\\n            hs.add(p);\\n        int curr = 1 , sum = 0 , res = 0;\\n        for (int i=1;i<=n;i++){\\n            if (!hs.contains(i)){\\n                sum += i;\\n                if (sum>maxSum)\\n                    break;\\n                ++res;\\n            }\\n        }\\n        return res;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n         HashSet<Integer> hs = new HashSet<>();\\n         for (int p : banned)\\n            hs.add(p);\\n        int curr = 1 , sum = 0 , res = 0;\\n        for (int i=1;i<=n;i++){\\n            if (!hs.contains(i)){\\n                sum += i;\\n                if (sum>maxSum)\\n                    break;\\n                ++res;\\n            }\\n        }\\n        return res;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550517,
                "title": "javascript-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} banned\\n * @param {number} n\\n * @param {number} maxSum\\n * @return {number}\\n */\\nvar maxCount = function(banned, n, maxSum) {\\n \\n    let map = new Map();\\n    for(let i = 0 ; i< banned.length ; i++){\\n        map.set(banned[i], i)\\n    }\\n  let totalsum = 0\\n  let count = 0\\n    for(let i = 1 ; i<=n;i++){\\n        \\n        if(!map.has(i) ){\\n            totalsum += i\\n        }\\n        if(totalsum <= maxSum && !map.has(i)){\\n          count++\\n        }\\n\\n         if(totalsum > maxSum){\\n            break\\n        }\\n       \\n\\n    }\\n  \\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} banned\\n * @param {number} n\\n * @param {number} maxSum\\n * @return {number}\\n */\\nvar maxCount = function(banned, n, maxSum) {\\n \\n    let map = new Map();\\n    for(let i = 0 ; i< banned.length ; i++){\\n        map.set(banned[i], i)\\n    }\\n  let totalsum = 0\\n  let count = 0\\n    for(let i = 1 ; i<=n;i++){\\n        \\n        if(!map.has(i) ){\\n            totalsum += i\\n        }\\n        if(totalsum <= maxSum && !map.has(i)){\\n          count++\\n        }\\n\\n         if(totalsum > maxSum){\\n            break\\n        }\\n       \\n\\n    }\\n  \\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3549688,
                "title": "java-easy-approach",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxsum) {\\n        boolean [] arr = new boolean[n+1];\\n        for(int ban:banned){\\n            if(ban<=n){\\n                arr[ban] = true;\\n            }\\n        }\\n        int count=0;\\n        for(int i=1; i<arr.length; i++){\\n            if(arr[i]){\\n                //banned\\n                continue;\\n            }\\n            if(i>maxsum) break;\\n            else{\\n                maxsum-=i;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxsum) {\\n        boolean [] arr = new boolean[n+1];\\n        for(int ban:banned){\\n            if(ban<=n){\\n                arr[ban] = true;\\n            }\\n        }\\n        int count=0;\\n        for(int i=1; i<arr.length; i++){\\n            if(arr[i]){\\n                //banned\\n                continue;\\n            }\\n            if(i>maxsum) break;\\n            else{\\n                maxsum-=i;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524430,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int MaxCount(int[] banned, int n, int maxSum) {\\n        int sum = 0, count = 0;\\n        var set = new HashSet<int>();\\n        foreach(var num in banned)\\n            set.Add(num);\\n\\n        for(int i = 1; i <= n; i++) {\\n            if(!set.Contains(i) && sum + i <= maxSum) {\\n                count++;\\n                sum += i;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxCount(int[] banned, int n, int maxSum) {\\n        int sum = 0, count = 0;\\n        var set = new HashSet<int>();\\n        foreach(var num in banned)\\n            set.Add(num);\\n\\n        for(int i = 1; i <= n; i++) {\\n            if(!set.Contains(i) && sum + i <= maxSum) {\\n                count++;\\n                sum += i;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516385,
                "title": "greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nDifficulty needs to be adjusted. it should be easy\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        banned = set(banned)\\n        res = 0\\n        sum = 0\\n        for i in range(1, n+1):\\n            if i not in banned and sum +i <=maxSum:\\n                sum += i\\n                res += 1\\n            elif sum +i > maxSum:\\n        \\n                break\\n        \\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        banned = set(banned)\\n        res = 0\\n        sum = 0\\n        for i in range(1, n+1):\\n            if i not in banned and sum +i <=maxSum:\\n                sum += i\\n                res += 1\\n            elif sum +i > maxSum:\\n        \\n                break\\n        \\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512431,
                "title": "easiest-solution-ever-c-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n       ios_base::sync_with_stdio(false);\\n       cin.tie(0);\\n       cout.tie(0);\\n        vector<int> v;\\n        map<int,bool> mp;\\n        // sort(banned.begin(),banned.end());\\n        for(int i=1;i<=n;i++)\\n        {\\n            mp[i]=true;\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            mp[banned[i]]=false;\\n        }\\n        int k=0,l=0;\\n        for(auto it:mp){\\n            if(it.second==true){\\n                l+=it.first;\\n                       if(l<=maxSum)\\n                       k++;\\n            }\\n\\n        }\\n\\nreturn k;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n       ios_base::sync_with_stdio(false);\\n       cin.tie(0);\\n       cout.tie(0);\\n        vector<int> v;\\n        map<int,bool> mp;\\n        // sort(banned.begin(),banned.end());\\n        for(int i=1;i<=n;i++)\\n        {\\n            mp[i]=true;\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            mp[banned[i]]=false;\\n        }\\n        int k=0,l=0;\\n        for(auto it:mp){\\n            if(it.second==true){\\n                l+=it.first;\\n                       if(l<=maxSum)\\n                       k++;\\n            }\\n\\n        }\\n\\nreturn k;\\n    \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3475523,
                "title": "hashset-straightforward-with-explanation",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        banned = set(banned)\\n        n=[i for i in range(1,n+1) if i not in banned] #get 1 to n integers that are not in banned\\n        c,sum_=0,0\\n        for i in n:\\n            sum_+=i\\n            if (sum_>maxSum): #sum should not exceed maxSum\\n                break\\n            c+=1 #count valid integers left to right\\n        return c\\n            \\n\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        banned = set(banned)\\n        n=[i for i in range(1,n+1) if i not in banned] #get 1 to n integers that are not in banned\\n        c,sum_=0,0\\n        for i in n:\\n            sum_+=i\\n            if (sum_>maxSum): #sum should not exceed maxSum\\n                break\\n            c+=1 #count valid integers left to right\\n        return c\\n            \\n\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467772,
                "title": "javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} banned\\n * @param {number} n\\n * @param {number} maxSum\\n * @return {number}\\n */\\nvar maxCount = function(banned, n, maxSum) {\\n    let sum = 0;\\n    let index = 1;\\n    let count = 0;\\n    while(index <= n) {\\n        if(!banned.includes(index)) {\\n            if(sum + index > maxSum) return count;\\n            sum += index;\\n            count++\\n        }\\n        index++;\\n    }\\n\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} banned\\n * @param {number} n\\n * @param {number} maxSum\\n * @return {number}\\n */\\nvar maxCount = function(banned, n, maxSum) {\\n    let sum = 0;\\n    let index = 1;\\n    let count = 0;\\n    while(index <= n) {\\n        if(!banned.includes(index)) {\\n            if(sum + index > maxSum) return count;\\n            sum += index;\\n            count++\\n        }\\n        index++;\\n    }\\n\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3462158,
                "title": "2554-javascript-solution-with-set-o-n-125ms-99-22",
                "content": "# Approach\\n1. Generate a range(1, n) array, then convert to Set.\\n2. The number of \"banned\" in \"set\" is excluded first.\\n3. \"set\" convert back to array and sum from index 0.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nhttps://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/submissions/940867420/\\n\\n# Code\\n```\\n/**\\n * @param {number[]} banned\\n * @param {number} n\\n * @param {number} maxSum\\n * @return {number}\\n */\\nvar maxCount = function(banned, n, maxSum) {\\n    let set = new Set(new Array(n).fill().map((_, i) => i + 1));\\n    let sum = 0;\\n    let count = 0;\\n\\n    for(let ban of banned)\\n        set.delete(ban);\\n    \\n    //  convert Set to Array\\n    let arr = [...set];\\n    let idx = 0;\\n    while(sum < maxSum){\\n        if((sum + arr[idx]) <= maxSum)\\n            count++;\\n        \\n        sum += arr[idx];\\n        idx++;\\n    }\\n\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} banned\\n * @param {number} n\\n * @param {number} maxSum\\n * @return {number}\\n */\\nvar maxCount = function(banned, n, maxSum) {\\n    let set = new Set(new Array(n).fill().map((_, i) => i + 1));\\n    let sum = 0;\\n    let count = 0;\\n\\n    for(let ban of banned)\\n        set.delete(ban);\\n    \\n    //  convert Set to Array\\n    let arr = [...set];\\n    let idx = 0;\\n    while(sum < maxSum){\\n        if((sum + arr[idx]) <= maxSum)\\n            count++;\\n        \\n        sum += arr[idx];\\n        idx++;\\n    }\\n\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3455326,
                "title": "c-hashset",
                "content": "note that using a vector is more efficient than unordered_set<int>\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        unordered_set<int> v(banned.begin(), banned.end());\\n        int curSum = 0, ans = 0;\\n        for (int i = 1; i <= n && curSum + i <= maxSum; ++i)\\n            if (v.find(i) == v.end())\\n                curSum += i, ++ans;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        unordered_set<int> v(banned.begin(), banned.end());\\n        int curSum = 0, ans = 0;\\n        for (int i = 1; i <= n && curSum + i <= maxSum; ++i)\\n            if (v.find(i) == v.end())\\n                curSum += i, ++ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452774,
                "title": "java-using-hashset-o-n",
                "content": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        \\n        Set<Integer> set = new HashSet<>();\\n        for(int val: banned){\\n            set.add(val);\\n        }\\n        \\n        int sum = 0, count = 0;\\n        for(int i = 1; i <= n; i++){\\n            if(!set.contains(i)){\\n                sum += i;\\n                count++;\\n            }\\n            if(sum == maxSum){\\n                return count;\\n            }\\n            else if(sum > maxSum){\\n                break;\\n            }\\n        }\\n        \\n        if(sum < maxSum) return count;\\n        \\n        return --count;\\n        \\n    }\\n}\\n``",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        \\n        Set<Integer> set = new HashSet<>();\\n        for(int val: banned){\\n            set.add(val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3447884,
                "title": "easy-cpp-solution-using-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& ban, int n, int maxsum) {\\n        int sum = 0;\\n    int count = 0;\\n    unordered_map<int, int> map;\\n    for (int x : ban)\\n        map[x]++;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        if (map[i] == 0)\\n        {\\n            if (sum <= maxsum)\\n            {\\n                sum += i;\\n                if (sum <= maxsum)\\n                    count++;\\n            }\\n        }\\n    }\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& ban, int n, int maxsum) {\\n        int sum = 0;\\n    int count = 0;\\n    unordered_map<int, int> map;\\n    for (int x : ban)\\n        map[x]++;\\n    for (int i = 1; i <= n; i++)\\n    {\\n        if (map[i] == 0)\\n        {\\n            if (sum <= maxsum)\\n            {\\n                sum += i;\\n                if (sum <= maxsum)\\n                    count++;\\n            }\\n        }\\n    }\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436229,
                "title": "c-solution-using-hashset",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int MaxCount(int[] banned, int n, int maxSum) {\\n        HashSet<int> bannedSet = new HashSet<int>(banned);\\n        int sum = 0, count = 0;\\n        for(int i = 1; i <= n; i++) {\\n            if(bannedSet.Contains(i)) continue;\\n            sum += i;\\n            if(sum > maxSum) break;\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxCount(int[] banned, int n, int maxSum) {\\n        HashSet<int> bannedSet = new HashSet<int>(banned);\\n        int sum = 0, count = 0;\\n        for(int i = 1; i <= n; i++) {\\n            if(bannedSet.Contains(i)) continue;\\n            sum += i;\\n            if(sum > maxSum) break;\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424692,
                "title": "one-of-the-easiest-question-must-see",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& ban, int n, int ms) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<ban.size();i++)\\n        {\\n            mp[ban[i]]++;\\n        }\\n        int sum=0;\\n        int ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp.find(i)==mp.end() and (sum+i)<=ms)\\n            {\\n                ans++;\\n                sum=sum+i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& ban, int n, int ms) {\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<ban.size();i++)\\n        {\\n            mp[ban[i]]++;\\n        }\\n        int sum=0;\\n        int ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(mp.find(i)==mp.end() and (sum+i)<=ms)\\n            {\\n                ans++;\\n                sum=sum+i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412343,
                "title": "simple-pick-and-not-pick-solution-memoized",
                "content": "## Intuition\\n```\\n/*\\n  Simple pick and not pick solution.\\n  Things to NOTE\\n  1 -> We can Pick only numbers between 1 to N\\n  2 -> The number we pick should not be in BANNED list\\n  3 -> BANNED list might contain numbers which are greater than N\\n       So basically we can minimize the size of BANNED list\\n       And consider only the elements which are <= N\\n       As we are not allowed to pick numbers greater than N\\n*/\\n```\\n\\n```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        \\n        \\n        /* Use a list to check if an index is considered or not in O(1) time */\\n        /* If we use a dictionary it will take some time to search in dictionary */\\n        dp = [-1 for _ in range(n+1)] \\n\\n        /* We also have to check if our choice of number is in banned list or not */\\n        /* And also we have to remove the extra elements from banned list which are > N */\\n        /* So creating a new list of size N and marking 1 - so we can pick and 0 - we cannot pick */\\n        /* Doing so it takes O(length(banned)) time to create but search in new banned list becomes O(1) */\\n\\n        choices = [1 for _ in range(n+1)]\\n        for i in range(len(banned)):\\n            if banned[i] <= n:\\n                choices[banned[i]] = 0\\n        \\n        def f(val,total):\\n            if val>n :return 0 /* if our choice > N return 0 */\\n            if dp[val] != -1:return dp[val] /* Memoization */\\n            pick = 0\\n            if choices[val] == 1 and total+val <= maxSum: /* only pick if current choice(val) is marked as 1 in new List and total+current choice <=maxSum  */\\n                pick = 1 + f(val+1,total+val)\\n            notPick = 0 + f(val+1,total)\\n            dp[val] = max(pick,notPick) /* return Max */\\n            return dp[val]\\n        return f(1,0)\\n```\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n/*\\n  Simple pick and not pick solution.\\n  Things to NOTE\\n  1 -> We can Pick only numbers between 1 to N\\n  2 -> The number we pick should not be in BANNED list\\n  3 -> BANNED list might contain numbers which are greater than N\\n       So basically we can minimize the size of BANNED list\\n       And consider only the elements which are <= N\\n       As we are not allowed to pick numbers greater than N\\n*/\\n```\n```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        \\n        \\n        /* Use a list to check if an index is considered or not in O(1) time */\\n        /* If we use a dictionary it will take some time to search in dictionary */\\n        dp = [-1 for _ in range(n+1)] \\n\\n        /* We also have to check if our choice of number is in banned list or not */\\n        /* And also we have to remove the extra elements from banned list which are > N */\\n        /* So creating a new list of size N and marking 1 - so we can pick and 0 - we cannot pick */\\n        /* Doing so it takes O(length(banned)) time to create but search in new banned list becomes O(1) */\\n\\n        choices = [1 for _ in range(n+1)]\\n        for i in range(len(banned)):\\n            if banned[i] <= n:\\n                choices[banned[i]] = 0\\n        \\n        def f(val,total):\\n            if val>n :return 0 /* if our choice > N return 0 */\\n            if dp[val] != -1:return dp[val] /* Memoization */\\n            pick = 0\\n            if choices[val] == 1 and total+val <= maxSum: /* only pick if current choice(val) is marked as 1 in new List and total+current choice <=maxSum  */\\n                pick = 1 + f(val+1,total+val)\\n            notPick = 0 + f(val+1,total)\\n            dp[val] = max(pick,notPick) /* return Max */\\n            return dp[val]\\n        return f(1,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407381,
                "title": "java-using-set",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        Set<Integer> setBan = new HashSet<>();\\n        for (int k : banned) setBan.add(k);\\n        int runSum = 0, count = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if (!setBan.contains(i)) {\\n                runSum += i;\\n                if (runSum <= maxSum) count++;\\n                else break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        Set<Integer> setBan = new HashSet<>();\\n        for (int k : banned) setBan.add(k);\\n        int runSum = 0, count = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if (!setBan.contains(i)) {\\n                runSum += i;\\n                if (runSum <= maxSum) count++;\\n                else break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405585,
                "title": "simple-hashing-solution-c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        // sort(banned.begin()banned.end());\\n        vector<int>v(n+1,0);\\n        for(int i=0;i<banned.size();i++){\\n            if(banned[i]>n)continue;\\n            v[banned[i]]++;\\n        }\\n        vector<int>v2;\\n        for(int i=1;i<=n;i++){\\n            if(v[i]==0)v2.push_back(i);\\n        }\\n        int sum=0,cnt=0;\\n        for(int i=0;i<v2.size();i++){\\n            sum+=v2[i];\\n            if(sum>maxSum)break;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        // sort(banned.begin()banned.end());\\n        vector<int>v(n+1,0);\\n        for(int i=0;i<banned.size();i++){\\n            if(banned[i]>n)continue;\\n            v[banned[i]]++;\\n        }\\n        vector<int>v2;\\n        for(int i=1;i<=n;i++){\\n            if(v[i]==0)v2.push_back(i);\\n        }\\n        int sum=0,cnt=0;\\n        for(int i=0;i<v2.size();i++){\\n            sum+=v2[i];\\n            if(sum>maxSum)break;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405555,
                "title": "scala-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def maxCount(banned: Array[Int], n: Int, maxSum: Int): Int = {\\n        val bannedSet = banned.toSet\\n        var count = 0\\n        var sum = 0\\n        var i = 1\\n        while (i <= n && sum + i <= maxSum) {\\n            if (!bannedSet.contains(i)) {\\n            count += 1\\n            sum += i\\n            }\\n            i += 1\\n        }\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def maxCount(banned: Array[Int], n: Int, maxSum: Int): Int = {\\n        val bannedSet = banned.toSet\\n        var count = 0\\n        var sum = 0\\n        var i = 1\\n        while (i <= n && sum + i <= maxSum) {\\n            if (!bannedSet.contains(i)) {\\n            count += 1\\n            sum += i\\n            }\\n            i += 1\\n        }\\n        count\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3383427,
                "title": "intuitive-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        vector<bool> seen(n + 1);\\n        for (auto b : banned) {\\n            if (b > n) continue;\\n            seen[b] = true;\\n        }\\n\\n        int acc = 0;\\n        int acc_sum = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if (!seen[i]) {\\n                if (acc_sum + i > maxSum) {\\n                    return acc;\\n                }\\n                ++acc;\\n                acc_sum += i;\\n            }\\n        }\\n\\n        return acc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        vector<bool> seen(n + 1);\\n        for (auto b : banned) {\\n            if (b > n) continue;\\n            seen[b] = true;\\n        }\\n\\n        int acc = 0;\\n        int acc_sum = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if (!seen[i]) {\\n                if (acc_sum + i > maxSum) {\\n                    return acc;\\n                }\\n                ++acc;\\n                acc_sum += i;\\n            }\\n        }\\n\\n        return acc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380088,
                "title": "two-binary-search-nlog-n-and-linear-97-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) is_banned bool array to access banned  elements in O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        bool is_banned[10001]={};\\n        for(int& i: banned){\\n            is_banned[i]=true;\\n        }\\n        int st=1;\\n        int end=n;\\n        int mid=st+(end-st)/2;\\n        int ans=0;\\n        while(st<=end){\\n            mid=st+(end-st)/2;\\n            int x=1;\\n            int cnt=0;\\n            int sum=0;\\n            while(x<=n && cnt<mid){\\n                if(is_banned[x]==0){\\n                    cnt++;\\n                    sum+=x;\\n                    if(sum>maxSum) break;\\n                }\\n                x++;\\n            }\\n            if(cnt==mid && sum<=maxSum){\\n                ans=mid;\\n                st=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n\\n\\nwe can also go for linear approach \\nint cnt=0;\\nfor(int i=1;i<=n;i++){\\n    if(is_banned[i]==0){\\n        maxSum-=i;\\n        if(maxSum<0) return cnt;\\n        cnt++;\\n    }\\n}\\nreturn cnt;\\n\\nafterv creating is_banned array\\nTC=o(N)\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        bool is_banned[10001]={};\\n        for(int& i: banned){\\n            is_banned[i]=true;\\n        }\\n        int st=1;\\n        int end=n;\\n        int mid=st+(end-st)/2;\\n        int ans=0;\\n        while(st<=end){\\n            mid=st+(end-st)/2;\\n            int x=1;\\n            int cnt=0;\\n            int sum=0;\\n            while(x<=n && cnt<mid){\\n                if(is_banned[x]==0){\\n                    cnt++;\\n                    sum+=x;\\n                    if(sum>maxSum) break;\\n                }\\n                x++;\\n            }\\n            if(cnt==mid && sum<=maxSum){\\n                ans=mid;\\n                st=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n\\n\\nwe can also go for linear approach \\nint cnt=0;\\nfor(int i=1;i<=n;i++){\\n    if(is_banned[i]==0){\\n        maxSum-=i;\\n        if(maxSum<0) return cnt;\\n        cnt++;\\n    }\\n}\\nreturn cnt;\\n\\nafterv creating is_banned array\\nTC=o(N)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377094,
                "title": "clean-and-easy-solution-using-set-in-c",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        int sum = 0;\\n        int ans = 0;\\n        set<int> elems;\\n\\n        for(int i = 0; i<banned.size(); i++) {\\n            elems.insert(banned[i]);\\n        }\\n\\n        for(int i = 1; i<=n; i++) {\\n            if(sum+i <= maxSum) {\\n                if(!elems.count(i)) {\\n                    sum+=i;\\n                    ans++;\\n                }\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease do upvote if it helps \\uD83E\\uDD19",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        int sum = 0;\\n        int ans = 0;\\n        set<int> elems;\\n\\n        for(int i = 0; i<banned.size(); i++) {\\n            elems.insert(banned[i]);\\n        }\\n\\n        for(int i = 1; i<=n; i++) {\\n            if(sum+i <= maxSum) {\\n                if(!elems.count(i)) {\\n                    sum+=i;\\n                    ans++;\\n                }\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372837,
                "title": "greedy-approach-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        sets = set(banned)\\n        count, max_sum = 0,0\\n        for i in range(1, n+1):\\n            if i not in sets:\\n                count += i\\n                if  count > maxSum:\\n                    break\\n                else:\\n                    max_sum += 1\\n        return max_sum\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        sets = set(banned)\\n        count, max_sum = 0,0\\n        for i in range(1, n+1):\\n            if i not in sets:\\n                count += i\\n                if  count > maxSum:\\n                    break\\n                else:\\n                    max_sum += 1\\n        return max_sum\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362818,
                "title": "easy-and-simple-solution-of-c-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binarySearch(vector<int>& vec, int l, int r, int val) {\\n        while (l <= r) {\\n            int mid = (l+r)/2;\\n            if (vec[mid] == val) return mid;\\n            else if (vec[mid] > val) {\\n                r = mid-1;\\n            } else if (vec[mid] < val) {\\n                l = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        int ans = 0, r=0;\\n        vector<int> vec;\\n\\n        for (int i=0; i<banned.size(); i++) {\\n            if (binarySearch(vec, 0, vec.size()-1, banned[i]) == -1) vec.push_back(banned[i]);\\n        }\\n\\n        sort(vec.begin(), vec.end());\\n        int sz = vec.size();\\n\\n        for (int i=1; i<=n; i++) {\\n            if (binarySearch(vec, 0, sz-1, i) == -1) {\\n                ans += i;\\n                if (ans <= maxSum) r++;\\n            }\\n        }\\n\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binarySearch(vector<int>& vec, int l, int r, int val) {\\n        while (l <= r) {\\n            int mid = (l+r)/2;\\n            if (vec[mid] == val) return mid;\\n            else if (vec[mid] > val) {\\n                r = mid-1;\\n            } else if (vec[mid] < val) {\\n                l = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        int ans = 0, r=0;\\n        vector<int> vec;\\n\\n        for (int i=0; i<banned.size(); i++) {\\n            if (binarySearch(vec, 0, vec.size()-1, banned[i]) == -1) vec.push_back(banned[i]);\\n        }\\n\\n        sort(vec.begin(), vec.end());\\n        int sz = vec.size();\\n\\n        for (int i=1; i<=n; i++) {\\n            if (binarySearch(vec, 0, sz-1, i) == -1) {\\n                ans += i;\\n                if (ans <= maxSum) r++;\\n            }\\n        }\\n\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356913,
                "title": "unordered-set",
                "content": "**time: `O(B)`; space: `O(B)`**\\n```\\nint maxCount(vector<int>& b, int n, int s)\\n{\\n\\tint out{};\\n\\tunordered_set us(begin(b), end(b));\\n\\tfor(int i{1}; i<=min(n,s); ++i)\\n\\t\\tif(!us.count(i)) s-=i, ++out;\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxCount(vector<int>& b, int n, int s)\\n{\\n\\tint out{};\\n\\tunordered_set us(begin(b), end(b));\\n\\tfor(int i{1}; i<=min(n,s); ++i)\\n\\t\\tif(!us.count(i)) s-=i, ++out;\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3351630,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i:banned)\\n        {\\n            set.add(i);\\n        }\\n        int sum = 0;\\n        int count = 0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(!set.contains(i))\\n            {\\n                sum+=i;\\n                count++;\\n            }\\n            if(sum<=maxSum && i==n)\\n            {\\n                return count;\\n            }\\n            if(sum>maxSum && i!=n)\\n            {\\n                count--;\\n                sum-=i;\\n            }\\n            if(sum>maxSum && i==n)\\n            {\\n                return count-1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i:banned)\\n        {\\n            set.add(i);\\n        }\\n        int sum = 0;\\n        int count = 0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(!set.contains(i))\\n            {\\n                sum+=i;\\n                count++;\\n            }\\n            if(sum<=maxSum && i==n)\\n            {\\n                return count;\\n            }\\n            if(sum>maxSum && i!=n)\\n            {\\n                count--;\\n                sum-=i;\\n            }\\n            if(sum>maxSum && i==n)\\n            {\\n                return count-1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348662,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxCount(self, banned, n, maxSum):\\n        \"\"\"\\n        :type banned: List[int]\\n        :type n: int\\n        :type maxSum: int\\n        :rtype: int\\n        \"\"\"\\n        new_list=[x for x in range(1,n+1)]\\n        from collections import Counter\\n        x=sorted(list(Counter(new_list)-Counter(banned)))\\n        for i in range(len(x)-1,-1,-1):\\n            if sum(x)>maxSum:\\n                x.pop(i)\\n        return len(x)\\n        \\n            \\n\\n                \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxCount(self, banned, n, maxSum):\\n        \"\"\"\\n        :type banned: List[int]\\n        :type n: int\\n        :type maxSum: int\\n        :rtype: int\\n        \"\"\"\\n        new_list=[x for x in range(1,n+1)]\\n        from collections import Counter\\n        x=sorted(list(Counter(new_list)-Counter(banned)))\\n        for i in range(len(x)-1,-1,-1):\\n            if sum(x)>maxSum:\\n                x.pop(i)\\n        return len(x)\\n        \\n            \\n\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348484,
                "title": "maximum-number-of-integers-to-choose-from-a-range-i-easy-hashset-implementation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAdd all the elements of the array in the set to perform the search operation in O(1) time.\\nCheck the element in the set if not present the substract from the maxSum and increament the count \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) due to the Hashset.\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int x : banned)\\n            set.add(x);\\n        int x =1;\\n        int cnt=0;\\n        while(x<=n && maxSum>=x ){\\n            if(!set.contains(x)){\\n                maxSum-=x;\\n                cnt++;\\n            }\\n                x++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int x : banned)\\n            set.add(x);\\n        int x =1;\\n        int cnt=0;\\n        while(x<=n && maxSum>=x ){\\n            if(!set.contains(x)){\\n                maxSum-=x;\\n                cnt++;\\n            }\\n                x++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344352,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) \\n    {\\n        unordered_set<int>s(banned.begin(),banned.end());\\n        vector<int>v;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(s.find(i)==s.end())\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        int count=0;\\n        int sum=0;\\n        int i=0;\\n        while(i<v.size())\\n        {\\n            sum+=v[i];\\n            if(sum<maxSum)\\n            {\\n                 count++;\\n            }\\n            else if(sum==maxSum)\\n            {\\n                count++;\\n                break;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/b96f8fd1-0ab0-462d-abd2-6ac4d82235f7_1679843548.2460592.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) \\n    {\\n        unordered_set<int>s(banned.begin(),banned.end());\\n        vector<int>v;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(s.find(i)==s.end())\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        int count=0;\\n        int sum=0;\\n        int i=0;\\n        while(i<v.size())\\n        {\\n            sum+=v[i];\\n            if(sum<maxSum)\\n            {\\n                 count++;\\n            }\\n            else if(sum==maxSum)\\n            {\\n                count++;\\n                break;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339549,
                "title": "unordered-set-sorting-two-methods-efficient-solution",
                "content": "# Jai Shree Ram \\n# C++ Code | Using Sorting\\n# Complexity\\n- Time complexity: if m = banned.size()-\\n- m(logm) for sorting the array ```banned``` and\\n- O(n) for tarversing 1 to n\\n- So ```overall Time Complexity``` : O( m(logm) + n )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: As I have not used any extra space so, \\n- ```Space Complexity``` : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        int m = banned.size();\\n        sort(banned.begin(), banned.end());\\n        int j = 0; //iterate through banned array\\n        int i = 1;\\n        int ans = 0;\\n        int sum = 0;\\n        while(i <= n){\\n            if(j < m && i == banned[j]){\\n                while(j < m && i == banned[j]) j++;\\n            }\\n            else{\\n                sum += i;\\n                if(sum <= maxSum) ans++;\\n                else break;\\n            }\\n            i++;\\n        }\\n        return ans;  \\n    }\\n};\\n```\\n# C++ Code | Using HashSet\\n\\n- ```Time Complexity``` : O(m(logm) + n) ; m is the size of array ```banned```.\\n- ```Space```: O(m)\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        unordered_set<int> uset;\\n        for(int x : banned) uset.insert(x);\\n\\n        int sum = 0;\\n        int count = 0;\\n        for(int i=1; i<=n; i++){\\n            if(!uset.count(i) && sum < maxSum){\\n                count++;\\n                sum += i;\\n                if(sum > maxSum) return count-1;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```banned```\n```overall Time Complexity```\n```Space Complexity```\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        int m = banned.size();\\n        sort(banned.begin(), banned.end());\\n        int j = 0; //iterate through banned array\\n        int i = 1;\\n        int ans = 0;\\n        int sum = 0;\\n        while(i <= n){\\n            if(j < m && i == banned[j]){\\n                while(j < m && i == banned[j]) j++;\\n            }\\n            else{\\n                sum += i;\\n                if(sum <= maxSum) ans++;\\n                else break;\\n            }\\n            i++;\\n        }\\n        return ans;  \\n    }\\n};\\n```\n```Time Complexity```\n```banned```\n```Space```\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        unordered_set<int> uset;\\n        for(int x : banned) uset.insert(x);\\n\\n        int sum = 0;\\n        int count = 0;\\n        for(int i=1; i<=n; i++){\\n            if(!uset.count(i) && sum < maxSum){\\n                count++;\\n                sum += i;\\n                if(sum > maxSum) return count-1;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338065,
                "title": "simple-java-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        HashSet<Integer> set=new HashSet<>();\\n        int i=0,x=0,sum=0;\\n        for(i=0;i<banned.length;i++)\\n        set.add(banned[i]);\\n        for(i=1;i<=n;i++)\\n        {\\n            if(!set.contains(i))\\n            {\\n                if((sum+i)<=maxSum)\\n                {\\n                    x++;\\n                    sum+=i;\\n                }\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        HashSet<Integer> set=new HashSet<>();\\n        int i=0,x=0,sum=0;\\n        for(i=0;i<banned.length;i++)\\n        set.add(banned[i]);\\n        for(i=1;i<=n;i++)\\n        {\\n            if(!set.contains(i))\\n            {\\n                if((sum+i)<=maxSum)\\n                {\\n                    x++;\\n                    sum+=i;\\n                }\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320118,
                "title": "100-time-complexity",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        boolean[] bannedNumbers = new boolean[10001];\\n\\n        for(int i = 0; i < banned.length; i++)\\n            bannedNumbers[banned[i]] = true;\\n\\n        int count = 0;\\n        int sum = 0;\\n        for(int i=1; i<=n; i++){\\n            if(!bannedNumbers[i]){\\n                sum+=i;\\n                if(sum > maxSum) break;\\n                count++;\\n                \\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        boolean[] bannedNumbers = new boolean[10001];\\n\\n        for(int i = 0; i < banned.length; i++)\\n            bannedNumbers[banned[i]] = true;\\n\\n        int count = 0;\\n        int sum = 0;\\n        for(int i=1; i<=n; i++){\\n            if(!bannedNumbers[i]){\\n                sum+=i;\\n                if(sum > maxSum) break;\\n                count++;\\n                \\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308253,
                "title": "python-overthinked-slow-solution-using-heap",
                "content": "There are much more efficient solutions to solve this problem. But here is an easy approach solving that problem using ```maxheap```.\\n\\n1. First create a list with numbers in range [1,n].\\n2. Create a new list with numbers from that interval that are not in the banned list.\\n3. Multiply every value with -1 and create a maxheap.\\n4. Apply ```heappop```on that list as long the abs sum of the elements is greater than ```maxSum```\\n5. Finally return the length of the listh  \\n\\n# Code\\n```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        s = [i for i in range(1, n + 1)]\\n        not_banned = list(set(s) - set(banned))\\n        not_banned = [-1 * i for i in not_banned]\\n        heapq.heapify(not_banned)\\n        while abs(sum(not_banned)) > maxSum:\\n            heapq.heappop(not_banned)\\n        return len(not_banned)\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```maxheap```\n```heappop```\n```maxSum```\n```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        s = [i for i in range(1, n + 1)]\\n        not_banned = list(set(s) - set(banned))\\n        not_banned = [-1 * i for i in not_banned]\\n        heapq.heapify(not_banned)\\n        while abs(sum(not_banned)) > maxSum:\\n            heapq.heappop(not_banned)\\n        return len(not_banned)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296340,
                "title": "no-set-or-map-used-o-n-complexcity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\niterate from 1 to n , check if current i in banned or not\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate i from 1 to n, check if current i in banned ,\\n1. check current i in banned by increament idx for banned for banned[idx]<i\\n2. increament count and sum+=i upto sum<=maxSum\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        sort(banned.begin(),banned.end());\\n        int idx=0;\\n        long long sum=0;\\n        int count=0;\\n        for(int i=1;i<=n && sum<maxSum;i++){\\n            while(idx<banned.size() && i>banned[idx]) idx++;\\n            if(idx<banned.size() && banned[idx]!=i){\\n                sum+=i;\\n                if(sum<=maxSum) count++;\\n            }\\n            if(idx==banned.size()){\\n                sum+=i;\\n                if(sum<=maxSum) count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        sort(banned.begin(),banned.end());\\n        int idx=0;\\n        long long sum=0;\\n        int count=0;\\n        for(int i=1;i<=n && sum<maxSum;i++){\\n            while(idx<banned.size() && i>banned[idx]) idx++;\\n            if(idx<banned.size() && banned[idx]!=i){\\n                sum+=i;\\n                if(sum<=maxSum) count++;\\n            }\\n            if(idx==banned.size()){\\n                sum+=i;\\n                if(sum<=maxSum) count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291664,
                "title": "java-90-faster-time-complexity-o-n-space-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst take all element in set so that we can find that is present in banned array or not if it is present  thwn we can\\'t add it. \\nWe use set because the following reason: \\n1. If duplicate is present \\n2. To find the element is present in banned array in less time    complexity.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        HashSet<Integer>s=new HashSet<>();\\n        for(int i=0;i<banned.length;i++)\\n            s.add(banned[i]);\\n        int sum=0,m=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(s.contains(i)==false && ((sum+i)<=maxSum))\\n            {\\n                sum+=i;\\n                m++;\\n            }\\n        }\\n        return m;\\n    }\\n}\\nfeel free to ask your doubt happy to help.....\\nIf it help then plz upvote.....Thanks!!!!\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        HashSet<Integer>s=new HashSet<>();\\n        for(int i=0;i<banned.length;i++)\\n            s.add(banned[i]);\\n        int sum=0,m=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(s.contains(i)==false && ((sum+i)<=maxSum))\\n            {\\n                sum+=i;\\n                m++;\\n            }\\n        }\\n        return m;\\n    }\\n}\\nfeel free to ask your doubt happy to help.....\\nIf it help then plz upvote.....Thanks!!!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289290,
                "title": "sweets-and-simple-solution-specially-for-beginner-easy-approach-straight-forward-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        map<int,int> hashMap;\\n        for(auto x: banned){\\n            hashMap[x]++;\\n        }\\n        int ans=0;\\n        int ansSum=0;\\n        for(int i=1;i<=n;i++){\\n\\n            if(hashMap.find(i)==hashMap.end() && ansSum + i <= maxSum){\\n                ansSum+=i;\\n            ans++;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        map<int,int> hashMap;\\n        for(auto x: banned){\\n            hashMap[x]++;\\n        }\\n        int ans=0;\\n        int ansSum=0;\\n        for(int i=1;i<=n;i++){\\n\\n            if(hashMap.find(i)==hashMap.end() && ansSum + i <= maxSum){\\n                ansSum+=i;\\n            ans++;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284846,
                "title": "easy-c-solution",
                "content": "# Intuition\\nHashing and Greedy\\n\\n# Approach\\nStart from i=1 to i=n and gather as much you can in banned set\\n\\n# Complexity\\n- Time complexity:\\nO(n) for the set\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        int count=0;\\n        set<int>s;\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            s.insert(banned[i]);\\n        }\\n        int sum=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(s.find(i)==s.end())\\n            {\\n            count++;\\n            sum+=i;\\n            }\\n            \\n            if(sum>maxSum)\\n            {\\n                count--;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        int count=0;\\n        set<int>s;\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            s.insert(banned[i]);\\n        }\\n        int sum=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(s.find(i)==s.end())\\n            {\\n            count++;\\n            sum+=i;\\n            }\\n            \\n            if(sum>maxSum)\\n            {\\n                count--;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282827,
                "title": "simple-binary-search-approach-my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasicall this is searching an element from the range 1 to n in the banned array and check if it is present in it or not.If it is not there we can consider it and if adding it to sum doesnot exceed the max sum, then this is the number for which we can increase our count.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo for searching I used binary search. If it returns false then we can add it to our sum and check if sum does not exceed maxsum .If sum doesnot exceed maxsum, we can increase our count.Atlast we return the count.\\n\\n# Complexity\\n- Time complexity:Nlog(banned.size())\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  bool inarr(int i,vector<int>& arr){\\n        int low = 0;\\n        int high = arr.size()-1;\\n        while(low<=high){\\n            int mid = (high - low)/2 + low;\\n            if(arr[mid]==i){\\n                return true;\\n            }\\n            else if(arr[mid]<i){\\n                low=mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        sort(banned.begin(),banned.end());\\n        int count=0;\\n        int i=1;\\n        int sum =0;\\n        while(i<=n){\\n            if(inarr(i,banned)){\\n                i++;\\n            }\\n            else{\\n                if(sum+i<=maxSum){\\n                    count++;\\n                    sum = sum+i;\\n                }\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n \\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool inarr(int i,vector<int>& arr){\\n        int low = 0;\\n        int high = arr.size()-1;\\n        while(low<=high){\\n            int mid = (high - low)/2 + low;\\n            if(arr[mid]==i){\\n                return true;\\n            }\\n            else if(arr[mid]<i){\\n                low=mid+1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        sort(banned.begin(),banned.end());\\n        int count=0;\\n        int i=1;\\n        int sum =0;\\n        while(i<=n){\\n            if(inarr(i,banned)){\\n                i++;\\n            }\\n            else{\\n                if(sum+i<=maxSum){\\n                    count++;\\n                    sum = sum+i;\\n                }\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275381,
                "title": "python-greedy-solution",
                "content": "```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        banned_set = set(banned)\\n        max_num, curr_val = 0, 0\\n        for val in range(1, n+1):\\n            if val not in banned_set:\\n                curr_val += val \\n                if curr_val > maxSum:\\n                    break\\n                else:\\n                    max_num += 1\\n        \\n        return max_num\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\\n        banned_set = set(banned)\\n        max_num, curr_val = 0, 0\\n        for val in range(1, n+1):\\n            if val not in banned_set:\\n                curr_val += val \\n                if curr_val > maxSum:\\n                    break\\n                else:\\n                    max_num += 1\\n        \\n        return max_num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272930,
                "title": "skipping-some-middle-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt can avoid travesing over 1 to n with each pair of [i-1, i], the sum of [a1,an] is cnt*(a1 + an) / 2, so we only need to traverse over [a1,an] at the last part of numbers\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        sort(banned.begin(), banned.end());    \\n        if (banned.back() <= n)\\n            banned.push_back(n + 1);\\n        int sum = 0, ans = 0, prev = 0;\\n        for (int i = 0; i < banned.size(); ++i) {\\n            int a1 = prev + 1, an = min(n, banned[i] - 1);\\n            prev = banned[i];\\n            if (a1 > an)\\n                continue;\\n            int cnt = an - a1 + 1, total = cnt * (an + a1) / 2;\\n            if (total + sum <= maxSum) {\\n                ans += cnt;\\n                sum += total;\\n            } else {\\n                while (a1 <= an) {\\n                    if (a1 + sum <= maxSum) {\\n                        sum += a1;\\n                        ans++;\\n                    }\\n                    a1++;\\n                }\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        sort(banned.begin(), banned.end());    \\n        if (banned.back() <= n)\\n            banned.push_back(n + 1);\\n        int sum = 0, ans = 0, prev = 0;\\n        for (int i = 0; i < banned.size(); ++i) {\\n            int a1 = prev + 1, an = min(n, banned[i] - 1);\\n            prev = banned[i];\\n            if (a1 > an)\\n                continue;\\n            int cnt = an - a1 + 1, total = cnt * (an + a1) / 2;\\n            if (total + sum <= maxSum) {\\n                ans += cnt;\\n                sum += total;\\n            } else {\\n                while (a1 <= an) {\\n                    if (a1 + sum <= maxSum) {\\n                        sum += a1;\\n                        ans++;\\n                    }\\n                    a1++;\\n                }\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269919,
                "title": "very-easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum)\\n    {\\n        Set<Integer> ban=new HashSet<>();\\n        for(int i:banned)\\n        {\\n            ban.add(i);\\n        }\\n        \\n        List<Integer> list=new ArrayList<>();\\n        int count=0;\\n        int sum=0;\\n        \\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            if(!ban.contains(i) && i<=maxSum)\\n            {\\n                if(sum+i<=maxSum)\\n                {\\n                    sum+=i;\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum)\\n    {\\n        Set<Integer> ban=new HashSet<>();\\n        for(int i:banned)\\n        {\\n            ban.add(i);\\n        }\\n        \\n        List<Integer> list=new ArrayList<>();\\n        int count=0;\\n        int sum=0;\\n        \\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            if(!ban.contains(i) && i<=maxSum)\\n            {\\n                if(sum+i<=maxSum)\\n                {\\n                    sum+=i;\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269693,
                "title": "ordered-map-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOrdered Map   \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmaintain  a ordered map  with  freq 1 of all  element from 1 to n iterate in array and if element found  in  array also exist  in  map then reduce  the freq  by 1 .. \\nno  you  have    to go to element  in  map  whose  freq  >  0 ie  they are not present in array coz  in iteration you  have  decreasd .it \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nn  time  \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nOrder n space as extra  map is  used \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        int  ans = 0 ; \\n\\n        map<int ,    int > m  ; \\n        for (  int  i = 1  ; i  <=    n ;i++ ){\\n            m[i]++    ; \\n\\n        }\\n        for (  int   i  = 0  ; i  < banned.size() ;i++ ){\\n            m[banned[i]]--  ; \\n\\n        }\\n        int  sum = 0  ; \\n\\n        for (  auto  it  : m  ){\\n            if (  it.second > 0 ){\\n                sum  += it.first   ; \\n                if ( sum  > maxSum  ){\\n                    break  ; \\n\\n                }\\n                ans +=  1    ;  \\n\\n            }\\n        }\\n        return ans    ;  \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        int  ans = 0 ; \\n\\n        map<int ,    int > m  ; \\n        for (  int  i = 1  ; i  <=    n ;i++ ){\\n            m[i]++    ; \\n\\n        }\\n        for (  int   i  = 0  ; i  < banned.size() ;i++ ){\\n            m[banned[i]]--  ; \\n\\n        }\\n        int  sum = 0  ; \\n\\n        for (  auto  it  : m  ){\\n            if (  it.second > 0 ){\\n                sum  += it.first   ; \\n                if ( sum  > maxSum  ){\\n                    break  ; \\n\\n                }\\n                ans +=  1    ;  \\n\\n            }\\n        }\\n        return ans    ;  \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266417,
                "title": "simple-solution-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n\\n\\n        Set<Integer> set = new HashSet<>();\\n\\n        for(int i : banned) {\\n\\n            if(i <= n) {\\n                set.add(i);\\n            }\\n           \\n        }\\n\\n        int count = 0;\\n        int sum = 0;\\n\\n        for(int i = 1; i <= n; i++) {\\n\\n         \\n            if(!set.contains(i)) {\\n                sum += i;\\n\\n                if(sum <= maxSum) {\\n                    count++;\\n                }   \\n            }\\n\\n        }\\n\\n\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n\\n\\n        Set<Integer> set = new HashSet<>();\\n\\n        for(int i : banned) {\\n\\n            if(i <= n) {\\n                set.add(i);\\n            }\\n           \\n        }\\n\\n        int count = 0;\\n        int sum = 0;\\n\\n        for(int i = 1; i <= n; i++) {\\n\\n         \\n            if(!set.contains(i)) {\\n                sum += i;\\n\\n                if(sum <= maxSum) {\\n                    count++;\\n                }   \\n            }\\n\\n        }\\n\\n\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266409,
                "title": "easy-faster-efficient-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int val : banned){\\n            set.add(val);\\n        }\\n        int sum = 0, i = 1, count = 0;\\n        while(i <= n && sum <= maxSum){\\n            if(!set.contains(i)){\\n                sum += i;\\n                if(sum > maxSum){\\n                    break;\\n                }\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int val : banned){\\n            set.add(val);\\n        }\\n        int sum = 0, i = 1, count = 0;\\n        while(i <= n && sum <= maxSum){\\n            if(!set.contains(i)){\\n                sum += i;\\n                if(sum > maxSum){\\n                    break;\\n                }\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1787813,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "i think in the example they should also show the [2,3] in the ans of [1,6,5] case as it is also less tha 6 "
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "individual integers are not asked no.. you just need to return the maximum number of integers that you can gather..\\n"
                    },
                    {
                        "username": "ayushacharya13",
                        "content": "same issue bro and the banned should be [1,3,5]."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "i got TLE coz i used list instead of set while storing elements 😫 just bad times"
                    },
                    {
                        "username": "sagar897",
                        "content": "why we r not using vector ' count method ? \n\nbecause it is slower then set , is it correct ?"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@Kaustav1810](/Kaustav1810)  Same Here !!"
                    },
                    {
                        "username": "pestlain",
                        "content": "same"
                    },
                    {
                        "username": "Kaustav1810",
                        "content": "same bro :("
                    },
                    {
                        "username": "21Cash",
                        "content": "this one shoulda been a easy"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "nice and simple problem"
                    },
                    {
                        "username": "Labracadabra",
                        "content": "Test #171 expects the answer \\'56\\' which I also get in my IDE, but here the same code outputs different answer - \\'44\\', how is it possible??"
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "Guys, my 205th test case failed on submission but it is running OK when I click on run what should I do."
                    },
                    {
                        "username": "blue262",
                        "content": "if you are passing any array to function\\nuse call by reference"
                    },
                    {
                        "username": "chintu12",
                        "content": " `\n\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\n        check = set(banned) \n        count=0\n        summ=0\n        for i in range(1,n+1):\n            if i not in banned:\n                summ+=i\n                count+=1\n            if summ>maxSum:\n                return (count-1)\n            if summ==maxSum:\n                return count         \n            \n        return count`\n                \n \nwhy this code is giving TLE?"
                    },
                    {
                        "username": "chintu12",
                        "content": "[@stackphish](/stackphish)  it worked , thanks"
                    },
                    {
                        "username": "stackphish",
                        "content": "You probably need to check whether `i` is present in `check` instead of `banned` as checking in a set runs in constant time complexity.\n```\nif i not in check:\n```\ninstead of \n```\nif i not in banned\n```"
                    },
                    {
                        "username": "101rror",
                        "content": "Solution using Map-->>https://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/submissions/891374565/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple Solution <br>\\nMy solution Link : -> https://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/solutions/3141766/c-easy-and-simple-solution-using-hash-map/\\n<br>\\nDon\\'t Forgot to upvote it ."
                    }
                ]
            },
            {
                "id": 1787537,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "i think in the example they should also show the [2,3] in the ans of [1,6,5] case as it is also less tha 6 "
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "individual integers are not asked no.. you just need to return the maximum number of integers that you can gather..\\n"
                    },
                    {
                        "username": "ayushacharya13",
                        "content": "same issue bro and the banned should be [1,3,5]."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "i got TLE coz i used list instead of set while storing elements 😫 just bad times"
                    },
                    {
                        "username": "sagar897",
                        "content": "why we r not using vector ' count method ? \n\nbecause it is slower then set , is it correct ?"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@Kaustav1810](/Kaustav1810)  Same Here !!"
                    },
                    {
                        "username": "pestlain",
                        "content": "same"
                    },
                    {
                        "username": "Kaustav1810",
                        "content": "same bro :("
                    },
                    {
                        "username": "21Cash",
                        "content": "this one shoulda been a easy"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "nice and simple problem"
                    },
                    {
                        "username": "Labracadabra",
                        "content": "Test #171 expects the answer \\'56\\' which I also get in my IDE, but here the same code outputs different answer - \\'44\\', how is it possible??"
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "Guys, my 205th test case failed on submission but it is running OK when I click on run what should I do."
                    },
                    {
                        "username": "blue262",
                        "content": "if you are passing any array to function\\nuse call by reference"
                    },
                    {
                        "username": "chintu12",
                        "content": " `\n\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\n        check = set(banned) \n        count=0\n        summ=0\n        for i in range(1,n+1):\n            if i not in banned:\n                summ+=i\n                count+=1\n            if summ>maxSum:\n                return (count-1)\n            if summ==maxSum:\n                return count         \n            \n        return count`\n                \n \nwhy this code is giving TLE?"
                    },
                    {
                        "username": "chintu12",
                        "content": "[@stackphish](/stackphish)  it worked , thanks"
                    },
                    {
                        "username": "stackphish",
                        "content": "You probably need to check whether `i` is present in `check` instead of `banned` as checking in a set runs in constant time complexity.\n```\nif i not in check:\n```\ninstead of \n```\nif i not in banned\n```"
                    },
                    {
                        "username": "101rror",
                        "content": "Solution using Map-->>https://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/submissions/891374565/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple Solution <br>\\nMy solution Link : -> https://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/solutions/3141766/c-easy-and-simple-solution-using-hash-map/\\n<br>\\nDon\\'t Forgot to upvote it ."
                    }
                ]
            },
            {
                "id": 1991335,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "i think in the example they should also show the [2,3] in the ans of [1,6,5] case as it is also less tha 6 "
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "individual integers are not asked no.. you just need to return the maximum number of integers that you can gather..\\n"
                    },
                    {
                        "username": "ayushacharya13",
                        "content": "same issue bro and the banned should be [1,3,5]."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "i got TLE coz i used list instead of set while storing elements 😫 just bad times"
                    },
                    {
                        "username": "sagar897",
                        "content": "why we r not using vector ' count method ? \n\nbecause it is slower then set , is it correct ?"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@Kaustav1810](/Kaustav1810)  Same Here !!"
                    },
                    {
                        "username": "pestlain",
                        "content": "same"
                    },
                    {
                        "username": "Kaustav1810",
                        "content": "same bro :("
                    },
                    {
                        "username": "21Cash",
                        "content": "this one shoulda been a easy"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "nice and simple problem"
                    },
                    {
                        "username": "Labracadabra",
                        "content": "Test #171 expects the answer \\'56\\' which I also get in my IDE, but here the same code outputs different answer - \\'44\\', how is it possible??"
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "Guys, my 205th test case failed on submission but it is running OK when I click on run what should I do."
                    },
                    {
                        "username": "blue262",
                        "content": "if you are passing any array to function\\nuse call by reference"
                    },
                    {
                        "username": "chintu12",
                        "content": " `\n\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\n        check = set(banned) \n        count=0\n        summ=0\n        for i in range(1,n+1):\n            if i not in banned:\n                summ+=i\n                count+=1\n            if summ>maxSum:\n                return (count-1)\n            if summ==maxSum:\n                return count         \n            \n        return count`\n                \n \nwhy this code is giving TLE?"
                    },
                    {
                        "username": "chintu12",
                        "content": "[@stackphish](/stackphish)  it worked , thanks"
                    },
                    {
                        "username": "stackphish",
                        "content": "You probably need to check whether `i` is present in `check` instead of `banned` as checking in a set runs in constant time complexity.\n```\nif i not in check:\n```\ninstead of \n```\nif i not in banned\n```"
                    },
                    {
                        "username": "101rror",
                        "content": "Solution using Map-->>https://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/submissions/891374565/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple Solution <br>\\nMy solution Link : -> https://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/solutions/3141766/c-easy-and-simple-solution-using-hash-map/\\n<br>\\nDon\\'t Forgot to upvote it ."
                    }
                ]
            },
            {
                "id": 1983984,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "i think in the example they should also show the [2,3] in the ans of [1,6,5] case as it is also less tha 6 "
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "individual integers are not asked no.. you just need to return the maximum number of integers that you can gather..\\n"
                    },
                    {
                        "username": "ayushacharya13",
                        "content": "same issue bro and the banned should be [1,3,5]."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "i got TLE coz i used list instead of set while storing elements 😫 just bad times"
                    },
                    {
                        "username": "sagar897",
                        "content": "why we r not using vector ' count method ? \n\nbecause it is slower then set , is it correct ?"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@Kaustav1810](/Kaustav1810)  Same Here !!"
                    },
                    {
                        "username": "pestlain",
                        "content": "same"
                    },
                    {
                        "username": "Kaustav1810",
                        "content": "same bro :("
                    },
                    {
                        "username": "21Cash",
                        "content": "this one shoulda been a easy"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "nice and simple problem"
                    },
                    {
                        "username": "Labracadabra",
                        "content": "Test #171 expects the answer \\'56\\' which I also get in my IDE, but here the same code outputs different answer - \\'44\\', how is it possible??"
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "Guys, my 205th test case failed on submission but it is running OK when I click on run what should I do."
                    },
                    {
                        "username": "blue262",
                        "content": "if you are passing any array to function\\nuse call by reference"
                    },
                    {
                        "username": "chintu12",
                        "content": " `\n\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\n        check = set(banned) \n        count=0\n        summ=0\n        for i in range(1,n+1):\n            if i not in banned:\n                summ+=i\n                count+=1\n            if summ>maxSum:\n                return (count-1)\n            if summ==maxSum:\n                return count         \n            \n        return count`\n                \n \nwhy this code is giving TLE?"
                    },
                    {
                        "username": "chintu12",
                        "content": "[@stackphish](/stackphish)  it worked , thanks"
                    },
                    {
                        "username": "stackphish",
                        "content": "You probably need to check whether `i` is present in `check` instead of `banned` as checking in a set runs in constant time complexity.\n```\nif i not in check:\n```\ninstead of \n```\nif i not in banned\n```"
                    },
                    {
                        "username": "101rror",
                        "content": "Solution using Map-->>https://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/submissions/891374565/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple Solution <br>\\nMy solution Link : -> https://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/solutions/3141766/c-easy-and-simple-solution-using-hash-map/\\n<br>\\nDon\\'t Forgot to upvote it ."
                    }
                ]
            },
            {
                "id": 1855760,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "i think in the example they should also show the [2,3] in the ans of [1,6,5] case as it is also less tha 6 "
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "individual integers are not asked no.. you just need to return the maximum number of integers that you can gather..\\n"
                    },
                    {
                        "username": "ayushacharya13",
                        "content": "same issue bro and the banned should be [1,3,5]."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "i got TLE coz i used list instead of set while storing elements 😫 just bad times"
                    },
                    {
                        "username": "sagar897",
                        "content": "why we r not using vector ' count method ? \n\nbecause it is slower then set , is it correct ?"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@Kaustav1810](/Kaustav1810)  Same Here !!"
                    },
                    {
                        "username": "pestlain",
                        "content": "same"
                    },
                    {
                        "username": "Kaustav1810",
                        "content": "same bro :("
                    },
                    {
                        "username": "21Cash",
                        "content": "this one shoulda been a easy"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "nice and simple problem"
                    },
                    {
                        "username": "Labracadabra",
                        "content": "Test #171 expects the answer \\'56\\' which I also get in my IDE, but here the same code outputs different answer - \\'44\\', how is it possible??"
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "Guys, my 205th test case failed on submission but it is running OK when I click on run what should I do."
                    },
                    {
                        "username": "blue262",
                        "content": "if you are passing any array to function\\nuse call by reference"
                    },
                    {
                        "username": "chintu12",
                        "content": " `\n\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\n        check = set(banned) \n        count=0\n        summ=0\n        for i in range(1,n+1):\n            if i not in banned:\n                summ+=i\n                count+=1\n            if summ>maxSum:\n                return (count-1)\n            if summ==maxSum:\n                return count         \n            \n        return count`\n                \n \nwhy this code is giving TLE?"
                    },
                    {
                        "username": "chintu12",
                        "content": "[@stackphish](/stackphish)  it worked , thanks"
                    },
                    {
                        "username": "stackphish",
                        "content": "You probably need to check whether `i` is present in `check` instead of `banned` as checking in a set runs in constant time complexity.\n```\nif i not in check:\n```\ninstead of \n```\nif i not in banned\n```"
                    },
                    {
                        "username": "101rror",
                        "content": "Solution using Map-->>https://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/submissions/891374565/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple Solution <br>\\nMy solution Link : -> https://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/solutions/3141766/c-easy-and-simple-solution-using-hash-map/\\n<br>\\nDon\\'t Forgot to upvote it ."
                    }
                ]
            },
            {
                "id": 1835855,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "i think in the example they should also show the [2,3] in the ans of [1,6,5] case as it is also less tha 6 "
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "individual integers are not asked no.. you just need to return the maximum number of integers that you can gather..\\n"
                    },
                    {
                        "username": "ayushacharya13",
                        "content": "same issue bro and the banned should be [1,3,5]."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "i got TLE coz i used list instead of set while storing elements 😫 just bad times"
                    },
                    {
                        "username": "sagar897",
                        "content": "why we r not using vector ' count method ? \n\nbecause it is slower then set , is it correct ?"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@Kaustav1810](/Kaustav1810)  Same Here !!"
                    },
                    {
                        "username": "pestlain",
                        "content": "same"
                    },
                    {
                        "username": "Kaustav1810",
                        "content": "same bro :("
                    },
                    {
                        "username": "21Cash",
                        "content": "this one shoulda been a easy"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "nice and simple problem"
                    },
                    {
                        "username": "Labracadabra",
                        "content": "Test #171 expects the answer \\'56\\' which I also get in my IDE, but here the same code outputs different answer - \\'44\\', how is it possible??"
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "Guys, my 205th test case failed on submission but it is running OK when I click on run what should I do."
                    },
                    {
                        "username": "blue262",
                        "content": "if you are passing any array to function\\nuse call by reference"
                    },
                    {
                        "username": "chintu12",
                        "content": " `\n\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\n        check = set(banned) \n        count=0\n        summ=0\n        for i in range(1,n+1):\n            if i not in banned:\n                summ+=i\n                count+=1\n            if summ>maxSum:\n                return (count-1)\n            if summ==maxSum:\n                return count         \n            \n        return count`\n                \n \nwhy this code is giving TLE?"
                    },
                    {
                        "username": "chintu12",
                        "content": "[@stackphish](/stackphish)  it worked , thanks"
                    },
                    {
                        "username": "stackphish",
                        "content": "You probably need to check whether `i` is present in `check` instead of `banned` as checking in a set runs in constant time complexity.\n```\nif i not in check:\n```\ninstead of \n```\nif i not in banned\n```"
                    },
                    {
                        "username": "101rror",
                        "content": "Solution using Map-->>https://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/submissions/891374565/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple Solution <br>\\nMy solution Link : -> https://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/solutions/3141766/c-easy-and-simple-solution-using-hash-map/\\n<br>\\nDon\\'t Forgot to upvote it ."
                    }
                ]
            },
            {
                "id": 1789291,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "i think in the example they should also show the [2,3] in the ans of [1,6,5] case as it is also less tha 6 "
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "individual integers are not asked no.. you just need to return the maximum number of integers that you can gather..\\n"
                    },
                    {
                        "username": "ayushacharya13",
                        "content": "same issue bro and the banned should be [1,3,5]."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "i got TLE coz i used list instead of set while storing elements 😫 just bad times"
                    },
                    {
                        "username": "sagar897",
                        "content": "why we r not using vector ' count method ? \n\nbecause it is slower then set , is it correct ?"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@Kaustav1810](/Kaustav1810)  Same Here !!"
                    },
                    {
                        "username": "pestlain",
                        "content": "same"
                    },
                    {
                        "username": "Kaustav1810",
                        "content": "same bro :("
                    },
                    {
                        "username": "21Cash",
                        "content": "this one shoulda been a easy"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "nice and simple problem"
                    },
                    {
                        "username": "Labracadabra",
                        "content": "Test #171 expects the answer \\'56\\' which I also get in my IDE, but here the same code outputs different answer - \\'44\\', how is it possible??"
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "Guys, my 205th test case failed on submission but it is running OK when I click on run what should I do."
                    },
                    {
                        "username": "blue262",
                        "content": "if you are passing any array to function\\nuse call by reference"
                    },
                    {
                        "username": "chintu12",
                        "content": " `\n\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\n        check = set(banned) \n        count=0\n        summ=0\n        for i in range(1,n+1):\n            if i not in banned:\n                summ+=i\n                count+=1\n            if summ>maxSum:\n                return (count-1)\n            if summ==maxSum:\n                return count         \n            \n        return count`\n                \n \nwhy this code is giving TLE?"
                    },
                    {
                        "username": "chintu12",
                        "content": "[@stackphish](/stackphish)  it worked , thanks"
                    },
                    {
                        "username": "stackphish",
                        "content": "You probably need to check whether `i` is present in `check` instead of `banned` as checking in a set runs in constant time complexity.\n```\nif i not in check:\n```\ninstead of \n```\nif i not in banned\n```"
                    },
                    {
                        "username": "101rror",
                        "content": "Solution using Map-->>https://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/submissions/891374565/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple Solution <br>\\nMy solution Link : -> https://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/solutions/3141766/c-easy-and-simple-solution-using-hash-map/\\n<br>\\nDon\\'t Forgot to upvote it ."
                    }
                ]
            },
            {
                "id": 1788323,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "i think in the example they should also show the [2,3] in the ans of [1,6,5] case as it is also less tha 6 "
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "individual integers are not asked no.. you just need to return the maximum number of integers that you can gather..\\n"
                    },
                    {
                        "username": "ayushacharya13",
                        "content": "same issue bro and the banned should be [1,3,5]."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "i got TLE coz i used list instead of set while storing elements 😫 just bad times"
                    },
                    {
                        "username": "sagar897",
                        "content": "why we r not using vector ' count method ? \n\nbecause it is slower then set , is it correct ?"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@Kaustav1810](/Kaustav1810)  Same Here !!"
                    },
                    {
                        "username": "pestlain",
                        "content": "same"
                    },
                    {
                        "username": "Kaustav1810",
                        "content": "same bro :("
                    },
                    {
                        "username": "21Cash",
                        "content": "this one shoulda been a easy"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "nice and simple problem"
                    },
                    {
                        "username": "Labracadabra",
                        "content": "Test #171 expects the answer \\'56\\' which I also get in my IDE, but here the same code outputs different answer - \\'44\\', how is it possible??"
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "Guys, my 205th test case failed on submission but it is running OK when I click on run what should I do."
                    },
                    {
                        "username": "blue262",
                        "content": "if you are passing any array to function\\nuse call by reference"
                    },
                    {
                        "username": "chintu12",
                        "content": " `\n\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\n        check = set(banned) \n        count=0\n        summ=0\n        for i in range(1,n+1):\n            if i not in banned:\n                summ+=i\n                count+=1\n            if summ>maxSum:\n                return (count-1)\n            if summ==maxSum:\n                return count         \n            \n        return count`\n                \n \nwhy this code is giving TLE?"
                    },
                    {
                        "username": "chintu12",
                        "content": "[@stackphish](/stackphish)  it worked , thanks"
                    },
                    {
                        "username": "stackphish",
                        "content": "You probably need to check whether `i` is present in `check` instead of `banned` as checking in a set runs in constant time complexity.\n```\nif i not in check:\n```\ninstead of \n```\nif i not in banned\n```"
                    },
                    {
                        "username": "101rror",
                        "content": "Solution using Map-->>https://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/submissions/891374565/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple Solution <br>\\nMy solution Link : -> https://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/solutions/3141766/c-easy-and-simple-solution-using-hash-map/\\n<br>\\nDon\\'t Forgot to upvote it ."
                    }
                ]
            },
            {
                "id": 1787612,
                "content": [
                    {
                        "username": "shekharaditya",
                        "content": "i think in the example they should also show the [2,3] in the ans of [1,6,5] case as it is also less tha 6 "
                    },
                    {
                        "username": "pawan2806kumar",
                        "content": "individual integers are not asked no.. you just need to return the maximum number of integers that you can gather..\\n"
                    },
                    {
                        "username": "ayushacharya13",
                        "content": "same issue bro and the banned should be [1,3,5]."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "i got TLE coz i used list instead of set while storing elements 😫 just bad times"
                    },
                    {
                        "username": "sagar897",
                        "content": "why we r not using vector ' count method ? \n\nbecause it is slower then set , is it correct ?"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "[@Kaustav1810](/Kaustav1810)  Same Here !!"
                    },
                    {
                        "username": "pestlain",
                        "content": "same"
                    },
                    {
                        "username": "Kaustav1810",
                        "content": "same bro :("
                    },
                    {
                        "username": "21Cash",
                        "content": "this one shoulda been a easy"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "nice and simple problem"
                    },
                    {
                        "username": "Labracadabra",
                        "content": "Test #171 expects the answer \\'56\\' which I also get in my IDE, but here the same code outputs different answer - \\'44\\', how is it possible??"
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "Guys, my 205th test case failed on submission but it is running OK when I click on run what should I do."
                    },
                    {
                        "username": "blue262",
                        "content": "if you are passing any array to function\\nuse call by reference"
                    },
                    {
                        "username": "chintu12",
                        "content": " `\n\n    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:\n        check = set(banned) \n        count=0\n        summ=0\n        for i in range(1,n+1):\n            if i not in banned:\n                summ+=i\n                count+=1\n            if summ>maxSum:\n                return (count-1)\n            if summ==maxSum:\n                return count         \n            \n        return count`\n                \n \nwhy this code is giving TLE?"
                    },
                    {
                        "username": "chintu12",
                        "content": "[@stackphish](/stackphish)  it worked , thanks"
                    },
                    {
                        "username": "stackphish",
                        "content": "You probably need to check whether `i` is present in `check` instead of `banned` as checking in a set runs in constant time complexity.\n```\nif i not in check:\n```\ninstead of \n```\nif i not in banned\n```"
                    },
                    {
                        "username": "101rror",
                        "content": "Solution using Map-->>https://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/submissions/891374565/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple Solution <br>\\nMy solution Link : -> https://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/solutions/3141766/c-easy-and-simple-solution-using-hash-map/\\n<br>\\nDon\\'t Forgot to upvote it ."
                    }
                ]
            }
        ]
    }
]