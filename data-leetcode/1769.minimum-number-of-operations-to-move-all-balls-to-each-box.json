[
    {
        "title": "Delete Columns to Make Sorted",
        "question_content": "You are given an array of n strings strs, all of the same length.\nThe strings can be arranged such that there is one on each line, making a grid.\n\n\tFor example, strs = [\"abc\", \"bce\", \"cae\"] can be arranged as follows:\n\nabc\nbce\ncae\n\nYou want to delete the columns that are not sorted lexicographically. In the above example (0-indexed), columns 0 ('a', 'b', 'c') and 2 ('c', 'e', 'e') are sorted, while column 1 ('b', 'c', 'a') is not, so you would delete column 1.\nReturn the number of columns that you will delete.\n&nbsp;\nExample 1:\n\nInput: strs = [\"cba\",\"daf\",\"ghi\"]\nOutput: 1\nExplanation: The grid looks as follows:\n  cba\n  daf\n  ghi\nColumns 0 and 2 are sorted, but column 1 is not, so you only need to delete 1 column.\n\nExample 2:\n\nInput: strs = [\"a\",\"b\"]\nOutput: 0\nExplanation: The grid looks as follows:\n  a\n  b\nColumn 0 is the only column and is sorted, so you will not delete any columns.\n\nExample 3:\n\nInput: strs = [\"zyx\",\"wvu\",\"tsr\"]\nOutput: 3\nExplanation: The grid looks as follows:\n  zyx\n  wvu\n  tsr\nAll 3 columns are not sorted, so you will delete all 3.\n\n&nbsp;\nConstraints:\n\n\tn == strs.length\n\t1 <= n <= 100\n\t1 <= strs[i].length <= 1000\n\tstrs[i] consists of lowercase English letters.",
        "solutions": [
            {
                "id": 2989470,
                "title": "easiest-c-solution-with-detailed-explanation",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Intuition:** use a counter and if each char is lexicographically sorted column-wise.\\n\\n**Approach:**\\nFirst lets observe the given test example\\n![image](https://assets.leetcode.com/users/images/507a5d35-64d3-459c-a1bd-da9e768f0ded_1672712407.6624835.png)\\n* We can see that we are going through all the columns for comparision, so this is point 1. \\n* We need to compare the current char with the next char row-wise thus traversing will row-1, so this is point 2.\\n* If we find at any traversal that the order is not maintained, we need to delete the column according to the ques. So increment the counter and use break since the order is broken and we do not want to check that column any more, this is point 3.\\n* That\\'s it, just return the counter value now.\\n\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            for(int i=0; i<row-1; i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    delete_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return delete_count;\\n    }\\n};\\n```\\n**Time Complexity** => `O(row * col)`\\n**Space Complexity** => `O(1)`\\n\\n![image](https://assets.leetcode.com/users/images/025a6e75-7e39-4bdd-8ecd-ea9c6023729a_1672712882.8563874.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            for(int i=0; i<row-1; i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    delete_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return delete_count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989644,
                "title": "simple-java-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        // Initialize the delete count to 0\\n        int deleteCount = 0;\\n        // Get the number of rows and columns in the grid\\n        int n = strs.length;\\n        int m = strs[0].length();\\n        // Iterate through each column of the grid\\n        for (int i = 0; i < m; i++) {\\n            // Iterate through each element in the column\\n            for (int j = 1; j < n; j++) {\\n                // If the current element is lexicographically smaller than the previous element,\\n                // increment the delete count and break out of the loop\\n                if (strs[j].charAt(i) < strs[j - 1].charAt(i)) {\\n                    deleteCount++;\\n                    break;\\n                }\\n            }\\n        }\\n        // Return the delete count\\n        return deleteCount;\\n    }\\n}\\n```\\n\\n\\n# Code\\n```\\nclass Solution{\\npublic int minDeletionSize(String[] strs) {\\n    // Return 0 if the input array is null or empty\\n    if (strs == null || strs.length == 0) {\\n        return 0;\\n    }\\n    // Initialize the number of columns to the length of the first string\\n    int numColumns = strs[0].length();\\n    int numColumnsToDelete = 0;\\n    // Iterate through each column of the grid\\n    for (int i = 0; i < numColumns; i++) {\\n        // Initialize the current character to the first character in the column\\n        char currChar = strs[0].charAt(i);\\n        // Iterate through each element in the column\\n        for (int j = 1; j < strs.length; j++) {\\n            // If the current element is lexicographically smaller than the previous element,\\n            // increment the number of columns to delete and break out of the loop\\n            if (strs[j].charAt(i) < currChar) {\\n                numColumnsToDelete++;\\n                break;\\n            }\\n            // Otherwise, update the current character to the current element\\n            currChar = strs[j].charAt(i);\\n        }\\n    }\\n    // Return the number of columns to delete\\n    return numColumnsToDelete;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        // Initialize the delete count to 0\\n        int deleteCount = 0;\\n        // Get the number of rows and columns in the grid\\n        int n = strs.length;\\n        int m = strs[0].length();\\n        // Iterate through each column of the grid\\n        for (int i = 0; i < m; i++) {\\n            // Iterate through each element in the column\\n            for (int j = 1; j < n; j++) {\\n                // If the current element is lexicographically smaller than the previous element,\\n                // increment the delete count and break out of the loop\\n                if (strs[j].charAt(i) < strs[j - 1].charAt(i)) {\\n                    deleteCount++;\\n                    break;\\n                }\\n            }\\n        }\\n        // Return the delete count\\n        return deleteCount;\\n    }\\n}\\n```\n```\\nclass Solution{\\npublic int minDeletionSize(String[] strs) {\\n    // Return 0 if the input array is null or empty\\n    if (strs == null || strs.length == 0) {\\n        return 0;\\n    }\\n    // Initialize the number of columns to the length of the first string\\n    int numColumns = strs[0].length();\\n    int numColumnsToDelete = 0;\\n    // Iterate through each column of the grid\\n    for (int i = 0; i < numColumns; i++) {\\n        // Initialize the current character to the first character in the column\\n        char currChar = strs[0].charAt(i);\\n        // Iterate through each element in the column\\n        for (int j = 1; j < strs.length; j++) {\\n            // If the current element is lexicographically smaller than the previous element,\\n            // increment the number of columns to delete and break out of the loop\\n            if (strs[j].charAt(i) < currChar) {\\n                numColumnsToDelete++;\\n                break;\\n            }\\n            // Otherwise, update the current character to the current element\\n            currChar = strs[j].charAt(i);\\n        }\\n    }\\n    // Return the number of columns to delete\\n    return numColumnsToDelete;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 194919,
                "title": "python-count-unsorted-columns",
                "content": "Just count unsorted column numbers. \\n\\n`O(NlogNM)`, with `N <= 100`\\n```\\n    def minDeletionSize(self, A):\\n        return sum(list(col) != sorted(col) for col in zip(*A))\\n```\\n`O(NM)`\\n```\\n    def minDeletionSize(self, A):\\n        return sum(any(a > b for a, b in zip(col, col[1:])) for col in zip(*A))\\n```",
                "solutionTags": [],
                "code": "```\\n    def minDeletionSize(self, A):\\n        return sum(list(col) != sorted(col) for col in zip(*A))\\n```\n```\\n    def minDeletionSize(self, A):\\n        return sum(any(a > b for a, b in zip(col, col[1:])) for col in zip(*A))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2989395,
                "title": "3-different-java-codes",
                "content": "**If you find it useful please upvote it means a lot to me \\uD83D\\uDE0A**\\n\\n\\n# 84 % Fast\\n```\\npublic int minDeletionSize(String[] arr) {\\n    int count = 0;\\n    for(int i=0; i<arr[0].length(); i++){\\n        for(int j=1; j<arr.length; j++){\\n            if(arr[j].charAt(i) < arr[j-1].charAt(i)){\\n                count++;\\n                break;\\n            }\\n        }\\n    }     \\n    return count;\\n}\\n```\\n# 99.9 % Fast\\n```\\npublic int minDeletionSize(String[] strs) \\n{\\n    int len = strs.length;\\n    int wordlen = strs[0].length();\\n    int ans = 0;\\n        \\n    for(int i=0; i<wordlen; i++)\\n    {\\n        char prev = strs[0].charAt(i);\\n        for(int j=1; j<len; j++)\\n        {\\n            char ch = strs[j].charAt(i);\\n             if(ch < prev) \\n            {\\n                ans++;\\n                break;\\n            }\\n            prev = ch;\\n        }\\n    }\\n    return ans;       \\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/4d2ab3d9-4005-4ab5-8d40-b7c9eebad0b2_1672714083.5173585.png)\\n![UPVOTE MEME.jpg](https://assets.leetcode.com/users/images/c0e14b52-4f1e-4328-be55-9c3d894b7f7f_1672715067.254083.jpeg)\\n\\n# Not Fastest But Cool \\n```\\nclass Solution {\\n    public static int minDeletionSize(String[] S)\\n    {\\n        int answer = 0;\\n        int n = S.length;       \\n        int m = S[0].length(); \\n        char[][] matrix = new char[n][m];\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                matrix[i][j] = S[i].charAt(j);\\n            }\\n        }\\n        for(int col=0; col<m; col++){\\n            for(int row=1; row<n; row++){\\n                int min = matrix[row-1][col];\\n                if(matrix[row][col] < min){\\n                    answer++;\\n                    break;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minDeletionSize(String[] arr) {\\n    int count = 0;\\n    for(int i=0; i<arr[0].length(); i++){\\n        for(int j=1; j<arr.length; j++){\\n            if(arr[j].charAt(i) < arr[j-1].charAt(i)){\\n                count++;\\n                break;\\n            }\\n        }\\n    }     \\n    return count;\\n}\\n```\n```\\npublic int minDeletionSize(String[] strs) \\n{\\n    int len = strs.length;\\n    int wordlen = strs[0].length();\\n    int ans = 0;\\n        \\n    for(int i=0; i<wordlen; i++)\\n    {\\n        char prev = strs[0].charAt(i);\\n        for(int j=1; j<len; j++)\\n        {\\n            char ch = strs[j].charAt(i);\\n             if(ch < prev) \\n            {\\n                ans++;\\n                break;\\n            }\\n            prev = ch;\\n        }\\n    }\\n    return ans;       \\n}\\n```\n```\\nclass Solution {\\n    public static int minDeletionSize(String[] S)\\n    {\\n        int answer = 0;\\n        int n = S.length;       \\n        int m = S[0].length(); \\n        char[][] matrix = new char[n][m];\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                matrix[i][j] = S[i].charAt(j);\\n            }\\n        }\\n        for(int col=0; col<m; col++){\\n            for(int row=1; row<n; row++){\\n                int min = matrix[row-1][col];\\n                if(matrix[row][col] < min){\\n                    answer++;\\n                    break;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989165,
                "title": "python3-one-liner-iterative",
                "content": "**Solution 1:** Simply go though each column and check if the column is sorted or not by comparing it with its sorted version. Same as [lee215](https://leetcode.com/problems/delete-columns-to-make-sorted/discuss/194919/Python-Count-Unsorted-Columns)\\n\\n```python\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        return sum(list(column) != sorted(column) for column in zip(*strs))\\n```\\n\\n**Solution 2:** Iterativelly go through each column, and compare each element with the previous one in this column, if the current element is smaller than the previous one, this column is not sorted, so increase the result and don\\'t look farther in this column. Same as [Vlad](https://leetcode.com/problems/delete-columns-to-make-sorted/discuss/194916/C%2B%2B-brute-force-O(n-*-m))\\n```python\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        res = 0\\n        \\n        # for each column index\\n        for j in range(len(strs[0])):\\n            \\n            # for each row index start from 1, since we need to compare with the previous one.\\n            for i in range(1,len(strs)):\\n\\n                # this column is not sorted, don\\'t look farther.\\n                if strs[i][j] < strs[i-1][j]:\\n                    res += 1\\n                    break\\n        return res\\n```\\n\\n**Solution 3:** one-liner iterative from [SunnyvaleCA](https://leetcode.com/SunnyvaleCA/)\\'s comment below.\\n```python\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        return sum( any( strs[i][j]<strs[i-1][j] for i in range(1,len(strs)) ) for j in range(len(strs[0])))\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        return sum(list(column) != sorted(column) for column in zip(*strs))\\n```\n```python\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        res = 0\\n        \\n        # for each column index\\n        for j in range(len(strs[0])):\\n            \\n            # for each row index start from 1, since we need to compare with the previous one.\\n            for i in range(1,len(strs)):\\n\\n                # this column is not sorted, don\\'t look farther.\\n                if strs[i][j] < strs[i-1][j]:\\n                    res += 1\\n                    break\\n        return res\\n```\n```python\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        return sum( any( strs[i][j]<strs[i-1][j] for i in range(1,len(strs)) ) for j in range(len(strs[0])))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 194916,
                "title": "c-brute-force-o-n-m",
                "content": "Go column by column ```c```, then row by row ```i```. If ```A[i - 1][c] > A[i][c]```, then that column is unsorted - we increase the number of deleted columns and go to the next column.\\n```\\nint minDeletionSize(vector<string>& A, int res = 0) {\\n    if (A.empty()) return res;\\n    for (auto c = 0; c < A[0].size(); ++c)\\n        for (auto i = 1; i < A.size(); ++i) {\\n            if (A[i - 1][c] > A[i][c]) {\\n                ++res;\\n                break;\\n            }\\n        }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```c```\n```i```\n```A[i - 1][c] > A[i][c]```\n```\\nint minDeletionSize(vector<string>& A, int res = 0) {\\n    if (A.empty()) return res;\\n    for (auto c = 0; c < A[0].size(); ++c)\\n        for (auto i = 1; i < A.size(); ++i) {\\n            if (A[i - 1][c] > A[i][c]) {\\n                ++res;\\n                break;\\n            }\\n        }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2989277,
                "title": "c-o-nm-easy-to-understand-with-in-depth-explanation-and-examples",
                "content": "#### Table of Contents\\n\\n- [TL;DR](#tldr)\\n  - [Code](#code)\\n  - [Complexity](#complexity)\\n- [In Depth Analysis](#in-depth-analysis)\\n  - [Intuition](#intuition)\\n  - [Approach](#approach)\\n  - [Example](#example)\\n\\n# TL;DR\\n\\nCheck each column to ensure that it is in sorted order. If any elements breaks the sorting, increase the answer by one and move onto the next column\\n\\n## Code\\n\\n```c++\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        const int n = strs.size(), m = strs[0].size();\\n\\n        int ans = 0;\\n        for (int j = 0; j < m; j++)\\n            for (int i = 1; i < n; i++)\\n                if (strs[i][j] < strs[i - 1][j]) {\\n                    ans++;\\n                    break;\\n                }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n## Complexity\\n\\n**Time Complexity:** $$O(NM)$$ where $$N$$ is the number of rows and $$M$$ is the number of columns\\n**Space Complexity:** $$O(1)$$\\n\\n**PLEASE UPVOTE IF YOU FIND MY POST HELPFUL!! \\uD83E\\uDD7A\\uD83D\\uDE01**\\n\\n---\\n\\n# In Depth Analysis\\n\\n## Intuition\\n\\nIterate in column major order (the outer loop is columns, inner loop is rows) and make sure that each element in the column is greater than or equal to the one before it. In other words, ensure that `strs[i][j] >= str[i - 1][j]`. If any element breaks this rule, then we delete the column and move on\\n\\n## Approach \\n\\nIterate in column major order but starting at the second row each time. If any element is less than the the element in the previous row, we increase the answer and break out of the loop since we don\\'t need to check the rest of them. \\n\\nIn other words, we just check to see if `strs[i][j] < strs[i - 1][j]` at any point. If it is, we know it isn\\'t sorted properly and we want to delete the column. We just return `ans` at the end.\\n\\n## Example\\n\\nLets use the second example, where `strs = [\"cba\",\"daf\",\"ghi\"]`\\n\\n* Col = 0\\n  * Row = 1\\n    Check if `strs[i][j] < strs[i - 1][j] = strs[1][0] < strs[0][0] = \\'d\\' < \\'c\\'`, which is `false` so we go to the next row\\n  * Row = 2\\n    Check if `strs[i][j] < strs[i - 1][j] = strs[2][0] < strs[1][0] = \\'g\\' < \\'d\\'`, which is `false` so we go to the next column\\n* Col = 1\\n  * Row = 1\\n    Check if `strs[i][j] < strs[i - 1][j] = strs[1][1] < strs[0][1] = \\'a\\' < \\'b\\'`, which is `true` so we delete the row and move to the next column\\n* Col = 2\\n  * Row = 1\\n    Check if `strs[i][j] < strs[i - 1][j] = strs[1][2] < strs[0][2] = \\'f\\' < \\'a\\'`, which is `false` so we go to the next row\\n  * Row = 2\\n    Check if `strs[i][j] < strs[i - 1][j] = strs[2][2] < strs[1][2] = \\'i\\' < \\'f\\'`, which is `false` so we exit the loop\\n\\nAt the end, `ans = 1` which is correct\\n\\n**PLEASE UPVOTE IF YOU FIND MY POST HELPFUL!! \\uD83E\\uDD7A\\uD83D\\uDE01**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        const int n = strs.size(), m = strs[0].size();\\n\\n        int ans = 0;\\n        for (int j = 0; j < m; j++)\\n            for (int i = 1; i < n; i++)\\n                if (strs[i][j] < strs[i - 1][j]) {\\n                    ans++;\\n                    break;\\n                }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223870,
                "title": "python3-efficient-and-concise-without-sorting",
                "content": "```python\\n\\tdef minDeletionSize(self, strs: List[str]) -> int:\\n        m, n = len(strs), len(strs[0])\\n        count = 0\\n        \\n        for i in range(n):\\n            for j in range(1,m):\\n                if strs[j][i] < strs[j-1][i]:\\n                    count += 1\\n                    break\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\n\\tdef minDeletionSize(self, strs: List[str]) -> int:\\n        m, n = len(strs), len(strs[0])\\n        count = 0\\n        \\n        for i in range(n):\\n            for j in range(1,m):\\n                if strs[j][i] < strs[j-1][i]:\\n                    count += 1\\n                    break\\n        \\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2991965,
                "title": "c-solution-with-detailed-explanations",
                "content": "## Explanation:\\n\\n### Solution 01\\n\\n- Here we\\u2019ve to find the no of columns which are not sorted.\\n- First, we\\u2019ll take row & column numbers in ***n & m.***\\n- Then we\\u2019ll compare the column elements one by one in the for loop.\\n- If we find any one column is not in sorted order we\\u2019ll increase the *********ans********* count & break it.\\n- Return the ans.\\n- **Time complexity:** O(n*m).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int n = strs.size();\\n        int m = strs[0].size();\\n        int ans = 0;\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n-1; j++){\\n                if(strs[j][i] > strs[j+1][i]){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "String Matching",
                    "Matrix"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int n = strs.size();\\n        int m = strs[0].size();\\n        int ans = 0;\\n\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n-1; j++){\\n                if(strs[j][i] > strs[j+1][i]){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989202,
                "title": "python-one-line",
                "content": "```python []\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        return sum(col != sorted(col) for col in map(list, zip(*strs)))\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        return sum(col != sorted(col) for col in map(list, zip(*strs)))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197402,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] A) {\\n        int count = 0;\\n        for (int i = 0; i < A[0].length(); i++) {\\n            for (int j = 1; j < A.length; j++) {\\n                if (A[j-1].charAt(i) > A[j].charAt(i)) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n         }\\n        \\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minDeletionSize(String[] A) {\\n        int count = 0;\\n        for (int i = 0; i < A[0].length(); i++) {\\n            for (int j = 1; j < A.length; j++) {\\n                if (A[j-1].charAt(i) > A[j].charAt(i)) {\\n                    count++;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 422457,
                "title": "javascript-beats-98-w-comments",
                "content": "```javascript\\nvar minDeletionSize = function(A) {\\n    //number of deletions\\n    var deletions = 0;\\n    \\n    //iterate through first word in array\\n    for (var index = 0; index < A[0].length; index++) {\\n        \\n        //now iterate through array\\n        for (var i = 0; i < A.length - 1; i++) {\\n            \\n            //check if the character at the index in this word is greater than the next\\n            if (A[i].charAt(index) > A[i + 1].charAt(index)) {\\n                //increment deletions (we would need to delete this char to make it sorted)\\n                deletions++;\\n                \\n                //break out of current for loop\\n                break;\\n            }\\n            \\n        }\\n    }\\n    \\n    //result\\n    return deletions;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar minDeletionSize = function(A) {\\n    //number of deletions\\n    var deletions = 0;\\n    \\n    //iterate through first word in array\\n    for (var index = 0; index < A[0].length; index++) {\\n        \\n        //now iterate through array\\n        for (var i = 0; i < A.length - 1; i++) {\\n            \\n            //check if the character at the index in this word is greater than the next\\n            if (A[i].charAt(index) > A[i + 1].charAt(index)) {\\n                //increment deletions (we would need to delete this char to make it sorted)\\n                deletions++;\\n                \\n                //break out of current for loop\\n                break;\\n            }\\n            \\n        }\\n    }\\n    \\n    //result\\n    return deletions;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2989456,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=JTA_WgDqx8o&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=3) if you are interested.\\n\\n---\\n\\n# Intuition\\nCompare two characters in adjacent row in the same column to see if they are sorted, we can delete that column if they are not sorted.\\n\\n# Approach\\nBrute Force. First we iterate the columns, then iterate the rows. If the character in the previous row is greater than the character in the current row, then we can delete this column. \\n\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& s) {\\n        int ans = 0;\\n        // iterate cols\\n        for (int col = 0; col < s[0].size(); col++) {\\n            // iterate rows\\n            for (int row = 1; row < s.size(); row++) {\\n                // if the character in the previous row is greater than the character in the current row\\n                // then we can delete this column\\n                if (s[row - 1][col] > s[row][col]) {\\n                    ans += 1;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& s) {\\n        int ans = 0;\\n        // iterate cols\\n        for (int col = 0; col < s[0].size(); col++) {\\n            // iterate rows\\n            for (int row = 1; row < s.size(); row++) {\\n                // if the character in the previous row is greater than the character in the current row\\n                // then we can delete this column\\n                if (s[row - 1][col] > s[row][col]) {\\n                    ans += 1;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209807,
                "title": "88ms-python-1-liner",
                "content": "```\\nclass Solution(object):\\n    def minDeletionSize(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n        return len([s for s in zip(*A) if list(s) != sorted(s)])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minDeletionSize(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n        return len([s for s in zip(*A) if list(s) != sorted(s)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990398,
                "title": "c-intuitive-explained",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        \\n        int n = strs.size();\\n        int m = strs[0].size();\\n        int dlt = 0;\\n\\n        for( int j=0 ; j<m ; j++ ){\\n            // store every current column\\n            string currCol = \"\";\\n\\n            for( int i=0 ; i<n ; i++ ){\\n                currCol += strs[i][j];\\n            }\\n\\n            // check that columns is lexicographically sorted or not \\n            string revCol = currCol;\\n            sort( currCol.begin(), currCol.end() );\\n            if( revCol != currCol ) dlt++;\\n        }\\n\\n        return dlt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        \\n        int n = strs.size();\\n        int m = strs[0].size();\\n        int dlt = 0;\\n\\n        for( int j=0 ; j<m ; j++ ){\\n            // store every current column\\n            string currCol = \"\";\\n\\n            for( int i=0 ; i<n ; i++ ){\\n                currCol += strs[i][j];\\n            }\\n\\n            // check that columns is lexicographically sorted or not \\n            string revCol = currCol;\\n            sort( currCol.begin(), currCol.end() );\\n            if( revCol != currCol ) dlt++;\\n        }\\n\\n        return dlt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244899,
                "title": "java-straightforward-solution",
                "content": "**Well, Example 2 is really bad, so I used it as my special consition in line 3:**\\n```\\n if(A.length <= 1 || A[0].length() <= 1) return 0;\\n```\\n**Then use two for loop to go Straightforward!**\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] A) {\\n        if(A.length <= 1 || A[0].length() <= 1) return 0;\\n        int res = 0;\\n        for(int i = 0; i < A[0].length(); i++){\\n            for(int j = 1; j < A.length; j++){\\n                if(A[j].charAt(i) < A[j-1].charAt(i)){\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n if(A.length <= 1 || A[0].length() <= 1) return 0;\\n```\n```\\nclass Solution {\\n    public int minDeletionSize(String[] A) {\\n        if(A.length <= 1 || A[0].length() <= 1) return 0;\\n        int res = 0;\\n        for(int i = 0; i < A[0].length(); i++){\\n            for(int j = 1; j < A.length; j++){\\n                if(A[j].charAt(i) < A[j-1].charAt(i)){\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991429,
                "title": "another-linq-solution-super-simple",
                "content": "1. For each column `i`, construct the column:\\n  `col = strs.Select(s => s[i])`\\n2. Then check whether the column matches its sorted form:\\n  `col.OrderBy(c => c).SequenceEqual(col)`\\n```csharp\\npublic class Solution\\n{\\n    public int MinDeletionSize(string[] strs)\\n    {\\n        int res = 0;\\n\\n        for (int i = 0; i < strs[0].Length; i++)\\n        {\\n            var col = strs.Select(s => s[i]);\\n            if (!col.OrderBy(c => c).SequenceEqual(col)) res++;\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n\\nIn the latest version of C#, this part\\n`col.OrderBy(c => c).SequenceEqual(col)`\\ncan be shortened to:\\n`col.Order().SequenceEqual(col)`\\n\\nI don\\'t like the negated `if` condition. Here is how to get rid of it:\\n```csharp\\npublic class Solution\\n{\\n    public int MinDeletionSize(string[] strs)\\n    {\\n        int res = strs[0].Length;\\n\\n        for (int i = 0; i < strs[0].Length; i++)\\n        {\\n            var col = strs.Select(s => s[i]);\\n            if (col.OrderBy(c => c).SequenceEqual(col)) res--;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public int MinDeletionSize(string[] strs)\\n    {\\n        int res = 0;\\n\\n        for (int i = 0; i < strs[0].Length; i++)\\n        {\\n            var col = strs.Select(s => s[i]);\\n            if (!col.OrderBy(c => c).SequenceEqual(col)) res++;\\n        }\\n\\n        return res;\\n    }\\n}\\n```\n```csharp\\npublic class Solution\\n{\\n    public int MinDeletionSize(string[] strs)\\n    {\\n        int res = strs[0].Length;\\n\\n        for (int i = 0; i < strs[0].Length; i++)\\n        {\\n            var col = strs.Select(s => s[i]);\\n            if (col.OrderBy(c => c).SequenceEqual(col)) res--;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989760,
                "title": "python-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        c=0\\n        for col in range(len(strs[0])):\\n            for row in range(len(strs)-1):\\n                if ord(strs[row][col])>ord(strs[row+1][col]):\\n                    print(strs[row][col],strs[row+1][col])\\n                    c+=1\\n                    break\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        c=0\\n        for col in range(len(strs[0])):\\n            for row in range(len(strs)-1):\\n                if ord(strs[row][col])>ord(strs[row+1][col]):\\n                    print(strs[row][col],strs[row+1][col])\\n                    c+=1\\n                    break\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723450,
                "title": "short-clean-java-javascript-solution",
                "content": "``` java []\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0; i<strs[0].length(); i++){\\n            for(int j=0; j<strs.length-1; j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n```javascript []\\nvar minDeletionSize = function(strs) {\\n    let count = 0;\\n    for(let i=0; i<strs[0].length; i++){\\n        for(let j=0; j<strs.length-1; j++){\\n            if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                count++;\\n                break;\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0; i<strs[0].length(); i++){\\n            for(int j=0; j<strs.length-1; j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```javascript []\\nvar minDeletionSize = function(strs) {\\n    let count = 0;\\n    for(let i=0; i<strs[0].length; i++){\\n        for(let j=0; j<strs.length-1; j++){\\n            if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                count++;\\n                break;\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991557,
                "title": "javascript-solutions-step-by-step",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMerge and compare strings in each column\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is a function that counts how many columns of characters in a string array do not satisfy the order from smallest to largest.\\n\\nThe variable minDeletionSize is the name of the function. It takes in a parameter strs, which represents the string array to be checked.\\n\\nThe variable count is used to count how many columns of characters do not satisfy the order from smallest to largest. It is initialized to 0.\\n\\nNext is a loop that iterates through each character (i.e., each column) of strs[0].\\n\\nThe variable str is used to store the characters of the current column. It is initialized to an empty string.\\n\\nNext is another loop that iterates through each string (i.e., each row) in strs. For each string, it adds the character of the current column to str.\\n\\nThen, the variable check is used to store whether the characters of the current column satisfy the order from smallest to largest. This is done by converting the string str to a character array, sorting the character array, and then converting the sorted character array back to a string and comparing it with the original string.\\n\\nIf the value of check is false, it means that the characters of the current column do not satisfy the order from smallest to largest. In this case, count is incremented by 1.\\n\\nFinally, the function returns count.\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(L)$$\\nL is strs length\\n\\n# Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {number}\\n */\\nvar minDeletionSize = function(strs) {\\n    let count = 0\\n    for(let i = 0; i < strs[0].length; i++){\\n        let str = \\'\\'\\n        for(let j = 0; j < strs.length; j++){\\n            str += strs[j][i]\\n        }\\n        let check = str.split(\\'\\').sort().join(\\'\\') == str\\n        if(!check){\\n            count += 1\\n        }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {number}\\n */\\nvar minDeletionSize = function(strs) {\\n    let count = 0\\n    for(let i = 0; i < strs[0].length; i++){\\n        let str = \\'\\'\\n        for(let j = 0; j < strs.length; j++){\\n            str += strs[j][i]\\n        }\\n        let check = str.split(\\'\\').sort().join(\\'\\') == str\\n        if(!check){\\n            count += 1\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2990824,
                "title": "simplest-c-approach-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(row*col)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n      \\n        int count=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0; j<strs.size();j++){\\n                if( j+1 < strs.size() && strs[j][i] > strs[j+1][i]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n         \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n      \\n        int count=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0; j<strs.size();j++){\\n                if( j+1 < strs.size() && strs[j][i] > strs[j+1][i]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n         \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990400,
                "title": "java-short-and-explained-beats-93-3",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate over the columns from 0 to strLen-1, for each column col:\\n\\n- Iterate over the rows row from 1 to n - 1:\\n\\n  - If the character at index col in the string strs[row] is smaller than the character at index col in the string strs[row - 1], then increment the counter variable answer. Also, we can break the inner loop here as we find the current column unsorted.\\n  - Otherwise, we check the next row.\\n\\n# Complexity\\n- Time complexity: $$O(N*K)$$ . As, you can see there are two nested for loops. **K** is the `strLen` and **N** is the `strs` array length.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ . We haven\\'t used any extra space. The spaces taken here are constant. Meaning they do not depend on the size of the input parameters.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Submission link: \\nhttps://leetcode.com/problems/delete-columns-to-make-sorted/submissions/870222049/\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        // number of columns..\\n        int strLen = strs[0].length();\\n        // cols to be deleted.. \\n        int dels = 0;\\n\\n        for(int col=0; col<strLen; col++){\\n            // by default take \\'0\\' as it is the smallest character\\n            char prev = \\'0\\';\\n            for(String str : strs){\\n                char cur = str.charAt(col);\\n                // compare with prev. if prev was bigger than cur,\\n                // it is unsorted. so, increase count and break;\\n                if(cur<prev){\\n                    dels++;\\n                    break;\\n                }\\n                prev = cur;\\n            }\\n        }\\n        return dels;\\n    }\\n}\\n```\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/9a1fce67-3636-4da5-8a8a-52f395f24a50_1672725016.0186899.png)\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        // number of columns..\\n        int strLen = strs[0].length();\\n        // cols to be deleted.. \\n        int dels = 0;\\n\\n        for(int col=0; col<strLen; col++){\\n            // by default take \\'0\\' as it is the smallest character\\n            char prev = \\'0\\';\\n            for(String str : strs){\\n                char cur = str.charAt(col);\\n                // compare with prev. if prev was bigger than cur,\\n                // it is unsorted. so, increase count and break;\\n                if(cur<prev){\\n                    dels++;\\n                    break;\\n                }\\n                prev = cur;\\n            }\\n        }\\n        return dels;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990299,
                "title": "super-easy-to-understand-fully-explained-different-approach-java",
                "content": "# Request \\uD83D\\uDE0A :\\n```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D.\\n```\\n# Approach [Explained in Comments] :\\n```\\nclass Solution \\n{\\n    public int minDeletionSize(String[] strs) \\n    {\\n        if(strs==null||strs.length==0)\\n            return 0;//base case\\n        int res=0;//result\\n        int n=strs[0].length();//for longest column length\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=0;//should be 0 every time i increases\\n            for(;j<strs.length-1;j++)\\n            {\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i))\\n                    break;\\n            }\\n            if(j!=strs.length-1)// j not reach charcter of lowest string since break came\\n                res++;//one column not sorted found\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D.\\n```\n```\\nclass Solution \\n{\\n    public int minDeletionSize(String[] strs) \\n    {\\n        if(strs==null||strs.length==0)\\n            return 0;//base case\\n        int res=0;//result\\n        int n=strs[0].length();//for longest column length\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=0;//should be 0 every time i increases\\n            for(;j<strs.length-1;j++)\\n            {\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i))\\n                    break;\\n            }\\n            if(j!=strs.length-1)// j not reach charcter of lowest string since break came\\n                res++;//one column not sorted found\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989143,
                "title": "daily-leetcoding-challenge-january-day-3",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **üìå Do you want to learn the problem thoroughly?**\n  Read [**‚≠ê  LeetCode Official Solution‚≠ê**](https://leetcode.com/problems/delete-columns-to-make-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**‚≠ê  LeetCode Official Solution‚≠ê**](https://leetcode.com/problems/delete-columns-to-make-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 517343,
                "title": "python-99-easy-to-read",
                "content": "Yes, technically sorted should have worse O() than a linear scan, but in this particular context it delivers better performance (>99%) and a shorter code.\\n\\nWe basically take a slice of A, store in c and compare against sorted c.\\n\\n```\\nclass Solution(object):\\n    def minDeletionSize(self, A):\\n\\n        ret = 0\\n        \\n        for c in zip(*A): \\n            if list(c) != sorted(c): \\n                ret += 1\\n                \\n        return ret \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minDeletionSize(self, A):\\n\\n        ret = 0\\n        \\n        for c in zip(*A): \\n            if list(c) != sorted(c): \\n                ret += 1\\n                \\n        return ret \\n```",
                "codeTag": "Java"
            },
            {
                "id": 385630,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] A) {\\n        int count = 0;\\n        \\n        // Go through each char column\\n        for (int j = 0; j < A[0].length(); j++) {\\n            // Go through each string\\n            for (int i = 0; i < A.length - 1; i++) {\\n                // If column\\'s char is decreasing on the next string,\\n                // count as deletion index\\n                if (A[i].charAt(j) > A[i + 1].charAt(j)) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] A) {\\n        int count = 0;\\n        \\n        // Go through each char column\\n        for (int j = 0; j < A[0].length(); j++) {\\n            // Go through each string\\n            for (int i = 0; i < A.length - 1; i++) {\\n                // If column\\'s char is decreasing on the next string,\\n                // count as deletion index\\n                if (A[i].charAt(j) > A[i + 1].charAt(j)) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991674,
                "title": "python-easy-beats-97-multiple-approaches",
                "content": "# Approach 1\\nUse a loop with zip and *strs. *strs will convert lists into tuple and zip will create another tuple with all the values at first index in each tuple in a tuple at first index.\\n**For Example:**\\n> Lets say there is a list with [[\"abc\"],[\"cdf\"]] then *strs will create a tuple ((\"abc\"),(\"cdf\")) and zip will convert them in ((\"ac\"),(\"bd\"),(\"cf\")).\\n\\nNow check if the tuple converted into a list and sorted tuple that would also return a sorted list aren\\'t equal. if they are not equal then count+=1. return count.\\n\\n# Complexity\\n- Time complexity: **Not sure what these convertion will take.**\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n\\n        counter = 0\\n\\n        for i in zip(*strs):\\n            if list(i)!=sorted(i):\\n                counter+=1\\n\\n        return counter              \\n```\\n\\n# Approach 2\\nWe can create a grid with all the strings as list then create another list to store the transpose of the grid. after that we can create another list to store the sorted list of that transposed grid and compare it with transpose of grid if it is not equal then we can simply increment the counter. (**This is too listy, i guess :D**)\\n\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n\\n        grid = []\\n\\n        for i in range(len(strs)):\\n            grid.append(list(strs[i]))\\n\\n\\n        result = [[grid[j][i] for j in range(len(grid))] for i in range(len(grid[0]))] \\n\\n\\n        new = []\\n\\n        for i in range(len(result)):\\n            new.append(\"\".join(sorted(result[i])))\\n\\n        count = 0\\n\\n        for i in range(len(result)):\\n            if \"\".join(result[i])!=new[i]:\\n                count+=1\\n        \\n       \\n\\n        return count           \\n\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n\\n        counter = 0\\n\\n        for i in zip(*strs):\\n            if list(i)!=sorted(i):\\n                counter+=1\\n\\n        return counter              \\n```\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n\\n        grid = []\\n\\n        for i in range(len(strs)):\\n            grid.append(list(strs[i]))\\n\\n\\n        result = [[grid[j][i] for j in range(len(grid))] for i in range(len(grid[0]))] \\n\\n\\n        new = []\\n\\n        for i in range(len(result)):\\n            new.append(\"\".join(sorted(result[i])))\\n\\n        count = 0\\n\\n        for i in range(len(result)):\\n            if \"\".join(result[i])!=new[i]:\\n                count+=1\\n        \\n       \\n\\n        return count           \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990789,
                "title": "easy-c-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(n^2)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int result = 0;\\n\\n        for(int i=0; i<strs[0].size(); ++i)\\n            for(int j=1; j<strs.size(); ++j)\\n                if(strs[j][i] < strs[j-1][i]){\\n                    ++result;\\n                    break;\\n                }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int result = 0;\\n\\n        for(int i=0; i<strs[0].size(); ++i)\\n            for(int j=1; j<strs.size(); ++j)\\n                if(strs[j][i] < strs[j-1][i]){\\n                    ++result;\\n                    break;\\n                }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990685,
                "title": "c-simple-logic-row-and-col-space-o-1-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) \\n    {\\n        int n = strs.size();\\n        int m = strs[0].size();\\n        \\n        int ans=0;\\n        \\n        // just check for each column, and if we got wrong lexicographically order just remove that and incraese count by 1\\n        for(int j=0;j<m;j++)        // each column\\n        {\\n            for(int i=1;i<n;i++)    // each row\\n            {\\n                if(strs[i-1][j] > strs[i][j])\\n                {\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) \\n    {\\n        int n = strs.size();\\n        int m = strs[0].size();\\n        \\n        int ans=0;\\n        \\n        // just check for each column, and if we got wrong lexicographically order just remove that and incraese count by 1\\n        for(int j=0;j<m;j++)        // each column\\n        {\\n            for(int i=1;i<n;i++)    // each row\\n            {\\n                if(strs[i-1][j] > strs[i][j])\\n                {\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989260,
                "title": "brute-force-approach-python-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe simply traverse the matrix column wise, when we encounter that two consecutive elements of the column are not in lexicographic order, we add the column number in a temporary list `c`.\\nAfter Traversing the whole list of strings, there\\'s a high chance of having redundant values in the list `c`. Thus , we typecaste the list `c` to a set, which will drop any redundant values in the list and have distinct column numbers to be deleted. At the end we will simply return the length of the set `c`.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        c = []\\n        for i in range(len(strs)-1):\\n            for j in range(len(strs[0])):\\n                if strs[i][j] > strs[i+1][j]:\\n                    c.append(j)\\n        return len(set(c))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        c = []\\n        for i in range(len(strs)-1):\\n            for j in range(len(strs[0])):\\n                if strs[i][j] > strs[i+1][j]:\\n                    c.append(j)\\n        return len(set(c))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991057,
                "title": "c-easy-fully-explained-in-hindi",
                "content": "# Intuition\\nJaisa question m bola h waisa he krna h (check for all char)\\n\\n# Approach\\nham sabse phle first word pr jayenge or uske first, second...nd all character ko remaining word ke first second ..nd all character se match krenge(how ??check if condition in my code) agar koi character condition satisfy nahi kr rha h to hmare count jo initially 0 tha usme increament krenge or loop ko break kr lenge for that char only.\\nwe will use 2 for loop for that\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)Constraints bhut chote h\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>&s) {\\n        int ans=0;\\n        for(int i=0;i<s[0].size();i++)\\n            for(int j=1;j<s.size();j++)\\n             if(s[j][i]<s[j-1][i]){\\n                ans++;\\n                break;\\n             }\\n             return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>&s) {\\n        int ans=0;\\n        for(int i=0;i<s[0].size();i++)\\n            for(int j=1;j<s.size();j++)\\n             if(s[j][i]<s[j-1][i]){\\n                ans++;\\n                break;\\n             }\\n             return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989849,
                "title": "c-java-and-javascript-o-n-solution-easy-to-understand",
                "content": "# Java Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int row=strs.length;\\n        int col=strs[0].length();\\n        int ans=0;\\n\\n        for(int i=0;i<col;i++)\\n        {\\n            for(int j=0;j<row-1;j++)\\n            {\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i))\\n                {\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& s) {\\n        int col=s[0].length();\\n        int row=s.size();\\n        int ans=0;\\n        for(int i=0;i<col;i++)\\n        {\\n            for(int j=0;j<row-1;j++)\\n            {\\n                if(s[j][i]>s[j+1][i])\\n                {\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# JavaScript Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {number}\\n */\\nvar minDeletionSize = function(strs) {\\n    const row=strs.length;\\n    const col=strs[0].length;\\n    let ans=0;\\n    for(let i=0;i<col;i++)\\n    {\\n        for(let j=0;j<row-1;j++)\\n        {\\n            if(strs[j][i]>strs[j+1][i])\\n            {\\n                ans++;\\n                break;\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int row=strs.length;\\n        int col=strs[0].length();\\n        int ans=0;\\n\\n        for(int i=0;i<col;i++)\\n        {\\n            for(int j=0;j<row-1;j++)\\n            {\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i))\\n                {\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& s) {\\n        int col=s[0].length();\\n        int row=s.size();\\n        int ans=0;\\n        for(int i=0;i<col;i++)\\n        {\\n            for(int j=0;j<row-1;j++)\\n            {\\n                if(s[j][i]>s[j+1][i])\\n                {\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n/**\\n * @param {string[]} strs\\n * @return {number}\\n */\\nvar minDeletionSize = function(strs) {\\n    const row=strs.length;\\n    const col=strs[0].length;\\n    let ans=0;\\n    for(let i=0;i<col;i++)\\n    {\\n        for(let j=0;j<row-1;j++)\\n        {\\n            if(strs[j][i]>strs[j+1][i])\\n            {\\n                ans++;\\n                break;\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989543,
                "title": "simple-java-solution-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Since we are talking about a grid, we might need a nested loop to solve the problem.\\n- One way to solve this problem would be iterating over a particular column in a grid and checking whether that particular column in sorted.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a variable to keep track of the number of columns to be deleted. Let\\'s call it `colsDelete`. \\n- Have an outer loop to iterate over the length of any string in `strs`. (Since all the strings in `strs` have same length)\\n- The inner loop will iterate over all the strings in `strs` i.e. `strs.length`. This ensures that we are traversing columnwise. \\n- Now check whether `(strs[j].charAt(i) < strs[j-1].charAt(i))`. This means we are checking whether two adjacent rows in a column are lexiographically sorted or not.\\n- If not then increment `colsDelete` and `break` the inner loop as we do not need to check further whether that column is sorted.\\n- Finally, after checking for all columns, return `colsDelete`\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int colsDelete = 0; \\n\\n        //Iterating over the length of any string in strs. Here we took strs[0]\\n        for(int i=0; i<strs[0].length(); i++){\\n\\n            //Iterating over all the strings in strs\\n            for(int j=1; j<strs.length; j++){\\n\\n                if(strs[j].charAt(i) < strs[j-1].charAt(i)){\\n                    colsDelete++;\\n                    break;\\n                } \\n            }\\n        }\\n        return colsDelete;\\n    }\\n}\\n```\\n\\n**Please do Upvote if found helpful**",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int colsDelete = 0; \\n\\n        //Iterating over the length of any string in strs. Here we took strs[0]\\n        for(int i=0; i<strs[0].length(); i++){\\n\\n            //Iterating over all the strings in strs\\n            for(int j=1; j<strs.length; j++){\\n\\n                if(strs[j].charAt(i) < strs[j-1].charAt(i)){\\n                    colsDelete++;\\n                    break;\\n                } \\n            }\\n        }\\n        return colsDelete;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989304,
                "title": "c-c-java-python-brute-force",
                "content": "\\n```C++ []\\nint minDeletionSize(vector<string>& strs) {\\n    int remove = 0;\\n    for(int i=0 ; i<strs[0].size();++i)\\n        for(int j=0;j<strs.size()-1;++j)\\n            if(strs[j][i] > strs[j+1][i]){\\n                ++remove;\\n                break;\\n            }\\n    return remove;\\n```\\n```java []\\npublic int minDeletionSize(String[] strs) {\\n    int remove = 0;\\n    for(int i=0 ; i<strs[0].length();i++)\\n        for(int j=0;j<strs.length-1;j++)\\n            if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                ++remove;\\n                break;\\n            }\\n    return remove;\\n```\\n```c []\\nint minDeletionSize(char ** strs, int strsSize){\\n    int remove = 0;\\n    for(int i=0 ; i<strlen(strs[0]);++i)\\n        for(int j=0;j<strsSize-1;++j)\\n            if(strs[j][i] > strs[j+1][i]){\\n                ++remove;\\n                break;\\n            }\\n    return remove;\\n```\\n```python []\\ndef minDeletionSize(self, strs):\\n    remove = 0\\n    for i in range(len(strs[0])):\\n        for j in range(len(strs)-1):\\n            if(strs[j][i] > strs[j+1][i]):\\n                remove += 1\\n                break\\n    return remove \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```C++ []\\nint minDeletionSize(vector<string>& strs) {\\n    int remove = 0;\\n    for(int i=0 ; i<strs[0].size();++i)\\n        for(int j=0;j<strs.size()-1;++j)\\n            if(strs[j][i] > strs[j+1][i]){\\n                ++remove;\\n                break;\\n            }\\n    return remove;\\n```\n```java []\\npublic int minDeletionSize(String[] strs) {\\n    int remove = 0;\\n    for(int i=0 ; i<strs[0].length();i++)\\n        for(int j=0;j<strs.length-1;j++)\\n            if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                ++remove;\\n                break;\\n            }\\n    return remove;\\n```\n```c []\\nint minDeletionSize(char ** strs, int strsSize){\\n    int remove = 0;\\n    for(int i=0 ; i<strlen(strs[0]);++i)\\n        for(int j=0;j<strsSize-1;++j)\\n            if(strs[j][i] > strs[j+1][i]){\\n                ++remove;\\n                break;\\n            }\\n    return remove;\\n```\n```python []\\ndef minDeletionSize(self, strs):\\n    remove = 0\\n    for i in range(len(strs[0])):\\n        for j in range(len(strs)-1):\\n            if(strs[j][i] > strs[j+1][i]):\\n                remove += 1\\n                break\\n    return remove \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2989210,
                "title": "python-o-m-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        del_col = 0\\n        for c in range(len(strs[0])):\\n            for r in range(len(strs)-1):\\n                if strs[r][c] > strs[r+1][c]:\\n                    del_col += 1\\n                    break\\n        return del_col\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        del_col = 0\\n        for c in range(len(strs[0])):\\n            for r in range(len(strs)-1):\\n                if strs[r][c] > strs[r+1][c]:\\n                    del_col += 1\\n                    break\\n        return del_col\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249501,
                "title": "golang-solution-with-quick-explanation",
                "content": "This solution loops through every column, and then if the previous letter in the column is greater than the current letter, we know that this column can be removed.\\n\\n``` go\\nfunc minDeletionSize(strs []string) int {\\n\\tres := 0\\n\\tfor i := 0; i < len(strs[0]); i++ {\\n\\t\\tfor j := 1; j < len(strs); j++ {\\n\\t\\t\\tif strs[j][i] < strs[j-1][i] {\\n\\t\\t\\t\\tres++\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc minDeletionSize(strs []string) int {\\n\\tres := 0\\n\\tfor i := 0; i < len(strs[0]); i++ {\\n\\t\\tfor j := 1; j < len(strs); j++ {\\n\\t\\t\\tif strs[j][i] < strs[j-1][i] {\\n\\t\\t\\t\\tres++\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2995674,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int ans=0;\\n        for(int i=0;i<strs[0].size();i++)\\n        {\\n            for(int j=1;j<strs.size();j++)\\n            {\\n                if(strs[j][i]<strs[j-1][i])\\n                {\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int ans=0;\\n        for(int i=0;i<strs[0].size();i++)\\n        {\\n            for(int j=1;j<strs.size();j++)\\n            {\\n                if(strs[j][i]<strs[j-1][i])\\n                {\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993186,
                "title": "easy-c-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing a counter and increment it every time we got lexicographically unsorted characters.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We are going through all the columns, so this is outer loop.\\n2. We need to compare the current character with character at next row of same column, so traversal will be less than row-1.\\n3. If current character is greater than next row character, then increment counter and break from loop.\\n4. At last, return counter value.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        \\n        int deletedCount = 0;\\n        int r = strs.size();\\n        int c = strs[0].size();\\n\\n        /*\\n        1. We are going through all the columns, so this is outer loop.\\n        2. We need to compare the currentChar with char at next row of same column, so traversal will be < row-1.\\n        3. If current char is > next row char, then increment deletedCount and break from loop.\\n        4. At last, return deletedCount.\\n        */\\n        \\n        for(int j=0; j<c; j++){\\n            for(int i=0; i<r-1; i++){\\n                if(strs[i][j] > strs[i+1][j]){\\n                    deletedCount++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return deletedCount;\\n    }\\n};\\n```\\n**Do UPVOTE, if you find this approach helpful.**\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        \\n        int deletedCount = 0;\\n        int r = strs.size();\\n        int c = strs[0].size();\\n\\n        /*\\n        1. We are going through all the columns, so this is outer loop.\\n        2. We need to compare the currentChar with char at next row of same column, so traversal will be < row-1.\\n        3. If current char is > next row char, then increment deletedCount and break from loop.\\n        4. At last, return deletedCount.\\n        */\\n        \\n        for(int j=0; j<c; j++){\\n            for(int i=0; i<r-1; i++){\\n                if(strs[i][j] > strs[i+1][j]){\\n                    deletedCount++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return deletedCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992494,
                "title": "easy-c-solution",
                "content": "Here is the code for the question:\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int strlen = strs[0].length(), n = strs.size();\\n        int count{0};\\n        for (int i{0}; i<strlen; i++) {\\n            int a = \\'a\\';\\n            for (int j{0}; j<n; j++) {\\n                if (a <= strs[j][i]) {\\n                    a=strs[j][i];\\n                }\\n                else {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```\\n\\n*Upvote if it helped!*",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int strlen = strs[0].length(), n = strs.size();\\n        int count{0};\\n        for (int i{0}; i<strlen; i++) {\\n            int a = \\'a\\';\\n            for (int j{0}; j<n; j++) {\\n                if (a <= strs[j][i]) {\\n                    a=strs[j][i];\\n                }\\n                else {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992451,
                "title": "java-easiest-solution-possible",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int x = strs[0].length(), n = strs.length;\\n        int ans = 0;\\n        for (int j = 0; j < x; ++j) {\\n            for (int i = 1; i < n; ++i) {\\n                if (strs[i].charAt(j) < strs[i - 1].charAt(j)) {\\n                    ++ans;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int x = strs[0].length(), n = strs.length;\\n        int ans = 0;\\n        for (int j = 0; j < x; ++j) {\\n            for (int i = 1; i < n; ++i) {\\n                if (strs[i].charAt(j) < strs[i - 1].charAt(j)) {\\n                    ++ans;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990754,
                "title": "c-most-optimized-easy-short-clean-code",
                "content": "![image](https://assets.leetcode.com/users/images/ebb1f9d3-e025-4a0f-9f5d-6e49e414e63b_1672728455.6099532.png)\\n\\n**T->O(m * n) [Worst Case Complexity] && S->O(1)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint minDeletionSize(vector<string>& strs) {\\n\\t\\t\\t\\tint n = strs.size();\\n\\t\\t\\t\\tint m = strs[0].size();\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tfor(int col = 0 ; col < m ; col++){\\n\\t\\t\\t\\t\\tfor(int row = 0 ; row < n-1 ; row++){\\n\\t\\t\\t\\t\\t\\tif(strs[row][col] > strs[row+1][col]){\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn count;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint minDeletionSize(vector<string>& strs) {\\n\\t\\t\\t\\tint n = strs.size();\\n\\t\\t\\t\\tint m = strs[0].size();\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tfor(int col = 0 ; col < m ; col++){\\n\\t\\t\\t\\t\\tfor(int row = 0 ; row < n-1 ; row++){\\n\\t\\t\\t\\t\\t\\tif(strs[row][col] > strs[row+1][col]){\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2990652,
                "title": "c-simple-approach",
                "content": "# Complexity\\n- Time complexity:\\nO(nxs)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int minDeletionSize(vector<string>& strs) \\n    {\\n        int n=strs.size(), sz=strs[0].size();\\n        int cnt=0;\\n        for(int j=0; j<sz; j++)\\n        {\\n            for(int i=1; i<n; i++)\\n            {\\n                if(strs[i][j] < strs[i-1][j]) \\n                {\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minDeletionSize(vector<string>& strs) \\n    {\\n        int n=strs.size(), sz=strs[0].size();\\n        int cnt=0;\\n        for(int j=0; j<sz; j++)\\n        {\\n            for(int i=1; i<n; i++)\\n            {\\n                if(strs[i][j] < strs[i-1][j]) \\n                {\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990516,
                "title": "5ms-speed-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBased on the Aschii values we can justify wether it is sorted or not.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere i have created a count varibale for storing the answer value and a for loop for each coloum and then declared a temp variable which stores the temperory value of previous aschi value of the character, with this \\'temp\\' i have chechked whether the present character value is greater then the previous one. In case of failure the loop is terminated and the count value is increased.\\n# Complexity\\n- Time complexity: 5 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 42.8MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++) {\\n        \\tint temp = 0;\\n        \\tfor(int j=0;j<strs.length;j++) {\\n        \\t\\tint a = strs[j].charAt(i);\\n        \\t\\tif(a>=temp) {\\n        \\t\\t\\ttemp = a;\\n        \\t\\t}else {\\n        \\t\\t\\tcount++;\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t}\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++) {\\n        \\tint temp = 0;\\n        \\tfor(int j=0;j<strs.length;j++) {\\n        \\t\\tint a = strs[j].charAt(i);\\n        \\t\\tif(a>=temp) {\\n        \\t\\t\\ttemp = a;\\n        \\t\\t}else {\\n        \\t\\t\\tcount++;\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t}\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990389,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n       bool check(string st)\\n        {\\n            int count=0;\\n            for(int i=1; i<st.length(); i++)\\n                if(st[i]<st[i-1])\\n                    return 1;   \\n            return 0;\\n        }\\n    int minDeletionSize(vector<string>& str) {\\n        int count=0;\\n        int col = str[0].size();\\n        for(int j=0; j<col; j++)\\n            {\\n                string str1 = \"\";\\n                for(int i=0; i<str.size(); i++)\\n                    str1 += str[i][j];\\n                if(check(str1)) count++;\\n            }\\n            return count;\\n        }\\n    };\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n       bool check(string st)\\n        {\\n            int count=0;\\n            for(int i=1; i<st.length(); i++)\\n                if(st[i]<st[i-1])\\n                    return 1;   \\n            return 0;\\n        }\\n    int minDeletionSize(vector<string>& str) {\\n        int count=0;\\n        int col = str[0].size();\\n        for(int j=0; j<col; j++)\\n            {\\n                string str1 = \"\";\\n                for(int i=0; i<str.size(); i++)\\n                    str1 += str[i][j];\\n                if(check(str1)) count++;\\n            }\\n            return count;\\n        }\\n    };\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990169,
                "title": "using-map-short-easy-c",
                "content": "\\nThis can be done in a single pass! Look at the code.\\nn: strs.size() , m = strs[0].size()\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n    int minDeletionSize(vector<string>& strs) {\\n        unordered_map<int,bool> column;   //** store column to be deleted \\n\\n        for(int i =1;i<strs.size();i++)\\n            for(int j=0;j<strs[i].size();j++)\\n                if(strs[i][j]<strs[i-1][j])column[j]=true;\\n            \\n        return column.size();\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int minDeletionSize(vector<string>& strs) {\\n        unordered_map<int,bool> column;   //** store column to be deleted \\n\\n        for(int i =1;i<strs.size();i++)\\n            for(int j=0;j<strs[i].size();j++)\\n                if(strs[i][j]<strs[i-1][j])column[j]=true;\\n            \\n        return column.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2989628,
                "title": "java-easy-iterative-solution",
                "content": "# Approach\\nWe use nested for loop.\\nWe take the column number in the outer loop\\nand the row number in the inner loop.\\nWe use the ascii values to check the lexicographic order.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(m x n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public static int minDeletionSize(String[] strs) {\\n        int c=0;\\n        int l = strs.length;\\n        for (int i = 0; i < strs[0].length(); i++) {\\n            for (int j = 0; j <l-1 ; j++) {\\n                if((int)strs[j].charAt(i)>(int)strs[j+1].charAt(i))\\n                {\\n                    c++;\\n                    break;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int minDeletionSize(String[] strs) {\\n        int c=0;\\n        int l = strs.length;\\n        for (int i = 0; i < strs[0].length(); i++) {\\n            for (int j = 0; j <l-1 ; j++) {\\n                if((int)strs[j].charAt(i)>(int)strs[j+1].charAt(i))\\n                {\\n                    c++;\\n                    break;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989497,
                "title": "c-easiest-possible-approach-100-efficient-in-memory-simple-loop",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& A) {\\n        int cnt = 0; // keep the track of non-ordered columns\\n        \\n        for(int i=0; i<A[0].length(); i++){\\n            bool flag = false;\\n            for(int j=1; j<A.size(); j++){\\n                if(A[j][i] < A[j-1][i])\\n                    flag = true; //mark true if found in non decreasing order\\n            }\\n            if(flag)\\n                cnt++; //update count\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n# Please upvote if you find this helpful.\\uD83D\\uDE4F\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& A) {\\n        int cnt = 0; // keep the track of non-ordered columns\\n        \\n        for(int i=0; i<A[0].length(); i++){\\n            bool flag = false;\\n            for(int j=1; j<A.size(); j++){\\n                if(A[j][i] < A[j-1][i])\\n                    flag = true; //mark true if found in non decreasing order\\n            }\\n            if(flag)\\n                cnt++; //update count\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989460,
                "title": "iterative-approach-c-easy",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(m x n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(m x n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int c=0;\\n        for(int i=0;i<strs[0].size();i++){\\n            for(int k=0;k<strs.size()-1;k++){\\n                if(strs[k][i]>strs[k+1][i]){\\n                    c++;break;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int c=0;\\n        for(int i=0;i<strs[0].size();i++){\\n            for(int k=0;k<strs.size()-1;k++){\\n                if(strs[k][i]>strs[k+1][i]){\\n                    c++;break;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989419,
                "title": "c-code-using-brute-force",
                "content": "# Intuition\\n- Brute Force \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Iterate in column major order but starting at the second row each time. If any element is less than the the element in the previous row, we increase the count and break out of the loop since we don\\'t need to check the rest of them.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Codestr\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count=0;\\n        for(int i=0;i<strs[0].length();i++)\\n        {\\n            for(int j=0;j<strs.size()-1;j++)\\n            {\\n                if(strs[j][i]>strs[j+1][i])\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count=0;\\n        for(int i=0;i<strs[0].length();i++)\\n        {\\n            for(int j=0;j<strs.size()-1;j++)\\n            {\\n                if(strs[j][i]>strs[j+1][i])\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989406,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n    func minDeletionSize(_ strs: [String]) -> Int {\\n        strs.reduce(Array(repeating:\"a\", count:strs[0].count)) { zip($0,$1).map { $0.0 > $0.1 ? \"~\" : $0.1 }}.filter { $0 == \"~\" }.count\\n    }\\n}\\n```\\n**NOTE:** This technically qualifies as a one-liner, since the `return` keyword was omitted.\\n\\n---\\n\\n**One-Liner, expanded and annotated (accepted answer)**\\n```\\nclass Solution {\\n    func minDeletionSize(_ strs: [String]) -> Int {\\n        strs.reduce(Array(repeating:\"a\", count:strs[0].count)) { columns, str in\\n\\t\\t\\t// Approach:\\n\\t\\t\\t// - Replace column element with `~` where lexographic order not maintained.\\n\\t\\t\\t// - At the end, return count of `~` in `columns`\\n            zip(columns, str)\\n            .map {\\n                // $0.0 is `columns` element \\n                // $0.1 is `str` element\\n                $0.0 > $0.1 ? \"~\" : $0.1  // `~` is (arbitrarily-chosen) larger ASCII value than `z`\\n            }\\n        }\\n        .filter { ch in ch == \"~\" }\\n        .count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minDeletionSize(_ strs: [String]) -> Int {\\n        strs.reduce(Array(repeating:\"a\", count:strs[0].count)) { zip($0,$1).map { $0.0 > $0.1 ? \"~\" : $0.1 }}.filter { $0 == \"~\" }.count\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func minDeletionSize(_ strs: [String]) -> Int {\\n        strs.reduce(Array(repeating:\"a\", count:strs[0].count)) { columns, str in\\n\\t\\t\\t// Approach:\\n\\t\\t\\t// - Replace column element with `~` where lexographic order not maintained.\\n\\t\\t\\t// - At the end, return count of `~` in `columns`\\n            zip(columns, str)\\n            .map {\\n                // $0.0 is `columns` element \\n                // $0.1 is `str` element\\n                $0.0 > $0.1 ? \"~\" : $0.1  // `~` is (arbitrarily-chosen) larger ASCII value than `z`\\n            }\\n        }\\n        .filter { ch in ch == \"~\" }\\n        .count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635180,
                "title": "without-zip-function-in-python-faster-than-82-o-n-2",
                "content": "```\\n        c= 0\\n        for i in range(len(strs[0])):\\n             for j in range(1,len(strs)):\\n                if strs[j-1][i] > strs[j][i]:\\n                    c+= 1\\n                    break\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        c= 0\\n        for i in range(len(strs[0])):\\n             for j in range(1,len(strs)):\\n                if strs[j-1][i] > strs[j][i]:\\n                    c+= 1\\n                    break\\n        return c\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1854921,
                "title": "easy-solution-o-nk-faster-than-others",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.size()-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    delete_count++;\\n                    break;\\n                }\\n                    \\n            }\\n        }\\n        return delete_count;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.size()-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    delete_count++;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1080827,
                "title": "c-easy-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& A) {\\n        int cnt = 0;\\n        \\n        for(int i=0; i<A[0].length(); i++){\\n            bool flag = false;\\n            for(int j=1; j<A.size(); j++){\\n                if(A[j][i] < A[j-1][i])\\n                    flag = true;\\n            }\\n            if(flag)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\nKindly upvote if this helps you!! :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& A) {\\n        int cnt = 0;\\n        \\n        for(int i=0; i<A[0].length(); i++){\\n            bool flag = false;\\n            for(int j=1; j<A.size(); j++){\\n                if(A[j][i] < A[j-1][i])\\n                    flag = true;\\n            }\\n            if(flag)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907550,
                "title": "java-5-ms",
                "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] A) {\\n        int result = 0;\\n        char[][] aToChars = new char[A.length][A[0].length()];\\n        int k = 0;\\n        \\n        for(String s: A){\\n            aToChars[k] = s.toCharArray();\\n            k++;\\n        }\\n        \\n        for(int i = 0; i< A[0].length(); i++){\\n            for(int j = 1; j < A.length; j++){\\n                if(aToChars[j-1][i] > aToChars[j][i]){\\n                    result++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n       return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minDeletionSize(String[] A) {\\n        int result = 0;\\n        char[][] aToChars = new char[A.length][A[0].length()];\\n        int k = 0;\\n        \\n        for(String s: A){\\n            aToChars[k] = s.toCharArray();\\n            k++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 751152,
                "title": "python-3-submission",
                "content": "```\\nclass Solution:\\n    def minDeletionSize(self, A: List[str]) -> int:\\n        strings = []\\n        for i in range(0,len(A[0])):\\n            temp = \"\".join([item[i] for item in A])\\n            if \"\".join(sorted(temp)) == temp:\\n                pass\\n            else:\\n                strings.append(1)\\n        return len(strings)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, A: List[str]) -> int:\\n        strings = []\\n        for i in range(0,len(A[0])):\\n            temp = \"\".join([item[i] for item in A])\\n            if \"\".join(sorted(temp)) == temp:\\n                pass\\n            else:\\n                strings.append(1)\\n        return len(strings)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741397,
                "title": "c-one-liner",
                "content": "```csharp\\npublic int MinDeletionSize(string[] A) {\\n\\treturn Enumerable\\n\\t\\t.Range(0, A[0].Length)\\n\\t\\t.Select(i => new string(A.Select(s => s[i]).ToArray()))\\n\\t\\t.Count(col => new string(col.OrderBy(c => c).ToArray()) != col);\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MinDeletionSize(string[] A) {\\n\\treturn Enumerable\\n\\t\\t.Range(0, A[0].Length)\\n\\t\\t.Select(i => new string(A.Select(s => s[i]).ToArray()))\\n\\t\\t.Count(col => new string(col.OrderBy(c => c).ToArray()) != col);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 427225,
                "title": "python3-6-line-96ms-beats-99-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def minDeletionSize(self, A: List[str]) -> int:\\n        zipped=list(map(list,zip(*A)))\\n        count=0\\n        for item in zipped:\\n            if item!=sorted(item):\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, A: List[str]) -> int:\\n        zipped=list(map(list,zip(*A)))\\n        count=0\\n        for item in zipped:\\n            if item!=sorted(item):\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 240225,
                "title": "python-128-ms",
                "content": "```\\n check =0\\n        for i in range(len(A[0])):\\n            stack=[ord(x[i]) for x in A]\\n            if stack != sorted(stack):\\n                check += 1\\n            \\n        return check\\n\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n check =0\\n        for i in range(len(A[0])):\\n            stack=[ord(x[i]) for x in A]\\n            if stack != sorted(stack):\\n                check += 1\\n            \\n        return check\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 198993,
                "title": "simple-javascript-solution-with-comments",
                "content": "@LeetCode please stop using/allowing single capital letters for param names. It is literally non-existent in real code.\\nSome people might even take note and start using it themselves.\\n\\n```\\nvar minDeletionSize = function(A) {\\n    \\n    // increment this if we find a\\n    // column that is out of order\\n    let numColumnsToDelete = 0;\\n\\n    // all strings in the array\\n    // are the same length\\n    const strLength = A[0].length;\\n\\n    // outer loop checks entire string\\n    for (let i = 0; i < strLength; i++) {\\n\\n        // inner loop checks the colunns\\n        for (let j = 0; j < A.length - 1; j++) {\\n\\n            const top = A[j][i];\\n            const bottom = A[j + 1][i];\\n\\n            if (top > bottom) {\\n                numColumnsToDelete++;\\n                break;\\n            }\\n        }\\n    }\\n\\n    return numColumnsToDelete;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minDeletionSize = function(A) {\\n    \\n    // increment this if we find a\\n    // column that is out of order\\n    let numColumnsToDelete = 0;\\n\\n    // all strings in the array\\n    // are the same length\\n    const strLength = A[0].length;\\n\\n    // outer loop checks entire string\\n    for (let i = 0; i < strLength; i++) {\\n\\n        // inner loop checks the colunns\\n        for (let j = 0; j < A.length - 1; j++) {\\n\\n            const top = A[j][i];\\n            const bottom = A[j + 1][i];\\n\\n            if (top > bottom) {\\n                numColumnsToDelete++;\\n                break;\\n            }\\n        }\\n    }\\n\\n    return numColumnsToDelete;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 194896,
                "title": "stl-overkill",
                "content": "```\\nclass Solution {\\n    public:\\n        int minDeletionSize(vector<string>& A) {\\n            vector<string> s(A.front().size(), string(A.size(), \\' \\'));\\n            for (int r = 0; r < A.size(); ++r) {\\n                for (int c = 0; c < A[r].size(); ++c) {\\n                    s[c][r] = A[r][c];\\n                }\\n            }\\n            return count_if(s.begin(), s.end(), [](auto & p) {\\n                return !is_sorted(p.begin(), p.end());\\n            });\\n        }\\n    };\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public:\\n        int minDeletionSize(vector<string>& A) {\\n            vector<string> s(A.front().size(), string(A.size(), \\' \\'));\\n            for (int r = 0; r < A.size(); ++r) {\\n                for (int c = 0; c < A[r].size(); ++c) {\\n                    s[c][r] = A[r][c];\\n                }\\n            }\\n            return count_if(s.begin(), s.end(), [](auto & p) {\\n                return !is_sorted(p.begin(), p.end());\\n            });\\n        }\\n    };\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339326,
                "title": "best-solution-98-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use an array to keep track of which columns need to be deleted. Initially, all columns are marked for deletion, and we mark columns as not needing to be deleted as we check each column. At the end, we return the count of columns that are marked for deletion.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {number}\\n */\\nvar minDeletionSize = function(strs) {\\n    const sortedCols = new Array(strs[0].length).fill(true);\\n    let count = 0;\\n    for(let i = 0; i < strs[0].length; i++){\\n        for(let j = 1; j < strs.length; j++){\\n            if(strs[j][i] < strs[j-1][i]){\\n                sortedCols[i] = false;\\n                break;\\n            }\\n        }\\n        if(!sortedCols[i]){\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {number}\\n */\\nvar minDeletionSize = function(strs) {\\n    const sortedCols = new Array(strs[0].length).fill(true);\\n    let count = 0;\\n    for(let i = 0; i < strs[0].length; i++){\\n        for(let j = 1; j < strs.length; j++){\\n            if(strs[j][i] < strs[j-1][i]){\\n                sortedCols[i] = false;\\n                break;\\n            }\\n        }\\n        if(!sortedCols[i]){\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3252864,
                "title": "python-98-fastest-solution-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing python zip function, get list of coulums and check for ordering in each column.\\n\\n# Code\\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        m,n,ans=len(strs),len(strs[0]),0\\n        l=list(zip(*strs))\\n        for item in l:\\n            for i in range(1,len(item)):\\n                if item[i]<item[i-1]:\\n                    ans+=1\\n                    break\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        m,n,ans=len(strs),len(strs[0]),0\\n        l=list(zip(*strs))\\n        for item in l:\\n            for i in range(1,len(item)):\\n                if item[i]<item[i-1]:\\n                    ans+=1\\n                    break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011950,
                "title": "c-solution-with-full-explanation-and-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe needed to delete \"columns\" that are not lexicographically sorted therefore we will need 2 loops and will have to travel across the matrix in column-wise fashion\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe vector given is 1-D but it is a vector of strings so it can be thought of as a 2-D array with row elements as the strings and column elements as the individual characters of the string \\nOuter loop will iterate across the columns.\\nNo. if columns = length of string \\n\\nInner loop will iterate across the rows \\nNo. of rows = no. of elements in the vector \\n\\nif ASCII value of element of column i is greater than ASCII value of element of column i+1 then it is not sorted and we increase the count \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2) - 2 nested for loops so n square time complexity\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) - declared only one additional variable to keep track of count so constant space complexity\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        // ELEMENTS SHOULD BE SORTED LEXICOGRAPHICALLY - IN ALPHABETICAL ORDER **COLUMN WISE** \\n\\n        int n = strs.size();\\n        int cnt = 0 ; \\n        // have to check column-wise therefore outerloop for columns\\n        for (int i = 0 ; i<strs[0].size() ; i++)\\n        {\\n            // inner loop for rows \\n            for (int j = 0 ; j<strs.size()-1; j++)\\n            {\\n                // if ASCII value of previous element is greater than that of next then it is not sorted, we increase count and break the loop to move on to the next column\\n                if(strs[j][i]>strs[j+1][i])\\n                {\\n                    cnt++;\\n                    break;\\n                }\\n                else continue ; \\n            }\\n        }\\n        return cnt ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        // ELEMENTS SHOULD BE SORTED LEXICOGRAPHICALLY - IN ALPHABETICAL ORDER **COLUMN WISE** \\n\\n        int n = strs.size();\\n        int cnt = 0 ; \\n        // have to check column-wise therefore outerloop for columns\\n        for (int i = 0 ; i<strs[0].size() ; i++)\\n        {\\n            // inner loop for rows \\n            for (int j = 0 ; j<strs.size()-1; j++)\\n            {\\n                // if ASCII value of previous element is greater than that of next then it is not sorted, we increase count and break the loop to move on to the next column\\n                if(strs[j][i]>strs[j+1][i])\\n                {\\n                    cnt++;\\n                    break;\\n                }\\n                else continue ; \\n            }\\n        }\\n        return cnt ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994175,
                "title": "c-image-explanation-easiest-solution-very-easy-to-understand-understandable",
                "content": "\\napproach :- simply make a string of all same characters of given set of strings  and see if the sorted string is same as our string .if not that means it is not in lexicograpphycally .so increase count by one unit \\n\\n![IMG_20230104_011304.jpg](https://assets.leetcode.com/users/images/241b0105-a8be-4567-8eac-964a4b8c05b1_1672775259.2226002.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int size=strs[0].size();\\n        int ans=0;\\n        string temp=\"\";\\n        string temp2=\"\";\\n        for(int i=0;i<size;++i){\\n        for(auto string: strs){\\n            temp+=string[i];\\n        } \\n         string temp2=temp;\\n         sort(temp.begin(),temp.end());\\n        if(temp!=temp2){\\n         ans++;\\n        } temp=\"\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int size=strs[0].size();\\n        int ans=0;\\n        string temp=\"\";\\n        string temp2=\"\";\\n        for(int i=0;i<size;++i){\\n        for(auto string: strs){\\n            temp+=string[i];\\n        } \\n         string temp2=temp;\\n         sort(temp.begin(),temp.end());\\n        if(temp!=temp2){\\n         ans++;\\n        } temp=\"\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994134,
                "title": "simple-java-code",
                "content": "# Intuition \\nWe have to check each character of each string in array and break the loop as soon as we find non-lexicographicaly arranged character in column.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int len=strs.length;\\n       int count=0;\\n        int k=strs[0].length();\\n        if(strs==null) return count;\\n        for(int i=0;i<k;i++)\\n        {\\n           \\nfor(int j=0;j<len-1;j++)\\n            {\\n                \\n                if(strs[j].charAt(i)>strs[j+1].charAt(i))\\n                {\\n                    count++;\\n                    break;\\n                }\\n\\n            }\\n        }\\n       \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int len=strs.length;\\n       int count=0;\\n        int k=strs[0].length();\\n        if(strs==null) return count;\\n        for(int i=0;i<k;i++)\\n        {\\n           \\nfor(int j=0;j<len-1;j++)\\n            {\\n                \\n                if(strs[j].charAt(i)>strs[j+1].charAt(i))\\n                {\\n                    count++;\\n                    break;\\n                }\\n\\n            }\\n        }\\n       \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993715,
                "title": "easy-and-simple-2-approaches-with-simple-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        // initializing deletCol variable\\n        int deleteCol = 0;\\n        // traverse on to get first letter of each String\\n        // Approach => getting column from the matrix \\n        for(int i = 0; i < strs[0].length(); i ++) {\\n            // initializing temporay for checking sorted or not\\n            String tempStr = \"\";\\n            for(int j = 0; j < strs.length; j ++) {\\n                tempStr += strs[j].charAt(i);\\n            }\\n            // check tempStr\\n            if(!isSorted(tempStr)) deleteCol++;\\n        }\\n        return deleteCol;\\n    }\\n    //  create method for checking sorted or not\\n    public  boolean isSorted(String str) {\\n        for(int i = 0; i < str.length() - 1; i ++){\\n            if(str.charAt(i) > str.charAt(i + 1))  return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n```\\npublic int minDeletionSize(String[] strs) {\\n         // initializing deletCol variable\\n        int deleteCol = 0;\\n\\n        // traverse on to get first letter of each String\\n        // Approach => getting column from the matrix\\n        for(int i = 0; i < strs[0].length(); i ++) {\\n            String tempStr = \"\";\\n            for(int j = 1; j < strs.length; j ++) {\\n                tempStr += strs[j].charAt(i);\\n                // checking character are in sorted or not\\n                if(strs[j].charAt(i) < strs[j-1].charAt(i)){\\n                        deleteCol ++;\\n                        break;\\n                }\\n            }\\n            //if(!isSorted(tempStr)) deleteCol++;\\n        }\\n        return deleteCol;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        // initializing deletCol variable\\n        int deleteCol = 0;\\n        // traverse on to get first letter of each String\\n        // Approach => getting column from the matrix \\n        for(int i = 0; i < strs[0].length(); i ++) {\\n            // initializing temporay for checking sorted or not\\n            String tempStr = \"\";\\n            for(int j = 0; j < strs.length; j ++) {\\n                tempStr += strs[j].charAt(i);\\n            }\\n            // check tempStr\\n            if(!isSorted(tempStr)) deleteCol++;\\n        }\\n        return deleteCol;\\n    }\\n    //  create method for checking sorted or not\\n    public  boolean isSorted(String str) {\\n        for(int i = 0; i < str.length() - 1; i ++){\\n            if(str.charAt(i) > str.charAt(i + 1))  return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\npublic int minDeletionSize(String[] strs) {\\n         // initializing deletCol variable\\n        int deleteCol = 0;\\n\\n        // traverse on to get first letter of each String\\n        // Approach => getting column from the matrix\\n        for(int i = 0; i < strs[0].length(); i ++) {\\n            String tempStr = \"\";\\n            for(int j = 1; j < strs.length; j ++) {\\n                tempStr += strs[j].charAt(i);\\n                // checking character are in sorted or not\\n                if(strs[j].charAt(i) < strs[j-1].charAt(i)){\\n                        deleteCol ++;\\n                        break;\\n                }\\n            }\\n            //if(!isSorted(tempStr)) deleteCol++;\\n        }\\n        return deleteCol;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992427,
                "title": "simple-o-mn-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse array and check for condition\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nouter loop:for loop for traversing a string\\ninner loop:for loop for checking the same index character over the array\\nif condition satisfied count++ and end inner for loop I used i==strs.length to end it\\nreturn count\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int cnt=0;\\n        for(int j=0;j<strs[0].length();j++){\\n            for(int i=1;i<strs.length;i++){\\n                if(strs[i-1].charAt(j)>strs[i].charAt(j)){\\n                    cnt++;i=strs.length;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int cnt=0;\\n        for(int j=0;j<strs[0].length();j++){\\n            for(int i=1;i<strs.length;i++){\\n                if(strs[i-1].charAt(j)>strs[i].charAt(j)){\\n                    cnt++;i=strs.length;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992264,
                "title": "dart-solution-beats-100",
                "content": "# Complexity\\n### Time complexity:\\n- $$O(n*m)$$ -> worst case \\n    - Where (n) is the number of **strs** , and (m) is the length of strings.\\n\\n- **Space complexity**:\\nSolution is : $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\nint minDeletionSize(List<String> strs) {\\n  var deletedColumnsCount = 0;\\n  for (var i = 0; i < strs[0].length; i++) {\\n    for (var j = 0; j < strs.length - 1; j++) {\\n      if (strs[j][i].codeUnits[0] > strs[j + 1][i].codeUnits[0]) {\\n        deletedColumnsCount++;\\n        break;\\n      }\\n    }\\n  }\\n  return deletedColumnsCount;\\n}\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\nint minDeletionSize(List<String> strs) {\\n  var deletedColumnsCount = 0;\\n  for (var i = 0; i < strs[0].length; i++) {\\n    for (var j = 0; j < strs.length - 1; j++) {\\n      if (strs[j][i].codeUnits[0] > strs[j + 1][i].codeUnits[0]) {\\n        deletedColumnsCount++;\\n        break;\\n      }\\n    }\\n  }\\n  return deletedColumnsCount;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991752,
                "title": "o-n-m-easy-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int n=strs[0].size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            char curr=\\'a\\';\\n            for(string s:strs)\\n            {\\n                if(s[i]>=curr) curr=s[i];\\n                else\\n                {\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int n=strs[0].size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            char curr=\\'a\\';\\n            for(string s:strs)\\n            {\\n                if(s[i]>=curr) curr=s[i];\\n                else\\n                {\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991728,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinDeletionSize(string[] strs) {\\n        int columnDel = 0;\\n        for(int i = 0; i < strs[0].Length; i++)\\n        {\\n            for(int j = 0; j < strs.Length-1; j++)\\n            {\\n                if(strs[j][i] > strs[j+1][i])\\n                {\\n                    columnDel++;\\n                    break;\\n                }\\n            }\\n        }\\n        return columnDel;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinDeletionSize(string[] strs) {\\n        int columnDel = 0;\\n        for(int i = 0; i < strs[0].Length; i++)\\n        {\\n            for(int j = 0; j < strs.Length-1; j++)\\n            {\\n                if(strs[j][i] > strs[j+1][i])\\n                {\\n                    columnDel++;\\n                    break;\\n                }\\n            }\\n        }\\n        return columnDel;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991691,
                "title": "100-0ms-explained-beats-100-proof",
                "content": "# UPVOTE PLS\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/c1030d8d-c24a-4807-aac6-96f28a069d50_1672740417.848588.png)\\n\\n# Complexity\\n- Time complexity: O(N*rowSize)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] A) {\\n        int deleted = 0;\\n        if (A == null || A.length == 0) return deleted;\\n        int rowSize = A[0].length();\\n        \\n        for (int col = 0; col < rowSize; col++){\\n            if (!isSorted(A, col)) deleted++;\\n        }\\n        \\n        return deleted;\\n    }\\n    \\n    boolean isSorted(String[] A, int col){\\n        int N = A.length;\\n        char prev = (char)0;\\n        for (int i = 0; i < N; i++){\\n            char c = A[i].charAt(col);\\n            //If out of order\\n            if (c < prev) return false;\\n            //update prev\\n            prev = c;\\n        }\\n        \\n        return true; //In order the whole time\\n    }\\n}\\n\\n\\npython \\n\\nclass Solution:\\n    def minDeletionSize(self, A: List[str]) -> int:\\n        return len([True for col in zip(*A) if sorted(col) != list(col)])\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] A) {\\n        int deleted = 0;\\n        if (A == null || A.length == 0) return deleted;\\n        int rowSize = A[0].length();\\n        \\n        for (int col = 0; col < rowSize; col++){\\n            if (!isSorted(A, col)) deleted++;\\n        }\\n        \\n        return deleted;\\n    }\\n    \\n    boolean isSorted(String[] A, int col){\\n        int N = A.length;\\n        char prev = (char)0;\\n        for (int i = 0; i < N; i++){\\n            char c = A[i].charAt(col);\\n            //If out of order\\n            if (c < prev) return false;\\n            //update prev\\n            prev = c;\\n        }\\n        \\n        return true; //In order the whole time\\n    }\\n}\\n\\n\\npython \\n\\nclass Solution:\\n    def minDeletionSize(self, A: List[str]) -> int:\\n        return len([True for col in zip(*A) if sorted(col) != list(col)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991545,
                "title": "ruby-1-liner",
                "content": "\\n\\n# Code\\n```ruby\\ndef min_deletion_size(strs)\\n    strs.map(&:chars).transpose.count{ |col| col.each_cons(2).any?{ _1 > _2 } } \\nend\\n```\\n<hr>\\n\\n# Tests:\\n```ruby\\nrequire \\'test/unit\\'\\nclass Test_min_deletion_size < Test::Unit::TestCase\\n    def test_\\n        assert_equal 1, min_deletion_size([\"cba\",\"daf\",\"ghi\"])\\n        assert_equal 0, min_deletion_size([\"a\",\"b\"])\\n        assert_equal 3, min_deletion_size([\"zyx\",\"wvu\",\"tsr\"])\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef min_deletion_size(strs)\\n    strs.map(&:chars).transpose.count{ |col| col.each_cons(2).any?{ _1 > _2 } } \\nend\\n```\n```ruby\\nrequire \\'test/unit\\'\\nclass Test_min_deletion_size < Test::Unit::TestCase\\n    def test_\\n        assert_equal 1, min_deletion_size([\"cba\",\"daf\",\"ghi\"])\\n        assert_equal 0, min_deletion_size([\"a\",\"b\"])\\n        assert_equal 3, min_deletion_size([\"zyx\",\"wvu\",\"tsr\"])\\n    end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991268,
                "title": "commented-line-by-line-easy",
                "content": "# Code\\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        # count: to store no of columns we need to delete\\n        count=0\\n        # for columns\\n        for col in range(len(strs[0])):\\n            #for rows\\n            for row in range(1,len(strs)):\\n                #if current char is smaller than previous char in that column\\n                #then we need to delete that column \\n                #so just increase the count\\n                if strs[row-1][col] > strs[row][col]:\\n                    count+=1\\n                    #break bcz if any char is not sorted lexi.. \\n                    #then the whole will be deleted\\n                    #so need to check further char of column\\n                    break\\n        return count\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        # count: to store no of columns we need to delete\\n        count=0\\n        # for columns\\n        for col in range(len(strs[0])):\\n            #for rows\\n            for row in range(1,len(strs)):\\n                #if current char is smaller than previous char in that column\\n                #then we need to delete that column \\n                #so just increase the count\\n                if strs[row-1][col] > strs[row][col]:\\n                    count+=1\\n                    #break bcz if any char is not sorted lexi.. \\n                    #then the whole will be deleted\\n                    #so need to check further char of column\\n                    break\\n        return count\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991085,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        vector<char> v[1005];\\n        for(int j=0; j<strs[0].size(); j++) {\\n            for(int i=0; i<strs.size(); i++) {\\n                v[j].push_back(strs[i][j]);\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0; i<strs[0].size(); i++) {\\n            if(!is_sorted(v[i].begin(), v[i].end())) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        vector<char> v[1005];\\n        for(int j=0; j<strs[0].size(); j++) {\\n            for(int i=0; i<strs.size(); i++) {\\n                v[j].push_back(strs[i][j]);\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0; i<strs[0].size(); i++) {\\n            if(!is_sorted(v[i].begin(), v[i].end())) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991001,
                "title": "simple-and-easy-to-understand-c",
                "content": "# Intuition\\n**Basically 2-D vector traversal**\\n# Approach\\nFirst, we are traversing throgh the entire string vector and checking whether the first character  of consecutive strings are in alphabetical order or not ,then the second character ...... upto the last character.\\n# Complexity\\n- Time complexity:\\n# **O(n*m)**\\nwhere n = size of each individual string \\n      m = size of string vector\\n\\n- Space complexity:\\n# **O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int ans =0 , n=strs[1].size();\\n        int  j=0;\\n        while(j<n){\\n            int i=0;\\n            while(i<(strs.size())-1){\\n                string a = strs[i] ,b = strs[i+1];\\n                if(a[j] <= b[j]){\\n                    i++;\\n                }\\n                else{\\n                    ans++;\\n                    i++;\\n                    break;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int ans =0 , n=strs[1].size();\\n        int  j=0;\\n        while(j<n){\\n            int i=0;\\n            while(i<(strs.size())-1){\\n                string a = strs[i] ,b = strs[i+1];\\n                if(a[j] <= b[j]){\\n                    i++;\\n                }\\n                else{\\n                    ans++;\\n                    i++;\\n                    break;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990942,
                "title": "using-defaultdict-and-iterative-process-lengthy-easy-but-slow",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        to_delete = 0\\n        column_values = defaultdict(str)\\n        for i in range(len(strs[0])):\\n            for j in range(len(strs)):\\n                column_values[i] += strs[j][i]\\n        for each in column_values.values():\\n            if list(each) != sorted(each):\\n                to_delete += 1\\n        return to_delete\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        to_delete = 0\\n        column_values = defaultdict(str)\\n        for i in range(len(strs[0])):\\n            for j in range(len(strs)):\\n                column_values[i] += strs[j][i]\\n        for each in column_values.values():\\n            if list(each) != sorted(each):\\n                to_delete += 1\\n        return to_delete\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990912,
                "title": "c-bruteforce-approach-o-m-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++){\\n            for(int i=0; i<row-1; i++){\\n                if(strs[i][j]>strs[i+1][j]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++){\\n            for(int i=0; i<row-1; i++){\\n                if(strs[i][j]>strs[i+1][j]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990837,
                "title": "c-space-o-1-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& s) \\n    {\\n        int del_count = 0;\\n        for(int j = 0; j<s[0].size(); j++)\\n        {\\n            for(int i = 1; i<s.size(); i++)\\n            {\\n                if(s[i-1][j]>s[i][j])\\n                {\\n                    del_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return del_count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& s) \\n    {\\n        int del_count = 0;\\n        for(int j = 0; j<s[0].size(); j++)\\n        {\\n            for(int i = 1; i<s.size(); i++)\\n            {\\n                if(s[i-1][j]>s[i][j])\\n                {\\n                    del_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return del_count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990830,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count=0;\\n        for(int i=0;i<strs[0].size();i++){\\n            for(int j=0;j<strs.size()-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n# **Please share and upvote**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count=0;\\n        for(int i=0;i<strs[0].size();i++){\\n            for(int j=0;j<strs.size()-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990483,
                "title": "python3-simple-solutions",
                "content": "**Solution 1: for-loop**\\nhttps://leetcode.com/submissions/detail/870170112/\\nRuntime: **289 ms**, faster than 55.16% of Python3 online submissions for Delete Columns to Make Sorted.  \\nMemory Usage: 14.6 MB, less than 93.05% of Python3 online submissions for Delete Columns to Make Sorted.  \\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        n_rows, n_cols, n_del = len(strs), len(strs[0]), 0\\n        for j in range(n_cols):\\n            col_sorted = True\\n            for i in range(n_rows-1):\\n                if strs[i][j]>strs[i+1][j]:\\n                    col_sorted = False\\n                    break\\n            if not col_sorted:\\n                n_del += 1\\n        return n_del  \\n```\\n\\n**Solution 1.1: zip() and set()**  \\nhttps://leetcode.com/submissions/detail/870234000/\\nRuntime: **173 ms**, faster than 72.63% of Python3 online submissions for Delete Columns to Make Sorted.\\nMemory Usage: 14.6 MB, less than 61.89% of Python3 online submissions for Delete Columns to Make Sorted.\\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        n_row = len(strs)\\n        if n_row<=1: return 0\\n        cols_del = set()\\n        for i in range(n_row-1):\\n            for j,(c1,c2) in enumerate(zip(strs[i], strs[i+1])):\\n                if (j not in cols_del) and c1>c2:\\n                    cols_del.add(j)\\n        return len(cols_del)\\n```\\n\\n**Solution 2: numpy**  \\nhttps://leetcode.com/submissions/detail/870207660/  \\nRuntime: **492 ms**    \\nMemory Usage: 34.2 MB  \\n```\\nimport numpy as np\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        if len(strs)<=1: return 0\\n        arr = np.array([[ord(c) for c in s] for s in strs])\\n        return np.sum((np.any(np.greater(arr[:-1], arr[1:]), axis=0)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        n_rows, n_cols, n_del = len(strs), len(strs[0]), 0\\n        for j in range(n_cols):\\n            col_sorted = True\\n            for i in range(n_rows-1):\\n                if strs[i][j]>strs[i+1][j]:\\n                    col_sorted = False\\n                    break\\n            if not col_sorted:\\n                n_del += 1\\n        return n_del  \\n```\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        n_row = len(strs)\\n        if n_row<=1: return 0\\n        cols_del = set()\\n        for i in range(n_row-1):\\n            for j,(c1,c2) in enumerate(zip(strs[i], strs[i+1])):\\n                if (j not in cols_del) and c1>c2:\\n                    cols_del.add(j)\\n        return len(cols_del)\\n```\n```\\nimport numpy as np\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        if len(strs)<=1: return 0\\n        arr = np.array([[ord(c) for c in s] for s in strs])\\n        return np.sum((np.any(np.greater(arr[:-1], arr[1:]), axis=0)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990383,
                "title": "simple-typescript-code-with-comments",
                "content": "\\n# Complexity\\n- Time complexity: O(N*M) N = string length, M = strs array length\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction minDeletionSize(strs: string[]): number {\\n    \\n    const N = strs[0].length\\n    const M = strs.length\\n    let count = 0\\n\\n    // traverse each  columns\\n    for(let i=0; i< N; i++){;\\n        // traverse each row \\n        for(let j = 1; j < M; j++){\\n            // check previous char should be smaller or equall in case of greater\\n            // break the loop bcoz we need to delete that column.\\n            // main the count of delete\\n            if(strs[j-1].charCodeAt(i) > strs[j].charCodeAt(i)){\\n                count++\\n                break;\\n            }\\n        }\\n    }\\n    return count\\n}; \\n```\\n**If you like this solution please upvode, Thanks**",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "String"
                ],
                "code": "```\\nfunction minDeletionSize(strs: string[]): number {\\n    \\n    const N = strs[0].length\\n    const M = strs.length\\n    let count = 0\\n\\n    // traverse each  columns\\n    for(let i=0; i< N; i++){;\\n        // traverse each row \\n        for(let j = 1; j < M; j++){\\n            // check previous char should be smaller or equall in case of greater\\n            // break the loop bcoz we need to delete that column.\\n            // main the count of delete\\n            if(strs[j-1].charCodeAt(i) > strs[j].charCodeAt(i)){\\n                count++\\n                break;\\n            }\\n        }\\n    }\\n    return count\\n}; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2990263,
                "title": "c-most-easy-solution-if-else-statement",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        \\n        int cnt = 0; // to count the non equal column\\n        int col = strs[0].size(); // column\\n        int row = strs.size(); // row\\n\\n\\n        for(int i=0; i<col; i++) // iterating throught column\\n        { \\n          // 1. 1st loop select the first column\\n          // 2. 2nd loop itreates row wise and checks the element of the colum nin each row\\n          // 3. if the ascii of the element is greater than the ascii of the next element it is not sorted\\n\\n            for(int j=0; j<row-1; j++)\\n            {\\n                if(strs[j][i] > strs[j+1][i])\\n                {\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return cnt; // return the non sorted column\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        \\n        int cnt = 0; // to count the non equal column\\n        int col = strs[0].size(); // column\\n        int row = strs.size(); // row\\n\\n\\n        for(int i=0; i<col; i++) // iterating throught column\\n        { \\n          // 1. 1st loop select the first column\\n          // 2. 2nd loop itreates row wise and checks the element of the colum nin each row\\n          // 3. if the ascii of the element is greater than the ascii of the next element it is not sorted\\n\\n            for(int j=0; j<row-1; j++)\\n            {\\n                if(strs[j][i] > strs[j+1][i])\\n                {\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return cnt; // return the non sorted column\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990201,
                "title": "simple-easy-to-understand-brute-force-implementation-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int coldel = 0;\\n        for(int i=0; i<strs[0].size();i++)\\n        {\\n            for(int j=0; j <strs.size()-1;j++)\\n            {\\n                if(strs[j][i] > strs[j+1][i])\\n                {\\n                    coldel++;\\n                    break;\\n                }\\n            }\\n        }\\n        return coldel;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int coldel = 0;\\n        for(int i=0; i<strs[0].size();i++)\\n        {\\n            for(int j=0; j <strs.size()-1;j++)\\n            {\\n                if(strs[j][i] > strs[j+1][i])\\n                {\\n                    coldel++;\\n                    break;\\n                }\\n            }\\n        }\\n        return coldel;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989982,
                "title": "c-count-unsorted-columns-brute-force",
                "content": "# Approach\\n1. Traverse all strings column by column\\n2. Compare $$col$$th character of $$row$$th string with  $$col$$th character of $$row-1$$th string and increase $$ans$$ by $$1$$ if first character is lexographically greater than latter character\\n# Complexity\\n- Time complexity: $$O(n*m)$$ , where n is the number of strings in array and m is the length of each string \\n\\n- Space complexity: $$O(1)$$(Integer variables: n , len , ans , row , col)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) \\n    {\\n        int n=strs.size() , len=strs[0].length() , ans=0;\\n\\n        for(int col=0;col<len;col++)\\n        {\\n            for(int row=1;row<n;row++)\\n            {\\n                if(strs[row-1][col]>strs[row][col]) //Column is unsorted \\n                {\\n                    ans++;\\n                    break; //no need to check further in column\\n                }\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) \\n    {\\n        int n=strs.size() , len=strs[0].length() , ans=0;\\n\\n        for(int col=0;col<len;col++)\\n        {\\n            for(int row=1;row<n;row++)\\n            {\\n                if(strs[row-1][col]>strs[row][col]) //Column is unsorted \\n                {\\n                    ans++;\\n                    break; //no need to check further in column\\n                }\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989974,
                "title": "leetcode-official-answer-with-python-implementation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. --> \\nTake k = len(strs[0]) and ans = 0\\nIterate over the letters and second iteration over words and then check if the characters are in lexographical order or not, if not then increment ans by 1 and at last return ans.\\n\\n# Complexity\\n- Time complexity: O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        k = len(strs[0])\\n        ans = 0\\n        for col in range(0,k):\\n            for row in range(1,len(strs)):\\n                if strs[row][col] < strs[row-1][col]:\\n                    ans += 1\\n                    break\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        k = len(strs[0])\\n        ans = 0\\n        for col in range(0,k):\\n            for row in range(1,len(strs)):\\n                if strs[row][col] < strs[row-1][col]:\\n                    ans += 1\\n                    break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989901,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Traverse Column wise , if any current character of column is smaller than previous character count that column and break\\n\\n# Complexity\\n- Time complexity: (length of words)*(number of words)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int ans=0;\\n        for(int i;i<strs[0].size();i++){\\n            for(int j=1;j<strs.size();j++){\\n                if(strs[j][i]<strs[j-1][i]){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int ans=0;\\n        for(int i;i<strs[0].size();i++){\\n            for(int j=1;j<strs.size();j++){\\n                if(strs[j][i]<strs[j-1][i]){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989812,
                "title": "brute-force-simple-java-solution-beats-93-3",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int n=strs.length;\\n        int m=strs[0].length();\\n        int count=0;\\n        for(int j=0;j<m;j++){\\n            for(int i=1;i<n;i++){\\n                if(strs[i-1].charAt(j)>strs[i].charAt(j)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int n=strs.length;\\n        int m=strs[0].length();\\n        int count=0;\\n        for(int j=0;j<m;j++){\\n            for(int i=1;i<n;i++){\\n                if(strs[i-1].charAt(j)>strs[i].charAt(j)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989806,
                "title": "daily-leetcode-challenge-c-day-3",
                "content": "# Complexity\\n- Time complexity: O(row*column)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count = 0; // Counting number of deleted columns\\n        int row = strs.size(); // Counting number of rows\\n        int column = strs[0].size(); // Counting number of columns\\n        // First we will iterate through column and then row\\n        for(int j = 0; j < column; j++){\\n            for(int i = 0; i < row-1; i++){\\n                // If not sorted lexicographically then we count and then break that column because no mean to check further in that column \\n                if(strs[i][j] > strs[i+1][j]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count = 0; // Counting number of deleted columns\\n        int row = strs.size(); // Counting number of rows\\n        int column = strs[0].size(); // Counting number of columns\\n        // First we will iterate through column and then row\\n        for(int j = 0; j < column; j++){\\n            for(int i = 0; i < row-1; i++){\\n                // If not sorted lexicographically then we count and then break that column because no mean to check further in that column \\n                if(strs[i][j] > strs[i+1][j]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989732,
                "title": "c-begineer-friendly-easy-understanding-string-video-solution",
                "content": "# Intuition && Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\nhttps://www.youtube.com/watch?v=O35j95MSIZQ/\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int minDeletionSize(vector<string>& strs) {\\n        // count no. of rows and coln.\\n        int rows = strs.size();\\n        int colns = strs[0].size();\\n\\n        // store the ans\\n        int ans =0;\\n\\n        // Traverse column wise and for each row.\\n        for(int i=0;i<colns;i++){\\n            for(int j=1;j<rows;j++){\\n                // if previous row as higher value mean not sorted hence increase the value\\u2003of ans and break the inner loop for checking next column.\\n                if(strs[j-1][i]>strs[j][i]){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int minDeletionSize(vector<string>& strs) {\\n        // count no. of rows and coln.\\n        int rows = strs.size();\\n        int colns = strs[0].size();\\n\\n        // store the ans\\n        int ans =0;\\n\\n        // Traverse column wise and for each row.\\n        for(int i=0;i<colns;i++){\\n            for(int j=1;j<rows;j++){\\n                // if previous row as higher value mean not sorted hence increase the value\\u2003of ans and break the inner loop for checking next column.\\n                if(strs[j-1][i]>strs[j][i]){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989545,
                "title": "c-0ms-fastest-solution-100-fast-beginner-friendly-clean-code",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    int minDeletionSize(vector<string>& strs) {\\n        \\n        int cnt = 0;\\n\\n        for(int j = 0; j < strs[0].size(); ++j)\\n        {\\n            for(int i = 0; i < strs.size() - 1; ++i)\\n            {\\n                if(strs[i][j] > strs[i+1][j])\\n                {\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    int minDeletionSize(vector<string>& strs) {\\n        \\n        int cnt = 0;\\n\\n        for(int j = 0; j < strs[0].size(); ++j)\\n        {\\n            for(int i = 0; i < strs.size() - 1; ++i)\\n            {\\n                if(strs[i][j] > strs[i+1][j])\\n                {\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989286,
                "title": "c-parsing-by-column-with-condition-100-time-31ms-75-space-12-2mb",
                "content": "Nice problem for an easy one: not trivial, not trite.\\n\\nTo solve it, we will go and check each column separately, stopping as soon as we find an element out of order and increasing a counter with that information.\\n\\nStarting from our usual support variables, we will have:\\n* `res`, our counter of the unsorted columns, initialised to be `0`;\\n* `sorted`, a boolean flag we will use in our inner loop.\\n\\nWe will then go with `x` through each column and:\\n* reset the loop variables `prev` and `sorted` to `0` and `true`, respectively;\\n* loop through each row in the column with `y` and:\\n    * assign the value of the current cell `strs[y][x]` to `curr`;\\n    * deal with two cases:\\n        * if `curr` is not sorted in non-decreasing order (ie: `curr < prev`), we will:\\n            * flag `sorted` to be `false`;\\n            * `break` out of the inner loop;\\n        * otherwise, we will just set `prev` to be `curr` for the next iteration;\\n* increase `res` by `1` if we end the loop with `sorted == false`.\\n\\nOnce done, we can `return` `res` :)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        // support variables\\n        int res = 0;\\n        bool sorted;\\n        // parsing strs\\n        for (int x = 0, lmtX = strs[0].size(), prev, curr; x < lmtX; x++) {\\n            // resetting loop variables\\n            prev = 0, sorted = true;\\n            // parsing the current column\\n            for (int y = 0, lmtY = strs.size(); y < lmtY; y++) {\\n                curr = strs[y][x];\\n                // case 1: unsorted element\\n                if (curr < prev) {\\n                    sorted = false;\\n                    break;\\n                }\\n                // case 2: sorted element\\n                else prev = curr;\\n            }\\n            res += !sorted;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThe brag:\\n![image.png](https://assets.leetcode.com/users/images/353991ba-eef3-4c40-944d-77568c01021d_1672707709.4222438.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        // support variables\\n        int res = 0;\\n        bool sorted;\\n        // parsing strs\\n        for (int x = 0, lmtX = strs[0].size(), prev, curr; x < lmtX; x++) {\\n            // resetting loop variables\\n            prev = 0, sorted = true;\\n            // parsing the current column\\n            for (int y = 0, lmtY = strs.size(); y < lmtY; y++) {\\n                curr = strs[y][x];\\n                // case 1: unsorted element\\n                if (curr < prev) {\\n                    sorted = false;\\n                    break;\\n                }\\n                // case 2: sorted element\\n                else prev = curr;\\n            }\\n            res += !sorted;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930441,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs)\\n    {\\n\\n        int cnt = 0;\\n        for (int i = 0; i < strs[0].size(); i++) {\\n            bool flag = true;\\n            for (int j = 0; j < strs.size() - 1; j++) {\\n                if (strs[j][i] > strs[j + 1][i]) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag == false) {\\n                cnt++;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs)\\n    {\\n\\n        int cnt = 0;\\n        for (int i = 0; i < strs[0].size(); i++) {\\n            bool flag = true;\\n            for (int j = 0; j < strs.size() - 1; j++) {\\n                if (strs[j][i] > strs[j + 1][i]) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag == false) {\\n                cnt++;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851555,
                "title": "swift-easy-to-understand",
                "content": "```\\nclass Solution {\\n    func minDeletionSize(_ strs: [String]) -> Int {\\n        var strs = strs.map { Array($0) }\\n\\t\\tvar result = 0\\n\\n\\t\\tfor column in 0..<strs[0].count {\\n\\t\\t\\tfor row in 0..<strs.count - 1 {\\n\\t\\t\\t\\tif strs[row][column] > strs[row + 1][column] {\\n\\t\\t\\t\\t\\tresult += 1\\n                    break\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minDeletionSize(_ strs: [String]) -> Int {\\n        var strs = strs.map { Array($0) }\\n\\t\\tvar result = 0\\n\\n\\t\\tfor column in 0..<strs[0].count {\\n\\t\\t\\tfor row in 0..<strs.count - 1 {\\n\\t\\t\\t\\tif strs[row][column] > strs[row + 1][column] {\\n\\t\\t\\t\\t\\tresult += 1\\n                    break\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596251,
                "title": "js-simple-solution-with-o-n-2-easy-understand",
                "content": "```\\nvar minDeletionSize = function(strs) {\\n    let output = 0;\\n    for (let i = 0 ; i < strs[0].length; i++) {\\n        let isSorted = true;\\n        for (let j = 0 ; j < strs.length - 1; j++) {\\n            if (strs[j + 1][i] < strs[j][i]) {\\n                isSorted = false;\\n                break;\\n            }\\n        }\\n        if (!isSorted) output++;\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minDeletionSize = function(strs) {\\n    let output = 0;\\n    for (let i = 0 ; i < strs[0].length; i++) {\\n        let isSorted = true;\\n        for (let j = 0 ; j < strs.length - 1; j++) {\\n            if (strs[j + 1][i] < strs[j][i]) {\\n                isSorted = false;\\n                break;\\n            }\\n        }\\n        if (!isSorted) output++;\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2446370,
                "title": "java-o-n-m-6-ms",
                "content": "**Approach** : For every column, we keep track of the largest character visited, if we encounter a smaller character, that column has to be deleted\\n\\nConsider the following `strs`\\n```\\n[\"qowfc\",\"spyge\",\"sqbif\",\"vvrkk\"]\\u2935\\n\\n    |q o w f c|\\n\\t|s p y g e|     \\n\\t|s q b i f|\\n\\t|v v r k k|\\n```\\nFor the `1st` column we have `q <= s <= s <= v`, this column will not be deleted ( similary `2nd ,4th` column)\\nFor the `3rd` column we have `w <= y > b <= r`\\n\\n\\n**Time Complexity** : O(N*M)\\n**Space Complexity** : O(1)\\n\\nImplementation\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int n = strs.length, m = strs[0].length(),ans = 0;\\n        \\n        for(int j = 0;j<m;j++){\\n            \\n            int prev = 0; // largest previous character so far (we initialize this with \\'a\\')\\n            \\n            boolean toBeDeleted = false; \\n            \\n            for(int i = 0;i<n;i++){\\n                \\n                int cur = strs[i].charAt(j) - \\'a\\';\\n                \\n                if(cur >= prev){   // update prev if we get a larger character\\n                    \\n                    prev = cur;\\n                    \\n                }else{  // otherwise this column will be deleted\\n                    \\n                    toBeDeleted = true;\\n                    \\n                    break;\\n                    \\n                }\\n                \\n                \\n            }\\n            \\n            if(toBeDeleted) ans++; // increment count of deleted columns\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n[\"qowfc\",\"spyge\",\"sqbif\",\"vvrkk\"]\\u2935\\n\\n    |q o w f c|\\n\\t|s p y g e|     \\n\\t|s q b i f|\\n\\t|v v r k k|\\n```\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int n = strs.length, m = strs[0].length(),ans = 0;\\n        \\n        for(int j = 0;j<m;j++){\\n            \\n            int prev = 0; // largest previous character so far (we initialize this with \\'a\\')\\n            \\n            boolean toBeDeleted = false; \\n            \\n            for(int i = 0;i<n;i++){\\n                \\n                int cur = strs[i].charAt(j) - \\'a\\';\\n                \\n                if(cur >= prev){   // update prev if we get a larger character\\n                    \\n                    prev = cur;\\n                    \\n                }else{  // otherwise this column will be deleted\\n                    \\n                    toBeDeleted = true;\\n                    \\n                    break;\\n                    \\n                }\\n                \\n                \\n            }\\n            \\n            if(toBeDeleted) ans++; // increment count of deleted columns\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356993,
                "title": "c-bruteforce-with-explanation-59ms-63",
                "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        \\n        vector<string>sk;\\n        string c;\\n        string d;\\n        char l;\\n        int count=0;\\n        int io=0;\\n        for(int i=0;i<strs[io].length();i++){ //adding every column of string to vector;\\n            for(int j=0;j<strs.size();j++){\\n                c+=strs[j][i];\\n\\n            }\\n\\t\\t  sk.push_back(c);\\n\\t\\t\\tc=\"\";                   ///initializing back to 0;\\n\\t}\\n\\n\\n\\tfor(int i=0;i<sk.size();i++){       //now seaching among the sk[i] if found greater than initailize it and comparing with next and incrementing count if found!\\n\\t\\td=sk[i];\\n\\t\\t l=d[0];\\n\\t\\tfor(int j=1;j<d.length();j++){\\n\\t\\t\\tif(d[j]>l){\\n\\t\\t\\t\\tl=d[j];\\n\\t\\t\\t}\\n\\t\\t\\tif(d[j]<l){\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        \\n        vector<string>sk;\\n        string c;\\n        string d;\\n        char l;\\n        int count=0;\\n        int io=0;\\n        for(int i=0;i<strs[io].length();i++){ //adding every column of string to vector;\\n            for(int j=0;j<strs.size();j++){\\n                c+=strs[j][i];\\n\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2241960,
                "title": "actually-fast-python-solution",
                "content": "```\\ndef minDeletionSize(self, strs):\\n        count = 0\\n        for column in zip(*strs):\\n            if list(column) != sorted(column):\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minDeletionSize(self, strs):\\n        count = 0\\n        for column in zip(*strs):\\n            if list(column) != sorted(column):\\n                count += 1\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1546060,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int ans=0;\\n        vector<int> visited(strs[0].length(),0);\\n        for(int i=0;i<strs.size()-1;i++){\\n            for(int j=0;j<strs[0].length();j++){\\n                if(strs[i][j]>strs[i+1][j] && visited[j]==0){\\n                    \\n                    ans++;\\n                    visited[j]=1;\\n                \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int ans=0;\\n        vector<int> visited(strs[0].length(),0);\\n        for(int i=0;i<strs.size()-1;i++){\\n            for(int j=0;j<strs[0].length();j++){\\n                if(strs[i][j]>strs[i+1][j] && visited[j]==0){\\n                    \\n                    ans++;\\n                    visited[j]=1;\\n                \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1407387,
                "title": "simple-rust-solution",
                "content": "```\\n pub fn min_deletion_size(strs: Vec<String>) -> i32 {\\n        let mut ret = 0;\\n\\n        let mut new_strs: Vec<Vec<char>> = Vec::new();\\n\\n        for i in 0..strs.len() {\\n            new_strs.push(strs[i].chars().collect::<Vec<char>>());\\n        }\\n\\n        for i in 0..new_strs[0].len() {\\n           for j in 1..new_strs.len() {\\n               if new_strs[j-1][i] > new_strs[j][i] {\\n                   ret +=1;\\n                   break\\n               }\\n           }\\n        }\\n\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n pub fn min_deletion_size(strs: Vec<String>) -> i32 {\\n        let mut ret = 0;\\n\\n        let mut new_strs: Vec<Vec<char>> = Vec::new();\\n\\n        for i in 0..strs.len() {\\n            new_strs.push(strs[i].chars().collect::<Vec<char>>());\\n        }\\n\\n        for i in 0..new_strs[0].len() {\\n           for j in 1..new_strs.len() {\\n               if new_strs[j-1][i] > new_strs[j][i] {\\n                   ret +=1;\\n                   break\\n               }\\n           }\\n        }\\n\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1350250,
                "title": "simple-c-solution",
                "content": "```\\n   int minDeletionSize(vector<string>& A) {\\n        int n=A.size();\\n        int m=A[0].size();\\n        int ans=0;\\n        \\n        int a=0;\\n        \\n        while(a<m){\\n        for(int i=0;i<A.size()-1;i++){\\n         \\n          if(A[i][a]>A[i+1][a]){\\n              ans++;\\n              break;\\n          }  \\n            \\n        }\\n            a++;\\n       }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   int minDeletionSize(vector<string>& A) {\\n        int n=A.size();\\n        int m=A[0].size();\\n        int ans=0;\\n        \\n        int a=0;\\n        \\n        while(a<m){\\n        for(int i=0;i<A.size()-1;i++){\\n         \\n          if(A[i][a]>A[i+1][a]){\\n              ans++;\\n              break;\\n          }  \\n            \\n        }\\n            a++;\\n       }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1118008,
                "title": "fastest-100-java-easy-with-comments",
                "content": "```\\n    public int minDeletionSize(String[] strs) {\\n        int c = 0; // counter\\n        \\n    outer: for(int col = 0; col <  strs[0].length();col++){  //key concept is to iterate column wise and not row wise\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//so that it is ensures that we visit every column once!\\n        \\n       for(int row = 0; row < strs.length - 1; row++){\\n\\t   \\n                if(strs[row + 1].charAt(col) - strs[row].charAt(col) >= 0){ //check order\\n                    continue;\\n                }\\n                else {\\n                    c++;\\n                    continue outer; // jump to next columns\\n                }\\n                \\n            } \\n        }\\n        return c;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minDeletionSize(String[] strs) {\\n        int c = 0; // counter\\n        \\n    outer: for(int col = 0; col <  strs[0].length();col++){  //key concept is to iterate column wise and not row wise\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//so that it is ensures that we visit every column once!\\n        \\n       for(int row = 0; row < strs.length - 1; row++){\\n\\t   \\n                if(strs[row + 1].charAt(col) - strs[row].charAt(col) >= 0){ //check order\\n                    continue;\\n                }\\n                else {\\n                    c++;\\n                    continue outer; // jump to next columns\\n                }\\n                \\n            } \\n        }\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 953723,
                "title": "python-most-simple-o-nm-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def minDeletionSize(self, A: List[str]) -> int:\\n        \\n        res = 0\\n        for pos in range(len(A[0])):\\n            for word in range(len(A)-1):\\n                if A[word][pos] > A[word+1][pos]:\\n                    res += 1\\n                    break\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, A: List[str]) -> int:\\n        \\n        res = 0\\n        for pos in range(len(A[0])):\\n            for word in range(len(A)-1):\\n                if A[word][pos] > A[word+1][pos]:\\n                    res += 1\\n                    break\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 803740,
                "title": "c-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& A) {\\n        int d=0;\\n        for(int i=0;i<A[0].size();i++)\\n            for(int j=0;j+1<A.size();j++)\\n                if(A[j][i]>A[j+1][i]){\\n                    d++;\\n                    break;\\n                }\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& A) {\\n        int d=0;\\n        for(int i=0;i<A[0].size();i++)\\n            for(int j=0;j+1<A.size();j++)\\n                if(A[j][i]>A[j+1][i]){\\n                    d++;\\n                    break;\\n                }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522732,
                "title": "simple-java-solution",
                "content": "```java\\nclass Solution {\\n    public int minDeletionSize(String[] a) {\\n        int deleteCount = 0;\\n        int strCount = a[0].length();\\n\\n        for (int i = 0; i < strCount; i++) {\\n            for (int j = 1; j < a.length; j++) {\\n                if (a[j].charAt(i) < a[j - 1].charAt(i)) {\\n                    deleteCount++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return deleteCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int minDeletionSize(String[] a) {\\n        int deleteCount = 0;\\n        int strCount = a[0].length();\\n\\n        for (int i = 0; i < strCount; i++) {\\n            for (int j = 1; j < a.length; j++) {\\n                if (a[j].charAt(i) < a[j - 1].charAt(i)) {\\n                    deleteCount++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return deleteCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382127,
                "title": "solution-in-python-3-beats-100-one-line",
                "content": "```\\nclass Solution:\\n    def minDeletionSize(self, A: List[str]) -> int:\\n    \\treturn sum(list(i) != sorted(i) for i in zip(*A))\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, A: List[str]) -> int:\\n    \\treturn sum(list(i) != sorted(i) for i in zip(*A))\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "codeTag": "Java"
            },
            {
                "id": 280029,
                "title": "c-60-ms-faster-than-82-67-and-12-9-mb-less-than-98-91-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& A) {\\n        if (A.size() <= 1)  return 0;\\n        int minDeletionSize = 0;\\n\\n        for (int i=0; i<A[0].size(); i++) {\\n            for (int j=1; j<A.size(); j++) {\\n                if (A[j-1][i] - A[j][i] > 0)  {\\n                    ++minDeletionSize;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return minDeletionSize;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& A) {\\n        if (A.size() <= 1)  return 0;\\n        int minDeletionSize = 0;\\n\\n        for (int i=0; i<A[0].size(); i++) {\\n            for (int j=1; j<A.size(); j++) {\\n                if (A[j-1][i] - A[j][i] > 0)  {\\n                    ++minDeletionSize;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return minDeletionSize;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 252883,
                "title": "javascript-solution-with-comments",
                "content": "```\\n/**\\n * @param {string[]} A\\n * @return {number}\\n */\\nvar minDeletionSize = function(A) {\\n    //Problem definition is worded to make it confusing.\\n    //TL;DR:\\n    //A is a 2D array of ints\\n    //Count the number of columns where the ints are not in ascending order.\\n    \\n    //Solution:\\n    //We\\'ll search the 2D array column by column. If we find one int out of order - we\\'ll add 1 to our count, and move on.\\n    //O(n) time complexity. O(1) space complexity.\\n    //\\n    //No faster way, since finding one column is out of order doesn\\'t tell us anything about any other columns.\\n    //As a plus though, this problem could be paralellized using SIMD instructions or threads.\\n    //But this is Javascript, so who cares about speed.\\n    \\n    //Useful Problem Constraints:\\n    //All strings are the same length.\\n    //All characters are ASCII.\\n    //There\\'s only <= 100 strings, each with <= 1000 characters.\\n    var columnsToDelete = 0;\\n    if (A.length == 0)\\n        return 0;\\n    \\n    var stringLength = A[0].length; //We know all strings are of the same length, so we can do this.\\n    for(var i = 0; i < stringLength; i++) //For each column/character in our string\\n    {\\n        for (var j = 0; j < A.length - 1; j++) //For each row/string... (-1 so we can compare this row with the next one)\\n        {\\n            var numValue = A[j][i];\\n            var nextNumValue = A[j+1][i];\\n            \\n            if (numValue > nextNumValue) //If we aren\\'t in ascending order\\n            {\\n                columnsToDelete++;\\n                break;\\n            }\\n\\n        }\\n    }\\n    \\n    return columnsToDelete;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} A\\n * @return {number}\\n */\\nvar minDeletionSize = function(A) {\\n    //Problem definition is worded to make it confusing.\\n    //TL;DR:\\n    //A is a 2D array of ints\\n    //Count the number of columns where the ints are not in ascending order.\\n    \\n    //Solution:\\n    //We\\'ll search the 2D array column by column. If we find one int out of order - we\\'ll add 1 to our count, and move on.\\n    //O(n) time complexity. O(1) space complexity.\\n    //\\n    //No faster way, since finding one column is out of order doesn\\'t tell us anything about any other columns.\\n    //As a plus though, this problem could be paralellized using SIMD instructions or threads.\\n    //But this is Javascript, so who cares about speed.\\n    \\n    //Useful Problem Constraints:\\n    //All strings are the same length.\\n    //All characters are ASCII.\\n    //There\\'s only <= 100 strings, each with <= 1000 characters.\\n    var columnsToDelete = 0;\\n    if (A.length == 0)\\n        return 0;\\n    \\n    var stringLength = A[0].length; //We know all strings are of the same length, so we can do this.\\n    for(var i = 0; i < stringLength; i++) //For each column/character in our string\\n    {\\n        for (var j = 0; j < A.length - 1; j++) //For each row/string... (-1 so we can compare this row with the next one)\\n        {\\n            var numValue = A[j][i];\\n            var nextNumValue = A[j+1][i];\\n            \\n            if (numValue > nextNumValue) //If we aren\\'t in ascending order\\n            {\\n                columnsToDelete++;\\n                break;\\n            }\\n\\n        }\\n    }\\n    \\n    return columnsToDelete;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252488,
                "title": "swift-fast-approach-216ms",
                "content": "216ms by using utf16 view of string.\\n\\n```\\nclass Solution {\\n    func minDeletionSize(_ A: [String]) -> Int {\\n        var d = 0\\n        for column in 0..<A[0].count {\\n            let columnIndex = A[0].utf16.index(A[0].utf16.startIndex, offsetBy: column)\\n            for row in 1..<A.count {\\n                if A[row][columnIndex] < A[row - 1][columnIndex] {\\n                    d += 1\\n                    break\\n                }\\n            }\\n        }\\n        return d\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func minDeletionSize(_ A: [String]) -> Int {\\n        var d = 0\\n        for column in 0..<A[0].count {\\n            let columnIndex = A[0].utf16.index(A[0].utf16.startIndex, offsetBy: column)\\n            for row in 1..<A.count {\\n                if A[row][columnIndex] < A[row - 1][columnIndex] {\\n                    d += 1\\n                    break\\n                }\\n            }\\n        }\\n        return d\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 236378,
                "title": "javascript",
                "content": "```\\nvar minDeletionSize = function(A) {\\n    let result = 0\\n    const len = A[0].length\\n    for(let i = 0; i < len; i++) {\\n        for(let j = 1; j < A.length; j++){\\n            if(A[j][i] < A[j - 1][i]){\\n                result += 1\\n                break\\n            }\\n        }\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minDeletionSize = function(A) {\\n    let result = 0\\n    const len = A[0].length\\n    for(let i = 0; i < len; i++) {\\n        for(let j = 1; j < A.length; j++){\\n            if(A[j][i] < A[j - 1][i]){\\n                result += 1\\n                break\\n            }\\n        }\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 198881,
                "title": "fast-and-easy-to-understand-python-solution",
                "content": "With Zip\\n\\n```\\nclass Solution:\\n    def minDeletionSize(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n\\t\\t\\n        count = 0\\n        \\n        for items in zip(*A):  # The * operator can be used in conjuncton with zip() to unzip the list.\\n            if sorted(items) != list(items):\\n                count += 1\\n                \\n        return count\\n```\\n\\nWith No Zip\\n\\n```\\nclass Solution:\\n    def minDeletionSize(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n\\t\\tnew_A = []\\n\\t\\tcount = 0\\n\\n\\t\\tfor items in range(len(A[0])):\\n\\t\\t\\tcharacters = \\'\\'\\n\\n\\t\\t\\tfor item in range(len(A)):\\n\\t\\t\\t\\tcharacters += A[item][items]\\n\\n\\t\\t\\tnew_A.append(characters)\\n\\n\\t\\tfor items in new_A:\\n\\t\\t\\tif sorted(items) != list(items):\\n\\t\\t\\t\\tcount += 1\\n\\n\\t\\treturn count\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n\\t\\t\\n        count = 0\\n        \\n        for items in zip(*A):  # The * operator can be used in conjuncton with zip() to unzip the list.\\n            if sorted(items) != list(items):\\n                count += 1\\n                \\n        return count\\n```\n```\\nclass Solution:\\n    def minDeletionSize(self, A):\\n        \"\"\"\\n        :type A: List[str]\\n        :rtype: int\\n        \"\"\"\\n\\t\\tnew_A = []\\n\\t\\tcount = 0\\n\\n\\t\\tfor items in range(len(A[0])):\\n\\t\\t\\tcharacters = \\'\\'\\n\\n\\t\\t\\tfor item in range(len(A)):\\n\\t\\t\\t\\tcharacters += A[item][items]\\n\\n\\t\\t\\tnew_A.append(characters)\\n\\n\\t\\tfor items in new_A:\\n\\t\\t\\tif sorted(items) != list(items):\\n\\t\\t\\t\\tcount += 1\\n\\n\\t\\treturn count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 195562,
                "title": "java-o-a-length-a-0-length-easy-to-explain-and-impl-in-5mins-cheers",
                "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] A) {\\n        int res = 0;\\n        int len = A[0].length();\\n        int n = A.length;\\n\\n        for (int j = 0; j < len; ++j) {\\n            for (int i = 1; i < n; ++i) {\\n                if (A[i].charAt(j) < A[i - 1].charAt(j)) {\\n                    ++res;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] A) {\\n        int res = 0;\\n        int len = A[0].length();\\n        int n = A.length;\\n\\n        for (int j = 0; j < len; ++j) {\\n            for (int i = 1; i < n; ++i) {\\n                if (A[i].charAt(j) < A[i - 1].charAt(j)) {\\n                    ++res;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785999,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] ary) {\\n        int count=0;   \\n         // imagine each word are raw \\n        int raw= ary.length;\\n        // imagine each word are colum\\n        int colum=ary[0].length();\\n        for(int j=0;j<colum;j++)\\n        {\\n            for(int i=0;i<raw-1;i++)\\n            {\\n               // check in colum wize\\n  if(ary[i].charAt(j)>ary[i+1].charAt(j))\\n                {\\n                     count++;\\n                    break;\\n                }\\n              \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] ary) {\\n        int count=0;   \\n         // imagine each word are raw \\n        int raw= ary.length;\\n        // imagine each word are colum\\n        int colum=ary[0].length();\\n        for(int j=0;j<colum;j++)\\n        {\\n            for(int i=0;i<raw-1;i++)\\n            {\\n               // check in colum wize\\n  if(ary[i].charAt(j)>ary[i+1].charAt(j))\\n                {\\n                     count++;\\n                    break;\\n                }\\n              \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610797,
                "title": "beats-90-cpp-sol",
                "content": "# Pls Upvote if Helpful **Bold**\\uD83D\\uDE07\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool check(string temp){\\n        for(int i = 0; i<temp.size()-1; i++){\\n            if(temp[i]>temp[i+1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    int minDeletionSize(vector<string>& strs) {\\n        int size = strs[0].size();\\n        int ans = 0;\\n        for(int i = 0; i<size; i++){\\n            string temp;\\n            for(int j = 0; j<strs.size(); j++){\\n                string s = strs[j];\\n                temp.push_back(s[i]);\\n            }\\n\\n            // if string is lexographically not sorted inc count\\n            if(check(temp)==false){\\n                ans += 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool check(string temp){\\n        for(int i = 0; i<temp.size()-1; i++){\\n            if(temp[i]>temp[i+1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    int minDeletionSize(vector<string>& strs) {\\n        int size = strs[0].size();\\n        int ans = 0;\\n        for(int i = 0; i<size; i++){\\n            string temp;\\n            for(int j = 0; j<strs.size(); j++){\\n                string s = strs[j];\\n                temp.push_back(s[i]);\\n            }\\n\\n            // if string is lexographically not sorted inc count\\n            if(check(temp)==false){\\n                ans += 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525295,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        std::ios_base::sync_with_stdio(false);\\n        std::cin.tie(NULL);\\n        std::cout.tie(NULL);\\n    }\\n    int minDeletionSize(vector<string>& strs)\\n    {\\n        if (strs.size() == 1)\\n        {\\n            return 0;\\n        }\\n        std::vector<bool> toDelete(strs[0].size(), false);\\n        for (int r = 1; r < strs.size(); ++r)\\n        {\\n            auto const& curr = strs[r];\\n            auto const& last = strs[r-1];\\n            for (int c = 0; c < strs[0].size(); ++c)\\n            {\\n                if (toDelete[c])\\n                {\\n                    continue;\\n                }\\n                if (curr[c] < last[c])\\n                {\\n                    toDelete[c] = true;\\n                }\\n            }\\n        }\\n        return std::accumulate(toDelete.begin(), toDelete.end(), 0);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        char_matrix = []\\n        count = 0\\n        for column in zip(*strs):\\n            char_matrix.append(list(column))\\n        for col in char_matrix:\\n            if col != sorted(col):\\n                count += 1\\n        return count\\n```\\n\\n```Java []\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int columnsCount = 0;\\n        if(strs==null || strs.length==0){\\n            return columnsCount;\\n        }\\n        int strLen = strs[0].length();\\n        for(int coulmnNum=0; coulmnNum<strLen; coulmnNum++){\\n            if(!isCoulmnOrder(strs, coulmnNum)){\\n                columnsCount++;\\n            }\\n        }\\n        return columnsCount;\\n    }\\n    private boolean isCoulmnOrder(String[] strs, int coulmnNum){\\n        char currChar = \\'a\\';\\n        int linesCount = strs.length;\\n        for(int lineNum = 0; lineNum<linesCount; lineNum++ ){\\n            char nextChar = strs[lineNum].charAt(coulmnNum);\\n            if(currChar>nextChar){\\n                return false;\\n            }\\n            currChar = nextChar;\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        std::ios_base::sync_with_stdio(false);\\n        std::cin.tie(NULL);\\n        std::cout.tie(NULL);\\n    }\\n    int minDeletionSize(vector<string>& strs)\\n    {\\n        if (strs.size() == 1)\\n        {\\n            return 0;\\n        }\\n        std::vector<bool> toDelete(strs[0].size(), false);\\n        for (int r = 1; r < strs.size(); ++r)\\n        {\\n            auto const& curr = strs[r];\\n            auto const& last = strs[r-1];\\n            for (int c = 0; c < strs[0].size(); ++c)\\n            {\\n                if (toDelete[c])\\n                {\\n                    continue;\\n                }\\n                if (curr[c] < last[c])\\n                {\\n                    toDelete[c] = true;\\n                }\\n            }\\n        }\\n        return std::accumulate(toDelete.begin(), toDelete.end(), 0);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        char_matrix = []\\n        count = 0\\n        for column in zip(*strs):\\n            char_matrix.append(list(column))\\n        for col in char_matrix:\\n            if col != sorted(col):\\n                count += 1\\n        return count\\n```\n```Java []\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int columnsCount = 0;\\n        if(strs==null || strs.length==0){\\n            return columnsCount;\\n        }\\n        int strLen = strs[0].length();\\n        for(int coulmnNum=0; coulmnNum<strLen; coulmnNum++){\\n            if(!isCoulmnOrder(strs, coulmnNum)){\\n                columnsCount++;\\n            }\\n        }\\n        return columnsCount;\\n    }\\n    private boolean isCoulmnOrder(String[] strs, int coulmnNum){\\n        char currChar = \\'a\\';\\n        int linesCount = strs.length;\\n        for(int lineNum = 0; lineNum<linesCount; lineNum++ ){\\n            char nextChar = strs[lineNum].charAt(coulmnNum);\\n            if(currChar>nextChar){\\n                return false;\\n            }\\n            currChar = nextChar;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3477689,
                "title": "quick-and-easy-java-solution-be-consistent",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count=0;\\n        for(int i=0;i<strs[0].length();i++)\\n        {\\n           for(int j=1;j<strs.length;j++)\\n           {\\n               if((int)strs[j].charAt(i)<(int)strs[j-1].charAt(i))\\n               {\\n                   count++;\\n                   break;\\n               }\\n           }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count=0;\\n        for(int i=0;i<strs[0].length();i++)\\n        {\\n           for(int j=1;j<strs.length;j++)\\n           {\\n               if((int)strs[j].charAt(i)<(int)strs[j-1].charAt(i))\\n               {\\n                   count++;\\n                   break;\\n               }\\n           }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282917,
                "title": "delete-columns-to-make-sorted-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int i, j, count=0;\\n        for(i=0 ; i<strs[0].size() ; i++)\\n        {\\n            for(j=0 ; j<strs.size()-1 ; j++)\\n            {\\n                if(strs[j][i]>strs[j+1][i])\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int i, j, count=0;\\n        for(i=0 ; i<strs[0].size() ; i++)\\n        {\\n            for(j=0 ; j<strs.size()-1 ; j++)\\n            {\\n                if(strs[j][i]>strs[j+1][i])\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237885,
                "title": "one-liner-beat-99-75ms",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(nm * m log m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(nm)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        \\n        return sum(1 for i in zip(*strs) if list(i) != sorted(i))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        \\n        return sum(1 for i in zip(*strs) if list(i) != sorted(i))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071146,
                "title": "easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count=0;\\n        int n=strs.size();\\n        int l=strs[0].length();\\n        for(int i=0;i<l;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                if(strs[j][i]<strs[j-1][i])\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count=0;\\n        int n=strs.size();\\n        int l=strs[0].length();\\n        for(int i=0;i<l;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                if(strs[j][i]<strs[j-1][i])\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012526,
                "title": "columnwise-matrix-traversal",
                "content": "# Intuition\\nWe need to do columnwise matrix traversal .\\n\\n# Approach\\n1. We must check whether the no.of rows == 1 beforehand to avoid unnecessary computation of strings because if there is only one row in the matrix it cannot be compared with another string of the same column and therefore the matrix will always remain sorted columnwise.  For Example strs = [\"abc\"] or [\"a\"] .\\n2.  We must use outer loop for traversing in columnwise manner among the strings .\\n3.   We must use the inner loop for traversing rows in the matrix or strings in the array according to a particular column or index respectively and check whether they are in lexicographical order or not . See the implementation attached below .\\n\\n# Complexity\\n- Time complexity:\\nO(N * K)\\nwhere \\nN = length of the array of strings \"strs\" ,\\nK = length of each string . \\n\\n- Space complexity:\\nO(1)\\nAs only an extra variable unsorted_columns is required .\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        if(strs.length == 1)\\n            return 0;\\n        int unsorted_columns = 0;\\n        for(int i = 0 ; i < strs[0].length() ; ++i)\\n        {\\n            for(int j = 0 ; j < (strs.length - 1) ; ++j)\\n            {\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i))\\n                {\\n                    ++unsorted_columns;\\n                    break;\\n                }\\n            }\\n        }\\n        return unsorted_columns;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        if(strs.length == 1)\\n            return 0;\\n        int unsorted_columns = 0;\\n        for(int i = 0 ; i < strs[0].length() ; ++i)\\n        {\\n            for(int j = 0 ; j < (strs.length - 1) ; ++j)\\n            {\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i))\\n                {\\n                    ++unsorted_columns;\\n                    break;\\n                }\\n            }\\n        }\\n        return unsorted_columns;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002005,
                "title": "easy-java-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust Check vertically for each column that its sorted lexicographically if not increase your count and jump to next column and check.\\n\\n# Complexity\\n- Time complexity: O(NM)\\nN = length of array of Strings\\nM = String length\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        int n = strs.length;\\n        for(int i = 0 ; i < strs[0].length(); i ++){\\n            int nums = (int)strs[0].charAt(i);\\n            for(int j = 1; j < n; j ++){\\n                if((int)strs[j].charAt(i) >= nums){\\n                    nums = (int)strs[j].charAt(i);\\n                }else{\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        int n = strs.length;\\n        for(int i = 0 ; i < strs[0].length(); i ++){\\n            int nums = (int)strs[0].charAt(i);\\n            for(int j = 1; j < n; j ++){\\n                if((int)strs[j].charAt(i) >= nums){\\n                    nums = (int)strs[j].charAt(i);\\n                }else{\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000606,
                "title": "explained-well-with-pictures-c",
                "content": "\\n# Approach (Please like :D)\\n<!-- Describe your approach to solving the problem. -->\\nThe function starts by declaring three local integer variables: \"firstWordLength,\" \"lengthOfArray,\" and \"columnsDeleted.\" The value of \"firstWordLength\" is set to the length of the first string in the input array, \"strs.\" The value of \"lengthOfArray\" is set to the length of the array \"strs\" minus 1. The value of \"columnsDeleted\" is set to 0.\\n\\nThe function then enters a loop that iterates over the characters in the first string of the input array (which is stored at index 0). For each iteration of the loop, another loop is entered that iterates over the strings in the input array, starting at index 0 and ending at the second-to-last index.\\n\\nInside the inner loop, the function compares the character at the current index (which is stored in the variable \"i\") of the current string (which is stored in the variable \"j\") to the character at the same index of the next string (which is stored at index \"j+1\"). If the character in the current string is greater (i.e., has a higher ASCII value), the function increments the value of \"columnsDeleted\" by 1 and exits the inner loop using the \"break\" statement.\\n\\nAfter both loops have completed, the function returns the value of \"columnsDeleted.\\n\\n![image.png](https://assets.leetcode.com/users/images/6e5819bd-8665-4dcd-bf1e-72857588e0ef_1672886178.666302.png)\\n\\n# Complexity\\n- Time complexity: 130 - 200 ms ish \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinDeletionSize(string[] strs) {\\n\\n\\n        int firstWordLength = strs[0].Length;\\n        int lengthOfArray = strs.Length-1;\\n        int columnsDeleted = 0;\\n\\n        for(int i = 0; i < firstWordLength; i++)\\n        {\\n            for(int j = 0; j < lengthOfArray; j++)\\n            {\\n                if(strs[j][i] > strs[j+1][i])\\n                {\\n                    columnsDeleted++;\\n                    \\n                    break;\\n                }\\n            }\\n        }\\n        return columnsDeleted;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinDeletionSize(string[] strs) {\\n\\n\\n        int firstWordLength = strs[0].Length;\\n        int lengthOfArray = strs.Length-1;\\n        int columnsDeleted = 0;\\n\\n        for(int i = 0; i < firstWordLength; i++)\\n        {\\n            for(int j = 0; j < lengthOfArray; j++)\\n            {\\n                if(strs[j][i] > strs[j+1][i])\\n                {\\n                    columnsDeleted++;\\n                    \\n                    break;\\n                }\\n            }\\n        }\\n        return columnsDeleted;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997960,
                "title": "javascript-o-n-k-time-o-n-space",
                "content": "# Intuition\\nTo determine if the letters are in order, it\\'s enough to compare their ASCII values. We know that if previous letter is less than current letter, letters are in order. This is simplified even more since we know all items will be from lowercase english alphabet.\\n\\nIn javascript, it\\'s not necessary to extract that value using any methods, we can directly compare the strings. \\n\\n# Approach\\n1) Declare a counter variable, `res` (or any other name you prefer)\\n2) Iterate over columns\\n    - Iterate over rows\\n    - Check if the previous character in a column is less than the current one. If it is not, increment the counter. Break to avoid duplication of result.\\n3) Retun the answer\\n\\n\\n# Complexity\\n- Time complexity: O(N * K); N is the size of the array, K is the size of the string\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {number}\\n */\\nvar minDeletionSize = function(strs) {\\n    let res = 0\\n\\n    for (let col = 0; col < strs[0].length; col++) {\\n        for (let row = 1; row < strs.length; row++) {\\n            if (strs[row][col] < strs[row - 1][col]) {\\n                res++\\n                break\\n            }\\n        }\\n    }\\n\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {number}\\n */\\nvar minDeletionSize = function(strs) {\\n    let res = 0\\n\\n    for (let col = 0; col < strs[0].length; col++) {\\n        for (let row = 1; row < strs.length; row++) {\\n            if (strs[row][col] < strs[row - 1][col]) {\\n                res++\\n                break\\n            }\\n        }\\n    }\\n\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2997278,
                "title": "swift-solution",
                "content": "# Complexity\\n- Time complexity: $$O(nk)$$, n \\u2013 word lenght, k \\u2013 number of words\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func minDeletionSize(_ strs: [String]) -> Int {\\n        let strs = strs.map { Array($0) }\\n        var counter = 0\\n\\n        for column in 0..<strs[0].count {\\n            for row in 0..<strs.count - 1 {\\n                if strs[row][column] > strs[row + 1][column] {\\n                    counter += 1\\n                    break\\n                }\\n            }\\n        }\\n\\n        return counter\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minDeletionSize(_ strs: [String]) -> Int {\\n        let strs = strs.map { Array($0) }\\n        var counter = 0\\n\\n        for column in 0..<strs[0].count {\\n            for row in 0..<strs.count - 1 {\\n                if strs[row][column] > strs[row + 1][column] {\\n                    counter += 1\\n                    break\\n                }\\n            }\\n        }\\n\\n        return counter\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996514,
                "title": "easy-understanding-java-solution",
                "content": "# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int minDeletionSize(String[] strs) \\n    {\\n        int deletionCount = 0;\\n        \\n        for(int i=0; i<strs[0].length(); i++)\\n        {\\n            for(int j=0; j<strs.length-1; j++)\\n            {\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i))\\n                {\\n                    deletionCount++; break;\\n                }\\n            }\\n        }\\n        return deletionCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int minDeletionSize(String[] strs) \\n    {\\n        int deletionCount = 0;\\n        \\n        for(int i=0; i<strs[0].length(); i++)\\n        {\\n            for(int j=0; j<strs.length-1; j++)\\n            {\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i))\\n                {\\n                    deletionCount++; break;\\n                }\\n            }\\n        }\\n        return deletionCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995935,
                "title": "c-easiest-solution-deep-and-concise-detailed-solution-t-c-o-row-col",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n\\n**T.C => O(row*col)**\\n\\n*col -> word.size()\\nrow -> arr.length()-1*\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) \\n    {\\n           int ans=0;\\n           int word_size = strs[0].size();\\n           \\n           // Traverse in col. No. of col is length of words in arr. (# size of each words is same).\\n           // Traverse in row. No. of rows is No. of words in arr. \\n\\n           for(int col=0; col<word_size; col++)\\n           {\\n                  for(int row=0; row<strs.size()-1; row++) // strs.size()-1 -> becoz we take next pointer\\n                  {\\n                      if(strs[row][col] > strs[row+1][col])\\n                      {\\n                          ans++; // increment no of rows\\n                          break;  // we found fault.\\n                      }\\n                  } \\n           }\\n           \\n           return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) \\n    {\\n           int ans=0;\\n           int word_size = strs[0].size();\\n           \\n           // Traverse in col. No. of col is length of words in arr. (# size of each words is same).\\n           // Traverse in row. No. of rows is No. of words in arr. \\n\\n           for(int col=0; col<word_size; col++)\\n           {\\n                  for(int row=0; row<strs.size()-1; row++) // strs.size()-1 -> becoz we take next pointer\\n                  {\\n                      if(strs[row][col] > strs[row+1][col])\\n                      {\\n                          ans++; // increment no of rows\\n                          break;  // we found fault.\\n                      }\\n                  } \\n           }\\n           \\n           return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994473,
                "title": "python-easy-and-simple-solution",
                "content": "```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        m,n=len(strs),len(strs[0])\\n        c=0\\n        for i in range(n):\\n            for j in range(m-1):\\n                if ord(strs[j][i])>ord(strs[j+1][i]):\\n                    c+=1\\n                    break\\n        return c\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        m,n=len(strs),len(strs[0])\\n        c=0\\n        for i in range(n):\\n            for j in range(m-1):\\n                if ord(strs[j][i])>ord(strs[j+1][i]):\\n                    c+=1\\n                    break\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994326,
                "title": "java-solution-easy",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int c = 0;\\n\\n        for (int i = 0; i < strs[0].length(); i++){\\n            char temp = strs[0].charAt(i);\\n            for (String str : strs) {\\n                if (temp <= str.charAt(i)) {\\n                    temp = str.charAt(i);\\n                }else {\\n                    c++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int c = 0;\\n\\n        for (int i = 0; i < strs[0].length(); i++){\\n            char temp = strs[0].charAt(i);\\n            for (String str : strs) {\\n                if (temp <= str.charAt(i)) {\\n                    temp = str.charAt(i);\\n                }else {\\n                    c++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994295,
                "title": "c-traversing-row-and-column-solution",
                "content": "\\n# Code\\n```\\n    int minDeletionSize(vector<string>& strs) \\n    {\\n        int cnt=0;\\n        int m=strs.size();\\n        int n=strs[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m-1;j++)\\n            {\\n                if(strs[j][i]>strs[j+1][i])\\n                {\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int minDeletionSize(vector<string>& strs) \\n    {\\n        int cnt=0;\\n        int m=strs.size();\\n        int n=strs[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m-1;j++)\\n            {\\n                if(strs[j][i]>strs[j+1][i])\\n                {\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2994282,
                "title": "944-delete-columns-to-make-sorted",
                "content": "Approach use two loops one for choosing a particular  word for each string\\nOther for for comparing like [\"cba\",\"daf\",\"ghi\"] a with b its check a next ele with previous one\\nIf you find the solution useful then an upvote would really be an O(n) decison :)\\n\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int oddOne=0;\\n        int n=strs.length; // whole arr length\\n        int m=strs[0].length(); // particular word length\\n        for(int i=0;i<m;i++) { // for coloums\\n            for(int j=1;j<n;j++) { // for rows \\n            if(strs[j].charAt(i) <strs[j-1].charAt(i)){\\n                oddOne++;\\n                break;    \\n            }      \\n        }  \\n    }\\n        return oddOne;\\n   }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int oddOne=0;\\n        int n=strs.length; // whole arr length\\n        int m=strs[0].length(); // particular word length\\n        for(int i=0;i<m;i++) { // for coloums\\n            for(int j=1;j<n;j++) { // for rows \\n            if(strs[j].charAt(i) <strs[j-1].charAt(i)){\\n                oddOne++;\\n                break;    \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2994243,
                "title": "simple-solution-using-java-o-n-k-time-and-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*K)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        short deletedColumsNumber =0;\\n\\n        for(int i=0; i<strs[0].length(); i++){\\n     \\n            char prev = strs[0].charAt(i);\\n            for(int j=1; j<strs.length;j++){\\n                if(strs[j].charAt(i)-\\'a\\' < prev -\\'a\\') {deletedColumsNumber++; break;}\\n                prev = strs[j].charAt(i);\\n            }\\n        }\\n        return deletedColumsNumber;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        short deletedColumsNumber =0;\\n\\n        for(int i=0; i<strs[0].length(); i++){\\n     \\n            char prev = strs[0].charAt(i);\\n            for(int j=1; j<strs.length;j++){\\n                if(strs[j].charAt(i)-\\'a\\' < prev -\\'a\\') {deletedColumsNumber++; break;}\\n                prev = strs[j].charAt(i);\\n            }\\n        }\\n        return deletedColumsNumber;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993992,
                "title": "easiest-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        \\n        int cnt=0;\\n\\n        for(int j=0; j<strs[0].size(); j++){\\n\\n          char c=strs[0][j];\\n\\n          for(int i=1; i<strs.size();i++){\\n                 \\n                 if(strs[i][j]>=c){\\n                     c=strs[i][j];\\n                 }\\n                 else{\\n                     cnt++;\\n                     break;\\n                 }\\n\\n          }\\n\\n        }\\n\\n       return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        \\n        int cnt=0;\\n\\n        for(int j=0; j<strs[0].size(); j++){\\n\\n          char c=strs[0][j];\\n\\n          for(int i=1; i<strs.size();i++){\\n                 \\n                 if(strs[i][j]>=c){\\n                     c=strs[i][j];\\n                 }\\n                 else{\\n                     cnt++;\\n                     break;\\n                 }\\n\\n          }\\n\\n        }\\n\\n       return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993950,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int r=strs.size();\\n        int count=0;\\n        int col=strs[0].size();\\n        for(int j=0;j<col;j++)\\n        {\\n            for(int i=0;i<r-1;i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int r=strs.size();\\n        int count=0;\\n        int col=strs[0].size();\\n        for(int j=0;j<col;j++)\\n        {\\n            for(int i=0;i<r-1;i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993880,
                "title": "easy-understandable-c-code-with-o-1-sapce",
                "content": "# Intuition\\n<!-- Instead of RowWise Traversal we have have to do ColumnWise Traversal  -->\\n\\n# Approach\\n<!-- Just compare the chars in vertical order traversal -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- O(n*m) -->\\n\\n- Space complexity:\\n<!-- O(1) -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        // a -> 97.     z -> 122. (ASCII VALUES)\\n\\n        int cnt = 0;\\n        int m = strs[0].size();\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 1; j < strs.size(); j++)\\n            {\\n                // cout<<strs[j][i];\\n                if(strs[j-1][i] > strs[j][i]){\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n            // cout<<endl;\\n        }\\n        // cout<<\"cnt\"<<cnt<<endl;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        // a -> 97.     z -> 122. (ASCII VALUES)\\n\\n        int cnt = 0;\\n        int m = strs[0].size();\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 1; j < strs.size(); j++)\\n            {\\n                // cout<<strs[j][i];\\n                if(strs[j-1][i] > strs[j][i]){\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n            // cout<<endl;\\n        }\\n        // cout<<\"cnt\"<<cnt<<endl;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2993854,
                "title": "accepted-with-comments-solution-easy-and-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        // Initialize the delete count to 0\\n        int deleteCount = 0;\\n        // Get the number of rows and columns in the grid\\n        int n = strs.length;\\n        int m = strs[0].length();\\n        // Iterate through each column of the grid\\n        for (int i = 0; i < m; i++) {\\n            // Iterate through each element in the column\\n            for (int j = 1; j < n; j++) {\\n                // If the current element is lexicographically smaller than the previous element,\\n                // increment the delete count and break out of the loop\\n                if (strs[j].charAt(i) < strs[j - 1].charAt(i)) {\\n                    deleteCount++;\\n                    break;\\n                }\\n            }\\n        }\\n        // Return the delete count\\n        return deleteCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        // Initialize the delete count to 0\\n        int deleteCount = 0;\\n        // Get the number of rows and columns in the grid\\n        int n = strs.length;\\n        int m = strs[0].length();\\n        // Iterate through each column of the grid\\n        for (int i = 0; i < m; i++) {\\n            // Iterate through each element in the column\\n            for (int j = 1; j < n; j++) {\\n                // If the current element is lexicographically smaller than the previous element,\\n                // increment the delete count and break out of the loop\\n                if (strs[j].charAt(i) < strs[j - 1].charAt(i)) {\\n                    deleteCount++;\\n                    break;\\n                }\\n            }\\n        }\\n        // Return the delete count\\n        return deleteCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993830,
                "title": "java-string-matrix-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nString and array manipulation \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPut each string character wise in a matrix format. Then check for each column of the matrix if it is not inserted in ascending format, increase the count and break. Then move to next column and check for the same constraint. Finally return the count.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        int m = strs.length;\\n        int n = strs[0].length();\\n        int matrix[][] = new int[m][n];\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                matrix[i][j] = strs[i].charAt(j) - \\'a\\';\\n            }\\n        }\\n        for(int j = 0;j<n;j++){\\n            for(int i = 1;i<m;i++){\\n                if(matrix[i][j] < matrix[i-1][j]){\\n                    count++;\\n                    break;\\n                }\\n                else{\\n                    continue;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        int m = strs.length;\\n        int n = strs[0].length();\\n        int matrix[][] = new int[m][n];\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                matrix[i][j] = strs[i].charAt(j) - \\'a\\';\\n            }\\n        }\\n        for(int j = 0;j<n;j++){\\n            for(int i = 1;i<m;i++){\\n                if(matrix[i][j] < matrix[i-1][j]){\\n                    count++;\\n                    break;\\n                }\\n                else{\\n                    continue;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993737,
                "title": "simple-intuition-with-easy-approach-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first intuition is that we will have to iterate through the entire string vector and compare each char of each string in it.\\n\\nWe will also have to store the status of each column (whether sorted or not) to find out how many total columns do we actually need to delete.\\n\\n--> We cannot simply make a counter variable and do *counter++* when there is an unsorted occurance because a column may have more than one unsorted occurances and in this case, then result will be incorrect. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. If the vector of strings has only one element, then we do not need to delete anything because a single element is always sorted in itself. Hence, directly return 0.\\n2. Else, create a bool array (sorted here) of size equal to the number of columns such that each index denotes each column status.\\n3. Initially, initialize each column status as true (means sorted).\\n4. Iterate through the entire vector of strings from its second element and keep comparing its each char with the char of previous element at the same index.\\n5. If any unsorted order occurs, change the status of that corresponding column to false (denoting that it needs to be deleted).\\n6. Finally count all the number of false occurances in the bool array and return that value as the required output.\\n# Complexity\\n- Time complexity = $$O(n * len)$$\\nwhere, n = length of vector of strings and \\nlen = length of each string in it or the total number of columns.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity = $$O(n)$$\\nfor using boolean array to hold the status of each column.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& str) {\\n        int n = str.size() ;\\n\\n        if(n == 1) return 0 ;\\n\\n        int len = str[0].length() ;\\n        bool sorted[len] ;    //To store result of each column.\\n        memset(sorted, true, sizeof(sorted)) ;\\n\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<len; j++){\\n                if(str[i][j] < str[i-1][j]){\\n                    sorted[j] = false ;\\n                }\\n            }\\n        }\\n\\n        int count = 0 ;\\n        for(int i=0; i<len; i++){\\n            if(!sorted[i]){\\n                count++ ;\\n            }\\n        }\\n\\n        return count ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& str) {\\n        int n = str.size() ;\\n\\n        if(n == 1) return 0 ;\\n\\n        int len = str[0].length() ;\\n        bool sorted[len] ;    //To store result of each column.\\n        memset(sorted, true, sizeof(sorted)) ;\\n\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<len; j++){\\n                if(str[i][j] < str[i-1][j]){\\n                    sorted[j] = false ;\\n                }\\n            }\\n        }\\n\\n        int count = 0 ;\\n        for(int i=0; i<len; i++){\\n            if(!sorted[i]){\\n                count++ ;\\n            }\\n        }\\n\\n        return count ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993411,
                "title": "easy-to-understand-c-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIn this problem first we are traversing column wise so here if any greater ascii value alphabet if comes first  then count value increases by 1 then break the loop then again check the next column so on .finally we got the result as the count.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n**Please upvote if you like the solution.**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int count=0;\\n        int m=strs[0].length();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n      return count;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int count=0;\\n        int m=strs[0].length();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n      return count;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993409,
                "title": "easy-to-understand-c-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIn this problem first we are traversing column wise so here if any greater ascii value alphabet if comes first  then count value increases by 1 then break the loop then again check the next column so on .finally we got the result as the count.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n**Please upvote if you like the solution.**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int count=0;\\n        int m=strs[0].length();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n      return count;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int count=0;\\n        int m=strs[0].length();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n      return count;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993374,
                "title": "easy-java-solution",
                "content": "#\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int m=strs[0].length();\\n        int ans=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=1;j<strs.length;j++){\\n                if(strs[j].charAt(i)<strs[j-1].charAt(i)){\\n                 ans++;\\n                 break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int m=strs[0].length();\\n        int ans=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=1;j<strs.length;j++){\\n                if(strs[j].charAt(i)<strs[j-1].charAt(i)){\\n                 ans++;\\n                 break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993278,
                "title": "m-n-easiest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int m=strs[0].size();\\n        int col,row,res=0;\\n        for(col=0;col<m;col++){\\n            for(row=0;row<n-1;row++){\\n                if(strs[row][col]<=strs[row+1][col]){\\n                    continue;\\n                }\\n                else{\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int m=strs[0].size();\\n        int col,row,res=0;\\n        for(col=0;col<m;col++){\\n            for(row=0;row<n-1;row++){\\n                if(strs[row][col]<=strs[row+1][col]){\\n                    continue;\\n                }\\n                else{\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993164,
                "title": "simple-c-by-nested-loop-to-check-sorting",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count_col = 0;\\n        for (int i = 0; i < strs[0].size(); i++) {\\n            char prev = strs[0][i];\\n            char curr ;\\n            for (int j = 1; j < strs.size(); j++) {\\n                curr = strs[j][i];\\n                if (prev > curr) {\\n                    count_col++;\\n                    break;\\n                } else {\\n                    prev = curr;\\n                }\\n            }\\n        }\\n        return count_col;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count_col = 0;\\n        for (int i = 0; i < strs[0].size(); i++) {\\n            char prev = strs[0][i];\\n            char curr ;\\n            for (int j = 1; j < strs.size(); j++) {\\n                curr = strs[j][i];\\n                if (prev > curr) {\\n                    count_col++;\\n                    break;\\n                } else {\\n                    prev = curr;\\n                }\\n            }\\n        }\\n        return count_col;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992996,
                "title": "c-o-n-m-solution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& vec) {\\n        int r = 0; int c = 0; int colDel = 0;\\n        while(c < vec[0].size()) {\\n            if(r == vec.size()-1){\\n                r = 0;\\n                c++;\\n            }\\n            else if(vec[r][c] > vec[r + 1][c]) {\\n                colDel++;\\n                c++;\\n                r = 0;\\n            }\\n            else r++;\\n        }\\n        return colDel;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& vec) {\\n        int r = 0; int c = 0; int colDel = 0;\\n        while(c < vec[0].size()) {\\n            if(r == vec.size()-1){\\n                r = 0;\\n                c++;\\n            }\\n            else if(vec[r][c] > vec[r + 1][c]) {\\n                colDel++;\\n                c++;\\n                r = 0;\\n            }\\n            else r++;\\n        }\\n        return colDel;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992952,
                "title": "c-easy-approach-counitng",
                "content": "\\n\\n# Approach\\nTo check every character in a Col. Col should be constant and row must be kept changing.\\nAfter, that checking if previous char is greater than next only then inc counter(delete col) and break that loop.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int  r = strs.size();\\n        int c = strs[0].size();\\n        int cnt=0;\\n        \\n//tricky in loops\\n        for(int i=0; i<c; i++){\\n            for(int j=0; j<r-1; j++){\\n                if (strs[j][i] > strs[j+1][i]) {\\n                cnt++;\\n                break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String Matching",
                    "Matrix",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int  r = strs.size();\\n        int c = strs[0].size();\\n        int cnt=0;\\n        \\n//tricky in loops\\n        for(int i=0; i<c; i++){\\n            for(int j=0; j<r-1; j++){\\n                if (strs[j][i] > strs[j+1][i]) {\\n                cnt++;\\n                break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992829,
                "title": "c",
                "content": "~~~\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count=0,n=strs.size(),m=strs[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            int a=strs[0][i]-\\'a\\';\\n            for(int j=1;j<n;j++)\\n            {\\n                if(a>strs[j][i]-\\'a\\') \\n                {\\n                    count++;\\n                    break;\\n                }\\n                a=strs[j][i]-\\'a\\';\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int count=0,n=strs.size(),m=strs[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            int a=strs[0][i]-\\'a\\';\\n            for(int j=1;j<n;j++)\\n            {\\n                if(a>strs[j][i]-\\'a\\') \\n                {\\n                    count++;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2992782,
                "title": "c-faster-than-99",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nm)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int res = 0;\\n        for (int i = 0; i < strs[0].size(); ++ i) {\\n            for (int j = 1; j < strs.size(); ++ j) {\\n                if (strs[j][i] < strs[j - 1][i]) {\\n                    ++ res;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if u like the solution \\uD83D\\uDE0A**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int res = 0;\\n        for (int i = 0; i < strs[0].size(); ++ i) {\\n            for (int j = 1; j < strs.size(); ++ j) {\\n                if (strs[j][i] < strs[j - 1][i]) {\\n                    ++ res;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992502,
                "title": "cpp-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int ans=0;\\n        for(int i=0;i<strs[0].length();i++)\\n        {\\n            for(int j=1;j<strs.size();j++)\\n            {\\n                if(strs[j-1][i]>strs[j][i])\\n                {\\n                    ans+=1;\\n                    break;\\n                }\\n            }\\n           \\n        }\\n        return ans;\\n//upvote if you find it helpful\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int ans=0;\\n        for(int i=0;i<strs[0].length();i++)\\n        {\\n            for(int j=1;j<strs.size();j++)\\n            {\\n                if(strs[j-1][i]>strs[j][i])\\n                {\\n                    ans+=1;\\n                    break;\\n                }\\n            }\\n           \\n        }\\n        return ans;\\n//upvote if you find it helpful\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992497,
                "title": "easy-java-solution-90-faster",
                "content": "\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n- \\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n\\n    int count=0;\\n     for(int i=0;i<strs[0].length();i++)\\n     {\\n          char prev=\\'0\\';\\n         for(String s:strs)\\n         {\\n             char curr=s.charAt(i);\\n             if(prev>curr)\\n             {\\n                 count++;\\n                  break;\\n             }\\n             prev=curr;\\n         }\\n     }\\n     return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n\\n    int count=0;\\n     for(int i=0;i<strs[0].length();i++)\\n     {\\n          char prev=\\'0\\';\\n         for(String s:strs)\\n         {\\n             char curr=s.charAt(i);\\n             if(prev>curr)\\n             {\\n                 count++;\\n                  break;\\n             }\\n             prev=curr;\\n         }\\n     }\\n     return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992478,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n;\\n        int ans = 0;// no of columns to be deleted\\n        int k = 0; // for iterating over the length of string\\n        \\n        while(k < strs[0].length()) {\\n            int prev = (int) strs[0].charAt(k);\\n            for(int i = 1; i < strs.length; i++) { //iterating through array to check all strings\\n                int curr = (int) strs[i].charAt(k);\\n                if(curr < prev) {\\n                    ans++;\\n                    break;\\n                }else {\\n                    prev = curr;\\n                }\\n            }\\n            \\n            k++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n;\\n        int ans = 0;// no of columns to be deleted\\n        int k = 0; // for iterating over the length of string\\n        \\n        while(k < strs[0].length()) {\\n            int prev = (int) strs[0].charAt(k);\\n            for(int i = 1; i < strs.length; i++) { //iterating through array to check all strings\\n                int curr = (int) strs[i].charAt(k);\\n                if(curr < prev) {\\n                    ans++;\\n                    break;\\n                }else {\\n                    prev = curr;\\n                }\\n            }\\n            \\n            k++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992389,
                "title": "easy-c-code",
                "content": "\\n# Complexity\\n- Time complexity:O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int m=strs.size(),n=strs[0].size(),ans=0;\\n        for(int j=0;j<n;j++){\\n            bool flag=1;\\n            for(int i=1;i<m;i++){\\n            if(strs[i][j]<strs[i-1][j]){//unsorted\\n            flag=0;\\n            break;}\\n            }\\n            if(!flag)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int m=strs.size(),n=strs[0].size(),ans=0;\\n        for(int j=0;j<n;j++){\\n            bool flag=1;\\n            for(int i=1;i<m;i++){\\n            if(strs[i][j]<strs[i-1][j]){//unsorted\\n            flag=0;\\n            break;}\\n            }\\n            if(!flag)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992240,
                "title": "very-easy-process-normal-loop-operation-java",
                "content": "- 85/85 cases passed (10 ms)\\n- Your runtime beats 69.21 % of java submissions\\n- Your memory usage beats 45.62 % of java submissions (47.7 MB)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int l=strs[0].length(),out=0;\\n        for(int i=0;i<l;i++)\\n            for(int j=0;j<strs.length-1;j++)\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    out++;\\n                    break;\\n                }\\n\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int l=strs[0].length(),out=0;\\n        for(int i=0;i<l;i++)\\n            for(int j=0;j<strs.length-1;j++)\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    out++;\\n                    break;\\n                }\\n\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1738908,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....üßê?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1739329,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....üßê?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1739476,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....üßê?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1569669,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....üßê?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1738901,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....üßê?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1739477,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....üßê?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1565362,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....üßê?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1739160,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....üßê?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1738974,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....üßê?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1738982,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....üßê?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1738908,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....üßê?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1739329,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....üßê?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1739476,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....üßê?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1569669,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....üßê?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1738901,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....üßê?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1739477,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....üßê?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1565362,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....üßê?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1739160,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....üßê?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1738974,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....üßê?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1738982,
                "content": [
                    {
                        "username": "Emoclaw",
                        "content": "we\\'re starting 2023 with an easy streak, i feel like we\\'re gonna get blasted with dp hards towards mid-end of Jan"
                    },
                    {
                        "username": "drewbie",
                        "content": "The calm before the storm"
                    },
                    {
                        "username": "ravi_kant_chauhan",
                        "content": "and still some of the programmers like me are not even getting the problem ..."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "most probably hard dp problems in mid-jan and our streak gonna break out \\uD83D\\uDE25"
                    },
                    {
                        "username": "kajal1801",
                        "content": "I got the same feeling \\uD83E\\uDEE5"
                    },
                    {
                        "username": "marcocane",
                        "content": "man i forgor the 1st"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "You may thinking Why this problem got so much dislikes .....üßê?  Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes.  You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Indeed, it was super terrible!\\nThanks for this comment."
                    },
                    {
                        "username": "ajedmh",
                        "content": "I don\\'t understand why in the examples \"cba\" is considered but \"zyx\" isn\\'t. The problem seems to be just in the first example but it\\'s not allowing me to pass."
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I had the same thoughts, but it is columns, not rows. \\nFor example, \\n\\ncba\\ndaf\\nghi\\n\\ncba isn\\'t being considered, the columns that are considered are \"c, d, g\", \"b, a, h\", and \"a, f, i\". Since the middle row (b, a, h), is the only one that isn\\'t sorted, we return 1. If there was a column that spelled \"cba\", it wouldn\\'t be considered as sorted lexographically."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order, [cba] -> c b a are the rows"
                    },
                    {
                        "username": "esint2030",
                        "content": "I really don\\'t get why people are saying this problem is so hard to understand. I read the description and it only took me 2 minutes to understand it. Are people\\'s comprehension skills really that low or are people just giving up if they can\\'t understand a problem in less than 5 seconds?"
                    },
                    {
                        "username": "Finesse",
                        "content": "2 minutes? It took me 5 seconds (including finding a solution)"
                    },
                    {
                        "username": "calm27",
                        "content": "frankly, it is not that obvious. so, don\\'t be like that, it is fine to complain. people complain, relax and refine the scope. "
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151"
                    },
                    {
                        "username": "codedrian",
                        "content": "[@pieceofpie](/pieceofpie) i agree\\n"
                    },
                    {
                        "username": "Bobolov",
                        "content": "sure\\n"
                    },
                    {
                        "username": "larrasket",
                        "content": "No it\\'s obvious, you are a genius and most people have low IQ than yours. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I don\\'t think the problem is hard to understand. The problem is that the problem is very badly formulated, which can make some people not fully understand the problem."
                    },
                    {
                        "username": "chornox",
                        "content": "The problem constraints just need a small change. \\n\\n `for any i strs[i].length == m` \\n\\nAll strings are equal"
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "Entered this section looking for this kind of confirmation. Thx"
                    },
                    {
                        "username": "chornox",
                        "content": "[@_BREEZE_](/_BREEZE_) yes that\\'s correct. I was referring to the last section. I usually just glance at it to verify these details. "
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "That is written in the problem statement \\n`You are given an array of n strings strs, all of the same length.`"
                    },
                    {
                        "username": "Jugni",
                        "content": "What is this?? \\n1. columns 0 (\\'a\\', \\'b\\', \\'c\\') and 2 (\\'c\\', \\'e\\', \\'e\\') are sorted . Given array-> strs = [\"abc\", \"bce\", \"cae\"]. Where is \\'cee\\'?\\n2. Input: strs = [\"cba\",\"daf\",\"ghi\"].  Columns 0 and 2 are sorted\\n3. Input: strs = [\"zyx\",\"wvu\",\"tsr\"]. All 3 columns are not sorted\\n\\nTake a look at \"cba\". This group is sorted in descending order e.g \"abc\" and the description says that it is sorted (point 2) But in another example, it disregards the above example; \"zyx\" -> \"xyz\" (backwards). Can someone explain? "
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) got it\\n"
                    },
                    {
                        "username": "aka773",
                        "content": "https://blog.csdn.net/qq_38959715/article/details/85299151\\ngo here"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "[@belinskyi](/belinskyi) In input 3 what should be the output? "
                    },
                    {
                        "username": "arns",
                        "content": "it is being seen column wise not row-wise"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you'll see [`c`,`e`,`e`]. This array is sorted in ascending order."
                    },
                    {
                        "username": "emli",
                        "content": "It\\'s easy with but with bad statement"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Exactly, but easy to understand with the Sample Cases provided."
                    },
                    {
                        "username": "Knight-03",
                        "content": "There is nothing to dislike this question \\ntake a `pen and paper write down the condition` they\\'ve given \\nit will be `very clear` that whats the `question saying`\\n\\nyou just need to `compare column elements ` \\nrun two for loops ............\\n--->`one from 0 to numbers of columns `\\n---> `inner loops from 1 to number of rows` \\ncompare `str[j][i] < str[j-1][i]` if true count++; and break that loop \\n`return that count`\\n\\neasy pizzy "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the different strings in the array given. Other loop to iterate across the string i.e., to move across an individual element of the array. "
                    },
                    {
                        "username": "nipunrathore",
                        "content": "[@Ak_15](/Ak_15) 1 array we are using to access the elements of the array. 1st row is 1st string, 2nd row is 2nd string and so on. Other array we use to iterate across the string character-wise. "
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@Ak_15](/Ak_15)  in the given string \\n[\"abc\",\"bce\",\"cae\"]\\n   |         |        |   \\n  1        2       3\\nso , 1=> strs[j][i] and  strs[1][0] both are same. its not a entire string. \\n"
                    },
                    {
                        "username": "Knight-03",
                        "content": "[@Ak_15](/Ak_15) in array 0th element is the whole string so you can access it by just strs[i][j] "
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro but the given is 1-D array right! how can i use column?????? could you explain meee\\n"
                    },
                    {
                        "username": "user8166e",
                        "content": "Associated tag with this problem is Hash table. How Hash table feet\\'s in the solution ?"
                    },
                    {
                        "username": "davidaviadh",
                        "content": "I, like I assume you did as well, did not implicitly use a Hash table.\\nbut what i think is happening \"under the hood\" is that the way you compare letter using math symbols is by having a hash table in the background that give \"a\" a smaller value then \"b\" and so on.\\nthis is just a guess so I look forward to be corrected!"
                    },
                    {
                        "username": "ayushp2021",
                        "content": "Why so many dislikes to this problem??"
                    },
                    {
                        "username": "TALLEC-Scott",
                        "content": "You may thinking Why this problem got so much dislikes .....\\uD83E\\uDDD0? Because previously like 1.5 year ago when I tried to solve this question the formulation and explanation was terrible now I guess they revised it ,and explained properly ,that is why It is having so much dislikes. You can refer this ,how it was explained before : https://blog.csdn.net/qq_38959715/article/details/85299151\\n\\nsource: [@Sachin](/sachinbaral02) "
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "because they are noobs and cant reallt understand question"
                    },
                    {
                        "username": "mihir_adarsh",
                        "content": "Probably you won\\'t find this type of question in interviews. If you are new to programming, then you can solve this as a warm up question. "
                    },
                    {
                        "username": "BLOCKS",
                        "content": "Probably poor framing of the question."
                    }
                ]
            },
            {
                "id": 1739212,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have helped more if it could have been mentioned that only ascending lexicographical order is desired, I guess descending order too qualifies as lexicographical but is not desired in this problem."
                    },
                    {
                        "username": "Finesse",
                        "content": "It is neither ascending nor descending, it's lexicographical. I.e. follows a predefined order (the English alphabet in this case). Letters aren't numbers, so they can't ascend or descend. What you call \"descending\" is actually reverse lexicographical order."
                    },
                    {
                        "username": "shailika",
                        "content": "Don't see array index value like in\nExample 1 Input: strs = [\"cba\",\"daf\",\"ghi\"]\nhere, cba is correct so why in\nExample 2 Input: strs = [\"zyx\",\"wvu\",\"tsr\"]\nzyx , wvu , tsr   are not correct üòÇ..\n\nExplanation:\nbecause we have to check as column wise so see each index 1st value with another index 1st value:\nlike\ncba \ndaf\nghi\n\nin see this each row 1st index\n1st column \"c , d , g\" c ASCII number smaller then d same with d is smaller then g they are sorted.\n\n2nd column \"b , a , h\" here b is grater then a so it will be delete.\n\n3rd column \"a , f , i\" here all r sorted a ASCII smaller then f and f is smaller then i.\n\nhere ASCII is a number of characters.\nrefer this link to know more about ASCII\nhttps://www.computerhope.com/jargon/a/ascii.htm\n\n\n\n"
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Easy Problem Just Traverse The Grid Through The Columns"
                    },
                    {
                        "username": "kena",
                        "content": "Its actually row which needs to be sorted, not the column"
                    },
                    {
                        "username": "user5466Sr",
                        "content": "i think you are correct!\\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "No, we need to find the number of columns which are not sorted."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The given problem now feels more like a programming exercise than a serious algorithm interview question.\\n\\nAs the title, I wonder if this problem is still solvable if the description is changed to `delete columns to make the remaining characters in every string sorted`?"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "[@kunaljainwin](/kunaljainwin)  Lets make itmore interesting by adding \\n`\\nMinimum number of columns to be deleted.\\n`"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "for(auto &it:strs){\\nfor(int i=0;i<len-1;i++){\\nif(it[i]>it[i+1]){\\n// Delete that column , make of size len and mark i th colum as deleted\\n}\\n}\\n}"
                    },
                    {
                        "username": "qiushile",
                        "content": "yep, no corresponding issue in reality"
                    },
                    {
                        "username": "SalihE",
                        "content": "Really hard to undestand the problem. But solutions is so easy :)"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Traversing the 2D array column-wise (n=strs.size(), m=strs[0].size() ) and compare characters strs[j][i] > strs[j+1][i]. \\nAny more than this might as well be a spoiler(if already isn\\'t) but not a bad problem."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Is there a mistake? Why in Example 1 \"cba\" is sorted and in the Example 3 \"zyx\" isn\\'t sorted? Can someone please clarify what do I need to implement because this task seems to me as ambiguous."
                    },
                    {
                        "username": "NightGamer01",
                        "content": "C++ Users \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shushpanovdenis",
                        "content": "One of the easiest problems"
                    }
                ]
            },
            {
                "id": 1740128,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have helped more if it could have been mentioned that only ascending lexicographical order is desired, I guess descending order too qualifies as lexicographical but is not desired in this problem."
                    },
                    {
                        "username": "Finesse",
                        "content": "It is neither ascending nor descending, it's lexicographical. I.e. follows a predefined order (the English alphabet in this case). Letters aren't numbers, so they can't ascend or descend. What you call \"descending\" is actually reverse lexicographical order."
                    },
                    {
                        "username": "shailika",
                        "content": "Don't see array index value like in\nExample 1 Input: strs = [\"cba\",\"daf\",\"ghi\"]\nhere, cba is correct so why in\nExample 2 Input: strs = [\"zyx\",\"wvu\",\"tsr\"]\nzyx , wvu , tsr   are not correct üòÇ..\n\nExplanation:\nbecause we have to check as column wise so see each index 1st value with another index 1st value:\nlike\ncba \ndaf\nghi\n\nin see this each row 1st index\n1st column \"c , d , g\" c ASCII number smaller then d same with d is smaller then g they are sorted.\n\n2nd column \"b , a , h\" here b is grater then a so it will be delete.\n\n3rd column \"a , f , i\" here all r sorted a ASCII smaller then f and f is smaller then i.\n\nhere ASCII is a number of characters.\nrefer this link to know more about ASCII\nhttps://www.computerhope.com/jargon/a/ascii.htm\n\n\n\n"
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Easy Problem Just Traverse The Grid Through The Columns"
                    },
                    {
                        "username": "kena",
                        "content": "Its actually row which needs to be sorted, not the column"
                    },
                    {
                        "username": "user5466Sr",
                        "content": "i think you are correct!\\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "No, we need to find the number of columns which are not sorted."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The given problem now feels more like a programming exercise than a serious algorithm interview question.\\n\\nAs the title, I wonder if this problem is still solvable if the description is changed to `delete columns to make the remaining characters in every string sorted`?"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "[@kunaljainwin](/kunaljainwin)  Lets make itmore interesting by adding \\n`\\nMinimum number of columns to be deleted.\\n`"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "for(auto &it:strs){\\nfor(int i=0;i<len-1;i++){\\nif(it[i]>it[i+1]){\\n// Delete that column , make of size len and mark i th colum as deleted\\n}\\n}\\n}"
                    },
                    {
                        "username": "qiushile",
                        "content": "yep, no corresponding issue in reality"
                    },
                    {
                        "username": "SalihE",
                        "content": "Really hard to undestand the problem. But solutions is so easy :)"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Traversing the 2D array column-wise (n=strs.size(), m=strs[0].size() ) and compare characters strs[j][i] > strs[j+1][i]. \\nAny more than this might as well be a spoiler(if already isn\\'t) but not a bad problem."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Is there a mistake? Why in Example 1 \"cba\" is sorted and in the Example 3 \"zyx\" isn\\'t sorted? Can someone please clarify what do I need to implement because this task seems to me as ambiguous."
                    },
                    {
                        "username": "NightGamer01",
                        "content": "C++ Users \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shushpanovdenis",
                        "content": "One of the easiest problems"
                    }
                ]
            },
            {
                "id": 1739150,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have helped more if it could have been mentioned that only ascending lexicographical order is desired, I guess descending order too qualifies as lexicographical but is not desired in this problem."
                    },
                    {
                        "username": "Finesse",
                        "content": "It is neither ascending nor descending, it's lexicographical. I.e. follows a predefined order (the English alphabet in this case). Letters aren't numbers, so they can't ascend or descend. What you call \"descending\" is actually reverse lexicographical order."
                    },
                    {
                        "username": "shailika",
                        "content": "Don't see array index value like in\nExample 1 Input: strs = [\"cba\",\"daf\",\"ghi\"]\nhere, cba is correct so why in\nExample 2 Input: strs = [\"zyx\",\"wvu\",\"tsr\"]\nzyx , wvu , tsr   are not correct üòÇ..\n\nExplanation:\nbecause we have to check as column wise so see each index 1st value with another index 1st value:\nlike\ncba \ndaf\nghi\n\nin see this each row 1st index\n1st column \"c , d , g\" c ASCII number smaller then d same with d is smaller then g they are sorted.\n\n2nd column \"b , a , h\" here b is grater then a so it will be delete.\n\n3rd column \"a , f , i\" here all r sorted a ASCII smaller then f and f is smaller then i.\n\nhere ASCII is a number of characters.\nrefer this link to know more about ASCII\nhttps://www.computerhope.com/jargon/a/ascii.htm\n\n\n\n"
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Easy Problem Just Traverse The Grid Through The Columns"
                    },
                    {
                        "username": "kena",
                        "content": "Its actually row which needs to be sorted, not the column"
                    },
                    {
                        "username": "user5466Sr",
                        "content": "i think you are correct!\\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "No, we need to find the number of columns which are not sorted."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The given problem now feels more like a programming exercise than a serious algorithm interview question.\\n\\nAs the title, I wonder if this problem is still solvable if the description is changed to `delete columns to make the remaining characters in every string sorted`?"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "[@kunaljainwin](/kunaljainwin)  Lets make itmore interesting by adding \\n`\\nMinimum number of columns to be deleted.\\n`"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "for(auto &it:strs){\\nfor(int i=0;i<len-1;i++){\\nif(it[i]>it[i+1]){\\n// Delete that column , make of size len and mark i th colum as deleted\\n}\\n}\\n}"
                    },
                    {
                        "username": "qiushile",
                        "content": "yep, no corresponding issue in reality"
                    },
                    {
                        "username": "SalihE",
                        "content": "Really hard to undestand the problem. But solutions is so easy :)"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Traversing the 2D array column-wise (n=strs.size(), m=strs[0].size() ) and compare characters strs[j][i] > strs[j+1][i]. \\nAny more than this might as well be a spoiler(if already isn\\'t) but not a bad problem."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Is there a mistake? Why in Example 1 \"cba\" is sorted and in the Example 3 \"zyx\" isn\\'t sorted? Can someone please clarify what do I need to implement because this task seems to me as ambiguous."
                    },
                    {
                        "username": "NightGamer01",
                        "content": "C++ Users \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shushpanovdenis",
                        "content": "One of the easiest problems"
                    }
                ]
            },
            {
                "id": 1739116,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have helped more if it could have been mentioned that only ascending lexicographical order is desired, I guess descending order too qualifies as lexicographical but is not desired in this problem."
                    },
                    {
                        "username": "Finesse",
                        "content": "It is neither ascending nor descending, it's lexicographical. I.e. follows a predefined order (the English alphabet in this case). Letters aren't numbers, so they can't ascend or descend. What you call \"descending\" is actually reverse lexicographical order."
                    },
                    {
                        "username": "shailika",
                        "content": "Don't see array index value like in\nExample 1 Input: strs = [\"cba\",\"daf\",\"ghi\"]\nhere, cba is correct so why in\nExample 2 Input: strs = [\"zyx\",\"wvu\",\"tsr\"]\nzyx , wvu , tsr   are not correct üòÇ..\n\nExplanation:\nbecause we have to check as column wise so see each index 1st value with another index 1st value:\nlike\ncba \ndaf\nghi\n\nin see this each row 1st index\n1st column \"c , d , g\" c ASCII number smaller then d same with d is smaller then g they are sorted.\n\n2nd column \"b , a , h\" here b is grater then a so it will be delete.\n\n3rd column \"a , f , i\" here all r sorted a ASCII smaller then f and f is smaller then i.\n\nhere ASCII is a number of characters.\nrefer this link to know more about ASCII\nhttps://www.computerhope.com/jargon/a/ascii.htm\n\n\n\n"
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Easy Problem Just Traverse The Grid Through The Columns"
                    },
                    {
                        "username": "kena",
                        "content": "Its actually row which needs to be sorted, not the column"
                    },
                    {
                        "username": "user5466Sr",
                        "content": "i think you are correct!\\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "No, we need to find the number of columns which are not sorted."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The given problem now feels more like a programming exercise than a serious algorithm interview question.\\n\\nAs the title, I wonder if this problem is still solvable if the description is changed to `delete columns to make the remaining characters in every string sorted`?"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "[@kunaljainwin](/kunaljainwin)  Lets make itmore interesting by adding \\n`\\nMinimum number of columns to be deleted.\\n`"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "for(auto &it:strs){\\nfor(int i=0;i<len-1;i++){\\nif(it[i]>it[i+1]){\\n// Delete that column , make of size len and mark i th colum as deleted\\n}\\n}\\n}"
                    },
                    {
                        "username": "qiushile",
                        "content": "yep, no corresponding issue in reality"
                    },
                    {
                        "username": "SalihE",
                        "content": "Really hard to undestand the problem. But solutions is so easy :)"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Traversing the 2D array column-wise (n=strs.size(), m=strs[0].size() ) and compare characters strs[j][i] > strs[j+1][i]. \\nAny more than this might as well be a spoiler(if already isn\\'t) but not a bad problem."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Is there a mistake? Why in Example 1 \"cba\" is sorted and in the Example 3 \"zyx\" isn\\'t sorted? Can someone please clarify what do I need to implement because this task seems to me as ambiguous."
                    },
                    {
                        "username": "NightGamer01",
                        "content": "C++ Users \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shushpanovdenis",
                        "content": "One of the easiest problems"
                    }
                ]
            },
            {
                "id": 1569400,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have helped more if it could have been mentioned that only ascending lexicographical order is desired, I guess descending order too qualifies as lexicographical but is not desired in this problem."
                    },
                    {
                        "username": "Finesse",
                        "content": "It is neither ascending nor descending, it's lexicographical. I.e. follows a predefined order (the English alphabet in this case). Letters aren't numbers, so they can't ascend or descend. What you call \"descending\" is actually reverse lexicographical order."
                    },
                    {
                        "username": "shailika",
                        "content": "Don't see array index value like in\nExample 1 Input: strs = [\"cba\",\"daf\",\"ghi\"]\nhere, cba is correct so why in\nExample 2 Input: strs = [\"zyx\",\"wvu\",\"tsr\"]\nzyx , wvu , tsr   are not correct üòÇ..\n\nExplanation:\nbecause we have to check as column wise so see each index 1st value with another index 1st value:\nlike\ncba \ndaf\nghi\n\nin see this each row 1st index\n1st column \"c , d , g\" c ASCII number smaller then d same with d is smaller then g they are sorted.\n\n2nd column \"b , a , h\" here b is grater then a so it will be delete.\n\n3rd column \"a , f , i\" here all r sorted a ASCII smaller then f and f is smaller then i.\n\nhere ASCII is a number of characters.\nrefer this link to know more about ASCII\nhttps://www.computerhope.com/jargon/a/ascii.htm\n\n\n\n"
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Easy Problem Just Traverse The Grid Through The Columns"
                    },
                    {
                        "username": "kena",
                        "content": "Its actually row which needs to be sorted, not the column"
                    },
                    {
                        "username": "user5466Sr",
                        "content": "i think you are correct!\\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "No, we need to find the number of columns which are not sorted."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The given problem now feels more like a programming exercise than a serious algorithm interview question.\\n\\nAs the title, I wonder if this problem is still solvable if the description is changed to `delete columns to make the remaining characters in every string sorted`?"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "[@kunaljainwin](/kunaljainwin)  Lets make itmore interesting by adding \\n`\\nMinimum number of columns to be deleted.\\n`"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "for(auto &it:strs){\\nfor(int i=0;i<len-1;i++){\\nif(it[i]>it[i+1]){\\n// Delete that column , make of size len and mark i th colum as deleted\\n}\\n}\\n}"
                    },
                    {
                        "username": "qiushile",
                        "content": "yep, no corresponding issue in reality"
                    },
                    {
                        "username": "SalihE",
                        "content": "Really hard to undestand the problem. But solutions is so easy :)"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Traversing the 2D array column-wise (n=strs.size(), m=strs[0].size() ) and compare characters strs[j][i] > strs[j+1][i]. \\nAny more than this might as well be a spoiler(if already isn\\'t) but not a bad problem."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Is there a mistake? Why in Example 1 \"cba\" is sorted and in the Example 3 \"zyx\" isn\\'t sorted? Can someone please clarify what do I need to implement because this task seems to me as ambiguous."
                    },
                    {
                        "username": "NightGamer01",
                        "content": "C++ Users \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shushpanovdenis",
                        "content": "One of the easiest problems"
                    }
                ]
            },
            {
                "id": 1572550,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have helped more if it could have been mentioned that only ascending lexicographical order is desired, I guess descending order too qualifies as lexicographical but is not desired in this problem."
                    },
                    {
                        "username": "Finesse",
                        "content": "It is neither ascending nor descending, it's lexicographical. I.e. follows a predefined order (the English alphabet in this case). Letters aren't numbers, so they can't ascend or descend. What you call \"descending\" is actually reverse lexicographical order."
                    },
                    {
                        "username": "shailika",
                        "content": "Don't see array index value like in\nExample 1 Input: strs = [\"cba\",\"daf\",\"ghi\"]\nhere, cba is correct so why in\nExample 2 Input: strs = [\"zyx\",\"wvu\",\"tsr\"]\nzyx , wvu , tsr   are not correct üòÇ..\n\nExplanation:\nbecause we have to check as column wise so see each index 1st value with another index 1st value:\nlike\ncba \ndaf\nghi\n\nin see this each row 1st index\n1st column \"c , d , g\" c ASCII number smaller then d same with d is smaller then g they are sorted.\n\n2nd column \"b , a , h\" here b is grater then a so it will be delete.\n\n3rd column \"a , f , i\" here all r sorted a ASCII smaller then f and f is smaller then i.\n\nhere ASCII is a number of characters.\nrefer this link to know more about ASCII\nhttps://www.computerhope.com/jargon/a/ascii.htm\n\n\n\n"
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Easy Problem Just Traverse The Grid Through The Columns"
                    },
                    {
                        "username": "kena",
                        "content": "Its actually row which needs to be sorted, not the column"
                    },
                    {
                        "username": "user5466Sr",
                        "content": "i think you are correct!\\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "No, we need to find the number of columns which are not sorted."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The given problem now feels more like a programming exercise than a serious algorithm interview question.\\n\\nAs the title, I wonder if this problem is still solvable if the description is changed to `delete columns to make the remaining characters in every string sorted`?"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "[@kunaljainwin](/kunaljainwin)  Lets make itmore interesting by adding \\n`\\nMinimum number of columns to be deleted.\\n`"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "for(auto &it:strs){\\nfor(int i=0;i<len-1;i++){\\nif(it[i]>it[i+1]){\\n// Delete that column , make of size len and mark i th colum as deleted\\n}\\n}\\n}"
                    },
                    {
                        "username": "qiushile",
                        "content": "yep, no corresponding issue in reality"
                    },
                    {
                        "username": "SalihE",
                        "content": "Really hard to undestand the problem. But solutions is so easy :)"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Traversing the 2D array column-wise (n=strs.size(), m=strs[0].size() ) and compare characters strs[j][i] > strs[j+1][i]. \\nAny more than this might as well be a spoiler(if already isn\\'t) but not a bad problem."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Is there a mistake? Why in Example 1 \"cba\" is sorted and in the Example 3 \"zyx\" isn\\'t sorted? Can someone please clarify what do I need to implement because this task seems to me as ambiguous."
                    },
                    {
                        "username": "NightGamer01",
                        "content": "C++ Users \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shushpanovdenis",
                        "content": "One of the easiest problems"
                    }
                ]
            },
            {
                "id": 1961285,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have helped more if it could have been mentioned that only ascending lexicographical order is desired, I guess descending order too qualifies as lexicographical but is not desired in this problem."
                    },
                    {
                        "username": "Finesse",
                        "content": "It is neither ascending nor descending, it's lexicographical. I.e. follows a predefined order (the English alphabet in this case). Letters aren't numbers, so they can't ascend or descend. What you call \"descending\" is actually reverse lexicographical order."
                    },
                    {
                        "username": "shailika",
                        "content": "Don't see array index value like in\nExample 1 Input: strs = [\"cba\",\"daf\",\"ghi\"]\nhere, cba is correct so why in\nExample 2 Input: strs = [\"zyx\",\"wvu\",\"tsr\"]\nzyx , wvu , tsr   are not correct üòÇ..\n\nExplanation:\nbecause we have to check as column wise so see each index 1st value with another index 1st value:\nlike\ncba \ndaf\nghi\n\nin see this each row 1st index\n1st column \"c , d , g\" c ASCII number smaller then d same with d is smaller then g they are sorted.\n\n2nd column \"b , a , h\" here b is grater then a so it will be delete.\n\n3rd column \"a , f , i\" here all r sorted a ASCII smaller then f and f is smaller then i.\n\nhere ASCII is a number of characters.\nrefer this link to know more about ASCII\nhttps://www.computerhope.com/jargon/a/ascii.htm\n\n\n\n"
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Easy Problem Just Traverse The Grid Through The Columns"
                    },
                    {
                        "username": "kena",
                        "content": "Its actually row which needs to be sorted, not the column"
                    },
                    {
                        "username": "user5466Sr",
                        "content": "i think you are correct!\\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "No, we need to find the number of columns which are not sorted."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The given problem now feels more like a programming exercise than a serious algorithm interview question.\\n\\nAs the title, I wonder if this problem is still solvable if the description is changed to `delete columns to make the remaining characters in every string sorted`?"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "[@kunaljainwin](/kunaljainwin)  Lets make itmore interesting by adding \\n`\\nMinimum number of columns to be deleted.\\n`"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "for(auto &it:strs){\\nfor(int i=0;i<len-1;i++){\\nif(it[i]>it[i+1]){\\n// Delete that column , make of size len and mark i th colum as deleted\\n}\\n}\\n}"
                    },
                    {
                        "username": "qiushile",
                        "content": "yep, no corresponding issue in reality"
                    },
                    {
                        "username": "SalihE",
                        "content": "Really hard to undestand the problem. But solutions is so easy :)"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Traversing the 2D array column-wise (n=strs.size(), m=strs[0].size() ) and compare characters strs[j][i] > strs[j+1][i]. \\nAny more than this might as well be a spoiler(if already isn\\'t) but not a bad problem."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Is there a mistake? Why in Example 1 \"cba\" is sorted and in the Example 3 \"zyx\" isn\\'t sorted? Can someone please clarify what do I need to implement because this task seems to me as ambiguous."
                    },
                    {
                        "username": "NightGamer01",
                        "content": "C++ Users \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shushpanovdenis",
                        "content": "One of the easiest problems"
                    }
                ]
            },
            {
                "id": 1958841,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have helped more if it could have been mentioned that only ascending lexicographical order is desired, I guess descending order too qualifies as lexicographical but is not desired in this problem."
                    },
                    {
                        "username": "Finesse",
                        "content": "It is neither ascending nor descending, it's lexicographical. I.e. follows a predefined order (the English alphabet in this case). Letters aren't numbers, so they can't ascend or descend. What you call \"descending\" is actually reverse lexicographical order."
                    },
                    {
                        "username": "shailika",
                        "content": "Don't see array index value like in\nExample 1 Input: strs = [\"cba\",\"daf\",\"ghi\"]\nhere, cba is correct so why in\nExample 2 Input: strs = [\"zyx\",\"wvu\",\"tsr\"]\nzyx , wvu , tsr   are not correct üòÇ..\n\nExplanation:\nbecause we have to check as column wise so see each index 1st value with another index 1st value:\nlike\ncba \ndaf\nghi\n\nin see this each row 1st index\n1st column \"c , d , g\" c ASCII number smaller then d same with d is smaller then g they are sorted.\n\n2nd column \"b , a , h\" here b is grater then a so it will be delete.\n\n3rd column \"a , f , i\" here all r sorted a ASCII smaller then f and f is smaller then i.\n\nhere ASCII is a number of characters.\nrefer this link to know more about ASCII\nhttps://www.computerhope.com/jargon/a/ascii.htm\n\n\n\n"
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Easy Problem Just Traverse The Grid Through The Columns"
                    },
                    {
                        "username": "kena",
                        "content": "Its actually row which needs to be sorted, not the column"
                    },
                    {
                        "username": "user5466Sr",
                        "content": "i think you are correct!\\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "No, we need to find the number of columns which are not sorted."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The given problem now feels more like a programming exercise than a serious algorithm interview question.\\n\\nAs the title, I wonder if this problem is still solvable if the description is changed to `delete columns to make the remaining characters in every string sorted`?"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "[@kunaljainwin](/kunaljainwin)  Lets make itmore interesting by adding \\n`\\nMinimum number of columns to be deleted.\\n`"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "for(auto &it:strs){\\nfor(int i=0;i<len-1;i++){\\nif(it[i]>it[i+1]){\\n// Delete that column , make of size len and mark i th colum as deleted\\n}\\n}\\n}"
                    },
                    {
                        "username": "qiushile",
                        "content": "yep, no corresponding issue in reality"
                    },
                    {
                        "username": "SalihE",
                        "content": "Really hard to undestand the problem. But solutions is so easy :)"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Traversing the 2D array column-wise (n=strs.size(), m=strs[0].size() ) and compare characters strs[j][i] > strs[j+1][i]. \\nAny more than this might as well be a spoiler(if already isn\\'t) but not a bad problem."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Is there a mistake? Why in Example 1 \"cba\" is sorted and in the Example 3 \"zyx\" isn\\'t sorted? Can someone please clarify what do I need to implement because this task seems to me as ambiguous."
                    },
                    {
                        "username": "NightGamer01",
                        "content": "C++ Users \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shushpanovdenis",
                        "content": "One of the easiest problems"
                    }
                ]
            },
            {
                "id": 1958633,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have helped more if it could have been mentioned that only ascending lexicographical order is desired, I guess descending order too qualifies as lexicographical but is not desired in this problem."
                    },
                    {
                        "username": "Finesse",
                        "content": "It is neither ascending nor descending, it's lexicographical. I.e. follows a predefined order (the English alphabet in this case). Letters aren't numbers, so they can't ascend or descend. What you call \"descending\" is actually reverse lexicographical order."
                    },
                    {
                        "username": "shailika",
                        "content": "Don't see array index value like in\nExample 1 Input: strs = [\"cba\",\"daf\",\"ghi\"]\nhere, cba is correct so why in\nExample 2 Input: strs = [\"zyx\",\"wvu\",\"tsr\"]\nzyx , wvu , tsr   are not correct üòÇ..\n\nExplanation:\nbecause we have to check as column wise so see each index 1st value with another index 1st value:\nlike\ncba \ndaf\nghi\n\nin see this each row 1st index\n1st column \"c , d , g\" c ASCII number smaller then d same with d is smaller then g they are sorted.\n\n2nd column \"b , a , h\" here b is grater then a so it will be delete.\n\n3rd column \"a , f , i\" here all r sorted a ASCII smaller then f and f is smaller then i.\n\nhere ASCII is a number of characters.\nrefer this link to know more about ASCII\nhttps://www.computerhope.com/jargon/a/ascii.htm\n\n\n\n"
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Easy Problem Just Traverse The Grid Through The Columns"
                    },
                    {
                        "username": "kena",
                        "content": "Its actually row which needs to be sorted, not the column"
                    },
                    {
                        "username": "user5466Sr",
                        "content": "i think you are correct!\\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "No, we need to find the number of columns which are not sorted."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The given problem now feels more like a programming exercise than a serious algorithm interview question.\\n\\nAs the title, I wonder if this problem is still solvable if the description is changed to `delete columns to make the remaining characters in every string sorted`?"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "[@kunaljainwin](/kunaljainwin)  Lets make itmore interesting by adding \\n`\\nMinimum number of columns to be deleted.\\n`"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "for(auto &it:strs){\\nfor(int i=0;i<len-1;i++){\\nif(it[i]>it[i+1]){\\n// Delete that column , make of size len and mark i th colum as deleted\\n}\\n}\\n}"
                    },
                    {
                        "username": "qiushile",
                        "content": "yep, no corresponding issue in reality"
                    },
                    {
                        "username": "SalihE",
                        "content": "Really hard to undestand the problem. But solutions is so easy :)"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Traversing the 2D array column-wise (n=strs.size(), m=strs[0].size() ) and compare characters strs[j][i] > strs[j+1][i]. \\nAny more than this might as well be a spoiler(if already isn\\'t) but not a bad problem."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Is there a mistake? Why in Example 1 \"cba\" is sorted and in the Example 3 \"zyx\" isn\\'t sorted? Can someone please clarify what do I need to implement because this task seems to me as ambiguous."
                    },
                    {
                        "username": "NightGamer01",
                        "content": "C++ Users \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shushpanovdenis",
                        "content": "One of the easiest problems"
                    }
                ]
            },
            {
                "id": 1913130,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have helped more if it could have been mentioned that only ascending lexicographical order is desired, I guess descending order too qualifies as lexicographical but is not desired in this problem."
                    },
                    {
                        "username": "Finesse",
                        "content": "It is neither ascending nor descending, it's lexicographical. I.e. follows a predefined order (the English alphabet in this case). Letters aren't numbers, so they can't ascend or descend. What you call \"descending\" is actually reverse lexicographical order."
                    },
                    {
                        "username": "shailika",
                        "content": "Don't see array index value like in\nExample 1 Input: strs = [\"cba\",\"daf\",\"ghi\"]\nhere, cba is correct so why in\nExample 2 Input: strs = [\"zyx\",\"wvu\",\"tsr\"]\nzyx , wvu , tsr   are not correct üòÇ..\n\nExplanation:\nbecause we have to check as column wise so see each index 1st value with another index 1st value:\nlike\ncba \ndaf\nghi\n\nin see this each row 1st index\n1st column \"c , d , g\" c ASCII number smaller then d same with d is smaller then g they are sorted.\n\n2nd column \"b , a , h\" here b is grater then a so it will be delete.\n\n3rd column \"a , f , i\" here all r sorted a ASCII smaller then f and f is smaller then i.\n\nhere ASCII is a number of characters.\nrefer this link to know more about ASCII\nhttps://www.computerhope.com/jargon/a/ascii.htm\n\n\n\n"
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Easy Problem Just Traverse The Grid Through The Columns"
                    },
                    {
                        "username": "kena",
                        "content": "Its actually row which needs to be sorted, not the column"
                    },
                    {
                        "username": "user5466Sr",
                        "content": "i think you are correct!\\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "No, we need to find the number of columns which are not sorted."
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The given problem now feels more like a programming exercise than a serious algorithm interview question.\\n\\nAs the title, I wonder if this problem is still solvable if the description is changed to `delete columns to make the remaining characters in every string sorted`?"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "[@kunaljainwin](/kunaljainwin)  Lets make itmore interesting by adding \\n`\\nMinimum number of columns to be deleted.\\n`"
                    },
                    {
                        "username": "kunaljainwin",
                        "content": "for(auto &it:strs){\\nfor(int i=0;i<len-1;i++){\\nif(it[i]>it[i+1]){\\n// Delete that column , make of size len and mark i th colum as deleted\\n}\\n}\\n}"
                    },
                    {
                        "username": "qiushile",
                        "content": "yep, no corresponding issue in reality"
                    },
                    {
                        "username": "SalihE",
                        "content": "Really hard to undestand the problem. But solutions is so easy :)"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Traversing the 2D array column-wise (n=strs.size(), m=strs[0].size() ) and compare characters strs[j][i] > strs[j+1][i]. \\nAny more than this might as well be a spoiler(if already isn\\'t) but not a bad problem."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Is there a mistake? Why in Example 1 \"cba\" is sorted and in the Example 3 \"zyx\" isn\\'t sorted? Can someone please clarify what do I need to implement because this task seems to me as ambiguous."
                    },
                    {
                        "username": "NightGamer01",
                        "content": "C++ Users \\uD83D\\uDE0E"
                    },
                    {
                        "username": "shushpanovdenis",
                        "content": "One of the easiest problems"
                    }
                ]
            },
            {
                "id": 1779306,
                "content": [
                    {
                        "username": "harshilnashier",
                        "content": "can it be solved with time complexity that is better than O(n^2)?"
                    },
                    {
                        "username": "ganesh254",
                        "content": "class Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        count = 0\\n        n = len(strs)\\n        m = len(strs[0])\\n        for i in range(0, m):\\n            for j in range(0,n-1):\\n                if strs[j][i] > strs[j+1][i]:\\n                    count += 1\\n                    break\\n        return count"
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Why so many dislikes on the problem? Just transpose matrix and check each row for i+1-th element being greater or equal than i-th. Check my solution if don\\'t get the idea."
                    },
                    {
                        "username": "bharatjoshics",
                        "content": "Step 1. Initialize a counter to 0\\nStep 2. Start a loop from 0th index example \\'j\\'\\nStep 3. Start second loop inside first loop from 1st index example \\'i\\'\\nStep 4. Compare if [i][j]<[i-1][j]\\nStep 5. If yes then make your counter +1 and break \\nStep 6. At the end , return your counter"
                    },
                    {
                        "username": "Loreee",
                        "content": "If we had to delete the columns that are not sorted lexicographically, and not only show the number of those columns, what would we use? When we find a column that is not sorted, can we use memmove to move the content of each string after the index  of that column to the left with one letter? Is this a good idea? If it is can someone please show me how the arguments of memmove would look like for this? "
                    },
                    {
                        "username": "Siroj910",
                        "content": "There is a problem in expected: \\ninput: [\"cba\",\"daf\",\"ghi\"] -> in sorted it will be [\\'abc\\', \\'adf\\', \\'ghi\\'], \\nand result will be 2 because \"abc\" and \"daf\" is wrong, but expected 1, who can explain it? In my view my result is true"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# Intuition\\n- To be in lexicographic order, each character in the column should be equal to or greater than the corresponding character in the previous row.\\n- Therefore, we will iterate over the columns and for each column, we will iterate over the rows starting from index `1` (not zero, as we will compare the character to the character in the previous row). We will then increment the count of unsorted columns every time we observe a character smaller than the character in the previous row.\\n\\n---\\n\\n\\n# Approach\\n- Initialize the delete count to `0`.\\n- Get the number of rows (`r`) and columns (`c`).\\n- If the current element is lexicographically smaller than the previous element, increment the delete count and break out of the loop\\n\\n---\\n\\n\\n# Complexity\\n- Time Complexity\\n$$O(n*m)$$ \\n\\n- Space Complexity\\n$$O(1)$$\\n\\nRefer My Solution - [Java | Easy | 100% Fast Solution | Matrix | Pointers](https://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2994341/java-easy-100-fast-solution-matrix-pointers/)"
                    },
                    {
                        "username": "ckcjc",
                        "content": " ```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0; \\n        for(int i= 0; i < strs[0].length(); i++){\\n            for(int j = 0; j< strs.length - 1; j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "pratham95484",
                        "content": " `your inline code...your inline code...` \\nstatic public int minDeletionSize(String[] str) {\\n      \\n       int counts=0,countus=0;\\n       for(int i=0;i<str.length;i++)\\n       {    \\n           char[] a = str[i].toCharArray();\\n           int count=0;\\n           for(int j=0;j<a.length;j++)\\n           {\\n               for(int k=j+1;k<a.length;k++)\\n               {\\n                   int first=(int)a[j];\\n                   int second=(int)a[k];\\n                   if(first>second)\\n                   {\\n                       count++;\\n                   }\\n               }\\n           }\\n           if(count==a.length)\\n           {\\n               counts++;\\n           }\\n           \\n       }\\n       return counts;\\n    }\\n    public static void main(String [] args)\\n    {\\n String [] str = {\"cba\",\"daf\",\"ghi\"}; \\n    int result =Solution.minDeletionSize(str);\\n    System.out.println(result);\\n    }"
                    },
                    {
                        "username": "nxabdullah",
                        "content": "Hint: think of it as a 2D array (or a matrix) problem"
                    }
                ]
            },
            {
                "id": 1765162,
                "content": [
                    {
                        "username": "harshilnashier",
                        "content": "can it be solved with time complexity that is better than O(n^2)?"
                    },
                    {
                        "username": "ganesh254",
                        "content": "class Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        count = 0\\n        n = len(strs)\\n        m = len(strs[0])\\n        for i in range(0, m):\\n            for j in range(0,n-1):\\n                if strs[j][i] > strs[j+1][i]:\\n                    count += 1\\n                    break\\n        return count"
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Why so many dislikes on the problem? Just transpose matrix and check each row for i+1-th element being greater or equal than i-th. Check my solution if don\\'t get the idea."
                    },
                    {
                        "username": "bharatjoshics",
                        "content": "Step 1. Initialize a counter to 0\\nStep 2. Start a loop from 0th index example \\'j\\'\\nStep 3. Start second loop inside first loop from 1st index example \\'i\\'\\nStep 4. Compare if [i][j]<[i-1][j]\\nStep 5. If yes then make your counter +1 and break \\nStep 6. At the end , return your counter"
                    },
                    {
                        "username": "Loreee",
                        "content": "If we had to delete the columns that are not sorted lexicographically, and not only show the number of those columns, what would we use? When we find a column that is not sorted, can we use memmove to move the content of each string after the index  of that column to the left with one letter? Is this a good idea? If it is can someone please show me how the arguments of memmove would look like for this? "
                    },
                    {
                        "username": "Siroj910",
                        "content": "There is a problem in expected: \\ninput: [\"cba\",\"daf\",\"ghi\"] -> in sorted it will be [\\'abc\\', \\'adf\\', \\'ghi\\'], \\nand result will be 2 because \"abc\" and \"daf\" is wrong, but expected 1, who can explain it? In my view my result is true"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# Intuition\\n- To be in lexicographic order, each character in the column should be equal to or greater than the corresponding character in the previous row.\\n- Therefore, we will iterate over the columns and for each column, we will iterate over the rows starting from index `1` (not zero, as we will compare the character to the character in the previous row). We will then increment the count of unsorted columns every time we observe a character smaller than the character in the previous row.\\n\\n---\\n\\n\\n# Approach\\n- Initialize the delete count to `0`.\\n- Get the number of rows (`r`) and columns (`c`).\\n- If the current element is lexicographically smaller than the previous element, increment the delete count and break out of the loop\\n\\n---\\n\\n\\n# Complexity\\n- Time Complexity\\n$$O(n*m)$$ \\n\\n- Space Complexity\\n$$O(1)$$\\n\\nRefer My Solution - [Java | Easy | 100% Fast Solution | Matrix | Pointers](https://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2994341/java-easy-100-fast-solution-matrix-pointers/)"
                    },
                    {
                        "username": "ckcjc",
                        "content": " ```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0; \\n        for(int i= 0; i < strs[0].length(); i++){\\n            for(int j = 0; j< strs.length - 1; j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "pratham95484",
                        "content": " `your inline code...your inline code...` \\nstatic public int minDeletionSize(String[] str) {\\n      \\n       int counts=0,countus=0;\\n       for(int i=0;i<str.length;i++)\\n       {    \\n           char[] a = str[i].toCharArray();\\n           int count=0;\\n           for(int j=0;j<a.length;j++)\\n           {\\n               for(int k=j+1;k<a.length;k++)\\n               {\\n                   int first=(int)a[j];\\n                   int second=(int)a[k];\\n                   if(first>second)\\n                   {\\n                       count++;\\n                   }\\n               }\\n           }\\n           if(count==a.length)\\n           {\\n               counts++;\\n           }\\n           \\n       }\\n       return counts;\\n    }\\n    public static void main(String [] args)\\n    {\\n String [] str = {\"cba\",\"daf\",\"ghi\"}; \\n    int result =Solution.minDeletionSize(str);\\n    System.out.println(result);\\n    }"
                    },
                    {
                        "username": "nxabdullah",
                        "content": "Hint: think of it as a 2D array (or a matrix) problem"
                    }
                ]
            },
            {
                "id": 1750348,
                "content": [
                    {
                        "username": "harshilnashier",
                        "content": "can it be solved with time complexity that is better than O(n^2)?"
                    },
                    {
                        "username": "ganesh254",
                        "content": "class Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        count = 0\\n        n = len(strs)\\n        m = len(strs[0])\\n        for i in range(0, m):\\n            for j in range(0,n-1):\\n                if strs[j][i] > strs[j+1][i]:\\n                    count += 1\\n                    break\\n        return count"
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Why so many dislikes on the problem? Just transpose matrix and check each row for i+1-th element being greater or equal than i-th. Check my solution if don\\'t get the idea."
                    },
                    {
                        "username": "bharatjoshics",
                        "content": "Step 1. Initialize a counter to 0\\nStep 2. Start a loop from 0th index example \\'j\\'\\nStep 3. Start second loop inside first loop from 1st index example \\'i\\'\\nStep 4. Compare if [i][j]<[i-1][j]\\nStep 5. If yes then make your counter +1 and break \\nStep 6. At the end , return your counter"
                    },
                    {
                        "username": "Loreee",
                        "content": "If we had to delete the columns that are not sorted lexicographically, and not only show the number of those columns, what would we use? When we find a column that is not sorted, can we use memmove to move the content of each string after the index  of that column to the left with one letter? Is this a good idea? If it is can someone please show me how the arguments of memmove would look like for this? "
                    },
                    {
                        "username": "Siroj910",
                        "content": "There is a problem in expected: \\ninput: [\"cba\",\"daf\",\"ghi\"] -> in sorted it will be [\\'abc\\', \\'adf\\', \\'ghi\\'], \\nand result will be 2 because \"abc\" and \"daf\" is wrong, but expected 1, who can explain it? In my view my result is true"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# Intuition\\n- To be in lexicographic order, each character in the column should be equal to or greater than the corresponding character in the previous row.\\n- Therefore, we will iterate over the columns and for each column, we will iterate over the rows starting from index `1` (not zero, as we will compare the character to the character in the previous row). We will then increment the count of unsorted columns every time we observe a character smaller than the character in the previous row.\\n\\n---\\n\\n\\n# Approach\\n- Initialize the delete count to `0`.\\n- Get the number of rows (`r`) and columns (`c`).\\n- If the current element is lexicographically smaller than the previous element, increment the delete count and break out of the loop\\n\\n---\\n\\n\\n# Complexity\\n- Time Complexity\\n$$O(n*m)$$ \\n\\n- Space Complexity\\n$$O(1)$$\\n\\nRefer My Solution - [Java | Easy | 100% Fast Solution | Matrix | Pointers](https://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2994341/java-easy-100-fast-solution-matrix-pointers/)"
                    },
                    {
                        "username": "ckcjc",
                        "content": " ```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0; \\n        for(int i= 0; i < strs[0].length(); i++){\\n            for(int j = 0; j< strs.length - 1; j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "pratham95484",
                        "content": " `your inline code...your inline code...` \\nstatic public int minDeletionSize(String[] str) {\\n      \\n       int counts=0,countus=0;\\n       for(int i=0;i<str.length;i++)\\n       {    \\n           char[] a = str[i].toCharArray();\\n           int count=0;\\n           for(int j=0;j<a.length;j++)\\n           {\\n               for(int k=j+1;k<a.length;k++)\\n               {\\n                   int first=(int)a[j];\\n                   int second=(int)a[k];\\n                   if(first>second)\\n                   {\\n                       count++;\\n                   }\\n               }\\n           }\\n           if(count==a.length)\\n           {\\n               counts++;\\n           }\\n           \\n       }\\n       return counts;\\n    }\\n    public static void main(String [] args)\\n    {\\n String [] str = {\"cba\",\"daf\",\"ghi\"}; \\n    int result =Solution.minDeletionSize(str);\\n    System.out.println(result);\\n    }"
                    },
                    {
                        "username": "nxabdullah",
                        "content": "Hint: think of it as a 2D array (or a matrix) problem"
                    }
                ]
            },
            {
                "id": 1744641,
                "content": [
                    {
                        "username": "harshilnashier",
                        "content": "can it be solved with time complexity that is better than O(n^2)?"
                    },
                    {
                        "username": "ganesh254",
                        "content": "class Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        count = 0\\n        n = len(strs)\\n        m = len(strs[0])\\n        for i in range(0, m):\\n            for j in range(0,n-1):\\n                if strs[j][i] > strs[j+1][i]:\\n                    count += 1\\n                    break\\n        return count"
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Why so many dislikes on the problem? Just transpose matrix and check each row for i+1-th element being greater or equal than i-th. Check my solution if don\\'t get the idea."
                    },
                    {
                        "username": "bharatjoshics",
                        "content": "Step 1. Initialize a counter to 0\\nStep 2. Start a loop from 0th index example \\'j\\'\\nStep 3. Start second loop inside first loop from 1st index example \\'i\\'\\nStep 4. Compare if [i][j]<[i-1][j]\\nStep 5. If yes then make your counter +1 and break \\nStep 6. At the end , return your counter"
                    },
                    {
                        "username": "Loreee",
                        "content": "If we had to delete the columns that are not sorted lexicographically, and not only show the number of those columns, what would we use? When we find a column that is not sorted, can we use memmove to move the content of each string after the index  of that column to the left with one letter? Is this a good idea? If it is can someone please show me how the arguments of memmove would look like for this? "
                    },
                    {
                        "username": "Siroj910",
                        "content": "There is a problem in expected: \\ninput: [\"cba\",\"daf\",\"ghi\"] -> in sorted it will be [\\'abc\\', \\'adf\\', \\'ghi\\'], \\nand result will be 2 because \"abc\" and \"daf\" is wrong, but expected 1, who can explain it? In my view my result is true"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# Intuition\\n- To be in lexicographic order, each character in the column should be equal to or greater than the corresponding character in the previous row.\\n- Therefore, we will iterate over the columns and for each column, we will iterate over the rows starting from index `1` (not zero, as we will compare the character to the character in the previous row). We will then increment the count of unsorted columns every time we observe a character smaller than the character in the previous row.\\n\\n---\\n\\n\\n# Approach\\n- Initialize the delete count to `0`.\\n- Get the number of rows (`r`) and columns (`c`).\\n- If the current element is lexicographically smaller than the previous element, increment the delete count and break out of the loop\\n\\n---\\n\\n\\n# Complexity\\n- Time Complexity\\n$$O(n*m)$$ \\n\\n- Space Complexity\\n$$O(1)$$\\n\\nRefer My Solution - [Java | Easy | 100% Fast Solution | Matrix | Pointers](https://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2994341/java-easy-100-fast-solution-matrix-pointers/)"
                    },
                    {
                        "username": "ckcjc",
                        "content": " ```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0; \\n        for(int i= 0; i < strs[0].length(); i++){\\n            for(int j = 0; j< strs.length - 1; j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "pratham95484",
                        "content": " `your inline code...your inline code...` \\nstatic public int minDeletionSize(String[] str) {\\n      \\n       int counts=0,countus=0;\\n       for(int i=0;i<str.length;i++)\\n       {    \\n           char[] a = str[i].toCharArray();\\n           int count=0;\\n           for(int j=0;j<a.length;j++)\\n           {\\n               for(int k=j+1;k<a.length;k++)\\n               {\\n                   int first=(int)a[j];\\n                   int second=(int)a[k];\\n                   if(first>second)\\n                   {\\n                       count++;\\n                   }\\n               }\\n           }\\n           if(count==a.length)\\n           {\\n               counts++;\\n           }\\n           \\n       }\\n       return counts;\\n    }\\n    public static void main(String [] args)\\n    {\\n String [] str = {\"cba\",\"daf\",\"ghi\"}; \\n    int result =Solution.minDeletionSize(str);\\n    System.out.println(result);\\n    }"
                    },
                    {
                        "username": "nxabdullah",
                        "content": "Hint: think of it as a 2D array (or a matrix) problem"
                    }
                ]
            },
            {
                "id": 1741273,
                "content": [
                    {
                        "username": "harshilnashier",
                        "content": "can it be solved with time complexity that is better than O(n^2)?"
                    },
                    {
                        "username": "ganesh254",
                        "content": "class Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        count = 0\\n        n = len(strs)\\n        m = len(strs[0])\\n        for i in range(0, m):\\n            for j in range(0,n-1):\\n                if strs[j][i] > strs[j+1][i]:\\n                    count += 1\\n                    break\\n        return count"
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Why so many dislikes on the problem? Just transpose matrix and check each row for i+1-th element being greater or equal than i-th. Check my solution if don\\'t get the idea."
                    },
                    {
                        "username": "bharatjoshics",
                        "content": "Step 1. Initialize a counter to 0\\nStep 2. Start a loop from 0th index example \\'j\\'\\nStep 3. Start second loop inside first loop from 1st index example \\'i\\'\\nStep 4. Compare if [i][j]<[i-1][j]\\nStep 5. If yes then make your counter +1 and break \\nStep 6. At the end , return your counter"
                    },
                    {
                        "username": "Loreee",
                        "content": "If we had to delete the columns that are not sorted lexicographically, and not only show the number of those columns, what would we use? When we find a column that is not sorted, can we use memmove to move the content of each string after the index  of that column to the left with one letter? Is this a good idea? If it is can someone please show me how the arguments of memmove would look like for this? "
                    },
                    {
                        "username": "Siroj910",
                        "content": "There is a problem in expected: \\ninput: [\"cba\",\"daf\",\"ghi\"] -> in sorted it will be [\\'abc\\', \\'adf\\', \\'ghi\\'], \\nand result will be 2 because \"abc\" and \"daf\" is wrong, but expected 1, who can explain it? In my view my result is true"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# Intuition\\n- To be in lexicographic order, each character in the column should be equal to or greater than the corresponding character in the previous row.\\n- Therefore, we will iterate over the columns and for each column, we will iterate over the rows starting from index `1` (not zero, as we will compare the character to the character in the previous row). We will then increment the count of unsorted columns every time we observe a character smaller than the character in the previous row.\\n\\n---\\n\\n\\n# Approach\\n- Initialize the delete count to `0`.\\n- Get the number of rows (`r`) and columns (`c`).\\n- If the current element is lexicographically smaller than the previous element, increment the delete count and break out of the loop\\n\\n---\\n\\n\\n# Complexity\\n- Time Complexity\\n$$O(n*m)$$ \\n\\n- Space Complexity\\n$$O(1)$$\\n\\nRefer My Solution - [Java | Easy | 100% Fast Solution | Matrix | Pointers](https://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2994341/java-easy-100-fast-solution-matrix-pointers/)"
                    },
                    {
                        "username": "ckcjc",
                        "content": " ```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0; \\n        for(int i= 0; i < strs[0].length(); i++){\\n            for(int j = 0; j< strs.length - 1; j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "pratham95484",
                        "content": " `your inline code...your inline code...` \\nstatic public int minDeletionSize(String[] str) {\\n      \\n       int counts=0,countus=0;\\n       for(int i=0;i<str.length;i++)\\n       {    \\n           char[] a = str[i].toCharArray();\\n           int count=0;\\n           for(int j=0;j<a.length;j++)\\n           {\\n               for(int k=j+1;k<a.length;k++)\\n               {\\n                   int first=(int)a[j];\\n                   int second=(int)a[k];\\n                   if(first>second)\\n                   {\\n                       count++;\\n                   }\\n               }\\n           }\\n           if(count==a.length)\\n           {\\n               counts++;\\n           }\\n           \\n       }\\n       return counts;\\n    }\\n    public static void main(String [] args)\\n    {\\n String [] str = {\"cba\",\"daf\",\"ghi\"}; \\n    int result =Solution.minDeletionSize(str);\\n    System.out.println(result);\\n    }"
                    },
                    {
                        "username": "nxabdullah",
                        "content": "Hint: think of it as a 2D array (or a matrix) problem"
                    }
                ]
            },
            {
                "id": 1740304,
                "content": [
                    {
                        "username": "harshilnashier",
                        "content": "can it be solved with time complexity that is better than O(n^2)?"
                    },
                    {
                        "username": "ganesh254",
                        "content": "class Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        count = 0\\n        n = len(strs)\\n        m = len(strs[0])\\n        for i in range(0, m):\\n            for j in range(0,n-1):\\n                if strs[j][i] > strs[j+1][i]:\\n                    count += 1\\n                    break\\n        return count"
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Why so many dislikes on the problem? Just transpose matrix and check each row for i+1-th element being greater or equal than i-th. Check my solution if don\\'t get the idea."
                    },
                    {
                        "username": "bharatjoshics",
                        "content": "Step 1. Initialize a counter to 0\\nStep 2. Start a loop from 0th index example \\'j\\'\\nStep 3. Start second loop inside first loop from 1st index example \\'i\\'\\nStep 4. Compare if [i][j]<[i-1][j]\\nStep 5. If yes then make your counter +1 and break \\nStep 6. At the end , return your counter"
                    },
                    {
                        "username": "Loreee",
                        "content": "If we had to delete the columns that are not sorted lexicographically, and not only show the number of those columns, what would we use? When we find a column that is not sorted, can we use memmove to move the content of each string after the index  of that column to the left with one letter? Is this a good idea? If it is can someone please show me how the arguments of memmove would look like for this? "
                    },
                    {
                        "username": "Siroj910",
                        "content": "There is a problem in expected: \\ninput: [\"cba\",\"daf\",\"ghi\"] -> in sorted it will be [\\'abc\\', \\'adf\\', \\'ghi\\'], \\nand result will be 2 because \"abc\" and \"daf\" is wrong, but expected 1, who can explain it? In my view my result is true"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# Intuition\\n- To be in lexicographic order, each character in the column should be equal to or greater than the corresponding character in the previous row.\\n- Therefore, we will iterate over the columns and for each column, we will iterate over the rows starting from index `1` (not zero, as we will compare the character to the character in the previous row). We will then increment the count of unsorted columns every time we observe a character smaller than the character in the previous row.\\n\\n---\\n\\n\\n# Approach\\n- Initialize the delete count to `0`.\\n- Get the number of rows (`r`) and columns (`c`).\\n- If the current element is lexicographically smaller than the previous element, increment the delete count and break out of the loop\\n\\n---\\n\\n\\n# Complexity\\n- Time Complexity\\n$$O(n*m)$$ \\n\\n- Space Complexity\\n$$O(1)$$\\n\\nRefer My Solution - [Java | Easy | 100% Fast Solution | Matrix | Pointers](https://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2994341/java-easy-100-fast-solution-matrix-pointers/)"
                    },
                    {
                        "username": "ckcjc",
                        "content": " ```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0; \\n        for(int i= 0; i < strs[0].length(); i++){\\n            for(int j = 0; j< strs.length - 1; j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "pratham95484",
                        "content": " `your inline code...your inline code...` \\nstatic public int minDeletionSize(String[] str) {\\n      \\n       int counts=0,countus=0;\\n       for(int i=0;i<str.length;i++)\\n       {    \\n           char[] a = str[i].toCharArray();\\n           int count=0;\\n           for(int j=0;j<a.length;j++)\\n           {\\n               for(int k=j+1;k<a.length;k++)\\n               {\\n                   int first=(int)a[j];\\n                   int second=(int)a[k];\\n                   if(first>second)\\n                   {\\n                       count++;\\n                   }\\n               }\\n           }\\n           if(count==a.length)\\n           {\\n               counts++;\\n           }\\n           \\n       }\\n       return counts;\\n    }\\n    public static void main(String [] args)\\n    {\\n String [] str = {\"cba\",\"daf\",\"ghi\"}; \\n    int result =Solution.minDeletionSize(str);\\n    System.out.println(result);\\n    }"
                    },
                    {
                        "username": "nxabdullah",
                        "content": "Hint: think of it as a 2D array (or a matrix) problem"
                    }
                ]
            },
            {
                "id": 1740299,
                "content": [
                    {
                        "username": "harshilnashier",
                        "content": "can it be solved with time complexity that is better than O(n^2)?"
                    },
                    {
                        "username": "ganesh254",
                        "content": "class Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        count = 0\\n        n = len(strs)\\n        m = len(strs[0])\\n        for i in range(0, m):\\n            for j in range(0,n-1):\\n                if strs[j][i] > strs[j+1][i]:\\n                    count += 1\\n                    break\\n        return count"
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Why so many dislikes on the problem? Just transpose matrix and check each row for i+1-th element being greater or equal than i-th. Check my solution if don\\'t get the idea."
                    },
                    {
                        "username": "bharatjoshics",
                        "content": "Step 1. Initialize a counter to 0\\nStep 2. Start a loop from 0th index example \\'j\\'\\nStep 3. Start second loop inside first loop from 1st index example \\'i\\'\\nStep 4. Compare if [i][j]<[i-1][j]\\nStep 5. If yes then make your counter +1 and break \\nStep 6. At the end , return your counter"
                    },
                    {
                        "username": "Loreee",
                        "content": "If we had to delete the columns that are not sorted lexicographically, and not only show the number of those columns, what would we use? When we find a column that is not sorted, can we use memmove to move the content of each string after the index  of that column to the left with one letter? Is this a good idea? If it is can someone please show me how the arguments of memmove would look like for this? "
                    },
                    {
                        "username": "Siroj910",
                        "content": "There is a problem in expected: \\ninput: [\"cba\",\"daf\",\"ghi\"] -> in sorted it will be [\\'abc\\', \\'adf\\', \\'ghi\\'], \\nand result will be 2 because \"abc\" and \"daf\" is wrong, but expected 1, who can explain it? In my view my result is true"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# Intuition\\n- To be in lexicographic order, each character in the column should be equal to or greater than the corresponding character in the previous row.\\n- Therefore, we will iterate over the columns and for each column, we will iterate over the rows starting from index `1` (not zero, as we will compare the character to the character in the previous row). We will then increment the count of unsorted columns every time we observe a character smaller than the character in the previous row.\\n\\n---\\n\\n\\n# Approach\\n- Initialize the delete count to `0`.\\n- Get the number of rows (`r`) and columns (`c`).\\n- If the current element is lexicographically smaller than the previous element, increment the delete count and break out of the loop\\n\\n---\\n\\n\\n# Complexity\\n- Time Complexity\\n$$O(n*m)$$ \\n\\n- Space Complexity\\n$$O(1)$$\\n\\nRefer My Solution - [Java | Easy | 100% Fast Solution | Matrix | Pointers](https://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2994341/java-easy-100-fast-solution-matrix-pointers/)"
                    },
                    {
                        "username": "ckcjc",
                        "content": " ```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0; \\n        for(int i= 0; i < strs[0].length(); i++){\\n            for(int j = 0; j< strs.length - 1; j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "pratham95484",
                        "content": " `your inline code...your inline code...` \\nstatic public int minDeletionSize(String[] str) {\\n      \\n       int counts=0,countus=0;\\n       for(int i=0;i<str.length;i++)\\n       {    \\n           char[] a = str[i].toCharArray();\\n           int count=0;\\n           for(int j=0;j<a.length;j++)\\n           {\\n               for(int k=j+1;k<a.length;k++)\\n               {\\n                   int first=(int)a[j];\\n                   int second=(int)a[k];\\n                   if(first>second)\\n                   {\\n                       count++;\\n                   }\\n               }\\n           }\\n           if(count==a.length)\\n           {\\n               counts++;\\n           }\\n           \\n       }\\n       return counts;\\n    }\\n    public static void main(String [] args)\\n    {\\n String [] str = {\"cba\",\"daf\",\"ghi\"}; \\n    int result =Solution.minDeletionSize(str);\\n    System.out.println(result);\\n    }"
                    },
                    {
                        "username": "nxabdullah",
                        "content": "Hint: think of it as a 2D array (or a matrix) problem"
                    }
                ]
            },
            {
                "id": 1740253,
                "content": [
                    {
                        "username": "harshilnashier",
                        "content": "can it be solved with time complexity that is better than O(n^2)?"
                    },
                    {
                        "username": "ganesh254",
                        "content": "class Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        count = 0\\n        n = len(strs)\\n        m = len(strs[0])\\n        for i in range(0, m):\\n            for j in range(0,n-1):\\n                if strs[j][i] > strs[j+1][i]:\\n                    count += 1\\n                    break\\n        return count"
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Why so many dislikes on the problem? Just transpose matrix and check each row for i+1-th element being greater or equal than i-th. Check my solution if don\\'t get the idea."
                    },
                    {
                        "username": "bharatjoshics",
                        "content": "Step 1. Initialize a counter to 0\\nStep 2. Start a loop from 0th index example \\'j\\'\\nStep 3. Start second loop inside first loop from 1st index example \\'i\\'\\nStep 4. Compare if [i][j]<[i-1][j]\\nStep 5. If yes then make your counter +1 and break \\nStep 6. At the end , return your counter"
                    },
                    {
                        "username": "Loreee",
                        "content": "If we had to delete the columns that are not sorted lexicographically, and not only show the number of those columns, what would we use? When we find a column that is not sorted, can we use memmove to move the content of each string after the index  of that column to the left with one letter? Is this a good idea? If it is can someone please show me how the arguments of memmove would look like for this? "
                    },
                    {
                        "username": "Siroj910",
                        "content": "There is a problem in expected: \\ninput: [\"cba\",\"daf\",\"ghi\"] -> in sorted it will be [\\'abc\\', \\'adf\\', \\'ghi\\'], \\nand result will be 2 because \"abc\" and \"daf\" is wrong, but expected 1, who can explain it? In my view my result is true"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# Intuition\\n- To be in lexicographic order, each character in the column should be equal to or greater than the corresponding character in the previous row.\\n- Therefore, we will iterate over the columns and for each column, we will iterate over the rows starting from index `1` (not zero, as we will compare the character to the character in the previous row). We will then increment the count of unsorted columns every time we observe a character smaller than the character in the previous row.\\n\\n---\\n\\n\\n# Approach\\n- Initialize the delete count to `0`.\\n- Get the number of rows (`r`) and columns (`c`).\\n- If the current element is lexicographically smaller than the previous element, increment the delete count and break out of the loop\\n\\n---\\n\\n\\n# Complexity\\n- Time Complexity\\n$$O(n*m)$$ \\n\\n- Space Complexity\\n$$O(1)$$\\n\\nRefer My Solution - [Java | Easy | 100% Fast Solution | Matrix | Pointers](https://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2994341/java-easy-100-fast-solution-matrix-pointers/)"
                    },
                    {
                        "username": "ckcjc",
                        "content": " ```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0; \\n        for(int i= 0; i < strs[0].length(); i++){\\n            for(int j = 0; j< strs.length - 1; j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "pratham95484",
                        "content": " `your inline code...your inline code...` \\nstatic public int minDeletionSize(String[] str) {\\n      \\n       int counts=0,countus=0;\\n       for(int i=0;i<str.length;i++)\\n       {    \\n           char[] a = str[i].toCharArray();\\n           int count=0;\\n           for(int j=0;j<a.length;j++)\\n           {\\n               for(int k=j+1;k<a.length;k++)\\n               {\\n                   int first=(int)a[j];\\n                   int second=(int)a[k];\\n                   if(first>second)\\n                   {\\n                       count++;\\n                   }\\n               }\\n           }\\n           if(count==a.length)\\n           {\\n               counts++;\\n           }\\n           \\n       }\\n       return counts;\\n    }\\n    public static void main(String [] args)\\n    {\\n String [] str = {\"cba\",\"daf\",\"ghi\"}; \\n    int result =Solution.minDeletionSize(str);\\n    System.out.println(result);\\n    }"
                    },
                    {
                        "username": "nxabdullah",
                        "content": "Hint: think of it as a 2D array (or a matrix) problem"
                    }
                ]
            },
            {
                "id": 1740250,
                "content": [
                    {
                        "username": "harshilnashier",
                        "content": "can it be solved with time complexity that is better than O(n^2)?"
                    },
                    {
                        "username": "ganesh254",
                        "content": "class Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        count = 0\\n        n = len(strs)\\n        m = len(strs[0])\\n        for i in range(0, m):\\n            for j in range(0,n-1):\\n                if strs[j][i] > strs[j+1][i]:\\n                    count += 1\\n                    break\\n        return count"
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Why so many dislikes on the problem? Just transpose matrix and check each row for i+1-th element being greater or equal than i-th. Check my solution if don\\'t get the idea."
                    },
                    {
                        "username": "bharatjoshics",
                        "content": "Step 1. Initialize a counter to 0\\nStep 2. Start a loop from 0th index example \\'j\\'\\nStep 3. Start second loop inside first loop from 1st index example \\'i\\'\\nStep 4. Compare if [i][j]<[i-1][j]\\nStep 5. If yes then make your counter +1 and break \\nStep 6. At the end , return your counter"
                    },
                    {
                        "username": "Loreee",
                        "content": "If we had to delete the columns that are not sorted lexicographically, and not only show the number of those columns, what would we use? When we find a column that is not sorted, can we use memmove to move the content of each string after the index  of that column to the left with one letter? Is this a good idea? If it is can someone please show me how the arguments of memmove would look like for this? "
                    },
                    {
                        "username": "Siroj910",
                        "content": "There is a problem in expected: \\ninput: [\"cba\",\"daf\",\"ghi\"] -> in sorted it will be [\\'abc\\', \\'adf\\', \\'ghi\\'], \\nand result will be 2 because \"abc\" and \"daf\" is wrong, but expected 1, who can explain it? In my view my result is true"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# Intuition\\n- To be in lexicographic order, each character in the column should be equal to or greater than the corresponding character in the previous row.\\n- Therefore, we will iterate over the columns and for each column, we will iterate over the rows starting from index `1` (not zero, as we will compare the character to the character in the previous row). We will then increment the count of unsorted columns every time we observe a character smaller than the character in the previous row.\\n\\n---\\n\\n\\n# Approach\\n- Initialize the delete count to `0`.\\n- Get the number of rows (`r`) and columns (`c`).\\n- If the current element is lexicographically smaller than the previous element, increment the delete count and break out of the loop\\n\\n---\\n\\n\\n# Complexity\\n- Time Complexity\\n$$O(n*m)$$ \\n\\n- Space Complexity\\n$$O(1)$$\\n\\nRefer My Solution - [Java | Easy | 100% Fast Solution | Matrix | Pointers](https://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2994341/java-easy-100-fast-solution-matrix-pointers/)"
                    },
                    {
                        "username": "ckcjc",
                        "content": " ```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0; \\n        for(int i= 0; i < strs[0].length(); i++){\\n            for(int j = 0; j< strs.length - 1; j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "pratham95484",
                        "content": " `your inline code...your inline code...` \\nstatic public int minDeletionSize(String[] str) {\\n      \\n       int counts=0,countus=0;\\n       for(int i=0;i<str.length;i++)\\n       {    \\n           char[] a = str[i].toCharArray();\\n           int count=0;\\n           for(int j=0;j<a.length;j++)\\n           {\\n               for(int k=j+1;k<a.length;k++)\\n               {\\n                   int first=(int)a[j];\\n                   int second=(int)a[k];\\n                   if(first>second)\\n                   {\\n                       count++;\\n                   }\\n               }\\n           }\\n           if(count==a.length)\\n           {\\n               counts++;\\n           }\\n           \\n       }\\n       return counts;\\n    }\\n    public static void main(String [] args)\\n    {\\n String [] str = {\"cba\",\"daf\",\"ghi\"}; \\n    int result =Solution.minDeletionSize(str);\\n    System.out.println(result);\\n    }"
                    },
                    {
                        "username": "nxabdullah",
                        "content": "Hint: think of it as a 2D array (or a matrix) problem"
                    }
                ]
            },
            {
                "id": 1740209,
                "content": [
                    {
                        "username": "harshilnashier",
                        "content": "can it be solved with time complexity that is better than O(n^2)?"
                    },
                    {
                        "username": "ganesh254",
                        "content": "class Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        count = 0\\n        n = len(strs)\\n        m = len(strs[0])\\n        for i in range(0, m):\\n            for j in range(0,n-1):\\n                if strs[j][i] > strs[j+1][i]:\\n                    count += 1\\n                    break\\n        return count"
                    },
                    {
                        "username": "tradingpractice2122",
                        "content": "Why so many dislikes on the problem? Just transpose matrix and check each row for i+1-th element being greater or equal than i-th. Check my solution if don\\'t get the idea."
                    },
                    {
                        "username": "bharatjoshics",
                        "content": "Step 1. Initialize a counter to 0\\nStep 2. Start a loop from 0th index example \\'j\\'\\nStep 3. Start second loop inside first loop from 1st index example \\'i\\'\\nStep 4. Compare if [i][j]<[i-1][j]\\nStep 5. If yes then make your counter +1 and break \\nStep 6. At the end , return your counter"
                    },
                    {
                        "username": "Loreee",
                        "content": "If we had to delete the columns that are not sorted lexicographically, and not only show the number of those columns, what would we use? When we find a column that is not sorted, can we use memmove to move the content of each string after the index  of that column to the left with one letter? Is this a good idea? If it is can someone please show me how the arguments of memmove would look like for this? "
                    },
                    {
                        "username": "Siroj910",
                        "content": "There is a problem in expected: \\ninput: [\"cba\",\"daf\",\"ghi\"] -> in sorted it will be [\\'abc\\', \\'adf\\', \\'ghi\\'], \\nand result will be 2 because \"abc\" and \"daf\" is wrong, but expected 1, who can explain it? In my view my result is true"
                    },
                    {
                        "username": "deleted_user",
                        "content": "# Intuition\\n- To be in lexicographic order, each character in the column should be equal to or greater than the corresponding character in the previous row.\\n- Therefore, we will iterate over the columns and for each column, we will iterate over the rows starting from index `1` (not zero, as we will compare the character to the character in the previous row). We will then increment the count of unsorted columns every time we observe a character smaller than the character in the previous row.\\n\\n---\\n\\n\\n# Approach\\n- Initialize the delete count to `0`.\\n- Get the number of rows (`r`) and columns (`c`).\\n- If the current element is lexicographically smaller than the previous element, increment the delete count and break out of the loop\\n\\n---\\n\\n\\n# Complexity\\n- Time Complexity\\n$$O(n*m)$$ \\n\\n- Space Complexity\\n$$O(1)$$\\n\\nRefer My Solution - [Java | Easy | 100% Fast Solution | Matrix | Pointers](https://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2994341/java-easy-100-fast-solution-matrix-pointers/)"
                    },
                    {
                        "username": "ckcjc",
                        "content": " ```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0; \\n        for(int i= 0; i < strs[0].length(); i++){\\n            for(int j = 0; j< strs.length - 1; j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n"
                    },
                    {
                        "username": "pratham95484",
                        "content": " `your inline code...your inline code...` \\nstatic public int minDeletionSize(String[] str) {\\n      \\n       int counts=0,countus=0;\\n       for(int i=0;i<str.length;i++)\\n       {    \\n           char[] a = str[i].toCharArray();\\n           int count=0;\\n           for(int j=0;j<a.length;j++)\\n           {\\n               for(int k=j+1;k<a.length;k++)\\n               {\\n                   int first=(int)a[j];\\n                   int second=(int)a[k];\\n                   if(first>second)\\n                   {\\n                       count++;\\n                   }\\n               }\\n           }\\n           if(count==a.length)\\n           {\\n               counts++;\\n           }\\n           \\n       }\\n       return counts;\\n    }\\n    public static void main(String [] args)\\n    {\\n String [] str = {\"cba\",\"daf\",\"ghi\"}; \\n    int result =Solution.minDeletionSize(str);\\n    System.out.println(result);\\n    }"
                    },
                    {
                        "username": "nxabdullah",
                        "content": "Hint: think of it as a 2D array (or a matrix) problem"
                    }
                ]
            },
            {
                "id": 1740199,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "    // Variable to store the count of columns to be deleted.\\n        int answer = 0;\\n        // Iterate over each index in the string.\\n        for (int row = 1; row < strs.length; row++){\\n       // for (int col = 0; col < K; col++) {\\n            // Iterate over the strings.\\n             for (int col = 0; col < K; col++) {\\n          //  for (int row = 1; row < strs.length; row++) {\\n                // Characters should be in increasing order, \\n                // If not, increment the counter.\\n                if (strs[row].charAt(col) < strs[row - 1].charAt(col)) {\\n                    answer++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n\\n\\n\\nWhy my this answer is not working for test"
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I think you have the columns and rows confused. The nested for loop should be the rows, since you want to be going down each column before moving to the next one."
                    },
                    {
                        "username": "amanraaj",
                        "content": "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        return IntStream.range(0, strs[0].length())\\n                .filter(i -> IntStream.range(0, strs.length - 1)\\n                        .anyMatch(j -> strs[j].charAt(i) > strs[j + 1].charAt(i)))\\n                .toArray().length;\\n    }\\n}"
                    },
                    {
                        "username": "whiteknight16",
                        "content": "Look vertically and not horizontally\\n"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "C++ solution \\n\\nint minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int m=strs[0].size();\\n        int cnt=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n-1; j++){\\n                 if(strs[j][i] > strs[j+1][i]){\\n                     cnt++;\\n                     break;\\n                 }\\n                 \\n            }\\n        }\\n        return cnt;\\n    }"
                    },
                    {
                        "username": "HARSHIDAS_21",
                        "content": "The question says to detect the non lexiographical order count \\nSo \\nStep1 =Initialize The Count By 0.\\nStep2=Count The Size Of The Word In The Given Array, If The Size Of The word is not same then the count will increment.\\nStep3= Count the size of the array.\\nStep4= Now compare the column and hence, if not in the lexiographical order then increment count by 1.\\nStep5= Return the value at last.\\n\\nCode=\\n//Initialization of count by 0.\\nint cnt=0;\\n//Count the size of word in the array\\nint wordsize=strs[0].length();\\n//Count the size of the array \\nint size=strs.size();\\n//Now compare the lexiographical order \\nfor   (int i=0;i<wordsize;i++)\\n{\\nfor   (int j=0;j<size;j++)\\n{\\nif   (strs[j][i]>strs[j+1][i])\\n{\\n//Incrementing Count\\ncnt++;\\nbreak;\\n}\\n}\\n}\\n//Return the final value of count.\\nreturn cnt;"
                    },
                    {
                        "username": "folexz",
                        "content": "Swift submission fails at test cases 76-79, due to time limit while totally same python submission passes with no problem. Plz fix it"
                    },
                    {
                        "username": "OptimusHP",
                        "content": "Can anyone think of possible follow up to this question?"
                    },
                    {
                        "username": "farddinkhan733",
                        "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int ans=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}"
                    },
                    {
                        "username": "anubhavraj554",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int k= strs[0].size();\\n        int count=0,flag;\\n        for(int col=0; col<k; col++){\\n            for(int row=1; row<strs.size(); row++){\\n                flag=0;\\n                if(strs[row-1][col] > strs[row][col])\\n                    flag =1;\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWHY THIS CODE IS NOT A SOLUTION ?"
                    },
                    {
                        "username": "user7114ny",
                        "content": "meow "
                    }
                ]
            },
            {
                "id": 1740188,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "    // Variable to store the count of columns to be deleted.\\n        int answer = 0;\\n        // Iterate over each index in the string.\\n        for (int row = 1; row < strs.length; row++){\\n       // for (int col = 0; col < K; col++) {\\n            // Iterate over the strings.\\n             for (int col = 0; col < K; col++) {\\n          //  for (int row = 1; row < strs.length; row++) {\\n                // Characters should be in increasing order, \\n                // If not, increment the counter.\\n                if (strs[row].charAt(col) < strs[row - 1].charAt(col)) {\\n                    answer++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n\\n\\n\\nWhy my this answer is not working for test"
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I think you have the columns and rows confused. The nested for loop should be the rows, since you want to be going down each column before moving to the next one."
                    },
                    {
                        "username": "amanraaj",
                        "content": "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        return IntStream.range(0, strs[0].length())\\n                .filter(i -> IntStream.range(0, strs.length - 1)\\n                        .anyMatch(j -> strs[j].charAt(i) > strs[j + 1].charAt(i)))\\n                .toArray().length;\\n    }\\n}"
                    },
                    {
                        "username": "whiteknight16",
                        "content": "Look vertically and not horizontally\\n"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "C++ solution \\n\\nint minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int m=strs[0].size();\\n        int cnt=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n-1; j++){\\n                 if(strs[j][i] > strs[j+1][i]){\\n                     cnt++;\\n                     break;\\n                 }\\n                 \\n            }\\n        }\\n        return cnt;\\n    }"
                    },
                    {
                        "username": "HARSHIDAS_21",
                        "content": "The question says to detect the non lexiographical order count \\nSo \\nStep1 =Initialize The Count By 0.\\nStep2=Count The Size Of The Word In The Given Array, If The Size Of The word is not same then the count will increment.\\nStep3= Count the size of the array.\\nStep4= Now compare the column and hence, if not in the lexiographical order then increment count by 1.\\nStep5= Return the value at last.\\n\\nCode=\\n//Initialization of count by 0.\\nint cnt=0;\\n//Count the size of word in the array\\nint wordsize=strs[0].length();\\n//Count the size of the array \\nint size=strs.size();\\n//Now compare the lexiographical order \\nfor   (int i=0;i<wordsize;i++)\\n{\\nfor   (int j=0;j<size;j++)\\n{\\nif   (strs[j][i]>strs[j+1][i])\\n{\\n//Incrementing Count\\ncnt++;\\nbreak;\\n}\\n}\\n}\\n//Return the final value of count.\\nreturn cnt;"
                    },
                    {
                        "username": "folexz",
                        "content": "Swift submission fails at test cases 76-79, due to time limit while totally same python submission passes with no problem. Plz fix it"
                    },
                    {
                        "username": "OptimusHP",
                        "content": "Can anyone think of possible follow up to this question?"
                    },
                    {
                        "username": "farddinkhan733",
                        "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int ans=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}"
                    },
                    {
                        "username": "anubhavraj554",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int k= strs[0].size();\\n        int count=0,flag;\\n        for(int col=0; col<k; col++){\\n            for(int row=1; row<strs.size(); row++){\\n                flag=0;\\n                if(strs[row-1][col] > strs[row][col])\\n                    flag =1;\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWHY THIS CODE IS NOT A SOLUTION ?"
                    },
                    {
                        "username": "user7114ny",
                        "content": "meow "
                    }
                ]
            },
            {
                "id": 1740166,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "    // Variable to store the count of columns to be deleted.\\n        int answer = 0;\\n        // Iterate over each index in the string.\\n        for (int row = 1; row < strs.length; row++){\\n       // for (int col = 0; col < K; col++) {\\n            // Iterate over the strings.\\n             for (int col = 0; col < K; col++) {\\n          //  for (int row = 1; row < strs.length; row++) {\\n                // Characters should be in increasing order, \\n                // If not, increment the counter.\\n                if (strs[row].charAt(col) < strs[row - 1].charAt(col)) {\\n                    answer++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n\\n\\n\\nWhy my this answer is not working for test"
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I think you have the columns and rows confused. The nested for loop should be the rows, since you want to be going down each column before moving to the next one."
                    },
                    {
                        "username": "amanraaj",
                        "content": "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        return IntStream.range(0, strs[0].length())\\n                .filter(i -> IntStream.range(0, strs.length - 1)\\n                        .anyMatch(j -> strs[j].charAt(i) > strs[j + 1].charAt(i)))\\n                .toArray().length;\\n    }\\n}"
                    },
                    {
                        "username": "whiteknight16",
                        "content": "Look vertically and not horizontally\\n"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "C++ solution \\n\\nint minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int m=strs[0].size();\\n        int cnt=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n-1; j++){\\n                 if(strs[j][i] > strs[j+1][i]){\\n                     cnt++;\\n                     break;\\n                 }\\n                 \\n            }\\n        }\\n        return cnt;\\n    }"
                    },
                    {
                        "username": "HARSHIDAS_21",
                        "content": "The question says to detect the non lexiographical order count \\nSo \\nStep1 =Initialize The Count By 0.\\nStep2=Count The Size Of The Word In The Given Array, If The Size Of The word is not same then the count will increment.\\nStep3= Count the size of the array.\\nStep4= Now compare the column and hence, if not in the lexiographical order then increment count by 1.\\nStep5= Return the value at last.\\n\\nCode=\\n//Initialization of count by 0.\\nint cnt=0;\\n//Count the size of word in the array\\nint wordsize=strs[0].length();\\n//Count the size of the array \\nint size=strs.size();\\n//Now compare the lexiographical order \\nfor   (int i=0;i<wordsize;i++)\\n{\\nfor   (int j=0;j<size;j++)\\n{\\nif   (strs[j][i]>strs[j+1][i])\\n{\\n//Incrementing Count\\ncnt++;\\nbreak;\\n}\\n}\\n}\\n//Return the final value of count.\\nreturn cnt;"
                    },
                    {
                        "username": "folexz",
                        "content": "Swift submission fails at test cases 76-79, due to time limit while totally same python submission passes with no problem. Plz fix it"
                    },
                    {
                        "username": "OptimusHP",
                        "content": "Can anyone think of possible follow up to this question?"
                    },
                    {
                        "username": "farddinkhan733",
                        "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int ans=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}"
                    },
                    {
                        "username": "anubhavraj554",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int k= strs[0].size();\\n        int count=0,flag;\\n        for(int col=0; col<k; col++){\\n            for(int row=1; row<strs.size(); row++){\\n                flag=0;\\n                if(strs[row-1][col] > strs[row][col])\\n                    flag =1;\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWHY THIS CODE IS NOT A SOLUTION ?"
                    },
                    {
                        "username": "user7114ny",
                        "content": "meow "
                    }
                ]
            },
            {
                "id": 1740061,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "    // Variable to store the count of columns to be deleted.\\n        int answer = 0;\\n        // Iterate over each index in the string.\\n        for (int row = 1; row < strs.length; row++){\\n       // for (int col = 0; col < K; col++) {\\n            // Iterate over the strings.\\n             for (int col = 0; col < K; col++) {\\n          //  for (int row = 1; row < strs.length; row++) {\\n                // Characters should be in increasing order, \\n                // If not, increment the counter.\\n                if (strs[row].charAt(col) < strs[row - 1].charAt(col)) {\\n                    answer++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n\\n\\n\\nWhy my this answer is not working for test"
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I think you have the columns and rows confused. The nested for loop should be the rows, since you want to be going down each column before moving to the next one."
                    },
                    {
                        "username": "amanraaj",
                        "content": "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        return IntStream.range(0, strs[0].length())\\n                .filter(i -> IntStream.range(0, strs.length - 1)\\n                        .anyMatch(j -> strs[j].charAt(i) > strs[j + 1].charAt(i)))\\n                .toArray().length;\\n    }\\n}"
                    },
                    {
                        "username": "whiteknight16",
                        "content": "Look vertically and not horizontally\\n"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "C++ solution \\n\\nint minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int m=strs[0].size();\\n        int cnt=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n-1; j++){\\n                 if(strs[j][i] > strs[j+1][i]){\\n                     cnt++;\\n                     break;\\n                 }\\n                 \\n            }\\n        }\\n        return cnt;\\n    }"
                    },
                    {
                        "username": "HARSHIDAS_21",
                        "content": "The question says to detect the non lexiographical order count \\nSo \\nStep1 =Initialize The Count By 0.\\nStep2=Count The Size Of The Word In The Given Array, If The Size Of The word is not same then the count will increment.\\nStep3= Count the size of the array.\\nStep4= Now compare the column and hence, if not in the lexiographical order then increment count by 1.\\nStep5= Return the value at last.\\n\\nCode=\\n//Initialization of count by 0.\\nint cnt=0;\\n//Count the size of word in the array\\nint wordsize=strs[0].length();\\n//Count the size of the array \\nint size=strs.size();\\n//Now compare the lexiographical order \\nfor   (int i=0;i<wordsize;i++)\\n{\\nfor   (int j=0;j<size;j++)\\n{\\nif   (strs[j][i]>strs[j+1][i])\\n{\\n//Incrementing Count\\ncnt++;\\nbreak;\\n}\\n}\\n}\\n//Return the final value of count.\\nreturn cnt;"
                    },
                    {
                        "username": "folexz",
                        "content": "Swift submission fails at test cases 76-79, due to time limit while totally same python submission passes with no problem. Plz fix it"
                    },
                    {
                        "username": "OptimusHP",
                        "content": "Can anyone think of possible follow up to this question?"
                    },
                    {
                        "username": "farddinkhan733",
                        "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int ans=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}"
                    },
                    {
                        "username": "anubhavraj554",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int k= strs[0].size();\\n        int count=0,flag;\\n        for(int col=0; col<k; col++){\\n            for(int row=1; row<strs.size(); row++){\\n                flag=0;\\n                if(strs[row-1][col] > strs[row][col])\\n                    flag =1;\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWHY THIS CODE IS NOT A SOLUTION ?"
                    },
                    {
                        "username": "user7114ny",
                        "content": "meow "
                    }
                ]
            },
            {
                "id": 1740043,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "    // Variable to store the count of columns to be deleted.\\n        int answer = 0;\\n        // Iterate over each index in the string.\\n        for (int row = 1; row < strs.length; row++){\\n       // for (int col = 0; col < K; col++) {\\n            // Iterate over the strings.\\n             for (int col = 0; col < K; col++) {\\n          //  for (int row = 1; row < strs.length; row++) {\\n                // Characters should be in increasing order, \\n                // If not, increment the counter.\\n                if (strs[row].charAt(col) < strs[row - 1].charAt(col)) {\\n                    answer++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n\\n\\n\\nWhy my this answer is not working for test"
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I think you have the columns and rows confused. The nested for loop should be the rows, since you want to be going down each column before moving to the next one."
                    },
                    {
                        "username": "amanraaj",
                        "content": "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        return IntStream.range(0, strs[0].length())\\n                .filter(i -> IntStream.range(0, strs.length - 1)\\n                        .anyMatch(j -> strs[j].charAt(i) > strs[j + 1].charAt(i)))\\n                .toArray().length;\\n    }\\n}"
                    },
                    {
                        "username": "whiteknight16",
                        "content": "Look vertically and not horizontally\\n"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "C++ solution \\n\\nint minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int m=strs[0].size();\\n        int cnt=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n-1; j++){\\n                 if(strs[j][i] > strs[j+1][i]){\\n                     cnt++;\\n                     break;\\n                 }\\n                 \\n            }\\n        }\\n        return cnt;\\n    }"
                    },
                    {
                        "username": "HARSHIDAS_21",
                        "content": "The question says to detect the non lexiographical order count \\nSo \\nStep1 =Initialize The Count By 0.\\nStep2=Count The Size Of The Word In The Given Array, If The Size Of The word is not same then the count will increment.\\nStep3= Count the size of the array.\\nStep4= Now compare the column and hence, if not in the lexiographical order then increment count by 1.\\nStep5= Return the value at last.\\n\\nCode=\\n//Initialization of count by 0.\\nint cnt=0;\\n//Count the size of word in the array\\nint wordsize=strs[0].length();\\n//Count the size of the array \\nint size=strs.size();\\n//Now compare the lexiographical order \\nfor   (int i=0;i<wordsize;i++)\\n{\\nfor   (int j=0;j<size;j++)\\n{\\nif   (strs[j][i]>strs[j+1][i])\\n{\\n//Incrementing Count\\ncnt++;\\nbreak;\\n}\\n}\\n}\\n//Return the final value of count.\\nreturn cnt;"
                    },
                    {
                        "username": "folexz",
                        "content": "Swift submission fails at test cases 76-79, due to time limit while totally same python submission passes with no problem. Plz fix it"
                    },
                    {
                        "username": "OptimusHP",
                        "content": "Can anyone think of possible follow up to this question?"
                    },
                    {
                        "username": "farddinkhan733",
                        "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int ans=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}"
                    },
                    {
                        "username": "anubhavraj554",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int k= strs[0].size();\\n        int count=0,flag;\\n        for(int col=0; col<k; col++){\\n            for(int row=1; row<strs.size(); row++){\\n                flag=0;\\n                if(strs[row-1][col] > strs[row][col])\\n                    flag =1;\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWHY THIS CODE IS NOT A SOLUTION ?"
                    },
                    {
                        "username": "user7114ny",
                        "content": "meow "
                    }
                ]
            },
            {
                "id": 1740003,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "    // Variable to store the count of columns to be deleted.\\n        int answer = 0;\\n        // Iterate over each index in the string.\\n        for (int row = 1; row < strs.length; row++){\\n       // for (int col = 0; col < K; col++) {\\n            // Iterate over the strings.\\n             for (int col = 0; col < K; col++) {\\n          //  for (int row = 1; row < strs.length; row++) {\\n                // Characters should be in increasing order, \\n                // If not, increment the counter.\\n                if (strs[row].charAt(col) < strs[row - 1].charAt(col)) {\\n                    answer++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n\\n\\n\\nWhy my this answer is not working for test"
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I think you have the columns and rows confused. The nested for loop should be the rows, since you want to be going down each column before moving to the next one."
                    },
                    {
                        "username": "amanraaj",
                        "content": "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        return IntStream.range(0, strs[0].length())\\n                .filter(i -> IntStream.range(0, strs.length - 1)\\n                        .anyMatch(j -> strs[j].charAt(i) > strs[j + 1].charAt(i)))\\n                .toArray().length;\\n    }\\n}"
                    },
                    {
                        "username": "whiteknight16",
                        "content": "Look vertically and not horizontally\\n"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "C++ solution \\n\\nint minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int m=strs[0].size();\\n        int cnt=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n-1; j++){\\n                 if(strs[j][i] > strs[j+1][i]){\\n                     cnt++;\\n                     break;\\n                 }\\n                 \\n            }\\n        }\\n        return cnt;\\n    }"
                    },
                    {
                        "username": "HARSHIDAS_21",
                        "content": "The question says to detect the non lexiographical order count \\nSo \\nStep1 =Initialize The Count By 0.\\nStep2=Count The Size Of The Word In The Given Array, If The Size Of The word is not same then the count will increment.\\nStep3= Count the size of the array.\\nStep4= Now compare the column and hence, if not in the lexiographical order then increment count by 1.\\nStep5= Return the value at last.\\n\\nCode=\\n//Initialization of count by 0.\\nint cnt=0;\\n//Count the size of word in the array\\nint wordsize=strs[0].length();\\n//Count the size of the array \\nint size=strs.size();\\n//Now compare the lexiographical order \\nfor   (int i=0;i<wordsize;i++)\\n{\\nfor   (int j=0;j<size;j++)\\n{\\nif   (strs[j][i]>strs[j+1][i])\\n{\\n//Incrementing Count\\ncnt++;\\nbreak;\\n}\\n}\\n}\\n//Return the final value of count.\\nreturn cnt;"
                    },
                    {
                        "username": "folexz",
                        "content": "Swift submission fails at test cases 76-79, due to time limit while totally same python submission passes with no problem. Plz fix it"
                    },
                    {
                        "username": "OptimusHP",
                        "content": "Can anyone think of possible follow up to this question?"
                    },
                    {
                        "username": "farddinkhan733",
                        "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int ans=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}"
                    },
                    {
                        "username": "anubhavraj554",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int k= strs[0].size();\\n        int count=0,flag;\\n        for(int col=0; col<k; col++){\\n            for(int row=1; row<strs.size(); row++){\\n                flag=0;\\n                if(strs[row-1][col] > strs[row][col])\\n                    flag =1;\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWHY THIS CODE IS NOT A SOLUTION ?"
                    },
                    {
                        "username": "user7114ny",
                        "content": "meow "
                    }
                ]
            },
            {
                "id": 1739977,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "    // Variable to store the count of columns to be deleted.\\n        int answer = 0;\\n        // Iterate over each index in the string.\\n        for (int row = 1; row < strs.length; row++){\\n       // for (int col = 0; col < K; col++) {\\n            // Iterate over the strings.\\n             for (int col = 0; col < K; col++) {\\n          //  for (int row = 1; row < strs.length; row++) {\\n                // Characters should be in increasing order, \\n                // If not, increment the counter.\\n                if (strs[row].charAt(col) < strs[row - 1].charAt(col)) {\\n                    answer++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n\\n\\n\\nWhy my this answer is not working for test"
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I think you have the columns and rows confused. The nested for loop should be the rows, since you want to be going down each column before moving to the next one."
                    },
                    {
                        "username": "amanraaj",
                        "content": "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        return IntStream.range(0, strs[0].length())\\n                .filter(i -> IntStream.range(0, strs.length - 1)\\n                        .anyMatch(j -> strs[j].charAt(i) > strs[j + 1].charAt(i)))\\n                .toArray().length;\\n    }\\n}"
                    },
                    {
                        "username": "whiteknight16",
                        "content": "Look vertically and not horizontally\\n"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "C++ solution \\n\\nint minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int m=strs[0].size();\\n        int cnt=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n-1; j++){\\n                 if(strs[j][i] > strs[j+1][i]){\\n                     cnt++;\\n                     break;\\n                 }\\n                 \\n            }\\n        }\\n        return cnt;\\n    }"
                    },
                    {
                        "username": "HARSHIDAS_21",
                        "content": "The question says to detect the non lexiographical order count \\nSo \\nStep1 =Initialize The Count By 0.\\nStep2=Count The Size Of The Word In The Given Array, If The Size Of The word is not same then the count will increment.\\nStep3= Count the size of the array.\\nStep4= Now compare the column and hence, if not in the lexiographical order then increment count by 1.\\nStep5= Return the value at last.\\n\\nCode=\\n//Initialization of count by 0.\\nint cnt=0;\\n//Count the size of word in the array\\nint wordsize=strs[0].length();\\n//Count the size of the array \\nint size=strs.size();\\n//Now compare the lexiographical order \\nfor   (int i=0;i<wordsize;i++)\\n{\\nfor   (int j=0;j<size;j++)\\n{\\nif   (strs[j][i]>strs[j+1][i])\\n{\\n//Incrementing Count\\ncnt++;\\nbreak;\\n}\\n}\\n}\\n//Return the final value of count.\\nreturn cnt;"
                    },
                    {
                        "username": "folexz",
                        "content": "Swift submission fails at test cases 76-79, due to time limit while totally same python submission passes with no problem. Plz fix it"
                    },
                    {
                        "username": "OptimusHP",
                        "content": "Can anyone think of possible follow up to this question?"
                    },
                    {
                        "username": "farddinkhan733",
                        "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int ans=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}"
                    },
                    {
                        "username": "anubhavraj554",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int k= strs[0].size();\\n        int count=0,flag;\\n        for(int col=0; col<k; col++){\\n            for(int row=1; row<strs.size(); row++){\\n                flag=0;\\n                if(strs[row-1][col] > strs[row][col])\\n                    flag =1;\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWHY THIS CODE IS NOT A SOLUTION ?"
                    },
                    {
                        "username": "user7114ny",
                        "content": "meow "
                    }
                ]
            },
            {
                "id": 1739969,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "    // Variable to store the count of columns to be deleted.\\n        int answer = 0;\\n        // Iterate over each index in the string.\\n        for (int row = 1; row < strs.length; row++){\\n       // for (int col = 0; col < K; col++) {\\n            // Iterate over the strings.\\n             for (int col = 0; col < K; col++) {\\n          //  for (int row = 1; row < strs.length; row++) {\\n                // Characters should be in increasing order, \\n                // If not, increment the counter.\\n                if (strs[row].charAt(col) < strs[row - 1].charAt(col)) {\\n                    answer++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n\\n\\n\\nWhy my this answer is not working for test"
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I think you have the columns and rows confused. The nested for loop should be the rows, since you want to be going down each column before moving to the next one."
                    },
                    {
                        "username": "amanraaj",
                        "content": "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        return IntStream.range(0, strs[0].length())\\n                .filter(i -> IntStream.range(0, strs.length - 1)\\n                        .anyMatch(j -> strs[j].charAt(i) > strs[j + 1].charAt(i)))\\n                .toArray().length;\\n    }\\n}"
                    },
                    {
                        "username": "whiteknight16",
                        "content": "Look vertically and not horizontally\\n"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "C++ solution \\n\\nint minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int m=strs[0].size();\\n        int cnt=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n-1; j++){\\n                 if(strs[j][i] > strs[j+1][i]){\\n                     cnt++;\\n                     break;\\n                 }\\n                 \\n            }\\n        }\\n        return cnt;\\n    }"
                    },
                    {
                        "username": "HARSHIDAS_21",
                        "content": "The question says to detect the non lexiographical order count \\nSo \\nStep1 =Initialize The Count By 0.\\nStep2=Count The Size Of The Word In The Given Array, If The Size Of The word is not same then the count will increment.\\nStep3= Count the size of the array.\\nStep4= Now compare the column and hence, if not in the lexiographical order then increment count by 1.\\nStep5= Return the value at last.\\n\\nCode=\\n//Initialization of count by 0.\\nint cnt=0;\\n//Count the size of word in the array\\nint wordsize=strs[0].length();\\n//Count the size of the array \\nint size=strs.size();\\n//Now compare the lexiographical order \\nfor   (int i=0;i<wordsize;i++)\\n{\\nfor   (int j=0;j<size;j++)\\n{\\nif   (strs[j][i]>strs[j+1][i])\\n{\\n//Incrementing Count\\ncnt++;\\nbreak;\\n}\\n}\\n}\\n//Return the final value of count.\\nreturn cnt;"
                    },
                    {
                        "username": "folexz",
                        "content": "Swift submission fails at test cases 76-79, due to time limit while totally same python submission passes with no problem. Plz fix it"
                    },
                    {
                        "username": "OptimusHP",
                        "content": "Can anyone think of possible follow up to this question?"
                    },
                    {
                        "username": "farddinkhan733",
                        "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int ans=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}"
                    },
                    {
                        "username": "anubhavraj554",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int k= strs[0].size();\\n        int count=0,flag;\\n        for(int col=0; col<k; col++){\\n            for(int row=1; row<strs.size(); row++){\\n                flag=0;\\n                if(strs[row-1][col] > strs[row][col])\\n                    flag =1;\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWHY THIS CODE IS NOT A SOLUTION ?"
                    },
                    {
                        "username": "user7114ny",
                        "content": "meow "
                    }
                ]
            },
            {
                "id": 1739961,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "    // Variable to store the count of columns to be deleted.\\n        int answer = 0;\\n        // Iterate over each index in the string.\\n        for (int row = 1; row < strs.length; row++){\\n       // for (int col = 0; col < K; col++) {\\n            // Iterate over the strings.\\n             for (int col = 0; col < K; col++) {\\n          //  for (int row = 1; row < strs.length; row++) {\\n                // Characters should be in increasing order, \\n                // If not, increment the counter.\\n                if (strs[row].charAt(col) < strs[row - 1].charAt(col)) {\\n                    answer++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n\\n\\n\\nWhy my this answer is not working for test"
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I think you have the columns and rows confused. The nested for loop should be the rows, since you want to be going down each column before moving to the next one."
                    },
                    {
                        "username": "amanraaj",
                        "content": "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        return IntStream.range(0, strs[0].length())\\n                .filter(i -> IntStream.range(0, strs.length - 1)\\n                        .anyMatch(j -> strs[j].charAt(i) > strs[j + 1].charAt(i)))\\n                .toArray().length;\\n    }\\n}"
                    },
                    {
                        "username": "whiteknight16",
                        "content": "Look vertically and not horizontally\\n"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "C++ solution \\n\\nint minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int m=strs[0].size();\\n        int cnt=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n-1; j++){\\n                 if(strs[j][i] > strs[j+1][i]){\\n                     cnt++;\\n                     break;\\n                 }\\n                 \\n            }\\n        }\\n        return cnt;\\n    }"
                    },
                    {
                        "username": "HARSHIDAS_21",
                        "content": "The question says to detect the non lexiographical order count \\nSo \\nStep1 =Initialize The Count By 0.\\nStep2=Count The Size Of The Word In The Given Array, If The Size Of The word is not same then the count will increment.\\nStep3= Count the size of the array.\\nStep4= Now compare the column and hence, if not in the lexiographical order then increment count by 1.\\nStep5= Return the value at last.\\n\\nCode=\\n//Initialization of count by 0.\\nint cnt=0;\\n//Count the size of word in the array\\nint wordsize=strs[0].length();\\n//Count the size of the array \\nint size=strs.size();\\n//Now compare the lexiographical order \\nfor   (int i=0;i<wordsize;i++)\\n{\\nfor   (int j=0;j<size;j++)\\n{\\nif   (strs[j][i]>strs[j+1][i])\\n{\\n//Incrementing Count\\ncnt++;\\nbreak;\\n}\\n}\\n}\\n//Return the final value of count.\\nreturn cnt;"
                    },
                    {
                        "username": "folexz",
                        "content": "Swift submission fails at test cases 76-79, due to time limit while totally same python submission passes with no problem. Plz fix it"
                    },
                    {
                        "username": "OptimusHP",
                        "content": "Can anyone think of possible follow up to this question?"
                    },
                    {
                        "username": "farddinkhan733",
                        "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int ans=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}"
                    },
                    {
                        "username": "anubhavraj554",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int k= strs[0].size();\\n        int count=0,flag;\\n        for(int col=0; col<k; col++){\\n            for(int row=1; row<strs.size(); row++){\\n                flag=0;\\n                if(strs[row-1][col] > strs[row][col])\\n                    flag =1;\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWHY THIS CODE IS NOT A SOLUTION ?"
                    },
                    {
                        "username": "user7114ny",
                        "content": "meow "
                    }
                ]
            },
            {
                "id": 1739949,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "    // Variable to store the count of columns to be deleted.\\n        int answer = 0;\\n        // Iterate over each index in the string.\\n        for (int row = 1; row < strs.length; row++){\\n       // for (int col = 0; col < K; col++) {\\n            // Iterate over the strings.\\n             for (int col = 0; col < K; col++) {\\n          //  for (int row = 1; row < strs.length; row++) {\\n                // Characters should be in increasing order, \\n                // If not, increment the counter.\\n                if (strs[row].charAt(col) < strs[row - 1].charAt(col)) {\\n                    answer++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n\\n\\n\\nWhy my this answer is not working for test"
                    },
                    {
                        "username": "Peiferinc",
                        "content": "I think you have the columns and rows confused. The nested for loop should be the rows, since you want to be going down each column before moving to the next one."
                    },
                    {
                        "username": "amanraaj",
                        "content": "class Solution {\\n    public int minDeletionSize(String[] strs) {\\n        return IntStream.range(0, strs[0].length())\\n                .filter(i -> IntStream.range(0, strs.length - 1)\\n                        .anyMatch(j -> strs[j].charAt(i) > strs[j + 1].charAt(i)))\\n                .toArray().length;\\n    }\\n}"
                    },
                    {
                        "username": "whiteknight16",
                        "content": "Look vertically and not horizontally\\n"
                    },
                    {
                        "username": "rahul_rm__",
                        "content": "C++ solution \\n\\nint minDeletionSize(vector<string>& strs) {\\n        int n=strs.size();\\n        int m=strs[0].size();\\n        int cnt=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n-1; j++){\\n                 if(strs[j][i] > strs[j+1][i]){\\n                     cnt++;\\n                     break;\\n                 }\\n                 \\n            }\\n        }\\n        return cnt;\\n    }"
                    },
                    {
                        "username": "HARSHIDAS_21",
                        "content": "The question says to detect the non lexiographical order count \\nSo \\nStep1 =Initialize The Count By 0.\\nStep2=Count The Size Of The Word In The Given Array, If The Size Of The word is not same then the count will increment.\\nStep3= Count the size of the array.\\nStep4= Now compare the column and hence, if not in the lexiographical order then increment count by 1.\\nStep5= Return the value at last.\\n\\nCode=\\n//Initialization of count by 0.\\nint cnt=0;\\n//Count the size of word in the array\\nint wordsize=strs[0].length();\\n//Count the size of the array \\nint size=strs.size();\\n//Now compare the lexiographical order \\nfor   (int i=0;i<wordsize;i++)\\n{\\nfor   (int j=0;j<size;j++)\\n{\\nif   (strs[j][i]>strs[j+1][i])\\n{\\n//Incrementing Count\\ncnt++;\\nbreak;\\n}\\n}\\n}\\n//Return the final value of count.\\nreturn cnt;"
                    },
                    {
                        "username": "folexz",
                        "content": "Swift submission fails at test cases 76-79, due to time limit while totally same python submission passes with no problem. Plz fix it"
                    },
                    {
                        "username": "OptimusHP",
                        "content": "Can anyone think of possible follow up to this question?"
                    },
                    {
                        "username": "farddinkhan733",
                        "content": "```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        \\n        int ans=0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i)>strs[j+1].charAt(i)){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n}"
                    },
                    {
                        "username": "anubhavraj554",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int k= strs[0].size();\\n        int count=0,flag;\\n        for(int col=0; col<k; col++){\\n            for(int row=1; row<strs.size(); row++){\\n                flag=0;\\n                if(strs[row-1][col] > strs[row][col])\\n                    flag =1;\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\nWHY THIS CODE IS NOT A SOLUTION ?"
                    },
                    {
                        "username": "user7114ny",
                        "content": "meow "
                    }
                ]
            },
            {
                "id": 1739948,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "The problem statement had me under the impression that we are to find the optimal way to re-arrange the words. Anyone else that had the same issue?"
                    },
                    {
                        "username": "happyrogue2307",
                        "content": "I noticed something strange for my Python3 solution. \\n\\nLeaving the parameter name as strs make my solution beat 68% but changing it from strs to A makes the same solution beat 94.5%.\\n\\nDoes anyone have an explanation for why this is happening? Thanks!"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "You have an error in the description. In the first example you give us array [\"abc\", \"bce\", \"cae\"], but above in explanation you write that  \"abc\" and \"cee\" are sorted, but where did you get \"cee\"? We have only \"cae\" and it\\'s not sorted. And later you write that \"bca\" is not sorted, but we don\\'t have it, we have \"bce\" which is against sorted"
                    },
                    {
                        "username": "belinskyi",
                        "content": "\"abc\" are characters at 0 index in each string from [\"abc\", \"bce\", \"cae\"]\\n\"cee\" at 2 index\\n\"bca\" at 1 index "
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "int minDeletionSize(vector<string>& strs) {\\n        \\n        int deletions=0;\\n        int n=strs.size();\\n        int wordSize=strs[0].length();\\n        for(int i=0;i<wordSize;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    deletions++;\\n                    break;\\n                }\\n            }\\n        }\\n        return deletions;\\n    }\\n"
                    },
                    {
                        "username": "ujjwalujjs",
                        "content": "Description could be better . Not very hard to understand  but takes some time  to understand the problem."
                    },
                    {
                        "username": "exlo89",
                        "content": "it took me 20 min to check the question and read COLUMNS. "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy problem take O (n2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "why n2? it takes `length of array` * `length of strings inside the array`"
                    },
                    {
                        "username": "atninthsky",
                        "content": "What\\'s wrong with the testcase, I don\\'t understand the testcases in the problem statement. Can someone help?"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "The title is misleading to me, we are neither deleting nor making sorted.\\nIt should rather be named \\'counting unsorted columns from string arrays\\'."
                    },
                    {
                        "username": "obaissa",
                        "content": "I definitely struggled with how to format the array for matrix list. \\n\\n```\\n\\'\\'\\'\\nreturn type: integer \\nmatch: sorting / arrays \\nplan:\\n1. counter var \\n2. loop through list and append each index and a piece in a new list of list\\n3. check if sorted value is the same as the list index and add to counter if not \\n4. return counter \\n\\ntime: o(m *n log n ) space: o(n*m)\\n\\'\\'\\'\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        counter = 0   \\n        for i in range(len(strs[0])):\\n            new_word = [strs[j][i] for j in range(len(strs))]\\n            if new_word != sorted(new_word):\\n                counter += 1 \\n        return counter \\n``` "
                    }
                ]
            },
            {
                "id": 1739942,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "The problem statement had me under the impression that we are to find the optimal way to re-arrange the words. Anyone else that had the same issue?"
                    },
                    {
                        "username": "happyrogue2307",
                        "content": "I noticed something strange for my Python3 solution. \\n\\nLeaving the parameter name as strs make my solution beat 68% but changing it from strs to A makes the same solution beat 94.5%.\\n\\nDoes anyone have an explanation for why this is happening? Thanks!"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "You have an error in the description. In the first example you give us array [\"abc\", \"bce\", \"cae\"], but above in explanation you write that  \"abc\" and \"cee\" are sorted, but where did you get \"cee\"? We have only \"cae\" and it\\'s not sorted. And later you write that \"bca\" is not sorted, but we don\\'t have it, we have \"bce\" which is against sorted"
                    },
                    {
                        "username": "belinskyi",
                        "content": "\"abc\" are characters at 0 index in each string from [\"abc\", \"bce\", \"cae\"]\\n\"cee\" at 2 index\\n\"bca\" at 1 index "
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "int minDeletionSize(vector<string>& strs) {\\n        \\n        int deletions=0;\\n        int n=strs.size();\\n        int wordSize=strs[0].length();\\n        for(int i=0;i<wordSize;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    deletions++;\\n                    break;\\n                }\\n            }\\n        }\\n        return deletions;\\n    }\\n"
                    },
                    {
                        "username": "ujjwalujjs",
                        "content": "Description could be better . Not very hard to understand  but takes some time  to understand the problem."
                    },
                    {
                        "username": "exlo89",
                        "content": "it took me 20 min to check the question and read COLUMNS. "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy problem take O (n2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "why n2? it takes `length of array` * `length of strings inside the array`"
                    },
                    {
                        "username": "atninthsky",
                        "content": "What\\'s wrong with the testcase, I don\\'t understand the testcases in the problem statement. Can someone help?"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "The title is misleading to me, we are neither deleting nor making sorted.\\nIt should rather be named \\'counting unsorted columns from string arrays\\'."
                    },
                    {
                        "username": "obaissa",
                        "content": "I definitely struggled with how to format the array for matrix list. \\n\\n```\\n\\'\\'\\'\\nreturn type: integer \\nmatch: sorting / arrays \\nplan:\\n1. counter var \\n2. loop through list and append each index and a piece in a new list of list\\n3. check if sorted value is the same as the list index and add to counter if not \\n4. return counter \\n\\ntime: o(m *n log n ) space: o(n*m)\\n\\'\\'\\'\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        counter = 0   \\n        for i in range(len(strs[0])):\\n            new_word = [strs[j][i] for j in range(len(strs))]\\n            if new_word != sorted(new_word):\\n                counter += 1 \\n        return counter \\n``` "
                    }
                ]
            },
            {
                "id": 1739934,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "The problem statement had me under the impression that we are to find the optimal way to re-arrange the words. Anyone else that had the same issue?"
                    },
                    {
                        "username": "happyrogue2307",
                        "content": "I noticed something strange for my Python3 solution. \\n\\nLeaving the parameter name as strs make my solution beat 68% but changing it from strs to A makes the same solution beat 94.5%.\\n\\nDoes anyone have an explanation for why this is happening? Thanks!"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "You have an error in the description. In the first example you give us array [\"abc\", \"bce\", \"cae\"], but above in explanation you write that  \"abc\" and \"cee\" are sorted, but where did you get \"cee\"? We have only \"cae\" and it\\'s not sorted. And later you write that \"bca\" is not sorted, but we don\\'t have it, we have \"bce\" which is against sorted"
                    },
                    {
                        "username": "belinskyi",
                        "content": "\"abc\" are characters at 0 index in each string from [\"abc\", \"bce\", \"cae\"]\\n\"cee\" at 2 index\\n\"bca\" at 1 index "
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "int minDeletionSize(vector<string>& strs) {\\n        \\n        int deletions=0;\\n        int n=strs.size();\\n        int wordSize=strs[0].length();\\n        for(int i=0;i<wordSize;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    deletions++;\\n                    break;\\n                }\\n            }\\n        }\\n        return deletions;\\n    }\\n"
                    },
                    {
                        "username": "ujjwalujjs",
                        "content": "Description could be better . Not very hard to understand  but takes some time  to understand the problem."
                    },
                    {
                        "username": "exlo89",
                        "content": "it took me 20 min to check the question and read COLUMNS. "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy problem take O (n2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "why n2? it takes `length of array` * `length of strings inside the array`"
                    },
                    {
                        "username": "atninthsky",
                        "content": "What\\'s wrong with the testcase, I don\\'t understand the testcases in the problem statement. Can someone help?"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "The title is misleading to me, we are neither deleting nor making sorted.\\nIt should rather be named \\'counting unsorted columns from string arrays\\'."
                    },
                    {
                        "username": "obaissa",
                        "content": "I definitely struggled with how to format the array for matrix list. \\n\\n```\\n\\'\\'\\'\\nreturn type: integer \\nmatch: sorting / arrays \\nplan:\\n1. counter var \\n2. loop through list and append each index and a piece in a new list of list\\n3. check if sorted value is the same as the list index and add to counter if not \\n4. return counter \\n\\ntime: o(m *n log n ) space: o(n*m)\\n\\'\\'\\'\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        counter = 0   \\n        for i in range(len(strs[0])):\\n            new_word = [strs[j][i] for j in range(len(strs))]\\n            if new_word != sorted(new_word):\\n                counter += 1 \\n        return counter \\n``` "
                    }
                ]
            },
            {
                "id": 1739928,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "The problem statement had me under the impression that we are to find the optimal way to re-arrange the words. Anyone else that had the same issue?"
                    },
                    {
                        "username": "happyrogue2307",
                        "content": "I noticed something strange for my Python3 solution. \\n\\nLeaving the parameter name as strs make my solution beat 68% but changing it from strs to A makes the same solution beat 94.5%.\\n\\nDoes anyone have an explanation for why this is happening? Thanks!"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "You have an error in the description. In the first example you give us array [\"abc\", \"bce\", \"cae\"], but above in explanation you write that  \"abc\" and \"cee\" are sorted, but where did you get \"cee\"? We have only \"cae\" and it\\'s not sorted. And later you write that \"bca\" is not sorted, but we don\\'t have it, we have \"bce\" which is against sorted"
                    },
                    {
                        "username": "belinskyi",
                        "content": "\"abc\" are characters at 0 index in each string from [\"abc\", \"bce\", \"cae\"]\\n\"cee\" at 2 index\\n\"bca\" at 1 index "
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "int minDeletionSize(vector<string>& strs) {\\n        \\n        int deletions=0;\\n        int n=strs.size();\\n        int wordSize=strs[0].length();\\n        for(int i=0;i<wordSize;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    deletions++;\\n                    break;\\n                }\\n            }\\n        }\\n        return deletions;\\n    }\\n"
                    },
                    {
                        "username": "ujjwalujjs",
                        "content": "Description could be better . Not very hard to understand  but takes some time  to understand the problem."
                    },
                    {
                        "username": "exlo89",
                        "content": "it took me 20 min to check the question and read COLUMNS. "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy problem take O (n2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "why n2? it takes `length of array` * `length of strings inside the array`"
                    },
                    {
                        "username": "atninthsky",
                        "content": "What\\'s wrong with the testcase, I don\\'t understand the testcases in the problem statement. Can someone help?"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "The title is misleading to me, we are neither deleting nor making sorted.\\nIt should rather be named \\'counting unsorted columns from string arrays\\'."
                    },
                    {
                        "username": "obaissa",
                        "content": "I definitely struggled with how to format the array for matrix list. \\n\\n```\\n\\'\\'\\'\\nreturn type: integer \\nmatch: sorting / arrays \\nplan:\\n1. counter var \\n2. loop through list and append each index and a piece in a new list of list\\n3. check if sorted value is the same as the list index and add to counter if not \\n4. return counter \\n\\ntime: o(m *n log n ) space: o(n*m)\\n\\'\\'\\'\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        counter = 0   \\n        for i in range(len(strs[0])):\\n            new_word = [strs[j][i] for j in range(len(strs))]\\n            if new_word != sorted(new_word):\\n                counter += 1 \\n        return counter \\n``` "
                    }
                ]
            },
            {
                "id": 1739917,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "The problem statement had me under the impression that we are to find the optimal way to re-arrange the words. Anyone else that had the same issue?"
                    },
                    {
                        "username": "happyrogue2307",
                        "content": "I noticed something strange for my Python3 solution. \\n\\nLeaving the parameter name as strs make my solution beat 68% but changing it from strs to A makes the same solution beat 94.5%.\\n\\nDoes anyone have an explanation for why this is happening? Thanks!"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "You have an error in the description. In the first example you give us array [\"abc\", \"bce\", \"cae\"], but above in explanation you write that  \"abc\" and \"cee\" are sorted, but where did you get \"cee\"? We have only \"cae\" and it\\'s not sorted. And later you write that \"bca\" is not sorted, but we don\\'t have it, we have \"bce\" which is against sorted"
                    },
                    {
                        "username": "belinskyi",
                        "content": "\"abc\" are characters at 0 index in each string from [\"abc\", \"bce\", \"cae\"]\\n\"cee\" at 2 index\\n\"bca\" at 1 index "
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "int minDeletionSize(vector<string>& strs) {\\n        \\n        int deletions=0;\\n        int n=strs.size();\\n        int wordSize=strs[0].length();\\n        for(int i=0;i<wordSize;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    deletions++;\\n                    break;\\n                }\\n            }\\n        }\\n        return deletions;\\n    }\\n"
                    },
                    {
                        "username": "ujjwalujjs",
                        "content": "Description could be better . Not very hard to understand  but takes some time  to understand the problem."
                    },
                    {
                        "username": "exlo89",
                        "content": "it took me 20 min to check the question and read COLUMNS. "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy problem take O (n2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "why n2? it takes `length of array` * `length of strings inside the array`"
                    },
                    {
                        "username": "atninthsky",
                        "content": "What\\'s wrong with the testcase, I don\\'t understand the testcases in the problem statement. Can someone help?"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "The title is misleading to me, we are neither deleting nor making sorted.\\nIt should rather be named \\'counting unsorted columns from string arrays\\'."
                    },
                    {
                        "username": "obaissa",
                        "content": "I definitely struggled with how to format the array for matrix list. \\n\\n```\\n\\'\\'\\'\\nreturn type: integer \\nmatch: sorting / arrays \\nplan:\\n1. counter var \\n2. loop through list and append each index and a piece in a new list of list\\n3. check if sorted value is the same as the list index and add to counter if not \\n4. return counter \\n\\ntime: o(m *n log n ) space: o(n*m)\\n\\'\\'\\'\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        counter = 0   \\n        for i in range(len(strs[0])):\\n            new_word = [strs[j][i] for j in range(len(strs))]\\n            if new_word != sorted(new_word):\\n                counter += 1 \\n        return counter \\n``` "
                    }
                ]
            },
            {
                "id": 1739875,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "The problem statement had me under the impression that we are to find the optimal way to re-arrange the words. Anyone else that had the same issue?"
                    },
                    {
                        "username": "happyrogue2307",
                        "content": "I noticed something strange for my Python3 solution. \\n\\nLeaving the parameter name as strs make my solution beat 68% but changing it from strs to A makes the same solution beat 94.5%.\\n\\nDoes anyone have an explanation for why this is happening? Thanks!"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "You have an error in the description. In the first example you give us array [\"abc\", \"bce\", \"cae\"], but above in explanation you write that  \"abc\" and \"cee\" are sorted, but where did you get \"cee\"? We have only \"cae\" and it\\'s not sorted. And later you write that \"bca\" is not sorted, but we don\\'t have it, we have \"bce\" which is against sorted"
                    },
                    {
                        "username": "belinskyi",
                        "content": "\"abc\" are characters at 0 index in each string from [\"abc\", \"bce\", \"cae\"]\\n\"cee\" at 2 index\\n\"bca\" at 1 index "
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "int minDeletionSize(vector<string>& strs) {\\n        \\n        int deletions=0;\\n        int n=strs.size();\\n        int wordSize=strs[0].length();\\n        for(int i=0;i<wordSize;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    deletions++;\\n                    break;\\n                }\\n            }\\n        }\\n        return deletions;\\n    }\\n"
                    },
                    {
                        "username": "ujjwalujjs",
                        "content": "Description could be better . Not very hard to understand  but takes some time  to understand the problem."
                    },
                    {
                        "username": "exlo89",
                        "content": "it took me 20 min to check the question and read COLUMNS. "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy problem take O (n2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "why n2? it takes `length of array` * `length of strings inside the array`"
                    },
                    {
                        "username": "atninthsky",
                        "content": "What\\'s wrong with the testcase, I don\\'t understand the testcases in the problem statement. Can someone help?"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "The title is misleading to me, we are neither deleting nor making sorted.\\nIt should rather be named \\'counting unsorted columns from string arrays\\'."
                    },
                    {
                        "username": "obaissa",
                        "content": "I definitely struggled with how to format the array for matrix list. \\n\\n```\\n\\'\\'\\'\\nreturn type: integer \\nmatch: sorting / arrays \\nplan:\\n1. counter var \\n2. loop through list and append each index and a piece in a new list of list\\n3. check if sorted value is the same as the list index and add to counter if not \\n4. return counter \\n\\ntime: o(m *n log n ) space: o(n*m)\\n\\'\\'\\'\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        counter = 0   \\n        for i in range(len(strs[0])):\\n            new_word = [strs[j][i] for j in range(len(strs))]\\n            if new_word != sorted(new_word):\\n                counter += 1 \\n        return counter \\n``` "
                    }
                ]
            },
            {
                "id": 1739850,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "The problem statement had me under the impression that we are to find the optimal way to re-arrange the words. Anyone else that had the same issue?"
                    },
                    {
                        "username": "happyrogue2307",
                        "content": "I noticed something strange for my Python3 solution. \\n\\nLeaving the parameter name as strs make my solution beat 68% but changing it from strs to A makes the same solution beat 94.5%.\\n\\nDoes anyone have an explanation for why this is happening? Thanks!"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "You have an error in the description. In the first example you give us array [\"abc\", \"bce\", \"cae\"], but above in explanation you write that  \"abc\" and \"cee\" are sorted, but where did you get \"cee\"? We have only \"cae\" and it\\'s not sorted. And later you write that \"bca\" is not sorted, but we don\\'t have it, we have \"bce\" which is against sorted"
                    },
                    {
                        "username": "belinskyi",
                        "content": "\"abc\" are characters at 0 index in each string from [\"abc\", \"bce\", \"cae\"]\\n\"cee\" at 2 index\\n\"bca\" at 1 index "
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "int minDeletionSize(vector<string>& strs) {\\n        \\n        int deletions=0;\\n        int n=strs.size();\\n        int wordSize=strs[0].length();\\n        for(int i=0;i<wordSize;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    deletions++;\\n                    break;\\n                }\\n            }\\n        }\\n        return deletions;\\n    }\\n"
                    },
                    {
                        "username": "ujjwalujjs",
                        "content": "Description could be better . Not very hard to understand  but takes some time  to understand the problem."
                    },
                    {
                        "username": "exlo89",
                        "content": "it took me 20 min to check the question and read COLUMNS. "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy problem take O (n2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "why n2? it takes `length of array` * `length of strings inside the array`"
                    },
                    {
                        "username": "atninthsky",
                        "content": "What\\'s wrong with the testcase, I don\\'t understand the testcases in the problem statement. Can someone help?"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "The title is misleading to me, we are neither deleting nor making sorted.\\nIt should rather be named \\'counting unsorted columns from string arrays\\'."
                    },
                    {
                        "username": "obaissa",
                        "content": "I definitely struggled with how to format the array for matrix list. \\n\\n```\\n\\'\\'\\'\\nreturn type: integer \\nmatch: sorting / arrays \\nplan:\\n1. counter var \\n2. loop through list and append each index and a piece in a new list of list\\n3. check if sorted value is the same as the list index and add to counter if not \\n4. return counter \\n\\ntime: o(m *n log n ) space: o(n*m)\\n\\'\\'\\'\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        counter = 0   \\n        for i in range(len(strs[0])):\\n            new_word = [strs[j][i] for j in range(len(strs))]\\n            if new_word != sorted(new_word):\\n                counter += 1 \\n        return counter \\n``` "
                    }
                ]
            },
            {
                "id": 1739816,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "The problem statement had me under the impression that we are to find the optimal way to re-arrange the words. Anyone else that had the same issue?"
                    },
                    {
                        "username": "happyrogue2307",
                        "content": "I noticed something strange for my Python3 solution. \\n\\nLeaving the parameter name as strs make my solution beat 68% but changing it from strs to A makes the same solution beat 94.5%.\\n\\nDoes anyone have an explanation for why this is happening? Thanks!"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "You have an error in the description. In the first example you give us array [\"abc\", \"bce\", \"cae\"], but above in explanation you write that  \"abc\" and \"cee\" are sorted, but where did you get \"cee\"? We have only \"cae\" and it\\'s not sorted. And later you write that \"bca\" is not sorted, but we don\\'t have it, we have \"bce\" which is against sorted"
                    },
                    {
                        "username": "belinskyi",
                        "content": "\"abc\" are characters at 0 index in each string from [\"abc\", \"bce\", \"cae\"]\\n\"cee\" at 2 index\\n\"bca\" at 1 index "
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "int minDeletionSize(vector<string>& strs) {\\n        \\n        int deletions=0;\\n        int n=strs.size();\\n        int wordSize=strs[0].length();\\n        for(int i=0;i<wordSize;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    deletions++;\\n                    break;\\n                }\\n            }\\n        }\\n        return deletions;\\n    }\\n"
                    },
                    {
                        "username": "ujjwalujjs",
                        "content": "Description could be better . Not very hard to understand  but takes some time  to understand the problem."
                    },
                    {
                        "username": "exlo89",
                        "content": "it took me 20 min to check the question and read COLUMNS. "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy problem take O (n2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "why n2? it takes `length of array` * `length of strings inside the array`"
                    },
                    {
                        "username": "atninthsky",
                        "content": "What\\'s wrong with the testcase, I don\\'t understand the testcases in the problem statement. Can someone help?"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "The title is misleading to me, we are neither deleting nor making sorted.\\nIt should rather be named \\'counting unsorted columns from string arrays\\'."
                    },
                    {
                        "username": "obaissa",
                        "content": "I definitely struggled with how to format the array for matrix list. \\n\\n```\\n\\'\\'\\'\\nreturn type: integer \\nmatch: sorting / arrays \\nplan:\\n1. counter var \\n2. loop through list and append each index and a piece in a new list of list\\n3. check if sorted value is the same as the list index and add to counter if not \\n4. return counter \\n\\ntime: o(m *n log n ) space: o(n*m)\\n\\'\\'\\'\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        counter = 0   \\n        for i in range(len(strs[0])):\\n            new_word = [strs[j][i] for j in range(len(strs))]\\n            if new_word != sorted(new_word):\\n                counter += 1 \\n        return counter \\n``` "
                    }
                ]
            },
            {
                "id": 1739778,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "The problem statement had me under the impression that we are to find the optimal way to re-arrange the words. Anyone else that had the same issue?"
                    },
                    {
                        "username": "happyrogue2307",
                        "content": "I noticed something strange for my Python3 solution. \\n\\nLeaving the parameter name as strs make my solution beat 68% but changing it from strs to A makes the same solution beat 94.5%.\\n\\nDoes anyone have an explanation for why this is happening? Thanks!"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "You have an error in the description. In the first example you give us array [\"abc\", \"bce\", \"cae\"], but above in explanation you write that  \"abc\" and \"cee\" are sorted, but where did you get \"cee\"? We have only \"cae\" and it\\'s not sorted. And later you write that \"bca\" is not sorted, but we don\\'t have it, we have \"bce\" which is against sorted"
                    },
                    {
                        "username": "belinskyi",
                        "content": "\"abc\" are characters at 0 index in each string from [\"abc\", \"bce\", \"cae\"]\\n\"cee\" at 2 index\\n\"bca\" at 1 index "
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "int minDeletionSize(vector<string>& strs) {\\n        \\n        int deletions=0;\\n        int n=strs.size();\\n        int wordSize=strs[0].length();\\n        for(int i=0;i<wordSize;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    deletions++;\\n                    break;\\n                }\\n            }\\n        }\\n        return deletions;\\n    }\\n"
                    },
                    {
                        "username": "ujjwalujjs",
                        "content": "Description could be better . Not very hard to understand  but takes some time  to understand the problem."
                    },
                    {
                        "username": "exlo89",
                        "content": "it took me 20 min to check the question and read COLUMNS. "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy problem take O (n2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "why n2? it takes `length of array` * `length of strings inside the array`"
                    },
                    {
                        "username": "atninthsky",
                        "content": "What\\'s wrong with the testcase, I don\\'t understand the testcases in the problem statement. Can someone help?"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "The title is misleading to me, we are neither deleting nor making sorted.\\nIt should rather be named \\'counting unsorted columns from string arrays\\'."
                    },
                    {
                        "username": "obaissa",
                        "content": "I definitely struggled with how to format the array for matrix list. \\n\\n```\\n\\'\\'\\'\\nreturn type: integer \\nmatch: sorting / arrays \\nplan:\\n1. counter var \\n2. loop through list and append each index and a piece in a new list of list\\n3. check if sorted value is the same as the list index and add to counter if not \\n4. return counter \\n\\ntime: o(m *n log n ) space: o(n*m)\\n\\'\\'\\'\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        counter = 0   \\n        for i in range(len(strs[0])):\\n            new_word = [strs[j][i] for j in range(len(strs))]\\n            if new_word != sorted(new_word):\\n                counter += 1 \\n        return counter \\n``` "
                    }
                ]
            },
            {
                "id": 1739764,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "The problem statement had me under the impression that we are to find the optimal way to re-arrange the words. Anyone else that had the same issue?"
                    },
                    {
                        "username": "happyrogue2307",
                        "content": "I noticed something strange for my Python3 solution. \\n\\nLeaving the parameter name as strs make my solution beat 68% but changing it from strs to A makes the same solution beat 94.5%.\\n\\nDoes anyone have an explanation for why this is happening? Thanks!"
                    },
                    {
                        "username": "rustam_taov",
                        "content": "You have an error in the description. In the first example you give us array [\"abc\", \"bce\", \"cae\"], but above in explanation you write that  \"abc\" and \"cee\" are sorted, but where did you get \"cee\"? We have only \"cae\" and it\\'s not sorted. And later you write that \"bca\" is not sorted, but we don\\'t have it, we have \"bce\" which is against sorted"
                    },
                    {
                        "username": "belinskyi",
                        "content": "\"abc\" are characters at 0 index in each string from [\"abc\", \"bce\", \"cae\"]\\n\"cee\" at 2 index\\n\"bca\" at 1 index "
                    },
                    {
                        "username": "ashiqhussainkumar143",
                        "content": "int minDeletionSize(vector<string>& strs) {\\n        \\n        int deletions=0;\\n        int n=strs.size();\\n        int wordSize=strs[0].length();\\n        for(int i=0;i<wordSize;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(strs[j][i]>strs[j+1][i]){\\n                    deletions++;\\n                    break;\\n                }\\n            }\\n        }\\n        return deletions;\\n    }\\n"
                    },
                    {
                        "username": "ujjwalujjs",
                        "content": "Description could be better . Not very hard to understand  but takes some time  to understand the problem."
                    },
                    {
                        "username": "exlo89",
                        "content": "it took me 20 min to check the question and read COLUMNS. "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy problem take O (n2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "why n2? it takes `length of array` * `length of strings inside the array`"
                    },
                    {
                        "username": "atninthsky",
                        "content": "What\\'s wrong with the testcase, I don\\'t understand the testcases in the problem statement. Can someone help?"
                    },
                    {
                        "username": "shutdown-r",
                        "content": "The title is misleading to me, we are neither deleting nor making sorted.\\nIt should rather be named \\'counting unsorted columns from string arrays\\'."
                    },
                    {
                        "username": "obaissa",
                        "content": "I definitely struggled with how to format the array for matrix list. \\n\\n```\\n\\'\\'\\'\\nreturn type: integer \\nmatch: sorting / arrays \\nplan:\\n1. counter var \\n2. loop through list and append each index and a piece in a new list of list\\n3. check if sorted value is the same as the list index and add to counter if not \\n4. return counter \\n\\ntime: o(m *n log n ) space: o(n*m)\\n\\'\\'\\'\\nclass Solution:\\n    def minDeletionSize(self, strs: List[str]) -> int:\\n        counter = 0   \\n        for i in range(len(strs[0])):\\n            new_word = [strs[j][i] for j in range(len(strs))]\\n            if new_word != sorted(new_word):\\n                counter += 1 \\n        return counter \\n``` "
                    }
                ]
            },
            {
                "id": 1739760,
                "content": [
                    {
                        "username": "aka773",
                        "content": "don't ignore line 7 explanation!!!\nlets say we have\nstrs = [\"abc\", \"def\", \"ghi\"]\n see like this: \n \nfirst col :  a, d, g\nsecond:   b, e, h\nthird col:  c, f, i\n"
                    },
                    {
                        "username": "_Black_sd_",
                        "content": "\\u2705 Black Code | C++ | Brute Force\\n\\ntraversing for all column and check for non ascending order if yes then cnt++ and break the loop. check for all coulmn and return ans.\\n\\n    class Solution {\\n    public:\\n        int minDeletionSize(vector<string>& v) {\\n            int n=v.size();\\n            int m=v[0].size();\\n\\n            int cnt=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    if(v[j-1][i]>v[j][i])\\n                    {\\n                        cnt++;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return cnt;\\n        }\\n    };"
                    },
                    {
                        "username": "sourabh15072002",
                        "content": "Easy and Simple Approach to do it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine breaking your streak on 31st December \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25 I redeemed coins to make up for that missed challenge but I\\'m not able to?!?! :("
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Key concept: we need to check if column is sorted or not .\\nso \\n1. we traverse the matrix by column .\\n2. in each column if any element is smaller than the previous one then that column is not sorted (count it)\\n\\nSpace complexity : O(1) \\nTime complexity : O(n*k) where n is size of vector and k is size of each string(all with same size)."
                    },
                    {
                        "username": "Namit567",
                        "content": "This code appears to be checking for how many columns need to be deleted from a list of strings in order to make the strings lexicographically sorted in ascending order.\\n\\nFor each column in the strings, the code checks if the characters at that column are in the correct order (i.e. the character in the first string is lexicographically smaller than the character in the second string, the character in the second string is lexicographically smaller than the character in the third string, and so on). If a column is out of order, the code increments the count by 1 and breaks out of the inner loop.\\n\\nFinally, the code returns the count of columns that need to be deleted."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order\n[abc] -> a b —Å are the ROWS so dont check b > a, c > b etc"
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "All good and nice practice. The bullet point of this question is that it requires to find out the number of the columns that is not sorted instead of the rows, so directly checking each elements in the given list does not work."
                    },
                    {
                        "username": "Peet_code",
                        "content": "The idea is to take each column directly, and then sort it to see if it it is equal to the original string."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Rather check order instead of sorting as sorting is heavy operation( O(n*log(n)) )"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good to solve it in a single go :)"
                    }
                ]
            },
            {
                "id": 1739751,
                "content": [
                    {
                        "username": "aka773",
                        "content": "don't ignore line 7 explanation!!!\nlets say we have\nstrs = [\"abc\", \"def\", \"ghi\"]\n see like this: \n \nfirst col :  a, d, g\nsecond:   b, e, h\nthird col:  c, f, i\n"
                    },
                    {
                        "username": "_Black_sd_",
                        "content": "\\u2705 Black Code | C++ | Brute Force\\n\\ntraversing for all column and check for non ascending order if yes then cnt++ and break the loop. check for all coulmn and return ans.\\n\\n    class Solution {\\n    public:\\n        int minDeletionSize(vector<string>& v) {\\n            int n=v.size();\\n            int m=v[0].size();\\n\\n            int cnt=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    if(v[j-1][i]>v[j][i])\\n                    {\\n                        cnt++;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return cnt;\\n        }\\n    };"
                    },
                    {
                        "username": "sourabh15072002",
                        "content": "Easy and Simple Approach to do it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine breaking your streak on 31st December \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25 I redeemed coins to make up for that missed challenge but I\\'m not able to?!?! :("
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Key concept: we need to check if column is sorted or not .\\nso \\n1. we traverse the matrix by column .\\n2. in each column if any element is smaller than the previous one then that column is not sorted (count it)\\n\\nSpace complexity : O(1) \\nTime complexity : O(n*k) where n is size of vector and k is size of each string(all with same size)."
                    },
                    {
                        "username": "Namit567",
                        "content": "This code appears to be checking for how many columns need to be deleted from a list of strings in order to make the strings lexicographically sorted in ascending order.\\n\\nFor each column in the strings, the code checks if the characters at that column are in the correct order (i.e. the character in the first string is lexicographically smaller than the character in the second string, the character in the second string is lexicographically smaller than the character in the third string, and so on). If a column is out of order, the code increments the count by 1 and breaks out of the inner loop.\\n\\nFinally, the code returns the count of columns that need to be deleted."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order\n[abc] -> a b —Å are the ROWS so dont check b > a, c > b etc"
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "All good and nice practice. The bullet point of this question is that it requires to find out the number of the columns that is not sorted instead of the rows, so directly checking each elements in the given list does not work."
                    },
                    {
                        "username": "Peet_code",
                        "content": "The idea is to take each column directly, and then sort it to see if it it is equal to the original string."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Rather check order instead of sorting as sorting is heavy operation( O(n*log(n)) )"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good to solve it in a single go :)"
                    }
                ]
            },
            {
                "id": 1739729,
                "content": [
                    {
                        "username": "aka773",
                        "content": "don't ignore line 7 explanation!!!\nlets say we have\nstrs = [\"abc\", \"def\", \"ghi\"]\n see like this: \n \nfirst col :  a, d, g\nsecond:   b, e, h\nthird col:  c, f, i\n"
                    },
                    {
                        "username": "_Black_sd_",
                        "content": "\\u2705 Black Code | C++ | Brute Force\\n\\ntraversing for all column and check for non ascending order if yes then cnt++ and break the loop. check for all coulmn and return ans.\\n\\n    class Solution {\\n    public:\\n        int minDeletionSize(vector<string>& v) {\\n            int n=v.size();\\n            int m=v[0].size();\\n\\n            int cnt=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    if(v[j-1][i]>v[j][i])\\n                    {\\n                        cnt++;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return cnt;\\n        }\\n    };"
                    },
                    {
                        "username": "sourabh15072002",
                        "content": "Easy and Simple Approach to do it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine breaking your streak on 31st December \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25 I redeemed coins to make up for that missed challenge but I\\'m not able to?!?! :("
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Key concept: we need to check if column is sorted or not .\\nso \\n1. we traverse the matrix by column .\\n2. in each column if any element is smaller than the previous one then that column is not sorted (count it)\\n\\nSpace complexity : O(1) \\nTime complexity : O(n*k) where n is size of vector and k is size of each string(all with same size)."
                    },
                    {
                        "username": "Namit567",
                        "content": "This code appears to be checking for how many columns need to be deleted from a list of strings in order to make the strings lexicographically sorted in ascending order.\\n\\nFor each column in the strings, the code checks if the characters at that column are in the correct order (i.e. the character in the first string is lexicographically smaller than the character in the second string, the character in the second string is lexicographically smaller than the character in the third string, and so on). If a column is out of order, the code increments the count by 1 and breaks out of the inner loop.\\n\\nFinally, the code returns the count of columns that need to be deleted."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order\n[abc] -> a b —Å are the ROWS so dont check b > a, c > b etc"
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "All good and nice practice. The bullet point of this question is that it requires to find out the number of the columns that is not sorted instead of the rows, so directly checking each elements in the given list does not work."
                    },
                    {
                        "username": "Peet_code",
                        "content": "The idea is to take each column directly, and then sort it to see if it it is equal to the original string."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Rather check order instead of sorting as sorting is heavy operation( O(n*log(n)) )"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good to solve it in a single go :)"
                    }
                ]
            },
            {
                "id": 1739635,
                "content": [
                    {
                        "username": "aka773",
                        "content": "don't ignore line 7 explanation!!!\nlets say we have\nstrs = [\"abc\", \"def\", \"ghi\"]\n see like this: \n \nfirst col :  a, d, g\nsecond:   b, e, h\nthird col:  c, f, i\n"
                    },
                    {
                        "username": "_Black_sd_",
                        "content": "\\u2705 Black Code | C++ | Brute Force\\n\\ntraversing for all column and check for non ascending order if yes then cnt++ and break the loop. check for all coulmn and return ans.\\n\\n    class Solution {\\n    public:\\n        int minDeletionSize(vector<string>& v) {\\n            int n=v.size();\\n            int m=v[0].size();\\n\\n            int cnt=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    if(v[j-1][i]>v[j][i])\\n                    {\\n                        cnt++;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return cnt;\\n        }\\n    };"
                    },
                    {
                        "username": "sourabh15072002",
                        "content": "Easy and Simple Approach to do it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine breaking your streak on 31st December \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25 I redeemed coins to make up for that missed challenge but I\\'m not able to?!?! :("
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Key concept: we need to check if column is sorted or not .\\nso \\n1. we traverse the matrix by column .\\n2. in each column if any element is smaller than the previous one then that column is not sorted (count it)\\n\\nSpace complexity : O(1) \\nTime complexity : O(n*k) where n is size of vector and k is size of each string(all with same size)."
                    },
                    {
                        "username": "Namit567",
                        "content": "This code appears to be checking for how many columns need to be deleted from a list of strings in order to make the strings lexicographically sorted in ascending order.\\n\\nFor each column in the strings, the code checks if the characters at that column are in the correct order (i.e. the character in the first string is lexicographically smaller than the character in the second string, the character in the second string is lexicographically smaller than the character in the third string, and so on). If a column is out of order, the code increments the count by 1 and breaks out of the inner loop.\\n\\nFinally, the code returns the count of columns that need to be deleted."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order\n[abc] -> a b —Å are the ROWS so dont check b > a, c > b etc"
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "All good and nice practice. The bullet point of this question is that it requires to find out the number of the columns that is not sorted instead of the rows, so directly checking each elements in the given list does not work."
                    },
                    {
                        "username": "Peet_code",
                        "content": "The idea is to take each column directly, and then sort it to see if it it is equal to the original string."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Rather check order instead of sorting as sorting is heavy operation( O(n*log(n)) )"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good to solve it in a single go :)"
                    }
                ]
            },
            {
                "id": 1739619,
                "content": [
                    {
                        "username": "aka773",
                        "content": "don't ignore line 7 explanation!!!\nlets say we have\nstrs = [\"abc\", \"def\", \"ghi\"]\n see like this: \n \nfirst col :  a, d, g\nsecond:   b, e, h\nthird col:  c, f, i\n"
                    },
                    {
                        "username": "_Black_sd_",
                        "content": "\\u2705 Black Code | C++ | Brute Force\\n\\ntraversing for all column and check for non ascending order if yes then cnt++ and break the loop. check for all coulmn and return ans.\\n\\n    class Solution {\\n    public:\\n        int minDeletionSize(vector<string>& v) {\\n            int n=v.size();\\n            int m=v[0].size();\\n\\n            int cnt=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    if(v[j-1][i]>v[j][i])\\n                    {\\n                        cnt++;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return cnt;\\n        }\\n    };"
                    },
                    {
                        "username": "sourabh15072002",
                        "content": "Easy and Simple Approach to do it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine breaking your streak on 31st December \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25 I redeemed coins to make up for that missed challenge but I\\'m not able to?!?! :("
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Key concept: we need to check if column is sorted or not .\\nso \\n1. we traverse the matrix by column .\\n2. in each column if any element is smaller than the previous one then that column is not sorted (count it)\\n\\nSpace complexity : O(1) \\nTime complexity : O(n*k) where n is size of vector and k is size of each string(all with same size)."
                    },
                    {
                        "username": "Namit567",
                        "content": "This code appears to be checking for how many columns need to be deleted from a list of strings in order to make the strings lexicographically sorted in ascending order.\\n\\nFor each column in the strings, the code checks if the characters at that column are in the correct order (i.e. the character in the first string is lexicographically smaller than the character in the second string, the character in the second string is lexicographically smaller than the character in the third string, and so on). If a column is out of order, the code increments the count by 1 and breaks out of the inner loop.\\n\\nFinally, the code returns the count of columns that need to be deleted."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order\n[abc] -> a b —Å are the ROWS so dont check b > a, c > b etc"
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "All good and nice practice. The bullet point of this question is that it requires to find out the number of the columns that is not sorted instead of the rows, so directly checking each elements in the given list does not work."
                    },
                    {
                        "username": "Peet_code",
                        "content": "The idea is to take each column directly, and then sort it to see if it it is equal to the original string."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Rather check order instead of sorting as sorting is heavy operation( O(n*log(n)) )"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good to solve it in a single go :)"
                    }
                ]
            },
            {
                "id": 1739598,
                "content": [
                    {
                        "username": "aka773",
                        "content": "don't ignore line 7 explanation!!!\nlets say we have\nstrs = [\"abc\", \"def\", \"ghi\"]\n see like this: \n \nfirst col :  a, d, g\nsecond:   b, e, h\nthird col:  c, f, i\n"
                    },
                    {
                        "username": "_Black_sd_",
                        "content": "\\u2705 Black Code | C++ | Brute Force\\n\\ntraversing for all column and check for non ascending order if yes then cnt++ and break the loop. check for all coulmn and return ans.\\n\\n    class Solution {\\n    public:\\n        int minDeletionSize(vector<string>& v) {\\n            int n=v.size();\\n            int m=v[0].size();\\n\\n            int cnt=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    if(v[j-1][i]>v[j][i])\\n                    {\\n                        cnt++;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return cnt;\\n        }\\n    };"
                    },
                    {
                        "username": "sourabh15072002",
                        "content": "Easy and Simple Approach to do it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine breaking your streak on 31st December \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25 I redeemed coins to make up for that missed challenge but I\\'m not able to?!?! :("
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Key concept: we need to check if column is sorted or not .\\nso \\n1. we traverse the matrix by column .\\n2. in each column if any element is smaller than the previous one then that column is not sorted (count it)\\n\\nSpace complexity : O(1) \\nTime complexity : O(n*k) where n is size of vector and k is size of each string(all with same size)."
                    },
                    {
                        "username": "Namit567",
                        "content": "This code appears to be checking for how many columns need to be deleted from a list of strings in order to make the strings lexicographically sorted in ascending order.\\n\\nFor each column in the strings, the code checks if the characters at that column are in the correct order (i.e. the character in the first string is lexicographically smaller than the character in the second string, the character in the second string is lexicographically smaller than the character in the third string, and so on). If a column is out of order, the code increments the count by 1 and breaks out of the inner loop.\\n\\nFinally, the code returns the count of columns that need to be deleted."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order\n[abc] -> a b —Å are the ROWS so dont check b > a, c > b etc"
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "All good and nice practice. The bullet point of this question is that it requires to find out the number of the columns that is not sorted instead of the rows, so directly checking each elements in the given list does not work."
                    },
                    {
                        "username": "Peet_code",
                        "content": "The idea is to take each column directly, and then sort it to see if it it is equal to the original string."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Rather check order instead of sorting as sorting is heavy operation( O(n*log(n)) )"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good to solve it in a single go :)"
                    }
                ]
            },
            {
                "id": 1739592,
                "content": [
                    {
                        "username": "aka773",
                        "content": "don't ignore line 7 explanation!!!\nlets say we have\nstrs = [\"abc\", \"def\", \"ghi\"]\n see like this: \n \nfirst col :  a, d, g\nsecond:   b, e, h\nthird col:  c, f, i\n"
                    },
                    {
                        "username": "_Black_sd_",
                        "content": "\\u2705 Black Code | C++ | Brute Force\\n\\ntraversing for all column and check for non ascending order if yes then cnt++ and break the loop. check for all coulmn and return ans.\\n\\n    class Solution {\\n    public:\\n        int minDeletionSize(vector<string>& v) {\\n            int n=v.size();\\n            int m=v[0].size();\\n\\n            int cnt=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    if(v[j-1][i]>v[j][i])\\n                    {\\n                        cnt++;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return cnt;\\n        }\\n    };"
                    },
                    {
                        "username": "sourabh15072002",
                        "content": "Easy and Simple Approach to do it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine breaking your streak on 31st December \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25 I redeemed coins to make up for that missed challenge but I\\'m not able to?!?! :("
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Key concept: we need to check if column is sorted or not .\\nso \\n1. we traverse the matrix by column .\\n2. in each column if any element is smaller than the previous one then that column is not sorted (count it)\\n\\nSpace complexity : O(1) \\nTime complexity : O(n*k) where n is size of vector and k is size of each string(all with same size)."
                    },
                    {
                        "username": "Namit567",
                        "content": "This code appears to be checking for how many columns need to be deleted from a list of strings in order to make the strings lexicographically sorted in ascending order.\\n\\nFor each column in the strings, the code checks if the characters at that column are in the correct order (i.e. the character in the first string is lexicographically smaller than the character in the second string, the character in the second string is lexicographically smaller than the character in the third string, and so on). If a column is out of order, the code increments the count by 1 and breaks out of the inner loop.\\n\\nFinally, the code returns the count of columns that need to be deleted."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order\n[abc] -> a b —Å are the ROWS so dont check b > a, c > b etc"
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "All good and nice practice. The bullet point of this question is that it requires to find out the number of the columns that is not sorted instead of the rows, so directly checking each elements in the given list does not work."
                    },
                    {
                        "username": "Peet_code",
                        "content": "The idea is to take each column directly, and then sort it to see if it it is equal to the original string."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Rather check order instead of sorting as sorting is heavy operation( O(n*log(n)) )"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good to solve it in a single go :)"
                    }
                ]
            },
            {
                "id": 1739579,
                "content": [
                    {
                        "username": "aka773",
                        "content": "don't ignore line 7 explanation!!!\nlets say we have\nstrs = [\"abc\", \"def\", \"ghi\"]\n see like this: \n \nfirst col :  a, d, g\nsecond:   b, e, h\nthird col:  c, f, i\n"
                    },
                    {
                        "username": "_Black_sd_",
                        "content": "\\u2705 Black Code | C++ | Brute Force\\n\\ntraversing for all column and check for non ascending order if yes then cnt++ and break the loop. check for all coulmn and return ans.\\n\\n    class Solution {\\n    public:\\n        int minDeletionSize(vector<string>& v) {\\n            int n=v.size();\\n            int m=v[0].size();\\n\\n            int cnt=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    if(v[j-1][i]>v[j][i])\\n                    {\\n                        cnt++;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return cnt;\\n        }\\n    };"
                    },
                    {
                        "username": "sourabh15072002",
                        "content": "Easy and Simple Approach to do it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine breaking your streak on 31st December \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25 I redeemed coins to make up for that missed challenge but I\\'m not able to?!?! :("
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Key concept: we need to check if column is sorted or not .\\nso \\n1. we traverse the matrix by column .\\n2. in each column if any element is smaller than the previous one then that column is not sorted (count it)\\n\\nSpace complexity : O(1) \\nTime complexity : O(n*k) where n is size of vector and k is size of each string(all with same size)."
                    },
                    {
                        "username": "Namit567",
                        "content": "This code appears to be checking for how many columns need to be deleted from a list of strings in order to make the strings lexicographically sorted in ascending order.\\n\\nFor each column in the strings, the code checks if the characters at that column are in the correct order (i.e. the character in the first string is lexicographically smaller than the character in the second string, the character in the second string is lexicographically smaller than the character in the third string, and so on). If a column is out of order, the code increments the count by 1 and breaks out of the inner loop.\\n\\nFinally, the code returns the count of columns that need to be deleted."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order\n[abc] -> a b —Å are the ROWS so dont check b > a, c > b etc"
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "All good and nice practice. The bullet point of this question is that it requires to find out the number of the columns that is not sorted instead of the rows, so directly checking each elements in the given list does not work."
                    },
                    {
                        "username": "Peet_code",
                        "content": "The idea is to take each column directly, and then sort it to see if it it is equal to the original string."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Rather check order instead of sorting as sorting is heavy operation( O(n*log(n)) )"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good to solve it in a single go :)"
                    }
                ]
            },
            {
                "id": 1739571,
                "content": [
                    {
                        "username": "aka773",
                        "content": "don't ignore line 7 explanation!!!\nlets say we have\nstrs = [\"abc\", \"def\", \"ghi\"]\n see like this: \n \nfirst col :  a, d, g\nsecond:   b, e, h\nthird col:  c, f, i\n"
                    },
                    {
                        "username": "_Black_sd_",
                        "content": "\\u2705 Black Code | C++ | Brute Force\\n\\ntraversing for all column and check for non ascending order if yes then cnt++ and break the loop. check for all coulmn and return ans.\\n\\n    class Solution {\\n    public:\\n        int minDeletionSize(vector<string>& v) {\\n            int n=v.size();\\n            int m=v[0].size();\\n\\n            int cnt=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    if(v[j-1][i]>v[j][i])\\n                    {\\n                        cnt++;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return cnt;\\n        }\\n    };"
                    },
                    {
                        "username": "sourabh15072002",
                        "content": "Easy and Simple Approach to do it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine breaking your streak on 31st December \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25 I redeemed coins to make up for that missed challenge but I\\'m not able to?!?! :("
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Key concept: we need to check if column is sorted or not .\\nso \\n1. we traverse the matrix by column .\\n2. in each column if any element is smaller than the previous one then that column is not sorted (count it)\\n\\nSpace complexity : O(1) \\nTime complexity : O(n*k) where n is size of vector and k is size of each string(all with same size)."
                    },
                    {
                        "username": "Namit567",
                        "content": "This code appears to be checking for how many columns need to be deleted from a list of strings in order to make the strings lexicographically sorted in ascending order.\\n\\nFor each column in the strings, the code checks if the characters at that column are in the correct order (i.e. the character in the first string is lexicographically smaller than the character in the second string, the character in the second string is lexicographically smaller than the character in the third string, and so on). If a column is out of order, the code increments the count by 1 and breaks out of the inner loop.\\n\\nFinally, the code returns the count of columns that need to be deleted."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order\n[abc] -> a b —Å are the ROWS so dont check b > a, c > b etc"
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "All good and nice practice. The bullet point of this question is that it requires to find out the number of the columns that is not sorted instead of the rows, so directly checking each elements in the given list does not work."
                    },
                    {
                        "username": "Peet_code",
                        "content": "The idea is to take each column directly, and then sort it to see if it it is equal to the original string."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Rather check order instead of sorting as sorting is heavy operation( O(n*log(n)) )"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good to solve it in a single go :)"
                    }
                ]
            },
            {
                "id": 1739565,
                "content": [
                    {
                        "username": "aka773",
                        "content": "don't ignore line 7 explanation!!!\nlets say we have\nstrs = [\"abc\", \"def\", \"ghi\"]\n see like this: \n \nfirst col :  a, d, g\nsecond:   b, e, h\nthird col:  c, f, i\n"
                    },
                    {
                        "username": "_Black_sd_",
                        "content": "\\u2705 Black Code | C++ | Brute Force\\n\\ntraversing for all column and check for non ascending order if yes then cnt++ and break the loop. check for all coulmn and return ans.\\n\\n    class Solution {\\n    public:\\n        int minDeletionSize(vector<string>& v) {\\n            int n=v.size();\\n            int m=v[0].size();\\n\\n            int cnt=0;\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    if(v[j-1][i]>v[j][i])\\n                    {\\n                        cnt++;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return cnt;\\n        }\\n    };"
                    },
                    {
                        "username": "sourabh15072002",
                        "content": "Easy and Simple Approach to do it"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine breaking your streak on 31st December \\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25 I redeemed coins to make up for that missed challenge but I\\'m not able to?!?! :("
                    },
                    {
                        "username": "Amantvn1234",
                        "content": "Key concept: we need to check if column is sorted or not .\\nso \\n1. we traverse the matrix by column .\\n2. in each column if any element is smaller than the previous one then that column is not sorted (count it)\\n\\nSpace complexity : O(1) \\nTime complexity : O(n*k) where n is size of vector and k is size of each string(all with same size)."
                    },
                    {
                        "username": "Namit567",
                        "content": "This code appears to be checking for how many columns need to be deleted from a list of strings in order to make the strings lexicographically sorted in ascending order.\\n\\nFor each column in the strings, the code checks if the characters at that column are in the correct order (i.e. the character in the first string is lexicographically smaller than the character in the second string, the character in the second string is lexicographically smaller than the character in the third string, and so on). If a column is out of order, the code increments the count by 1 and breaks out of the inner loop.\\n\\nFinally, the code returns the count of columns that need to be deleted."
                    },
                    {
                        "username": "Msey",
                        "content": "the main idea is the sorting should be applied on COLUMNS in ascending order\n[abc] -> a b —Å are the ROWS so dont check b > a, c > b etc"
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "All good and nice practice. The bullet point of this question is that it requires to find out the number of the columns that is not sorted instead of the rows, so directly checking each elements in the given list does not work."
                    },
                    {
                        "username": "Peet_code",
                        "content": "The idea is to take each column directly, and then sort it to see if it it is equal to the original string."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Rather check order instead of sorting as sorting is heavy operation( O(n*log(n)) )"
                    },
                    {
                        "username": "abdul_sohail24",
                        "content": "Feels good to solve it in a single go :)"
                    }
                ]
            },
            {
                "id": 1739563,
                "content": [
                    {
                        "username": "seankala",
                        "content": "I can\\'t be the only one who didn\\'t have a problem understanding the problem... Then again, I feel like if the word \"lexicographically\" appears people get confused."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sean Yi](/seankala), descending lexical order is also lexical. They should have mentioned clearly that only ascending lexical is desired."
                    },
                    {
                        "username": "calm27",
                        "content": "pardon, i don't understand the problem. \nif any low-ego level person willing to explain, it would be nice. \nI see those big-ego unemployed kids spitting a lot in comments, but it is not useful. \n\n `abc\nbce\ncae`\n\n`bce` is not sorted, by what rule?\nwhat is the rule of ordering? \nThere are several variants and generalizations of the lexicographical ordering. \nWhich one we follow here?"
                    },
                    {
                        "username": "calm27",
                        "content": "[@belinskyi](/belinskyi) gooosh. got it. thanks a lot "
                    },
                    {
                        "username": "belinskyi",
                        "content": "[@Msey](/Msey) you\\'ve updated your answer while I was writing extended explanation :) "
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The question requires to find out the number of the COLUMNS that is not sorted instead of the rows."
                    },
                    {
                        "username": "Msey",
                        "content": "[@belinskyi](/belinskyi) but why this one is not? [\"zyx\",\"wvu\",\"tsr\"]\n\nupd: I got it. It should be sorted in ascending order"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you\\'ll see [c,e,e]. This array is sorted."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please go through the video fro easiest explanation \\nNaive Approach :\\n\\nhttps://youtu.be/3IIUFbqmXik\\n\\nOptimal Approach: \\nhttps://youtu.be/2wfg0YeYM4k"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I just hope someone finds a solution with O(n*log(n)) or less time complexity"
                    },
                    {
                        "username": "Siddhi_shah",
                        "content": "Just use two loops one for rows and other for column and increase the counter if strs[i][j]<strs[i-1][j] this is true (note : i=rows and j=column)"
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "The problem statement states that we want to delete the columns that are not sorted lexicographically, i.e. sorted in ascending order of their ASCII numbers(as in a dictionary). What would be algorithm if the problem stated that they could also be in descending order.\\n\\nExample: \"c b a\" is also correct."
                    },
                    {
                        "username": "ankit_0710",
                        "content": "please explain this code\n\nint minDeletionSize(char ** A, int ASize){\n    int count = 0, l = strlen(A[0]);\n    for(int i = 0; i < l; i++){\n        for(int j = 0; j < ASize-1; j++){\n            if(A[j][i] > A[j+1][i]){\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please upvote for the easiest explanation\\nhttps://youtu.be/3IIUFbqmXik\\n"
                    },
                    {
                        "username": "paularko64",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n       int count=0;\\n       for(int i=0;i<strs[0].length();i++)\\n       {\\n           for(int j=0;j<strs.size()-1;j++)\\n           {\\n               if(strs[j][i]>strs[j+1][i])\\n               {\\n                   count++;\\n                   break;\\n               }\\n           }\\n       } \\n       return count;\\n    }\\n};"
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Treat this as two dimensional array.\\nYou can check if ASCII char is less that before, if yes, this column need to be deleted"
                    }
                ]
            },
            {
                "id": 1739544,
                "content": [
                    {
                        "username": "seankala",
                        "content": "I can\\'t be the only one who didn\\'t have a problem understanding the problem... Then again, I feel like if the word \"lexicographically\" appears people get confused."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sean Yi](/seankala), descending lexical order is also lexical. They should have mentioned clearly that only ascending lexical is desired."
                    },
                    {
                        "username": "calm27",
                        "content": "pardon, i don't understand the problem. \nif any low-ego level person willing to explain, it would be nice. \nI see those big-ego unemployed kids spitting a lot in comments, but it is not useful. \n\n `abc\nbce\ncae`\n\n`bce` is not sorted, by what rule?\nwhat is the rule of ordering? \nThere are several variants and generalizations of the lexicographical ordering. \nWhich one we follow here?"
                    },
                    {
                        "username": "calm27",
                        "content": "[@belinskyi](/belinskyi) gooosh. got it. thanks a lot "
                    },
                    {
                        "username": "belinskyi",
                        "content": "[@Msey](/Msey) you\\'ve updated your answer while I was writing extended explanation :) "
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The question requires to find out the number of the COLUMNS that is not sorted instead of the rows."
                    },
                    {
                        "username": "Msey",
                        "content": "[@belinskyi](/belinskyi) but why this one is not? [\"zyx\",\"wvu\",\"tsr\"]\n\nupd: I got it. It should be sorted in ascending order"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you\\'ll see [c,e,e]. This array is sorted."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please go through the video fro easiest explanation \\nNaive Approach :\\n\\nhttps://youtu.be/3IIUFbqmXik\\n\\nOptimal Approach: \\nhttps://youtu.be/2wfg0YeYM4k"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I just hope someone finds a solution with O(n*log(n)) or less time complexity"
                    },
                    {
                        "username": "Siddhi_shah",
                        "content": "Just use two loops one for rows and other for column and increase the counter if strs[i][j]<strs[i-1][j] this is true (note : i=rows and j=column)"
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "The problem statement states that we want to delete the columns that are not sorted lexicographically, i.e. sorted in ascending order of their ASCII numbers(as in a dictionary). What would be algorithm if the problem stated that they could also be in descending order.\\n\\nExample: \"c b a\" is also correct."
                    },
                    {
                        "username": "ankit_0710",
                        "content": "please explain this code\n\nint minDeletionSize(char ** A, int ASize){\n    int count = 0, l = strlen(A[0]);\n    for(int i = 0; i < l; i++){\n        for(int j = 0; j < ASize-1; j++){\n            if(A[j][i] > A[j+1][i]){\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please upvote for the easiest explanation\\nhttps://youtu.be/3IIUFbqmXik\\n"
                    },
                    {
                        "username": "paularko64",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n       int count=0;\\n       for(int i=0;i<strs[0].length();i++)\\n       {\\n           for(int j=0;j<strs.size()-1;j++)\\n           {\\n               if(strs[j][i]>strs[j+1][i])\\n               {\\n                   count++;\\n                   break;\\n               }\\n           }\\n       } \\n       return count;\\n    }\\n};"
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Treat this as two dimensional array.\\nYou can check if ASCII char is less that before, if yes, this column need to be deleted"
                    }
                ]
            },
            {
                "id": 1739543,
                "content": [
                    {
                        "username": "seankala",
                        "content": "I can\\'t be the only one who didn\\'t have a problem understanding the problem... Then again, I feel like if the word \"lexicographically\" appears people get confused."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sean Yi](/seankala), descending lexical order is also lexical. They should have mentioned clearly that only ascending lexical is desired."
                    },
                    {
                        "username": "calm27",
                        "content": "pardon, i don't understand the problem. \nif any low-ego level person willing to explain, it would be nice. \nI see those big-ego unemployed kids spitting a lot in comments, but it is not useful. \n\n `abc\nbce\ncae`\n\n`bce` is not sorted, by what rule?\nwhat is the rule of ordering? \nThere are several variants and generalizations of the lexicographical ordering. \nWhich one we follow here?"
                    },
                    {
                        "username": "calm27",
                        "content": "[@belinskyi](/belinskyi) gooosh. got it. thanks a lot "
                    },
                    {
                        "username": "belinskyi",
                        "content": "[@Msey](/Msey) you\\'ve updated your answer while I was writing extended explanation :) "
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The question requires to find out the number of the COLUMNS that is not sorted instead of the rows."
                    },
                    {
                        "username": "Msey",
                        "content": "[@belinskyi](/belinskyi) but why this one is not? [\"zyx\",\"wvu\",\"tsr\"]\n\nupd: I got it. It should be sorted in ascending order"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you\\'ll see [c,e,e]. This array is sorted."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please go through the video fro easiest explanation \\nNaive Approach :\\n\\nhttps://youtu.be/3IIUFbqmXik\\n\\nOptimal Approach: \\nhttps://youtu.be/2wfg0YeYM4k"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I just hope someone finds a solution with O(n*log(n)) or less time complexity"
                    },
                    {
                        "username": "Siddhi_shah",
                        "content": "Just use two loops one for rows and other for column and increase the counter if strs[i][j]<strs[i-1][j] this is true (note : i=rows and j=column)"
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "The problem statement states that we want to delete the columns that are not sorted lexicographically, i.e. sorted in ascending order of their ASCII numbers(as in a dictionary). What would be algorithm if the problem stated that they could also be in descending order.\\n\\nExample: \"c b a\" is also correct."
                    },
                    {
                        "username": "ankit_0710",
                        "content": "please explain this code\n\nint minDeletionSize(char ** A, int ASize){\n    int count = 0, l = strlen(A[0]);\n    for(int i = 0; i < l; i++){\n        for(int j = 0; j < ASize-1; j++){\n            if(A[j][i] > A[j+1][i]){\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please upvote for the easiest explanation\\nhttps://youtu.be/3IIUFbqmXik\\n"
                    },
                    {
                        "username": "paularko64",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n       int count=0;\\n       for(int i=0;i<strs[0].length();i++)\\n       {\\n           for(int j=0;j<strs.size()-1;j++)\\n           {\\n               if(strs[j][i]>strs[j+1][i])\\n               {\\n                   count++;\\n                   break;\\n               }\\n           }\\n       } \\n       return count;\\n    }\\n};"
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Treat this as two dimensional array.\\nYou can check if ASCII char is less that before, if yes, this column need to be deleted"
                    }
                ]
            },
            {
                "id": 1739522,
                "content": [
                    {
                        "username": "seankala",
                        "content": "I can\\'t be the only one who didn\\'t have a problem understanding the problem... Then again, I feel like if the word \"lexicographically\" appears people get confused."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sean Yi](/seankala), descending lexical order is also lexical. They should have mentioned clearly that only ascending lexical is desired."
                    },
                    {
                        "username": "calm27",
                        "content": "pardon, i don't understand the problem. \nif any low-ego level person willing to explain, it would be nice. \nI see those big-ego unemployed kids spitting a lot in comments, but it is not useful. \n\n `abc\nbce\ncae`\n\n`bce` is not sorted, by what rule?\nwhat is the rule of ordering? \nThere are several variants and generalizations of the lexicographical ordering. \nWhich one we follow here?"
                    },
                    {
                        "username": "calm27",
                        "content": "[@belinskyi](/belinskyi) gooosh. got it. thanks a lot "
                    },
                    {
                        "username": "belinskyi",
                        "content": "[@Msey](/Msey) you\\'ve updated your answer while I was writing extended explanation :) "
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The question requires to find out the number of the COLUMNS that is not sorted instead of the rows."
                    },
                    {
                        "username": "Msey",
                        "content": "[@belinskyi](/belinskyi) but why this one is not? [\"zyx\",\"wvu\",\"tsr\"]\n\nupd: I got it. It should be sorted in ascending order"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you\\'ll see [c,e,e]. This array is sorted."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please go through the video fro easiest explanation \\nNaive Approach :\\n\\nhttps://youtu.be/3IIUFbqmXik\\n\\nOptimal Approach: \\nhttps://youtu.be/2wfg0YeYM4k"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I just hope someone finds a solution with O(n*log(n)) or less time complexity"
                    },
                    {
                        "username": "Siddhi_shah",
                        "content": "Just use two loops one for rows and other for column and increase the counter if strs[i][j]<strs[i-1][j] this is true (note : i=rows and j=column)"
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "The problem statement states that we want to delete the columns that are not sorted lexicographically, i.e. sorted in ascending order of their ASCII numbers(as in a dictionary). What would be algorithm if the problem stated that they could also be in descending order.\\n\\nExample: \"c b a\" is also correct."
                    },
                    {
                        "username": "ankit_0710",
                        "content": "please explain this code\n\nint minDeletionSize(char ** A, int ASize){\n    int count = 0, l = strlen(A[0]);\n    for(int i = 0; i < l; i++){\n        for(int j = 0; j < ASize-1; j++){\n            if(A[j][i] > A[j+1][i]){\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please upvote for the easiest explanation\\nhttps://youtu.be/3IIUFbqmXik\\n"
                    },
                    {
                        "username": "paularko64",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n       int count=0;\\n       for(int i=0;i<strs[0].length();i++)\\n       {\\n           for(int j=0;j<strs.size()-1;j++)\\n           {\\n               if(strs[j][i]>strs[j+1][i])\\n               {\\n                   count++;\\n                   break;\\n               }\\n           }\\n       } \\n       return count;\\n    }\\n};"
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Treat this as two dimensional array.\\nYou can check if ASCII char is less that before, if yes, this column need to be deleted"
                    }
                ]
            },
            {
                "id": 1739500,
                "content": [
                    {
                        "username": "seankala",
                        "content": "I can\\'t be the only one who didn\\'t have a problem understanding the problem... Then again, I feel like if the word \"lexicographically\" appears people get confused."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sean Yi](/seankala), descending lexical order is also lexical. They should have mentioned clearly that only ascending lexical is desired."
                    },
                    {
                        "username": "calm27",
                        "content": "pardon, i don't understand the problem. \nif any low-ego level person willing to explain, it would be nice. \nI see those big-ego unemployed kids spitting a lot in comments, but it is not useful. \n\n `abc\nbce\ncae`\n\n`bce` is not sorted, by what rule?\nwhat is the rule of ordering? \nThere are several variants and generalizations of the lexicographical ordering. \nWhich one we follow here?"
                    },
                    {
                        "username": "calm27",
                        "content": "[@belinskyi](/belinskyi) gooosh. got it. thanks a lot "
                    },
                    {
                        "username": "belinskyi",
                        "content": "[@Msey](/Msey) you\\'ve updated your answer while I was writing extended explanation :) "
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The question requires to find out the number of the COLUMNS that is not sorted instead of the rows."
                    },
                    {
                        "username": "Msey",
                        "content": "[@belinskyi](/belinskyi) but why this one is not? [\"zyx\",\"wvu\",\"tsr\"]\n\nupd: I got it. It should be sorted in ascending order"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you\\'ll see [c,e,e]. This array is sorted."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please go through the video fro easiest explanation \\nNaive Approach :\\n\\nhttps://youtu.be/3IIUFbqmXik\\n\\nOptimal Approach: \\nhttps://youtu.be/2wfg0YeYM4k"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I just hope someone finds a solution with O(n*log(n)) or less time complexity"
                    },
                    {
                        "username": "Siddhi_shah",
                        "content": "Just use two loops one for rows and other for column and increase the counter if strs[i][j]<strs[i-1][j] this is true (note : i=rows and j=column)"
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "The problem statement states that we want to delete the columns that are not sorted lexicographically, i.e. sorted in ascending order of their ASCII numbers(as in a dictionary). What would be algorithm if the problem stated that they could also be in descending order.\\n\\nExample: \"c b a\" is also correct."
                    },
                    {
                        "username": "ankit_0710",
                        "content": "please explain this code\n\nint minDeletionSize(char ** A, int ASize){\n    int count = 0, l = strlen(A[0]);\n    for(int i = 0; i < l; i++){\n        for(int j = 0; j < ASize-1; j++){\n            if(A[j][i] > A[j+1][i]){\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please upvote for the easiest explanation\\nhttps://youtu.be/3IIUFbqmXik\\n"
                    },
                    {
                        "username": "paularko64",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n       int count=0;\\n       for(int i=0;i<strs[0].length();i++)\\n       {\\n           for(int j=0;j<strs.size()-1;j++)\\n           {\\n               if(strs[j][i]>strs[j+1][i])\\n               {\\n                   count++;\\n                   break;\\n               }\\n           }\\n       } \\n       return count;\\n    }\\n};"
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Treat this as two dimensional array.\\nYou can check if ASCII char is less that before, if yes, this column need to be deleted"
                    }
                ]
            },
            {
                "id": 1739474,
                "content": [
                    {
                        "username": "seankala",
                        "content": "I can\\'t be the only one who didn\\'t have a problem understanding the problem... Then again, I feel like if the word \"lexicographically\" appears people get confused."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sean Yi](/seankala), descending lexical order is also lexical. They should have mentioned clearly that only ascending lexical is desired."
                    },
                    {
                        "username": "calm27",
                        "content": "pardon, i don't understand the problem. \nif any low-ego level person willing to explain, it would be nice. \nI see those big-ego unemployed kids spitting a lot in comments, but it is not useful. \n\n `abc\nbce\ncae`\n\n`bce` is not sorted, by what rule?\nwhat is the rule of ordering? \nThere are several variants and generalizations of the lexicographical ordering. \nWhich one we follow here?"
                    },
                    {
                        "username": "calm27",
                        "content": "[@belinskyi](/belinskyi) gooosh. got it. thanks a lot "
                    },
                    {
                        "username": "belinskyi",
                        "content": "[@Msey](/Msey) you\\'ve updated your answer while I was writing extended explanation :) "
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The question requires to find out the number of the COLUMNS that is not sorted instead of the rows."
                    },
                    {
                        "username": "Msey",
                        "content": "[@belinskyi](/belinskyi) but why this one is not? [\"zyx\",\"wvu\",\"tsr\"]\n\nupd: I got it. It should be sorted in ascending order"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you\\'ll see [c,e,e]. This array is sorted."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please go through the video fro easiest explanation \\nNaive Approach :\\n\\nhttps://youtu.be/3IIUFbqmXik\\n\\nOptimal Approach: \\nhttps://youtu.be/2wfg0YeYM4k"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I just hope someone finds a solution with O(n*log(n)) or less time complexity"
                    },
                    {
                        "username": "Siddhi_shah",
                        "content": "Just use two loops one for rows and other for column and increase the counter if strs[i][j]<strs[i-1][j] this is true (note : i=rows and j=column)"
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "The problem statement states that we want to delete the columns that are not sorted lexicographically, i.e. sorted in ascending order of their ASCII numbers(as in a dictionary). What would be algorithm if the problem stated that they could also be in descending order.\\n\\nExample: \"c b a\" is also correct."
                    },
                    {
                        "username": "ankit_0710",
                        "content": "please explain this code\n\nint minDeletionSize(char ** A, int ASize){\n    int count = 0, l = strlen(A[0]);\n    for(int i = 0; i < l; i++){\n        for(int j = 0; j < ASize-1; j++){\n            if(A[j][i] > A[j+1][i]){\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please upvote for the easiest explanation\\nhttps://youtu.be/3IIUFbqmXik\\n"
                    },
                    {
                        "username": "paularko64",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n       int count=0;\\n       for(int i=0;i<strs[0].length();i++)\\n       {\\n           for(int j=0;j<strs.size()-1;j++)\\n           {\\n               if(strs[j][i]>strs[j+1][i])\\n               {\\n                   count++;\\n                   break;\\n               }\\n           }\\n       } \\n       return count;\\n    }\\n};"
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Treat this as two dimensional array.\\nYou can check if ASCII char is less that before, if yes, this column need to be deleted"
                    }
                ]
            },
            {
                "id": 1739473,
                "content": [
                    {
                        "username": "seankala",
                        "content": "I can\\'t be the only one who didn\\'t have a problem understanding the problem... Then again, I feel like if the word \"lexicographically\" appears people get confused."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sean Yi](/seankala), descending lexical order is also lexical. They should have mentioned clearly that only ascending lexical is desired."
                    },
                    {
                        "username": "calm27",
                        "content": "pardon, i don't understand the problem. \nif any low-ego level person willing to explain, it would be nice. \nI see those big-ego unemployed kids spitting a lot in comments, but it is not useful. \n\n `abc\nbce\ncae`\n\n`bce` is not sorted, by what rule?\nwhat is the rule of ordering? \nThere are several variants and generalizations of the lexicographical ordering. \nWhich one we follow here?"
                    },
                    {
                        "username": "calm27",
                        "content": "[@belinskyi](/belinskyi) gooosh. got it. thanks a lot "
                    },
                    {
                        "username": "belinskyi",
                        "content": "[@Msey](/Msey) you\\'ve updated your answer while I was writing extended explanation :) "
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The question requires to find out the number of the COLUMNS that is not sorted instead of the rows."
                    },
                    {
                        "username": "Msey",
                        "content": "[@belinskyi](/belinskyi) but why this one is not? [\"zyx\",\"wvu\",\"tsr\"]\n\nupd: I got it. It should be sorted in ascending order"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you\\'ll see [c,e,e]. This array is sorted."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please go through the video fro easiest explanation \\nNaive Approach :\\n\\nhttps://youtu.be/3IIUFbqmXik\\n\\nOptimal Approach: \\nhttps://youtu.be/2wfg0YeYM4k"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I just hope someone finds a solution with O(n*log(n)) or less time complexity"
                    },
                    {
                        "username": "Siddhi_shah",
                        "content": "Just use two loops one for rows and other for column and increase the counter if strs[i][j]<strs[i-1][j] this is true (note : i=rows and j=column)"
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "The problem statement states that we want to delete the columns that are not sorted lexicographically, i.e. sorted in ascending order of their ASCII numbers(as in a dictionary). What would be algorithm if the problem stated that they could also be in descending order.\\n\\nExample: \"c b a\" is also correct."
                    },
                    {
                        "username": "ankit_0710",
                        "content": "please explain this code\n\nint minDeletionSize(char ** A, int ASize){\n    int count = 0, l = strlen(A[0]);\n    for(int i = 0; i < l; i++){\n        for(int j = 0; j < ASize-1; j++){\n            if(A[j][i] > A[j+1][i]){\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please upvote for the easiest explanation\\nhttps://youtu.be/3IIUFbqmXik\\n"
                    },
                    {
                        "username": "paularko64",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n       int count=0;\\n       for(int i=0;i<strs[0].length();i++)\\n       {\\n           for(int j=0;j<strs.size()-1;j++)\\n           {\\n               if(strs[j][i]>strs[j+1][i])\\n               {\\n                   count++;\\n                   break;\\n               }\\n           }\\n       } \\n       return count;\\n    }\\n};"
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Treat this as two dimensional array.\\nYou can check if ASCII char is less that before, if yes, this column need to be deleted"
                    }
                ]
            },
            {
                "id": 1739449,
                "content": [
                    {
                        "username": "seankala",
                        "content": "I can\\'t be the only one who didn\\'t have a problem understanding the problem... Then again, I feel like if the word \"lexicographically\" appears people get confused."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sean Yi](/seankala), descending lexical order is also lexical. They should have mentioned clearly that only ascending lexical is desired."
                    },
                    {
                        "username": "calm27",
                        "content": "pardon, i don't understand the problem. \nif any low-ego level person willing to explain, it would be nice. \nI see those big-ego unemployed kids spitting a lot in comments, but it is not useful. \n\n `abc\nbce\ncae`\n\n`bce` is not sorted, by what rule?\nwhat is the rule of ordering? \nThere are several variants and generalizations of the lexicographical ordering. \nWhich one we follow here?"
                    },
                    {
                        "username": "calm27",
                        "content": "[@belinskyi](/belinskyi) gooosh. got it. thanks a lot "
                    },
                    {
                        "username": "belinskyi",
                        "content": "[@Msey](/Msey) you\\'ve updated your answer while I was writing extended explanation :) "
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The question requires to find out the number of the COLUMNS that is not sorted instead of the rows."
                    },
                    {
                        "username": "Msey",
                        "content": "[@belinskyi](/belinskyi) but why this one is not? [\"zyx\",\"wvu\",\"tsr\"]\n\nupd: I got it. It should be sorted in ascending order"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you\\'ll see [c,e,e]. This array is sorted."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please go through the video fro easiest explanation \\nNaive Approach :\\n\\nhttps://youtu.be/3IIUFbqmXik\\n\\nOptimal Approach: \\nhttps://youtu.be/2wfg0YeYM4k"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I just hope someone finds a solution with O(n*log(n)) or less time complexity"
                    },
                    {
                        "username": "Siddhi_shah",
                        "content": "Just use two loops one for rows and other for column and increase the counter if strs[i][j]<strs[i-1][j] this is true (note : i=rows and j=column)"
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "The problem statement states that we want to delete the columns that are not sorted lexicographically, i.e. sorted in ascending order of their ASCII numbers(as in a dictionary). What would be algorithm if the problem stated that they could also be in descending order.\\n\\nExample: \"c b a\" is also correct."
                    },
                    {
                        "username": "ankit_0710",
                        "content": "please explain this code\n\nint minDeletionSize(char ** A, int ASize){\n    int count = 0, l = strlen(A[0]);\n    for(int i = 0; i < l; i++){\n        for(int j = 0; j < ASize-1; j++){\n            if(A[j][i] > A[j+1][i]){\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please upvote for the easiest explanation\\nhttps://youtu.be/3IIUFbqmXik\\n"
                    },
                    {
                        "username": "paularko64",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n       int count=0;\\n       for(int i=0;i<strs[0].length();i++)\\n       {\\n           for(int j=0;j<strs.size()-1;j++)\\n           {\\n               if(strs[j][i]>strs[j+1][i])\\n               {\\n                   count++;\\n                   break;\\n               }\\n           }\\n       } \\n       return count;\\n    }\\n};"
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Treat this as two dimensional array.\\nYou can check if ASCII char is less that before, if yes, this column need to be deleted"
                    }
                ]
            },
            {
                "id": 1739416,
                "content": [
                    {
                        "username": "seankala",
                        "content": "I can\\'t be the only one who didn\\'t have a problem understanding the problem... Then again, I feel like if the word \"lexicographically\" appears people get confused."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sean Yi](/seankala), descending lexical order is also lexical. They should have mentioned clearly that only ascending lexical is desired."
                    },
                    {
                        "username": "calm27",
                        "content": "pardon, i don't understand the problem. \nif any low-ego level person willing to explain, it would be nice. \nI see those big-ego unemployed kids spitting a lot in comments, but it is not useful. \n\n `abc\nbce\ncae`\n\n`bce` is not sorted, by what rule?\nwhat is the rule of ordering? \nThere are several variants and generalizations of the lexicographical ordering. \nWhich one we follow here?"
                    },
                    {
                        "username": "calm27",
                        "content": "[@belinskyi](/belinskyi) gooosh. got it. thanks a lot "
                    },
                    {
                        "username": "belinskyi",
                        "content": "[@Msey](/Msey) you\\'ve updated your answer while I was writing extended explanation :) "
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The question requires to find out the number of the COLUMNS that is not sorted instead of the rows."
                    },
                    {
                        "username": "Msey",
                        "content": "[@belinskyi](/belinskyi) but why this one is not? [\"zyx\",\"wvu\",\"tsr\"]\n\nupd: I got it. It should be sorted in ascending order"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you\\'ll see [c,e,e]. This array is sorted."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please go through the video fro easiest explanation \\nNaive Approach :\\n\\nhttps://youtu.be/3IIUFbqmXik\\n\\nOptimal Approach: \\nhttps://youtu.be/2wfg0YeYM4k"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I just hope someone finds a solution with O(n*log(n)) or less time complexity"
                    },
                    {
                        "username": "Siddhi_shah",
                        "content": "Just use two loops one for rows and other for column and increase the counter if strs[i][j]<strs[i-1][j] this is true (note : i=rows and j=column)"
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "The problem statement states that we want to delete the columns that are not sorted lexicographically, i.e. sorted in ascending order of their ASCII numbers(as in a dictionary). What would be algorithm if the problem stated that they could also be in descending order.\\n\\nExample: \"c b a\" is also correct."
                    },
                    {
                        "username": "ankit_0710",
                        "content": "please explain this code\n\nint minDeletionSize(char ** A, int ASize){\n    int count = 0, l = strlen(A[0]);\n    for(int i = 0; i < l; i++){\n        for(int j = 0; j < ASize-1; j++){\n            if(A[j][i] > A[j+1][i]){\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please upvote for the easiest explanation\\nhttps://youtu.be/3IIUFbqmXik\\n"
                    },
                    {
                        "username": "paularko64",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n       int count=0;\\n       for(int i=0;i<strs[0].length();i++)\\n       {\\n           for(int j=0;j<strs.size()-1;j++)\\n           {\\n               if(strs[j][i]>strs[j+1][i])\\n               {\\n                   count++;\\n                   break;\\n               }\\n           }\\n       } \\n       return count;\\n    }\\n};"
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Treat this as two dimensional array.\\nYou can check if ASCII char is less that before, if yes, this column need to be deleted"
                    }
                ]
            },
            {
                "id": 1739412,
                "content": [
                    {
                        "username": "seankala",
                        "content": "I can\\'t be the only one who didn\\'t have a problem understanding the problem... Then again, I feel like if the word \"lexicographically\" appears people get confused."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Sean Yi](/seankala), descending lexical order is also lexical. They should have mentioned clearly that only ascending lexical is desired."
                    },
                    {
                        "username": "calm27",
                        "content": "pardon, i don't understand the problem. \nif any low-ego level person willing to explain, it would be nice. \nI see those big-ego unemployed kids spitting a lot in comments, but it is not useful. \n\n `abc\nbce\ncae`\n\n`bce` is not sorted, by what rule?\nwhat is the rule of ordering? \nThere are several variants and generalizations of the lexicographical ordering. \nWhich one we follow here?"
                    },
                    {
                        "username": "calm27",
                        "content": "[@belinskyi](/belinskyi) gooosh. got it. thanks a lot "
                    },
                    {
                        "username": "belinskyi",
                        "content": "[@Msey](/Msey) you\\'ve updated your answer while I was writing extended explanation :) "
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The question requires to find out the number of the COLUMNS that is not sorted instead of the rows."
                    },
                    {
                        "username": "Msey",
                        "content": "[@belinskyi](/belinskyi) but why this one is not? [\"zyx\",\"wvu\",\"tsr\"]\n\nupd: I got it. It should be sorted in ascending order"
                    },
                    {
                        "username": "belinskyi",
                        "content": "You should review character at each index and evaluate if it is sorted, e.g. :\\nstrs = [\"abc\", \"bce\", \"cae\"] -> take chars at the second index in each word and you\\'ll see [c,e,e]. This array is sorted."
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please go through the video fro easiest explanation \\nNaive Approach :\\n\\nhttps://youtu.be/3IIUFbqmXik\\n\\nOptimal Approach: \\nhttps://youtu.be/2wfg0YeYM4k"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I just hope someone finds a solution with O(n*log(n)) or less time complexity"
                    },
                    {
                        "username": "Siddhi_shah",
                        "content": "Just use two loops one for rows and other for column and increase the counter if strs[i][j]<strs[i-1][j] this is true (note : i=rows and j=column)"
                    },
                    {
                        "username": "harrysodhi1000",
                        "content": "The problem statement states that we want to delete the columns that are not sorted lexicographically, i.e. sorted in ascending order of their ASCII numbers(as in a dictionary). What would be algorithm if the problem stated that they could also be in descending order.\\n\\nExample: \"c b a\" is also correct."
                    },
                    {
                        "username": "ankit_0710",
                        "content": "please explain this code\n\nint minDeletionSize(char ** A, int ASize){\n    int count = 0, l = strlen(A[0]);\n    for(int i = 0; i < l; i++){\n        for(int j = 0; j < ASize-1; j++){\n            if(A[j][i] > A[j+1][i]){\n                count++;\n                break;\n            }\n        }\n    }\n    return count;\n}"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please upvote for the easiest explanation\\nhttps://youtu.be/3IIUFbqmXik\\n"
                    },
                    {
                        "username": "paularko64",
                        "content": "class Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n       int count=0;\\n       for(int i=0;i<strs[0].length();i++)\\n       {\\n           for(int j=0;j<strs.size()-1;j++)\\n           {\\n               if(strs[j][i]>strs[j+1][i])\\n               {\\n                   count++;\\n                   break;\\n               }\\n           }\\n       } \\n       return count;\\n    }\\n};"
                    },
                    {
                        "username": "piotrkow93",
                        "content": "Treat this as two dimensional array.\\nYou can check if ASCII char is less that before, if yes, this column need to be deleted"
                    }
                ]
            },
            {
                "id": 1739397,
                "content": [
                    {
                        "username": "USEBRAIN",
                        "content": "It is fairly simple question \\n- We will just iterate over the column \\n- Check whether the previous char is smaller or not \\n- If previous character is larger then current character  then we will increase the count by one and break the inner loop\\n- return the count . "
                    },
                    {
                        "username": "SJTGSHIVAM",
                        "content": "This new UI for testcases is so annoying, previous one was easier to use when we wanted multiple testcases, now it has an upper cap of 8 cases and for that too we have to click on a \"+\" button then erase older one and then type new one"
                    },
                    {
                        "username": "ankit_0710",
                        "content": "hope you all get 365 streak this year all the best guys"
                    },
                    {
                        "username": "sonusahu050502",
                        "content": "Doing this problem just to maintain the streak.....\\nbasic problem."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2990706/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "haider1210",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003459c0 bp 0x7ffece5de990 sp 0x7ffece5de920 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #2 0x7fbd181ec0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\nwhy is this problem coming?\\n"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Your code has undefined behavior for any input I guess , You are trying to access some index that doesn't present/exist or may be you are dereferencing a null pointer ,Debug your code once. "
                    },
                    {
                        "username": "Love_Barot",
                        "content": "its a easy problem but I cant understand why so much people dislike this problem...!"
                    },
                    {
                        "username": "andreasdua21",
                        "content": "If you don\\'t understand the question, the main thing is, it need sorted at every *COLUMN*, not every row. At first I see the question, my perspective stuck at comparing row, and, at first I think the example is false. \\n\\nI think it happens bcs the input is array of string, not two dimensional array. \\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "Why are there so many dislikes for this question?"
                    },
                    {
                        "username": "user3043Jk",
                        "content": "I couldn\\'t understand the first example of this question as the output is 1 but should be 2 no? "
                    },
                    {
                        "username": "ii_m_ss",
                        "content": "output is just counting the number of deleted columns."
                    }
                ]
            },
            {
                "id": 1739368,
                "content": [
                    {
                        "username": "USEBRAIN",
                        "content": "It is fairly simple question \\n- We will just iterate over the column \\n- Check whether the previous char is smaller or not \\n- If previous character is larger then current character  then we will increase the count by one and break the inner loop\\n- return the count . "
                    },
                    {
                        "username": "SJTGSHIVAM",
                        "content": "This new UI for testcases is so annoying, previous one was easier to use when we wanted multiple testcases, now it has an upper cap of 8 cases and for that too we have to click on a \"+\" button then erase older one and then type new one"
                    },
                    {
                        "username": "ankit_0710",
                        "content": "hope you all get 365 streak this year all the best guys"
                    },
                    {
                        "username": "sonusahu050502",
                        "content": "Doing this problem just to maintain the streak.....\\nbasic problem."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2990706/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "haider1210",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003459c0 bp 0x7ffece5de990 sp 0x7ffece5de920 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #2 0x7fbd181ec0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\nwhy is this problem coming?\\n"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Your code has undefined behavior for any input I guess , You are trying to access some index that doesn't present/exist or may be you are dereferencing a null pointer ,Debug your code once. "
                    },
                    {
                        "username": "Love_Barot",
                        "content": "its a easy problem but I cant understand why so much people dislike this problem...!"
                    },
                    {
                        "username": "andreasdua21",
                        "content": "If you don\\'t understand the question, the main thing is, it need sorted at every *COLUMN*, not every row. At first I see the question, my perspective stuck at comparing row, and, at first I think the example is false. \\n\\nI think it happens bcs the input is array of string, not two dimensional array. \\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "Why are there so many dislikes for this question?"
                    },
                    {
                        "username": "user3043Jk",
                        "content": "I couldn\\'t understand the first example of this question as the output is 1 but should be 2 no? "
                    },
                    {
                        "username": "ii_m_ss",
                        "content": "output is just counting the number of deleted columns."
                    }
                ]
            },
            {
                "id": 1739354,
                "content": [
                    {
                        "username": "USEBRAIN",
                        "content": "It is fairly simple question \\n- We will just iterate over the column \\n- Check whether the previous char is smaller or not \\n- If previous character is larger then current character  then we will increase the count by one and break the inner loop\\n- return the count . "
                    },
                    {
                        "username": "SJTGSHIVAM",
                        "content": "This new UI for testcases is so annoying, previous one was easier to use when we wanted multiple testcases, now it has an upper cap of 8 cases and for that too we have to click on a \"+\" button then erase older one and then type new one"
                    },
                    {
                        "username": "ankit_0710",
                        "content": "hope you all get 365 streak this year all the best guys"
                    },
                    {
                        "username": "sonusahu050502",
                        "content": "Doing this problem just to maintain the streak.....\\nbasic problem."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2990706/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "haider1210",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003459c0 bp 0x7ffece5de990 sp 0x7ffece5de920 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #2 0x7fbd181ec0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\nwhy is this problem coming?\\n"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Your code has undefined behavior for any input I guess , You are trying to access some index that doesn't present/exist or may be you are dereferencing a null pointer ,Debug your code once. "
                    },
                    {
                        "username": "Love_Barot",
                        "content": "its a easy problem but I cant understand why so much people dislike this problem...!"
                    },
                    {
                        "username": "andreasdua21",
                        "content": "If you don\\'t understand the question, the main thing is, it need sorted at every *COLUMN*, not every row. At first I see the question, my perspective stuck at comparing row, and, at first I think the example is false. \\n\\nI think it happens bcs the input is array of string, not two dimensional array. \\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "Why are there so many dislikes for this question?"
                    },
                    {
                        "username": "user3043Jk",
                        "content": "I couldn\\'t understand the first example of this question as the output is 1 but should be 2 no? "
                    },
                    {
                        "username": "ii_m_ss",
                        "content": "output is just counting the number of deleted columns."
                    }
                ]
            },
            {
                "id": 1739316,
                "content": [
                    {
                        "username": "USEBRAIN",
                        "content": "It is fairly simple question \\n- We will just iterate over the column \\n- Check whether the previous char is smaller or not \\n- If previous character is larger then current character  then we will increase the count by one and break the inner loop\\n- return the count . "
                    },
                    {
                        "username": "SJTGSHIVAM",
                        "content": "This new UI for testcases is so annoying, previous one was easier to use when we wanted multiple testcases, now it has an upper cap of 8 cases and for that too we have to click on a \"+\" button then erase older one and then type new one"
                    },
                    {
                        "username": "ankit_0710",
                        "content": "hope you all get 365 streak this year all the best guys"
                    },
                    {
                        "username": "sonusahu050502",
                        "content": "Doing this problem just to maintain the streak.....\\nbasic problem."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2990706/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "haider1210",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003459c0 bp 0x7ffece5de990 sp 0x7ffece5de920 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #2 0x7fbd181ec0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\nwhy is this problem coming?\\n"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Your code has undefined behavior for any input I guess , You are trying to access some index that doesn't present/exist or may be you are dereferencing a null pointer ,Debug your code once. "
                    },
                    {
                        "username": "Love_Barot",
                        "content": "its a easy problem but I cant understand why so much people dislike this problem...!"
                    },
                    {
                        "username": "andreasdua21",
                        "content": "If you don\\'t understand the question, the main thing is, it need sorted at every *COLUMN*, not every row. At first I see the question, my perspective stuck at comparing row, and, at first I think the example is false. \\n\\nI think it happens bcs the input is array of string, not two dimensional array. \\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "Why are there so many dislikes for this question?"
                    },
                    {
                        "username": "user3043Jk",
                        "content": "I couldn\\'t understand the first example of this question as the output is 1 but should be 2 no? "
                    },
                    {
                        "username": "ii_m_ss",
                        "content": "output is just counting the number of deleted columns."
                    }
                ]
            },
            {
                "id": 1739313,
                "content": [
                    {
                        "username": "USEBRAIN",
                        "content": "It is fairly simple question \\n- We will just iterate over the column \\n- Check whether the previous char is smaller or not \\n- If previous character is larger then current character  then we will increase the count by one and break the inner loop\\n- return the count . "
                    },
                    {
                        "username": "SJTGSHIVAM",
                        "content": "This new UI for testcases is so annoying, previous one was easier to use when we wanted multiple testcases, now it has an upper cap of 8 cases and for that too we have to click on a \"+\" button then erase older one and then type new one"
                    },
                    {
                        "username": "ankit_0710",
                        "content": "hope you all get 365 streak this year all the best guys"
                    },
                    {
                        "username": "sonusahu050502",
                        "content": "Doing this problem just to maintain the streak.....\\nbasic problem."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2990706/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "haider1210",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003459c0 bp 0x7ffece5de990 sp 0x7ffece5de920 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #2 0x7fbd181ec0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\nwhy is this problem coming?\\n"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Your code has undefined behavior for any input I guess , You are trying to access some index that doesn't present/exist or may be you are dereferencing a null pointer ,Debug your code once. "
                    },
                    {
                        "username": "Love_Barot",
                        "content": "its a easy problem but I cant understand why so much people dislike this problem...!"
                    },
                    {
                        "username": "andreasdua21",
                        "content": "If you don\\'t understand the question, the main thing is, it need sorted at every *COLUMN*, not every row. At first I see the question, my perspective stuck at comparing row, and, at first I think the example is false. \\n\\nI think it happens bcs the input is array of string, not two dimensional array. \\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "Why are there so many dislikes for this question?"
                    },
                    {
                        "username": "user3043Jk",
                        "content": "I couldn\\'t understand the first example of this question as the output is 1 but should be 2 no? "
                    },
                    {
                        "username": "ii_m_ss",
                        "content": "output is just counting the number of deleted columns."
                    }
                ]
            },
            {
                "id": 1739310,
                "content": [
                    {
                        "username": "USEBRAIN",
                        "content": "It is fairly simple question \\n- We will just iterate over the column \\n- Check whether the previous char is smaller or not \\n- If previous character is larger then current character  then we will increase the count by one and break the inner loop\\n- return the count . "
                    },
                    {
                        "username": "SJTGSHIVAM",
                        "content": "This new UI for testcases is so annoying, previous one was easier to use when we wanted multiple testcases, now it has an upper cap of 8 cases and for that too we have to click on a \"+\" button then erase older one and then type new one"
                    },
                    {
                        "username": "ankit_0710",
                        "content": "hope you all get 365 streak this year all the best guys"
                    },
                    {
                        "username": "sonusahu050502",
                        "content": "Doing this problem just to maintain the streak.....\\nbasic problem."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2990706/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "haider1210",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003459c0 bp 0x7ffece5de990 sp 0x7ffece5de920 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #2 0x7fbd181ec0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\nwhy is this problem coming?\\n"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Your code has undefined behavior for any input I guess , You are trying to access some index that doesn't present/exist or may be you are dereferencing a null pointer ,Debug your code once. "
                    },
                    {
                        "username": "Love_Barot",
                        "content": "its a easy problem but I cant understand why so much people dislike this problem...!"
                    },
                    {
                        "username": "andreasdua21",
                        "content": "If you don\\'t understand the question, the main thing is, it need sorted at every *COLUMN*, not every row. At first I see the question, my perspective stuck at comparing row, and, at first I think the example is false. \\n\\nI think it happens bcs the input is array of string, not two dimensional array. \\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "Why are there so many dislikes for this question?"
                    },
                    {
                        "username": "user3043Jk",
                        "content": "I couldn\\'t understand the first example of this question as the output is 1 but should be 2 no? "
                    },
                    {
                        "username": "ii_m_ss",
                        "content": "output is just counting the number of deleted columns."
                    }
                ]
            },
            {
                "id": 1739303,
                "content": [
                    {
                        "username": "USEBRAIN",
                        "content": "It is fairly simple question \\n- We will just iterate over the column \\n- Check whether the previous char is smaller or not \\n- If previous character is larger then current character  then we will increase the count by one and break the inner loop\\n- return the count . "
                    },
                    {
                        "username": "SJTGSHIVAM",
                        "content": "This new UI for testcases is so annoying, previous one was easier to use when we wanted multiple testcases, now it has an upper cap of 8 cases and for that too we have to click on a \"+\" button then erase older one and then type new one"
                    },
                    {
                        "username": "ankit_0710",
                        "content": "hope you all get 365 streak this year all the best guys"
                    },
                    {
                        "username": "sonusahu050502",
                        "content": "Doing this problem just to maintain the streak.....\\nbasic problem."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2990706/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "haider1210",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003459c0 bp 0x7ffece5de990 sp 0x7ffece5de920 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #2 0x7fbd181ec0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\nwhy is this problem coming?\\n"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Your code has undefined behavior for any input I guess , You are trying to access some index that doesn't present/exist or may be you are dereferencing a null pointer ,Debug your code once. "
                    },
                    {
                        "username": "Love_Barot",
                        "content": "its a easy problem but I cant understand why so much people dislike this problem...!"
                    },
                    {
                        "username": "andreasdua21",
                        "content": "If you don\\'t understand the question, the main thing is, it need sorted at every *COLUMN*, not every row. At first I see the question, my perspective stuck at comparing row, and, at first I think the example is false. \\n\\nI think it happens bcs the input is array of string, not two dimensional array. \\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "Why are there so many dislikes for this question?"
                    },
                    {
                        "username": "user3043Jk",
                        "content": "I couldn\\'t understand the first example of this question as the output is 1 but should be 2 no? "
                    },
                    {
                        "username": "ii_m_ss",
                        "content": "output is just counting the number of deleted columns."
                    }
                ]
            },
            {
                "id": 1739291,
                "content": [
                    {
                        "username": "USEBRAIN",
                        "content": "It is fairly simple question \\n- We will just iterate over the column \\n- Check whether the previous char is smaller or not \\n- If previous character is larger then current character  then we will increase the count by one and break the inner loop\\n- return the count . "
                    },
                    {
                        "username": "SJTGSHIVAM",
                        "content": "This new UI for testcases is so annoying, previous one was easier to use when we wanted multiple testcases, now it has an upper cap of 8 cases and for that too we have to click on a \"+\" button then erase older one and then type new one"
                    },
                    {
                        "username": "ankit_0710",
                        "content": "hope you all get 365 streak this year all the best guys"
                    },
                    {
                        "username": "sonusahu050502",
                        "content": "Doing this problem just to maintain the streak.....\\nbasic problem."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2990706/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "haider1210",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003459c0 bp 0x7ffece5de990 sp 0x7ffece5de920 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #2 0x7fbd181ec0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\nwhy is this problem coming?\\n"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Your code has undefined behavior for any input I guess , You are trying to access some index that doesn't present/exist or may be you are dereferencing a null pointer ,Debug your code once. "
                    },
                    {
                        "username": "Love_Barot",
                        "content": "its a easy problem but I cant understand why so much people dislike this problem...!"
                    },
                    {
                        "username": "andreasdua21",
                        "content": "If you don\\'t understand the question, the main thing is, it need sorted at every *COLUMN*, not every row. At first I see the question, my perspective stuck at comparing row, and, at first I think the example is false. \\n\\nI think it happens bcs the input is array of string, not two dimensional array. \\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "Why are there so many dislikes for this question?"
                    },
                    {
                        "username": "user3043Jk",
                        "content": "I couldn\\'t understand the first example of this question as the output is 1 but should be 2 no? "
                    },
                    {
                        "username": "ii_m_ss",
                        "content": "output is just counting the number of deleted columns."
                    }
                ]
            },
            {
                "id": 1739237,
                "content": [
                    {
                        "username": "USEBRAIN",
                        "content": "It is fairly simple question \\n- We will just iterate over the column \\n- Check whether the previous char is smaller or not \\n- If previous character is larger then current character  then we will increase the count by one and break the inner loop\\n- return the count . "
                    },
                    {
                        "username": "SJTGSHIVAM",
                        "content": "This new UI for testcases is so annoying, previous one was easier to use when we wanted multiple testcases, now it has an upper cap of 8 cases and for that too we have to click on a \"+\" button then erase older one and then type new one"
                    },
                    {
                        "username": "ankit_0710",
                        "content": "hope you all get 365 streak this year all the best guys"
                    },
                    {
                        "username": "sonusahu050502",
                        "content": "Doing this problem just to maintain the streak.....\\nbasic problem."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2990706/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "haider1210",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003459c0 bp 0x7ffece5de990 sp 0x7ffece5de920 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #2 0x7fbd181ec0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\nwhy is this problem coming?\\n"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Your code has undefined behavior for any input I guess , You are trying to access some index that doesn't present/exist or may be you are dereferencing a null pointer ,Debug your code once. "
                    },
                    {
                        "username": "Love_Barot",
                        "content": "its a easy problem but I cant understand why so much people dislike this problem...!"
                    },
                    {
                        "username": "andreasdua21",
                        "content": "If you don\\'t understand the question, the main thing is, it need sorted at every *COLUMN*, not every row. At first I see the question, my perspective stuck at comparing row, and, at first I think the example is false. \\n\\nI think it happens bcs the input is array of string, not two dimensional array. \\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "Why are there so many dislikes for this question?"
                    },
                    {
                        "username": "user3043Jk",
                        "content": "I couldn\\'t understand the first example of this question as the output is 1 but should be 2 no? "
                    },
                    {
                        "username": "ii_m_ss",
                        "content": "output is just counting the number of deleted columns."
                    }
                ]
            },
            {
                "id": 1739236,
                "content": [
                    {
                        "username": "USEBRAIN",
                        "content": "It is fairly simple question \\n- We will just iterate over the column \\n- Check whether the previous char is smaller or not \\n- If previous character is larger then current character  then we will increase the count by one and break the inner loop\\n- return the count . "
                    },
                    {
                        "username": "SJTGSHIVAM",
                        "content": "This new UI for testcases is so annoying, previous one was easier to use when we wanted multiple testcases, now it has an upper cap of 8 cases and for that too we have to click on a \"+\" button then erase older one and then type new one"
                    },
                    {
                        "username": "ankit_0710",
                        "content": "hope you all get 365 streak this year all the best guys"
                    },
                    {
                        "username": "sonusahu050502",
                        "content": "Doing this problem just to maintain the streak.....\\nbasic problem."
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2990706/simple-java-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "haider1210",
                        "content": "AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==31==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x0000003459c0 bp 0x7ffece5de990 sp 0x7ffece5de920 T0)\\n==31==The signal is caused by a READ memory access.\\n==31==Hint: this fault was caused by a dereference of a high value address (see register values below).  Dissassemble the provided pc to learn which register was used.\\n    #2 0x7fbd181ec0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nAddressSanitizer can not provide additional info.\\n==31==ABORTING\\n\\nwhy is this problem coming?\\n"
                    },
                    {
                        "username": "sachinbaral02",
                        "content": "Your code has undefined behavior for any input I guess , You are trying to access some index that doesn't present/exist or may be you are dereferencing a null pointer ,Debug your code once. "
                    },
                    {
                        "username": "Love_Barot",
                        "content": "its a easy problem but I cant understand why so much people dislike this problem...!"
                    },
                    {
                        "username": "andreasdua21",
                        "content": "If you don\\'t understand the question, the main thing is, it need sorted at every *COLUMN*, not every row. At first I see the question, my perspective stuck at comparing row, and, at first I think the example is false. \\n\\nI think it happens bcs the input is array of string, not two dimensional array. \\n"
                    },
                    {
                        "username": "_horiZon_OP",
                        "content": "Why are there so many dislikes for this question?"
                    },
                    {
                        "username": "user3043Jk",
                        "content": "I couldn\\'t understand the first example of this question as the output is 1 but should be 2 no? "
                    },
                    {
                        "username": "ii_m_ss",
                        "content": "output is just counting the number of deleted columns."
                    }
                ]
            },
            {
                "id": 1739231,
                "content": [
                    {
                        "username": "Maxx_1007",
                        "content": "Why this problem has so many downvotes?"
                    },
                    {
                        "username": "Sumit70421",
                        "content": "Is there any solution which takes linear time? I went through all solutions nobody did it in linear time."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "linear time is the only solution possible, you have to go through all characters in all strings O(n*m) which is linear for this case."
                    },
                    {
                        "username": "santanusen",
                        "content": "It was quite difficult for me to get a good timing using C++ with brute-force nested loop-columns  loop-rows approach. I got little better timing by looping from the last row to the first. May be the test cases are designed such."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "first to last, or last to first : anyway comparison is bound to happen. They have same complexity. The reason you got better time in second submission is that leetcode submissions for same code themselves have hugely varying time. So I don\\'t give much significance to the %tile of time, rather the actual time which is in 30-50 ms range for all sane submissions."
                    },
                    {
                        "username": "surajku2022",
                        "content": "Why this question has so many dislikes, I don\\'t find it hard to read or hard to implement."
                    },
                    {
                        "username": "js5809",
                        "content": "A fairly simple problem. Only the wording of the problem statement can be improved for easier understanding by everyone."
                    },
                    {
                        "username": "gugansps64",
                        "content": "Why my solution\\'s runtime is 18ms, I don\\'t find much difference with the 4ms solution and mine.\\nBelow is my solution, can anyone explain?\\n\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "aym_n",
                        "content": "I have used two for loops to check condition for each pair , but the runtime is like 5s. is there a way i can optimize this?"
                    },
                    {
                        "username": "rajkanwar",
                        "content": "if say strs = [\"c\",\"b\"] would the output be 1?"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "yes,  output will be one"
                    },
                    {
                        "username": "gnarendra89",
                        "content": "I think this problem doesn\\'t deserve to be disliked at all."
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Why so many dislikes for this question?"
                    }
                ]
            },
            {
                "id": 1739218,
                "content": [
                    {
                        "username": "Maxx_1007",
                        "content": "Why this problem has so many downvotes?"
                    },
                    {
                        "username": "Sumit70421",
                        "content": "Is there any solution which takes linear time? I went through all solutions nobody did it in linear time."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "linear time is the only solution possible, you have to go through all characters in all strings O(n*m) which is linear for this case."
                    },
                    {
                        "username": "santanusen",
                        "content": "It was quite difficult for me to get a good timing using C++ with brute-force nested loop-columns  loop-rows approach. I got little better timing by looping from the last row to the first. May be the test cases are designed such."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "first to last, or last to first : anyway comparison is bound to happen. They have same complexity. The reason you got better time in second submission is that leetcode submissions for same code themselves have hugely varying time. So I don\\'t give much significance to the %tile of time, rather the actual time which is in 30-50 ms range for all sane submissions."
                    },
                    {
                        "username": "surajku2022",
                        "content": "Why this question has so many dislikes, I don\\'t find it hard to read or hard to implement."
                    },
                    {
                        "username": "js5809",
                        "content": "A fairly simple problem. Only the wording of the problem statement can be improved for easier understanding by everyone."
                    },
                    {
                        "username": "gugansps64",
                        "content": "Why my solution\\'s runtime is 18ms, I don\\'t find much difference with the 4ms solution and mine.\\nBelow is my solution, can anyone explain?\\n\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "aym_n",
                        "content": "I have used two for loops to check condition for each pair , but the runtime is like 5s. is there a way i can optimize this?"
                    },
                    {
                        "username": "rajkanwar",
                        "content": "if say strs = [\"c\",\"b\"] would the output be 1?"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "yes,  output will be one"
                    },
                    {
                        "username": "gnarendra89",
                        "content": "I think this problem doesn\\'t deserve to be disliked at all."
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Why so many dislikes for this question?"
                    }
                ]
            },
            {
                "id": 1739213,
                "content": [
                    {
                        "username": "Maxx_1007",
                        "content": "Why this problem has so many downvotes?"
                    },
                    {
                        "username": "Sumit70421",
                        "content": "Is there any solution which takes linear time? I went through all solutions nobody did it in linear time."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "linear time is the only solution possible, you have to go through all characters in all strings O(n*m) which is linear for this case."
                    },
                    {
                        "username": "santanusen",
                        "content": "It was quite difficult for me to get a good timing using C++ with brute-force nested loop-columns  loop-rows approach. I got little better timing by looping from the last row to the first. May be the test cases are designed such."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "first to last, or last to first : anyway comparison is bound to happen. They have same complexity. The reason you got better time in second submission is that leetcode submissions for same code themselves have hugely varying time. So I don\\'t give much significance to the %tile of time, rather the actual time which is in 30-50 ms range for all sane submissions."
                    },
                    {
                        "username": "surajku2022",
                        "content": "Why this question has so many dislikes, I don\\'t find it hard to read or hard to implement."
                    },
                    {
                        "username": "js5809",
                        "content": "A fairly simple problem. Only the wording of the problem statement can be improved for easier understanding by everyone."
                    },
                    {
                        "username": "gugansps64",
                        "content": "Why my solution\\'s runtime is 18ms, I don\\'t find much difference with the 4ms solution and mine.\\nBelow is my solution, can anyone explain?\\n\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "aym_n",
                        "content": "I have used two for loops to check condition for each pair , but the runtime is like 5s. is there a way i can optimize this?"
                    },
                    {
                        "username": "rajkanwar",
                        "content": "if say strs = [\"c\",\"b\"] would the output be 1?"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "yes,  output will be one"
                    },
                    {
                        "username": "gnarendra89",
                        "content": "I think this problem doesn\\'t deserve to be disliked at all."
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Why so many dislikes for this question?"
                    }
                ]
            },
            {
                "id": 1739207,
                "content": [
                    {
                        "username": "Maxx_1007",
                        "content": "Why this problem has so many downvotes?"
                    },
                    {
                        "username": "Sumit70421",
                        "content": "Is there any solution which takes linear time? I went through all solutions nobody did it in linear time."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "linear time is the only solution possible, you have to go through all characters in all strings O(n*m) which is linear for this case."
                    },
                    {
                        "username": "santanusen",
                        "content": "It was quite difficult for me to get a good timing using C++ with brute-force nested loop-columns  loop-rows approach. I got little better timing by looping from the last row to the first. May be the test cases are designed such."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "first to last, or last to first : anyway comparison is bound to happen. They have same complexity. The reason you got better time in second submission is that leetcode submissions for same code themselves have hugely varying time. So I don\\'t give much significance to the %tile of time, rather the actual time which is in 30-50 ms range for all sane submissions."
                    },
                    {
                        "username": "surajku2022",
                        "content": "Why this question has so many dislikes, I don\\'t find it hard to read or hard to implement."
                    },
                    {
                        "username": "js5809",
                        "content": "A fairly simple problem. Only the wording of the problem statement can be improved for easier understanding by everyone."
                    },
                    {
                        "username": "gugansps64",
                        "content": "Why my solution\\'s runtime is 18ms, I don\\'t find much difference with the 4ms solution and mine.\\nBelow is my solution, can anyone explain?\\n\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "aym_n",
                        "content": "I have used two for loops to check condition for each pair , but the runtime is like 5s. is there a way i can optimize this?"
                    },
                    {
                        "username": "rajkanwar",
                        "content": "if say strs = [\"c\",\"b\"] would the output be 1?"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "yes,  output will be one"
                    },
                    {
                        "username": "gnarendra89",
                        "content": "I think this problem doesn\\'t deserve to be disliked at all."
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Why so many dislikes for this question?"
                    }
                ]
            },
            {
                "id": 1739180,
                "content": [
                    {
                        "username": "Maxx_1007",
                        "content": "Why this problem has so many downvotes?"
                    },
                    {
                        "username": "Sumit70421",
                        "content": "Is there any solution which takes linear time? I went through all solutions nobody did it in linear time."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "linear time is the only solution possible, you have to go through all characters in all strings O(n*m) which is linear for this case."
                    },
                    {
                        "username": "santanusen",
                        "content": "It was quite difficult for me to get a good timing using C++ with brute-force nested loop-columns  loop-rows approach. I got little better timing by looping from the last row to the first. May be the test cases are designed such."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "first to last, or last to first : anyway comparison is bound to happen. They have same complexity. The reason you got better time in second submission is that leetcode submissions for same code themselves have hugely varying time. So I don\\'t give much significance to the %tile of time, rather the actual time which is in 30-50 ms range for all sane submissions."
                    },
                    {
                        "username": "surajku2022",
                        "content": "Why this question has so many dislikes, I don\\'t find it hard to read or hard to implement."
                    },
                    {
                        "username": "js5809",
                        "content": "A fairly simple problem. Only the wording of the problem statement can be improved for easier understanding by everyone."
                    },
                    {
                        "username": "gugansps64",
                        "content": "Why my solution\\'s runtime is 18ms, I don\\'t find much difference with the 4ms solution and mine.\\nBelow is my solution, can anyone explain?\\n\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "aym_n",
                        "content": "I have used two for loops to check condition for each pair , but the runtime is like 5s. is there a way i can optimize this?"
                    },
                    {
                        "username": "rajkanwar",
                        "content": "if say strs = [\"c\",\"b\"] would the output be 1?"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "yes,  output will be one"
                    },
                    {
                        "username": "gnarendra89",
                        "content": "I think this problem doesn\\'t deserve to be disliked at all."
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Why so many dislikes for this question?"
                    }
                ]
            },
            {
                "id": 1739108,
                "content": [
                    {
                        "username": "Maxx_1007",
                        "content": "Why this problem has so many downvotes?"
                    },
                    {
                        "username": "Sumit70421",
                        "content": "Is there any solution which takes linear time? I went through all solutions nobody did it in linear time."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "linear time is the only solution possible, you have to go through all characters in all strings O(n*m) which is linear for this case."
                    },
                    {
                        "username": "santanusen",
                        "content": "It was quite difficult for me to get a good timing using C++ with brute-force nested loop-columns  loop-rows approach. I got little better timing by looping from the last row to the first. May be the test cases are designed such."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "first to last, or last to first : anyway comparison is bound to happen. They have same complexity. The reason you got better time in second submission is that leetcode submissions for same code themselves have hugely varying time. So I don\\'t give much significance to the %tile of time, rather the actual time which is in 30-50 ms range for all sane submissions."
                    },
                    {
                        "username": "surajku2022",
                        "content": "Why this question has so many dislikes, I don\\'t find it hard to read or hard to implement."
                    },
                    {
                        "username": "js5809",
                        "content": "A fairly simple problem. Only the wording of the problem statement can be improved for easier understanding by everyone."
                    },
                    {
                        "username": "gugansps64",
                        "content": "Why my solution\\'s runtime is 18ms, I don\\'t find much difference with the 4ms solution and mine.\\nBelow is my solution, can anyone explain?\\n\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "aym_n",
                        "content": "I have used two for loops to check condition for each pair , but the runtime is like 5s. is there a way i can optimize this?"
                    },
                    {
                        "username": "rajkanwar",
                        "content": "if say strs = [\"c\",\"b\"] would the output be 1?"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "yes,  output will be one"
                    },
                    {
                        "username": "gnarendra89",
                        "content": "I think this problem doesn\\'t deserve to be disliked at all."
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Why so many dislikes for this question?"
                    }
                ]
            },
            {
                "id": 1739082,
                "content": [
                    {
                        "username": "Maxx_1007",
                        "content": "Why this problem has so many downvotes?"
                    },
                    {
                        "username": "Sumit70421",
                        "content": "Is there any solution which takes linear time? I went through all solutions nobody did it in linear time."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "linear time is the only solution possible, you have to go through all characters in all strings O(n*m) which is linear for this case."
                    },
                    {
                        "username": "santanusen",
                        "content": "It was quite difficult for me to get a good timing using C++ with brute-force nested loop-columns  loop-rows approach. I got little better timing by looping from the last row to the first. May be the test cases are designed such."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "first to last, or last to first : anyway comparison is bound to happen. They have same complexity. The reason you got better time in second submission is that leetcode submissions for same code themselves have hugely varying time. So I don\\'t give much significance to the %tile of time, rather the actual time which is in 30-50 ms range for all sane submissions."
                    },
                    {
                        "username": "surajku2022",
                        "content": "Why this question has so many dislikes, I don\\'t find it hard to read or hard to implement."
                    },
                    {
                        "username": "js5809",
                        "content": "A fairly simple problem. Only the wording of the problem statement can be improved for easier understanding by everyone."
                    },
                    {
                        "username": "gugansps64",
                        "content": "Why my solution\\'s runtime is 18ms, I don\\'t find much difference with the 4ms solution and mine.\\nBelow is my solution, can anyone explain?\\n\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "aym_n",
                        "content": "I have used two for loops to check condition for each pair , but the runtime is like 5s. is there a way i can optimize this?"
                    },
                    {
                        "username": "rajkanwar",
                        "content": "if say strs = [\"c\",\"b\"] would the output be 1?"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "yes,  output will be one"
                    },
                    {
                        "username": "gnarendra89",
                        "content": "I think this problem doesn\\'t deserve to be disliked at all."
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Why so many dislikes for this question?"
                    }
                ]
            },
            {
                "id": 1739074,
                "content": [
                    {
                        "username": "Maxx_1007",
                        "content": "Why this problem has so many downvotes?"
                    },
                    {
                        "username": "Sumit70421",
                        "content": "Is there any solution which takes linear time? I went through all solutions nobody did it in linear time."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "linear time is the only solution possible, you have to go through all characters in all strings O(n*m) which is linear for this case."
                    },
                    {
                        "username": "santanusen",
                        "content": "It was quite difficult for me to get a good timing using C++ with brute-force nested loop-columns  loop-rows approach. I got little better timing by looping from the last row to the first. May be the test cases are designed such."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "first to last, or last to first : anyway comparison is bound to happen. They have same complexity. The reason you got better time in second submission is that leetcode submissions for same code themselves have hugely varying time. So I don\\'t give much significance to the %tile of time, rather the actual time which is in 30-50 ms range for all sane submissions."
                    },
                    {
                        "username": "surajku2022",
                        "content": "Why this question has so many dislikes, I don\\'t find it hard to read or hard to implement."
                    },
                    {
                        "username": "js5809",
                        "content": "A fairly simple problem. Only the wording of the problem statement can be improved for easier understanding by everyone."
                    },
                    {
                        "username": "gugansps64",
                        "content": "Why my solution\\'s runtime is 18ms, I don\\'t find much difference with the 4ms solution and mine.\\nBelow is my solution, can anyone explain?\\n\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "aym_n",
                        "content": "I have used two for loops to check condition for each pair , but the runtime is like 5s. is there a way i can optimize this?"
                    },
                    {
                        "username": "rajkanwar",
                        "content": "if say strs = [\"c\",\"b\"] would the output be 1?"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "yes,  output will be one"
                    },
                    {
                        "username": "gnarendra89",
                        "content": "I think this problem doesn\\'t deserve to be disliked at all."
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Why so many dislikes for this question?"
                    }
                ]
            },
            {
                "id": 1739047,
                "content": [
                    {
                        "username": "Maxx_1007",
                        "content": "Why this problem has so many downvotes?"
                    },
                    {
                        "username": "Sumit70421",
                        "content": "Is there any solution which takes linear time? I went through all solutions nobody did it in linear time."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "linear time is the only solution possible, you have to go through all characters in all strings O(n*m) which is linear for this case."
                    },
                    {
                        "username": "santanusen",
                        "content": "It was quite difficult for me to get a good timing using C++ with brute-force nested loop-columns  loop-rows approach. I got little better timing by looping from the last row to the first. May be the test cases are designed such."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "first to last, or last to first : anyway comparison is bound to happen. They have same complexity. The reason you got better time in second submission is that leetcode submissions for same code themselves have hugely varying time. So I don\\'t give much significance to the %tile of time, rather the actual time which is in 30-50 ms range for all sane submissions."
                    },
                    {
                        "username": "surajku2022",
                        "content": "Why this question has so many dislikes, I don\\'t find it hard to read or hard to implement."
                    },
                    {
                        "username": "js5809",
                        "content": "A fairly simple problem. Only the wording of the problem statement can be improved for easier understanding by everyone."
                    },
                    {
                        "username": "gugansps64",
                        "content": "Why my solution\\'s runtime is 18ms, I don\\'t find much difference with the 4ms solution and mine.\\nBelow is my solution, can anyone explain?\\n\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "aym_n",
                        "content": "I have used two for loops to check condition for each pair , but the runtime is like 5s. is there a way i can optimize this?"
                    },
                    {
                        "username": "rajkanwar",
                        "content": "if say strs = [\"c\",\"b\"] would the output be 1?"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "yes,  output will be one"
                    },
                    {
                        "username": "gnarendra89",
                        "content": "I think this problem doesn\\'t deserve to be disliked at all."
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Why so many dislikes for this question?"
                    }
                ]
            },
            {
                "id": 1739019,
                "content": [
                    {
                        "username": "Maxx_1007",
                        "content": "Why this problem has so many downvotes?"
                    },
                    {
                        "username": "Sumit70421",
                        "content": "Is there any solution which takes linear time? I went through all solutions nobody did it in linear time."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "linear time is the only solution possible, you have to go through all characters in all strings O(n*m) which is linear for this case."
                    },
                    {
                        "username": "santanusen",
                        "content": "It was quite difficult for me to get a good timing using C++ with brute-force nested loop-columns  loop-rows approach. I got little better timing by looping from the last row to the first. May be the test cases are designed such."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "first to last, or last to first : anyway comparison is bound to happen. They have same complexity. The reason you got better time in second submission is that leetcode submissions for same code themselves have hugely varying time. So I don\\'t give much significance to the %tile of time, rather the actual time which is in 30-50 ms range for all sane submissions."
                    },
                    {
                        "username": "surajku2022",
                        "content": "Why this question has so many dislikes, I don\\'t find it hard to read or hard to implement."
                    },
                    {
                        "username": "js5809",
                        "content": "A fairly simple problem. Only the wording of the problem statement can be improved for easier understanding by everyone."
                    },
                    {
                        "username": "gugansps64",
                        "content": "Why my solution\\'s runtime is 18ms, I don\\'t find much difference with the 4ms solution and mine.\\nBelow is my solution, can anyone explain?\\n\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++){\\n            for(int j=0;j<strs.length-1;j++){\\n                if(strs[j].charAt(i) > strs[j+1].charAt(i)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "aym_n",
                        "content": "I have used two for loops to check condition for each pair , but the runtime is like 5s. is there a way i can optimize this?"
                    },
                    {
                        "username": "rajkanwar",
                        "content": "if say strs = [\"c\",\"b\"] would the output be 1?"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "yes,  output will be one"
                    },
                    {
                        "username": "gnarendra89",
                        "content": "I think this problem doesn\\'t deserve to be disliked at all."
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Why so many dislikes for this question?"
                    }
                ]
            },
            {
                "id": 1738996,
                "content": [
                    {
                        "username": "kritikagupta3003",
                        "content": "Firstly read the problem as many times until you cannot understand it. Once you get it, It will be very easy for you to implement it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "graphs and dp problems are on way to smash us xD."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Intuition\\nIterate in column major order (the outer loop is columns, inner loop is rows) and make sure that each element in the column is greater than or equal to the one before it. In other words, ensure that strs[i][j] >= str[i - 1][j]. If any element breaks this rule, then we delete the column and move on\\n\\nApproach\\nIterate in column major order but starting at the second row each time. If any element is less than the the element in the previous row, we increase the answer and break out of the loop since we don\\'t need to check the rest of them.\\n\\nIn other words, we just check to see if strs[i][j] < strs[i - 1][j] at any point. If it is, we know it isn\\'t sorted properly and we want to delete the column. We just return ans at the end.\\n\\nExample\\nLets use the second example, where strs = [\"cba\",\"daf\",\"ghi\"]\\n\\nCol = 0\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][0] < strs[0][0] = \\'d\\' < \\'c\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][0] < strs[1][0] = \\'g\\' < \\'d\\', which is false so we go to the next column\\nCol = 1\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][1] < strs[0][1] = \\'a\\' < \\'b\\', which is true so we delete the row and move to the next column\\nCol = 2\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][2] < strs[0][2] = \\'f\\' < \\'a\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][2] < strs[1][2] = \\'i\\' < \\'f\\', which is false so we exit the loop\\nAt the end, ans = 1 which is correct\\n\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            for(int i=0; i<row-1; i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    delete_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return delete_count;\\n    }\\n};"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "If you\\'re solving it using brute force, then this is not a bad/difficult problem. But there is also a suffix array based solution for this problem. Also the statement is fine, just read it carefully and look at the examples."
                    },
                    {
                        "username": "jeffsven",
                        "content": "I believe the statement fulfil the input requirement. Besides, \"understanding statement/troubleshooting\" is one of the core skill you will need for any career or life decision. Just my simple thought. HNY and cheers. "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "I\\'m sure most of the leetcoders solved this easy problem with exactly the same code on Java, which turns to be equal to the only official solution.\\n\\nThe only confusion is why I run the same code 5 times and get 20-30%, then I get 96% 2 times, then again 26% etc....\\nSeems something should be improved in the platform...\\n"
                    },
                    {
                        "username": "adnanahmads999",
                        "content": "I think the problem statement could be more to the he point and precise. However, if you will analyse given examples carefully you\\'ll get that you\\'ve to just compare column elements alphabetically and count them those are not in order."
                    },
                    {
                        "username": "wareag1e",
                        "content": "This is an English reading problem rather than an algorithm problem. \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "no discussion needed..."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Why people are finding the statement hard to understand? The input is just like a \"matrix\" and we\\'re checking if each column of that matrix is sorted alphabetically.\\n\\nA brute force approach would work just fine since the input size is small."
                    }
                ]
            },
            {
                "id": 1738992,
                "content": [
                    {
                        "username": "kritikagupta3003",
                        "content": "Firstly read the problem as many times until you cannot understand it. Once you get it, It will be very easy for you to implement it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "graphs and dp problems are on way to smash us xD."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Intuition\\nIterate in column major order (the outer loop is columns, inner loop is rows) and make sure that each element in the column is greater than or equal to the one before it. In other words, ensure that strs[i][j] >= str[i - 1][j]. If any element breaks this rule, then we delete the column and move on\\n\\nApproach\\nIterate in column major order but starting at the second row each time. If any element is less than the the element in the previous row, we increase the answer and break out of the loop since we don\\'t need to check the rest of them.\\n\\nIn other words, we just check to see if strs[i][j] < strs[i - 1][j] at any point. If it is, we know it isn\\'t sorted properly and we want to delete the column. We just return ans at the end.\\n\\nExample\\nLets use the second example, where strs = [\"cba\",\"daf\",\"ghi\"]\\n\\nCol = 0\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][0] < strs[0][0] = \\'d\\' < \\'c\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][0] < strs[1][0] = \\'g\\' < \\'d\\', which is false so we go to the next column\\nCol = 1\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][1] < strs[0][1] = \\'a\\' < \\'b\\', which is true so we delete the row and move to the next column\\nCol = 2\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][2] < strs[0][2] = \\'f\\' < \\'a\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][2] < strs[1][2] = \\'i\\' < \\'f\\', which is false so we exit the loop\\nAt the end, ans = 1 which is correct\\n\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            for(int i=0; i<row-1; i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    delete_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return delete_count;\\n    }\\n};"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "If you\\'re solving it using brute force, then this is not a bad/difficult problem. But there is also a suffix array based solution for this problem. Also the statement is fine, just read it carefully and look at the examples."
                    },
                    {
                        "username": "jeffsven",
                        "content": "I believe the statement fulfil the input requirement. Besides, \"understanding statement/troubleshooting\" is one of the core skill you will need for any career or life decision. Just my simple thought. HNY and cheers. "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "I\\'m sure most of the leetcoders solved this easy problem with exactly the same code on Java, which turns to be equal to the only official solution.\\n\\nThe only confusion is why I run the same code 5 times and get 20-30%, then I get 96% 2 times, then again 26% etc....\\nSeems something should be improved in the platform...\\n"
                    },
                    {
                        "username": "adnanahmads999",
                        "content": "I think the problem statement could be more to the he point and precise. However, if you will analyse given examples carefully you\\'ll get that you\\'ve to just compare column elements alphabetically and count them those are not in order."
                    },
                    {
                        "username": "wareag1e",
                        "content": "This is an English reading problem rather than an algorithm problem. \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "no discussion needed..."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Why people are finding the statement hard to understand? The input is just like a \"matrix\" and we\\'re checking if each column of that matrix is sorted alphabetically.\\n\\nA brute force approach would work just fine since the input size is small."
                    }
                ]
            },
            {
                "id": 1738987,
                "content": [
                    {
                        "username": "kritikagupta3003",
                        "content": "Firstly read the problem as many times until you cannot understand it. Once you get it, It will be very easy for you to implement it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "graphs and dp problems are on way to smash us xD."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Intuition\\nIterate in column major order (the outer loop is columns, inner loop is rows) and make sure that each element in the column is greater than or equal to the one before it. In other words, ensure that strs[i][j] >= str[i - 1][j]. If any element breaks this rule, then we delete the column and move on\\n\\nApproach\\nIterate in column major order but starting at the second row each time. If any element is less than the the element in the previous row, we increase the answer and break out of the loop since we don\\'t need to check the rest of them.\\n\\nIn other words, we just check to see if strs[i][j] < strs[i - 1][j] at any point. If it is, we know it isn\\'t sorted properly and we want to delete the column. We just return ans at the end.\\n\\nExample\\nLets use the second example, where strs = [\"cba\",\"daf\",\"ghi\"]\\n\\nCol = 0\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][0] < strs[0][0] = \\'d\\' < \\'c\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][0] < strs[1][0] = \\'g\\' < \\'d\\', which is false so we go to the next column\\nCol = 1\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][1] < strs[0][1] = \\'a\\' < \\'b\\', which is true so we delete the row and move to the next column\\nCol = 2\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][2] < strs[0][2] = \\'f\\' < \\'a\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][2] < strs[1][2] = \\'i\\' < \\'f\\', which is false so we exit the loop\\nAt the end, ans = 1 which is correct\\n\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            for(int i=0; i<row-1; i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    delete_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return delete_count;\\n    }\\n};"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "If you\\'re solving it using brute force, then this is not a bad/difficult problem. But there is also a suffix array based solution for this problem. Also the statement is fine, just read it carefully and look at the examples."
                    },
                    {
                        "username": "jeffsven",
                        "content": "I believe the statement fulfil the input requirement. Besides, \"understanding statement/troubleshooting\" is one of the core skill you will need for any career or life decision. Just my simple thought. HNY and cheers. "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "I\\'m sure most of the leetcoders solved this easy problem with exactly the same code on Java, which turns to be equal to the only official solution.\\n\\nThe only confusion is why I run the same code 5 times and get 20-30%, then I get 96% 2 times, then again 26% etc....\\nSeems something should be improved in the platform...\\n"
                    },
                    {
                        "username": "adnanahmads999",
                        "content": "I think the problem statement could be more to the he point and precise. However, if you will analyse given examples carefully you\\'ll get that you\\'ve to just compare column elements alphabetically and count them those are not in order."
                    },
                    {
                        "username": "wareag1e",
                        "content": "This is an English reading problem rather than an algorithm problem. \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "no discussion needed..."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Why people are finding the statement hard to understand? The input is just like a \"matrix\" and we\\'re checking if each column of that matrix is sorted alphabetically.\\n\\nA brute force approach would work just fine since the input size is small."
                    }
                ]
            },
            {
                "id": 1738975,
                "content": [
                    {
                        "username": "kritikagupta3003",
                        "content": "Firstly read the problem as many times until you cannot understand it. Once you get it, It will be very easy for you to implement it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "graphs and dp problems are on way to smash us xD."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Intuition\\nIterate in column major order (the outer loop is columns, inner loop is rows) and make sure that each element in the column is greater than or equal to the one before it. In other words, ensure that strs[i][j] >= str[i - 1][j]. If any element breaks this rule, then we delete the column and move on\\n\\nApproach\\nIterate in column major order but starting at the second row each time. If any element is less than the the element in the previous row, we increase the answer and break out of the loop since we don\\'t need to check the rest of them.\\n\\nIn other words, we just check to see if strs[i][j] < strs[i - 1][j] at any point. If it is, we know it isn\\'t sorted properly and we want to delete the column. We just return ans at the end.\\n\\nExample\\nLets use the second example, where strs = [\"cba\",\"daf\",\"ghi\"]\\n\\nCol = 0\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][0] < strs[0][0] = \\'d\\' < \\'c\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][0] < strs[1][0] = \\'g\\' < \\'d\\', which is false so we go to the next column\\nCol = 1\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][1] < strs[0][1] = \\'a\\' < \\'b\\', which is true so we delete the row and move to the next column\\nCol = 2\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][2] < strs[0][2] = \\'f\\' < \\'a\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][2] < strs[1][2] = \\'i\\' < \\'f\\', which is false so we exit the loop\\nAt the end, ans = 1 which is correct\\n\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            for(int i=0; i<row-1; i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    delete_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return delete_count;\\n    }\\n};"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "If you\\'re solving it using brute force, then this is not a bad/difficult problem. But there is also a suffix array based solution for this problem. Also the statement is fine, just read it carefully and look at the examples."
                    },
                    {
                        "username": "jeffsven",
                        "content": "I believe the statement fulfil the input requirement. Besides, \"understanding statement/troubleshooting\" is one of the core skill you will need for any career or life decision. Just my simple thought. HNY and cheers. "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "I\\'m sure most of the leetcoders solved this easy problem with exactly the same code on Java, which turns to be equal to the only official solution.\\n\\nThe only confusion is why I run the same code 5 times and get 20-30%, then I get 96% 2 times, then again 26% etc....\\nSeems something should be improved in the platform...\\n"
                    },
                    {
                        "username": "adnanahmads999",
                        "content": "I think the problem statement could be more to the he point and precise. However, if you will analyse given examples carefully you\\'ll get that you\\'ve to just compare column elements alphabetically and count them those are not in order."
                    },
                    {
                        "username": "wareag1e",
                        "content": "This is an English reading problem rather than an algorithm problem. \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "no discussion needed..."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Why people are finding the statement hard to understand? The input is just like a \"matrix\" and we\\'re checking if each column of that matrix is sorted alphabetically.\\n\\nA brute force approach would work just fine since the input size is small."
                    }
                ]
            },
            {
                "id": 1738955,
                "content": [
                    {
                        "username": "kritikagupta3003",
                        "content": "Firstly read the problem as many times until you cannot understand it. Once you get it, It will be very easy for you to implement it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "graphs and dp problems are on way to smash us xD."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Intuition\\nIterate in column major order (the outer loop is columns, inner loop is rows) and make sure that each element in the column is greater than or equal to the one before it. In other words, ensure that strs[i][j] >= str[i - 1][j]. If any element breaks this rule, then we delete the column and move on\\n\\nApproach\\nIterate in column major order but starting at the second row each time. If any element is less than the the element in the previous row, we increase the answer and break out of the loop since we don\\'t need to check the rest of them.\\n\\nIn other words, we just check to see if strs[i][j] < strs[i - 1][j] at any point. If it is, we know it isn\\'t sorted properly and we want to delete the column. We just return ans at the end.\\n\\nExample\\nLets use the second example, where strs = [\"cba\",\"daf\",\"ghi\"]\\n\\nCol = 0\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][0] < strs[0][0] = \\'d\\' < \\'c\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][0] < strs[1][0] = \\'g\\' < \\'d\\', which is false so we go to the next column\\nCol = 1\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][1] < strs[0][1] = \\'a\\' < \\'b\\', which is true so we delete the row and move to the next column\\nCol = 2\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][2] < strs[0][2] = \\'f\\' < \\'a\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][2] < strs[1][2] = \\'i\\' < \\'f\\', which is false so we exit the loop\\nAt the end, ans = 1 which is correct\\n\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            for(int i=0; i<row-1; i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    delete_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return delete_count;\\n    }\\n};"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "If you\\'re solving it using brute force, then this is not a bad/difficult problem. But there is also a suffix array based solution for this problem. Also the statement is fine, just read it carefully and look at the examples."
                    },
                    {
                        "username": "jeffsven",
                        "content": "I believe the statement fulfil the input requirement. Besides, \"understanding statement/troubleshooting\" is one of the core skill you will need for any career or life decision. Just my simple thought. HNY and cheers. "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "I\\'m sure most of the leetcoders solved this easy problem with exactly the same code on Java, which turns to be equal to the only official solution.\\n\\nThe only confusion is why I run the same code 5 times and get 20-30%, then I get 96% 2 times, then again 26% etc....\\nSeems something should be improved in the platform...\\n"
                    },
                    {
                        "username": "adnanahmads999",
                        "content": "I think the problem statement could be more to the he point and precise. However, if you will analyse given examples carefully you\\'ll get that you\\'ve to just compare column elements alphabetically and count them those are not in order."
                    },
                    {
                        "username": "wareag1e",
                        "content": "This is an English reading problem rather than an algorithm problem. \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "no discussion needed..."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Why people are finding the statement hard to understand? The input is just like a \"matrix\" and we\\'re checking if each column of that matrix is sorted alphabetically.\\n\\nA brute force approach would work just fine since the input size is small."
                    }
                ]
            },
            {
                "id": 1738953,
                "content": [
                    {
                        "username": "kritikagupta3003",
                        "content": "Firstly read the problem as many times until you cannot understand it. Once you get it, It will be very easy for you to implement it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "graphs and dp problems are on way to smash us xD."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Intuition\\nIterate in column major order (the outer loop is columns, inner loop is rows) and make sure that each element in the column is greater than or equal to the one before it. In other words, ensure that strs[i][j] >= str[i - 1][j]. If any element breaks this rule, then we delete the column and move on\\n\\nApproach\\nIterate in column major order but starting at the second row each time. If any element is less than the the element in the previous row, we increase the answer and break out of the loop since we don\\'t need to check the rest of them.\\n\\nIn other words, we just check to see if strs[i][j] < strs[i - 1][j] at any point. If it is, we know it isn\\'t sorted properly and we want to delete the column. We just return ans at the end.\\n\\nExample\\nLets use the second example, where strs = [\"cba\",\"daf\",\"ghi\"]\\n\\nCol = 0\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][0] < strs[0][0] = \\'d\\' < \\'c\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][0] < strs[1][0] = \\'g\\' < \\'d\\', which is false so we go to the next column\\nCol = 1\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][1] < strs[0][1] = \\'a\\' < \\'b\\', which is true so we delete the row and move to the next column\\nCol = 2\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][2] < strs[0][2] = \\'f\\' < \\'a\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][2] < strs[1][2] = \\'i\\' < \\'f\\', which is false so we exit the loop\\nAt the end, ans = 1 which is correct\\n\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            for(int i=0; i<row-1; i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    delete_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return delete_count;\\n    }\\n};"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "If you\\'re solving it using brute force, then this is not a bad/difficult problem. But there is also a suffix array based solution for this problem. Also the statement is fine, just read it carefully and look at the examples."
                    },
                    {
                        "username": "jeffsven",
                        "content": "I believe the statement fulfil the input requirement. Besides, \"understanding statement/troubleshooting\" is one of the core skill you will need for any career or life decision. Just my simple thought. HNY and cheers. "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "I\\'m sure most of the leetcoders solved this easy problem with exactly the same code on Java, which turns to be equal to the only official solution.\\n\\nThe only confusion is why I run the same code 5 times and get 20-30%, then I get 96% 2 times, then again 26% etc....\\nSeems something should be improved in the platform...\\n"
                    },
                    {
                        "username": "adnanahmads999",
                        "content": "I think the problem statement could be more to the he point and precise. However, if you will analyse given examples carefully you\\'ll get that you\\'ve to just compare column elements alphabetically and count them those are not in order."
                    },
                    {
                        "username": "wareag1e",
                        "content": "This is an English reading problem rather than an algorithm problem. \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "no discussion needed..."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Why people are finding the statement hard to understand? The input is just like a \"matrix\" and we\\'re checking if each column of that matrix is sorted alphabetically.\\n\\nA brute force approach would work just fine since the input size is small."
                    }
                ]
            },
            {
                "id": 1738947,
                "content": [
                    {
                        "username": "kritikagupta3003",
                        "content": "Firstly read the problem as many times until you cannot understand it. Once you get it, It will be very easy for you to implement it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "graphs and dp problems are on way to smash us xD."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Intuition\\nIterate in column major order (the outer loop is columns, inner loop is rows) and make sure that each element in the column is greater than or equal to the one before it. In other words, ensure that strs[i][j] >= str[i - 1][j]. If any element breaks this rule, then we delete the column and move on\\n\\nApproach\\nIterate in column major order but starting at the second row each time. If any element is less than the the element in the previous row, we increase the answer and break out of the loop since we don\\'t need to check the rest of them.\\n\\nIn other words, we just check to see if strs[i][j] < strs[i - 1][j] at any point. If it is, we know it isn\\'t sorted properly and we want to delete the column. We just return ans at the end.\\n\\nExample\\nLets use the second example, where strs = [\"cba\",\"daf\",\"ghi\"]\\n\\nCol = 0\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][0] < strs[0][0] = \\'d\\' < \\'c\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][0] < strs[1][0] = \\'g\\' < \\'d\\', which is false so we go to the next column\\nCol = 1\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][1] < strs[0][1] = \\'a\\' < \\'b\\', which is true so we delete the row and move to the next column\\nCol = 2\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][2] < strs[0][2] = \\'f\\' < \\'a\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][2] < strs[1][2] = \\'i\\' < \\'f\\', which is false so we exit the loop\\nAt the end, ans = 1 which is correct\\n\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            for(int i=0; i<row-1; i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    delete_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return delete_count;\\n    }\\n};"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "If you\\'re solving it using brute force, then this is not a bad/difficult problem. But there is also a suffix array based solution for this problem. Also the statement is fine, just read it carefully and look at the examples."
                    },
                    {
                        "username": "jeffsven",
                        "content": "I believe the statement fulfil the input requirement. Besides, \"understanding statement/troubleshooting\" is one of the core skill you will need for any career or life decision. Just my simple thought. HNY and cheers. "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "I\\'m sure most of the leetcoders solved this easy problem with exactly the same code on Java, which turns to be equal to the only official solution.\\n\\nThe only confusion is why I run the same code 5 times and get 20-30%, then I get 96% 2 times, then again 26% etc....\\nSeems something should be improved in the platform...\\n"
                    },
                    {
                        "username": "adnanahmads999",
                        "content": "I think the problem statement could be more to the he point and precise. However, if you will analyse given examples carefully you\\'ll get that you\\'ve to just compare column elements alphabetically and count them those are not in order."
                    },
                    {
                        "username": "wareag1e",
                        "content": "This is an English reading problem rather than an algorithm problem. \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "no discussion needed..."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Why people are finding the statement hard to understand? The input is just like a \"matrix\" and we\\'re checking if each column of that matrix is sorted alphabetically.\\n\\nA brute force approach would work just fine since the input size is small."
                    }
                ]
            },
            {
                "id": 1738946,
                "content": [
                    {
                        "username": "kritikagupta3003",
                        "content": "Firstly read the problem as many times until you cannot understand it. Once you get it, It will be very easy for you to implement it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "graphs and dp problems are on way to smash us xD."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Intuition\\nIterate in column major order (the outer loop is columns, inner loop is rows) and make sure that each element in the column is greater than or equal to the one before it. In other words, ensure that strs[i][j] >= str[i - 1][j]. If any element breaks this rule, then we delete the column and move on\\n\\nApproach\\nIterate in column major order but starting at the second row each time. If any element is less than the the element in the previous row, we increase the answer and break out of the loop since we don\\'t need to check the rest of them.\\n\\nIn other words, we just check to see if strs[i][j] < strs[i - 1][j] at any point. If it is, we know it isn\\'t sorted properly and we want to delete the column. We just return ans at the end.\\n\\nExample\\nLets use the second example, where strs = [\"cba\",\"daf\",\"ghi\"]\\n\\nCol = 0\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][0] < strs[0][0] = \\'d\\' < \\'c\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][0] < strs[1][0] = \\'g\\' < \\'d\\', which is false so we go to the next column\\nCol = 1\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][1] < strs[0][1] = \\'a\\' < \\'b\\', which is true so we delete the row and move to the next column\\nCol = 2\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][2] < strs[0][2] = \\'f\\' < \\'a\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][2] < strs[1][2] = \\'i\\' < \\'f\\', which is false so we exit the loop\\nAt the end, ans = 1 which is correct\\n\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            for(int i=0; i<row-1; i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    delete_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return delete_count;\\n    }\\n};"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "If you\\'re solving it using brute force, then this is not a bad/difficult problem. But there is also a suffix array based solution for this problem. Also the statement is fine, just read it carefully and look at the examples."
                    },
                    {
                        "username": "jeffsven",
                        "content": "I believe the statement fulfil the input requirement. Besides, \"understanding statement/troubleshooting\" is one of the core skill you will need for any career or life decision. Just my simple thought. HNY and cheers. "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "I\\'m sure most of the leetcoders solved this easy problem with exactly the same code on Java, which turns to be equal to the only official solution.\\n\\nThe only confusion is why I run the same code 5 times and get 20-30%, then I get 96% 2 times, then again 26% etc....\\nSeems something should be improved in the platform...\\n"
                    },
                    {
                        "username": "adnanahmads999",
                        "content": "I think the problem statement could be more to the he point and precise. However, if you will analyse given examples carefully you\\'ll get that you\\'ve to just compare column elements alphabetically and count them those are not in order."
                    },
                    {
                        "username": "wareag1e",
                        "content": "This is an English reading problem rather than an algorithm problem. \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "no discussion needed..."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Why people are finding the statement hard to understand? The input is just like a \"matrix\" and we\\'re checking if each column of that matrix is sorted alphabetically.\\n\\nA brute force approach would work just fine since the input size is small."
                    }
                ]
            },
            {
                "id": 1738900,
                "content": [
                    {
                        "username": "kritikagupta3003",
                        "content": "Firstly read the problem as many times until you cannot understand it. Once you get it, It will be very easy for you to implement it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "graphs and dp problems are on way to smash us xD."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Intuition\\nIterate in column major order (the outer loop is columns, inner loop is rows) and make sure that each element in the column is greater than or equal to the one before it. In other words, ensure that strs[i][j] >= str[i - 1][j]. If any element breaks this rule, then we delete the column and move on\\n\\nApproach\\nIterate in column major order but starting at the second row each time. If any element is less than the the element in the previous row, we increase the answer and break out of the loop since we don\\'t need to check the rest of them.\\n\\nIn other words, we just check to see if strs[i][j] < strs[i - 1][j] at any point. If it is, we know it isn\\'t sorted properly and we want to delete the column. We just return ans at the end.\\n\\nExample\\nLets use the second example, where strs = [\"cba\",\"daf\",\"ghi\"]\\n\\nCol = 0\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][0] < strs[0][0] = \\'d\\' < \\'c\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][0] < strs[1][0] = \\'g\\' < \\'d\\', which is false so we go to the next column\\nCol = 1\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][1] < strs[0][1] = \\'a\\' < \\'b\\', which is true so we delete the row and move to the next column\\nCol = 2\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][2] < strs[0][2] = \\'f\\' < \\'a\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][2] < strs[1][2] = \\'i\\' < \\'f\\', which is false so we exit the loop\\nAt the end, ans = 1 which is correct\\n\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            for(int i=0; i<row-1; i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    delete_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return delete_count;\\n    }\\n};"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "If you\\'re solving it using brute force, then this is not a bad/difficult problem. But there is also a suffix array based solution for this problem. Also the statement is fine, just read it carefully and look at the examples."
                    },
                    {
                        "username": "jeffsven",
                        "content": "I believe the statement fulfil the input requirement. Besides, \"understanding statement/troubleshooting\" is one of the core skill you will need for any career or life decision. Just my simple thought. HNY and cheers. "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "I\\'m sure most of the leetcoders solved this easy problem with exactly the same code on Java, which turns to be equal to the only official solution.\\n\\nThe only confusion is why I run the same code 5 times and get 20-30%, then I get 96% 2 times, then again 26% etc....\\nSeems something should be improved in the platform...\\n"
                    },
                    {
                        "username": "adnanahmads999",
                        "content": "I think the problem statement could be more to the he point and precise. However, if you will analyse given examples carefully you\\'ll get that you\\'ve to just compare column elements alphabetically and count them those are not in order."
                    },
                    {
                        "username": "wareag1e",
                        "content": "This is an English reading problem rather than an algorithm problem. \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "no discussion needed..."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Why people are finding the statement hard to understand? The input is just like a \"matrix\" and we\\'re checking if each column of that matrix is sorted alphabetically.\\n\\nA brute force approach would work just fine since the input size is small."
                    }
                ]
            },
            {
                "id": 1738897,
                "content": [
                    {
                        "username": "kritikagupta3003",
                        "content": "Firstly read the problem as many times until you cannot understand it. Once you get it, It will be very easy for you to implement it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "graphs and dp problems are on way to smash us xD."
                    },
                    {
                        "username": "ranjeet43",
                        "content": "Intuition\\nIterate in column major order (the outer loop is columns, inner loop is rows) and make sure that each element in the column is greater than or equal to the one before it. In other words, ensure that strs[i][j] >= str[i - 1][j]. If any element breaks this rule, then we delete the column and move on\\n\\nApproach\\nIterate in column major order but starting at the second row each time. If any element is less than the the element in the previous row, we increase the answer and break out of the loop since we don\\'t need to check the rest of them.\\n\\nIn other words, we just check to see if strs[i][j] < strs[i - 1][j] at any point. If it is, we know it isn\\'t sorted properly and we want to delete the column. We just return ans at the end.\\n\\nExample\\nLets use the second example, where strs = [\"cba\",\"daf\",\"ghi\"]\\n\\nCol = 0\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][0] < strs[0][0] = \\'d\\' < \\'c\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][0] < strs[1][0] = \\'g\\' < \\'d\\', which is false so we go to the next column\\nCol = 1\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][1] < strs[0][1] = \\'a\\' < \\'b\\', which is true so we delete the row and move to the next column\\nCol = 2\\nRow = 1\\nCheck if strs[i][j] < strs[i - 1][j] = strs[1][2] < strs[0][2] = \\'f\\' < \\'a\\', which is false so we go to the next row\\nRow = 2\\nCheck if strs[i][j] < strs[i - 1][j] = strs[2][2] < strs[1][2] = \\'i\\' < \\'f\\', which is false so we exit the loop\\nAt the end, ans = 1 which is correct\\n\\nclass Solution {\\npublic:\\n    int minDeletionSize(vector<string>& strs) {\\n        int delete_count=0;\\n        int row = strs.size();\\n        int col = strs[0].size();\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            for(int i=0; i<row-1; i++)\\n            {\\n                if(strs[i][j]>strs[i+1][j])\\n                {\\n                    delete_count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return delete_count;\\n    }\\n};"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "If you\\'re solving it using brute force, then this is not a bad/difficult problem. But there is also a suffix array based solution for this problem. Also the statement is fine, just read it carefully and look at the examples."
                    },
                    {
                        "username": "jeffsven",
                        "content": "I believe the statement fulfil the input requirement. Besides, \"understanding statement/troubleshooting\" is one of the core skill you will need for any career or life decision. Just my simple thought. HNY and cheers. "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "I\\'m sure most of the leetcoders solved this easy problem with exactly the same code on Java, which turns to be equal to the only official solution.\\n\\nThe only confusion is why I run the same code 5 times and get 20-30%, then I get 96% 2 times, then again 26% etc....\\nSeems something should be improved in the platform...\\n"
                    },
                    {
                        "username": "adnanahmads999",
                        "content": "I think the problem statement could be more to the he point and precise. However, if you will analyse given examples carefully you\\'ll get that you\\'ve to just compare column elements alphabetically and count them those are not in order."
                    },
                    {
                        "username": "wareag1e",
                        "content": "This is an English reading problem rather than an algorithm problem. \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "no discussion needed..."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Why people are finding the statement hard to understand? The input is just like a \"matrix\" and we\\'re checking if each column of that matrix is sorted alphabetically.\\n\\nA brute force approach would work just fine since the input size is small."
                    }
                ]
            }
        ]
    },
    {
        "title": "Balance a Binary Search Tree",
        "question_content": "<p>Given the <code>root</code> of a binary search tree, return <em>a <strong>balanced</strong> binary search tree with the same node values</em>. If there is more than one answer, return <strong>any of them</strong>.</p>\n\n<p>A binary search tree is <strong>balanced</strong> if the depth of the two subtrees of every node never differs by more than <code>1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/10/balance1-tree.jpg\" style=\"width: 500px; height: 319px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,2,null,3,null,4,null,null]\n<strong>Output:</strong> [2,1,3,null,null,null,4]\n<b>Explanation:</b> This is not the only correct answer, [3,1,4,null,2] is also correct.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/10/balanced2-tree.jpg\" style=\"width: 224px; height: 145px;\" />\n<pre>\n<strong>Input:</strong> root = [2,1,3]\n<strong>Output:</strong> [2,1,3]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 539686,
                "title": "java-c-sorted-array-to-bst-o-n-clean-code",
                "content": "**Intuitive**\\n- Traverse binary tree in-order to get sorted array\\n- The problem become [108. Convert Sorted Array to Binary Search Tree\\n](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)\\n\\n**Java**\\n```java\\nclass Solution {\\n    List<TreeNode> sortedArr = new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n        inorderTraverse(root);\\n        return sortedArrayToBST(0, sortedArr.size() - 1);\\n    }\\n    void inorderTraverse(TreeNode root) {\\n        if (root == null) return;\\n        inorderTraverse(root.left);\\n        sortedArr.add(root);\\n        inorderTraverse(root.right);\\n    }\\n    TreeNode sortedArrayToBST(int start, int end) {\\n        if (start > end) return null;\\n        int mid = (start + end) / 2;\\n        TreeNode root = sortedArr.get(mid);\\n        root.left = sortedArrayToBST(start, mid - 1);\\n        root.right = sortedArrayToBST(mid + 1, end);\\n        return root;\\n    }\\n}\\n```\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    vector<TreeNode*> sortedArr;\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorderTraverse(root);\\n        return sortedArrayToBST(0, sortedArr.size() - 1);\\n    }\\n    void inorderTraverse(TreeNode* root) {\\n        if (root == NULL) return;\\n        inorderTraverse(root->left);\\n        sortedArr.push_back(root);\\n        inorderTraverse(root->right);\\n    }\\n    TreeNode* sortedArrayToBST(int start, int end) {\\n        if (start > end) return NULL;\\n        int mid = (start + end) / 2;\\n        TreeNode* root = sortedArr[mid];\\n        root->left = sortedArrayToBST(start, mid - 1);\\n        root->right = sortedArrayToBST(mid + 1, end);\\n        return root;\\n    }\\n};\\n```\\nComplexity\\n- Time & Space: `O(n)`",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    List<TreeNode> sortedArr = new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n        inorderTraverse(root);\\n        return sortedArrayToBST(0, sortedArr.size() - 1);\\n    }\\n    void inorderTraverse(TreeNode root) {\\n        if (root == null) return;\\n        inorderTraverse(root.left);\\n        sortedArr.add(root);\\n        inorderTraverse(root.right);\\n    }\\n    TreeNode sortedArrayToBST(int start, int end) {\\n        if (start > end) return null;\\n        int mid = (start + end) / 2;\\n        TreeNode root = sortedArr.get(mid);\\n        root.left = sortedArrayToBST(start, mid - 1);\\n        root.right = sortedArrayToBST(mid + 1, end);\\n        return root;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<TreeNode*> sortedArr;\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorderTraverse(root);\\n        return sortedArrayToBST(0, sortedArr.size() - 1);\\n    }\\n    void inorderTraverse(TreeNode* root) {\\n        if (root == NULL) return;\\n        inorderTraverse(root->left);\\n        sortedArr.push_back(root);\\n        inorderTraverse(root->right);\\n    }\\n    TreeNode* sortedArrayToBST(int start, int end) {\\n        if (start > end) return NULL;\\n        int mid = (start + end) / 2;\\n        TreeNode* root = sortedArr[mid];\\n        root->left = sortedArrayToBST(start, mid - 1);\\n        root->right = sortedArrayToBST(mid + 1, end);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541785,
                "title": "c-java-with-picture-dsw-o-n-o-1",
                "content": "The DSW algorithm is more complicated than re-creating a balanced tree from a sorted array. However, it does not require any extra memory as we manipulate existing nodes. It can be a big plus if your node stores more than just an int.\\n\\nThe idea is to convert the tree into a vine (like linked list) using left rotations, and then balance it using right rotations. You can look online for the full description of the DSW algorithm.\\n\\n**Algorithm**\\n1. Convert the initial tree into a vine. By doing right rotations, we flatten a tree into a \\'linked list\\', where the head is the former leftmost node, and tail - former rightmost node.\\n2. As you convert the tree into a vine, count the total number of nodes in `cnt`.\\n3. Calculate the height of the closest perfectly balanced tree: `h = log2(cnt + 1)`. \\n4. Calculate the number of nodes in the closest perfectly balanced tree: `m = pow(2, h) - 1`.\\n5. Left-rotate `cnt - m` nodes to cover up the excess of nodes.\\n> Note: you rotate the root node, then you rotate the right child of the new root node, and so on. In other words, left rotations are performed on every second node of the vine. See pictures below for the illustration.\\n6. Left-rotate `m / 2` nodes.\\n7. Divide `m` by two and repeat the step above while `m / 2` is greater than zero.  \\n\\n**Example**\\nThis example is borrowed from [this article](https://csactor.blogspot.com/2018/08/dsw-day-stout-warren-algorithm-dsw.html).\\n\\n1. Our initial tree has 9 nodes, and we convert it to a vine.\\n\\n![image](https://assets.leetcode.com/users/votrubac/image_1584399705.png)![image](https://assets.leetcode.com/users/votrubac/image_1584399732.png)\\n2. The height of the closest perfectly balanced tree is 3, and it contains 7 nodes.\\n3. So, we initially perform 2 left rotations (9 - 7) to cover up the excess.\\n\\n![image](https://assets.leetcode.com/users/votrubac/image_1584400245.png)\\n4. Then, we perform 3 left rotations (7 / 2).\\n\\n![image](https://assets.leetcode.com/users/votrubac/image_1584400266.png)\\n5. Finally, we perform 1 left rotation (3 / 2).\\n\\n![image](https://assets.leetcode.com/users/votrubac/image_1584400292.png)\\n\\n> Note two excess nodes fill the next (4th) level of the resulting tree, so it\\'s not just balanced but also complete.\\n\\n**Implementation**\\nIn order to achieve O(1) memory, we must to avoid recursion. To do that, we track the grandparent `grand` when doing rotations. Also, we create a temporary node as a tree root to be the initial grandparent.\\n\\n**C++**\\n```cpp\\nint makeVine(TreeNode *grand, int cnt = 0) {\\n  auto n = grand->right;\\n  while (n != nullptr) {\\n    if (n->left != nullptr) {\\n      auto old_n = n;\\n      n = n->left;\\n      old_n->left = n->right;\\n      n->right = old_n;\\n      grand->right = n;\\n    }\\n    else {      \\n        ++cnt;\\n        grand = n;\\n        n = n->right;\\n    }\\n  }\\n  return cnt;\\n}\\nvoid compress(TreeNode *grand, int m) {\\n  auto n = grand->right;\\n  while (m-- > 0) {\\n    auto old_n = n;\\n    n = n->right;\\n    grand->right = n;\\n    old_n->right = n->left;\\n    n->left = old_n;\\n    grand = n;\\n    n = n->right;\\n  }\\n}\\nTreeNode* balanceBST(TreeNode *root) {\\n  TreeNode grand;\\n  grand.right = root;\\n  auto cnt = makeVine(&grand);\\n  int m = pow(2, int(log2(cnt + 1))) - 1;\\n  compress(&grand, cnt - m);\\n  for (m = m / 2; m > 0; m /= 2)\\n    compress(&grand, m);\\n  return grand.right;\\n}\\n```\\n\\n**Java**\\n```java\\nint makeVine(TreeNode grand) {\\n  int cnt = 0;\\n  var n = grand.right;\\n  while (n != null) {\\n    if (n.left != null) {\\n      var old_n = n;\\n      n = n.left;\\n      old_n.left = n.right;\\n      n.right = old_n;\\n      grand.right = n;\\n    }\\n    else {      \\n        ++cnt;\\n        grand = n;\\n        n = n.right;\\n    }\\n  }\\n  return cnt;\\n}\\nvoid compress(TreeNode grand, int m) {\\n  var n = grand.right;\\n  while (m-- > 0) {\\n    var old_n = n;\\n    n = n.right;\\n    grand.right = n;\\n    old_n.right = n.left;\\n    n.left = old_n;\\n    grand = n;\\n    n = n.right;\\n  }\\n}    \\npublic TreeNode balanceBST(TreeNode root) {\\n  TreeNode grand = new TreeNode(0);\\n  grand.right = root;\\n  int cnt = makeVine(grand);\\n  int m = (int)Math.pow(2, (int)(Math.log(cnt + 1) / Math.log(2))) - 1;\\n  compress(grand, cnt - m);\\n  for (m = m / 2; m > 0; m /= 2)\\n    compress(grand, m);\\n  return grand.right;\\n}\\n```\\n\\n**Complexity Analysis**\\n- Time: *O(n)*. We perform up to *n* rotations and traverse *n* nodes.\\n- Memory: *O(1)*. We re-use existing nodes and process our tree iteratively.",
                "solutionTags": [],
                "code": "```cpp\\nint makeVine(TreeNode *grand, int cnt = 0) {\\n  auto n = grand->right;\\n  while (n != nullptr) {\\n    if (n->left != nullptr) {\\n      auto old_n = n;\\n      n = n->left;\\n      old_n->left = n->right;\\n      n->right = old_n;\\n      grand->right = n;\\n    }\\n    else {      \\n        ++cnt;\\n        grand = n;\\n        n = n->right;\\n    }\\n  }\\n  return cnt;\\n}\\nvoid compress(TreeNode *grand, int m) {\\n  auto n = grand->right;\\n  while (m-- > 0) {\\n    auto old_n = n;\\n    n = n->right;\\n    grand->right = n;\\n    old_n->right = n->left;\\n    n->left = old_n;\\n    grand = n;\\n    n = n->right;\\n  }\\n}\\nTreeNode* balanceBST(TreeNode *root) {\\n  TreeNode grand;\\n  grand.right = root;\\n  auto cnt = makeVine(&grand);\\n  int m = pow(2, int(log2(cnt + 1))) - 1;\\n  compress(&grand, cnt - m);\\n  for (m = m / 2; m > 0; m /= 2)\\n    compress(&grand, m);\\n  return grand.right;\\n}\\n```\n```java\\nint makeVine(TreeNode grand) {\\n  int cnt = 0;\\n  var n = grand.right;\\n  while (n != null) {\\n    if (n.left != null) {\\n      var old_n = n;\\n      n = n.left;\\n      old_n.left = n.right;\\n      n.right = old_n;\\n      grand.right = n;\\n    }\\n    else {      \\n        ++cnt;\\n        grand = n;\\n        n = n.right;\\n    }\\n  }\\n  return cnt;\\n}\\nvoid compress(TreeNode grand, int m) {\\n  var n = grand.right;\\n  while (m-- > 0) {\\n    var old_n = n;\\n    n = n.right;\\n    grand.right = n;\\n    old_n.right = n.left;\\n    n.left = old_n;\\n    grand = n;\\n    n = n.right;\\n  }\\n}    \\npublic TreeNode balanceBST(TreeNode root) {\\n  TreeNode grand = new TreeNode(0);\\n  grand.right = root;\\n  int cnt = makeVine(grand);\\n  int m = (int)Math.pow(2, (int)(Math.log(cnt + 1) / Math.log(2))) - 1;\\n  compress(grand, cnt - m);\\n  for (m = m / 2; m > 0; m /= 2)\\n    compress(grand, m);\\n  return grand.right;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540038,
                "title": "python-3-easy-to-understand",
                "content": "\\t# Definition for a binary tree node.\\n\\t# class TreeNode:\\n\\t#     def __init__(self, x):\\n\\t#         self.val = x\\n\\t#         self.left = None\\n\\t#         self.right = None\\n\\n\\tclass Solution:\\n\\t\\tdef balanceBST(self, root: TreeNode) -> TreeNode:\\n\\t\\t\\tv = []\\n\\t\\t\\tdef dfs(node):\\n\\t\\t\\t\\tif node:\\n\\t\\t\\t\\t\\tdfs(node.left)\\n\\t\\t\\t\\t\\tv.append(node.val)\\n\\t\\t\\t\\t\\tdfs(node.right)\\n\\t\\t\\tdfs(root)\\n\\n\\t\\t\\tdef bst(v):\\n\\t\\t\\t\\tif not v:\\n\\t\\t\\t\\t\\treturn None\\n\\t\\t\\t\\tmid = len(v) // 2\\n\\t\\t\\t\\troot = TreeNode(v[mid])\\n\\t\\t\\t\\troot.left = bst(v[:mid])\\n\\t\\t\\t\\troot.right = bst(v[mid + 1:])\\n\\t\\t\\t\\treturn root\\n\\n\\t\\t\\treturn bst(v)",
                "solutionTags": [],
                "code": "\\t# Definition for a binary tree node.\\n\\t# class TreeNode:\\n\\t#     def __init__(self, x):\\n\\t#         self.val = x\\n\\t#         self.left = None\\n\\t#         self.right = None\\n\\n\\tclass Solution:\\n\\t\\tdef balanceBST(self, root: TreeNode) -> TreeNode:\\n\\t\\t\\tv = []\\n\\t\\t\\tdef dfs(node):\\n\\t\\t\\t\\tif node:\\n\\t\\t\\t\\t\\tdfs(node.left)\\n\\t\\t\\t\\t\\tv.append(node.val)\\n\\t\\t\\t\\t\\tdfs(node.right)\\n\\t\\t\\tdfs(root)\\n\\n\\t\\t\\tdef bst(v):\\n\\t\\t\\t\\tif not v:\\n\\t\\t\\t\\t\\treturn None\\n\\t\\t\\t\\tmid = len(v) // 2\\n\\t\\t\\t\\troot = TreeNode(v[mid])\\n\\t\\t\\t\\troot.left = bst(v[:mid])\\n\\t\\t\\t\\troot.right = bst(v[mid + 1:])\\n\\t\\t\\t\\treturn root\\n\\n\\t\\t\\treturn bst(v)",
                "codeTag": "Java"
            },
            {
                "id": 821240,
                "title": "visualized-c-code-well-explained",
                "content": "```\\n\\tExample:  [1,null,2,null,3,null,4,null,null]\\n\\t\\n\\t1. \\tCreate a vector Inorder to store the nodes. \\n\\t\\n\\t2. \\tTraverse the tree in such a way that the nodes stored in the vector are in ascending order i.e. Inorder Traversal. \\n\\t\\t\\t\\t\\t\\t\\t\\tInorder: [ 1, 2, 3, 4 ]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t3. \\tThen use this vector of nodes to find the root node of the balanced BST.\\n\\t\\n\\t4. \\tThe newRoot node will be mid element of the array;\\n\\t\\t\\t\\t\\t\\t\\t\\tnewRoot= Inorder[mid]=2\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t5. Then recursively add the mid of first half to the left of the tree.\\n\\t\\t\\t\\t\\t\\t\\t\\tnewRoot->left=1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t6. And the mid of second half to the right of the tree.\\n\\t\\t\\t\\t\\t\\t\\t\\tnewRoot->right=3\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n```\\n**Code** \\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> inorder;\\n    void findInorder(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return;\\n        findInorder(root->left);\\n        inorder.push_back(root);\\n        findInorder(root->right);\\n    }\\n    TreeNode* buildTree(int start,int end)\\n    {\\n        if(start>end)\\n            return NULL;\\n        int mid=(start+end)/2;\\n        TreeNode* root=inorder[mid];\\n        root->left=buildTree(start,mid-1);\\n        root->right=buildTree(mid+1,end);\\n        return root;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) \\n    {\\n        if(root==NULL)\\n            return NULL;\\n        findInorder(root);\\n        int n=inorder.size();\\n        root=buildTree(0,n-1);\\n        return root;\\n    }\\n};\\n```\\n**Please Upvote if you find it useful.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tExample:  [1,null,2,null,3,null,4,null,null]\\n\\t\\n\\t1. \\tCreate a vector Inorder to store the nodes. \\n\\t\\n\\t2. \\tTraverse the tree in such a way that the nodes stored in the vector are in ascending order i.e. Inorder Traversal. \\n\\t\\t\\t\\t\\t\\t\\t\\tInorder: [ 1, 2, 3, 4 ]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t3. \\tThen use this vector of nodes to find the root node of the balanced BST.\\n\\t\\n\\t4. \\tThe newRoot node will be mid element of the array;\\n\\t\\t\\t\\t\\t\\t\\t\\tnewRoot= Inorder[mid]=2\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t5. Then recursively add the mid of first half to the left of the tree.\\n\\t\\t\\t\\t\\t\\t\\t\\tnewRoot->left=1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t6. And the mid of second half to the right of the tree.\\n\\t\\t\\t\\t\\t\\t\\t\\tnewRoot->right=3\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*> inorder;\\n    void findInorder(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return;\\n        findInorder(root->left);\\n        inorder.push_back(root);\\n        findInorder(root->right);\\n    }\\n    TreeNode* buildTree(int start,int end)\\n    {\\n        if(start>end)\\n            return NULL;\\n        int mid=(start+end)/2;\\n        TreeNode* root=inorder[mid];\\n        root->left=buildTree(start,mid-1);\\n        root->right=buildTree(mid+1,end);\\n        return root;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) \\n    {\\n        if(root==NULL)\\n            return NULL;\\n        findInorder(root);\\n        int n=inorder.size();\\n        root=buildTree(0,n-1);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 551956,
                "title": "python-3-dfs-in-order-extraction-balanced-tree-building",
                "content": "# Steps\\n1. We use DFS (in-order) to extract node values while preserving the order.\\n2. We build the balanced tree by recursively taking the middle element of the ordered list as root.\\n\\n*Note: we use indices (`l:left`, `r:right`) instead of slicing to preserve space.*\\n\\n```Python\\nclass Solution:\\n    def balanceBST(self, root):\\n        \\n        def dfs(node):\\n            if not node: return []\\n            return dfs(node.left) + [node.val] + dfs(node.right)\\n        ns = dfs(root)\\n        \\n        def build(l, r):\\n            if l > r: return None\\n            m = (l + r) // 2\\n            root = TreeNode(ns[m])\\n            root.left, root.right = build(l, m-1), build(m + 1, r)\\n            return root\\n        \\n        return build(0, len(ns) - 1)\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```Python\\nclass Solution:\\n    def balanceBST(self, root):\\n        \\n        def dfs(node):\\n            if not node: return []\\n            return dfs(node.left) + [node.val] + dfs(node.right)\\n        ns = dfs(root)\\n        \\n        def build(l, r):\\n            if l > r: return None\\n            m = (l + r) // 2\\n            root = TreeNode(ns[m])\\n            root.left, root.right = build(l, m-1), build(m + 1, r)\\n            return root\\n        \\n        return build(0, len(ns) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838211,
                "title": "java-solution-2-ms-and-100-divide-and-conquer",
                "content": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        if (root == null)\\n            return null;\\n        \\n        if (root.left == null && root.right == null)\\n            return root;\\n        \\n        List<Integer> bstArray = new ArrayList<Integer>();\\n        getSortedList(root, bstArray);\\n        \\n        root = createBST(bstArray, 0, bstArray.size()-1);\\n        return root;\\n    }\\n    \\n    public void getSortedList(TreeNode root, List<Integer> list) {\\n        \\n        if (root == null)\\n            return;\\n        \\n        getSortedList(root.left, list);\\n        list.add(root.val);\\n        getSortedList(root.right, list);\\n    }\\n    \\n    public TreeNode createBST(List<Integer> list, int start, int end) {\\n        \\n        if (start > end)\\n            return null;\\n        \\n        int mid = (start + end)/2;\\n        \\n        TreeNode root = new TreeNode(list.get(mid));\\n        root.left = createBST(list, start, mid-1);\\n        root.right = createBST(list, mid+1, end);\\n        \\n        return root;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        if (root == null)\\n            return null;\\n        \\n        if (root.left == null && root.right == null)\\n            return root;\\n        \\n        List<Integer> bstArray = new ArrayList<Integer>();\\n        getSortedList(root, bstArray);\\n        \\n        root = createBST(bstArray, 0, bstArray.size()-1);\\n        return root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 596965,
                "title": "python-solution-based-on-rotations-o-1-space-o-nlogn-runtime",
                "content": "```\\n\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        def rotateLeft(x: TreeNode, p: TreeNode) -> TreeNode:\\n            y = x.right\\n            x.right = y.left\\n            y.left = x\\n            \\n            if p.left == x:\\n                p.left = y\\n            else:\\n                p.right = y\\n            \\n            return y\\n            \\n        def rotateRight(x: TreeNode, p: TreeNode) -> TreeNode:\\n            y = x.left\\n            x.left = y.right       \\n            y.right = x\\n            \\n            if p.left == x:\\n                p.left = y\\n            else:\\n                p.right = y\\n            \\n            return y\\n        \\n        def getHeight(node: TreeNode) -> int:\\n            if not node:\\n                return 0\\n            \\n            return max(getHeight(node.left), getHeight(node.right)) + 1\\n        \\n        def recBalance(node: TreeNode, p: TreeNode) -> tuple:\\n            if not node:\\n                return 0,0\\n            \\n            left_height, left_balance = recBalance(node.left, node)\\n            right_height, right_balance = recBalance(node.right, node)        \\n            \\n            node_balance = left_height - right_height\\n            \\n            if node_balance > 1:\\n                if left_balance < 0:\\n                    rotateLeft(node.left, node)\\n                return recBalance(rotateRight(node, p), p)\\n            elif node_balance < -1:\\n                if right_balance > 0:\\n                    rotateRight(node.right, node)\\n                return recBalance(rotateLeft(node, p), p)\\n            else:\\n                left_height, right_height = getHeight(node.left), getHeight(node.right)\\n                return max(left_height, right_height) + 1, left_height - right_height\\n    \\n        dummy = TreeNode(None)\\n        dummy.right = root\\n        recBalance(dummy.right, dummy)\\n        return dummy.right\\n    \\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        def rotateLeft(x: TreeNode, p: TreeNode) -> TreeNode:\\n            y = x.right\\n            x.right = y.left\\n            y.left = x\\n            \\n            if p.left == x:\\n                p.left = y\\n            else:\\n                p.right = y\\n            \\n            return y\\n            \\n        def rotateRight(x: TreeNode, p: TreeNode) -> TreeNode:\\n            y = x.left\\n            x.left = y.right       \\n            y.right = x\\n            \\n            if p.left == x:\\n                p.left = y\\n            else:\\n                p.right = y\\n            \\n            return y\\n        \\n        def getHeight(node: TreeNode) -> int:\\n            if not node:\\n                return 0\\n            \\n            return max(getHeight(node.left), getHeight(node.right)) + 1\\n        \\n        def recBalance(node: TreeNode, p: TreeNode) -> tuple:\\n            if not node:\\n                return 0,0\\n            \\n            left_height, left_balance = recBalance(node.left, node)\\n            right_height, right_balance = recBalance(node.right, node)        \\n            \\n            node_balance = left_height - right_height\\n            \\n            if node_balance > 1:\\n                if left_balance < 0:\\n                    rotateLeft(node.left, node)\\n                return recBalance(rotateRight(node, p), p)\\n            elif node_balance < -1:\\n                if right_balance > 0:\\n                    rotateRight(node.right, node)\\n                return recBalance(rotateLeft(node, p), p)\\n            else:\\n                left_height, right_height = getHeight(node.left), getHeight(node.right)\\n                return max(left_height, right_height) + 1, left_height - right_height\\n    \\n        dummy = TreeNode(None)\\n        dummy.right = root\\n        recBalance(dummy.right, dummy)\\n        return dummy.right\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 599833,
                "title": "python-sol-by-rebuilding-w-hint",
                "content": "Python sol by rebuilding.\\n\\n---\\n**Hint**:\\n\\nExcept for roration-based algorithm, like [this post](https://leetcode.com/problems/balance-a-binary-search-tree/discuss/541785/C%2B%2BJava-with-picture-DSW-O(n)orO(1)) by @votrubac.\\n\\nThere is another one feasible solution.\\nWe can reuse the algorithm we had developed before in [Leetcode #108 Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/).\\n\\n---\\n\\nHere is the procedure:\\n\\n1. \\nFlatten original BST into a ascending sorted sequence.\\n( Recall that BST is a binary tree with ordered elements with inorder traversal )\\n\\n2. \\nConvert asecnding sorted sequence into Balanced BST by the algorithm in Leetcode #108\\n\\n---\\n\\n**Implementation**:\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        \\n        nums = []\\n        \\n        def inorder( node,nums):\\n            \\'\\'\\'\\n            Convert BST to ascending sequence\\n            \\'\\'\\'    \\n            if node:\\n                \\n                inorder( node.left, nums )\\n                nums.append( node.val )\\n                inorder( node.right, nums )\\n                \\n        # ----------------------------------------\\n        \\n        def sequence_to_balanced_BST( left, right, nums):\\n            \\'\\'\\'\\n            Convert ascending sequence to balanced BST\\n            \\'\\'\\'\\n            if left > right:\\n                # Base case:\\n                return None\\n            \\n            else:\\n                # General case:\\n\\n                mid = left + ( right - left ) // 2\\n\\n                root = TreeNode( nums[mid] )\\n\\n                root.left = sequence_to_balanced_BST( left, mid-1, nums)\\n                root.right = sequence_to_balanced_BST( mid+1, right, nums)\\n\\n                return root\\n        \\n        # ----------------------------------------\\n\\t\\t\\n        # Flatten original BST into a ascending sorted sequence.\\n        inorder( root, nums )\\n        \\n\\t\\t# Convert asecnding sorted sequence into Balanced BST by the algorithm in Leetcode #108\\n        return sequence_to_balanced_BST( left = 0, right = len(nums)-1, nums = nums)\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[1] [Leetcode #94 Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal)\\n\\n[2] [Leetcode #108 Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Divide and Conquer",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        \\n        nums = []\\n        \\n        def inorder( node,nums):\\n            \\'\\'\\'\\n            Convert BST to ascending sequence\\n            \\'\\'\\'    \\n            if node:\\n                \\n                inorder( node.left, nums )\\n                nums.append( node.val )\\n                inorder( node.right, nums )\\n                \\n        # ----------------------------------------\\n        \\n        def sequence_to_balanced_BST( left, right, nums):\\n            \\'\\'\\'\\n            Convert ascending sequence to balanced BST\\n            \\'\\'\\'\\n            if left > right:\\n                # Base case:\\n                return None\\n            \\n            else:\\n                # General case:\\n\\n                mid = left + ( right - left ) // 2\\n\\n                root = TreeNode( nums[mid] )\\n\\n                root.left = sequence_to_balanced_BST( left, mid-1, nums)\\n                root.right = sequence_to_balanced_BST( mid+1, right, nums)\\n\\n                return root\\n        \\n        # ----------------------------------------\\n\\t\\t\\n        # Flatten original BST into a ascending sorted sequence.\\n        inorder( root, nums )\\n        \\n\\t\\t# Convert asecnding sorted sequence into Balanced BST by the algorithm in Leetcode #108\\n        return sequence_to_balanced_BST( left = 0, right = len(nums)-1, nums = nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362115,
                "title": "java-easy-approach-with-explanation-recursive-inorder-postoder-dfs",
                "content": "```\\nclass Solution\\n{\\n    List<Integer> arrS= new ArrayList<>();//to store the node value in sorted manner  \\n    \\n    public void inorder(TreeNode root) \\n    {//BST of inorder is sorted \\n        if (root == null)//base case when we reach to the null node \\n            return;//deleting the current activation block and returning to the parent \\n        \\n        inorder(root.left);//recursing down the left subtree \\n        \\n        arrS.add(root.val);//manipulating the root// adding the node value in ascending order \\n        \\n        inorder(root.right);//recursing down the right subtree \\n        \\n        return;//deleting the current activation block and returning to the parent, as all thefunctions are completed \\n    }\\n    \\n    public TreeNode createBST(int low, int high) \\n    {//postorder, bottom up approach is used because we want to know the child first then the parent \\n        if(low > high)//base case //not creating any further node on wrong index \\n           return null;\\n        \\n        int mid= low + (high - low)/2;//getting the middle index at every activation block \\n        \\n        int data= arrS.get(mid);//getting the data in the middle index \\n        \\n        //----Left----(Mid)----Right----\\n        \\n        TreeNode left= createBST(low, mid - 1);//recursing down in the left subtree in search of child, is there or null is returned //lower bound\\n        TreeNode right= createBST(mid + 1, high);//recursing down in the right subtree in search of child, is there or null//upper bound \\n        \\n        TreeNode node= new TreeNode(data, left, right);//finally creating root node after knowing the reference of the children(left, right)\\n       \\n        return node;//return the node to its parent for backward linking//to tell that I am present \\n    }\\n    \\n    public TreeNode balanceBST(TreeNode root) \\n    {\\n        TreeNode rootN= null;\\n        if(root == null)//when we are provided with null graph \\n            return rootN;\\n        \\n        inorder(root);//creates the sorted ArrayList \\n        rootN= createBST(0, arrS.size() - 1);//creates the tree and returns the root, because root is the last node created as it takes time to get left and right child information since we are doing postorder traversal \\n        return rootN;\\n    }\\n}//please do Upvote, it helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    List<Integer> arrS= new ArrayList<>();//to store the node value in sorted manner  \\n    \\n    public void inorder(TreeNode root) \\n    {//BST of inorder is sorted \\n        if (root == null)//base case when we reach to the null node \\n            return;//deleting the current activation block and returning to the parent \\n        \\n        inorder(root.left);//recursing down the left subtree \\n        \\n        arrS.add(root.val);//manipulating the root// adding the node value in ascending order \\n        \\n        inorder(root.right);//recursing down the right subtree \\n        \\n        return;//deleting the current activation block and returning to the parent, as all thefunctions are completed \\n    }\\n    \\n    public TreeNode createBST(int low, int high) \\n    {//postorder, bottom up approach is used because we want to know the child first then the parent \\n        if(low > high)//base case //not creating any further node on wrong index \\n           return null;\\n        \\n        int mid= low + (high - low)/2;//getting the middle index at every activation block \\n        \\n        int data= arrS.get(mid);//getting the data in the middle index \\n        \\n        //----Left----(Mid)----Right----\\n        \\n        TreeNode left= createBST(low, mid - 1);//recursing down in the left subtree in search of child, is there or null is returned //lower bound\\n        TreeNode right= createBST(mid + 1, high);//recursing down in the right subtree in search of child, is there or null//upper bound \\n        \\n        TreeNode node= new TreeNode(data, left, right);//finally creating root node after knowing the reference of the children(left, right)\\n       \\n        return node;//return the node to its parent for backward linking//to tell that I am present \\n    }\\n    \\n    public TreeNode balanceBST(TreeNode root) \\n    {\\n        TreeNode rootN= null;\\n        if(root == null)//when we are provided with null graph \\n            return rootN;\\n        \\n        inorder(root);//creates the sorted ArrayList \\n        rootN= createBST(0, arrS.size() - 1);//creates the tree and returns the root, because root is the last node created as it takes time to get left and right child information since we are doing postorder traversal \\n        return rootN;\\n    }\\n}//please do Upvote, it helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 552673,
                "title": "python-solution",
                "content": "```\\ndef balanceBST(self, root: TreeNode) -> TreeNode:\\n        vals=[]\\n        def inorder(node):\\n            if node:\\n                inorder(node.left)\\n                vals.append(node.val)\\n                inorder(node.right)\\n        def balance(l, r):\\n            if l<=r:\\n                mid = (l+r)//2\\n                cur = TreeNode(vals[mid])\\n                cur.left = balance(l, mid-1)\\n                cur.right = balance(mid+1, r)\\n                return cur\\n        inorder(root)\\n        n=len(vals)\\n        return balance(0, n-1)\\n```",
                "solutionTags": [],
                "code": "```\\ndef balanceBST(self, root: TreeNode) -> TreeNode:\\n        vals=[]\\n        def inorder(node):\\n            if node:\\n                inorder(node.left)\\n                vals.append(node.val)\\n                inorder(node.right)\\n        def balance(l, r):\\n            if l<=r:\\n                mid = (l+r)//2\\n                cur = TreeNode(vals[mid])\\n                cur.left = balance(l, mid-1)\\n                cur.right = balance(mid+1, r)\\n                return cur\\n        inorder(root)\\n        n=len(vals)\\n        return balance(0, n-1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 621291,
                "title": "javascript-simple-solution-using-tree-reconstruction",
                "content": "Steps:\\n1. Use inorder traversal to create a sorted array\\n2. Construct a balance tree using the sorted array\\n```javascript\\nvar balanceBST = function(root) {\\n    function inOrder(myRoot) {\\n        if(!myRoot) return [];\\n        return [...inOrder(myRoot.left), myRoot.val, ...inOrder(myRoot.right)]\\n    }\\n    const sortedArr = inOrder(root)\\n    \\n    function constructTree(arr) {\\n        if(!arr.length) return null;\\n        \\n        const mid = Math.floor(arr.length / 2);\\n        const node = new TreeNode(arr[mid])\\n        node.left = constructTree(arr.slice(0, mid));\\n        node.right = constructTree(arr.slice(mid+1));\\n        \\n        return node;\\n    }\\n    return constructTree(sortedArr);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar balanceBST = function(root) {\\n    function inOrder(myRoot) {\\n        if(!myRoot) return [];\\n        return [...inOrder(myRoot.left), myRoot.val, ...inOrder(myRoot.right)]\\n    }\\n    const sortedArr = inOrder(root)\\n    \\n    function constructTree(arr) {\\n        if(!arr.length) return null;\\n        \\n        const mid = Math.floor(arr.length / 2);\\n        const node = new TreeNode(arr[mid])\\n        node.left = constructTree(arr.slice(0, mid));\\n        node.right = constructTree(arr.slice(mid+1));\\n        \\n        return node;\\n    }\\n    return constructTree(sortedArr);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1124362,
                "title": "java-in-order-traversal-quite-fast",
                "content": "```\\nclass Solution {\\n    List<TreeNode> list = new ArrayList();                                         //declaring list globally so that it can be accessed thoughout the program.\\n    public void InOrder(TreeNode root) {                                           //InOrder traveral of the tree.\\n        \\n        if(root == null)\\n            return;\\n        else\\n        {\\n            InOrder(root.left);\\n            list.add(root);\\n            InOrder(root.right);    \\n        }\\n    }\\n    \\n    public TreeNode balancedBST(int start,int end) {                                   //creating new tree with the help of list.\\n        if(start>end)\\n            return null;\\n        int mid = (start+end)/2;\\n        TreeNode root = list.get(mid);\\n        root.left = balancedBST(start,mid-1);\\n        root.right = balancedBST(mid+1,end);\\n        return root;\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        if(root ==null)\\n            return null;\\n        InOrder(root);\\n        return balancedBST(0,list.size()-1);\\n    }\\n}\\n```\\n\\n# // Do upvote if you like.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<TreeNode> list = new ArrayList();                                         //declaring list globally so that it can be accessed thoughout the program.\\n    public void InOrder(TreeNode root) {                                           //InOrder traveral of the tree.\\n        \\n        if(root == null)\\n            return;\\n        else\\n        {\\n            InOrder(root.left);\\n            list.add(root);\\n            InOrder(root.right);    \\n        }\\n    }\\n    \\n    public TreeNode balancedBST(int start,int end) {                                   //creating new tree with the help of list.\\n        if(start>end)\\n            return null;\\n        int mid = (start+end)/2;\\n        TreeNode root = list.get(mid);\\n        root.left = balancedBST(start,mid-1);\\n        root.right = balancedBST(mid+1,end);\\n        return root;\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        if(root ==null)\\n            return null;\\n        InOrder(root);\\n        return balancedBST(0,list.size()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315556,
                "title": "easiest-solution-full-beginner-level-code",
                "content": "# Intuition\\n1) InOrder Sequence\\n2) Conversion of ArrayList into Balanced BST.\\n3) return BST\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1) Step -> is to add all the elements in ArrayList in sorted form.\\n2) Step -> Then conversion of arr to Balanced BST\\n3) Step -> return root.\\n<!-- Describe your approach to solving the problem. -->\\n-> If you will try to understand to will understand it very easily <-\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nPlssss Up Vote! -> \\uD83D\\uDE2D\\n# Code\\n```\\nclass Solution {\\n    public static void getInOrder(TreeNode root, ArrayList<Integer> inorder){\\n        if(root==null){\\n            return;\\n        }\\n        getInOrder(root.left,inorder);\\n        inorder.add(root.val);\\n        getInOrder(root.right,inorder);\\n    }\\n    public static TreeNode CreateBST(ArrayList<Integer> inorder, int left, int right) {\\n        if (left > right) return null;\\n        int m = (right + left) / 2;\\n        TreeNode root = new TreeNode(inorder.get(m));\\n        root.left = CreateBST(inorder, left, m - 1);\\n        root.right = CreateBST(inorder, m+ 1, right);\\n        return root;\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> inorder = new ArrayList<>();\\n        getInOrder(root,inorder);\\n        root = CreateBST(inorder,0,inorder.size()-1);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static void getInOrder(TreeNode root, ArrayList<Integer> inorder){\\n        if(root==null){\\n            return;\\n        }\\n        getInOrder(root.left,inorder);\\n        inorder.add(root.val);\\n        getInOrder(root.right,inorder);\\n    }\\n    public static TreeNode CreateBST(ArrayList<Integer> inorder, int left, int right) {\\n        if (left > right) return null;\\n        int m = (right + left) / 2;\\n        TreeNode root = new TreeNode(inorder.get(m));\\n        root.left = CreateBST(inorder, left, m - 1);\\n        root.right = CreateBST(inorder, m+ 1, right);\\n        return root;\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> inorder = new ArrayList<>();\\n        getInOrder(root,inorder);\\n        root = CreateBST(inorder,0,inorder.size()-1);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919887,
                "title": "another-avl-solution-with-some-remarks-accepted-java",
                "content": "```\\nclass Solution {\\n    Map<TreeNode, Integer> nodeToHeight = new HashMap<>();\\n    {\\n        nodeToHeight.put(null, -1);    \\n    }\\n    int threshold = 1;         \\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        if(root == null) {\\n            return null;\\n        }    \\n        TreeNode left =  balanceBST(root.left);        \\n        TreeNode right = balanceBST(root.right);    \\n        root.left = left;\\n        root.right = right;\\n        int leftHeight = nodeToHeight.get(left);\\n        int rightHeight = nodeToHeight.get(right);\\n        int balance = rightHeight - leftHeight;                   \\n        nodeToHeight.put(root, 1 + Math.max(leftHeight, rightHeight));        \\n        if(Math.abs(balance) > threshold) {\\n            if(balance > 0) {                                                               \\n                if(getBalance(right) < 0) {\\n                   root.right = rotateRight(right);          \\n                }              \\n                root = rotateLeft(root);  \\n            }                            \\n            else {                \\n                if(getBalance(left) > 0) {                    \\n                   root.left = rotateLeft(left);\\n                }               \\n                root = rotateRight(root);                  \\n            }\\n        } \\n\\t\\t//comment out this _if block_ if you want to see the solution to fail for some testcases like\\n\\t\\t//[1,null,15,14,17,7,null,null,null,2,12,null,3,9,null,null,null,null,11]\\n        if(!isBalanced(root)) {\\n            return balanceBST(root);\\n        }\\n        return root;\\n    }\\n    \\t\\n    private int getBalance(TreeNode node) {\\n        return nodeToHeight.get(node.right) - nodeToHeight.get(node.left);\\n    }\\n    \\n    private TreeNode rotateRight(TreeNode node) {\\n        if(node == null || node.left == null) {\\n            return node;\\n        }        \\n        TreeNode left = node.left;        \\n        int height1 = nodeToHeight.get(left.left);\\n        TreeNode two = left.right;\\n        int height2 = nodeToHeight.get(two);\\n        int height3 = nodeToHeight.get(node.right);\\n        TreeNode root = left;\\n        root.right = node;\\n        node.left = two;  \\n        int newNodeHeight = 1 + Math.max(height2, height3);\\n        int newRootHeight = 1 + Math.max(height1, newNodeHeight);\\n        nodeToHeight.put(node, newNodeHeight);\\n        nodeToHeight.put(root, newRootHeight);\\n        return root;\\n    }\\n    \\n    private TreeNode rotateLeft(TreeNode node) {\\n        if(node == null || node.right == null) {\\n            return node;\\n        }\\n        TreeNode right = node.right; \\n        int height1 = nodeToHeight.get(node.left);\\n        TreeNode two = right.left;\\n        int height2 = nodeToHeight.get(two);\\n        int height3 = nodeToHeight.get(right.right);\\n        TreeNode root = right;\\n        root.left = node;\\n        node.right = two;\\n        int newNodeHeight = 1 + Math.max(height1, height2);\\n        int newRootHeight = 1 + Math.max(height3, newNodeHeight);\\n        nodeToHeight.put(node, newNodeHeight);\\n        nodeToHeight.put(root, newRootHeight);\\n        return root;\\n    }\\n    \\n    private boolean isBalanced(TreeNode root) {\\n        if(root == null) {\\n            return true;\\n        }\\n        boolean left = isBalanced(root.left);\\n        boolean right = isBalanced(root.right);\\n        return left && right && Math.abs(getBalance(root)) <= threshold;                    \\n    }\\n}\\n```\\nIt turns out, not all binary trees can be balanced by rotation on \"one go\" (one set of recursive calls).\\nExample:\\n[1,null,15,14,17,7,null,null,null,2,12,null,3,9,null,null,null,null,11]\\n![image](https://assets.leetcode.com/users/images/97250f89-a24a-496c-88a6-20fce9c22449_1604278341.2874842.png)\\n\\nWithout additional calls to balanceBST resulting tree can still be unbalanced:\\n[11,1,15,null,7,14,17,2,9,12,null,null,null,null,3]\\n![image](https://assets.leetcode.com/users/images/7a9cf12b-c295-449c-be1a-3795c3ad7200_1604278362.8475924.png)\\n\\nNotice how \"node 11\" itself has Math.abs(balance) equal to 1, yet \"node 1\" is still unbalanced.\\n\\nJust comment out this portion of code in *balanceBST* method to see the test fail:\\n```\\n if(!isBalanced(root)) {\\n        return balanceBST(root);\\n }\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<TreeNode, Integer> nodeToHeight = new HashMap<>();\\n    {\\n        nodeToHeight.put(null, -1);    \\n    }\\n    int threshold = 1;         \\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        if(root == null) {\\n            return null;\\n        }    \\n        TreeNode left =  balanceBST(root.left);        \\n        TreeNode right = balanceBST(root.right);    \\n        root.left = left;\\n        root.right = right;\\n        int leftHeight = nodeToHeight.get(left);\\n        int rightHeight = nodeToHeight.get(right);\\n        int balance = rightHeight - leftHeight;                   \\n        nodeToHeight.put(root, 1 + Math.max(leftHeight, rightHeight));        \\n        if(Math.abs(balance) > threshold) {\\n            if(balance > 0) {                                                               \\n                if(getBalance(right) < 0) {\\n                   root.right = rotateRight(right);          \\n                }              \\n                root = rotateLeft(root);  \\n            }                            \\n            else {                \\n                if(getBalance(left) > 0) {                    \\n                   root.left = rotateLeft(left);\\n                }               \\n                root = rotateRight(root);                  \\n            }\\n        } \\n\\t\\t//comment out this _if block_ if you want to see the solution to fail for some testcases like\\n\\t\\t//[1,null,15,14,17,7,null,null,null,2,12,null,3,9,null,null,null,null,11]\\n        if(!isBalanced(root)) {\\n            return balanceBST(root);\\n        }\\n        return root;\\n    }\\n    \\t\\n    private int getBalance(TreeNode node) {\\n        return nodeToHeight.get(node.right) - nodeToHeight.get(node.left);\\n    }\\n    \\n    private TreeNode rotateRight(TreeNode node) {\\n        if(node == null || node.left == null) {\\n            return node;\\n        }        \\n        TreeNode left = node.left;        \\n        int height1 = nodeToHeight.get(left.left);\\n        TreeNode two = left.right;\\n        int height2 = nodeToHeight.get(two);\\n        int height3 = nodeToHeight.get(node.right);\\n        TreeNode root = left;\\n        root.right = node;\\n        node.left = two;  \\n        int newNodeHeight = 1 + Math.max(height2, height3);\\n        int newRootHeight = 1 + Math.max(height1, newNodeHeight);\\n        nodeToHeight.put(node, newNodeHeight);\\n        nodeToHeight.put(root, newRootHeight);\\n        return root;\\n    }\\n    \\n    private TreeNode rotateLeft(TreeNode node) {\\n        if(node == null || node.right == null) {\\n            return node;\\n        }\\n        TreeNode right = node.right; \\n        int height1 = nodeToHeight.get(node.left);\\n        TreeNode two = right.left;\\n        int height2 = nodeToHeight.get(two);\\n        int height3 = nodeToHeight.get(right.right);\\n        TreeNode root = right;\\n        root.left = node;\\n        node.right = two;\\n        int newNodeHeight = 1 + Math.max(height1, height2);\\n        int newRootHeight = 1 + Math.max(height3, newNodeHeight);\\n        nodeToHeight.put(node, newNodeHeight);\\n        nodeToHeight.put(root, newRootHeight);\\n        return root;\\n    }\\n    \\n    private boolean isBalanced(TreeNode root) {\\n        if(root == null) {\\n            return true;\\n        }\\n        boolean left = isBalanced(root.left);\\n        boolean right = isBalanced(root.right);\\n        return left && right && Math.abs(getBalance(root)) <= threshold;                    \\n    }\\n}\\n```\n```\\n if(!isBalanced(root)) {\\n        return balanceBST(root);\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 742665,
                "title": "c-simple-clean-code",
                "content": "```\\nvector<TreeNode*> ans;\\n    void inorder(TreeNode *root) {\\n        if(!root) return;\\n        inorder(root->left);\\n        ans.push_back(root);\\n        inorder(root->right);      \\n    }\\n    TreeNode* solve(int l,int h) {\\n        if(l>h) return NULL;\\n        int m=(l+h)/2;\\n        ans[m]->left=solve(l,m-1);\\n        ans[m]->right=solve(m+1,h);\\n        return ans[m];\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorder(root);\\n        return solve(0,ans.size()-1);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<TreeNode*> ans;\\n    void inorder(TreeNode *root) {\\n        if(!root) return;\\n        inorder(root->left);\\n        ans.push_back(root);\\n        inorder(root->right);      \\n    }\\n    TreeNode* solve(int l,int h) {\\n        if(l>h) return NULL;\\n        int m=(l+h)/2;\\n        ans[m]->left=solve(l,m-1);\\n        ans[m]->right=solve(m+1,h);\\n        return ans[m];\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorder(root);\\n        return solve(0,ans.size()-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1764006,
                "title": "python-easy-to-read-and-understand-inorder-and-recusion",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def bst(self, nums, i, j):\\n        if i > j:\\n            return None\\n        mid = (i+j) // 2\\n        node = TreeNode(nums[mid])\\n        node.left = self.bst(nums, i, mid-1)\\n        node.right = self.bst(nums, mid+1, j)\\n        return node\\n    \\n    def dfs(self, node):\\n        if not node:\\n            return []\\n        l, r = self.dfs(node.left), self.dfs(node.right)\\n        return l + [node.val] + r\\n    \\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        nums = self.dfs(root)\\n        return self.bst(nums, 0, len(nums)-1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def bst(self, nums, i, j):\\n        if i > j:\\n            return None\\n        mid = (i+j) // 2\\n        node = TreeNode(nums[mid])\\n        node.left = self.bst(nums, i, mid-1)\\n        node.right = self.bst(nums, mid+1, j)\\n        return node\\n    \\n    def dfs(self, node):\\n        if not node:\\n            return []\\n        l, r = self.dfs(node.left), self.dfs(node.right)\\n        return l + [node.val] + r\\n    \\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        nums = self.dfs(root)\\n        return self.bst(nums, 0, len(nums)-1)",
                "codeTag": "Java"
            },
            {
                "id": 1324526,
                "title": "c-bst-using-rotation",
                "content": "Solving using recursion. Basically, at each node, we assume that the left and right sub-trees are balanced. Now we have to merge the 2 sub-trees with the node. There are 5 conditions that can occur during the balancing.\\nCondition for balanced tree is that ```abs(left_height - right_height)) <= 1 ```\\n1. Root node is already balanced -> Do Nothing.\\n2. Root node is unbalanced leaning on the left and the left sub-tree also has a height of or more -> (LL configuration) -> To balance this, simply do a right rotation. \\n3. LR configuration -> Do 2 swaps. First left rotate the left sub-tree root to make it a LL configuration, then right rotate the root.\\n4. RR configuration -> Do a left rotation on the root\\n5. RL configuration -> First right rotate the right sub-tree root to make it a RR config. Then left rotate the root.\\n\\nWhenever we rotate, we need to make sure the swapped nodes, form a balanced sub-tree too!\\n```\\n    int getHeight(TreeNode *root){\\n        if(root == NULL) return -1;\\n        return max(getHeight(root->left), getHeight(root->right))+1;\\n    }\\n    int isBalanced(TreeNode *root){\\n        return getHeight(root->left) - getHeight(root->right);\\n    }\\n    \\n    TreeNode* leftRotate(TreeNode* root){\\n        TreeNode* x = root->right;\\n        root->right = x->left;\\n        x->left = getRotation(root);\\n        return getRotation(x);\\n    }\\n    \\n    TreeNode* rightRotate(TreeNode* root){ // O(1)\\n       TreeNode* x = root->left;\\n        root->left = x->right;\\n        x->right = getRotation(root);\\n        return getRotation(x);\\n    }\\n    \\n    TreeNode* getRotation(TreeNode *root){\\n        int bal = isBalanced(root);\\n        // cout<<\"Root: \"<<root->val<<\" Bal: \"<<bal<<endl;\\n        if(bal >=2){ //Left height  > right height -> LL, LR\\n            if(isBalanced(root->left) >= 1){ // LL\\n                // cout<<\"LL case: RightRotate(\"<<root->val<<\")\"<<endl;\\n                return rightRotate(root);\\n            }\\n            else{ //LR\\n                // auto tmp = (root->left==NULL)?INT_MAX:root->left->val;\\n                // cout<<\"LR case: leftRotate(\"<<tmp<<\")\"<<endl;\\n                root->left = leftRotate(root->left);\\n                // cout<<\"LR case: RightRotate(\"<<root->val<<\")\"<<endl;\\n                return rightRotate(root);\\n            }\\n        }\\n        else if(bal <= -2){ //RR , RL\\n            if(isBalanced(root->right) <= -1){ // RR\\n                // cout<<\"RR case: LeftRotate(\"<<root->val<<\")\"<<endl;\\n                return leftRotate(root);\\n            }\\n            else{ //RL\\n                // auto tmp = (root->right==NULL)?INT_MAX:root->right->val; \\n                // cout<<\"RL case: RightRotate(\"<<tmp<<\")\"<<endl;\\n                root->right = rightRotate(root->right);\\n                // cout<<\"RL case: LeftRotate(\"<<root->val<<\")\"<<endl;\\n                return leftRotate(root);\\n            }        \\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        if(root == NULL) return NULL;\\n        // cout<<\"balanceBST(\"<<root->val<<\")\"<<endl;\\n        root->left = balanceBST(root->left);\\n        // int tmp = (root->left)?root->left->val: INT_MAX;\\n        // cout<<root->val<<\"->left = \"<<tmp<<endl;\\n        root->right = balanceBST(root->right);\\n        // tmp = (root->right)?root->right->val: INT_MAX;\\n        // cout<<root->val<<\"->right = \"<<tmp<<endl;\\n        return getRotation(root);\\n        \\n    }\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```abs(left_height - right_height)) <= 1 ```\n```\\n    int getHeight(TreeNode *root){\\n        if(root == NULL) return -1;\\n        return max(getHeight(root->left), getHeight(root->right))+1;\\n    }\\n    int isBalanced(TreeNode *root){\\n        return getHeight(root->left) - getHeight(root->right);\\n    }\\n    \\n    TreeNode* leftRotate(TreeNode* root){\\n        TreeNode* x = root->right;\\n        root->right = x->left;\\n        x->left = getRotation(root);\\n        return getRotation(x);\\n    }\\n    \\n    TreeNode* rightRotate(TreeNode* root){ // O(1)\\n       TreeNode* x = root->left;\\n        root->left = x->right;\\n        x->right = getRotation(root);\\n        return getRotation(x);\\n    }\\n    \\n    TreeNode* getRotation(TreeNode *root){\\n        int bal = isBalanced(root);\\n        // cout<<\"Root: \"<<root->val<<\" Bal: \"<<bal<<endl;\\n        if(bal >=2){ //Left height  > right height -> LL, LR\\n            if(isBalanced(root->left) >= 1){ // LL\\n                // cout<<\"LL case: RightRotate(\"<<root->val<<\")\"<<endl;\\n                return rightRotate(root);\\n            }\\n            else{ //LR\\n                // auto tmp = (root->left==NULL)?INT_MAX:root->left->val;\\n                // cout<<\"LR case: leftRotate(\"<<tmp<<\")\"<<endl;\\n                root->left = leftRotate(root->left);\\n                // cout<<\"LR case: RightRotate(\"<<root->val<<\")\"<<endl;\\n                return rightRotate(root);\\n            }\\n        }\\n        else if(bal <= -2){ //RR , RL\\n            if(isBalanced(root->right) <= -1){ // RR\\n                // cout<<\"RR case: LeftRotate(\"<<root->val<<\")\"<<endl;\\n                return leftRotate(root);\\n            }\\n            else{ //RL\\n                // auto tmp = (root->right==NULL)?INT_MAX:root->right->val; \\n                // cout<<\"RL case: RightRotate(\"<<tmp<<\")\"<<endl;\\n                root->right = rightRotate(root->right);\\n                // cout<<\"RL case: LeftRotate(\"<<root->val<<\")\"<<endl;\\n                return leftRotate(root);\\n            }        \\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        if(root == NULL) return NULL;\\n        // cout<<\"balanceBST(\"<<root->val<<\")\"<<endl;\\n        root->left = balanceBST(root->left);\\n        // int tmp = (root->left)?root->left->val: INT_MAX;\\n        // cout<<root->val<<\"->left = \"<<tmp<<endl;\\n        root->right = balanceBST(root->right);\\n        // tmp = (root->right)?root->right->val: INT_MAX;\\n        // cout<<root->val<<\"->right = \"<<tmp<<endl;\\n        return getRotation(root);\\n        \\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 970237,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        List<TreeNode> ls=new ArrayList<>();\\n        inorder(root,ls);\\n        return construct(ls,0,ls.size()-1);\\n    }\\n    public void inorder(TreeNode root,List<TreeNode> ls){\\n        if(root==null){\\n            return;\\n        }\\n        inorder(root.left,ls);\\n        ls.add(root);\\n        inorder(root.right,ls);\\n    }\\n    public TreeNode construct(List<TreeNode> ls,int si,int ei){\\n        if(si>ei)\\n            return null;\\n        int mid=(si+ei)/2;\\n        TreeNode root=ls.get(mid);\\n        root.left=construct(ls,si,mid-1);\\n        root.right=construct(ls,mid+1,ei);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        List<TreeNode> ls=new ArrayList<>();\\n        inorder(root,ls);\\n        return construct(ls,0,ls.size()-1);\\n    }\\n    public void inorder(TreeNode root,List<TreeNode> ls){\\n        if(root==null){\\n            return;\\n        }\\n        inorder(root.left,ls);\\n        ls.add(root);\\n        inorder(root.right,ls);\\n    }\\n    public TreeNode construct(List<TreeNode> ls,int si,int ei){\\n        if(si>ei)\\n            return null;\\n        int mid=(si+ei)/2;\\n        TreeNode root=ls.get(mid);\\n        root.left=construct(ls,si,mid-1);\\n        root.right=construct(ls,mid+1,ei);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701184,
                "title": "very-simple-solution-using-java-python",
                "content": "> # Algorithm \\n- Traverse and find the inorder of the tree and store it in an ArrayList.\\n- Now Similar to merge sort we mantain low, high pointers and mid will be the root element and the left part will be its left subtree and right part will be its right subtree. \\n- We will be recursively travelling to the left and right parts of the ArrayList.\\n- Finally we will return the root that if have got from the buildTree function.\\n> ## *Look at the code for better understanding.* \\n---\\n# Java\\n```\\nclass Solution {\\n    public void inorderTraversal(TreeNode root,List<Integer> lst)\\n    {\\n        if(root!=null)\\n        {\\n            inorderTraversal(root.left,lst);\\n            lst.add(root.val);\\n            inorderTraversal(root.right,lst);\\n        }\\n    }\\n    public TreeNode buildTree(List<Integer> lst ,int low,int high)\\n    {\\n        if(low > high)  return null;\\n        int mid = (low+high)/2;\\n        TreeNode root = new TreeNode(lst.get(mid));\\n        root.left = buildTree(lst,low,mid-1);\\n        root.right = buildTree(lst,mid+1,high);\\n        return root;\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        List<Integer> lst = new ArrayList<>();\\n        inorderTraversal(root,lst);\\n        root = buildTree(lst,0,lst.size()-1);\\n        return root;\\n    }\\n}\\n```\\n---\\n# Python\\n```\\nclass Solution:\\n    def inorder(self,root,lst):\\n        if root!=None:\\n            self.inorder(root.left,lst)\\n            lst.append(root.val)\\n            self.inorder(root.right,lst)\\n    def buildTree(self,lst,low,high):\\n        if low > high:\\n            return None\\n        mid = (low+high)//2\\n        root = TreeNode(lst[mid])\\n        root.left = self.buildTree(lst,low,mid-1)\\n        root.right = self.buildTree(lst,mid+1,high)\\n        return root\\n\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        lst = []\\n        self.inorder(root,lst)\\n        low = 0\\n        high = len(lst)-1\\n        root = self.buildTree(lst,low,high)\\n        return root\\n```\\n---\\n#### *Please don\\'t forget to upvote if you\\'ve liked my explanation.* \\u2B06\\uFE0F\\n---\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public void inorderTraversal(TreeNode root,List<Integer> lst)\\n    {\\n        if(root!=null)\\n        {\\n            inorderTraversal(root.left,lst);\\n            lst.add(root.val);\\n            inorderTraversal(root.right,lst);\\n        }\\n    }\\n    public TreeNode buildTree(List<Integer> lst ,int low,int high)\\n    {\\n        if(low > high)  return null;\\n        int mid = (low+high)/2;\\n        TreeNode root = new TreeNode(lst.get(mid));\\n        root.left = buildTree(lst,low,mid-1);\\n        root.right = buildTree(lst,mid+1,high);\\n        return root;\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        List<Integer> lst = new ArrayList<>();\\n        inorderTraversal(root,lst);\\n        root = buildTree(lst,0,lst.size()-1);\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def inorder(self,root,lst):\\n        if root!=None:\\n            self.inorder(root.left,lst)\\n            lst.append(root.val)\\n            self.inorder(root.right,lst)\\n    def buildTree(self,lst,low,high):\\n        if low > high:\\n            return None\\n        mid = (low+high)//2\\n        root = TreeNode(lst[mid])\\n        root.left = self.buildTree(lst,low,mid-1)\\n        root.right = self.buildTree(lst,mid+1,high)\\n        return root\\n\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        lst = []\\n        self.inorder(root,lst)\\n        low = 0\\n        high = len(lst)-1\\n        root = self.buildTree(lst,low,high)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2517360,
                "title": "c-sorted-array-to-bst-easy-solution",
                "content": "```\\nvoid inorder(TreeNode* root, vector<int> &in){\\n        // base case\\n        if(!root) return;\\n        inorder(root->left, in);\\n        in.push_back(root->val);\\n        inorder(root->right, in);\\n    }\\n    \\n    TreeNode* createBST(vector<int> &in, int st, int end){\\n        // base case\\n        if(st > end) return NULL;\\n        \\n        int mid = (st+end)/2;\\n        TreeNode* root = new TreeNode(in[mid]);\\n        root->left = createBST(in, st, mid-1);\\n        root->right = createBST(in, mid+1, end);\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> in;\\n        inorder(root, in);\\n        return createBST(in, 0, in.size()-1);\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid inorder(TreeNode* root, vector<int> &in){\\n        // base case\\n        if(!root) return;\\n        inorder(root->left, in);\\n        in.push_back(root->val);\\n        inorder(root->right, in);\\n    }\\n    \\n    TreeNode* createBST(vector<int> &in, int st, int end){\\n        // base case\\n        if(st > end) return NULL;\\n        \\n        int mid = (st+end)/2;\\n        TreeNode* root = new TreeNode(in[mid]);\\n        root->left = createBST(in, st, mid-1);\\n        root->right = createBST(in, mid+1, end);\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> in;\\n        inorder(root, in);\\n        return createBST(in, 0, in.size()-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1345696,
                "title": "using-avl-o-n",
                "content": "\\tint height[];\\n    public void updateHeight(TreeNode root){\\n        int lh = root.left != null ? height[root.left.val] : -1;\\n        int rh = root.right != null ? height[root.right.val] : -1;\\n        \\n        height[root.val] = Math.max(lh,rh) + 1;\\n    }\\n    \\n    public int getBal(TreeNode root){\\n        int lh = root.left != null ? height[root.left.val] : -1;\\n        int rh = root.right != null ? height[root.right.val] : -1;\\n        return lh - rh;\\n    }\\n    \\n    public TreeNode leftRotation(TreeNode A){\\n        TreeNode B = A.right;\\n        TreeNode BkaLeft = B.left;\\n        \\n        B.left = A;\\n        A.right = BkaLeft;\\n        \\n        B.left = getRotation(A);\\n        return getRotation(B);\\n    }\\n    \\n    public TreeNode rightRotation(TreeNode A){\\n        TreeNode B = A.left;\\n        TreeNode BkaRight = B.right;\\n        \\n        B.right = A;\\n        A.left = BkaRight;\\n        \\n        B.right = getRotation(A);\\n        return getRotation(B);\\n    }\\n    \\n    public TreeNode getRotation(TreeNode root){\\n        updateHeight(root);\\n        if(getBal(root) >= 2){   // ll, lr\\n            if(getBal(root.left) >= 1){  // ll\\n                return rightRotation(root);    \\n            }else{    // lr\\n                root.left = leftRotation(root.left);\\n                return rightRotation(root);\\n            }\\n        }else if(getBal(root) <= -2){  // rr,rl\\n            if(getBal(root.right) <= -1){   // rr\\n                return leftRotation(root);\\n            }else{ // rl\\n                root.right = rightRotation(root.right);\\n                return leftRotation(root);\\n            }\\n        }\\n        return root;\\n    }\\n    \\n    public TreeNode postOrder(TreeNode root){\\n        if(root == null) return null;\\n        \\n        root.left = postOrder(root.left);\\n        root.right = postOrder(root.right);\\n        \\n        return getRotation(root);\\n    }\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        height = new int[100001];\\n        return postOrder(root);\\n    }",
                "solutionTags": [],
                "code": "\\tint height[];\\n    public void updateHeight(TreeNode root){\\n        int lh = root.left != null ? height[root.left.val] : -1;\\n        int rh = root.right != null ? height[root.right.val] : -1;\\n        \\n        height[root.val] = Math.max(lh,rh) + 1;\\n    }\\n    \\n    public int getBal(TreeNode root){\\n        int lh = root.left != null ? height[root.left.val] : -1;\\n        int rh = root.right != null ? height[root.right.val] : -1;\\n        return lh - rh;\\n    }\\n    \\n    public TreeNode leftRotation(TreeNode A){\\n        TreeNode B = A.right;\\n        TreeNode BkaLeft = B.left;\\n        \\n        B.left = A;\\n        A.right = BkaLeft;\\n        \\n        B.left = getRotation(A);\\n        return getRotation(B);\\n    }\\n    \\n    public TreeNode rightRotation(TreeNode A){\\n        TreeNode B = A.left;\\n        TreeNode BkaRight = B.right;\\n        \\n        B.right = A;\\n        A.left = BkaRight;\\n        \\n        B.right = getRotation(A);\\n        return getRotation(B);\\n    }\\n    \\n    public TreeNode getRotation(TreeNode root){\\n        updateHeight(root);\\n        if(getBal(root) >= 2){   // ll, lr\\n            if(getBal(root.left) >= 1){  // ll\\n                return rightRotation(root);    \\n            }else{    // lr\\n                root.left = leftRotation(root.left);\\n                return rightRotation(root);\\n            }\\n        }else if(getBal(root) <= -2){  // rr,rl\\n            if(getBal(root.right) <= -1){   // rr\\n                return leftRotation(root);\\n            }else{ // rl\\n                root.right = rightRotation(root.right);\\n                return leftRotation(root);\\n            }\\n        }\\n        return root;\\n    }\\n    \\n    public TreeNode postOrder(TreeNode root){\\n        if(root == null) return null;\\n        \\n        root.left = postOrder(root.left);\\n        root.right = postOrder(root.right);\\n        \\n        return getRotation(root);\\n    }\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        height = new int[100001];\\n        return postOrder(root);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 539780,
                "title": "python3-collect-values-reconstruct-bst-recursively",
                "content": "Algorithm:\\nCollect values and reconstruct the tree. \\n\\nImplementation: \\n```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        \\n        def dfs(node):\\n            \"\"\"inorder depth-first traverse bst\"\"\"\\n            if not node: return \\n            dfs(node.left)\\n            value.append(node.val)\\n            dfs(node.right)\\n        \\n        value = [] #collect values\\n        dfs(root)\\n        \\n        def tree(lo, hi): \\n            if lo > hi: return None\\n            mid = (lo + hi)//2\\n            ans = TreeNode(value[mid])\\n            ans.left = tree(lo, mid-1)\\n            ans.right = tree(mid+1, hi)\\n            return ans\\n        \\n        return tree(0, len(value)-1)\\n```\\nAnalysis:\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        \\n        def dfs(node):\\n            \"\"\"inorder depth-first traverse bst\"\"\"\\n            if not node: return \\n            dfs(node.left)\\n            value.append(node.val)\\n            dfs(node.right)\\n        \\n        value = [] #collect values\\n        dfs(root)\\n        \\n        def tree(lo, hi): \\n            if lo > hi: return None\\n            mid = (lo + hi)//2\\n            ans = TreeNode(value[mid])\\n            ans.left = tree(lo, mid-1)\\n            ans.right = tree(mid+1, hi)\\n            return ans\\n        \\n        return tree(0, len(value)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858403,
                "title": "c-easy-solution-using-avl-trees-concept",
                "content": "Only Prerequiste is to know about concept for AVL Trees root insertion, as code is almost similar.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define null nullptr\\n#define l left\\n#define r right\\nclass Solution {\\npublic:\\n    TreeNode* rrot (TreeNode* root){\\n        if(root==null) return null;\\n        TreeNode* x = root->l;\\n        root->l=x->r;\\n        x->r=root;\\n        root=x;\\n        return root;\\n    }\\n    \\n    TreeNode* lrot (TreeNode* root){\\n        if(root==null) return null;\\n        TreeNode* x = root->r;\\n        root->r=x->l;\\n        x->l=root;\\n        root=x;\\n        return root;\\n    }\\n    \\n    int height (TreeNode* root){\\n        if(root==null) return -1;\\n        return 1 + max(height(root->l),height(root->r));\\n    }\\n    \\n    TreeNode* helper (TreeNode* root){\\n        if (root==null) return null;\\n        root->l=helper(root->l);\\n        root->r=helper(root->r);\\n        int l = height(root->l), r = height(root->r);\\n        int bf = l -r ;\\n        if(bf > 1){\\n            if (height(root->l->l)<height(root->l->r)){\\n                root->l=lrot(root->l);\\n            }\\n            return helper(rrot(root));\\n        }else if (bf<-1){\\n            if (height(root->r->r)<height(root->r->l)){\\n                root->r=rrot(root->r);\\n            }\\n            return helper(lrot(root));\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        if(root==null) return root;\\n        return helper(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define null nullptr\\n#define l left\\n#define r right\\nclass Solution {\\npublic:\\n    TreeNode* rrot (TreeNode* root){\\n        if(root==null) return null;\\n        TreeNode* x = root->l;\\n        root->l=x->r;\\n        x->r=root;\\n        root=x;\\n        return root;\\n    }\\n    \\n    TreeNode* lrot (TreeNode* root){\\n        if(root==null) return null;\\n        TreeNode* x = root->r;\\n        root->r=x->l;\\n        x->l=root;\\n        root=x;\\n        return root;\\n    }\\n    \\n    int height (TreeNode* root){\\n        if(root==null) return -1;\\n        return 1 + max(height(root->l),height(root->r));\\n    }\\n    \\n    TreeNode* helper (TreeNode* root){\\n        if (root==null) return null;\\n        root->l=helper(root->l);\\n        root->r=helper(root->r);\\n        int l = height(root->l), r = height(root->r);\\n        int bf = l -r ;\\n        if(bf > 1){\\n            if (height(root->l->l)<height(root->l->r)){\\n                root->l=lrot(root->l);\\n            }\\n            return helper(rrot(root));\\n        }else if (bf<-1){\\n            if (height(root->r->r)<height(root->r->l)){\\n                root->r=rrot(root->r);\\n            }\\n            return helper(lrot(root));\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        if(root==null) return root;\\n        return helper(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465380,
                "title": "c-easy-to-understand-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<TreeNode*> &v) {\\n        if (root==NULL)\\n            return;\\n        inorder(root->left, v);\\n        v.push_back(root);\\n        inorder(root->right, v);\\n    }\\n    \\n    TreeNode* createBST(vector<TreeNode*> &v, int lo, int hi) {\\n        if (hi<lo)\\n            return NULL;\\n        \\n        int mid = lo + (hi-lo)/2;\\n        TreeNode* root = v[mid];\\n        root->left = createBST(v, lo, mid-1);\\n        root->right = createBST(v, mid+1, hi);\\n        \\n        return root;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> v;\\n        inorder(root,v);\\n        return createBST(v,0,v.size()-1);\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<TreeNode*> &v) {\\n        if (root==NULL)\\n            return;\\n        inorder(root->left, v);\\n        v.push_back(root);\\n        inorder(root->right, v);\\n    }\\n    \\n    TreeNode* createBST(vector<TreeNode*> &v, int lo, int hi) {\\n        if (hi<lo)\\n            return NULL;\\n        \\n        int mid = lo + (hi-lo)/2;\\n        TreeNode* root = v[mid];\\n        root->left = createBST(v, lo, mid-1);\\n        root->right = createBST(v, mid+1, hi);\\n        \\n        return root;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> v;\\n        inorder(root,v);\\n        return createBST(v,0,v.size()-1);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1273243,
                "title": "quite-simple-solution-n-85-accuracy-python-and-good-structured-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/fbcfc483-7d61-417d-a96c-4adcef9fc8d2_1623726107.514847.png)\\n--\\n----> Approach <-------\\n--\\n1) Inorer traversal and store the nodes in the list.\\n2) Then make bst using recursion and take mid element of list as root.\\n```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        def inorder(root):\\n            if root is None: return None\\n            inorder(root.left); lst.append(root); inorder(root.right)\\n        \\n        lst = []\\n        inorder(root)\\n        \\n        def bst(arr):\\n            if len(arr) == 0:return \\n            mid = len(arr)//2;   root = arr[mid]\\n            root.left = bst(arr[:mid]);   root.right = bst(arr[mid+1:])\\n            return root\\n        \\n        return bst(lst) \\n```\\nPlease upvote if u Like < \\' - \\'>  \\n--",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        def inorder(root):\\n            if root is None: return None\\n            inorder(root.left); lst.append(root); inorder(root.right)\\n        \\n        lst = []\\n        inorder(root)\\n        \\n        def bst(arr):\\n            if len(arr) == 0:return \\n            mid = len(arr)//2;   root = arr[mid]\\n            root.left = bst(arr[:mid]);   root.right = bst(arr[mid+1:])\\n            return root\\n        \\n        return bst(lst) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 877598,
                "title": "solution-using-avl-tree-class-quality",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    struct AVL{\\n        \\n        struct AVLnode{\\n            int element;\\n            AVLnode* left;\\n            AVLnode* right;\\n            int height;\\n            AVLnode(int x, AVLnode* l, AVLnode* r, int h=0): element{x}, left{l}, right{r},height{h} {}\\n        };\\n        \\n        AVLnode* root;\\n        \\n        AVL(){\\n            root=nullptr;\\n        }\\n        \\n        int height(AVLnode* t){\\n            return t==nullptr ? -1: t->height;\\n        }\\n        \\n        void insert( int x, AVLnode*&  t ){\\n            \\n            if(t==nullptr) \\n                t=new AVLnode(x, nullptr, nullptr);\\n            \\n            else if(x<t->element)\\n                insert(x, t->left);\\n            else if(t->element<x)\\n                insert(x,t->right);\\n            \\n           balance(t);\\n        }\\n        \\n        void balance(AVLnode* & t){\\n            \\n            if(t==nullptr) return;\\n            \\n            if(height(t->left)-height(t->right)>1){\\n                if(height(t->left->left)>=height(t->left->right)) rotateWithLeftChild(t);\\n                else doubleWithLeftChild(t);\\n            }\\n            else{\\n                if(height(t->right)-height(t->left)>1){\\n                if(height(t->right->right)>=height(t->right->left)) rotateWithRightChild(t);\\n                else doubleWithRightChild(t);\\n                }\\n            }\\n            \\n            t->height=max(height(t->left), height(t->right))+1;\\n        }\\n        \\n        void rotateWithLeftChild(AVLnode* & k2){\\n            AVLnode* k1=k2->left;\\n            k2->left=k1->right;\\n            k1->right=k2;\\n            k2->height=max(height(k2->left),height(k2->right))+1;\\n            k1->height=max(height(k1->left),k2->height)+1;\\n            k2=k1;\\n            \\n        }\\n        \\n        void rotateWithRightChild(AVLnode* & k2){\\n            AVLnode* k1=k2->right;\\n            k2->right=k1->left;\\n            k1->left=k2;\\n            k2->height=max(height(k2->right),height(k2->left))+1;\\n            k1->height=max(height(k1->right),k2->height)+1;\\n            k2=k1;\\n            \\n        }\\n        \\n        void doubleWithLeftChild(AVLnode* & k3){\\n            \\n            rotateWithRightChild(k3->left);\\n            rotateWithLeftChild(k3);\\n        }\\n        \\n        void doubleWithRightChild(AVLnode* & k3){\\n           \\n            rotateWithLeftChild(k3->right);\\n            rotateWithRightChild(k3);\\n        }\\n        \\n        \\n        \\n        \\n    };\\n    \\n    \\n    \\n    \\n    \\n    void traverseAndStore(TreeNode* root, vector<int>& temp){\\n        \\n        if(root==nullptr) return;\\n        else temp.push_back(root->val);\\n        \\n        traverseAndStore(root->left, temp);\\n        traverseAndStore(root->right, temp);\\n        \\n        \\n    }\\n    \\n    \\n    \\n    void f(TreeNode*& ans, AVL::AVLnode*& temp){\\n        \\n        if(temp==nullptr) return;\\n        else ans=new TreeNode(temp->element);\\n        \\n        f(ans->left,temp->left);\\n        f(ans->right,temp->right);\\n        \\n        \\n    }\\n    \\n    \\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        \\n        vector<int> storeTree;\\n        \\n        traverseAndStore(root,storeTree);\\n        \\n        AVL* myAVL= new AVL();\\n        \\n        \\n        for( auto k: storeTree){\\n            myAVL->insert(k,myAVL->root);\\n        }\\n        \\n        TreeNode* ans;\\n        \\n        AVL:: AVLnode* temp=myAVL->root;\\n        \\n        f(ans,temp);\\n        \\n        \\n        \\n        return ans;\\n        \\n    }\\n    \\n    \\n    \\n    \\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    struct AVL{\\n        \\n        struct AVLnode{\\n            int element;\\n            AVLnode* left;\\n            AVLnode* right;\\n            int height;\\n            AVLnode(int x, AVLnode* l, AVLnode* r, int h=0): element{x}, left{l}, right{r},height{h} {}\\n        };\\n        \\n        AVLnode* root;\\n        \\n        AVL(){\\n            root=nullptr;\\n        }\\n        \\n        int height(AVLnode* t){\\n            return t==nullptr ? -1: t->height;\\n        }\\n        \\n        void insert( int x, AVLnode*&  t ){\\n            \\n            if(t==nullptr) \\n                t=new AVLnode(x, nullptr, nullptr);\\n            \\n            else if(x<t->element)\\n                insert(x, t->left);\\n            else if(t->element<x)\\n                insert(x,t->right);\\n            \\n           balance(t);\\n        }\\n        \\n        void balance(AVLnode* & t){\\n            \\n            if(t==nullptr) return;\\n            \\n            if(height(t->left)-height(t->right)>1){\\n                if(height(t->left->left)>=height(t->left->right)) rotateWithLeftChild(t);\\n                else doubleWithLeftChild(t);\\n            }\\n            else{\\n                if(height(t->right)-height(t->left)>1){\\n                if(height(t->right->right)>=height(t->right->left)) rotateWithRightChild(t);\\n                else doubleWithRightChild(t);\\n                }\\n            }\\n            \\n            t->height=max(height(t->left), height(t->right))+1;\\n        }\\n        \\n        void rotateWithLeftChild(AVLnode* & k2){\\n            AVLnode* k1=k2->left;\\n            k2->left=k1->right;\\n            k1->right=k2;\\n            k2->height=max(height(k2->left),height(k2->right))+1;\\n            k1->height=max(height(k1->left),k2->height)+1;\\n            k2=k1;\\n            \\n        }\\n        \\n        void rotateWithRightChild(AVLnode* & k2){\\n            AVLnode* k1=k2->right;\\n            k2->right=k1->left;\\n            k1->left=k2;\\n            k2->height=max(height(k2->right),height(k2->left))+1;\\n            k1->height=max(height(k1->right),k2->height)+1;\\n            k2=k1;\\n            \\n        }\\n        \\n        void doubleWithLeftChild(AVLnode* & k3){\\n            \\n            rotateWithRightChild(k3->left);\\n            rotateWithLeftChild(k3);\\n        }\\n        \\n        void doubleWithRightChild(AVLnode* & k3){\\n           \\n            rotateWithLeftChild(k3->right);\\n            rotateWithRightChild(k3);\\n        }\\n        \\n        \\n        \\n        \\n    };\\n    \\n    \\n    \\n    \\n    \\n    void traverseAndStore(TreeNode* root, vector<int>& temp){\\n        \\n        if(root==nullptr) return;\\n        else temp.push_back(root->val);\\n        \\n        traverseAndStore(root->left, temp);\\n        traverseAndStore(root->right, temp);\\n        \\n        \\n    }\\n    \\n    \\n    \\n    void f(TreeNode*& ans, AVL::AVLnode*& temp){\\n        \\n        if(temp==nullptr) return;\\n        else ans=new TreeNode(temp->element);\\n        \\n        f(ans->left,temp->left);\\n        f(ans->right,temp->right);\\n        \\n        \\n    }\\n    \\n    \\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        \\n        vector<int> storeTree;\\n        \\n        traverseAndStore(root,storeTree);\\n        \\n        AVL* myAVL= new AVL();\\n        \\n        \\n        for( auto k: storeTree){\\n            myAVL->insert(k,myAVL->root);\\n        }\\n        \\n        TreeNode* ans;\\n        \\n        AVL:: AVLnode* temp=myAVL->root;\\n        \\n        f(ans,temp);\\n        \\n        \\n        \\n        return ans;\\n        \\n    }\\n    \\n    \\n    \\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439377,
                "title": "easy-and-commented-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // for getting the inorder of BST\\n    void inorderTraversal(TreeNode*root,vector<TreeNode*>&inorder){\\n        if(root==NULL){\\n            return ;\\n        }\\n        if(root->left){\\n            inorderTraversal(root->left,inorder);\\n        }\\n\\n        inorder.push_back(root);\\n\\n        if(root->right){\\n            inorderTraversal(root->right,inorder);\\n        }\\n    }\\n\\n    // to make a balanced tree \\n    TreeNode* makeBalancedBST(vector<TreeNode*>&inorder,int start,int end){\\n        //base case \\n        if(start>end){\\n            return NULL;\\n        }\\n\\n        // find mid\\n        int mid=start + (end-start)/2;\\n        //now call for left and right \\n\\n        //for left keep start as it is and change end \\n        inorder[mid]->left=makeBalancedBST(inorder,start,mid-1);\\n\\n        // for right keeping end same but changing start\\n        inorder[mid]->right=makeBalancedBST(inorder,mid+1,end);\\n        \\n        return inorder[mid];//returning mid as it\\'s root for this subtree which will be linked with above left or right\\n    }\\n\\n            <!-- Please upvote \\uD83D\\uDE4F if you found this solution helpful\\uD83D\\uDE00 -->\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*>inorder;//to store the inorder traversal of BST\\n        inorderTraversal(root,inorder);\\n\\n        int start=0;//initially start is 0 index and end is n-1\\n        int end=inorder.size()-1;\\n\\n        return makeBalancedBST(inorder,start,end);//this will return the mid of inorder which is our root for balanced BST\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // for getting the inorder of BST\\n    void inorderTraversal(TreeNode*root,vector<TreeNode*>&inorder){\\n        if(root==NULL){\\n            return ;\\n        }\\n        if(root->left){\\n            inorderTraversal(root->left,inorder);\\n        }\\n\\n        inorder.push_back(root);\\n\\n        if(root->right){\\n            inorderTraversal(root->right,inorder);\\n        }\\n    }\\n\\n    // to make a balanced tree \\n    TreeNode* makeBalancedBST(vector<TreeNode*>&inorder,int start,int end){\\n        //base case \\n        if(start>end){\\n            return NULL;\\n        }\\n\\n        // find mid\\n        int mid=start + (end-start)/2;\\n        //now call for left and right \\n\\n        //for left keep start as it is and change end \\n        inorder[mid]->left=makeBalancedBST(inorder,start,mid-1);\\n\\n        // for right keeping end same but changing start\\n        inorder[mid]->right=makeBalancedBST(inorder,mid+1,end);\\n        \\n        return inorder[mid];//returning mid as it\\'s root for this subtree which will be linked with above left or right\\n    }\\n\\n            <!-- Please upvote \\uD83D\\uDE4F if you found this solution helpful\\uD83D\\uDE00 -->\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*>inorder;//to store the inorder traversal of BST\\n        inorderTraversal(root,inorder);\\n\\n        int start=0;//initially start is 0 index and end is n-1\\n        int end=inorder.size()-1;\\n\\n        return makeBalancedBST(inorder,start,end);//this will return the mid of inorder which is our root for balanced BST\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561068,
                "title": "javascript-solution-using-recursion-bst-array-bst",
                "content": "```\\nvar balanceBST = function(root) {\\n    const values = toArray(root);\\n    return toBST(values);\\n    \\n    function toBST(arr) {\\n        if (arr.length===0) return null;\\n        if (arr.length===1) return new TreeNode(arr[0]);\\n        const mid = Math.floor(arr.length / 2);\\n        const left = toBST(arr.slice(0, mid));\\n        const right = toBST(arr.slice(mid+1));\\n        return new TreeNode(arr[mid], left, right);\\n    }\\n    \\n    function toArray(node) {\\n        if (!node) return [];\\n        return [...toArray(node.left), node.val, ...toArray(node.right)];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nvar balanceBST = function(root) {\\n    const values = toArray(root);\\n    return toBST(values);\\n    \\n    function toBST(arr) {\\n        if (arr.length===0) return null;\\n        if (arr.length===1) return new TreeNode(arr[0]);\\n        const mid = Math.floor(arr.length / 2);\\n        const left = toBST(arr.slice(0, mid));\\n        const right = toBST(arr.slice(mid+1));\\n        return new TreeNode(arr[mid], left, right);\\n    }\\n    \\n    function toArray(node) {\\n        if (!node) return [];\\n        return [...toArray(node.left), node.val, ...toArray(node.right)];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1555843,
                "title": "python-solutions-with-some-explanation",
                "content": "```\\nclass Solution(object):\\n\\t# We need to sort the distinct nodes of the BST by using inorder traversal\\n    def balanceBST(self, root):\\n        def inorder(root):\\n            if not root:\\n                return []\\n            return inorder(root.left) + [root.val] + inorder(root.right)\\n        \\n        nums = inorder(root) # Because the function returns a list, we assign that list to variable nums for later uses\\n        \\n        def constructBST(nums):\\n            if len(nums) == 0: # Our list is empty\\n                return None\\n            if len(nums) == 1: # Our list has only one element\\n                return TreeNode(nums[0])\\n\\t\\t\\t\\t\\n\\t\\t\\t# Here is one illustration before the code:\\n\\t\\t\\t# Assuming that we already have a sorted list : [1, 2, 5, 7, 9, 12, 14]\\n\\t\\t\\t# The middle value is 7, which is also our very first root\\n\\t\\t\\t# root.left will apply the same thought recursively with a sorted list: [1, 2, 5]\\n\\t\\t\\t# root.right will apply the same thought recursively with a sorted list: [9, 12, 14]\\n\\t\\t\\t# Below is the final code:\\n\\t\\t\\t\\n            mid = len(nums) // 2\\n            new_node = TreeNode(nums[mid])\\n            new_node.left = constructBST(nums[:mid])\\n            new_node.right = constructBST(nums[mid+1:])\\n            return new_node\\n        \\n        return constructBST(nums)",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n\\t# We need to sort the distinct nodes of the BST by using inorder traversal\\n    def balanceBST(self, root):\\n        def inorder(root):\\n            if not root:\\n                return []\\n            return inorder(root.left) + [root.val] + inorder(root.right)\\n        \\n        nums = inorder(root) # Because the function returns a list, we assign that list to variable nums for later uses\\n        \\n        def constructBST(nums):\\n            if len(nums) == 0: # Our list is empty\\n                return None\\n            if len(nums) == 1: # Our list has only one element\\n                return TreeNode(nums[0])\\n\\t\\t\\t\\t\\n\\t\\t\\t# Here is one illustration before the code:\\n\\t\\t\\t# Assuming that we already have a sorted list : [1, 2, 5, 7, 9, 12, 14]\\n\\t\\t\\t# The middle value is 7, which is also our very first root\\n\\t\\t\\t# root.left will apply the same thought recursively with a sorted list: [1, 2, 5]\\n\\t\\t\\t# root.right will apply the same thought recursively with a sorted list: [9, 12, 14]\\n\\t\\t\\t# Below is the final code:\\n\\t\\t\\t\\n            mid = len(nums) // 2\\n            new_node = TreeNode(nums[mid])\\n            new_node.left = constructBST(nums[:mid])\\n            new_node.right = constructBST(nums[mid+1:])\\n            return new_node\\n        \\n        return constructBST(nums)",
                "codeTag": "Java"
            },
            {
                "id": 757687,
                "title": "java-inorder-beat-100-easy-understand",
                "content": "```\\nclass Solution {\\n    List<TreeNode> list = new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n        helper(root);\\n        if(list.size() == 0)\\n            return null;\\n        return formTree(0, list.size() - 1);\\n    }\\n    \\n    private void helper(TreeNode root){\\n        if(root == null)\\n            return;\\n        helper(root.left);\\n        list.add(root);  // don\\'t store value\\n        helper(root.right);\\n        root.left = null;\\n        root.right = null;\\n    }\\n    \\n\\t//recursive form BST\\n    private TreeNode formTree(int start, int end){\\n        if(start > end)\\n            return null;\\n        int middle = start + (end - start) / 2;\\n        TreeNode root = list.get(middle);\\n        root.left = formTree(start, middle - 1);\\n        root.right = formTree(middle + 1, end);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<TreeNode> list = new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n        helper(root);\\n        if(list.size() == 0)\\n            return null;\\n        return formTree(0, list.size() - 1);\\n    }\\n    \\n    private void helper(TreeNode root){\\n        if(root == null)\\n            return;\\n        helper(root.left);\\n        list.add(root);  // don\\'t store value\\n        helper(root.right);\\n        root.left = null;\\n        root.right = null;\\n    }\\n    \\n\\t//recursive form BST\\n    private TreeNode formTree(int start, int end){\\n        if(start > end)\\n            return null;\\n        int middle = start + (end - start) / 2;\\n        TreeNode root = list.get(middle);\\n        root.left = formTree(start, middle - 1);\\n        root.right = formTree(middle + 1, end);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 540352,
                "title": "javascript-inorder-traverse-and-build-a-balance-tree-100-beat",
                "content": "```\\nconst balanceBST = root => {\\n  let arr = [];\\n  const inorderTraverse = node => {\\n    if (!node) return;\\n    if (node.left) inorderTraverse(node.left);\\n    arr.push(node.val);\\n    if (node.right) inorderTraverse(node.right);\\n  }\\n  \\n  inorderTraverse(root);\\n  \\n  const constructBST = (start, end) => {\\n    if (start > end) return null;\\n    const mid = Math.floor((start+end) / 2);\\n    \\n    let node = new TreeNode(arr[mid]);\\n    node.left = constructBST(start, mid - 1);\\n    node.right = constructBST(mid + 1, end);\\n    \\n    return node;\\n  }\\n  \\n  let node = constructBST(0, arr.length - 1)\\n  \\n  return node;\\n};\\n```\\n\\n<br />\\n\\n\\u2139\\uFE0F [My javascript solution collection](https://github.com/toantd90/leetcode-js-solutions)\\n\\n<br />",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst balanceBST = root => {\\n  let arr = [];\\n  const inorderTraverse = node => {\\n    if (!node) return;\\n    if (node.left) inorderTraverse(node.left);\\n    arr.push(node.val);\\n    if (node.right) inorderTraverse(node.right);\\n  }\\n  \\n  inorderTraverse(root);\\n  \\n  const constructBST = (start, end) => {\\n    if (start > end) return null;\\n    const mid = Math.floor((start+end) / 2);\\n    \\n    let node = new TreeNode(arr[mid]);\\n    node.left = constructBST(start, mid - 1);\\n    node.right = constructBST(mid + 1, end);\\n    \\n    return node;\\n  }\\n  \\n  let node = constructBST(0, arr.length - 1)\\n  \\n  return node;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 539735,
                "title": "clean-python-3-inorder-rebuild-tree-o-n",
                "content": "Get the inorder traversal of original tree first.\\nThen pick the middle one as the new root and rebuild entire tree.\\n\\nTime: `O(N)`\\nSpace: `O(N)`\\n```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        def inorder(root: TreeNode) -> List[TreeNode]:\\n            stack, result = [], []\\n            while root or stack:\\n                while root:\\n                    stack.append(root)\\n                    root = root.left\\n                root = stack.pop()\\n                result.append(root)\\n                root = root.right\\n            return result\\n            \\n        def build(nodes: List[TreeNode]) -> TreeNode:\\n            if not nodes: return None\\n            mid = len(nodes) // 2\\n            mid_node = nodes[mid]\\n            mid_node.left = build(nodes[:mid])\\n            mid_node.right = build(nodes[mid+1:])\\n            return mid_node\\n\\n        return build(inorder(root))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        def inorder(root: TreeNode) -> List[TreeNode]:\\n            stack, result = [], []\\n            while root or stack:\\n                while root:\\n                    stack.append(root)\\n                    root = root.left\\n                root = stack.pop()\\n                result.append(root)\\n                root = root.right\\n            return result\\n            \\n        def build(nodes: List[TreeNode]) -> TreeNode:\\n            if not nodes: return None\\n            mid = len(nodes) // 2\\n            mid_node = nodes[mid]\\n            mid_node.left = build(nodes[:mid])\\n            mid_node.right = build(nodes[mid+1:])\\n            return mid_node\\n\\n        return build(inorder(root))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976249,
                "title": "2-best-c-solutions-beats-100-in-both-time-and-memory",
                "content": "# Code\\n```\\n// Recursive solution\\nclass Solution {\\npublic:\\n    void inorder(TreeNode *root, vector<int> &ans){\\n        if(root == NULL)\\n            return;\\n        \\n        inorder(root->left, ans);\\n        ans.push_back(root->val);\\n        inorder(root->right, ans);\\n    }\\n\\n    TreeNode* createBST(vector<int> ans, int start, int end){\\n        if(start > end)\\n            return NULL;\\n        \\n        int mid = start+(end-start)/2;\\n        TreeNode *root = new TreeNode(ans[mid]);\\n        root->left = createBST(ans, start, mid-1);\\n        root->right = createBST(ans, mid+1, end);\\n        return root;\\n    }\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> ans;\\n        inorder(root, ans);\\n\\n        int start = 0, end = ans.size()-1;\\n        return createBST(ans, start, end);\\n    }\\n};\\n\\n// Same solution but directly storing nodes and not integers\\n// Works way better in both time and space complexity\\nclass Solution {\\n    vector<TreeNode*> sorted;\\npublic:\\n    void inorder(TreeNode* root) {\\n        if (root == NULL) \\n            return;\\n        \\n        inorder(root->left);\\n        sorted.push_back(root);\\n        inorder(root->right);\\n    }\\n    \\n    TreeNode* createTree(int start, int end) {\\n        if (start > end) \\n            return NULL;\\n        \\n        int mid = start + (end - start)/2;\\n        TreeNode *root = sorted[mid];\\n        root->left = createTree(start, mid - 1);\\n        root->right = createTree(mid + 1, end);\\n        return root;\\n        \\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorder(root);\\n        return createTree(0, sorted.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Greedy",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n// Recursive solution\\nclass Solution {\\npublic:\\n    void inorder(TreeNode *root, vector<int> &ans){\\n        if(root == NULL)\\n            return;\\n        \\n        inorder(root->left, ans);\\n        ans.push_back(root->val);\\n        inorder(root->right, ans);\\n    }\\n\\n    TreeNode* createBST(vector<int> ans, int start, int end){\\n        if(start > end)\\n            return NULL;\\n        \\n        int mid = start+(end-start)/2;\\n        TreeNode *root = new TreeNode(ans[mid]);\\n        root->left = createBST(ans, start, mid-1);\\n        root->right = createBST(ans, mid+1, end);\\n        return root;\\n    }\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> ans;\\n        inorder(root, ans);\\n\\n        int start = 0, end = ans.size()-1;\\n        return createBST(ans, start, end);\\n    }\\n};\\n\\n// Same solution but directly storing nodes and not integers\\n// Works way better in both time and space complexity\\nclass Solution {\\n    vector<TreeNode*> sorted;\\npublic:\\n    void inorder(TreeNode* root) {\\n        if (root == NULL) \\n            return;\\n        \\n        inorder(root->left);\\n        sorted.push_back(root);\\n        inorder(root->right);\\n    }\\n    \\n    TreeNode* createTree(int start, int end) {\\n        if (start > end) \\n            return NULL;\\n        \\n        int mid = start + (end - start)/2;\\n        TreeNode *root = sorted[mid];\\n        root->left = createTree(start, mid - 1);\\n        root->right = createTree(mid + 1, end);\\n        return root;\\n        \\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorder(root);\\n        return createTree(0, sorted.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370547,
                "title": "java-easy-solution-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere i have used concept of BST\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we Calculate inorder with the help of ArrayList\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public static TreeNode Balance( ArrayList<Integer> list,int st,int end){\\n        if(st>end){\\n            return null;\\n        }\\n        int mid=(st+end)/2;\\n        TreeNode root=new TreeNode(list.get(mid));\\n        root.left=Balance(list,st,mid-1);\\n        root.right=Balance(list,mid+1,end);\\n        return root;\\n    }\\n    public static void inorder(TreeNode root, ArrayList<Integer> list){\\n          if(root==null){\\n            return;\\n        }\\n        inorder(root.left,list);\\n        list.add(root.val);\\n        inorder(root.right,list);\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list =new ArrayList<>();\\n      if(root==null){\\n        return null;\\n      }\\n        inorder(root,list);\\n      \\n        TreeNode root1=Balance(list,0,list.size()-1);\\n        return root1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public static TreeNode Balance( ArrayList<Integer> list,int st,int end){\\n        if(st>end){\\n            return null;\\n        }\\n        int mid=(st+end)/2;\\n        TreeNode root=new TreeNode(list.get(mid));\\n        root.left=Balance(list,st,mid-1);\\n        root.right=Balance(list,mid+1,end);\\n        return root;\\n    }\\n    public static void inorder(TreeNode root, ArrayList<Integer> list){\\n          if(root==null){\\n            return;\\n        }\\n        inorder(root.left,list);\\n        list.add(root.val);\\n        inorder(root.right,list);\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list =new ArrayList<>();\\n      if(root==null){\\n        return null;\\n      }\\n        inorder(root,list);\\n      \\n        TreeNode root1=Balance(list,0,list.size()-1);\\n        return root1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796623,
                "title": "c-solution-balance-a-binary-search-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root , vector<int> &inorderVal){\\n        if(root == NULL)\\n            return ;\\n        \\n        inorder(root->left , inorderVal);\\n        inorderVal.push_back(root->val);\\n        inorder(root->right , inorderVal);\\n    }\\n    \\n    TreeNode* inorderToBST(int s , int e , vector<int> &inorderVal){\\n        if(s > e)\\n            return NULL;\\n        \\n        int mid = (s+e)/2;\\n        \\n        TreeNode* temp = new TreeNode(inorderVal[mid]);\\n        temp->left = inorderToBST(s , mid-1 , inorderVal);\\n        temp->right = inorderToBST(mid+1 , e , inorderVal);\\n        \\n        return temp;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> inorderVal;\\n        inorder(root , inorderVal);\\n        \\n        return inorderToBST(0 , inorderVal.size()-1 , inorderVal);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root , vector<int> &inorderVal){\\n        if(root == NULL)\\n            return ;\\n        \\n        inorder(root->left , inorderVal);\\n        inorderVal.push_back(root->val);\\n        inorder(root->right , inorderVal);\\n    }\\n    \\n    TreeNode* inorderToBST(int s , int e , vector<int> &inorderVal){\\n        if(s > e)\\n            return NULL;\\n        \\n        int mid = (s+e)/2;\\n        \\n        TreeNode* temp = new TreeNode(inorderVal[mid]);\\n        temp->left = inorderToBST(s , mid-1 , inorderVal);\\n        temp->right = inorderToBST(mid+1 , e , inorderVal);\\n        \\n        return temp;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> inorderVal;\\n        inorder(root , inorderVal);\\n        \\n        return inorderToBST(0 , inorderVal.size()-1 , inorderVal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394387,
                "title": "c-get-inorder-traversal-and-make-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nums ;\\n    void traverse(TreeNode * root){\\n        if(!root) return ;\\n        traverse(root->left) ;\\n        nums.push_back(root->val) ;\\n        traverse(root->right) ;\\n        return ;\\n    }\\n    \\n    TreeNode * makeTree(int s , int e){\\n        if(s > e) return nullptr ;\\n        int m = (s + e) / 2 ;\\n        TreeNode * root = new TreeNode(nums[m]) ;\\n        \\n        root->left = makeTree(s,m - 1) ;\\n        root->right = makeTree(m + 1,e) ;\\n        \\n        return root ;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        traverse(root) ;\\n        return makeTree(0,size(nums) - 1) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nums ;\\n    void traverse(TreeNode * root){\\n        if(!root) return ;\\n        traverse(root->left) ;\\n        nums.push_back(root->val) ;\\n        traverse(root->right) ;\\n        return ;\\n    }\\n    \\n    TreeNode * makeTree(int s , int e){\\n        if(s > e) return nullptr ;\\n        int m = (s + e) / 2 ;\\n        TreeNode * root = new TreeNode(nums[m]) ;\\n        \\n        root->left = makeTree(s,m - 1) ;\\n        root->right = makeTree(m + 1,e) ;\\n        \\n        return root ;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        traverse(root) ;\\n        return makeTree(0,size(nums) - 1) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042990,
                "title": "python-very-easy-sol-using-inorder-traversal",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        \\n        def inorder(root,lst):\\n            if not root:\\n                return \\n            inorder(root.left,lst)\\n            lst.append(root.val)\\n            inorder(root.right,lst)\\n        \\n        def createBST(l,r):\\n            while l <= r:\\n                mid = (l + r) // 2\\n                return TreeNode(lst[mid],createBST(l,mid-1),createBST(mid+1,r))\\n            return None\\n            \\n        lst = []\\n        inorder(root,lst)\\n        l,r = 0,len(lst) - 1        \\n        return createBST(l,r)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        \\n        def inorder(root,lst):\\n            if not root:\\n                return \\n            inorder(root.left,lst)\\n            lst.append(root.val)\\n            inorder(root.right,lst)\\n        \\n        def createBST(l,r):\\n            while l <= r:\\n                mid = (l + r) // 2\\n                return TreeNode(lst[mid],createBST(l,mid-1),createBST(mid+1,r))\\n            return None\\n            \\n        lst = []\\n        inorder(root,lst)\\n        l,r = 0,len(lst) - 1        \\n        return createBST(l,r)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922692,
                "title": "python-clean-recursive-soln-beats-60-soln-w-comments-time-space-complexity-o-n",
                "content": "# Solution:\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inOrderTraversal(self, root):\\n        if not root:\\n            return \\n        \\n\\t\\t# traverse left subtree\\n\\t\\tself.inOrderTraversal(root.left)\\n\\t\\t\\n\\t\\t# append to list\\n        self.inOrderList.append(root)\\n        \\n\\t\\t# traverse right subtree\\n\\t\\tself.inOrderTraversal(root.right)\\n        \\n        return \\n    \\n    def createBBST(self,low, high):\\n\\t\\t# base case\\n        if low > high:\\n            return None\\n\\n\\t\\t# pick middle node\\n        mid = low + high >> 1\\n        \\n        node = self.inOrderList[mid]\\n        node.left = self.createBBST(low, mid - 1)\\n        node.right = self.createBBST(mid + 1, high)\\n        \\n        return node\\n        \\n    \\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        self.inOrderList = []\\n        self.inOrderTraversal(root)\\n        return self.createBBST(0, len(self.inOrderList)-1)\\n```\\t\\t\\n\\t\\t\\n# Intuition/Approach:\\n**Step 1:** Inorder traversal on a binary search tree gives us all the nodes in sorted ascending order.\\n**Step 2:** To build a Balanced BST we would need a root with equal number of nodes to its left as to its right\\n**Example:** input: [3, 1, 4, null, null, null, 7, null, 9, null, 10] (*doesn\\'t really matter how the nodes are provided*)\\n```\\n\\t\\t3\\n\\t  /   \\\\\\n \\t 1     4\\n\\t        \\\\\\n\\t\\t\\t 7\\n\\t\\t\\t  \\\\\\n\\t\\t\\t   9\\n\\t\\t\\t\\t\\\\\\n\\t\\t\\t  \\t 10\\n\\t\\t\\t\\t \\n# we perform inOrderTraversal on this BST, we get\\n\\ninOrderList = [1,3,4,7,9,10]\\n\\n# Now if we were to form a Balanced BST from this list, our choice of root will be either 4 or 7 \\n#(partioning the list in such a way that left subtree is roughly equal to right subtree in size/# of nodes).\\n\\n# Say, it was 4: then\\n#\\t\\tleft node of 4 will be decided from the left half of the list (from inOrderList[0:2])\\n#\\t\\tand right node of 4 will be decided from the right half of the list (from inOrderList[3:])\\n#\\t\\tand the process goes on recursively\\n```\\n\\n\\n\\t\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inOrderTraversal(self, root):\\n        if not root:\\n            return \\n        \\n\\t\\t# traverse left subtree\\n\\t\\tself.inOrderTraversal(root.left)\\n\\t\\t\\n\\t\\t# append to list\\n        self.inOrderList.append(root)\\n        \\n\\t\\t# traverse right subtree\\n\\t\\tself.inOrderTraversal(root.right)\\n        \\n        return \\n    \\n    def createBBST(self,low, high):\\n\\t\\t# base case\\n        if low > high:\\n            return None\\n\\n\\t\\t# pick middle node\\n        mid = low + high >> 1\\n        \\n        node = self.inOrderList[mid]\\n        node.left = self.createBBST(low, mid - 1)\\n        node.right = self.createBBST(mid + 1, high)\\n        \\n        return node\\n        \\n    \\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        self.inOrderList = []\\n        self.inOrderTraversal(root)\\n        return self.createBBST(0, len(self.inOrderList)-1)\\n```\n```\\n\\t\\t3\\n\\t  /   \\\\\\n \\t 1     4\\n\\t        \\\\\\n\\t\\t\\t 7\\n\\t\\t\\t  \\\\\\n\\t\\t\\t   9\\n\\t\\t\\t\\t\\\\\\n\\t\\t\\t  \\t 10\\n\\t\\t\\t\\t \\n# we perform inOrderTraversal on this BST, we get\\n\\ninOrderList = [1,3,4,7,9,10]\\n\\n# Now if we were to form a Balanced BST from this list, our choice of root will be either 4 or 7 \\n#(partioning the list in such a way that left subtree is roughly equal to right subtree in size/# of nodes).\\n\\n# Say, it was 4: then\\n#\\t\\tleft node of 4 will be decided from the left half of the list (from inOrderList[0:2])\\n#\\t\\tand right node of 4 will be decided from the right half of the list (from inOrderList[3:])\\n#\\t\\tand the process goes on recursively\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604379,
                "title": "easy-c-solution",
                "content": "```\\nprivate:\\n    void inorder(TreeNode* root,vector<int>&v)\\n    {\\n        if(root==NULL)\\n            return;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    \\n    private:\\n    TreeNode* BST(vector<int>&v,int l,int h)\\n    {\\n        if(l<=h)\\n        {\\n            int mid=l+(h-l)/2;\\n            TreeNode* root=new TreeNode(v[mid]);\\n            root->left=BST(v,l,mid-1);\\n            root->right=BST(v,mid+1,h);\\n            return root;\\n        }\\n        return NULL;\\n    }\\n    \\n    public:\\n    TreeNode* balanceBST(TreeNode* root) \\n    {\\n        vector<int>v;\\n        if(root==NULL)\\n            return root;\\n        inorder(root,v);\\n        return BST(v,0,v.size()-1);\\n    }",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nprivate:\\n    void inorder(TreeNode* root,vector<int>&v)\\n    {\\n        if(root==NULL)\\n            return;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    \\n    private:\\n    TreeNode* BST(vector<int>&v,int l,int h)\\n    {\\n        if(l<=h)\\n        {\\n            int mid=l+(h-l)/2;\\n            TreeNode* root=new TreeNode(v[mid]);\\n            root->left=BST(v,l,mid-1);\\n            root->right=BST(v,mid+1,h);\\n            return root;\\n        }\\n        return NULL;\\n    }\\n    \\n    public:\\n    TreeNode* balanceBST(TreeNode* root) \\n    {\\n        vector<int>v;\\n        if(root==NULL)\\n            return root;\\n        inorder(root,v);\\n        return BST(v,0,v.size()-1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1487702,
                "title": "c-easy-to-understand-fast-find-inorder-traversal-and-then-construct",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<TreeNode*> &v)\\n    {\\n        if(root==NULL)\\n        return;\\n        if(root->left)\\n        inorder(root->left,v);\\n        v.push_back(root);\\n        if(root->right)\\n        inorder(root->right,v);\\n    }\\n    TreeNode* solve(int low,int high,vector<TreeNode*> &v)\\n    {\\n        if(low>high)\\n        return NULL;\\n        int m=(low+high)/2;\\n        v[m]->left=solve(low,m-1,v);\\n        v[m]->right=solve(m+1,high,v);\\n        return v[m];\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n     vector<TreeNode*> v;\\n     inorder(root,v);\\n     return solve(0,v.size()-1,v);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<TreeNode*> &v)\\n    {\\n        if(root==NULL)\\n        return;\\n        if(root->left)\\n        inorder(root->left,v);\\n        v.push_back(root);\\n        if(root->right)\\n        inorder(root->right,v);\\n    }\\n    TreeNode* solve(int low,int high,vector<TreeNode*> &v)\\n    {\\n        if(low>high)\\n        return NULL;\\n        int m=(low+high)/2;\\n        v[m]->left=solve(low,m-1,v);\\n        v[m]->right=solve(m+1,high,v);\\n        return v[m];\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n     vector<TreeNode*> v;\\n     inorder(root,v);\\n     return solve(0,v.size()-1,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1473137,
                "title": "simple-java-o-n-solution-100-faster-clear-and-step-by-step",
                "content": "public TreeNode balanceBST(TreeNode root) {\\n        \\n        List<TreeNode> list=new ArrayList<>();\\n        \\n        inorder(root,list);\\n        \\n        \\n        return buildTree(list,0,list.size()-1); \\n        \\n        \\n    }\\n    \\n    \\n    public TreeNode buildTree(List<TreeNode> list,int start,int end){\\n        \\n        if(start>end){\\n            return null;\\n        }\\n        \\n        int mid=start+(end-start)/2;\\n        \\n        TreeNode root=list.get(mid);\\n        \\n        root.left=buildTree(list,start,mid-1);\\n        root.right=buildTree(list,mid+1,end);\\n        \\n        return root;\\n        \\n    }\\n    \\n    public void inorder(TreeNode root,List<TreeNode> list){\\n        if(root==null){\\n            return;\\n        }\\n        inorder(root.left,list);\\n        list.add(root);\\n        inorder(root.right,list);\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "public TreeNode balanceBST(TreeNode root) {\\n        \\n        List<TreeNode> list=new ArrayList<>();\\n        \\n        inorder(root,list);\\n        \\n        \\n        return buildTree(list,0,list.size()-1); \\n        \\n        \\n    }\\n    \\n    \\n    public TreeNode buildTree(List<TreeNode> list,int start,int end){\\n        \\n        if(start>end){\\n            return null;\\n        }\\n        \\n        int mid=start+(end-start)/2;\\n        \\n        TreeNode root=list.get(mid);\\n        \\n        root.left=buildTree(list,start,mid-1);\\n        root.right=buildTree(list,mid+1,end);\\n        \\n        return root;\\n        \\n    }\\n    \\n    public void inorder(TreeNode root,List<TreeNode> list){\\n        if(root==null){\\n            return;\\n        }\\n        inorder(root.left,list);\\n        list.add(root);\\n        inorder(root.right,list);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1410630,
                "title": "c-red-balck-bst",
                "content": "DSW and Red-Black are two representative alogrithm to build a balanced tree. \\nDSW is static algorithm so any change after creating it will require you to apply DSW again to keep balance tree.\\nHowever, red-black tree is a dynamic data structure, all of its basic operations are LogN and it will maintain the balanced tree by modifiying itself on the fly when there is change.\\nSince there are already many people posted about DSW, I\\'m going to post Red-black tree version over here.\\n\\nAbout the algorithm : https://en.wikipedia.org/wiki/Red%E2%80%93black_tree\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* rotateLeft(TreeNode* root, unordered_map<TreeNode*, bool> &isRed){\\n        TreeNode * newHead = root->right;\\n        root->right = newHead->left;\\n        newHead->left = root;\\n        isRed[newHead] = isRed[root];\\n        isRed[newHead->left] = true;\\n        return newHead;\\n    }\\n    \\n    TreeNode* rotateRight(TreeNode* root, unordered_map<TreeNode*, bool> &isRed){\\n        TreeNode* newHead = root->left;\\n        root->left = newHead->right;\\n        newHead->right = root;\\n        isRed[newHead] = isRed[root];\\n        isRed[newHead->right] = true;\\n        return newHead;\\n    }\\n    \\n    void flipColors(TreeNode* root, unordered_map<TreeNode*, bool> &isRed){\\n        isRed[root] = true;\\n        isRed[root->left] = false;\\n        isRed[root->right] = false;\\n    }\\n    \\n    \\n    TreeNode* put(TreeNode* rbRoot, TreeNode* root, unordered_map<TreeNode*, bool> &isRed){\\n        if(rbRoot == nullptr){\\n            rbRoot = root;\\n            isRed[rbRoot] = true;\\n            return rbRoot;\\n        }\\n        if(root->val<= rbRoot->val){\\n            rbRoot->left = put(rbRoot->left, root, isRed);\\n        } else {\\n            rbRoot->right = put(rbRoot->right, root, isRed);\\n        }\\n        if(rbRoot->right && isRed[rbRoot->right]){\\n            rbRoot = rotateLeft(rbRoot, isRed);\\n        }\\n        if(rbRoot->left && rbRoot->left->left && isRed[rbRoot->left->left] && isRed[rbRoot->left]){\\n            rbRoot = rotateRight(rbRoot, isRed);\\n        }\\n        if(rbRoot->left && rbRoot->right && isRed[rbRoot->left] && isRed[rbRoot->right]){\\n            flipColors(rbRoot, isRed);\\n        }\\n        return rbRoot;\\n    }\\n    \\n    void iterate(TreeNode* root,TreeNode** rbRoot, unordered_map<TreeNode*, bool> &isRed){\\n        if(root == nullptr){\\n            return;\\n        }\\n        TreeNode* left = root->left;\\n        TreeNode* right = root->right;\\n        root->left = nullptr;\\n        root->right = nullptr;\\n        iterate(left, rbRoot, isRed);\\n        *rbRoot = put(*rbRoot, root, isRed);\\n        iterate(right, rbRoot, isRed);\\n        return;\\n    }\\n    \\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        unordered_map<TreeNode*, bool> isRed;\\n        TreeNode* rbRoot = nullptr;\\n        iterate(root, &rbRoot, isRed);\\n        return rbRoot;\\n    }\\n};\\n```\\n\\nWhile DSW will use O(N) time to create, red-black tree will use O(NlogN) to balance a tree whose node size is N.\\nHowever, in the future when we add a new node, DSW will need to use its O(N) algorithm to balance while red-black tree will use O(logn) to add that new node.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* rotateLeft(TreeNode* root, unordered_map<TreeNode*, bool> &isRed){\\n        TreeNode * newHead = root->right;\\n        root->right = newHead->left;\\n        newHead->left = root;\\n        isRed[newHead] = isRed[root];\\n        isRed[newHead->left] = true;\\n        return newHead;\\n    }\\n    \\n    TreeNode* rotateRight(TreeNode* root, unordered_map<TreeNode*, bool> &isRed){\\n        TreeNode* newHead = root->left;\\n        root->left = newHead->right;\\n        newHead->right = root;\\n        isRed[newHead] = isRed[root];\\n        isRed[newHead->right] = true;\\n        return newHead;\\n    }\\n    \\n    void flipColors(TreeNode* root, unordered_map<TreeNode*, bool> &isRed){\\n        isRed[root] = true;\\n        isRed[root->left] = false;\\n        isRed[root->right] = false;\\n    }\\n    \\n    \\n    TreeNode* put(TreeNode* rbRoot, TreeNode* root, unordered_map<TreeNode*, bool> &isRed){\\n        if(rbRoot == nullptr){\\n            rbRoot = root;\\n            isRed[rbRoot] = true;\\n            return rbRoot;\\n        }\\n        if(root->val<= rbRoot->val){\\n            rbRoot->left = put(rbRoot->left, root, isRed);\\n        } else {\\n            rbRoot->right = put(rbRoot->right, root, isRed);\\n        }\\n        if(rbRoot->right && isRed[rbRoot->right]){\\n            rbRoot = rotateLeft(rbRoot, isRed);\\n        }\\n        if(rbRoot->left && rbRoot->left->left && isRed[rbRoot->left->left] && isRed[rbRoot->left]){\\n            rbRoot = rotateRight(rbRoot, isRed);\\n        }\\n        if(rbRoot->left && rbRoot->right && isRed[rbRoot->left] && isRed[rbRoot->right]){\\n            flipColors(rbRoot, isRed);\\n        }\\n        return rbRoot;\\n    }\\n    \\n    void iterate(TreeNode* root,TreeNode** rbRoot, unordered_map<TreeNode*, bool> &isRed){\\n        if(root == nullptr){\\n            return;\\n        }\\n        TreeNode* left = root->left;\\n        TreeNode* right = root->right;\\n        root->left = nullptr;\\n        root->right = nullptr;\\n        iterate(left, rbRoot, isRed);\\n        *rbRoot = put(*rbRoot, root, isRed);\\n        iterate(right, rbRoot, isRed);\\n        return;\\n    }\\n    \\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        unordered_map<TreeNode*, bool> isRed;\\n        TreeNode* rbRoot = nullptr;\\n        iterate(root, &rbRoot, isRed);\\n        return rbRoot;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328246,
                "title": "basic-idea-inorder-traversal-balanced-bst",
                "content": "Break the problem into two-\\n* create an inorder traversal vector.\\n* use this vector to create balanced binary search tree\\n\\nvoid inorder(TreeNode *root,vector<int>&v)\\n    {\\n        if(root==NULL)return;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    \\n    TreeNode* construct(vector<int>&v , int low , int high)\\n    {\\n        if(low>high)return NULL;\\n        int ind=low + (high-low)/2;\\n        TreeNode *root=new TreeNode(v[ind]);\\n        root->left = construct(v,low,ind-1);\\n        root->right = construct(v,ind+1,high);\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        \\n        vector<int>v;\\n        inorder(root,v);\\n        return (construct(v,0,v.size()-1));\\n    }",
                "solutionTags": [],
                "code": "Break the problem into two-\\n* create an inorder traversal vector.\\n* use this vector to create balanced binary search tree\\n\\nvoid inorder(TreeNode *root,vector<int>&v)\\n    {\\n        if(root==NULL)return;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    \\n    TreeNode* construct(vector<int>&v , int low , int high)\\n    {\\n        if(low>high)return NULL;\\n        int ind=low + (high-low)/2;\\n        TreeNode *root=new TreeNode(v[ind]);\\n        root->left = construct(v,low,ind-1);\\n        root->right = construct(v,ind+1,high);\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        \\n        vector<int>v;\\n        inorder(root,v);\\n        return (construct(v,0,v.size()-1));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1297056,
                "title": "python-inorder-traversal-and-reconstruct-bst",
                "content": "```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        \\n        \\n        # Inorder traverse the tree\\n        def inorder(root, nums) -> None:\\n            if root == None:\\n                return\\n            \\n            if root.left != None:\\n                inorder(root.left, nums)\\n            \\n            nums.append(root.val)\\n            \\n            if root.right != None:\\n                inorder(root.right, nums)\\n\\n                \\n                \\n                \\n        # Recursively construct the BST given the list of value\\n        def constructBST(nums):\\n            totalNums = len(nums)\\n            \\n            if totalNums == 0:\\n                return None\\n            else:\\n                rootIndex = totalNums // 2\\n                print(nums, rootIndex)    \\n                root = TreeNode(nums[rootIndex])\\n                \\n                root.left = constructBST(nums[:rootIndex])\\n                root.right = constructBST(nums[rootIndex+1:])\\n                \\n                return root\\n                    \\n            \\n        nums = []\\n        inorder(root, nums)\\n        return constructBST(nums)\\n\\t\\t\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        \\n        \\n        # Inorder traverse the tree\\n        def inorder(root, nums) -> None:\\n            if root == None:\\n                return\\n            \\n            if root.left != None:\\n                inorder(root.left, nums)\\n            \\n            nums.append(root.val)\\n            \\n            if root.right != None:\\n                inorder(root.right, nums)\\n\\n                \\n                \\n                \\n        # Recursively construct the BST given the list of value\\n        def constructBST(nums):\\n            totalNums = len(nums)\\n            \\n            if totalNums == 0:\\n                return None\\n            else:\\n                rootIndex = totalNums // 2\\n                print(nums, rootIndex)    \\n                root = TreeNode(nums[rootIndex])\\n                \\n                root.left = constructBST(nums[:rootIndex])\\n                root.right = constructBST(nums[rootIndex+1:])\\n                \\n                return root\\n                    \\n            \\n        nums = []\\n        inorder(root, nums)\\n        return constructBST(nums)\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861125,
                "title": "java-solution-using-inorder-and-then-balancing",
                "content": "```\\nclass Solution {\\n    private TreeNode roott;\\n    private List<Integer> list;\\n    public TreeNode balanceBST(TreeNode root) {\\n        list = new ArrayList<>();\\n        inorder(root);\\n        TreeNode tn = balancedBst(0,list.size()-1);\\n        return tn;\\n    }\\n    \\n    void inorder(TreeNode node){\\n        if(node == null)\\n            return;\\n        inorder(node.left);\\n        list.add(node.val);\\n        inorder(node.right);\\n    }\\n     TreeNode balancedBst(int start,int end){\\n        \\n         if(start > end){\\n             return null;\\n         }\\n         \\n         int mid = (start+end)/2;\\n         TreeNode node = new TreeNode(list.get(mid));\\n         node.left = balancedBst(start,mid-1);\\n         node.right = balancedBst(mid+1,end);\\n             \\n         return node;\\n     }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private TreeNode roott;\\n    private List<Integer> list;\\n    public TreeNode balanceBST(TreeNode root) {\\n        list = new ArrayList<>();\\n        inorder(root);\\n        TreeNode tn = balancedBst(0,list.size()-1);\\n        return tn;\\n    }\\n    \\n    void inorder(TreeNode node){\\n        if(node == null)\\n            return;\\n        inorder(node.left);\\n        list.add(node.val);\\n        inorder(node.right);\\n    }\\n     TreeNode balancedBst(int start,int end){\\n        \\n         if(start > end){\\n             return null;\\n         }\\n         \\n         int mid = (start+end)/2;\\n         TreeNode node = new TreeNode(list.get(mid));\\n         node.left = balancedBst(start,mid-1);\\n         node.right = balancedBst(mid+1,end);\\n             \\n         return node;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 787872,
                "title": "java-o-n-space-o-n-time-2ms-recursion-divide-and-conquer",
                "content": "Please read comments. And upwote if you like this solution\\n```\\nclass Solution {\\n\\t// to store all nodes values\\n    List<Integer> array = new ArrayList<Integer>();\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n\\t\\t// traverse recursively to save sorged list of all node values\\n        traverse(root);\\n\\t\\t// build recursively new BST\\n        return buildTree(0, array.size() - 1);\\n    }\\n    \\n\\t// Divide and conquer\\n\\t// get mid item as a root node.\\n\\t// nodes to the left will build left subtree\\n\\t// nodes to the right will build right subtree\\n    public TreeNode buildTree(int start, int end) {\\n        if (start > end) return null;\\n        int mid = start + (end - start)/2;\\n        TreeNode node = new TreeNode(array.get(mid));\\n        node.left = buildTree(start, mid - 1);\\n        node.right = buildTree(mid + 1, end);\\n        return node;\\n    }\\n    \\n\\t// inorder traversal Left - Curr - Right\\n\\t// Array will be sorted, guaranted by BST Properties\\n    public void traverse(TreeNode root) {\\n        if (root.left != null) {\\n            traverse(root.left);\\n        }\\n        array.add(root.val);\\n        if (root.right != null) {\\n            traverse(root.right);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t// to store all nodes values\\n    List<Integer> array = new ArrayList<Integer>();\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n\\t\\t// traverse recursively to save sorged list of all node values\\n        traverse(root);\\n\\t\\t// build recursively new BST\\n        return buildTree(0, array.size() - 1);\\n    }\\n    \\n\\t// Divide and conquer\\n\\t// get mid item as a root node.\\n\\t// nodes to the left will build left subtree\\n\\t// nodes to the right will build right subtree\\n    public TreeNode buildTree(int start, int end) {\\n        if (start > end) return null;\\n        int mid = start + (end - start)/2;\\n        TreeNode node = new TreeNode(array.get(mid));\\n        node.left = buildTree(start, mid - 1);\\n        node.right = buildTree(mid + 1, end);\\n        return node;\\n    }\\n    \\n\\t// inorder traversal Left - Curr - Right\\n\\t// Array will be sorted, guaranted by BST Properties\\n    public void traverse(TreeNode root) {\\n        if (root.left != null) {\\n            traverse(root.left);\\n        }\\n        array.add(root.val);\\n        if (root.right != null) {\\n            traverse(root.right);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539793,
                "title": "java-inorder-bst",
                "content": "```\\nclass Solution {\\n    \\n    List<Integer> nums;\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        nums = new ArrayList<Integer>();\\n        getNumbers(root);\\n        TreeNode res = balanceTree(0,nums.size()-1);\\n        return res;\\n    }\\n    \\n    private void getNumbers(TreeNode node){\\n        if(node==null) return;\\n        getNumbers(node.left);\\n        nums.add(node.val);\\n        getNumbers(node.right);\\n    }\\n    \\n    private TreeNode balanceTree(int l, int r){\\n        if(l>r)return null;\\n        int middleIdx = l+ ((r-l)/2);\\n        TreeNode res = new TreeNode(nums.get(middleIdx));\\n        res.left = balanceTree(l,middleIdx-1);\\n        res.right = balanceTree(middleIdx+1,r);\\n        return res;\\n    }              \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    List<Integer> nums;\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        nums = new ArrayList<Integer>();\\n        getNumbers(root);\\n        TreeNode res = balanceTree(0,nums.size()-1);\\n        return res;\\n    }\\n    \\n    private void getNumbers(TreeNode node){\\n        if(node==null) return;\\n        getNumbers(node.left);\\n        nums.add(node.val);\\n        getNumbers(node.right);\\n    }\\n    \\n    private TreeNode balanceTree(int l, int r){\\n        if(l>r)return null;\\n        int middleIdx = l+ ((r-l)/2);\\n        TreeNode res = new TreeNode(nums.get(middleIdx));\\n        res.left = balanceTree(l,middleIdx-1);\\n        res.right = balanceTree(middleIdx+1,r);\\n        return res;\\n    }              \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539763,
                "title": "swift-inorder-dfs-clean-code",
                "content": "We create a sorted array by using inorder traversal\\n```\\nclass Solution {\\n    func balanceBST(_ root: TreeNode?) -> TreeNode? {\\n        var arr = [TreeNode]()\\n        \\n        func inorder(_ node: TreeNode?) {\\n            guard let node = node else { return }\\n            inorder(node.left)\\n            arr.append(node)\\n            inorder(node.right)\\n        }\\n        \\n        func build(_ nodes: [TreeNode], _ start: Int, _ end: Int) -> TreeNode? {\\n            if start > end { return nil }\\n  \\n            let mid = (start + end) / 2\\n            var node = nodes[mid] \\n            \\n            node.left = build(nodes, start, mid - 1)\\n            node.right = build(nodes, mid + 1, end)\\n\\n            return node\\n        }\\n        \\n        inorder(root)\\n        return build(arr, 0, arr.count-1)\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    func balanceBST(_ root: TreeNode?) -> TreeNode? {\\n        var arr = [TreeNode]()\\n        \\n        func inorder(_ node: TreeNode?) {\\n            guard let node = node else { return }\\n            inorder(node.left)\\n            arr.append(node)\\n            inorder(node.right)\\n        }\\n        \\n        func build(_ nodes: [TreeNode], _ start: Int, _ end: Int) -> TreeNode? {\\n            if start > end { return nil }\\n  \\n            let mid = (start + end) / 2\\n            var node = nodes[mid] \\n            \\n            node.left = build(nodes, start, mid - 1)\\n            node.right = build(nodes, mid + 1, end)\\n\\n            return node\\n        }\\n        \\n        inorder(root)\\n        return build(arr, 0, arr.count-1)\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539728,
                "title": "java-store-inorder-and-then-build-the-tree-again",
                "content": "```\\nclass Solution {\\n    static List<Integer> arr;\\n    public static void dfs(TreeNode root) {\\n        if(root == null) return;\\n        dfs(root.left);\\n        arr.add(root.val);\\n        dfs(root.right);\\n    }\\n    public static TreeNode build(List<Integer> arr, int st, int end) {\\n        if(st > end) return null;\\n        if(st == end) return new TreeNode(arr.get(st));\\n        int mid = (st + end)/2;\\n        TreeNode root = new TreeNode(arr.get(mid));\\n        root.left = build(arr, st, mid - 1);\\n        root.right = build(arr, mid + 1, end);\\n        return root;\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        arr = new ArrayList<>();\\n        dfs(root);\\n        return build(arr, 0, arr.size() - 1);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    static List<Integer> arr;\\n    public static void dfs(TreeNode root) {\\n        if(root == null) return;\\n        dfs(root.left);\\n        arr.add(root.val);\\n        dfs(root.right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 4010316,
                "title": "didive-and-conquer-simple-solution-in-python3",
                "content": "# Intuition\\nThe problem description is the following:\\n- given a **Binary Search Tree**\\n- the goal is to make this tree `balanced`\\n\\n```py\\n# Example\\nnodes = TreeNode(0, None, TreeNode(1, None, TreeNode(2)))\\n\\n# The first step is to inorder traversal, to get all nodes\\n# in sorted order \\nnums = [0, 1, 2]\\n\\n# The next step is to recreate a tree,\\n# there\\'s a bunch of different approaches, like building \\n# AVL-tree, but for the sake of brefity, we focus only\\n# on Divide-and-Conquer.\\n# The goal is to split a list at equal size parts by\\n# defining a middle of an initial list\\nnode = TreeNode(nums[1])\\nnode.left = TreeNode(nums[0])\\nnode.right = TreeNode(nums[2])\\n\\n# The thing is that the example above HARDCODED only for 3 nodes\\n# in that list, thus we need to split a list and repeat\\n# the procedure until we\\'re out of nodes\\n\\n```\\n\\n# Approach\\n1. initialize a `nums` variable to store the ordered numbers\\n2. perform `inorder traversal` by implementing and calling `dfs` function\\n3. create a `balance` function with `left` and `right` arguments as starting and ending index of `nums`\\n4. if we\\'re out of nodes `left > right`, return `None`\\n5. find the `mid` by dividing a **sum** of pointers\\n6. shift the pointers as if it was a **binary search** and store the result into `node.left` and `node.right` children\\n7. return `node`\\n\\n# Complexity\\n- Time complexity: **O(n)**, because of twice iterating over `root` and `nums`\\n\\n- Space complexity: **O(n)**, this requires for recursive stack calling.\\n\\n# Code\\n```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        nums = []\\n\\n        def dfs(node):\\n            if not node:\\n                return \\n\\n            dfs(node.left)\\n            nums.append(node.val)\\n            dfs(node.right)\\n\\n        dfs(root)\\n\\n        def balance(left = 0, right = len(nums) - 1):\\n            if left > right:\\n                return None\\n\\n            mid = (left + right) // 2\\n            node = TreeNode(nums[mid])\\n            node.left = balance(left, mid - 1)\\n            node.right = balance(mid + 1, right)\\n\\n            return node\\n\\n        return balance() \\n```",
                "solutionTags": [
                    "Python3",
                    "Divide and Conquer",
                    "Binary Search Tree"
                ],
                "code": "```py\\n# Example\\nnodes = TreeNode(0, None, TreeNode(1, None, TreeNode(2)))\\n\\n# The first step is to inorder traversal, to get all nodes\\n# in sorted order \\nnums = [0, 1, 2]\\n\\n# The next step is to recreate a tree,\\n# there\\'s a bunch of different approaches, like building \\n# AVL-tree, but for the sake of brefity, we focus only\\n# on Divide-and-Conquer.\\n# The goal is to split a list at equal size parts by\\n# defining a middle of an initial list\\nnode = TreeNode(nums[1])\\nnode.left = TreeNode(nums[0])\\nnode.right = TreeNode(nums[2])\\n\\n# The thing is that the example above HARDCODED only for 3 nodes\\n# in that list, thus we need to split a list and repeat\\n# the procedure until we\\'re out of nodes\\n\\n```\n```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        nums = []\\n\\n        def dfs(node):\\n            if not node:\\n                return \\n\\n            dfs(node.left)\\n            nums.append(node.val)\\n            dfs(node.right)\\n\\n        dfs(root)\\n\\n        def balance(left = 0, right = len(nums) - 1):\\n            if left > right:\\n                return None\\n\\n            mid = (left + right) // 2\\n            node = TreeNode(nums[mid])\\n            node.left = balance(left, mid - 1)\\n            node.right = balance(mid + 1, right)\\n\\n            return node\\n\\n        return balance() \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780838,
                "title": "solve-using-divide-and-conquer-algorithm",
                "content": "# Intuition\\nWe want to convert an original unbalanced binary search tree to balanced binary search tree.\\n\\n# Approach\\nFirst of all, we will use depth-first-search to traverse in-order and put them into a list of integer. Then we will use this list to construct a new height balanced binary search tree using normal divide and conquer.\\n\\n# Complexity\\n- Time complexity:\\nO(n) with n as the number of vertices.\\n\\n- Space complexity:\\nO(log(n)) on average and O(n) worst scenario.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    // convert a bst to an inorder traversal\\n    private static void convertInorder(TreeNode root, List<Integer> inOrderTraversal) {\\n        if(root==null) return;\\n        convertInorder(root.left, inOrderTraversal);\\n        inOrderTraversal.add(root.val);\\n        convertInorder(root.right, inOrderTraversal);  \\n    }\\n    // construct a height balanced bst using the in-order\\n    private TreeNode constructBST(List<Integer> inOrderTraversal, int start, int end) {\\n        if(start > end) return null;\\n        int mid = start + (end-start)/2;\\n        TreeNode root = new TreeNode(inOrderTraversal.get(mid));\\n        root.left = constructBST(inOrderTraversal, start, mid-1);\\n        root.right = constructBST(inOrderTraversal, mid+1, end);\\n        return root;\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        if(root==null) return null;\\n        List<Integer> inOrderTraversal = new ArrayList<>();\\n        convertInorder(root, inOrderTraversal);\\n        return constructBST(inOrderTraversal, 0, inOrderTraversal.size()-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    // convert a bst to an inorder traversal\\n    private static void convertInorder(TreeNode root, List<Integer> inOrderTraversal) {\\n        if(root==null) return;\\n        convertInorder(root.left, inOrderTraversal);\\n        inOrderTraversal.add(root.val);\\n        convertInorder(root.right, inOrderTraversal);  \\n    }\\n    // construct a height balanced bst using the in-order\\n    private TreeNode constructBST(List<Integer> inOrderTraversal, int start, int end) {\\n        if(start > end) return null;\\n        int mid = start + (end-start)/2;\\n        TreeNode root = new TreeNode(inOrderTraversal.get(mid));\\n        root.left = constructBST(inOrderTraversal, start, mid-1);\\n        root.right = constructBST(inOrderTraversal, mid+1, end);\\n        return root;\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        if(root==null) return null;\\n        List<Integer> inOrderTraversal = new ArrayList<>();\\n        convertInorder(root, inOrderTraversal);\\n        return constructBST(inOrderTraversal, 0, inOrderTraversal.size()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712468,
                "title": "easy-c-solution-beat-80",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    void inorderarray(TreeNode* &root,vector<int> &inorder){\\n        if(root==NULL)\\n        return ;\\n        inorderarray(root->left,inorder);\\n        inorder.push_back(root->val);\\n        inorderarray(root->right,inorder);\\n    }\\n    TreeNode* buildtree(vector<int>& inorder,int s,int e){\\n    if(s>e)\\n        return NULL;\\n    int mid=s+(e-s)/2;\\n    int ele=inorder[mid];\\n    TreeNode* root=new TreeNode(ele);\\n    root->left=buildtree(inorder,s,mid-1);\\n    root->right=buildtree(inorder,mid+1,e);\\n        return root;\\n    }\\n    \\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> inorder;\\n        inorderarray(root,inorder);\\n        return buildtree(inorder,0,inorder.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void inorderarray(TreeNode* &root,vector<int> &inorder){\\n        if(root==NULL)\\n        return ;\\n        inorderarray(root->left,inorder);\\n        inorder.push_back(root->val);\\n        inorderarray(root->right,inorder);\\n    }\\n    TreeNode* buildtree(vector<int>& inorder,int s,int e){\\n    if(s>e)\\n        return NULL;\\n    int mid=s+(e-s)/2;\\n    int ele=inorder[mid];\\n    TreeNode* root=new TreeNode(ele);\\n    root->left=buildtree(inorder,s,mid-1);\\n    root->right=buildtree(inorder,mid+1,e);\\n        return root;\\n    }\\n    \\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> inorder;\\n        inorderarray(root,inorder);\\n        return buildtree(inorder,0,inorder.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473553,
                "title": "easy-c-solution-using-recursion-and-inorder-traversal",
                "content": "\\n\\n# Approach\\nNormal BST to vector because we get in sorted order and then make a BST again\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root, vector<TreeNode*> &arr){\\n        if(root==NULL){\\n            return ;\\n        }\\n\\t\\tfun(root->left,arr);\\n        arr.push_back(root);\\n        fun(root->right,arr);\\n    }\\n\\n    TreeNode* newbst(vector<TreeNode*> &arr,int start,int end )\\n    {\\n        if(start>end)\\n        {\\n            return NULL;\\n        }\\n        int mid =start+(end-start)/2;\\n        TreeNode* temp=arr[mid];\\n        temp->left=newbst(arr,start,mid-1);\\n        temp->right=newbst(arr,mid+1,end);\\n        return temp;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*>arr;\\n        fun(root,arr);\\n        return newbst(arr,0,arr.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root, vector<TreeNode*> &arr){\\n        if(root==NULL){\\n            return ;\\n        }\\n\\t\\tfun(root->left,arr);\\n        arr.push_back(root);\\n        fun(root->right,arr);\\n    }\\n\\n    TreeNode* newbst(vector<TreeNode*> &arr,int start,int end )\\n    {\\n        if(start>end)\\n        {\\n            return NULL;\\n        }\\n        int mid =start+(end-start)/2;\\n        TreeNode* temp=arr[mid];\\n        temp->left=newbst(arr,start,mid-1);\\n        temp->right=newbst(arr,mid+1,end);\\n        return temp;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*>arr;\\n        fun(root,arr);\\n        return newbst(arr,0,arr.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092851,
                "title": "simple-approach-inorder-traversal-o-n-time",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<TreeNode*>inorder;\\n    void buildInorder(TreeNode* root){\\n        if(!root)return;\\n        buildInorder(root->left);\\n        inorder.push_back(root);\\n        buildInorder(root->right);\\n    }\\n    TreeNode* balanceUtil(TreeNode* root,int is,int ie){\\n        if(is>ie)return NULL;\\n        int mid=(is+ie)/2;\\n        root=inorder[mid];\\n        root->left=balanceUtil(root->left,is,mid-1);\\n        root->right=balanceUtil(root->right,mid+1,ie);\\n        return root;\\n\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        buildInorder(root);\\n        return balanceUtil(root,0,inorder.size()-1);\\n        \\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector<TreeNode*>inorder;\\n    void buildInorder(TreeNode* root){\\n        if(!root)return;\\n        buildInorder(root->left);\\n        inorder.push_back(root);\\n        buildInorder(root->right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2848494,
                "title": "c-solution-recursion-sc-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solution1(vector <int> &v,int start,int end){\\n        if(start>end) return NULL;\\n        int mid=start+(end-start)/2;\\n        TreeNode * root=new TreeNode (v[mid]);\\n        root->left=solution1(v,start,mid-1);\\n         root->right=solution1(v,mid+1,end);\\n         return root;\\n        \\n    }\\n    void solution(vector <int> &v,TreeNode* root){\\n        if(!root) return;\\n        solution(v,root->left);\\n        v.push_back(root->val);\\n        solution(v,root->right);\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector <int> v;\\n        solution(v,root);\\n        return solution1(v,0,v.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solution1(vector <int> &v,int start,int end){\\n        if(start>end) return NULL;\\n        int mid=start+(end-start)/2;\\n        TreeNode * root=new TreeNode (v[mid]);\\n        root->left=solution1(v,start,mid-1);\\n         root->right=solution1(v,mid+1,end);\\n         return root;\\n        \\n    }\\n    void solution(vector <int> &v,TreeNode* root){\\n        if(!root) return;\\n        solution(v,root->left);\\n        v.push_back(root->val);\\n        solution(v,root->right);\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector <int> v;\\n        solution(v,root);\\n        return solution1(v,0,v.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448929,
                "title": "90-faster-python-tc-385ms",
                "content": "```\\ndef helper(head): #getting a sorted list\\n\\tif not head:\\n\\t\\treturn\\n\\thelper(head.left)\\n\\tlist1.append(head.val)\\n\\thelper(head.right)\\n\\n\\ndef BBST(list1,start,end): #creating a Balance Binary search tree.\\n\\tif start > end:\\n\\t\\treturn\\n\\tmid = (end-start)//2 \\n\\troot = TreeNode(list1[mid]) \\n\\troot.left = BBST(list1[:mid],0,mid-1) \\n\\troot.right = BBST(list1[mid+1:],mid+1,len(list1)-1) \\n\\treturn root     \\n\\nlist1 = []\\nhelper(root) # getting a sorted list\\n_len = len(list1)   \\nreturn BBST(list1,0,_len) #creating a Balance Binary search tree.\\n```\\n\\nplease upvote.\\nThank You :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\ndef helper(head): #getting a sorted list\\n\\tif not head:\\n\\t\\treturn\\n\\thelper(head.left)\\n\\tlist1.append(head.val)\\n\\thelper(head.right)\\n\\n\\ndef BBST(list1,start,end): #creating a Balance Binary search tree.\\n\\tif start > end:\\n\\t\\treturn\\n\\tmid = (end-start)//2 \\n\\troot = TreeNode(list1[mid]) \\n\\troot.left = BBST(list1[:mid],0,mid-1) \\n\\troot.right = BBST(list1[mid+1:],mid+1,len(list1)-1) \\n\\treturn root     \\n\\nlist1 = []\\nhelper(root) # getting a sorted list\\n_len = len(list1)   \\nreturn BBST(list1,0,_len) #creating a Balance Binary search tree.\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2409235,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***DFS***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // function for finding inorder traversal of tree\\n    \\n    void inorder(TreeNode* root, vector<int>& arr)\\n    {\\n        if(root == NULL)\\n            return;\\n        \\n        inorder(root -> left, arr);\\n        \\n        arr.push_back(root -> val);\\n        \\n        inorder(root -> right, arr);\\n    }\\n    \\n    // function for balancing bst\\n    \\n    TreeNode* balance_bst(vector<int>& arr, int start, int end)\\n    {\\n        // base case\\n        \\n        if(start > end)\\n            return NULL;\\n        \\n        // find mid\\n        \\n        int mid = start + (end - start) / 2;\\n        \\n        // create root and insert value as arr[mid]\\n        \\n        TreeNode* root = new TreeNode(arr[mid]);\\n        \\n        // call for creating balanced left subtree\\n        \\n        root -> left = balance_bst(arr, start, mid - 1);\\n        \\n        // call for creating balanced right subtree\\n        \\n        root -> right = balance_bst(arr, mid + 1, end);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        \\n        // arr will store the inorder traversal of bst\\n        \\n        vector<int> arr;\\n        \\n        inorder(root, arr);\\n        \\n        // create balance bst\\n        \\n        return balance_bst(arr, 0, arr.size() - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // function for finding inorder traversal of tree\\n    \\n    void inorder(TreeNode* root, vector<int>& arr)\\n    {\\n        if(root == NULL)\\n            return;\\n        \\n        inorder(root -> left, arr);\\n        \\n        arr.push_back(root -> val);\\n        \\n        inorder(root -> right, arr);\\n    }\\n    \\n    // function for balancing bst\\n    \\n    TreeNode* balance_bst(vector<int>& arr, int start, int end)\\n    {\\n        // base case\\n        \\n        if(start > end)\\n            return NULL;\\n        \\n        // find mid\\n        \\n        int mid = start + (end - start) / 2;\\n        \\n        // create root and insert value as arr[mid]\\n        \\n        TreeNode* root = new TreeNode(arr[mid]);\\n        \\n        // call for creating balanced left subtree\\n        \\n        root -> left = balance_bst(arr, start, mid - 1);\\n        \\n        // call for creating balanced right subtree\\n        \\n        root -> right = balance_bst(arr, mid + 1, end);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        \\n        // arr will store the inorder traversal of bst\\n        \\n        vector<int> arr;\\n        \\n        inorder(root, arr);\\n        \\n        // create balance bst\\n        \\n        return balance_bst(arr, 0, arr.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310699,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        List<Integer> arr = new ArrayList();\\n        InOrder( root,  arr);\\n        return sortedArrayToBST( arr, 0, arr.size()-1);\\n    }\\n    \\n    public void InOrder(TreeNode node, List<Integer> arr){\\n        if(node != null){\\n            InOrder( node.left, arr);\\n            arr.add(node.val);\\n            InOrder( node.right, arr);\\n        }\\n    }\\n    \\n    public TreeNode sortedArrayToBST(List<Integer> arr, int start, int end) {\\n\\n        if (start > end) {\\n            return null;\\n        }\\n \\n        int mid = (start + end) / 2;\\n        \\n        TreeNode node = new TreeNode(arr.get(mid));\\n        node.left = sortedArrayToBST(arr, start, mid - 1);\\n        node.right = sortedArrayToBST(arr, mid + 1, end);\\n         \\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        List<Integer> arr = new ArrayList();\\n        InOrder( root,  arr);\\n        return sortedArrayToBST( arr, 0, arr.size()-1);\\n    }\\n    \\n    public void InOrder(TreeNode node, List<Integer> arr){\\n        if(node != null){\\n            InOrder( node.left, arr);\\n            arr.add(node.val);\\n            InOrder( node.right, arr);\\n        }\\n    }\\n    \\n    public TreeNode sortedArrayToBST(List<Integer> arr, int start, int end) {\\n\\n        if (start > end) {\\n            return null;\\n        }\\n \\n        int mid = (start + end) / 2;\\n        \\n        TreeNode node = new TreeNode(arr.get(mid));\\n        node.left = sortedArrayToBST(arr, start, mid - 1);\\n        node.right = sortedArrayToBST(arr, mid + 1, end);\\n         \\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296913,
                "title": "c-inorder-traversal-o-n-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    \\n    void getTree(TreeNode* node, vector<int>&v)\\n    {\\n        if(!node)\\n            return;\\n        \\n        getTree(node->left, v);\\n        v.push_back(node->val);\\n        getTree(node->right, v);\\n    }\\n    \\n    TreeNode* makeTree(vector<int>& v, int left, int right)\\n    {\\n        if(left>right)\\n            return NULL;\\n        \\n        int mid=(left+right)/2;\\n        TreeNode* node = new TreeNode(v[mid]);\\n        node->left=makeTree(v, left, mid-1);\\n        node->right=makeTree(v, mid+1, right); \\n        \\n        return node;\\n    }\\n    \\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> v;\\n        getTree(root, v);\\n        return makeTree(v, 0, v.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    \\n    void getTree(TreeNode* node, vector<int>&v)\\n    {\\n        if(!node)\\n            return;\\n        \\n        getTree(node->left, v);\\n        v.push_back(node->val);\\n        getTree(node->right, v);\\n    }\\n    \\n    TreeNode* makeTree(vector<int>& v, int left, int right)\\n    {\\n        if(left>right)\\n            return NULL;\\n        \\n        int mid=(left+right)/2;\\n        TreeNode* node = new TreeNode(v[mid]);\\n        node->left=makeTree(v, left, mid-1);\\n        node->right=makeTree(v, mid+1, right); \\n        \\n        return node;\\n    }\\n    \\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> v;\\n        getTree(root, v);\\n        return makeTree(v, 0, v.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173620,
                "title": "convert-to-doublylinkedlist-and-then-to-bst-without-extra-space-o-n",
                "content": "```\\npublic TreeNode balanceBST(TreeNode root) {\\n        \\n        TreeNode prev=new TreeNode(-1);\\n        createDLL(root,prev);\\n\\t\\t\\n        return balancedBST(prev.right,null);\\n    }\\n    \\n    private TreeNode balancedBST(TreeNode start, TreeNode end){\\n        if(start==end || start==null){\\n            return null;\\n        }\\n        \\n        TreeNode slow=start;\\n        TreeNode fast=start;\\n        while(fast!=end && fast.right!=end){\\n            slow=slow.right;\\n            fast=fast.right.right;\\n        }\\n        \\n        slow.left=balancedBST(start,slow);\\n        slow.right=balancedBST(slow.right,end);\\n        \\n        return slow;\\n    }\\n    \\n    private TreeNode createDLL(TreeNode root, TreeNode prev){\\n        \\n        if(root.left!=null){\\n            prev=createDLL(root.left,prev);\\n        }\\n        \\n        prev.right=root;\\n        root.left=prev;\\n        prev=root;\\n        \\n        if(root.right!=null){\\n            prev=createDLL(root.right,prev);\\n        }\\n        return prev;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic TreeNode balanceBST(TreeNode root) {\\n        \\n        TreeNode prev=new TreeNode(-1);\\n        createDLL(root,prev);\\n\\t\\t\\n        return balancedBST(prev.right,null);\\n    }\\n    \\n    private TreeNode balancedBST(TreeNode start, TreeNode end){\\n        if(start==end || start==null){\\n            return null;\\n        }\\n        \\n        TreeNode slow=start;\\n        TreeNode fast=start;\\n        while(fast!=end && fast.right!=end){\\n            slow=slow.right;\\n            fast=fast.right.right;\\n        }\\n        \\n        slow.left=balancedBST(start,slow);\\n        slow.right=balancedBST(slow.right,end);\\n        \\n        return slow;\\n    }\\n    \\n    private TreeNode createDLL(TreeNode root, TreeNode prev){\\n        \\n        if(root.left!=null){\\n            prev=createDLL(root.left,prev);\\n        }\\n        \\n        prev.right=root;\\n        root.left=prev;\\n        prev=root;\\n        \\n        if(root.right!=null){\\n            prev=createDLL(root.right,prev);\\n        }\\n        return prev;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2127321,
                "title": "java-extremely-easy-to-understand-faster-than-98",
                "content": "```\\n// Time complexity = 2n = O(n)\\n// Space complexity = O(n)\\n\\nclass Solution {\\n    List<TreeNode> inorder = new ArrayList<>();\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        getInOrder(root);\\n        return createBalancedBST(0, inorder.size() - 1);\\n    }\\n    \\n    public void getInOrder(TreeNode node) {\\n        if(node == null) {\\n            return;\\n        }\\n        getInOrder(node.left);\\n        inorder.add(node);\\n        getInOrder(node.right);\\n    }\\n    \\n    public TreeNode createBalancedBST(int left, int right) {\\n        if(left > right) {\\n            return null;\\n        }\\n        \\n        int mid = (left + right) / 2;\\n        TreeNode curr = inorder.get(mid);\\n        \\n        curr.left = createBalancedBST(left, mid - 1);\\n        curr.right = createBalancedBST(mid + 1, right);\\n        \\n        return curr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Time complexity = 2n = O(n)\\n// Space complexity = O(n)\\n\\nclass Solution {\\n    List<TreeNode> inorder = new ArrayList<>();\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        getInOrder(root);\\n        return createBalancedBST(0, inorder.size() - 1);\\n    }\\n    \\n    public void getInOrder(TreeNode node) {\\n        if(node == null) {\\n            return;\\n        }\\n        getInOrder(node.left);\\n        inorder.add(node);\\n        getInOrder(node.right);\\n    }\\n    \\n    public TreeNode createBalancedBST(int left, int right) {\\n        if(left > right) {\\n            return null;\\n        }\\n        \\n        int mid = (left + right) / 2;\\n        TreeNode curr = inorder.get(mid);\\n        \\n        curr.left = createBalancedBST(left, mid - 1);\\n        curr.right = createBalancedBST(mid + 1, right);\\n        \\n        return curr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091065,
                "title": "dsw-algorithm-o-n-o-1-c-explained",
                "content": "**Approach**:  The algorithm used in this scenario is the Day-Stout-Warren algorithm. The balanced tree formed will be a complete binary tree. Follow the steps below for the implementation of the algorithm.\\n\\n**Step 1**: Convert the given BST into a linked list ( right-sided linked list ) using the concept of right rotations by means of inorder traversal. This form of BST is known as backbone or vine. the Runtime of this phase is linear and no extra space is required. \\nThe function is coded in such a way that it does all the required right rotation to flatten the BST and at the end returns the number of nodes in BST.\\n\\n**Step 2:**  Calculate the height of BST in which all the levels will be completely filled using the formula h = log2(N+1) [N is the total number of nodes]. And using the height calculate the number of nodes that can be fitted in that height m = pow(2, h)-1. [h is height till which all the levels are fully filled with nodes]\\nThe difference (diff) of N and m is the amount of nodes that will be there in last level of balanced complete binary tree.\\nThe vine obtained in the first step is then left rotated diff amount of time from its root. The above modified tree is then left rotated m/2, m/4, m/8 . . . times until m is greater than 0 according to the algorithm.\\n**Illustrations:**\\n\\n**Illustration-1:** Here the given tree is a left skewed BST\\n![image](https://assets.leetcode.com/users/images/e9b46040-fbd2-4f83-ac72-093417ad432e_1653807803.6961153.png)\\n\\n                             \\n\\n**Illustration-2:** Here it is a non-skewed but unbalanced BST\\n![image](https://assets.leetcode.com/users/images/3e37188f-4912-48a2-9b12-ab1a66c8f8a4_1653920334.9465852.png)\\n\\n\\n\\n\\n                                                   Example-2\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\nsource- gfg\\n```\\n/ C++ code to balance BST using DSW algorithm.\\n// Function to convert input BST\\n// to right linked list\\n// known as vine or backbone.\\nint bstToVine(TreeNode* grand)\\n{\\n    int count = 0;\\n \\n    // Make tmp pointer to traverse\\n    // and right flatten the given BST.\\n    TreeNode* tmp = grand->right;\\n \\n    // Traverse until tmp becomes NULL\\n    while (tmp) {\\n         \\n        // If left exist for node\\n        // pointed by tmp then\\n        // right rotate it.\\n        if (tmp->left) {\\n            TreeNode* oldTmp = tmp;\\n            tmp = tmp->left;\\n            oldTmp->left = tmp->right;\\n            tmp->right = oldTmp;\\n            grand->right = tmp;\\n        }\\n \\n        // If left dont exists\\n        // add 1 to count and\\n        // traverse further right to\\n        // flatten remaining BST.\\n        else {\\n            count++;\\n            grand = tmp;\\n            tmp = tmp->right;\\n        }\\n    }\\n \\n    return count;\\n}\\n \\n// Function to compress given tree\\n// with its root as grand->right.\\nvoid compress(TreeNode* grand, int m)\\n{\\n    // Make tmp pointer to traverse\\n    // and compress the given BST.\\n    TreeNode* tmp = grand->right;\\n \\n    // Traverse and left-rotate root m times\\n    // to compress given vine form of BST.\\n    for (int i = 0; i < m; i++) {\\n        TreeNode* oldTmp = tmp;\\n        tmp = tmp->right;\\n        grand->right = tmp;\\n        oldTmp->right = tmp->left;\\n        tmp->left = oldTmp;\\n        grand = tmp;\\n        tmp = tmp->right;\\n    }\\n}\\n \\n// Function to implement the algorithm\\nTreeNode* balanceBST(TreeNode* root)\\n{\\n    // create dummy node with value 0\\n    TreeNode* grand = new TreeNode(0);\\n \\n    // assign the right of dummy node as our input BST\\n    grand->right = root;\\n \\n    // get the number of nodes in input BST and\\n    // simultaneously convert it into right linked list.\\n    int count = bstToVine(grand);\\n \\n    // gets the height of tree in which all levels\\n    // are completely filled.\\n    int h = log2(count + 1);\\n \\n    // get number of nodes until second last level\\n    int m = pow(2, h) - 1;\\n \\n    // Left rotate for excess nodes at last level\\n    compress(grand, count - m);\\n \\n    // Left rotation till m becomes 0\\n    // Step is done as mentioned in algo to\\n    // make BST balanced.\\n    for (m = m / 2; m > 0; m /= 2) {\\n        compress(grand, m);\\n    }\\n \\n    // return the balanced tree\\n    return grand->right;\\n}\\n \\n\\n```\\n\\n**Please Upvote if you find it helpful ....**\\n",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n/ C++ code to balance BST using DSW algorithm.\\n// Function to convert input BST\\n// to right linked list\\n// known as vine or backbone.\\nint bstToVine(TreeNode* grand)\\n{\\n    int count = 0;\\n \\n    // Make tmp pointer to traverse\\n    // and right flatten the given BST.\\n    TreeNode* tmp = grand->right;\\n \\n    // Traverse until tmp becomes NULL\\n    while (tmp) {\\n         \\n        // If left exist for node\\n        // pointed by tmp then\\n        // right rotate it.\\n        if (tmp->left) {\\n            TreeNode* oldTmp = tmp;\\n            tmp = tmp->left;\\n            oldTmp->left = tmp->right;\\n            tmp->right = oldTmp;\\n            grand->right = tmp;\\n        }\\n \\n        // If left dont exists\\n        // add 1 to count and\\n        // traverse further right to\\n        // flatten remaining BST.\\n        else {\\n            count++;\\n            grand = tmp;\\n            tmp = tmp->right;\\n        }\\n    }\\n \\n    return count;\\n}\\n \\n// Function to compress given tree\\n// with its root as grand->right.\\nvoid compress(TreeNode* grand, int m)\\n{\\n    // Make tmp pointer to traverse\\n    // and compress the given BST.\\n    TreeNode* tmp = grand->right;\\n \\n    // Traverse and left-rotate root m times\\n    // to compress given vine form of BST.\\n    for (int i = 0; i < m; i++) {\\n        TreeNode* oldTmp = tmp;\\n        tmp = tmp->right;\\n        grand->right = tmp;\\n        oldTmp->right = tmp->left;\\n        tmp->left = oldTmp;\\n        grand = tmp;\\n        tmp = tmp->right;\\n    }\\n}\\n \\n// Function to implement the algorithm\\nTreeNode* balanceBST(TreeNode* root)\\n{\\n    // create dummy node with value 0\\n    TreeNode* grand = new TreeNode(0);\\n \\n    // assign the right of dummy node as our input BST\\n    grand->right = root;\\n \\n    // get the number of nodes in input BST and\\n    // simultaneously convert it into right linked list.\\n    int count = bstToVine(grand);\\n \\n    // gets the height of tree in which all levels\\n    // are completely filled.\\n    int h = log2(count + 1);\\n \\n    // get number of nodes until second last level\\n    int m = pow(2, h) - 1;\\n \\n    // Left rotate for excess nodes at last level\\n    compress(grand, count - m);\\n \\n    // Left rotation till m becomes 0\\n    // Step is done as mentioned in algo to\\n    // make BST balanced.\\n    for (m = m / 2; m > 0; m /= 2) {\\n        compress(grand, m);\\n    }\\n \\n    // return the balanced tree\\n    return grand->right;\\n}\\n \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1755619,
                "title": "c-inorder-sorted-array-bst",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> in_order;\\n    void inorder(TreeNode* root){\\n        if(root == NULL) return ;\\n        \\n        inorder(root->left);\\n        in_order.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    \\n    TreeNode* res(int l, int r){\\n       \\n        if(l>r) return NULL;\\n        int mid = l + (r - l) / 2;\\n        TreeNode* head = new TreeNode(in_order[mid]);\\n        head -> right = res(mid + 1, r);\\n        head -> left = res(l, mid - 1);\\n        \\n        return head;\\n    \\n    }  \\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n         \\n        inorder(root);\\n        \\n        return res(0, in_order.size()-1);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> in_order;\\n    void inorder(TreeNode* root){\\n        if(root == NULL) return ;\\n        \\n        inorder(root->left);\\n        in_order.push_back(root->val);\\n        inorder(root->right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1751435,
                "title": "c-solution",
                "content": "```\\n    TreeNode* balanceBST(TreeNode* root) {\\n        // first, do a inorder traverse of the tree, and put values into a vector\\n        // the values in the vector should be in incresing order\\n        // then construct the balance BST with the vector\\n        vector<TreeNode*> treeVec;\\n        generateVec(root, treeVec);\\n        return generateBST(treeVec, 0, treeVec.size() - 1);\\n    }\\n    \\n    void generateVec(TreeNode* node, vector<TreeNode*>& res) {\\n        if (node->left != NULL) {\\n            generateVec(node->left, res);\\n        }\\n        res.push_back(node);\\n        if (node->right != NULL) {\\n            generateVec(node->right, res);\\n        }\\n    }\\n    \\n    // we choose the middle value as the root, so that the difference between right and left height would be at most 1\\n    TreeNode* generateBST(vector<TreeNode*>& res, int begin, int end) {\\n        if (begin > end) {\\n            return NULL;\\n        }\\n        int mid = (begin + end) / 2;\\n        TreeNode* root = res[mid];\\n        root->left = generateBST(res, begin, mid - 1);\\n        root->right = generateBST(res, mid + 1, end);\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    TreeNode* balanceBST(TreeNode* root) {\\n        // first, do a inorder traverse of the tree, and put values into a vector\\n        // the values in the vector should be in incresing order\\n        // then construct the balance BST with the vector\\n        vector<TreeNode*> treeVec;\\n        generateVec(root, treeVec);\\n        return generateBST(treeVec, 0, treeVec.size() - 1);\\n    }\\n    \\n    void generateVec(TreeNode* node, vector<TreeNode*>& res) {\\n        if (node->left != NULL) {\\n            generateVec(node->left, res);\\n        }\\n        res.push_back(node);\\n        if (node->right != NULL) {\\n            generateVec(node->right, res);\\n        }\\n    }\\n    \\n    // we choose the middle value as the root, so that the difference between right and left height would be at most 1\\n    TreeNode* generateBST(vector<TreeNode*>& res, int begin, int end) {\\n        if (begin > end) {\\n            return NULL;\\n        }\\n        int mid = (begin + end) / 2;\\n        TreeNode* root = res[mid];\\n        root->left = generateBST(res, begin, mid - 1);\\n        root->right = generateBST(res, mid + 1, end);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1686238,
                "title": "c-inorder-neat-and-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root,vector<int> &v){\\n        if(!root){\\n            return;\\n        }\\n        inOrder(root->left,v);\\n        v.push_back(root->val);\\n        inOrder(root->right,v);\\n    }\\n    \\n    \\n    TreeNode* makeTree(vector<int> &v,int start, int end){\\n        if(start>end) {\\n           return NULL;\\n         }\\n        int mid=start+(end-start)/2;\\n        TreeNode* nn=new TreeNode(v[mid]);\\n        nn->left=makeTree(v,start,mid-1);\\n        nn->right=makeTree(v,mid+1,end);\\n        return nn;\\n    }\\n    \\n    \\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> v;\\n        inOrder(root,v);\\n        TreeNode* ans=makeTree(v,0,v.size()-1);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root,vector<int> &v){\\n        if(!root){\\n            return;\\n        }\\n        inOrder(root->left,v);\\n        v.push_back(root->val);\\n        inOrder(root->right,v);\\n    }\\n    \\n    \\n    TreeNode* makeTree(vector<int> &v,int start, int end){\\n        if(start>end) {\\n           return NULL;\\n         }\\n        int mid=start+(end-start)/2;\\n        TreeNode* nn=new TreeNode(v[mid]);\\n        nn->left=makeTree(v,start,mid-1);\\n        nn->right=makeTree(v,mid+1,end);\\n        return nn;\\n    }\\n    \\n    \\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> v;\\n        inOrder(root,v);\\n        TreeNode* ans=makeTree(v,0,v.size()-1);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649374,
                "title": "simple-javascript-solution-81-88-clean",
                "content": "Runtime: 156 ms, faster than 81.09% of JavaScript online submissions for Balance a Binary Search Tree.\\nMemory Usage: 55.5 MB, less than 88.24% of JavaScript online submissions for Balance a Binary Search Tree.\\n\\n```\\nconst balanceBST = root => {\\n  const nodes = [];\\n\\n  const getNodesArray = node => {\\n    if (!node) return;\\n    getNodesArray(node.left);\\n    nodes.push(node.val);\\n    getNodesArray(node.right);\\n  }\\n  \\n  const getNode = (l, r) => {\\n    const mid = Math.floor((l + r) /2);\\n    return {\\n      val: nodes[mid],\\n      left: l >= mid ? null : getNode(l, mid - 1),\\n      right: r <= mid ? null : getNode(mid + 1, r)\\n    }\\n  }  \\n\\n  getNodesArray(root);  \\n  return getNode(0, nodes.length - 1);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst balanceBST = root => {\\n  const nodes = [];\\n\\n  const getNodesArray = node => {\\n    if (!node) return;\\n    getNodesArray(node.left);\\n    nodes.push(node.val);\\n    getNodesArray(node.right);\\n  }\\n  \\n  const getNode = (l, r) => {\\n    const mid = Math.floor((l + r) /2);\\n    return {\\n      val: nodes[mid],\\n      left: l >= mid ? null : getNode(l, mid - 1),\\n      right: r <= mid ? null : getNode(mid + 1, r)\\n    }\\n  }  \\n\\n  getNodesArray(root);  \\n  return getNode(0, nodes.length - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1590587,
                "title": "c-with-comments-beat-100",
                "content": "Here is the code with some comments, ***feel free to drop a comment! And plz upvote if  it helps.***\\n```\\nclass Solution {\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        // v: where we want to store the TreeNodes in their value order\\n        // construct list using inorder dfs\\n        vector<TreeNode*> v;\\n        dfs(root,v);\\n\\n        // user vector to contruct a balanced tree\\n        auto ans = build_tree(v, 0, v.size() - 1);\\n            \\n        // return tree root node\\n        return ans;\\n    }\\n    \\n    void dfs(TreeNode* root, vector<TreeNode*> &v) {\\n        if (root == nullptr)\\n            return;\\n        dfs(root->left, v);\\n        v.push_back(root);\\n        dfs(root->right, v);\\n    }\\n    \\n    TreeNode* build_tree(const vector<TreeNode*> & v, int left, int right) {\\n        if(left > right) {\\n            return nullptr;\\n        }\\n        int mid = left + (right - left) / 2;\\n        auto root = v[mid];\\n        root-> left = build_tree(v, left, mid - 1);\\n        root-> right = build_tree(v, mid + 1, right);\\n        return root;\\n    }\\n};\\n```\\n***feel free to drop a comment! And plz upvote if  it helps.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        // v: where we want to store the TreeNodes in their value order\\n        // construct list using inorder dfs\\n        vector<TreeNode*> v;\\n        dfs(root,v);\\n\\n        // user vector to contruct a balanced tree\\n        auto ans = build_tree(v, 0, v.size() - 1);\\n            \\n        // return tree root node\\n        return ans;\\n    }\\n    \\n    void dfs(TreeNode* root, vector<TreeNode*> &v) {\\n        if (root == nullptr)\\n            return;\\n        dfs(root->left, v);\\n        v.push_back(root);\\n        dfs(root->right, v);\\n    }\\n    \\n    TreeNode* build_tree(const vector<TreeNode*> & v, int left, int right) {\\n        if(left > right) {\\n            return nullptr;\\n        }\\n        int mid = left + (right - left) / 2;\\n        auto root = v[mid];\\n        root-> left = build_tree(v, left, mid - 1);\\n        root-> right = build_tree(v, mid + 1, right);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570508,
                "title": "readable-c-99-o-n-time-o-logn-space",
                "content": "1.  Convert BST to a doubly linked list.\\n2.  Convert linked list to a perfectly balanced BST.\\n\\nWe do 2 passes on the tree/list, that\\'s O(N) time. The stack takes up O(logN) space due to recursion.\\n\\nMost solutions here that claim O(1) space are incorrect, recursion will always take O(logN) space unless you use something like Morris traversal.\\n\\n```\\npair<TreeNode*, TreeNode*> BSTToSortedLinkedList(TreeNode* t, int& length) {\\n    auto left = t->left ? BSTToSortedLinkedList(t->left, length) : make_pair(t, nullptr);\\n    if (left.second && !left.second->right) {\\n        left.second->right = t;\\n    }\\n    auto right = t->right ? BSTToSortedLinkedList(t->right, length) : make_pair(nullptr, t);\\n    t->left = left.second;\\n    t->right = right.first;\\n    ++length;\\n    return {left.first, right.second};\\n}\\n\\nTreeNode* SortedLinkedListToBST(TreeNode*& head, int lo, int hi) {\\n    if (lo > hi) {\\n        return nullptr;\\n    }\\n    int mid = lo + (hi - lo) / 2;\\n    TreeNode* left = SortedLinkedListToBST(head, lo, mid-1);\\n    TreeNode* root = head;\\n    head = head->right;\\n    root->left = left;\\n    root->right = SortedLinkedListToBST(head, mid+1, hi);\\n    return root;\\n}\\n\\nclass Solution {\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        int length = 0;\\n        TreeNode* head = BSTToSortedLinkedList(root, length).first;\\n        root = SortedLinkedListToBST(head, 0, length-1);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npair<TreeNode*, TreeNode*> BSTToSortedLinkedList(TreeNode* t, int& length) {\\n    auto left = t->left ? BSTToSortedLinkedList(t->left, length) : make_pair(t, nullptr);\\n    if (left.second && !left.second->right) {\\n        left.second->right = t;\\n    }\\n    auto right = t->right ? BSTToSortedLinkedList(t->right, length) : make_pair(nullptr, t);\\n    t->left = left.second;\\n    t->right = right.first;\\n    ++length;\\n    return {left.first, right.second};\\n}\\n\\nTreeNode* SortedLinkedListToBST(TreeNode*& head, int lo, int hi) {\\n    if (lo > hi) {\\n        return nullptr;\\n    }\\n    int mid = lo + (hi - lo) / 2;\\n    TreeNode* left = SortedLinkedListToBST(head, lo, mid-1);\\n    TreeNode* root = head;\\n    head = head->right;\\n    root->left = left;\\n    root->right = SortedLinkedListToBST(head, mid+1, hi);\\n    return root;\\n}\\n\\nclass Solution {\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        int length = 0;\\n        TreeNode* head = BSTToSortedLinkedList(root, length).first;\\n        root = SortedLinkedListToBST(head, 0, length-1);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552927,
                "title": "well-coded-for-beginners-easy-approach",
                "content": "## IDEA :\\n* Traverse Inorder, Since root of BST is given so array formed will be sorted.\\n* Now by Divide and Conquer make new BST which will be balanced.\\n\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        \\n        arr = []\\n        def inorder(root):\\n            if root is None:\\n                return \\n            inorder(root.left)\\n            arr.append(root.val)\\n            inorder(root.right)\\n        \\n        def mbst(i,j,arr):\\n            if i>j:\\n                return None\\n            if i==j:\\n                return TreeNode(arr[i])\\n            \\n            m = (i+j)//2\\n            root = TreeNode(arr[m])\\n            root.left = mbst(i,m-1,arr)\\n            root.right= mbst(m+1,j,arr)\\n            return root\\n        \\n        inorder(root)\\n        i, j = 0, len(arr)-1\\n        return mbst(i,j,arr\\n\\t\\n### Thanks & Upvote if you like the Idea !!\\u270C",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "## IDEA :\\n* Traverse Inorder, Since root of BST is given so array formed will be sorted.\\n* Now by Divide and Conquer make new BST which will be balanced.\\n\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        \\n        arr = []\\n        def inorder(root):\\n            if root is None:\\n                return \\n            inorder(root.left)\\n            arr.append(root.val)\\n            inorder(root.right)\\n        \\n        def mbst(i,j,arr):\\n            if i>j:\\n                return None\\n            if i==j:\\n                return TreeNode(arr[i])\\n            \\n            m = (i+j)//2\\n            root = TreeNode(arr[m])\\n            root.left = mbst(i,m-1,arr)\\n            root.right= mbst(m+1,j,arr)\\n            return root\\n        \\n        inorder(root)\\n        i, j = 0, len(arr)-1\\n        return mbst(i,j,arr\\n\\t\\n### Thanks & Upvote if you like the Idea !!\\u270C",
                "codeTag": "Java"
            },
            {
                "id": 1520065,
                "title": "c-convert-inorder-to-bst-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> io;\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorder(root); //inorder will sort the BST by left, root, right order which is nearly a sorted array.\\n        return build(0, io.size() - 1);\\n    }\\n    \\n    TreeNode* build(int start, int end) {\\n        if(start > end)\\n            return NULL;\\n        int mid = start + (end - start) / 2;\\n        TreeNode *root = io[mid];\\n        root->left = build(start, mid - 1);\\n        root->right = build(mid + 1, end);\\n        return root;\\n    }\\n    \\n    void inorder(TreeNode* root) {\\n        if(!root)\\n            return;\\n        inorder(root->left);\\n        io.push_back(root);\\n        inorder(root->right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> io;\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorder(root); //inorder will sort the BST by left, root, right order which is nearly a sorted array.\\n        return build(0, io.size() - 1);\\n    }\\n    \\n    TreeNode* build(int start, int end) {\\n        if(start > end)\\n            return NULL;\\n        int mid = start + (end - start) / 2;\\n        TreeNode *root = io[mid];\\n        root->left = build(start, mid - 1);\\n        root->right = build(mid + 1, end);\\n        return root;\\n    }\\n    \\n    void inorder(TreeNode* root) {\\n        if(!root)\\n            return;\\n        inorder(root->left);\\n        io.push_back(root);\\n        inorder(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1483940,
                "title": "clean-code-python3-recursive-0-n",
                "content": "```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        def binaryTraverse(arr, left, right):\\n            if left > right:\\n                return None\\n            mid = left + (right - left) // 2\\n            node = TreeNode(arr[mid])\\n            node.left = binaryTraverse(arr, left, mid - 1)\\n            node.right = binaryTraverse(arr, mid + 1, right)\\n            return node\\n        def inorder(root, traverse):\\n            if not root:\\n                return\\n            inorder(root.left, traverse)\\n            traverse.append(root.val)\\n            inorder(root.right, traverse)\\n            return\\n        traversal = []\\n        inorder(root, traversal)\\n        return binaryTraverse(traversal,0, len(traversal) - 1) \\n\\n\\n\\n````",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        def binaryTraverse(arr, left, right):\\n            if left > right:\\n                return None\\n            mid = left + (right - left) // 2\\n            node = TreeNode(arr[mid])\\n            node.left = binaryTraverse(arr, left, mid - 1)\\n            node.right = binaryTraverse(arr, mid + 1, right)\\n            return node\\n        def inorder(root, traverse):\\n            if not root:\\n                return\\n            inorder(root.left, traverse)\\n            traverse.append(root.val)\\n            inorder(root.right, traverse)\\n            return\\n        traversal = []\\n        inorder(root, traversal)\\n        return binaryTraverse(traversal,0, len(traversal) - 1) \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411614,
                "title": "simple-java-2ms-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<TreeNode> pq = new ArrayList<>();\\n    public void inorder(TreeNode root)\\n    {\\n        if(root == null)\\n            return;\\n        inorder(root.left);\\n        pq.add(root);\\n        inorder(root.right);\\n    }\\n    public TreeNode helper(int start,int end)\\n    {\\n        if (start > end) return null;\\n        int mid = (start + end) / 2;\\n        TreeNode root = pq.get(mid);\\n        root.left = helper(start, mid - 1);\\n        root.right = helper(mid + 1, end);\\n        return root;\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        inorder(root);\\n        int start = 0;\\n        int end = pq.size()-1;\\n        TreeNode result = helper(start,end);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<TreeNode> pq = new ArrayList<>();\\n    public void inorder(TreeNode root)\\n    {\\n        if(root == null)\\n            return;\\n        inorder(root.left);\\n        pq.add(root);\\n        inorder(root.right);\\n    }\\n    public TreeNode helper(int start,int end)\\n    {\\n        if (start > end) return null;\\n        int mid = (start + end) / 2;\\n        TreeNode root = pq.get(mid);\\n        root.left = helper(start, mid - 1);\\n        root.right = helper(mid + 1, end);\\n        return root;\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        inorder(root);\\n        int start = 0;\\n        int end = pq.size()-1;\\n        TreeNode result = helper(start,end);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357917,
                "title": "leetcode-discuss-hints-coded-as-solution",
                "content": "```\\nIf you find this helpful, please upvote\\n```\\n```\\nclass Solution {\\npublic:\\n//Inorder Traversal of the tree \\n    void helper(TreeNode* root,vector<int>& inorder)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        helper(root->left,inorder);\\n        inorder.push_back(root->val);\\n        helper(root->right,inorder);\\n    }\\n\\t//Take the start and index and the array which has the inorder traveral \\n    TreeNode* helper1(int s,int e,vector<int>& inorder)\\n    {\\n        if(s>e)\\n        {\\n            return NULL;\\n        }\\n\\t\\t//middle is start + end divided by 2 and we do this recursively \\n        int mid=(s+e)/2;\\n        TreeNode* root=new TreeNode(inorder[mid]);\\n        root->left=helper1(s,mid-1,inorder);\\n        root->right=helper1(mid+1,e,inorder);\\n        return root;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n    vector<int> inorder;\\n    helper(root,inorder);\\n        int s=0;\\n        int e=inorder.size()-1;\\n        int n=inorder.size()/2;\\n        return helper1(s,e,inorder);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nIf you find this helpful, please upvote\\n```\n```\\nclass Solution {\\npublic:\\n//Inorder Traversal of the tree \\n    void helper(TreeNode* root,vector<int>& inorder)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        helper(root->left,inorder);\\n        inorder.push_back(root->val);\\n        helper(root->right,inorder);\\n    }\\n\\t//Take the start and index and the array which has the inorder traveral \\n    TreeNode* helper1(int s,int e,vector<int>& inorder)\\n    {\\n        if(s>e)\\n        {\\n            return NULL;\\n        }\\n\\t\\t//middle is start + end divided by 2 and we do this recursively \\n        int mid=(s+e)/2;\\n        TreeNode* root=new TreeNode(inorder[mid]);\\n        root->left=helper1(s,mid-1,inorder);\\n        root->right=helper1(mid+1,e,inorder);\\n        return root;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n    vector<int> inorder;\\n    helper(root,inorder);\\n        int s=0;\\n        int e=inorder.size()-1;\\n        int n=inorder.size()/2;\\n        return helper1(s,e,inorder);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294545,
                "title": "do-it-in-place-o-n-time-no-need-to-create-sorted-array",
                "content": "```\\nTreeNode* balanceBST(TreeNode* root) {\\n        auto* node = root;\\n        int n = 0;\\n        stack<TreeNode*> sk;\\n        TreeNode* prev = nullptr, *head = nullptr;\\n        while (!sk.empty() || node) {\\n            while (node) {\\n                sk.push(node);\\n                node = node->left;\\n            }\\n            node = sk.top();\\n            sk.pop();\\n            if (prev) {\\n                prev->right = node;\\n            } else {\\n                head = node;\\n            }\\n            n++;\\n            node->left = nullptr;\\n            prev = node;\\n            node = node->right;\\n        }\\n        return helper(head, n);\\n    }\\n    \\n    TreeNode* helper(TreeNode*& node, int n) {\\n        if (n == 0) return nullptr;        \\n        node->left = helper(node, n/2);\\n        auto* root = node;\\n        node = node->right;\\n        root->right = helper(node, n-n/2-1);\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nTreeNode* balanceBST(TreeNode* root) {\\n        auto* node = root;\\n        int n = 0;\\n        stack<TreeNode*> sk;\\n        TreeNode* prev = nullptr, *head = nullptr;\\n        while (!sk.empty() || node) {\\n            while (node) {\\n                sk.push(node);\\n                node = node->left;\\n            }\\n            node = sk.top();\\n            sk.pop();\\n            if (prev) {\\n                prev->right = node;\\n            } else {\\n                head = node;\\n            }\\n            n++;\\n            node->left = nullptr;\\n            prev = node;\\n            node = node->right;\\n        }\\n        return helper(head, n);\\n    }\\n    \\n    TreeNode* helper(TreeNode*& node, int n) {\\n        if (n == 0) return nullptr;        \\n        node->left = helper(node, n/2);\\n        auto* root = node;\\n        node = node->right;\\n        root->right = helper(node, n-n/2-1);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1273037,
                "title": "java-iterative-inordertraversal-sortedarraytobst",
                "content": "```\\npublic TreeNode balanceBST(TreeNode root) {\\n    \\n    if(root==null) return null;\\n        \\n    List<Integer> list = getInorder(root);\\n    \\n    \\n    return sortedArrayToBalancedBst(list,0,list.size()-1);\\n        \\n    }\\n    \\n    public TreeNode sortedArrayToBalancedBst(List<Integer> list, int start, int end){\\n        if(list.size()==0 || start>end) return null;\\n        \\n        int mid = start + (end-start)/2;\\n        \\n        TreeNode root = new TreeNode(list.get(mid));\\n        root.left = sortedArrayToBalancedBst(list,start,mid-1);\\n        root.right = sortedArrayToBalancedBst(list,mid+1,end);\\n        return root;\\n    }\\n    \\n    public List<Integer> getInorder(TreeNode root){\\n        List<Integer> list = new ArrayList<>();\\n        if(root==null) return list;\\n        \\n        Stack<TreeNode> s = new Stack<>();\\n        \\n        while(true){\\n           if(root!=null){\\n               s.push(root);\\n               root=root.left;\\n           }else{\\n               if(s.isEmpty()) break;\\n               root = s.pop();\\n               list.add(root.val);\\n               root=root.right;\\n           }\\n        }\\n        return list;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic TreeNode balanceBST(TreeNode root) {\\n    \\n    if(root==null) return null;\\n        \\n    List<Integer> list = getInorder(root);\\n    \\n    \\n    return sortedArrayToBalancedBst(list,0,list.size()-1);\\n        \\n    }\\n    \\n    public TreeNode sortedArrayToBalancedBst(List<Integer> list, int start, int end){\\n        if(list.size()==0 || start>end) return null;\\n        \\n        int mid = start + (end-start)/2;\\n        \\n        TreeNode root = new TreeNode(list.get(mid));\\n        root.left = sortedArrayToBalancedBst(list,start,mid-1);\\n        root.right = sortedArrayToBalancedBst(list,mid+1,end);\\n        return root;\\n    }\\n    \\n    public List<Integer> getInorder(TreeNode root){\\n        List<Integer> list = new ArrayList<>();\\n        if(root==null) return list;\\n        \\n        Stack<TreeNode> s = new Stack<>();\\n        \\n        while(true){\\n           if(root!=null){\\n               s.push(root);\\n               root=root.left;\\n           }else{\\n               if(s.isEmpty()) break;\\n               root = s.pop();\\n               list.add(root.val);\\n               root=root.right;\\n           }\\n        }\\n        return list;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1206221,
                "title": "c-99-faster-simple-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void bst2array(TreeNode* root, vector<TreeNode*>& nodes)\\n    {\\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        bst2array(root->left,nodes);\\n        nodes.push_back(root);\\n        bst2array(root->right,nodes);\\n    }\\n    \\n    TreeNode* array2bst(vector<TreeNode*>& nodes, int start, int end)\\n    {\\n        if(start > end)\\n            return NULL;\\n        \\n        int mid = start + (end-start)/2;\\n        TreeNode* root = nodes[mid];\\n        root->left = array2bst(nodes,start,mid-1);\\n        root->right = array2bst(nodes,mid+1,end);\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> nodes;\\n        bst2array(root,nodes);\\n        \\n        int n = nodes.size();\\n        return array2bst(nodes,0,n-1);\\n        \\n    }\\n};\\n\\t\\t```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void bst2array(TreeNode* root, vector<TreeNode*>& nodes)\\n    {\\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        bst2array(root->left,nodes);\\n        nodes.push_back(root);\\n        bst2array(root->right,nodes);\\n    }\\n    \\n    TreeNode* array2bst(vector<TreeNode*>& nodes, int start, int end)\\n    {\\n        if(start > end)\\n            return NULL;\\n        \\n        int mid = start + (end-start)/2;\\n        TreeNode* root = nodes[mid];\\n        root->left = array2bst(nodes,start,mid-1);\\n        root->right = array2bst(nodes,mid+1,end);\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> nodes;\\n        bst2array(root,nodes);\\n        \\n        int n = nodes.size();\\n        return array2bst(nodes,0,n-1);\\n        \\n    }\\n};\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1100893,
                "title": "javascript-balance-using-avl-tree-rotation",
                "content": "```javascript\\nfunction balanceBST(root) {\\n    \\n    function rightRotate(node) {\\n        const mid = node.left;\\n        node.left = mid.right;\\n        mid.right = node;\\n        return mid;\\n    }\\n    \\n    function leftRotate(node) {\\n        const mid = node.right;\\n        node.right = mid.left;\\n        mid.left = node;\\n        return mid;\\n    }\\n    \\n    function getHeight(node) {\\n        if(!node) return 0\\n        return Math.max(getHeight(node.left), getHeight(node.right)) + 1\\n    }\\n    \\n    function recurse(node) {\\n        if(!node) return null;\\n        \\n        node.left = recurse(node.left);\\n        node.right = recurse(node.right);\\n        \\n        const leftHeight = getHeight(node.left);\\n        const rightHeight = getHeight(node.right);\\n        \\n        if(Math.abs(leftHeight - rightHeight) <= 1) return node\\n        \\n        if(leftHeight > rightHeight) {\\n            \\n            const leftOfLeft = getHeight(node.left.left);\\n            const rightOfLeft = getHeight(node.left.right);\\n            \\n            if(rightOfLeft > leftOfLeft) {\\n                node.left = leftRotate(node.left);\\n            }\\n            node = rightRotate(node);\\n        } else if(rightHeight > leftHeight) {\\n            \\n            const leftOfRight = getHeight(node.right.left);\\n            const rightOfRight = getHeight(node.right.right);\\n            \\n            if(leftOfRight > rightOfRight) {\\n                node.right = rightRotate(node.right);\\n            }\\n            node = leftRotate(node);\\n        }\\n        return recurse(node);\\n    }\\n    \\n    return recurse(root)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nfunction balanceBST(root) {\\n    \\n    function rightRotate(node) {\\n        const mid = node.left;\\n        node.left = mid.right;\\n        mid.right = node;\\n        return mid;\\n    }\\n    \\n    function leftRotate(node) {\\n        const mid = node.right;\\n        node.right = mid.left;\\n        mid.left = node;\\n        return mid;\\n    }\\n    \\n    function getHeight(node) {\\n        if(!node) return 0\\n        return Math.max(getHeight(node.left), getHeight(node.right)) + 1\\n    }\\n    \\n    function recurse(node) {\\n        if(!node) return null;\\n        \\n        node.left = recurse(node.left);\\n        node.right = recurse(node.right);\\n        \\n        const leftHeight = getHeight(node.left);\\n        const rightHeight = getHeight(node.right);\\n        \\n        if(Math.abs(leftHeight - rightHeight) <= 1) return node\\n        \\n        if(leftHeight > rightHeight) {\\n            \\n            const leftOfLeft = getHeight(node.left.left);\\n            const rightOfLeft = getHeight(node.left.right);\\n            \\n            if(rightOfLeft > leftOfLeft) {\\n                node.left = leftRotate(node.left);\\n            }\\n            node = rightRotate(node);\\n        } else if(rightHeight > leftHeight) {\\n            \\n            const leftOfRight = getHeight(node.right.left);\\n            const rightOfRight = getHeight(node.right.right);\\n            \\n            if(leftOfRight > rightOfRight) {\\n                node.right = rightRotate(node.right);\\n            }\\n            node = leftRotate(node);\\n        }\\n        return recurse(node);\\n    }\\n    \\n    return recurse(root)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 870600,
                "title": "java-100",
                "content": "class Solution {\\n\\n    List<TreeNode> list=new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n        if(root ==null)\\n            return null;\\n        inOrder(root);\\n        return balanced(0,list.size()-1);\\n    }\\n    \\n    void inOrder(TreeNode root){\\n        if(root==null)\\n            return;\\n        inOrder(root.left);\\n        list.add(root);\\n        inOrder(root.right);\\n    }\\n    \\n    TreeNode balanced(int start, int end){\\n        if(start>end)\\n            return null;\\n        int mid=start +(end-start)/2;\\n        TreeNode node=list.get(mid);\\n        node.left=balanced(start,mid-1);\\n        node.right=balanced(mid+1,end);\\n        return node;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    List<TreeNode> list=new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n        if(root ==null)\\n            return null;\\n        inOrder(root);\\n        return balanced(0,list.size()-1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 728466,
                "title": "java-clean-code-inorder-traversal-and-construct-tree-2-ms-time-92-faster",
                "content": "```\\nclass Solution {\\n \\n\\tprivate void inorderTraversal (TreeNode root, List<Integer> inorderList) {\\n\\t\\t\\n\\t\\tif (root != null) {\\n\\t\\t\\tinorderTraversal (root.left, inorderList);\\n\\t\\t\\tinorderList.add (root.val);\\n\\t\\t\\tinorderTraversal (root.right, inorderList);\\n\\t\\t}\\n\\t}\\n \\n\\tprivate TreeNode constructBinarySearchTree (List<Integer> inorderList, int start, int end) {\\n\\t\\n\\t\\tif (start > end) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint mid = (start + end) / 2;\\n\\t\\tTreeNode root = new TreeNode (inorderList.get (mid));\\n        \\n\\t\\troot.left = constructBinarySearchTree (inorderList, start, mid - 1);\\n\\t\\troot.right = constructBinarySearchTree (inorderList, mid + 1, end);\\n        \\n\\t\\treturn root;\\n\\t}\\n \\n\\tpublic TreeNode balanceBST (TreeNode root) {\\n\\t\\t\\n\\t\\tif (root == null) {\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t\\t\\n\\t\\tList<Integer> inorderList = new ArrayList <>();\\n\\t\\tinorderTraversal (root, inorderList);\\n \\n\\t\\treturn constructBinarySearchTree (inorderList, 0, inorderList.size () - 1);\\n\\t}\\n}\\n\\nTime Complexity: O(N)\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n \\n\\tprivate void inorderTraversal (TreeNode root, List<Integer> inorderList) {\\n\\t\\t\\n\\t\\tif (root != null) {\\n\\t\\t\\tinorderTraversal (root.left, inorderList);\\n\\t\\t\\tinorderList.add (root.val);\\n\\t\\t\\tinorderTraversal (root.right, inorderList);\\n\\t\\t}\\n\\t}\\n \\n\\tprivate TreeNode constructBinarySearchTree (List<Integer> inorderList, int start, int end) {\\n\\t\\n\\t\\tif (start > end) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint mid = (start + end) / 2;\\n\\t\\tTreeNode root = new TreeNode (inorderList.get (mid));\\n        \\n\\t\\troot.left = constructBinarySearchTree (inorderList, start, mid - 1);\\n\\t\\troot.right = constructBinarySearchTree (inorderList, mid + 1, end);\\n        \\n\\t\\treturn root;\\n\\t}\\n \\n\\tpublic TreeNode balanceBST (TreeNode root) {\\n\\t\\t\\n\\t\\tif (root == null) {\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t\\t\\n\\t\\tList<Integer> inorderList = new ArrayList <>();\\n\\t\\tinorderTraversal (root, inorderList);\\n \\n\\t\\treturn constructBinarySearchTree (inorderList, 0, inorderList.size () - 1);\\n\\t}\\n}\\n\\nTime Complexity: O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727132,
                "title": "simple-c-solution-using-inorder-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    unordered_map<int,int> m;\\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n        \\n        return;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        if(!root)\\n            return NULL;\\n       inorder(root);\\n       for(auto i=0;i<v.size();i++)\\n           m[v[i]]=i;\\n        \\n       return buildBST (v, 0,v.size()-1);\\n    }\\n    TreeNode* buildBST(vector<int> v, int strt, int end){\\n        \\n        if(strt>end)\\n            return NULL;\\n        int mid= (strt+end)/2;\\n        TreeNode* node = new TreeNode(v[mid]);\\n        if(strt==end)\\n            return node;\\n        \\n        node->left=buildBST(v,strt,mid-1);\\n        node->right=buildBST(v,mid+1,end);\\n        \\n        return node;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    unordered_map<int,int> m;\\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n        \\n        return;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        if(!root)\\n            return NULL;\\n       inorder(root);\\n       for(auto i=0;i<v.size();i++)\\n           m[v[i]]=i;\\n        \\n       return buildBST (v, 0,v.size()-1);\\n    }\\n    TreeNode* buildBST(vector<int> v, int strt, int end){\\n        \\n        if(strt>end)\\n            return NULL;\\n        int mid= (strt+end)/2;\\n        TreeNode* node = new TreeNode(v[mid]);\\n        if(strt==end)\\n            return node;\\n        \\n        node->left=buildBST(v,strt,mid-1);\\n        node->right=buildBST(v,mid+1,end);\\n        \\n        return node;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721154,
                "title": "c-easy-to-understand-solution",
                "content": "1) count the nodes\\n2) create array to store nodes of tree\\n3) convert into balance bst by dividing into two halves\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nvoid node(struct TreeNode* root, int *count) {\\n    \\n    if(root == NULL)\\n        return;\\n    \\n    node(root->left,count);\\n    (*count)++;\\n    node(root->right,count);\\n    \\n}\\n//create arr\\nvoid create(struct TreeNode *root, struct TreeNode **arr, int *k) {\\n    \\n    \\n    if(root == NULL)\\n        return;\\n    \\n    create(root->left,arr,k);\\n    \\n    arr[(*k)++] = root;\\n    create(root->right,arr,k);\\n}\\n\\n//convert to balance tree\\nstruct TreeNode* help(struct TreeNode **arr, int low, int high) {\\n    struct TreeNode *temp;\\n    if(low > high)\\n        return NULL;\\n    int mid = (low+high)/2;    \\n    \\n    temp = arr[mid];\\n    temp->left = help(arr,low,mid-1);\\n    temp->right = help(arr,mid+1,high);\\n    \\n    return temp;\\n    \\n}\\n\\nstruct TreeNode* balanceBST(struct TreeNode* root){\\n    \\n    int count=0;\\n    int k=0;\\n    struct TreeNode **arr;\\n    \\n    //count no of nodes\\n    node(root, &count);\\n\\n    //create arr of binary search tree\\n    arr = (struct TreeNode **)malloc(sizeof(struct TreeNode*) * count);\\n    create(root, arr, &k) ;  \\n    \\n    //conver\\n    root = help(arr,0,count-1);\\n    free(arr);\\n    return root;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nvoid node(struct TreeNode* root, int *count) {\\n    \\n    if(root == NULL)\\n        return;\\n    \\n    node(root->left,count);\\n    (*count)++;\\n    node(root->right,count);\\n    \\n}\\n//create arr\\nvoid create(struct TreeNode *root, struct TreeNode **arr, int *k) {\\n    \\n    \\n    if(root == NULL)\\n        return;\\n    \\n    create(root->left,arr,k);\\n    \\n    arr[(*k)++] = root;\\n    create(root->right,arr,k);\\n}\\n\\n//convert to balance tree\\nstruct TreeNode* help(struct TreeNode **arr, int low, int high) {\\n    struct TreeNode *temp;\\n    if(low > high)\\n        return NULL;\\n    int mid = (low+high)/2;    \\n    \\n    temp = arr[mid];\\n    temp->left = help(arr,low,mid-1);\\n    temp->right = help(arr,mid+1,high);\\n    \\n    return temp;\\n    \\n}\\n\\nstruct TreeNode* balanceBST(struct TreeNode* root){\\n    \\n    int count=0;\\n    int k=0;\\n    struct TreeNode **arr;\\n    \\n    //count no of nodes\\n    node(root, &count);\\n\\n    //create arr of binary search tree\\n    arr = (struct TreeNode **)malloc(sizeof(struct TreeNode*) * count);\\n    create(root, arr, &k) ;  \\n    \\n    //conver\\n    root = help(arr,0,count-1);\\n    free(arr);\\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 693606,
                "title": "c-very-naive-solution",
                "content": "- inorder a BST can retrieve a sorted array.\\n- rebuild the BST and make sure the middle of the sorted arry is the root. this can help the tree is always balanced.\\n- recusion.\\n```\\npublic class Solution {\\n    List<TreeNode> list = new List<TreeNode>();\\n    \\n    public TreeNode BalanceBST(TreeNode root) {\\n        if (root == null || root.left == null && root.right == null)\\n            return root;\\n        \\n        DFS(root);\\n        \\n        return Rebuild(0, list.Count - 1);\\n    }\\n    \\n    private void DFS(TreeNode node)\\n    {\\n        if (node == null)\\n            return;\\n        \\n        DFS(node.left);\\n        list.Add(node);\\n        DFS(node.right);\\n    }\\n    \\n    private TreeNode Rebuild(int i, int j)\\n    {\\n        if (i > j)\\n            return null;\\n        \\n        TreeNode root = new TreeNode();\\n        \\n        if (i == j)\\n            root.val = list[i].val;\\n        else\\n        {\\n            int mid = j + (i - j) / 2;\\n            \\n            root.val = list[mid].val;\\n            root.left = Rebuild(i, mid - 1);\\n            root.right = Rebuild(mid + 1, j);\\n        }\\n        \\n        return root;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    List<TreeNode> list = new List<TreeNode>();\\n    \\n    public TreeNode BalanceBST(TreeNode root) {\\n        if (root == null || root.left == null && root.right == null)\\n            return root;\\n        \\n        DFS(root);\\n        \\n        return Rebuild(0, list.Count - 1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 582156,
                "title": "c-solution-avl-tree-like-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution\\n{\\nprivate:\\n    TreeNode* leftRotate(TreeNode *node)\\n    {\\n        auto *pRoot = node->right;\\n        node->right = pRoot->left;\\n        pRoot->left = node;\\n        return pRoot;\\n    }\\n\\n    TreeNode* rightRotate(TreeNode *node)\\n    {\\n        auto *pRoot = node->left;\\n        node->left = pRoot->right;\\n        pRoot->right = node;\\n        return pRoot;\\n    }\\n    \\n    int height(TreeNode *node)\\n    {\\n        auto const left_h = node->left ? height(node->left) : 0;\\n        auto const right_h = node->right ? height(node->right) : 0;\\n        return std::max(left_h, right_h) + 1;\\n    }\\n    \\n    int bfactor(TreeNode *node)\\n    {\\n        return node ? (node->right ? height(node->right) : 0) - (node->left ? height(node->left) : 0) : 0;\\n    }\\n    \\n    TreeNode* balance(TreeNode *node)\\n    {\\n        if (!node)\\n            return nullptr;\\n        node->left = balance(node->left);\\n        node->right = balance(node->right);\\n        auto const bf = bfactor(node);\\n        if (bf >= 2)\\n        {\\n            if (bfactor(node->right) < 0)\\n                node->right = rightRotate(node->right);\\n            return balance(leftRotate(node));\\n        }\\n        else if (bf <= -2)\\n        {\\n            if (bfactor(node->left) > 0)\\n                node->left = leftRotate(node->left);\\n            return balance(rightRotate(node));\\n        }\\n        return node;\\n    }\\n\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        return balance(root);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution\\n{\\nprivate:\\n    TreeNode* leftRotate(TreeNode *node)\\n    {\\n        auto *pRoot = node->right;\\n        node->right = pRoot->left;\\n        pRoot->left = node;\\n        return pRoot;\\n    }\\n\\n    TreeNode* rightRotate(TreeNode *node)\\n    {\\n        auto *pRoot = node->left;\\n        node->left = pRoot->right;\\n        pRoot->right = node;\\n        return pRoot;\\n    }\\n    \\n    int height(TreeNode *node)\\n    {\\n        auto const left_h = node->left ? height(node->left) : 0;\\n        auto const right_h = node->right ? height(node->right) : 0;\\n        return std::max(left_h, right_h) + 1;\\n    }\\n    \\n    int bfactor(TreeNode *node)\\n    {\\n        return node ? (node->right ? height(node->right) : 0) - (node->left ? height(node->left) : 0) : 0;\\n    }\\n    \\n    TreeNode* balance(TreeNode *node)\\n    {\\n        if (!node)\\n            return nullptr;\\n        node->left = balance(node->left);\\n        node->right = balance(node->right);\\n        auto const bf = bfactor(node);\\n        if (bf >= 2)\\n        {\\n            if (bfactor(node->right) < 0)\\n                node->right = rightRotate(node->right);\\n            return balance(leftRotate(node));\\n        }\\n        else if (bf <= -2)\\n        {\\n            if (bfactor(node->left) > 0)\\n                node->left = leftRotate(node->left);\\n            return balance(rightRotate(node));\\n        }\\n        return node;\\n    }\\n\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        return balance(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 553491,
                "title": "go-golang-clean-solution",
                "content": ">Runtime: 944 ms, faster than 83.13% of Go online submissions for Balance a Binary Search Tree.\\nMemory Usage: 275.1 MB, less than 100.00% of Go online submissions for Balance a Binary Search Tree.\\n\\n```go\\nfunc balanceBST(root *TreeNode) *TreeNode {\\n    sorted := []int{}\\n    inorder(root, &sorted)\\n    return helper(sorted)\\n}\\n\\nfunc inorder(node *TreeNode, sorted *[]int) {\\n    if node == nil { return }\\n    inorder(node.Left, sorted)\\n    *sorted = append(*sorted, node.Val)\\n    inorder(node.Right, sorted)\\n}\\n\\nfunc helper(sorted []int) *TreeNode {\\n    if len(sorted) == 0 { return nil }\\n    index := len(sorted) / 2\\n    return &TreeNode{Val: sorted[index], Left: helper(sorted[:index]), Right: helper(sorted[index + 1:])}\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc balanceBST(root *TreeNode) *TreeNode {\\n    sorted := []int{}\\n    inorder(root, &sorted)\\n    return helper(sorted)\\n}\\n\\nfunc inorder(node *TreeNode, sorted *[]int) {\\n    if node == nil { return }\\n    inorder(node.Left, sorted)\\n    *sorted = append(*sorted, node.Val)\\n    inorder(node.Right, sorted)\\n}\\n\\nfunc helper(sorted []int) *TreeNode {\\n    if len(sorted) == 0 { return nil }\\n    index := len(sorted) / 2\\n    return &TreeNode{Val: sorted[index], Left: helper(sorted[:index]), Right: helper(sorted[index + 1:])}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540670,
                "title": "java-solution-pre-construct-in-order-traversal-to-modify-100-time-100-memory-up-to-current",
                "content": "1. count the total number of nodes in the given tree.\\n2. pre construct a binary tree recurisively;\\n3. modify the pre construct binary tree based on in order traversal of the given tree.\\n\\n```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        int count = countNodes(root);\\n        Map<Integer, TreeNode> mapping  = new HashMap<>();\\n        TreeNode newRoot = buildBinaryTree(1, count, mapping);\\n        modifyTreeValue(root, mapping);\\n        return newRoot;\\n    }\\n\\n    private int countNodes(TreeNode root) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        return 1 + countNodes(root.left) + countNodes(root.right);\\n    }\\n\\n    private TreeNode buildBinaryTree(int st, int en, Map<Integer, TreeNode> mapping) {\\n        if(st > en) return null;\\n        int rootVal  = st + (en - st) / 2;\\n        TreeNode root = new TreeNode(rootVal);\\n        root.left = buildBinaryTree(st, rootVal - 1, mapping);\\n        root.right = buildBinaryTree(rootVal + 1, en, mapping);\\n        mapping.put(rootVal, root);\\n        return root;\\n    }\\n\\t\\n    private void modifyTreeValue(TreeNode oldTree, Map<Integer, TreeNode> mapping) {\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode curr = oldTree;\\n        int index = 1;\\n        while(!stack.isEmpty() || curr != null) {\\n            if(curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            } else {\\n                curr = stack.pop();\\n                mapping.get(index).val = curr.val;\\n                curr = curr.right;\\n                ++index;\\n            }\\n        }    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        int count = countNodes(root);\\n        Map<Integer, TreeNode> mapping  = new HashMap<>();\\n        TreeNode newRoot = buildBinaryTree(1, count, mapping);\\n        modifyTreeValue(root, mapping);\\n        return newRoot;\\n    }\\n\\n    private int countNodes(TreeNode root) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        return 1 + countNodes(root.left) + countNodes(root.right);\\n    }\\n\\n    private TreeNode buildBinaryTree(int st, int en, Map<Integer, TreeNode> mapping) {\\n        if(st > en) return null;\\n        int rootVal  = st + (en - st) / 2;\\n        TreeNode root = new TreeNode(rootVal);\\n        root.left = buildBinaryTree(st, rootVal - 1, mapping);\\n        root.right = buildBinaryTree(rootVal + 1, en, mapping);\\n        mapping.put(rootVal, root);\\n        return root;\\n    }\\n\\t\\n    private void modifyTreeValue(TreeNode oldTree, Map<Integer, TreeNode> mapping) {\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode curr = oldTree;\\n        int index = 1;\\n        while(!stack.isEmpty() || curr != null) {\\n            if(curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            } else {\\n                curr = stack.pop();\\n                mapping.get(index).val = curr.val;\\n                curr = curr.right;\\n                ++index;\\n            }\\n        }    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539842,
                "title": "simple-solution-with-explanation",
                "content": "**Explanation:** This problem is acually really simple once you get the idea. Lets take an example first:\\n\\n           30\\n         /\\n       20\\n      /\\n    10\\n\\t\\nWhat we have to return is:\\n\\n        20\\n\\t   /  \\\\\\n\\t  10  30\\n\\t  \\nWe first create an inorder traversal of the tree, and store it into an array. In this case, that array will become ```{10, 20, 30}```, because the inorder traversal is ```{10, 20, 30}```. The root of the tree will be the middle of the inorder traversal, which in this case is ```20```. We recursively call the same method with the left side of the array to get the tree left of the root, and recursively call the right side of the arrray to get the tree to the right of the root. If we take this same example ```10, 20, 30```:\\n\\n```{10, 20, 30}```\\n\\n```20``` is selected as the root. Recursively call the same method with the left side of the array, or ```{10}``` for the left of the root. ```10``` is the midpoint of the array ```{10}```, and ```{10}``` has no left or right, so terminate. Recursively call the same method with the right side of the array, or ```{30}``` to get the right side of ```20```. That assigns ```30``` to the right of ```20```.\\n\\n```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<TreeNode> nodes = new ArrayList<>();\\n        inorder(root, nodes);\\n\\n        int n = nodes.size();\\n        return helper(nodes, 0, n - 1);\\n    }\\n\\n    private void inorder(TreeNode root, ArrayList<TreeNode> nodes) { // Does inorder traversal on root and assigns it to nodes.\\n        if (root == null) {\\n            return;\\n        }\\n\\n        inorder(root.left, nodes);\\n        nodes.add(root);\\n        inorder(root.right, nodes);\\n    }\\n\\n    private TreeNode helper(ArrayList<TreeNode> nodes, int start, int end) {\\n        if (start > end) { // Base case.\\n            return null;\\n        }\\n\\n        int mid = (start + end) / 2;\\n        TreeNode node = nodes.get(mid); // Add the root as the middle of nodes.\\n\\n        node.left = helper(nodes, start, mid - 1); // Recursively call the same method with the left side of the array, and assign it to the left of the root.\\n        node.right = helper(nodes, mid + 1, end); // Recursively call the same method with the right side of the array, and assign it to the right of the root.\\n\\n        return node; // Return the current TreeNode to your previous caller.\\n    }\\n}\\n```\\n\\n**Time Complexity:** O(n)\\nInorder traversal takes O(n) and constructing the tree takes O(n) too. So, the time complexity is just O(n). \\n\\n**Space Complexity:** O(n)\\nYou create a new array size n, so space complexity is O(n).",
                "solutionTags": [
                    "Java"
                ],
                "code": "```{10, 20, 30}```\n```{10, 20, 30}```\n```20```\n```10, 20, 30```\n```{10, 20, 30}```\n```20```\n```{10}```\n```10```\n```{10}```\n```{10}```\n```{30}```\n```20```\n```30```\n```20```\n```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<TreeNode> nodes = new ArrayList<>();\\n        inorder(root, nodes);\\n\\n        int n = nodes.size();\\n        return helper(nodes, 0, n - 1);\\n    }\\n\\n    private void inorder(TreeNode root, ArrayList<TreeNode> nodes) { // Does inorder traversal on root and assigns it to nodes.\\n        if (root == null) {\\n            return;\\n        }\\n\\n        inorder(root.left, nodes);\\n        nodes.add(root);\\n        inorder(root.right, nodes);\\n    }\\n\\n    private TreeNode helper(ArrayList<TreeNode> nodes, int start, int end) {\\n        if (start > end) { // Base case.\\n            return null;\\n        }\\n\\n        int mid = (start + end) / 2;\\n        TreeNode node = nodes.get(mid); // Add the root as the middle of nodes.\\n\\n        node.left = helper(nodes, start, mid - 1); // Recursively call the same method with the left side of the array, and assign it to the left of the root.\\n        node.right = helper(nodes, mid + 1, end); // Recursively call the same method with the right side of the array, and assign it to the right of the root.\\n\\n        return node; // Return the current TreeNode to your previous caller.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539740,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    List<TreeNode> nodes = new List<TreeNode>();\\n    public TreeNode BalanceBST(TreeNode root) \\n    {\\n        Traverse(root);\\n        nodes.Sort((x, y) => x.val.CompareTo(y.val));  \\n        return MakeBBST(nodes, 0, nodes.Count - 1);\\n    }\\n    \\n    private TreeNode MakeBBST(List<TreeNode> nodes, int start, int end)\\n    {\\n        if(start > end) return null;\\n        int mid = (start + end) / 2;\\n        var root = nodes[mid];\\n        root.left = MakeBBST(nodes, start, mid - 1);\\n        root.right = MakeBBST(nodes, mid + 1, end);\\n        return root;\\n    }\\n    \\n    private void Traverse(TreeNode root)\\n    {\\n        if(root == null) return;\\n        nodes.Add(root);\\n        Traverse(root.left);\\n        Traverse(root.right);\\n        root.left = null;\\n        root.right = null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    List<TreeNode> nodes = new List<TreeNode>();\\n    public TreeNode BalanceBST(TreeNode root) \\n    {\\n        Traverse(root);\\n        nodes.Sort((x, y) => x.val.CompareTo(y.val));  \\n        return MakeBBST(nodes, 0, nodes.Count - 1);\\n    }\\n    \\n    private TreeNode MakeBBST(List<TreeNode> nodes, int start, int end)\\n    {\\n        if(start > end) return null;\\n        int mid = (start + end) / 2;\\n        var root = nodes[mid];\\n        root.left = MakeBBST(nodes, start, mid - 1);\\n        root.right = MakeBBST(nodes, mid + 1, end);\\n        return root;\\n    }\\n    \\n    private void Traverse(TreeNode root)\\n    {\\n        if(root == null) return;\\n        nodes.Add(root);\\n        Traverse(root.left);\\n        Traverse(root.right);\\n        root.left = null;\\n        root.right = null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539724,
                "title": "c-generate-from-mid-from-in-order-traversal-array",
                "content": "```csharp\\npublic class Solution\\n{\\n    public TreeNode BalanceBST(TreeNode root)\\n    {\\n        List<int> nums = new List<int>();\\n        inorder(root, nums);\\n                \\n        var result = buildTree(nums, 0, nums.Count - 1);\\n        return result;\\n    }\\n    \\n    private void inorder(TreeNode node, List<int> nums)\\n    {\\n        if(node != null)\\n        {\\n            inorder(node.left, nums);\\n            nums.Add(node.val);\\n            inorder(node.right, nums);\\n        }\\n    }\\n    \\n    private TreeNode buildTree(List<int> nums, int start, int end)\\n    {\\n        if(start > end)\\n        {\\n            return null;\\n        }\\n        \\n        int mid = start + (end - start) / 2;\\n        \\n        TreeNode node = new TreeNode(nums[mid]);        \\n        node.left = buildTree(nums, start, mid - 1);\\n        node.right = buildTree(nums, mid + 1, end);\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution\\n{\\n    public TreeNode BalanceBST(TreeNode root)\\n    {\\n        List<int> nums = new List<int>();\\n        inorder(root, nums);\\n                \\n        var result = buildTree(nums, 0, nums.Count - 1);\\n        return result;\\n    }\\n    \\n    private void inorder(TreeNode node, List<int> nums)\\n    {\\n        if(node != null)\\n        {\\n            inorder(node.left, nums);\\n            nums.Add(node.val);\\n            inorder(node.right, nums);\\n        }\\n    }\\n    \\n    private TreeNode buildTree(List<int> nums, int start, int end)\\n    {\\n        if(start > end)\\n        {\\n            return null;\\n        }\\n        \\n        int mid = start + (end - start) / 2;\\n        \\n        TreeNode node = new TreeNode(nums[mid]);        \\n        node.left = buildTree(nums, start, mid - 1);\\n        node.right = buildTree(nums, mid + 1, end);\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539708,
                "title": "c-in-order-traversal-and-build-the-balanced-tree",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n    TreeNode* build(const vector<int>& vals, int left, int right) {\\n        if (left >= right) return nullptr;\\n        TreeNode* tn = new TreeNode(vals[(left + right) / 2]);\\n        tn->left = build(vals, left, (left + right) / 2);\\n        tn->right = build(vals, (left + right) / 2 + 1, right);\\n        return tn;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> vals;\\n        function<void(TreeNode*)> inorder = [&](TreeNode* tn) {\\n            if (!tn) return;\\n            inorder(tn->left);\\n            vals.push_back(tn->val);\\n            inorder(tn->right);\\n        };\\n        inorder(root);\\n        return build(vals, 0, vals.size());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n    TreeNode* build(const vector<int>& vals, int left, int right) {\\n        if (left >= right) return nullptr;\\n        TreeNode* tn = new TreeNode(vals[(left + right) / 2]);\\n        tn->left = build(vals, left, (left + right) / 2);\\n        tn->right = build(vals, (left + right) / 2 + 1, right);\\n        return tn;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> vals;\\n        function<void(TreeNode*)> inorder = [&](TreeNode* tn) {\\n            if (!tn) return;\\n            inorder(tn->left);\\n            vals.push_back(tn->val);\\n            inorder(tn->right);\\n        };\\n        inorder(root);\\n        return build(vals, 0, vals.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442020,
                "title": "c-solution-very-simple",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root,vector<int>&v) {\\n        if(root==NULL)\\n        return;\\n\\n        inorderTraversal(root->left,v);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right,v);\\n        return;\\n    }\\n\\n    TreeNode* build(int i,int j,vector<int>&v){\\n        if(i>j) return NULL;\\n        int mid=(i+j)/2;\\n         TreeNode*newNode=new TreeNode(v[mid]);\\n         newNode->left=build(i,mid-1,v);\\n         newNode->right=build(mid+1,j,v);\\n         return newNode;\\n    }\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int>v;\\n         inorderTraversal(root,v);\\n        int i=0,j=v.size()-1;\\n\\n        return build(0,j,v);\\n    }\\n};\\n```\\nUpvote if you like the solution",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root,vector<int>&v) {\\n        if(root==NULL)\\n        return;\\n\\n        inorderTraversal(root->left,v);\\n        v.push_back(root->val);\\n        inorderTraversal(root->right,v);\\n        return;\\n    }\\n\\n    TreeNode* build(int i,int j,vector<int>&v){\\n        if(i>j) return NULL;\\n        int mid=(i+j)/2;\\n         TreeNode*newNode=new TreeNode(v[mid]);\\n         newNode->left=build(i,mid-1,v);\\n         newNode->right=build(mid+1,j,v);\\n         return newNode;\\n    }\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int>v;\\n         inorderTraversal(root,v);\\n        int i=0,j=v.size()-1;\\n\\n        return build(0,j,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389353,
                "title": "java-solution-using-simple-approach-of-inorder-traversal-and-binary-search",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void traversal(TreeNode root, List<Integer> list) {\\n       \\n        // Return if the current node is null\\n        //base case\\n        if(root == null) return;\\n        // Recursively traverse the left and right subtrees\\n        traversal(root.left,list);\\n        // Add the current node\\'s value to the result list\\n        list.add(root.val);\\n        traversal(root.right, list);\\n   }\\n   public TreeNode balance(ArrayList<Integer> nums, int start, int end){\\n       if(start>end){\\n           return null;\\n       }\\n       int mid = (start+end)/2;\\n       TreeNode root = new TreeNode(nums.get(mid));\\n       root.left = balance(nums,start,mid-1);\\n       root.right = balance(nums, mid+1,end);\\n       return root;\\n   }\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        if(root == null){\\n            return null;\\n        }\\n        traversal(root, list);\\n        TreeNode newRoot = balance(list,0,list.size()-1);\\n        return newRoot;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void traversal(TreeNode root, List<Integer> list) {\\n       \\n        // Return if the current node is null\\n        //base case\\n        if(root == null) return;\\n        // Recursively traverse the left and right subtrees\\n        traversal(root.left,list);\\n        // Add the current node\\'s value to the result list\\n        list.add(root.val);\\n        traversal(root.right, list);\\n   }\\n   public TreeNode balance(ArrayList<Integer> nums, int start, int end){\\n       if(start>end){\\n           return null;\\n       }\\n       int mid = (start+end)/2;\\n       TreeNode root = new TreeNode(nums.get(mid));\\n       root.left = balance(nums,start,mid-1);\\n       root.right = balance(nums, mid+1,end);\\n       return root;\\n   }\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        if(root == null){\\n            return null;\\n        }\\n        traversal(root, list);\\n        TreeNode newRoot = balance(list,0,list.size()-1);\\n        return newRoot;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370779,
                "title": "solve-three-questions-with-this-approach-easy-java",
                "content": "```\\n//Que 1382  --> 108--> 109 are same logic based \\nclass Solution {\\n     List<TreeNode> ls=new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n       helper(root);\\n        int start=0;\\n        int end=ls.size()-1;\\n      return  createBBST(start,end);\\n        \\n    }\\n    public void helper(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        helper(root.left);\\n        ls.add(root);\\n        helper(root.right);\\n    }\\n    \\n    public TreeNode createBBST(int start,int end){\\n        if(start>end){\\n            return null;\\n        }\\n        int mid=start+(end-start)/2;\\n        TreeNode root=ls.get(mid);\\n        root.left=createBBST(start,mid-1);\\n        root.right=createBBST(mid+1,end);\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n//Que 1382  --> 108--> 109 are same logic based \\nclass Solution {\\n     List<TreeNode> ls=new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n       helper(root);\\n        int start=0;\\n        int end=ls.size()-1;\\n      return  createBBST(start,end);\\n        \\n    }\\n    public void helper(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        helper(root.left);\\n        ls.add(root);\\n        helper(root.right);\\n    }\\n    \\n    public TreeNode createBBST(int start,int end){\\n        if(start>end){\\n            return null;\\n        }\\n        int mid=start+(end-start)/2;\\n        TreeNode root=ls.get(mid);\\n        root.left=createBBST(start,mid-1);\\n        root.right=createBBST(mid+1,end);\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142530,
                "title": "c-easiest-approach-beginners-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<int> &in){\\n        if(root==NULL)\\n        return;\\n        inorder(root->left,in);\\n        in.push_back(root->val);\\n        inorder(root->right,in);\\n    }\\n\\n    TreeNode* inorderToBST(int s,int e,vector<int> &in){\\n        if(s>e)\\n        return NULL;\\n        int mid = (s+e)/2;\\n        TreeNode* root=new TreeNode(in[mid]);\\n        root->left = inorderToBST(s,mid-1,in);\\n        root->right = inorderToBST(mid+1,e,in);\\n        return root;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> inorderVal;\\n        inorder(root,inorderVal);\\n        return inorderToBST(0,inorderVal.size()-1,inorderVal);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<int> &in){\\n        if(root==NULL)\\n        return;\\n        inorder(root->left,in);\\n        in.push_back(root->val);\\n        inorder(root->right,in);\\n    }\\n\\n    TreeNode* inorderToBST(int s,int e,vector<int> &in){\\n        if(s>e)\\n        return NULL;\\n        int mid = (s+e)/2;\\n        TreeNode* root=new TreeNode(in[mid]);\\n        root->left = inorderToBST(s,mid-1,in);\\n        root->right = inorderToBST(mid+1,e,in);\\n        return root;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> inorderVal;\\n        inorder(root,inorderVal);\\n        return inorderToBST(0,inorderVal.size()-1,inorderVal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787111,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  int makeVine(TreeNode *grand, int cnt = 0) {\\n  auto n = grand->right;\\n  while (n != nullptr) {\\n    if (n->left != nullptr) {\\n      auto old_n = n;\\n      n = n->left;\\n      old_n->left = n->right;\\n      n->right = old_n;\\n      grand->right = n;\\n    }\\n    else {      \\n        ++cnt;\\n        grand = n;\\n        n = n->right;\\n    }\\n  }\\n  return cnt;\\n}\\nvoid compress(TreeNode *grand, int m) {\\n  auto n = grand->right;\\n  while (m-- > 0) {\\n    auto old_n = n;\\n    n = n->right;\\n    grand->right = n;\\n    old_n->right = n->left;\\n    n->left = old_n;\\n    grand = n;\\n    n = n->right;\\n  }\\n}\\nTreeNode* balanceBST(TreeNode *root) {\\n  TreeNode grand;\\n  grand.right = root;\\n  auto cnt = makeVine(&grand);\\n  int m = pow(2, int(log2(cnt + 1))) - 1;\\n  compress(&grand, cnt - m);\\n  for (m = m / 2; m > 0; m /= 2)\\n    compress(&grand, m);\\n  return grand.right;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  int makeVine(TreeNode *grand, int cnt = 0) {\\n  auto n = grand->right;\\n  while (n != nullptr) {\\n    if (n->left != nullptr) {\\n      auto old_n = n;\\n      n = n->left;\\n      old_n->left = n->right;\\n      n->right = old_n;\\n      grand->right = n;\\n    }\\n    else {      \\n        ++cnt;\\n        grand = n;\\n        n = n->right;\\n    }\\n  }\\n  return cnt;\\n}\\nvoid compress(TreeNode *grand, int m) {\\n  auto n = grand->right;\\n  while (m-- > 0) {\\n    auto old_n = n;\\n    n = n->right;\\n    grand->right = n;\\n    old_n->right = n->left;\\n    n->left = old_n;\\n    grand = n;\\n    n = n->right;\\n  }\\n}\\nTreeNode* balanceBST(TreeNode *root) {\\n  TreeNode grand;\\n  grand.right = root;\\n  auto cnt = makeVine(&grand);\\n  int m = pow(2, int(log2(cnt + 1))) - 1;\\n  compress(&grand, cnt - m);\\n  for (m = m / 2; m > 0; m /= 2)\\n    compress(&grand, m);\\n  return grand.right;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781041,
                "title": "c-inorder-traversal-o-n-time",
                "content": "# Intuition\\n- Convert the given BST to a sorted array using Inorder traversal.\\n- Build the tree using the inorder traversal.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> in;\\n        stack<TreeNode*> st;\\n        TreeNode* temp = root;\\n\\n        while(temp || !st.empty()){\\n            while(temp){\\n                st.push(temp);\\n                temp = temp->left;\\n            }\\n            temp = st.top();\\n            st.pop();\\n            in.push_back(temp->val);\\n            temp = temp->right;\\n        }\\n\\n        return buildTree(in, 0, in.size() - 1);\\n    }\\n\\n    TreeNode* buildTree(vector<int> &in, int start, int end){\\n        if(start > end){\\n            return nullptr;\\n        }\\n\\n        int mid = (start + end) / 2;\\n        TreeNode* newNode = new TreeNode(in[mid]);\\n        newNode->left = buildTree(in, start, mid - 1);\\n        newNode->right = buildTree(in, mid + 1, end);\\n\\n        return newNode;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> in;\\n        stack<TreeNode*> st;\\n        TreeNode* temp = root;\\n\\n        while(temp || !st.empty()){\\n            while(temp){\\n                st.push(temp);\\n                temp = temp->left;\\n            }\\n            temp = st.top();\\n            st.pop();\\n            in.push_back(temp->val);\\n            temp = temp->right;\\n        }\\n\\n        return buildTree(in, 0, in.size() - 1);\\n    }\\n\\n    TreeNode* buildTree(vector<int> &in, int start, int end){\\n        if(start > end){\\n            return nullptr;\\n        }\\n\\n        int mid = (start + end) / 2;\\n        TreeNode* newNode = new TreeNode(in[mid]);\\n        newNode->left = buildTree(in, start, mid - 1);\\n        newNode->right = buildTree(in, mid + 1, end);\\n\\n        return newNode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599981,
                "title": "c-solution-using-recursion-and-inorder-traversal",
                "content": "```\\nclass Solution {\\n    void inorder(TreeNode*root,vector<int> &v)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    TreeNode* help(int s,int e,vector<int> v)\\n    {\\n//         base case\\n        if(s>e)\\n        {\\n            return NULL;\\n        }\\n        int mid=s+(e-s)/2;\\n        TreeNode*root=new TreeNode(v[mid]);\\n        root->left=help(s,mid-1,v);\\n        root->right=help(mid+1,e,v);\\n        return root;\\n    }\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {  \\n        vector<int> v;\\n        inorder(root,v);\\n        return help(0,v.size()-1,v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    void inorder(TreeNode*root,vector<int> &v)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    TreeNode* help(int s,int e,vector<int> v)\\n    {\\n//         base case\\n        if(s>e)\\n        {\\n            return NULL;\\n        }\\n        int mid=s+(e-s)/2;\\n        TreeNode*root=new TreeNode(v[mid]);\\n        root->left=help(s,mid-1,v);\\n        root->right=help(mid+1,e,v);\\n        return root;\\n    }\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {  \\n        vector<int> v;\\n        inorder(root,v);\\n        return help(0,v.size()-1,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2536812,
                "title": "c-solution-de-structuring-and-structuring-solved",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int>nodeList;\\n        nodes(root,nodeList);\\n        TreeNode *ans = constructBst(nodeList,0,nodeList.size()-1);\\n        return ans;\\n        \\n    }\\n    void nodes(TreeNode *root,vector<int> &v) {\\n        if(root==NULL)return ;\\n        nodes(root->left,v);\\n        v.push_back(root->val);\\n        nodes(root->right,v);\\n        return;\\n    }\\n    TreeNode* constructBst(vector<int>&v,int s,int e){\\n        if(s>e)return NULL;\\n        int mid = (s+e)/2;\\n        TreeNode *root = new TreeNode(v[mid]);\\n        root->left = constructBst(v,s,mid-1);\\n        root->right = constructBst(v,mid+1,e);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int>nodeList;\\n        nodes(root,nodeList);\\n        TreeNode *ans = constructBst(nodeList,0,nodeList.size()-1);\\n        return ans;\\n        \\n    }\\n    void nodes(TreeNode *root,vector<int> &v) {\\n        if(root==NULL)return ;\\n        nodes(root->left,v);\\n        v.push_back(root->val);\\n        nodes(root->right,v);\\n        return;\\n    }\\n    TreeNode* constructBst(vector<int>&v,int s,int e){\\n        if(s>e)return NULL;\\n        int mid = (s+e)/2;\\n        TreeNode *root = new TreeNode(v[mid]);\\n        root->left = constructBst(v,s,mid-1);\\n        root->right = constructBst(v,mid+1,e);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504986,
                "title": "simple-python-solution-with-inorder-traversal-beats-92",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.arr = []\\n    def inOrder(self,root):\\n        if root is None:\\n            return []\\n        else:\\n            self.inOrder(root.left)\\n            self.arr.append(root.val)\\n            self.inOrder(root.right)\\n        return self.arr\\n    \\n    def balanced(self,left,right,nums):\\n        if left > right:\\n            return None\\n        else:\\n            mid = (left + right)//2\\n            root = TreeNode(nums[mid])\\n            root.left = self.balanced(left,mid-1,nums)\\n            root.right = self.balanced(mid+1,right,nums)\\n        return root\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        nums = self.inOrder(root)\\n        return self.balanced(0,len(nums)-1,nums)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.arr = []\\n    def inOrder(self,root):\\n        if root is None:\\n            return []\\n        else:\\n            self.inOrder(root.left)\\n            self.arr.append(root.val)\\n            self.inOrder(root.right)\\n        return self.arr\\n    \\n    def balanced(self,left,right,nums):\\n        if left > right:\\n            return None\\n        else:\\n            mid = (left + right)//2\\n            root = TreeNode(nums[mid])\\n            root.left = self.balanced(left,mid-1,nums)\\n            root.right = self.balanced(mid+1,right,nums)\\n        return root\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        nums = self.inOrder(root)\\n        return self.balanced(0,len(nums)-1,nums)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479600,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*>res;\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorder(root);\\n        return bst(0,res.size()-1);\\n    }\\n    void inorder(TreeNode* root){\\n        if(root==NULL)return;\\n        inorder(root->left);\\n        res.push_back(root);\\n        inorder(root->right);\\n    }\\n    \\n    TreeNode* bst(int start,int end){\\n        if(start>end)return NULL;\\n        int mid=(start+end)/2;\\n        TreeNode* root=res[mid];\\n        root->left=bst(start,mid-1);\\n        root->right=bst(mid+1,end);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*>res;\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorder(root);\\n        return bst(0,res.size()-1);\\n    }\\n    void inorder(TreeNode* root){\\n        if(root==NULL)return;\\n        inorder(root->left);\\n        res.push_back(root);\\n        inorder(root->right);\\n    }\\n    \\n    TreeNode* bst(int start,int end){\\n        if(start>end)return NULL;\\n        int mid=(start+end)/2;\\n        TreeNode* root=res[mid];\\n        root->left=bst(start,mid-1);\\n        root->right=bst(mid+1,end);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2378016,
                "title": "c-easy-recurion-inorder",
                "content": "\\n**UPVOTE IF IT HELPS**\\n\\n\\'\\'\\'\\n\\t\\n\\tvoid storeInorder(TreeNode* root , vector<int> &inorderVal){\\n    \\n    if(root == NULL)\\n        return ;\\n        \\n\\t\\tstoreInorder(root->left , inorderVal);\\n\\t\\tinorderVal.push_back(root->val);\\n\\t\\tstoreInorder(root->right , inorderVal);\\n\\t}    \\n    \\n\\tTreeNode* inorderToBST( int s , int e , vector<int> &inorderVal ){\\n        if(s>e)\\n            return NULL;\\n        \\n        int mid = (s+e)/2;\\n        TreeNode* newroot = new TreeNode(inorderVal[mid]);\\n        // value less than mid will be stored in left part\\n        newroot->left  = inorderToBST(s,mid-1,inorderVal );\\n        \\n        // value more than mid will be stored in right part\\n        newroot->right = inorderToBST(mid+1,e,inorderVal );\\n        \\n    return newroot;\\n\\t}    \\n\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n       \\n\\n        vector<int> inorderVal;\\n\\n        storeInorder(root, inorderVal);\\n    \\n        return inorderToBST( 0 , inorderVal.size() -1 ,inorderVal);\\n    \\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "\\n**UPVOTE IF IT HELPS**\\n\\n\\'\\'\\'\\n\\t\\n\\tvoid storeInorder(TreeNode* root , vector<int> &inorderVal){\\n    \\n    if(root == NULL)\\n        return ;\\n        \\n\\t\\tstoreInorder(root->left , inorderVal);\\n\\t\\tinorderVal.push_back(root->val);\\n\\t\\tstoreInorder(root->right , inorderVal);\\n\\t}    \\n    \\n\\tTreeNode* inorderToBST( int s , int e , vector<int> &inorderVal ){\\n        if(s>e)\\n            return NULL;\\n        \\n        int mid = (s+e)/2;\\n        TreeNode* newroot = new TreeNode(inorderVal[mid]);\\n        // value less than mid will be stored in left part\\n        newroot->left  = inorderToBST(s,mid-1,inorderVal );\\n        \\n        // value more than mid will be stored in right part\\n        newroot->right = inorderToBST(mid+1,e,inorderVal );\\n        \\n    return newroot;\\n\\t}    \\n\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n       \\n\\n        vector<int> inorderVal;\\n\\n        storeInorder(root, inorderVal);\\n    \\n        return inorderToBST( 0 , inorderVal.size() -1 ,inorderVal);\\n    \\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2336401,
                "title": "c-easy-understanding-code",
                "content": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &nums){\\n        if (root == NULL) return;\\n        inorder(root->left, nums);\\n        nums.push_back(root->val);\\n        inorder(root->right, nums);\\n    }\\n    \\n    TreeNode* buildTree(vector<int> &nums, int s , int e){\\n        if (s > e) return NULL;\\n        int mid = (s+e)/2;\\n        TreeNode *root = new TreeNode(nums[mid]);\\n        root->left = buildTree(nums, s, mid-1);\\n        root->right = buildTree(nums, mid+1, e);\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> nums;\\n        inorder(root, nums);\\n        int n = nums.size()-1;\\n        return buildTree(nums, 0, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &nums){\\n        if (root == NULL) return;\\n        inorder(root->left, nums);\\n        nums.push_back(root->val);\\n        inorder(root->right, nums);\\n    }\\n    \\n    TreeNode* buildTree(vector<int> &nums, int s , int e){\\n        if (s > e) return NULL;\\n        int mid = (s+e)/2;\\n        TreeNode *root = new TreeNode(nums[mid]);\\n        root->left = buildTree(nums, s, mid-1);\\n        root->right = buildTree(nums, mid+1, e);\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> nums;\\n        inorder(root, nums);\\n        int n = nums.size()-1;\\n        return buildTree(nums, 0, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327707,
                "title": "java-by-rotating-tree-avl-time-complexity-o-n",
                "content": "```\\n    // ? Remember that we can convert BST to a sorted array and then convert it into\\n    // ? balanced BST. Because when converting a sorted array into BST, we find the\\n    // ? middle and then split it into two halfs. Therefore the BST formed is\\n    // ? balanced\\n\\n    // # But here we would have taken the extra space of array.\\n\\n    // So we can also convert the BST into sorted doubly linked list, inplace and\\n    // then convert the sorted DLL to BST\\n\\n    // # But here it can also be solved by using AVL.\\n\\n    // ! But the question is HOW ???\\n\\n    // So that we can calculate the height in O(1), we will be keeping an array of\\n    // size of the range of nodes value since node value will be distinct.\\n\\n    // Otherwise we will have to calculate the height everytime and that will an\\n    // operation of logN itself.\\n\\n    // We are going to do as we did in AVL.\\n\\n    // We are going to rotate the tree such that our tree remains balanced.\\n\\n    // So we have just called the simple post order call.\\n\\n    // ? Why post order ???\\n\\n    // # It is because to calculate the balance factor we will be needing the height\\n    // # of both left and right subtree.\\n\\n    // And whenever we are returing the root, we Rotate it using the getRotation\\n    // function to get the balance BST.\\n\\n    // ! Important Note : To solve this using the AVL, please dry on the skew tree\\n\\n    public static void updateHeight(TreeNode root, int[] height) {\\n\\n        int lh = root.left != null ? height[root.left.val] : -1;\\n        int rh = root.right != null ? height[root.right.val] : -1;\\n\\n        height[root.val] = Math.max(lh, rh) + 1;\\n    }\\n\\n    public static int getBalance(TreeNode root, int[] height) {\\n\\n        int lh = root.left != null ? height[root.left.val] : -1;\\n        int rh = root.right != null ? height[root.right.val] : -1;\\n\\n        int bal = lh - rh;\\n\\n        return bal;\\n    }\\n\\n    public static TreeNode leftRotation(TreeNode A, int[] height) {\\n\\n        TreeNode B = A.right;\\n        TreeNode BKaLeft = B.left;\\n\\n        B.left = A;\\n        A.right = BKaLeft;\\n\\n        // Now we have called the getRotation function again because\\n        // Aisa ho sakta hai ki rotation ke baad bhi mera tree unbalanced ho sakta hai\\n        // to use dubara balance karne ke liye getRotation call kiya\\n\\n        B.left = getRotation(A, height);\\n        return getRotation(B, height);\\n    }\\n\\n    public static TreeNode rightRotation(TreeNode A, int[] height) {\\n\\n        TreeNode B = A.left;\\n        TreeNode BKaRight = B.right;\\n\\n        B.right = A;\\n        A.left = BKaRight;\\n\\n        // Now we have called the getRotation function again because\\n        // Aisa ho sakta hai ki rotation ke baad bhi mera tree unbalanced ho sakta hai\\n        // to use dubara balance karne ke liye getRotation call kiya\\n\\n        B.right = getRotation(A, height);\\n        return getRotation(B, height);\\n\\n    }\\n\\n    public static TreeNode getRotation(TreeNode root, int[] height) {\\n        // Now since here we are converting an already BSt to a balanced BST, so the\\n        // ` balance factor can be greater than 2 and can be less that -2. Other wise\\n        // the call remains the same as in AVL tree\\n\\n        updateHeight(root, height);\\n        if (getBalance(root, height) >= 2) {\\n            if (getBalance(root.left, height) >= 1) {\\n                return rightRotation(root, height);\\n            } else {\\n                root.left = leftRotation(root.left, height);\\n                return rightRotation(root, height);\\n            }\\n        } else if (getBalance(root, height) <= -2) {\\n            if (getBalance(root.right, height) <= -1) {\\n                return leftRotation(root, height);\\n            } else {\\n                root.right = rightRotation(root.right, height);\\n                return leftRotation(root, height);\\n            }\\n        }\\n\\n        return root;\\n    }\\n\\n    public TreeNode balanceBST(TreeNode root, int[] height) {\\n\\n        if (root == null) {\\n            return null;\\n        }\\n\\n        root.left = balanceBST(root.left, height);\\n        root.right = balanceBST(root.right, height);\\n\\n        return getRotation(root, height);\\n    }\\n\\n    public TreeNode balanceBST(TreeNode root) {\\n\\n        int[] height = new int[(int) 1e5 + 1];\\n        return balanceBST(root, height);\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\n    // ? Remember that we can convert BST to a sorted array and then convert it into\\n    // ? balanced BST. Because when converting a sorted array into BST, we find the\\n    // ? middle and then split it into two halfs. Therefore the BST formed is\\n    // ? balanced\\n\\n    // # But here we would have taken the extra space of array.\\n\\n    // So we can also convert the BST into sorted doubly linked list, inplace and\\n    // then convert the sorted DLL to BST\\n\\n    // # But here it can also be solved by using AVL.\\n\\n    // ! But the question is HOW ???\\n\\n    // So that we can calculate the height in O(1), we will be keeping an array of\\n    // size of the range of nodes value since node value will be distinct.\\n\\n    // Otherwise we will have to calculate the height everytime and that will an\\n    // operation of logN itself.\\n\\n    // We are going to do as we did in AVL.\\n\\n    // We are going to rotate the tree such that our tree remains balanced.\\n\\n    // So we have just called the simple post order call.\\n\\n    // ? Why post order ???\\n\\n    // # It is because to calculate the balance factor we will be needing the height\\n    // # of both left and right subtree.\\n\\n    // And whenever we are returing the root, we Rotate it using the getRotation\\n    // function to get the balance BST.\\n\\n    // ! Important Note : To solve this using the AVL, please dry on the skew tree\\n\\n    public static void updateHeight(TreeNode root, int[] height) {\\n\\n        int lh = root.left != null ? height[root.left.val] : -1;\\n        int rh = root.right != null ? height[root.right.val] : -1;\\n\\n        height[root.val] = Math.max(lh, rh) + 1;\\n    }\\n\\n    public static int getBalance(TreeNode root, int[] height) {\\n\\n        int lh = root.left != null ? height[root.left.val] : -1;\\n        int rh = root.right != null ? height[root.right.val] : -1;\\n\\n        int bal = lh - rh;\\n\\n        return bal;\\n    }\\n\\n    public static TreeNode leftRotation(TreeNode A, int[] height) {\\n\\n        TreeNode B = A.right;\\n        TreeNode BKaLeft = B.left;\\n\\n        B.left = A;\\n        A.right = BKaLeft;\\n\\n        // Now we have called the getRotation function again because\\n        // Aisa ho sakta hai ki rotation ke baad bhi mera tree unbalanced ho sakta hai\\n        // to use dubara balance karne ke liye getRotation call kiya\\n\\n        B.left = getRotation(A, height);\\n        return getRotation(B, height);\\n    }\\n\\n    public static TreeNode rightRotation(TreeNode A, int[] height) {\\n\\n        TreeNode B = A.left;\\n        TreeNode BKaRight = B.right;\\n\\n        B.right = A;\\n        A.left = BKaRight;\\n\\n        // Now we have called the getRotation function again because\\n        // Aisa ho sakta hai ki rotation ke baad bhi mera tree unbalanced ho sakta hai\\n        // to use dubara balance karne ke liye getRotation call kiya\\n\\n        B.right = getRotation(A, height);\\n        return getRotation(B, height);\\n\\n    }\\n\\n    public static TreeNode getRotation(TreeNode root, int[] height) {\\n        // Now since here we are converting an already BSt to a balanced BST, so the\\n        // ` balance factor can be greater than 2 and can be less that -2. Other wise\\n        // the call remains the same as in AVL tree\\n\\n        updateHeight(root, height);\\n        if (getBalance(root, height) >= 2) {\\n            if (getBalance(root.left, height) >= 1) {\\n                return rightRotation(root, height);\\n            } else {\\n                root.left = leftRotation(root.left, height);\\n                return rightRotation(root, height);\\n            }\\n        } else if (getBalance(root, height) <= -2) {\\n            if (getBalance(root.right, height) <= -1) {\\n                return leftRotation(root, height);\\n            } else {\\n                root.right = rightRotation(root.right, height);\\n                return leftRotation(root, height);\\n            }\\n        }\\n\\n        return root;\\n    }\\n\\n    public TreeNode balanceBST(TreeNode root, int[] height) {\\n\\n        if (root == null) {\\n            return null;\\n        }\\n\\n        root.left = balanceBST(root.left, height);\\n        root.right = balanceBST(root.right, height);\\n\\n        return getRotation(root, height);\\n    }\\n\\n    public TreeNode balanceBST(TreeNode root) {\\n\\n        int[] height = new int[(int) 1e5 + 1];\\n        return balanceBST(root, height);\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2313715,
                "title": "python-solution-dfs-inorder-extraction-and-building-tree-clean-code",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        def inorder(node,arr):\\n            if node is None:\\n                return None\\n            \\n            inorder(node.left,arr)\\n            arr.append(node)\\n            inorder(node.right,arr)\\n        \\n        def construct(arr):\\n            if not arr:\\n                return None\\n            \\n            mid = len(arr)//2\\n            \\n            node = TreeNode(arr[mid].val)\\n            node.left = construct(arr[:mid])\\n            node.right = construct(arr[mid+1:])\\n            \\n            return node\\n            \\n        arr = []\\n        inorder(root,arr)\\n        \\n        return construct(arr)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        def inorder(node,arr):\\n            if node is None:\\n                return None\\n            \\n            inorder(node.left,arr)\\n            arr.append(node)\\n            inorder(node.right,arr)\\n        \\n        def construct(arr):\\n            if not arr:\\n                return None\\n            \\n            mid = len(arr)//2\\n            \\n            node = TreeNode(arr[mid].val)\\n            node.left = construct(arr[:mid])\\n            node.right = construct(arr[mid+1:])\\n            \\n            return node\\n            \\n        arr = []\\n        inorder(root,arr)\\n        \\n        return construct(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303328,
                "title": "python-divide-and-conquer-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef balanceBST(self, root: TreeNode) -> TreeNode:\\n\\t\\t\\tnodes = []\\n\\n\\t\\t\\tdef inOrderTraverse(node: TreeNode):\\n\\t\\t\\t\\tif not node.right and not node.left:\\n\\t\\t\\t\\t\\tnodes.append(node.val)\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tif node.left:\\n\\t\\t\\t\\t\\tinOrderTraverse(node.left)\\n\\n\\t\\t\\t\\tnodes.append(node.val)\\n\\n\\t\\t\\t\\tif node.right:\\n\\t\\t\\t\\t\\tinOrderTraverse(node.right)\\n\\n\\t\\t\\tdef divideAndConquer(nodes_list: List[int], l: int, r: int) -> TreeNode:\\n\\t\\t\\t\\tif l >= 0 and r < len(nodes_list) and l <= r:\\n\\t\\t\\t\\t\\tmid = (l + r) // 2\\n\\t\\t\\t\\t\\tmid_val = nodes_list[mid]\\n\\n\\t\\t\\t\\t\\tnew_node = TreeNode(mid_val)\\n\\n\\t\\t\\t\\t\\tnew_node.left = divideAndConquer(nodes_list, l, mid - 1)\\n\\t\\t\\t\\t\\tnew_node.right = divideAndConquer(nodes_list, mid + 1, r)\\n\\n\\t\\t\\t\\t\\treturn new_node\\n\\n\\t\\t\\tinOrderTraverse(root)\\n\\t\\t\\treturn divideAndConquer(nodes, 0, len(nodes)-1)",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef balanceBST(self, root: TreeNode) -> TreeNode:\\n\\t\\t\\tnodes = []\\n\\n\\t\\t\\tdef inOrderTraverse(node: TreeNode):\\n\\t\\t\\t\\tif not node.right and not node.left:\\n\\t\\t\\t\\t\\tnodes.append(node.val)\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tif node.left:\\n\\t\\t\\t\\t\\tinOrderTraverse(node.left)\\n\\n\\t\\t\\t\\tnodes.append(node.val)\\n\\n\\t\\t\\t\\tif node.right:\\n\\t\\t\\t\\t\\tinOrderTraverse(node.right)\\n\\n\\t\\t\\tdef divideAndConquer(nodes_list: List[int], l: int, r: int) -> TreeNode:\\n\\t\\t\\t\\tif l >= 0 and r < len(nodes_list) and l <= r:\\n\\t\\t\\t\\t\\tmid = (l + r) // 2\\n\\t\\t\\t\\t\\tmid_val = nodes_list[mid]\\n\\n\\t\\t\\t\\t\\tnew_node = TreeNode(mid_val)\\n\\n\\t\\t\\t\\t\\tnew_node.left = divideAndConquer(nodes_list, l, mid - 1)\\n\\t\\t\\t\\t\\tnew_node.right = divideAndConquer(nodes_list, mid + 1, r)\\n\\n\\t\\t\\t\\t\\treturn new_node\\n\\n\\t\\t\\tinOrderTraverse(root)\\n\\t\\t\\treturn divideAndConquer(nodes, 0, len(nodes)-1)",
                "codeTag": "Java"
            },
            {
                "id": 2263962,
                "title": "c-recursion-tree-creation",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* node, vector<int>& v){\\n        if(node == NULL) return;\\n        dfs(node->left,v);\\n        v.push_back(node->val);\\n        dfs(node->right,v);\\n    }\\n    \\n    TreeNode* createTree(vector<int>& v, int i, int j){\\n        if(i>j) return NULL;\\n        int mid = (i+j)/2;\\n        TreeNode* cur = new TreeNode(v[mid]);\\n        cur->left = createTree(v,i,mid-1);\\n        cur->right = createTree(v,mid+1,j);\\n        return cur;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> v;\\n        dfs(root,v);\\n        TreeNode* res = createTree(v,0,v.size()-1);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* node, vector<int>& v){\\n        if(node == NULL) return;\\n        dfs(node->left,v);\\n        v.push_back(node->val);\\n        dfs(node->right,v);\\n    }\\n    \\n    TreeNode* createTree(vector<int>& v, int i, int j){\\n        if(i>j) return NULL;\\n        int mid = (i+j)/2;\\n        TreeNode* cur = new TreeNode(v[mid]);\\n        cur->left = createTree(v,i,mid-1);\\n        cur->right = createTree(v,mid+1,j);\\n        return cur;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> v;\\n        dfs(root,v);\\n        TreeNode* res = createTree(v,0,v.size()-1);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263961,
                "title": "67-tc-and-56-sc-easy-python-solution",
                "content": "```\\ndef balanceBST(self, root: TreeNode) -> TreeNode:\\n\\tlru_cache(None)\\n\\tdef dfs(node):\\n\\t\\tif not(node):\\n\\t\\t\\treturn []\\n\\t\\treturn dfs(node.left) + [node.val] + dfs(node.right)\\n\\tarr = dfs(root)\\n\\tdef balance(i, j):\\n\\t\\tif(i > j):\\n\\t\\t\\treturn None\\n\\t\\tif(i == j):\\n\\t\\t\\treturn TreeNode(arr[i])\\n\\t\\tmid = (i+j)//2\\n\\t\\treturn TreeNode(arr[mid], balance(i, mid-1), balance(mid+1, j))\\n\\treturn balance(0, len(arr)-1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\ndef balanceBST(self, root: TreeNode) -> TreeNode:\\n\\tlru_cache(None)\\n\\tdef dfs(node):\\n\\t\\tif not(node):\\n\\t\\t\\treturn []\\n\\t\\treturn dfs(node.left) + [node.val] + dfs(node.right)\\n\\tarr = dfs(root)\\n\\tdef balance(i, j):\\n\\t\\tif(i > j):\\n\\t\\t\\treturn None\\n\\t\\tif(i == j):\\n\\t\\t\\treturn TreeNode(arr[i])\\n\\t\\tmid = (i+j)//2\\n\\t\\treturn TreeNode(arr[mid], balance(i, mid-1), balance(mid+1, j))\\n\\treturn balance(0, len(arr)-1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2219250,
                "title": "c-solution-explained-faster-than-81-71-runtime-154ms-memory-61-9mb",
                "content": "Pull the elements in a vector by doing inorder traversal. (Note: Inorder of bst gives (ascending) sorted ordered elements)\\nNow find the middle element and start inserting to form a new bst.\\nRepeat the above step recursively until the start element = end element.\\nRefer to code below for further insights.\\n\\nIntuition: If the no. of elements in the right and left of the element to be inserted be equal or differ by one at each stage of insertion, the resultant tree would be balanced.\\n\\nComment down for further discussion.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    TreeNode *insert(TreeNode *root, int value)\\n    {\\n        if(root == NULL)\\n        {\\n            root  = new TreeNode(0);\\n            root->left = NULL; root->right = NULL;\\n            root->val = value;\\n            return root;\\n        }\\n        \\n        TreeNode *trav = root;\\n        \\n        while(true)\\n        {\\n            if(value < trav->val)\\n            {\\n                if(trav->left == NULL) break;\\n                trav = trav->left;\\n            }\\n            else\\n            {\\n                if(trav->right == NULL) break;\\n                trav = trav->right;\\n            }\\n        }\\n        \\n        TreeNode *tmp = new TreeNode(0);\\n        tmp->left = NULL; tmp->right = NULL;\\n        tmp->val = value;\\n        \\n        if(value < trav->val)\\n        {\\n            trav->left = tmp;\\n        }\\n        else\\n        {\\n            trav->right = tmp;\\n        }\\n        \\n        return root;\\n    }\\n    \\n    TreeNode *balance(vector<int> &v, TreeNode *root, int start, int end)\\n    {\\n        if(start == end) \\n        {\\n            root = insert(root, v[start]);\\n            return root;\\n        }\\n        int mid = ceil((start + end)/2);\\n        root = insert(root, v[mid]);\\n        \\n        if(mid != end)\\n        {\\n            root = balance(v, root, mid+1, end);\\n        }\\n        \\n        if(mid != start)\\n        {\\n            root = balance(v, root, start, mid-1);\\n        }\\n        return root;\\n    }\\n    \\n    void trav(vector<int> &v, TreeNode* root)\\n    {\\n        if(root == NULL) return;\\n        trav(v, root->left);\\n        v.push_back(root->val);\\n        trav(v, root->right);\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        if(root == NULL) return NULL;\\n        vector<int> v;\\n        trav(v, root);\\n        \\n        root = NULL;\\n        root = balance(v, root, 0, v.size()-1);\\n        \\n        return root;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode *insert(TreeNode *root, int value)\\n    {\\n        if(root == NULL)\\n        {\\n            root  = new TreeNode(0);\\n            root->left = NULL; root->right = NULL;\\n            root->val = value;\\n            return root;\\n        }\\n        \\n        TreeNode *trav = root;\\n        \\n        while(true)\\n        {\\n            if(value < trav->val)\\n            {\\n                if(trav->left == NULL) break;\\n                trav = trav->left;\\n            }\\n            else\\n            {\\n                if(trav->right == NULL) break;\\n                trav = trav->right;\\n            }\\n        }\\n        \\n        TreeNode *tmp = new TreeNode(0);\\n        tmp->left = NULL; tmp->right = NULL;\\n        tmp->val = value;\\n        \\n        if(value < trav->val)\\n        {\\n            trav->left = tmp;\\n        }\\n        else\\n        {\\n            trav->right = tmp;\\n        }\\n        \\n        return root;\\n    }\\n    \\n    TreeNode *balance(vector<int> &v, TreeNode *root, int start, int end)\\n    {\\n        if(start == end) \\n        {\\n            root = insert(root, v[start]);\\n            return root;\\n        }\\n        int mid = ceil((start + end)/2);\\n        root = insert(root, v[mid]);\\n        \\n        if(mid != end)\\n        {\\n            root = balance(v, root, mid+1, end);\\n        }\\n        \\n        if(mid != start)\\n        {\\n            root = balance(v, root, start, mid-1);\\n        }\\n        return root;\\n    }\\n    \\n    void trav(vector<int> &v, TreeNode* root)\\n    {\\n        if(root == NULL) return;\\n        trav(v, root->left);\\n        v.push_back(root->val);\\n        trav(v, root->right);\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        if(root == NULL) return NULL;\\n        vector<int> v;\\n        trav(v, root);\\n        \\n        root = NULL;\\n        root = balance(v, root, 0, v.size()-1);\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210507,
                "title": "easy-c-solution-with-explanation",
                "content": "```\\n\\n    // function to find BST elements in inorder(sorted) form\\nvoid inorder( TreeNode *root, vector<int>& in)\\n{\\n    // base case\\n    if(root == NULL)\\n    {\\n        return;\\n    }\\n    // inorder: left root right\\n    inorder(root->left, in);\\n    in.push_back(root->val);\\n    inorder(root->right, in);\\n}\\n    // function to get balanced bst\\n TreeNode * balancedBST(int s, int e, vector<int>& in)\\n{\\n    // base case\\n    if(s > e)\\n    {\\n        return NULL;\\n    }\\n     // find mid index\\n    int mid = (s+e)/2;\\n     // create root node\\n    TreeNode * root = new TreeNode(in[mid]);\\n    // left and right child of tree\\n    root->left = balancedBST(s,mid-1, in);\\n    root->right = balancedBST(mid+1, e, in);\\n    return root;\\n}\\n    TreeNode* balanceBST(TreeNode* root) {\\n        // to store inorder elements from BST\\n        vector<int>in;\\n        // store BST elements in inorder form inside in array\\n        inorder(root, in);\\n        int st = 0, end = in.size()-1;\\n        \\n        // creating balanced bst\\n         TreeNode * newRoot = balancedBST(st, end, in);\\n        return newRoot;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\n\\n    // function to find BST elements in inorder(sorted) form\\nvoid inorder( TreeNode *root, vector<int>& in)\\n{\\n    // base case\\n    if(root == NULL)\\n    {\\n        return;\\n    }\\n    // inorder: left root right\\n    inorder(root->left, in);\\n    in.push_back(root->val);\\n    inorder(root->right, in);\\n}\\n    // function to get balanced bst\\n TreeNode * balancedBST(int s, int e, vector<int>& in)\\n{\\n    // base case\\n    if(s > e)\\n    {\\n        return NULL;\\n    }\\n     // find mid index\\n    int mid = (s+e)/2;\\n     // create root node\\n    TreeNode * root = new TreeNode(in[mid]);\\n    // left and right child of tree\\n    root->left = balancedBST(s,mid-1, in);\\n    root->right = balancedBST(mid+1, e, in);\\n    return root;\\n}\\n    TreeNode* balanceBST(TreeNode* root) {\\n        // to store inorder elements from BST\\n        vector<int>in;\\n        // store BST elements in inorder form inside in array\\n        inorder(root, in);\\n        int st = 0, end = in.size()-1;\\n        \\n        // creating balanced bst\\n         TreeNode * newRoot = balancedBST(st, end, in);\\n        return newRoot;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2192937,
                "title": "python-easy-to-understand",
                "content": "**Intuition**\\nWe need to store the values stored in the given BST into an array in ascending order. \\nWe can achieve that by inorder traversal.\\n\\nNext we perform a pre-order traversal on the array and insert the values as nodes accordingly.\\n\\n**Solution**\\n1. Create a function `extract()` that will take values from the given BST and insert them in ascending order into an array.\\n2. Create a funtion `makeTree()` that takes the array and calls a function `makeTreeUtil()`.\\n3. `makeTreeUtil()` will take the middle value and insert it as the root node and then recursively call itself and assign the left and right child accordingly.\\n4. Return `self.makeTree(root)` in the return function of `balanceBST()`.\\n\\n***Code***\\n```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        return self.makeTree(root)\\n    \\n    def makeTreeUtil(self, arr, left, right):\\n        if left>right:\\n            return None\\n        \\n        mid = (right+left)//2\\n        \\n        node = TreeNode(arr[mid])\\n        node.left = self.makeTreeUtil(arr, left, mid-1)\\n        node.right = self.makeTreeUtil(arr , mid+1, right)\\n        \\n        return node\\n    \\n    \\n    def makeTree(self, root):\\n        arr= self.extract(root, [])\\n        return self.makeTreeUtil(arr, 0, len(arr)-1)\\n    \\n    \\n    def extract(self, node, arr):\\n        if not node:\\n            return\\n        self.extract(node.left, arr)\\n        arr.append(node.val)\\n        self.extract(node.right, arr) \\n        return arr\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        return self.makeTree(root)\\n    \\n    def makeTreeUtil(self, arr, left, right):\\n        if left>right:\\n            return None\\n        \\n        mid = (right+left)//2\\n        \\n        node = TreeNode(arr[mid])\\n        node.left = self.makeTreeUtil(arr, left, mid-1)\\n        node.right = self.makeTreeUtil(arr , mid+1, right)\\n        \\n        return node\\n    \\n    \\n    def makeTree(self, root):\\n        arr= self.extract(root, [])\\n        return self.makeTreeUtil(arr, 0, len(arr)-1)\\n    \\n    \\n    def extract(self, node, arr):\\n        if not node:\\n            return\\n        self.extract(node.left, arr)\\n        arr.append(node.val)\\n        self.extract(node.right, arr) \\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137310,
                "title": "python-inorder",
                "content": "```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        x=[]\\n        def g(r):\\n            if not r:return 0\\n            g(r.left)\\n            x.append(r.val)\\n            g(r.right)\\n        def f(i,j):\\n            if i>j:return \\n            m=(i+j)//2\\n            r=TreeNode(x[m])\\n            if i==j:return r\\n            r.left=f(i,m-1)\\n            r.right=f(m+1,j)\\n            return r\\n        g(root)\\n        return f(0,len(x)-1)\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        x=[]\\n        def g(r):\\n            if not r:return 0\\n            g(r.left)\\n            x.append(r.val)\\n            g(r.right)\\n        def f(i,j):\\n            if i>j:return \\n            m=(i+j)//2\\n            r=TreeNode(x[m])\\n            if i==j:return r\\n            r.left=f(i,m-1)\\n            r.right=f(m+1,j)\\n            return r\\n        g(root)\\n        return f(0,len(x)-1)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127029,
                "title": "c-inorder-recursion",
                "content": "form a vector from inorder traversal , & this will be sorted as , inorder traversal gives sorted vector.\\nFrom this we will buid a tree recursively by finding middle of the vector\\n```\\nclass Solution {\\npublic:\\n   \\n    TreeNode* buildFromInorder(vector<int> v,int start, int end){\\n        if(start>end)\\n            return NULL;\\n        \\n        int mid=(start+end)/2;\\n        TreeNode* root=new TreeNode(v[mid]);\\n        \\n        root->left= buildFromInorder(v,start,mid-1);\\n        root->right= buildFromInorder(v,mid+1,end);\\n        \\n        return root;\\n        \\n        \\n    }\\n    void inorder(TreeNode* root, vector<int> &v){\\n        if(!root)\\n            return ;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> v;\\n        inorder(root,v);\\n\\n       return  buildFromInorder(v,0,v.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    TreeNode* buildFromInorder(vector<int> v,int start, int end){\\n        if(start>end)\\n            return NULL;\\n        \\n        int mid=(start+end)/2;\\n        TreeNode* root=new TreeNode(v[mid]);\\n        \\n        root->left= buildFromInorder(v,start,mid-1);\\n        root->right= buildFromInorder(v,mid+1,end);\\n        \\n        return root;\\n        \\n        \\n    }\\n    void inorder(TreeNode* root, vector<int> &v){\\n        if(!root)\\n            return ;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> v;\\n        inorder(root,v);\\n\\n       return  buildFromInorder(v,0,v.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099010,
                "title": "golang",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc InOrder(root *TreeNode, arr *[]int) {\\n    if root==nil {\\n        return\\n    }\\n    InOrder(root.Left, arr)\\n    *arr=append(*arr, root.Val)\\n    InOrder(root.Right, arr)\\n    \\n}\\n\\nfunc createBalancedBST(A []int, l, r int) *TreeNode {\\n    if l>r {\\n        return nil\\n    }\\n    m:=(l+r)/2\\n    root:=&TreeNode{Val: A[m]}\\n    root.Left=createBalancedBST(A, l, m-1)\\n    root.Right=createBalancedBST(A, m+1, r)\\n    return root\\n}\\n\\nfunc balanceBST(root *TreeNode) *TreeNode {\\n    var arr []int\\n    InOrder(root, &arr)\\n    result:=createBalancedBST(arr, 0, len(arr)-1)\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc InOrder(root *TreeNode, arr *[]int) {\\n    if root==nil {\\n        return\\n    }\\n    InOrder(root.Left, arr)\\n    *arr=append(*arr, root.Val)\\n    InOrder(root.Right, arr)\\n    \\n}\\n\\nfunc createBalancedBST(A []int, l, r int) *TreeNode {\\n    if l>r {\\n        return nil\\n    }\\n    m:=(l+r)/2\\n    root:=&TreeNode{Val: A[m]}\\n    root.Left=createBalancedBST(A, l, m-1)\\n    root.Right=createBalancedBST(A, m+1, r)\\n    return root\\n}\\n\\nfunc balanceBST(root *TreeNode) *TreeNode {\\n    var arr []int\\n    InOrder(root, &arr)\\n    result:=createBalancedBST(arr, 0, len(arr)-1)\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2098593,
                "title": "easy-java-solution-with-comments",
                "content": "```\\n\\nclass Solution {\\n    List<Integer> arr = new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n        //creating sorted array from bst using Inorder\\n        inorder(root);\\n        // creating bst from sorted arr\\n        return bst(0,arr.size()-1);\\n    }\\n\\n//     creating bst\\n    public TreeNode bst(int start, int end){\\n        if(start>end) return null;\\n        int mid=(start+end)/2;\\n        TreeNode node= new TreeNode(arr.get(mid));\\n        node.left=bst(start,mid-1);\\n        node.right=bst(mid+1,end);\\n        return node;\\n    }\\n    //inorder mmethod\\n    public void inorder(TreeNode root){\\n        if(root==null) return;\\n        inorder(root.left);\\n        arr.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    List<Integer> arr = new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n        //creating sorted array from bst using Inorder\\n        inorder(root);\\n        // creating bst from sorted arr\\n        return bst(0,arr.size()-1);\\n    }\\n\\n//     creating bst\\n    public TreeNode bst(int start, int end){\\n        if(start>end) return null;\\n        int mid=(start+end)/2;\\n        TreeNode node= new TreeNode(arr.get(mid));\\n        node.left=bst(start,mid-1);\\n        node.right=bst(mid+1,end);\\n        return node;\\n    }\\n    //inorder mmethod\\n    public void inorder(TreeNode root){\\n        if(root==null) return;\\n        inorder(root.left);\\n        arr.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096187,
                "title": "c-inorder-list-recursive-bst-build",
                "content": "```\\npublic class Solution {\\n    public TreeNode BalanceBST(TreeNode root) {\\n        List<int> treeList=InorderTraverse(root,new List<int>());\\n        return BuildBST(treeList,0,treeList.Count-1);\\n    }\\n\\t\\n    private TreeNode BuildBST(List<int> list,int l,int r){\\n\\t\\t//This is base case, you can\\'t build a tree at this point so return null\\n        if(l>r){return null;}\\n\\t\\t\\n        int mid=l+(r-l)/2;\\n\\t\\t//make the middle element root\\n        TreeNode root=new TreeNode(list[mid]);\\n\\t\\t//from left end to mid-1 will be left sub-tree\\n        root.left=BuildBST(list,l,mid-1);\\n\\t\\t//from mid+1 to right end will be right sub tree\\n        root.right=BuildBST(list,mid+1,r);\\n\\t\\t\\n        return root;\\n    }\\n\\t\\n\\t// Do in-order traversal and convert to list\\n    private List<int> InorderTraverse(TreeNode root,List<int> list){\\n        if(root==null){\\n            return list;\\n        }\\n        InorderTraverse(root.left,list);\\n        list.Add(root.val);\\n        InorderTraverse(root.right,list);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public TreeNode BalanceBST(TreeNode root) {\\n        List<int> treeList=InorderTraverse(root,new List<int>());\\n        return BuildBST(treeList,0,treeList.Count-1);\\n    }\\n\\t\\n    private TreeNode BuildBST(List<int> list,int l,int r){\\n\\t\\t//This is base case, you can\\'t build a tree at this point so return null\\n        if(l>r){return null;}\\n\\t\\t\\n        int mid=l+(r-l)/2;\\n\\t\\t//make the middle element root\\n        TreeNode root=new TreeNode(list[mid]);\\n\\t\\t//from left end to mid-1 will be left sub-tree\\n        root.left=BuildBST(list,l,mid-1);\\n\\t\\t//from mid+1 to right end will be right sub tree\\n        root.right=BuildBST(list,mid+1,r);\\n\\t\\t\\n        return root;\\n    }\\n\\t\\n\\t// Do in-order traversal and convert to list\\n    private List<int> InorderTraverse(TreeNode root,List<int> list){\\n        if(root==null){\\n            return list;\\n        }\\n        InorderTraverse(root.left,list);\\n        list.Add(root.val);\\n        InorderTraverse(root.right,list);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090256,
                "title": "python-python-solution-inorder-recursion",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        def inorder(node):\\n            return inorder(node.left) + [node.val] + inorder(node.right) if node else []\\n        def bst(v):\\n            if not v:\\n                return None\\n            mid = len(v) // 2\\n            root = TreeNode(v[mid])\\n            root.left = bst(v[:mid])\\n            root.right = bst(v[mid + 1:])\\n            return root\\n        v = inorder(root)\\n        return bst(v)\\n",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        def inorder(node):\\n            return inorder(node.left) + [node.val] + inorder(node.right) if node else []\\n        def bst(v):\\n            if not v:\\n                return None\\n            mid = len(v) // 2\\n            root = TreeNode(v[mid])\\n            root.left = bst(v[:mid])\\n            root.right = bst(v[mid + 1:])\\n            return root\\n        v = inorder(root)\\n        return bst(v)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2049361,
                "title": "java-visualization-balance-a-binary-search-tree",
                "content": "**Algorithm:**\\n1. Convert BST to a sorted array using Inorder traversal\\n2. Build the balanced BST from sorted array.\\n    - Recursively choose the middle element of the sorted array as the root of the balanced BST\\n    - All the elements on the left of the middle element will be part of left subtree and elements on the right of the middle element will be part of right subtree\\n\\n**Visualization:**\\n\\n![image](https://assets.leetcode.com/users/images/717c400d-3711-48fe-ba83-a71557ccffd8_1652829347.4040399.png)\\n\\n**Code:**\\n```\\nclass Solution {\\n    List<Integer> sortedArray = new ArrayList();\\n    public TreeNode balanceBST(TreeNode root) {\\n        inorder(root);\\n        return construct(0, sortedArray.size()-1);\\n    }\\n    \\n    private TreeNode construct(int start, int end){\\n        if(start>end) return null;\\n        int mid = (end+start)/2;\\n        TreeNode root = new TreeNode(sortedArray.get(mid));\\n        root.left = construct(start, mid - 1);\\n        root.right = construct(mid+1, end);\\n        return root;\\n    }\\n    \\n    private void inorder(TreeNode root){\\n        if(root==null) return;\\n        inorder(root.left);\\n        sortedArray.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n```\\n\\n**Complexity:**\\n\\nTime Complexity :    O(N)\\nSpace Complexity :  O(N)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> sortedArray = new ArrayList();\\n    public TreeNode balanceBST(TreeNode root) {\\n        inorder(root);\\n        return construct(0, sortedArray.size()-1);\\n    }\\n    \\n    private TreeNode construct(int start, int end){\\n        if(start>end) return null;\\n        int mid = (end+start)/2;\\n        TreeNode root = new TreeNode(sortedArray.get(mid));\\n        root.left = construct(start, mid - 1);\\n        root.right = construct(mid+1, end);\\n        return root;\\n    }\\n    \\n    private void inorder(TreeNode root){\\n        if(root==null) return;\\n        inorder(root.left);\\n        sortedArray.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018226,
                "title": "mergesort-2-ms-java",
                "content": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list = new ArrayList();\\n        inOrder(root,list);\\n        return makeTree(list,0,list.size() - 1);\\n    }\\n    public TreeNode makeTree(ArrayList<Integer> list, int low, int high){\\n        if(low > high){\\n            return null;\\n        }   \\n        int middle = low + (high - low)/2;\\n        TreeNode node = new TreeNode(list.get(middle));\\n        node.left= makeTree(list,low,middle - 1);\\n        node.right= makeTree(list,middle + 1,high);\\n        return node;\\n    }\\n    \\n    public void inOrder(TreeNode root,ArrayList<Integer> list){\\n        if(root == null){\\n            return;\\n        }\\n        inOrder(root.left,list);\\n        list.add(root.val);\\n        inOrder(root.right,list);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list = new ArrayList();\\n        inOrder(root,list);\\n        return makeTree(list,0,list.size() - 1);\\n    }\\n    public TreeNode makeTree(ArrayList<Integer> list, int low, int high){\\n        if(low > high){\\n            return null;\\n        }   \\n        int middle = low + (high - low)/2;\\n        TreeNode node = new TreeNode(list.get(middle));\\n        node.left= makeTree(list,low,middle - 1);\\n        node.right= makeTree(list,middle + 1,high);\\n        return node;\\n    }\\n    \\n    public void inOrder(TreeNode root,ArrayList<Integer> list){\\n        if(root == null){\\n            return;\\n        }\\n        inOrder(root.left,list);\\n        list.add(root.val);\\n        inOrder(root.right,list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011059,
                "title": "balance-a-binary-search-tree-java-inorder",
                "content": "#### **Balance a Binary Search Tree**\\n```\\nclass Solution {\\n    \\n    private void inorder(TreeNode root, List<TreeNode> nodes) {\\n        if (root != null) {\\n            inorder(root.left, nodes);\\n            root.left = null;\\n            nodes.add(root);\\n            inorder(root.right, nodes);\\n            root.right = null;\\n        }\\n    }\\n    \\n    private TreeNode create(List<TreeNode> nodes, int start, int end) {\\n        if (start > end) return null;\\n        if (start == end) {\\n            return nodes.get(start);\\n        }\\n        int mid = start + (end - start) / 2;\\n        nodes.get(mid).left = create(nodes, start, mid-1);\\n        nodes.get(mid).right = create(nodes, mid+1, end);\\n        return nodes.get(mid);\\n    }\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        List<TreeNode> nodes = new ArrayList<>();\\n        inorder(root, nodes);\\n        return create(nodes, 0, nodes.size() - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private void inorder(TreeNode root, List<TreeNode> nodes) {\\n        if (root != null) {\\n            inorder(root.left, nodes);\\n            root.left = null;\\n            nodes.add(root);\\n            inorder(root.right, nodes);\\n            root.right = null;\\n        }\\n    }\\n    \\n    private TreeNode create(List<TreeNode> nodes, int start, int end) {\\n        if (start > end) return null;\\n        if (start == end) {\\n            return nodes.get(start);\\n        }\\n        int mid = start + (end - start) / 2;\\n        nodes.get(mid).left = create(nodes, start, mid-1);\\n        nodes.get(mid).right = create(nodes, mid+1, end);\\n        return nodes.get(mid);\\n    }\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        List<TreeNode> nodes = new ArrayList<>();\\n        inorder(root, nodes);\\n        return create(nodes, 0, nodes.size() - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999966,
                "title": "c-easy-clear-understanding",
                "content": "class Solution {\\npublic:\\n    \\n    void inorder(TreeNode* root,vector<TreeNode*> &vec)\\n    {\\n        if(!root)\\n            return;\\n        \\n        inorder(root->left,vec);\\n        vec.push_back(root);\\n        inorder(root->right,vec);\\n        \\n        \\n    }\\n    \\n    TreeNode* convert(vector<TreeNode*> &vec,int start,int end)\\n    {\\n        if(start > end)\\n            return NULL;\\n        \\n        int mid = (start+end)/2;\\n        TreeNode* root = vec[mid];\\n        \\n        root->left  = convert(vec,start,mid-1);\\n        root->right = convert(vec,mid+1,end);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        \\n        vector<TreeNode*> vec;\\n        \\n        inorder(root,vec);\\n        int n=vec.size();\\n        \\n        return convert(vec,0,n-1);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void inorder(TreeNode* root,vector<TreeNode*> &vec)\\n    {\\n        if(!root)\\n            return;\\n        \\n        inorder(root->left,vec);\\n        vec.push_back(root);\\n        inorder(root->right,vec);\\n        \\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1944795,
                "title": "java-in-place-solution-using-rotations",
                "content": "class Solution {\\n\\n    public TreeNode balanceBST(TreeNode root) {\\n        if (root == null) return null;\\n        \\n        TreeNode parent = new TreeNode(0);\\n        parent.left = root;\\n        balance(parent.left, parent);\\n        return parent.left;\\n    }\\n    \\n    private void balance(TreeNode node, TreeNode parent) {\\n        if (node == null) return;\\n        balance(node.left, node); \\n        balance(node.right, node);\\n            \\n        int bal = getBalance(node);\\n        if (bal > 1) {\\n            if (getBalance(node.left) < 0) {\\n                rotateLeft(node.left, node); // LR\\n            }\\n            balance(rotateRight(node, parent), parent); // LL\\n        } else if (bal < -1) {\\n            if (getBalance(node.right) > 0) {\\n                rotateRight(node.right, node); // RL\\n            }\\n            balance(rotateLeft(node, parent), parent); // RR\\n        }\\n    }\\n    \\n    private TreeNode rotateLeft(TreeNode x, TreeNode parent) {\\n        TreeNode y = x.right;\\n        x.right = y.left;\\n        y.left = x;\\n        \\n        if (parent.left == x) parent.left = y;\\n        if (parent.right == x) parent.right = y;\\n        \\n        return y;\\n    }\\n    \\n    private TreeNode rotateRight(TreeNode x, TreeNode parent) {\\n        TreeNode y = x.left;\\n        x.left = y.right;\\n        y.right = x;\\n        \\n        if (parent.left == x) parent.left = y;\\n        if (parent.right == x) parent.right = y;\\n        \\n        return y;\\n    }\\n    \\n    private int getBalance(TreeNode node) {\\n        if (node == null) return 0;\\n        int l = getHeight(node.left);\\n        int r = getHeight(node.right);\\n        return l-r;\\n    }\\n    \\n    private int getHeight(TreeNode node) {\\n        if (node == null) return -1;\\n        int l = getHeight(node.left);\\n        int r = getHeight(node.right);\\n        return 1 + Math.max(l, r);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public TreeNode balanceBST(TreeNode root) {\\n        if (root == null) return null;\\n        \\n        TreeNode parent = new TreeNode(0);\\n        parent.left = root;\\n        balance(parent.left, parent);\\n        return parent.left;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1926483,
                "title": "java-2ms-faster-than-99",
                "content": "Steps:\\n1,  Create inorder array using inorder traversal algorithm\\n2. From inorder array create the balanced BST using recursion\\nTime complexity: O(n)\\nSpace complexity: O(n) (need an extra array and a new tree)\\n\\n```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        // Create the inorder array\\n        ArrayList<Integer> inorderArray = new ArrayList<>();\\n        buildInorderArrayFromBST(root, inorderArray);\\n        \\n        // Create the balanced BST from inorder array\\n        return createBalancedBST_FromInorderArray(inorderArray, 0, inorderArray.size() - 1);\\n    }\\n    \\n    public TreeNode createBalancedBST_FromInorderArray(ArrayList<Integer> inorderArray, int l, int r) {\\n        if (l > r) return null;\\n        \\n        int m = l + (r - l) / 2;\\n        TreeNode root = new TreeNode(inorderArray.get(m));\\n        root.left = createBalancedBST_FromInorderArray(inorderArray, l, m - 1);\\n        root.right = createBalancedBST_FromInorderArray(inorderArray, m + 1, r);\\n        \\n        return root;\\n    }\\n\\n    public void buildInorderArrayFromBST(TreeNode root, ArrayList<Integer> inorderArray) {\\n        if (root == null) return;\\n        \\n        buildInorderArrayFromBST(root.left, inorderArray);\\n        inorderArray.add(root.val);\\n        buildInorderArrayFromBST(root.right, inorderArray);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        // Create the inorder array\\n        ArrayList<Integer> inorderArray = new ArrayList<>();\\n        buildInorderArrayFromBST(root, inorderArray);\\n        \\n        // Create the balanced BST from inorder array\\n        return createBalancedBST_FromInorderArray(inorderArray, 0, inorderArray.size() - 1);\\n    }\\n    \\n    public TreeNode createBalancedBST_FromInorderArray(ArrayList<Integer> inorderArray, int l, int r) {\\n        if (l > r) return null;\\n        \\n        int m = l + (r - l) / 2;\\n        TreeNode root = new TreeNode(inorderArray.get(m));\\n        root.left = createBalancedBST_FromInorderArray(inorderArray, l, m - 1);\\n        root.right = createBalancedBST_FromInorderArray(inorderArray, m + 1, r);\\n        \\n        return root;\\n    }\\n\\n    public void buildInorderArrayFromBST(TreeNode root, ArrayList<Integer> inorderArray) {\\n        if (root == null) return;\\n        \\n        buildInorderArrayFromBST(root.left, inorderArray);\\n        inorderArray.add(root.val);\\n        buildInorderArrayFromBST(root.right, inorderArray);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1916738,
                "title": "typescript-simple-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     val: number\\n *     left: TreeNode | null\\n *     right: TreeNode | null\\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.left = (left===undefined ? null : left)\\n *         this.right = (right===undefined ? null : right)\\n *     }\\n * }\\n */\\n\\nfunction balanceBST(root: TreeNode | null): TreeNode | null {\\n    let arr = [];\\n    dfs(root,arr);\\n    let newRoot = null\\n    const generate = (i: number,j: number) => {\\n        if(i > j) return null;\\n        let mid = Math.floor((i+j)/2);\\n        let node = new TreeNode(arr[mid]);\\n        if(!newRoot)  newRoot = node;\\n        node.left = generate(i,mid-1);\\n        node.right = generate(mid+1,j);\\n        return node;\\n    }\\n    generate(0,arr.length-1);\\n    return newRoot;\\n};\\nfunction dfs(node: TreeNode | null,arr: number[]) {\\n    if(!node) return;\\n    dfs(node.left,arr);\\n    arr.push(node.val);\\n    dfs(node.right,arr);\\n}",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     val: number\\n *     left: TreeNode | null\\n *     right: TreeNode | null\\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.left = (left===undefined ? null : left)\\n *         this.right = (right===undefined ? null : right)\\n *     }\\n * }\\n */\\n\\nfunction balanceBST(root: TreeNode | null): TreeNode | null {\\n    let arr = [];\\n    dfs(root,arr);\\n    let newRoot = null\\n    const generate = (i: number,j: number) => {\\n        if(i > j) return null;\\n        let mid = Math.floor((i+j)/2);\\n        let node = new TreeNode(arr[mid]);\\n        if(!newRoot)  newRoot = node;\\n        node.left = generate(i,mid-1);\\n        node.right = generate(mid+1,j);\\n        return node;\\n    }\\n    generate(0,arr.length-1);\\n    return newRoot;\\n};\\nfunction dfs(node: TreeNode | null,arr: number[]) {\\n    if(!node) return;\\n    dfs(node.left,arr);\\n    arr.push(node.val);\\n    dfs(node.right,arr);\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1901269,
                "title": "dfs-easy-to-understand-63-2-mb-less-than-55-04-of-c-for-balance-a-binary-search-tree",
                "content": "# **[@iprincekumark](https://leetcode.com/iprincekumark/)**\\nVISIT MY PROFILE\\n**CODE**\\n```\\nvoid help(TreeNode* root, vector<int>& inorder) {\\n        if(root == NULL)\\n            return;\\n        help(root->left, inorder);\\n        inorder.push_back(root->val);\\n        help(root->right, inorder);\\n    }\\n    TreeNode* balance(vector<int>& inorder, int s, int e) {\\n        if(s>e)\\n            return NULL;\\n        int m = s + (e-s)/2;\\n        TreeNode* root = new TreeNode(inorder[m]);\\n        root->left = balance(inorder, s, m-1);\\n        root->right = balance(inorder, m+1, e);\\n        return root;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> inorder;\\n        help(root, inorder);\\n        return balance(inorder, 0, inorder.size()-1);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nvoid help(TreeNode* root, vector<int>& inorder) {\\n        if(root == NULL)\\n            return;\\n        help(root->left, inorder);\\n        inorder.push_back(root->val);\\n        help(root->right, inorder);\\n    }\\n    TreeNode* balance(vector<int>& inorder, int s, int e) {\\n        if(s>e)\\n            return NULL;\\n        int m = s + (e-s)/2;\\n        TreeNode* root = new TreeNode(inorder[m]);\\n        root->left = balance(inorder, s, m-1);\\n        root->right = balance(inorder, m+1, e);\\n        return root;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> inorder;\\n        help(root, inorder);\\n        return balance(inorder, 0, inorder.size()-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1897807,
                "title": "java-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        bstarray(root,arr);\\n        Collections.sort(arr);\\n        return balanceBSTfromarray(arr,0,arr.size()-1);\\n        \\n    }\\n    \\n    // Converting the Sorted Array into Balanced Tree\\n    public TreeNode balanceBSTfromarray(ArrayList<Integer> arr,int start,int end){\\n        if(start>end) return null;\\n        int mid = start + (end-start)/2;\\n        TreeNode root = new TreeNode(arr.get(mid));\\n        root.left = balanceBSTfromarray(arr,start,mid-1);\\n        root.right = balanceBSTfromarray(arr,mid+1,end);\\n        return root;\\n        \\n    }\\n    \\n    // Constructing the Array using the Unbalanced Binary tree\\n    public void bstarray(TreeNode root,ArrayList<Integer> arr){\\n        if(root==null) return;\\n        arr.add(root.val);\\n        bstarray(root.left,arr);\\n        bstarray(root.right,arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        bstarray(root,arr);\\n        Collections.sort(arr);\\n        return balanceBSTfromarray(arr,0,arr.size()-1);\\n        \\n    }\\n    \\n    // Converting the Sorted Array into Balanced Tree\\n    public TreeNode balanceBSTfromarray(ArrayList<Integer> arr,int start,int end){\\n        if(start>end) return null;\\n        int mid = start + (end-start)/2;\\n        TreeNode root = new TreeNode(arr.get(mid));\\n        root.left = balanceBSTfromarray(arr,start,mid-1);\\n        root.right = balanceBSTfromarray(arr,mid+1,end);\\n        return root;\\n        \\n    }\\n    \\n    // Constructing the Array using the Unbalanced Binary tree\\n    public void bstarray(TreeNode root,ArrayList<Integer> arr){\\n        if(root==null) return;\\n        arr.add(root.val);\\n        bstarray(root.left,arr);\\n        bstarray(root.right,arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892577,
                "title": "c-recursive-solution",
                "content": "**Please do upvote if it helps you!**\\n**First of all we store the values of the nodes of tree in a vector(using inordered traversal) in a sorted manner..and then we will make another function which will convert the sorted array in height balanced bst\\nNow this helper function will calculate the mid value and make a node(root) out of it and then root->left will be vector left part from mid and root->right will be vector right part after mid\\nand this is how a height balanced bst will be formed!\\nand ofcourse consider the edge cases**\\n\\n * };\\n */\\nclass Solution {\\n    void inorder(TreeNode *root,vector<int>&v)\\n    {\\n\\t\\n        if(root)\\n        {\\n            inorder(root->left,v);\\n            v.push_back(root->val);\\n            inorder(root->right,v);\\n        }\\n    }\\n    TreeNode* helper(vector<int>&v,int low,int high)\\n    {\\n\\t\\n        int size=high-low;\\n        if(size<0)return NULL;\\n        if(size==0) return new TreeNode(v[low]);\\n        int mid=(low+high)/2;\\n        TreeNode *root=new TreeNode(v[mid]);\\n        root->left=helper(v,low,mid-1);\\n        root->right=helper(v,mid+1,high);\\n        return root;\\n    }\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n\\t\\n        vector<int>v;\\n        inorder(root,v);\\n       return helper(v,0,v.size()-1);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    void inorder(TreeNode *root,vector<int>&v)\\n    {\\n\\t\\n        if(root)\\n        {\\n            inorder(root->left,v);\\n            v.push_back(root->val);\\n            inorder(root->right,v);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1878298,
                "title": "c-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> nums;\\n    void inorder(TreeNode* root){ //First we write a function for inorder traversal of the tree  \\n        if(root){\\n        inorder(root->left);\\n        nums.push_back(root);// This snippet of code is tells if root exists in the binary tree first we go to the left child of the root and then we push the root into our vector nums and store it there ,and then move into the right child node of the root ,this is the basic recursive method fot inorder traversal.  \\n        inorder(root->right);\\n        }\\n    }\\n    TreeNode* solve(int start,int end)//This is the solving function we use to balance the tree,in this function we take 2 parameters start and end to denote the start and end points of our nums vector ,then we find out the mid variable and and the element in the middle of the vector nums is made the root of the tree.Then the left and right child nodes are chosen using the same solve function by taking mid-1 and mid+1 as the ending and starting points respectively. \\n    {\\n        if(start>end)\\n            return NULL; \\n        int mid=(start+end)/2;\\n        TreeNode *root=nums[mid];\\n    \\n        root->left=solve(start,mid-1);\\n        root->right=solve(mid+1,end);\\n        return root;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorder(root);\\n        return solve(0,nums.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> nums;\\n    void inorder(TreeNode* root){ //First we write a function for inorder traversal of the tree  \\n        if(root){\\n        inorder(root->left);\\n        nums.push_back(root);// This snippet of code is tells if root exists in the binary tree first we go to the left child of the root and then we push the root into our vector nums and store it there ,and then move into the right child node of the root ,this is the basic recursive method fot inorder traversal.  \\n        inorder(root->right);\\n        }\\n    }\\n    TreeNode* solve(int start,int end)//This is the solving function we use to balance the tree,in this function we take 2 parameters start and end to denote the start and end points of our nums vector ,then we find out the mid variable and and the element in the middle of the vector nums is made the root of the tree.Then the left and right child nodes are chosen using the same solve function by taking mid-1 and mid+1 as the ending and starting points respectively. \\n    {\\n        if(start>end)\\n            return NULL; \\n        int mid=(start+end)/2;\\n        TreeNode *root=nums[mid];\\n    \\n        root->left=solve(start,mid-1);\\n        root->right=solve(mid+1,end);\\n        return root;\\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorder(root);\\n        return solve(0,nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844708,
                "title": "simple-c-and-java-solution-easy",
                "content": "***C++***\\n```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* tobbst(vector<int>& v, int l, int r) {\\n        if(l>r) {\\n            return NULL;\\n        }\\n        int mid = (l+r)/2;\\n        TreeNode* root = new TreeNode(v[mid]);\\n        root->left = tobbst( v, l, mid-1);\\n        root->right = tobbst( v, mid+1, r);\\n        return root;\\n    }\\n    \\n    void inorder(TreeNode* root, vector<int>& v) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        inorder(root->left, v);\\n        v.push_back(root->val);\\n        inorder(root->right, v);\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> v;\\n        inorder(root, v);\\n        return tobbst(v, 0, v.size()-1);\\n    }\\n};\\n```\\n\\n***Java***\\n\\n```\\nclass Solution {\\n    public TreeNode solve(List<Integer> l, int s, int e) {\\n        if(s>e) {\\n            return null;\\n        }\\n        int m = s + (e-s)/2;\\n        TreeNode root = new TreeNode(l.get(m));\\n        root.left = solve(l, s, m-1);\\n        root.right = solve(l, m+1, e);\\n        return root;\\n    }\\n    public void inorder(TreeNode root, List<Integer>l) {\\n        if(root == null) {return ;}\\n        inorder(root.left, l);\\n        l.add(root.val);\\n        inorder(root.right, l);\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        List<Integer> l = new ArrayList<>();\\n        inorder(root, l);\\n        return solve(l, 0, l.size()-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* tobbst(vector<int>& v, int l, int r) {\\n        if(l>r) {\\n            return NULL;\\n        }\\n        int mid = (l+r)/2;\\n        TreeNode* root = new TreeNode(v[mid]);\\n        root->left = tobbst( v, l, mid-1);\\n        root->right = tobbst( v, mid+1, r);\\n        return root;\\n    }\\n    \\n    void inorder(TreeNode* root, vector<int>& v) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        inorder(root->left, v);\\n        v.push_back(root->val);\\n        inorder(root->right, v);\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> v;\\n        inorder(root, v);\\n        return tobbst(v, 0, v.size()-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public TreeNode solve(List<Integer> l, int s, int e) {\\n        if(s>e) {\\n            return null;\\n        }\\n        int m = s + (e-s)/2;\\n        TreeNode root = new TreeNode(l.get(m));\\n        root.left = solve(l, s, m-1);\\n        root.right = solve(l, m+1, e);\\n        return root;\\n    }\\n    public void inorder(TreeNode root, List<Integer>l) {\\n        if(root == null) {return ;}\\n        inorder(root.left, l);\\n        l.add(root.val);\\n        inorder(root.right, l);\\n    }\\n    public TreeNode balanceBST(TreeNode root) {\\n        List<Integer> l = new ArrayList<>();\\n        inorder(root, l);\\n        return solve(l, 0, l.size()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839967,
                "title": "java-simple-easy-solution",
                "content": "```\\nclass Solution {\\n    List<TreeNode> list=new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n        inorder(root);\\n        return makeBinaryTree(list);     \\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null)\\n            return;\\n        inorder(root.left);\\n        list.add(root);\\n        inorder(root.right);\\n    }\\n    public TreeNode makeBinaryTree(List<TreeNode> list){\\n        if(list.size()==0 || list==null)\\n            return null;\\n        int mid=list.size()/2;\\n        TreeNode root=list.get(mid);\\n        root.left=makeBinaryTree(list.subList(0,mid));\\n        root.right=makeBinaryTree(list.subList(mid+1,list.size()));\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<TreeNode> list=new ArrayList<>();\\n    public TreeNode balanceBST(TreeNode root) {\\n        inorder(root);\\n        return makeBinaryTree(list);     \\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null)\\n            return;\\n        inorder(root.left);\\n        list.add(root);\\n        inorder(root.right);\\n    }\\n    public TreeNode makeBinaryTree(List<TreeNode> list){\\n        if(list.size()==0 || list==null)\\n            return null;\\n        int mid=list.size()/2;\\n        TreeNode root=list.get(mid);\\n        root.left=makeBinaryTree(list.subList(0,mid));\\n        root.right=makeBinaryTree(list.subList(mid+1,list.size()));\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834021,
                "title": "normal-bst-to-balance-bst",
                "content": "```\\nclass Solution {\\nprivate:\\n    void inOrder(TreeNode* root, vector<int>& v){\\n        if(root==NULL)\\n            return ;\\n        \\n        inOrder(root->left,v);\\n        v.push_back(root->val);\\n        inOrder(root->right,v);\\n    }\\n    \\n    TreeNode* inorderToBst(vector<int> v,int s,int e){\\n        if(s>e)\\n            return NULL;\\n        \\n        int mid = (s+e)/2;\\n        TreeNode* root = new TreeNode(v[mid]);\\n        root->left = inorderToBst(v,s,mid-1);\\n        root->right = inorderToBst(v,mid+1,e);\\n        return root;\\n    }\\n    \\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> v;\\n        \\n        // storing elment in vector in sorted order using inorder traversal\\n        inOrder(root,v);\\n        \\n        //Forming a Balanced Binary Search Tree\\n        return inorderToBst(v,0,v.size()-1);\\n    }\\n};\\n```\\n\\nTime Complexity : O(n)\\nSpace Complexity:O(n)",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void inOrder(TreeNode* root, vector<int>& v){\\n        if(root==NULL)\\n            return ;\\n        \\n        inOrder(root->left,v);\\n        v.push_back(root->val);\\n        inOrder(root->right,v);\\n    }\\n    \\n    TreeNode* inorderToBst(vector<int> v,int s,int e){\\n        if(s>e)\\n            return NULL;\\n        \\n        int mid = (s+e)/2;\\n        TreeNode* root = new TreeNode(v[mid]);\\n        root->left = inorderToBst(v,s,mid-1);\\n        root->right = inorderToBst(v,mid+1,e);\\n        return root;\\n    }\\n    \\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> v;\\n        \\n        // storing elment in vector in sorted order using inorder traversal\\n        inOrder(root,v);\\n        \\n        //Forming a Balanced Binary Search Tree\\n        return inorderToBst(v,0,v.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833435,
                "title": "c-latest-code-with-hindi-explaination",
                "content": "```\\n\\tvoid inorder(TreeNode* root , vector<int> &v )\\n    {\\n        if( root == NULL )\\n            return ;\\n\\n        inorder( root->left , v ) ;\\n        v.push_back( root->val ) ;\\n        inorder( root->right , v ) ;\\n    }\\n\\n\\n    TreeNode* inorderToBST(  int s , int e , vector<int> &v )\\n    {\\n        if( s > e  )\\n            return NULL ;\\n\\n        int mid = (s+e)/2 ;       //mid nikalakar left part me small element daal do right me \\n                                //mid ke right side wale (bade) elements daal do \\n\\n        TreeNode* root = new TreeNode( v[mid] ) ; //mid hi BST ka 1st root node banega aur baaki ke mids node bante jayege \\n        root->left = inorderToBST( s , mid-1 , v) ;     //left-call \\n        root->right = inorderToBST( mid+1 , e , v) ;    //right-call\\n        \\n        \\n        return root ;\\n    }\\n\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n    vector<int>  v ;\\n\\tinorder( root , v ) ;\\n\\t\\n\\t//now mw vector is sorted so have have to break it in Two parts . smaal in left & big in right \\n\\treturn inorderToBST(  0 , v.size()-1 , v ) ;\\n\\t                   // tart ,  end ,   vector \\n        \\n    }\\n\\t\\n\\t\\n\\tcredit : @love_Babbar @CodeHelp ```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\tvoid inorder(TreeNode* root , vector<int> &v )\\n    {\\n        if( root == NULL )\\n            return ;\\n\\n        inorder( root->left , v ) ;\\n        v.push_back( root->val ) ;\\n        inorder( root->right , v ) ;\\n    }\\n\\n\\n    TreeNode* inorderToBST(  int s , int e , vector<int> &v )\\n    {\\n        if( s > e  )\\n            return NULL ;\\n\\n        int mid = (s+e)/2 ;       //mid nikalakar left part me small element daal do right me \\n                                //mid ke right side wale (bade) elements daal do \\n\\n        TreeNode* root = new TreeNode( v[mid] ) ; //mid hi BST ka 1st root node banega aur baaki ke mids node bante jayege \\n        root->left = inorderToBST( s , mid-1 , v) ;     //left-call \\n        root->right = inorderToBST( mid+1 , e , v) ;    //right-call\\n        \\n        \\n        return root ;\\n    }\\n\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n    vector<int>  v ;\\n\\tinorder( root , v ) ;\\n\\t\\n\\t//now mw vector is sorted so have have to break it in Two parts . smaal in left & big in right \\n\\treturn inorderToBST(  0 , v.size()-1 , v ) ;\\n\\t                   // tart ,  end ,   vector \\n        \\n    }\\n\\t\\n\\t\\n\\tcredit : @love_Babbar @CodeHelp ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1830686,
                "title": "javascript-in-order-traverse-o-n",
                "content": "```\\nvar balanceBST = function(root) {\\n    var arr = [];\\n    traverse(root, arr);\\n    return construct(arr);\\n};\\n\\nvar construct = function(arr) {\\n    if (arr.length == 0) {\\n        return null;\\n    }\\n    \\n    var middle = parseInt(arr.length / 2);\\n    \\n    return new TreeNode(arr[middle], construct(arr.slice(0, middle)), construct(arr.slice(middle + 1)));\\n};\\n\\nvar traverse = function(root, arr) {\\n    if (root == null) {\\n        return;\\n    }\\n    \\n    traverse(root.left, arr);\\n    arr.push(root.val);\\n    traverse(root.right, arr);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar balanceBST = function(root) {\\n    var arr = [];\\n    traverse(root, arr);\\n    return construct(arr);\\n};\\n\\nvar construct = function(arr) {\\n    if (arr.length == 0) {\\n        return null;\\n    }\\n    \\n    var middle = parseInt(arr.length / 2);\\n    \\n    return new TreeNode(arr[middle], construct(arr.slice(0, middle)), construct(arr.slice(middle + 1)));\\n};\\n\\nvar traverse = function(root, arr) {\\n    if (root == null) {\\n        return;\\n    }\\n    \\n    traverse(root.left, arr);\\n    arr.push(root.val);\\n    traverse(root.right, arr);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1794229,
                "title": "c-inorder-traversal-clean-code",
                "content": "middle element of the inorder traversal becomes the root recursively\\n\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> inorder;\\n    \\n    \\n    void iorder(TreeNode* root){\\n        if(root == NULL)return;\\n        iorder(root->left);\\n        inorder.push_back(root);\\n        iorder(root->right);\\n    }\\n    \\n    TreeNode* solve(int start,int end){\\n        if(start>end)return NULL;\\n        int mid = (start+end)/2;\\n        TreeNode* root = inorder[mid];\\n        root->left = solve(start,mid-1);\\n        root->right = solve(mid+1,end);\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {     \\n        iorder(root);\\n        TreeNode* Root = solve(0,inorder.size()-1);\\n        return Root;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<TreeNode*> inorder;\\n    \\n    \\n    void iorder(TreeNode* root){\\n        if(root == NULL)return;\\n        iorder(root->left);\\n        inorder.push_back(root);\\n        iorder(root->right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1774926,
                "title": "c-inorder-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* &root,vector<TreeNode*>&in){\\n        if(!root)\\n            return ;\\n        inorder(root->left,in);\\n        in.push_back(root);\\n        inorder(root->right,in);\\n    }\\n    TreeNode* buildBst(vector<TreeNode*>&in,int start,int end){\\n        if(start>end)\\n            return NULL;\\n        int mid=(start+end)/2;\\n        \\n            TreeNode* root1=in[mid];//in is already storing the node so no need to create another new node;\\n            root1->left=buildBst(in,start,mid-1);//mid already taken in root1;\\n            root1->right=buildBst(in,mid+1,end);\\n            return root1;\\n        \\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*>in;\\n        inorder(root,in);\\n        return buildBst(in,0,in.size()-1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* &root,vector<TreeNode*>&in){\\n        if(!root)\\n            return ;\\n        inorder(root->left,in);\\n        in.push_back(root);\\n        inorder(root->right,in);\\n    }\\n    TreeNode* buildBst(vector<TreeNode*>&in,int start,int end){\\n        if(start>end)\\n            return NULL;\\n        int mid=(start+end)/2;\\n        \\n            TreeNode* root1=in[mid];//in is already storing the node so no need to create another new node;\\n            root1->left=buildBst(in,start,mid-1);//mid already taken in root1;\\n            root1->right=buildBst(in,mid+1,end);\\n            return root1;\\n        \\n    }\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*>in;\\n        inorder(root,in);\\n        return buildBst(in,0,in.size()-1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763118,
                "title": "c-simple-array-to-bst",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> elems;\\n        collect(root, elems);\\n        return build(elems.cbegin(), elems.cend());\\n    }\\n    \\n    void collect(TreeNode *root, vector<int> &elems)\\n    {\\n        if (!root) return;\\n        collect(root->left, elems);\\n        elems.push_back(root->val);\\n        collect(root->right, elems);\\n    }\\n    \\n    TreeNode *build(vector<int>::const_iterator s, vector<int>::const_iterator e)\\n    {\\n        if (s >= e) return nullptr;\\n        const auto mid = s + (e - s) / 2;\\n        return new TreeNode(*mid, build(s, mid), build(next(mid), e));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<int> elems;\\n        collect(root, elems);\\n        return build(elems.cbegin(), elems.cend());\\n    }\\n    \\n    void collect(TreeNode *root, vector<int> &elems)\\n    {\\n        if (!root) return;\\n        collect(root->left, elems);\\n        elems.push_back(root->val);\\n        collect(root->right, elems);\\n    }\\n    \\n    TreeNode *build(vector<int>::const_iterator s, vector<int>::const_iterator e)\\n    {\\n        if (s >= e) return nullptr;\\n        const auto mid = s + (e - s) / 2;\\n        return new TreeNode(*mid, build(s, mid), build(next(mid), e));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734065,
                "title": "python-easy-recursive-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n\\t\\n        def inorder_t(root):\\n            \\n            if not root: return []\\n            \\n            return inorder_t(root.left)+[root.val]+inorder_t(root.right)\\n                \\n        inorder=inorder_t(root)\\n        \\n        def balance_tree(s,e):\\n            \\n            if s>e:\\n                return None\\n            \\n            mid=(s+e)//2\\n            root=TreeNode(inorder[mid])\\n            root.left=balance_tree(s,mid-1)\\n            root.right=balance_tree(mid+1,e)\\n                \\n            return root\\n            \\n        return balance_tree(0,len(inorder)-1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n\\t\\n        def inorder_t(root):\\n            \\n            if not root: return []\\n            \\n            return inorder_t(root.left)+[root.val]+inorder_t(root.right)\\n                \\n        inorder=inorder_t(root)\\n        \\n        def balance_tree(s,e):\\n            \\n            if s>e:\\n                return None\\n            \\n            mid=(s+e)//2\\n            root=TreeNode(inorder[mid])\\n            root.left=balance_tree(s,mid-1)\\n            root.right=balance_tree(mid+1,e)\\n                \\n            return root\\n            \\n        return balance_tree(0,len(inorder)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731554,
                "title": "c-easy-solution-inorder-traversal",
                "content": "```\\nclass Solution {\\n    vector<TreeNode*> inOrder;\\n    \\n    void makeArr(TreeNode* root){// make Inorder array //O(N) TC\\n        if(!root)\\n            return;\\n        makeArr(root->left);\\n        inOrder.push_back(root);\\n        makeArr(root->right);\\n    }\\n    \\n    TreeNode* reArrange(int a, int b){\\n        if(a>b)\\n            return NULL;\\n        int mid = (a+b)/2;\\n        TreeNode* top = inOrder[mid];\\n        top->left = reArrange(a, mid-1);\\n        top->right = reArrange(mid+1, b);\\n        return top;\\n    }\\n    \\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inOrder = {};\\n        makeArr(root);\\n        return reArrange(0, (int)(inOrder.size()-1));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<TreeNode*> inOrder;\\n    \\n    void makeArr(TreeNode* root){// make Inorder array //O(N) TC\\n        if(!root)\\n            return;\\n        makeArr(root->left);\\n        inOrder.push_back(root);\\n        makeArr(root->right);\\n    }\\n    \\n    TreeNode* reArrange(int a, int b){\\n        if(a>b)\\n            return NULL;\\n        int mid = (a+b)/2;\\n        TreeNode* top = inOrder[mid];\\n        top->left = reArrange(a, mid-1);\\n        top->right = reArrange(mid+1, b);\\n        return top;\\n    }\\n    \\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inOrder = {};\\n        makeArr(root);\\n        return reArrange(0, (int)(inOrder.size()-1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725734,
                "title": "best-python-solution-self-explained-easy-to-understand",
                "content": "```python\\n\"\"\"\\nImagine a list of sorted nodes, if we wanted to use the nodes to form a balanced BST, which root should we use?\\nYes, the one in the middle, since it can evenly spread two groups of nodes. This is what `getRoot()` does.\\nAnd we do the same for the left half and right half. And so on. And so on...\\n\\nTime: O(N), N is the number of nodes.\\nSpace: O(N)\\n\"\"\"\\nclass Solution(object):\\n    def balanceBST(self, root):\\n        def getInorderNodes(root):\\n            nodes = []\\n            stack = []\\n            node = root\\n            \\n            while node or stack:\\n                while node:\\n                    stack.append(node)\\n                    node = node.left\\n                \\n                node = stack.pop()\\n                nodes.append(node)\\n                node = node.right\\n            \\n            return nodes\\n                \\n        def getRoot(l, r):\\n            if l>r: return None\\n            m = (l+r)/2\\n            root = inorderNodes[m]\\n            root.left = getRoot(l, m-1)\\n            root.right = getRoot(m+1, r)\\n            return root\\n            \\n        inorderNodes = getInorderNodes(root)\\n        return getRoot(0, len(inorderNodes)-1)\\n\\t\\t\\n\"\"\"\\nFor interview preparation, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\nImagine a list of sorted nodes, if we wanted to use the nodes to form a balanced BST, which root should we use?\\nYes, the one in the middle, since it can evenly spread two groups of nodes. This is what `getRoot()` does.\\nAnd we do the same for the left half and right half. And so on. And so on...\\n\\nTime: O(N), N is the number of nodes.\\nSpace: O(N)\\n\"\"\"\\nclass Solution(object):\\n    def balanceBST(self, root):\\n        def getInorderNodes(root):\\n            nodes = []\\n            stack = []\\n            node = root\\n            \\n            while node or stack:\\n                while node:\\n                    stack.append(node)\\n                    node = node.left\\n                \\n                node = stack.pop()\\n                nodes.append(node)\\n                node = node.right\\n            \\n            return nodes\\n                \\n        def getRoot(l, r):\\n            if l>r: return None\\n            m = (l+r)/2\\n            root = inorderNodes[m]\\n            root.left = getRoot(l, m-1)\\n            root.right = getRoot(m+1, r)\\n            return root\\n            \\n        inorderNodes = getInorderNodes(root)\\n        return getRoot(0, len(inorderNodes)-1)\\n\\t\\t\\n\"\"\"\\nFor interview preparation, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1720230,
                "title": "java-dfs-sorted-array-to-bst",
                "content": "```\\npublic TreeNode balanceBST(TreeNode root) {\\n\\tList<Integer> inOrder = new ArrayList<>();\\n\\tinOrder(root, inOrder);\\n\\treturn buildTree(0, inOrder.size()-1, inOrder);\\n}\\n\\nTreeNode buildTree(int left, int right, List<Integer> inOrder) {\\n\\n\\tif (left > right)\\n\\t\\treturn null;\\n\\n\\tint middle = (left+right)/2;\\n\\tInteger val = inOrder.get(middle);\\n\\n\\tTreeNode n = new TreeNode(val);\\n\\tn.left = buildTree(left, middle-1, inOrder);\\n\\tn.right = buildTree(middle+1, right, inOrder);\\n\\n\\treturn n;\\n\\n}\\n\\nvoid inOrder(TreeNode node, List<Integer> inOrder) {\\n\\n\\tif (node == null)\\n\\t\\treturn;\\n\\n\\tinOrder(node.left, inOrder);\\n\\tinOrder.add(node.val);\\n\\tinOrder(node.right, inOrder);\\n}\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic TreeNode balanceBST(TreeNode root) {\\n\\tList<Integer> inOrder = new ArrayList<>();\\n\\tinOrder(root, inOrder);\\n\\treturn buildTree(0, inOrder.size()-1, inOrder);\\n}\\n\\nTreeNode buildTree(int left, int right, List<Integer> inOrder) {\\n\\n\\tif (left > right)\\n\\t\\treturn null;\\n\\n\\tint middle = (left+right)/2;\\n\\tInteger val = inOrder.get(middle);\\n\\n\\tTreeNode n = new TreeNode(val);\\n\\tn.left = buildTree(left, middle-1, inOrder);\\n\\tn.right = buildTree(middle+1, right, inOrder);\\n\\n\\treturn n;\\n\\n}\\n\\nvoid inOrder(TreeNode node, List<Integer> inOrder) {\\n\\n\\tif (node == null)\\n\\t\\treturn;\\n\\n\\tinOrder(node.left, inOrder);\\n\\tinOrder.add(node.val);\\n\\tinOrder(node.right, inOrder);\\n}\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1714873,
                "title": "c-inorder-traversal",
                "content": "```\\nclass Solution {\\nprivate:\\n    TreeNode *build(vector <TreeNode *> &nodes, int start , int end){\\n        if(start > end) return NULL;\\n\\n        int mid = (start + end)/2;\\n\\n        TreeNode *root = nodes[mid];\\n\\n        root -> left = build(nodes, start, mid -1);\\n        root -> right = build(nodes, mid + 1, end);\\n\\n        return root;\\n    }\\nprivate:\\n    void storeNodes(TreeNode *root, vector <TreeNode*> &nodes){\\n        if(root == NULL) return ;\\n\\n        storeNodes(root -> left, nodes);\\n\\n        nodes.push_back(root);\\n\\n        storeNodes(root -> right, nodes);\\n    }\\n    \\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        if(root == NULL) return NULL;\\n\\n        vector <TreeNode *> nodes;\\n\\n        storeNodes(root, nodes);\\n\\n        return build(nodes, 0, nodes.size() -1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    TreeNode *build(vector <TreeNode *> &nodes, int start , int end){\\n        if(start > end) return NULL;\\n\\n        int mid = (start + end)/2;\\n\\n        TreeNode *root = nodes[mid];\\n\\n        root -> left = build(nodes, start, mid -1);\\n        root -> right = build(nodes, mid + 1, end);\\n\\n        return root;\\n    }\\nprivate:\\n    void storeNodes(TreeNode *root, vector <TreeNode*> &nodes){\\n        if(root == NULL) return ;\\n\\n        storeNodes(root -> left, nodes);\\n\\n        nodes.push_back(root);\\n\\n        storeNodes(root -> right, nodes);\\n    }\\n    \\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        if(root == NULL) return NULL;\\n\\n        vector <TreeNode *> nodes;\\n\\n        storeNodes(root, nodes);\\n\\n        return build(nodes, 0, nodes.size() -1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708380,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<TreeNode*> v;\\n    void inorder(TreeNode* root){\\n        if(root){\\n        inorder(root->left);\\n        v.push_back(root);\\n        inorder(root->right);\\n        }\\n    }\\n    TreeNode* helper(int start,int end){\\n        if(start > end)\\n            return NULL;\\n        int mid = start + (end - start)/2;\\n        TreeNode* root = v[mid];\\n        root -> left = helper(start,mid - 1);\\n        root -> right = helper(mid + 1,end);\\n        return root;\\n    }\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorder(root);\\n        return helper(0,v.size() - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<TreeNode*> v;\\n    void inorder(TreeNode* root){\\n        if(root){\\n        inorder(root->left);\\n        v.push_back(root);\\n        inorder(root->right);\\n        }\\n    }\\n    TreeNode* helper(int start,int end){\\n        if(start > end)\\n            return NULL;\\n        int mid = start + (end - start)/2;\\n        TreeNode* root = v[mid];\\n        root -> left = helper(start,mid - 1);\\n        root -> right = helper(mid + 1,end);\\n        return root;\\n    }\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n        inorder(root);\\n        return helper(0,v.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646200,
                "title": "java-using-in-order-traversal-beat-100",
                "content": "```\\nclass Solution {\\n    private List<Integer> list;\\n    private void inorder(TreeNode root){\\n        if(root == null) return;\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);   \\n    }\\n    \\n    private TreeNode balance(int left, int right){\\n        if(right<left) return null;\\n        else{\\n            int mid = left + (right - left)/2;\\n            TreeNode temp = new TreeNode(list.get(mid));\\n            temp.left = balance(left,mid-1);\\n            temp.right = balance(mid+1,right);\\n            return temp;\\n        }\\n    }\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        list = new ArrayList<>();\\n        inorder(root);\\n        \\n        TreeNode temp = balance(0,list.size()-1);\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private List<Integer> list;\\n    private void inorder(TreeNode root){\\n        if(root == null) return;\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);   \\n    }\\n    \\n    private TreeNode balance(int left, int right){\\n        if(right<left) return null;\\n        else{\\n            int mid = left + (right - left)/2;\\n            TreeNode temp = new TreeNode(list.get(mid));\\n            temp.left = balance(left,mid-1);\\n            temp.right = balance(mid+1,right);\\n            return temp;\\n        }\\n    }\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        list = new ArrayList<>();\\n        inorder(root);\\n        \\n        TreeNode temp = balance(0,list.size()-1);\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1609536,
                "title": "c-inorder-building-balanced-bst-with-sorted-list",
                "content": "Logic : Run inorder traversal first to get the sorted list of nodes and then build a balanced BST with that list.\\nFor building balanced BST just pick the middle element to make root and then recurse with left part to build left subtree and recurse right part to build right subtree.\\n\\n```\\nvoid inorderTrav(TreeNode* root, vector<TreeNode*>& arr) {\\n        if (root == nullptr)\\n            return;\\n        inorderTrav(root->left, arr);\\n        arr.push_back(root);\\n        inorderTrav(root->right, arr);\\n    }\\n    \\n    TreeNode* CreateNewTree(vector<TreeNode*>& arr, int start, int end) {\\n        if (start > end)\\n            return nullptr;\\n        int mid = start + (end-start)/2;\\n        TreeNode* root = arr[mid];\\n        root->left = CreateNewTree(arr, start, mid-1);\\n        root->right = CreateNewTree(arr, mid+1, end);\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> arr;\\n        inorderTrav(root, arr);\\n        return CreateNewTree(arr, 0, arr.size()-1);\\n    }\\n```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nvoid inorderTrav(TreeNode* root, vector<TreeNode*>& arr) {\\n        if (root == nullptr)\\n            return;\\n        inorderTrav(root->left, arr);\\n        arr.push_back(root);\\n        inorderTrav(root->right, arr);\\n    }\\n    \\n    TreeNode* CreateNewTree(vector<TreeNode*>& arr, int start, int end) {\\n        if (start > end)\\n            return nullptr;\\n        int mid = start + (end-start)/2;\\n        TreeNode* root = arr[mid];\\n        root->left = CreateNewTree(arr, start, mid-1);\\n        root->right = CreateNewTree(arr, mid+1, end);\\n        return root;\\n    }\\n    \\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> arr;\\n        inorderTrav(root, arr);\\n        return CreateNewTree(arr, 0, arr.size()-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1587660,
                "title": "in-place-by-converting-to-doubly-linked-list-o-nlogn",
                "content": "Idea:\\n1. Convert binary tree to Doubly Linked List in place\\n2. Partition the Linked list into three parts based on the middle element\\n3. Recursively build the tree from the linked list partitions\\n\\nTime complexity\\n=> T(n) = 2T(n / 2) + O(n)\\n=> O(nlogn)\\n\\nSpace complexity\\n=> O(h) due to recursion stack space\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        # Time: O(n), Space: O(h)\\n        def to_dll(root):\\n            if root is None:\\n                return None, None\\n            \\n            lhead, ltail = to_dll(root.left)\\n            rhead, rtail = to_dll(root.right)\\n            \\n            if ltail is not None:\\n                ltail.right = root\\n                root.left = ltail\\n                \\n            if rhead is not None:\\n                root.right = rhead\\n                rhead.left = root\\n                \\n            head = lhead\\n            if head is None:\\n                head = root\\n            tail = rtail\\n            if tail is None:\\n                tail = root\\n            return head, tail\\n        \\n        # Time: O(n), Space: O(1)\\n        def partition(head, tail):\\n            slow = head\\n            fast = head\\n            while fast and fast.right:\\n                slow = slow.right\\n                fast = fast.right.right\\n            return head, slow, tail\\n        \\n        # Time: O(nlogn), space: O(h)\\n        def balance(head, tail):\\n            if head == tail:\\n                return head\\n            \\n            head, slow, tail = partition(head, tail)\\n            if slow.left is not None:\\n                slow.left.right = None\\n                slow.left = balance(head, slow.left)\\n            if slow.right is not None:\\n                slow.right.left = None\\n                slow.right = balance(slow.right, tail)\\n            return slow\\n        \\n        head, tail = to_dll(root)\\n        return balance(head, tail)\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        # Time: O(n), Space: O(h)\\n        def to_dll(root):\\n            if root is None:\\n                return None, None\\n            \\n            lhead, ltail = to_dll(root.left)\\n            rhead, rtail = to_dll(root.right)\\n            \\n            if ltail is not None:\\n                ltail.right = root\\n                root.left = ltail\\n                \\n            if rhead is not None:\\n                root.right = rhead\\n                rhead.left = root\\n                \\n            head = lhead\\n            if head is None:\\n                head = root\\n            tail = rtail\\n            if tail is None:\\n                tail = root\\n            return head, tail\\n        \\n        # Time: O(n), Space: O(1)\\n        def partition(head, tail):\\n            slow = head\\n            fast = head\\n            while fast and fast.right:\\n                slow = slow.right\\n                fast = fast.right.right\\n            return head, slow, tail\\n        \\n        # Time: O(nlogn), space: O(h)\\n        def balance(head, tail):\\n            if head == tail:\\n                return head\\n            \\n            head, slow, tail = partition(head, tail)\\n            if slow.left is not None:\\n                slow.left.right = None\\n                slow.left = balance(head, slow.left)\\n            if slow.right is not None:\\n                slow.right.left = None\\n                slow.right = balance(slow.right, tail)\\n            return slow\\n        \\n        head, tail = to_dll(root)\\n        return balance(head, tail)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568338,
                "title": "java-short-and-simple-code-o-n-2ms-faster-than-99-78",
                "content": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<TreeNode> al = new ArrayList<>();\\n        inorder(root, al);\\n        return BalancedBST(0, al.size()-1, al);\\n    }\\n    public void inorder(TreeNode node, ArrayList<TreeNode> al){\\n        if(node == null) return;\\n        inorder(node.left, al);\\n        al.add(node);\\n        inorder(node.right, al);\\n    }\\n    public TreeNode BalancedBST(int left, int right, ArrayList<TreeNode> al){\\n        if(right<left) return null;\\n        int x = (int)((left+right)/2);\\n        TreeNode node = new TreeNode(al.get(x).val);\\n        node.left = BalancedBST(left, x-1, al);\\n        node.right = BalancedBST(x+1, right, al);\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Divide and Conquer",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<TreeNode> al = new ArrayList<>();\\n        inorder(root, al);\\n        return BalancedBST(0, al.size()-1, al);\\n    }\\n    public void inorder(TreeNode node, ArrayList<TreeNode> al){\\n        if(node == null) return;\\n        inorder(node.left, al);\\n        al.add(node);\\n        inorder(node.right, al);\\n    }\\n    public TreeNode BalancedBST(int left, int right, ArrayList<TreeNode> al){\\n        if(right<left) return null;\\n        int x = (int)((left+right)/2);\\n        TreeNode node = new TreeNode(al.get(x).val);\\n        node.left = BalancedBST(left, x-1, al);\\n        node.right = BalancedBST(x+1, right, al);\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557903,
                "title": "functional-way-in-scala-i-wanna-know-a-way-using-tail-recursion-someone-let-me-know",
                "content": "I wanna change inorder function to tail recursion\\n```\\n  def main(args: Array[String]): Unit = {\\n    /*\\n             5\\n          3     6\\n        2   4     7\\n      1\\n    */\\n    val n = TreeNode(5, TreeNode(3, TreeNode(2, TreeNode(1)), TreeNode(4)), TreeNode(6, null, TreeNode(7)))\\n    assert(inorder(n) == List(1, 2, 3, 4, 5, 6, 7))\\n  }\\n\\n  def balanceBST(root: TreeNode): TreeNode = buildBST(inorder(root))\\n\\n\\n  /*\\n      1. mid of list is root node\\n      2. leftList is left subTree, rightList is right subTree\\n\\n      odd nums\\n      List(1, 2, 3) -> List(1) List(2, 3)\\n      even nums\\n      List(1, 2, 3, 4) -> List(1, 2) List(3, 4)\\n  */\\n  def buildBST(ns: List[Int]): TreeNode = {\\n    ns match {\\n      case Nil => null\\n      case _ => ns.splitAt(ns.size / 2) match {\\n        case (l, m :: r) => TreeNode(m, buildBST(l), buildBST(r))\\n        case _ => throw new UnsupportedOperationException()\\n      }\\n    }\\n  }\\n\\n  /*\\n      left -> root -> right\\n   */\\n  def inorder(n: TreeNode): List[Int] = {\\n    // @annotation.tailrec\\n    if (n == null) List()\\n    else inorder(n.left) ::: n.value :: inorder(n.right)\\n\\n\\n    /*\\n    def inorder(n: TreeNode, acc: List[Int]): List[Int] =\\n      if (n == null) return acc\\n      else inorder(n.left, n.value :: inorder(n.right, acc))\\n\\n    inorder(n, List())\\n    */\\n  }\\n```\\n\\n### Updated\\nI find out tail recursive solution with case class.\\nTail recursion should be linear traversal.\\nIt\\'s smiliar to a way with while loop (iterative)\\n```\\n   /*\\n      reverse inorder traversal ( right -> root -> left )\\n      because prepend element to list not append\\n   */\\n  def inorder(n: TreeNode): List[Int] = {\\n    @annotation.tailrec\\n    def inorder(stk: List[TreeNode], acc: List[Int]): List[Int] =\\n      stk match {\\n        case Nil => acc\\n        case h :: t =>\\n          h match {\\n            // go right\\n            case TreeNode(_, _, r) if r != null => inorder(r :: TreeNode(h.value, h.left, null) :: t, acc)\\n            // add value\\n            case TreeNode(v, null, null) => inorder(t, v :: acc)\\n            // add value and go left\\n            case TreeNode(v, l, null) => inorder(l :: t, v :: acc)\\n          }\\n      }\\n\\n    inorder(List(n), List())\\n    /*\\n      if (n == null) List()\\n      else inorder(n.left) ::: n.value :: inorder(n.right)\\n    */\\n  }\\n ```",
                "solutionTags": [],
                "code": "```\\n  def main(args: Array[String]): Unit = {\\n    /*\\n             5\\n          3     6\\n        2   4     7\\n      1\\n    */\\n    val n = TreeNode(5, TreeNode(3, TreeNode(2, TreeNode(1)), TreeNode(4)), TreeNode(6, null, TreeNode(7)))\\n    assert(inorder(n) == List(1, 2, 3, 4, 5, 6, 7))\\n  }\\n\\n  def balanceBST(root: TreeNode): TreeNode = buildBST(inorder(root))\\n\\n\\n  /*\\n      1. mid of list is root node\\n      2. leftList is left subTree, rightList is right subTree\\n\\n      odd nums\\n      List(1, 2, 3) -> List(1) List(2, 3)\\n      even nums\\n      List(1, 2, 3, 4) -> List(1, 2) List(3, 4)\\n  */\\n  def buildBST(ns: List[Int]): TreeNode = {\\n    ns match {\\n      case Nil => null\\n      case _ => ns.splitAt(ns.size / 2) match {\\n        case (l, m :: r) => TreeNode(m, buildBST(l), buildBST(r))\\n        case _ => throw new UnsupportedOperationException()\\n      }\\n    }\\n  }\\n\\n  /*\\n      left -> root -> right\\n   */\\n  def inorder(n: TreeNode): List[Int] = {\\n    // @annotation.tailrec\\n    if (n == null) List()\\n    else inorder(n.left) ::: n.value :: inorder(n.right)\\n\\n\\n    /*\\n    def inorder(n: TreeNode, acc: List[Int]): List[Int] =\\n      if (n == null) return acc\\n      else inorder(n.left, n.value :: inorder(n.right, acc))\\n\\n    inorder(n, List())\\n    */\\n  }\\n```\n```\\n   /*\\n      reverse inorder traversal ( right -> root -> left )\\n      because prepend element to list not append\\n   */\\n  def inorder(n: TreeNode): List[Int] = {\\n    @annotation.tailrec\\n    def inorder(stk: List[TreeNode], acc: List[Int]): List[Int] =\\n      stk match {\\n        case Nil => acc\\n        case h :: t =>\\n          h match {\\n            // go right\\n            case TreeNode(_, _, r) if r != null => inorder(r :: TreeNode(h.value, h.left, null) :: t, acc)\\n            // add value\\n            case TreeNode(v, null, null) => inorder(t, v :: acc)\\n            // add value and go left\\n            case TreeNode(v, l, null) => inorder(l :: t, v :: acc)\\n          }\\n      }\\n\\n    inorder(List(n), List())\\n    /*\\n      if (n == null) List()\\n      else inorder(n.left) ::: n.value :: inorder(n.right)\\n    */\\n  }\\n ```",
                "codeTag": "Python3"
            },
            {
                "id": 1548699,
                "title": "clean-code-c",
                "content": "```\\nclass Solution {\\n    vector<TreeNode*> inOrder;\\n    void inorderTraverse(TreeNode* root) {\\n        if( root == nullptr)\\n            return; \\n       inorderTraverse(root->left);\\n      \\n       inOrder.push_back(root);\\n       inorderTraverse(root->right); \\n       root->left = root->right = nullptr;\\n    }\\n    \\n    \\n    TreeNode* formBalancedBinaryTree(int start , int end) {\\n        if( start > end)\\n            return nullptr;\\n        else if(start == end)\\n            return inOrder[start];\\n        else {\\n            int mid = (start + end)/2;\\n            inOrder[mid]->left = formBalancedBinaryTree(start, mid-1);\\n            inOrder[mid]->right = formBalancedBinaryTree(mid+1, end);\\n            return inOrder[mid];\\n        }\\n    }\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n      inorderTraverse(root); \\n      return formBalancedBinaryTree(0, inOrder.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<TreeNode*> inOrder;\\n    void inorderTraverse(TreeNode* root) {\\n        if( root == nullptr)\\n            return; \\n       inorderTraverse(root->left);\\n      \\n       inOrder.push_back(root);\\n       inorderTraverse(root->right); \\n       root->left = root->right = nullptr;\\n    }\\n    \\n    \\n    TreeNode* formBalancedBinaryTree(int start , int end) {\\n        if( start > end)\\n            return nullptr;\\n        else if(start == end)\\n            return inOrder[start];\\n        else {\\n            int mid = (start + end)/2;\\n            inOrder[mid]->left = formBalancedBinaryTree(start, mid-1);\\n            inOrder[mid]->right = formBalancedBinaryTree(mid+1, end);\\n            return inOrder[mid];\\n        }\\n    }\\npublic:\\n    TreeNode* balanceBST(TreeNode* root) {\\n      inorderTraverse(root); \\n      return formBalancedBinaryTree(0, inOrder.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539052,
                "title": "python3-easy-to-understand",
                "content": "```\\ndef balanceBST(self, root: TreeNode) -> TreeNode:\\n\\tinorder = []\\n\\n\\t# Convert the tree to a sorted array \\n\\t# using an in-order traversal.\\n\\tdef dfs(root):\\n\\t\\tif not root:\\n\\t\\t\\treturn\\n\\n\\t\\tdfs(root.left)\\n\\t\\tinorder.append(root.val)\\n\\t\\tdfs(root.right)\\n\\n\\t# Construct a new balanced tree \\n\\t# from the sorted array recursively.\\n\\tdef constructBST(array):\\n\\t\\tif not array:\\n\\t\\t\\treturn None\\n\\t\\tmid = len(array) // 2\\n\\t\\troot = TreeNode(array[mid])\\n\\t\\troot.left = constructBST(array[:mid])\\n\\t\\troot.right = constructBST(array[mid+1:])\\n\\t\\treturn root\\n\\n\\tdfs(root)\\n\\treturn constructBST(inorder)\\n```",
                "solutionTags": [],
                "code": "```\\ndef balanceBST(self, root: TreeNode) -> TreeNode:\\n\\tinorder = []\\n\\n\\t# Convert the tree to a sorted array \\n\\t# using an in-order traversal.\\n\\tdef dfs(root):\\n\\t\\tif not root:\\n\\t\\t\\treturn\\n\\n\\t\\tdfs(root.left)\\n\\t\\tinorder.append(root.val)\\n\\t\\tdfs(root.right)\\n\\n\\t# Construct a new balanced tree \\n\\t# from the sorted array recursively.\\n\\tdef constructBST(array):\\n\\t\\tif not array:\\n\\t\\t\\treturn None\\n\\t\\tmid = len(array) // 2\\n\\t\\troot = TreeNode(array[mid])\\n\\t\\troot.left = constructBST(array[:mid])\\n\\t\\troot.right = constructBST(array[mid+1:])\\n\\t\\treturn root\\n\\n\\tdfs(root)\\n\\treturn constructBST(inorder)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1530702,
                "title": "python3-time-o-n-space-o-n",
                "content": "Time Complexity: O(n)\\nSpace Complexity: O(n)\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        # [1] => [1]\\n        # [1,2] => [1,2]\\n        # [1,null,2,3] => [2,1,3]\\n        \\n        # Traverse in-order and store node values\\n        # create BST \\n        # Time: O(n)\\n        # Space: O(n)\\n        \\n        arr = []\\n        def createValuesArr(root):\\n            if not root:\\n                return\\n            createValuesArr(root.left)\\n            arr.append(root.val)\\n            createValuesArr(root.right)\\n            \\n        createValuesArr(root)\\n        \\n        def createBST(arr):\\n            if len(arr) == 0:\\n                return\\n            if len(arr) == 1:\\n                return TreeNode(arr[0])\\n            mid = (len(arr) - 1) // 2\\n\\n            node = TreeNode(arr[mid])\\n            node.left = createBST(arr[:mid])\\n            node.right = createBST(arr[mid+1:])\\n            return node\\n\\n        ans = createBST(arr)\\n        return ans\\n```\\n![image](https://assets.leetcode.com/users/images/29e6011e-bbc6-42e9-ac8a-f690d889a776_1634699880.074155.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def balanceBST(self, root: TreeNode) -> TreeNode:\\n        # [1] => [1]\\n        # [1,2] => [1,2]\\n        # [1,null,2,3] => [2,1,3]\\n        \\n        # Traverse in-order and store node values\\n        # create BST \\n        # Time: O(n)\\n        # Space: O(n)\\n        \\n        arr = []\\n        def createValuesArr(root):\\n            if not root:\\n                return\\n            createValuesArr(root.left)\\n            arr.append(root.val)\\n            createValuesArr(root.right)\\n            \\n        createValuesArr(root)\\n        \\n        def createBST(arr):\\n            if len(arr) == 0:\\n                return\\n            if len(arr) == 1:\\n                return TreeNode(arr[0])\\n            mid = (len(arr) - 1) // 2\\n\\n            node = TreeNode(arr[mid])\\n            node.left = createBST(arr[:mid])\\n            node.right = createBST(arr[mid+1:])\\n            return node\\n\\n        ans = createBST(arr)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530538,
                "title": "java-iterate-all-nodes-then-build-bst-coolkid",
                "content": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        // first iterate to get all values\\n        // then create BST\\n        List<Integer> lis = new ArrayList<>();\\n        inOrder(root,lis);\\n        return createBST(lis,0,lis.size()-1);\\n    }\\n    \\n    private void inOrder(TreeNode root,List<Integer> lis) {\\n        if(root!=null) {\\n            inOrder(root.left,lis);\\n            lis.add(root.val);\\n            inOrder(root.right,lis);\\n        }\\n    }\\n    \\n    private TreeNode createBST(List<Integer> lis, int start,int end) {\\n        if(start>end){\\n            return null;\\n        }\\n        int mid = (start + end)/2;\\n        TreeNode root = new TreeNode(lis.get(mid));\\n        root.left = createBST(lis,start,mid-1);\\n        root.right = createBST(lis,mid+1,end);\\n        return root;\\n    }\\n}\\n```\\nnot sure this is the best solution",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        // first iterate to get all values\\n        // then create BST\\n        List<Integer> lis = new ArrayList<>();\\n        inOrder(root,lis);\\n        return createBST(lis,0,lis.size()-1);\\n    }\\n    \\n    private void inOrder(TreeNode root,List<Integer> lis) {\\n        if(root!=null) {\\n            inOrder(root.left,lis);\\n            lis.add(root.val);\\n            inOrder(root.right,lis);\\n        }\\n    }\\n    \\n    private TreeNode createBST(List<Integer> lis, int start,int end) {\\n        if(start>end){\\n            return null;\\n        }\\n        int mid = (start + end)/2;\\n        TreeNode root = new TreeNode(lis.get(mid));\\n        root.left = createBST(lis,start,mid-1);\\n        root.right = createBST(lis,mid+1,end);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523960,
                "title": "simple-and-made-easy-approach-java",
                "content": "```\\nclass Solution {\\n    \\n    List<TreeNode> list = new ArrayList<>();\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        buildSortedArray(root);\\n        return constructBalBST(0,list.size()-1);\\n        \\n    }\\n    \\n    \\n    public void buildSortedArray(TreeNode root){\\n        if(root==null) return;\\n        buildSortedArray(root.left);\\n        list.add(root);\\n        buildSortedArray(root.right);\\n        \\n    }\\n    \\n    public TreeNode constructBalBST(int start, int end){\\n        if(start>end) return null;\\n        int mid = start + (end - start) / 2;\\n        TreeNode root = list.get(mid);\\n        root.left = constructBalBST(start, mid-1);\\n        root.right = constructBalBST(mid+1, end);    \\n        return root;\\n    } \\n    \\n}\\n```\\n\\n\\n-> s =0 ,e= 2 mid =1 , root = Node(2)\\n                                rL = s=0 end=0 Node(1)\\n                                               rLL = s=0 e=-1 = null \\n                                rR = s=2 e =2 Node(3)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  rRR = 3,end 2 = null\\n\\t\\t\\t\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    List<TreeNode> list = new ArrayList<>();\\n    \\n    public TreeNode balanceBST(TreeNode root) {\\n        buildSortedArray(root);\\n        return constructBalBST(0,list.size()-1);\\n        \\n    }\\n    \\n    \\n    public void buildSortedArray(TreeNode root){\\n        if(root==null) return;\\n        buildSortedArray(root.left);\\n        list.add(root);\\n        buildSortedArray(root.right);\\n        \\n    }\\n    \\n    public TreeNode constructBalBST(int start, int end){\\n        if(start>end) return null;\\n        int mid = start + (end - start) / 2;\\n        TreeNode root = list.get(mid);\\n        root.left = constructBalBST(start, mid-1);\\n        root.right = constructBalBST(mid+1, end);    \\n        return root;\\n    } \\n    \\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576586,
                "content": [
                    {
                        "username": "ahcox",
                        "content": "Links to the algorithm for the optimal solution using just in-place node pointer manipulations:\\n\\n* [One-Time Binary Search Tree Balancing: The Day/Stout/Warren (DSW) Algorithm](https://web.archive.org/web/20220406184919/https://sci-hub.hkvisa.net/10.1145/820127.820173), 2002\\n* [Tree Rebalancing in Optimal Time and Space](http://web.eecs.umich.edu/~qstout/pap/CACM86.pdf), 1986\\n  This is the best one to read.\\n* [Balancing a Binary Tree, Algorithms Supplement, The Computer Journal, Volume 19, Issue 4, 1976, Pages 360\\u2013363](https://academic.oup.com/comjnl/article/19/4/360/326682)"
                    },
                    {
                        "username": "dimitars",
                        "content": "These look like some awesome reading materials. Thank you for sharing!"
                    },
                    {
                        "username": "raju31",
                        "content": "AVL tree solution ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Does AVL tree always give us the minimum height?"
                    },
                    {
                        "username": "PadhakuLaunde",
                        "content": "We can convert this BST to sorted DLL (using same nodes as of tree -https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/)\\nThen sorted DLL to height balanced BST . I think this can save some space"
                    },
                    {
                        "username": "Simpola",
                        "content": "Did it in one shot, basically it comes under traversal of tree and there are really less ways to tackle it so you will come up with solution after few tries.\\n```\\n- tree ( convert to ) vector\\n- sort the vector\\n- sorted vector -> Inorder Traversal\\n- that\\'s all\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This question is quite tricky. I never want this question to come up in my interview!"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Alright, This question sucks!"
                    },
                    {
                        "username": "sxz1069",
                        "content": "Is it possible to adjust the input tree without building a new one? \\nAnyone have that kind of solution?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "I try this way and I couldn\\'t figure out why it\\'s not work yet, maybe it could help you a little bit\\n```\\nvoid selfBalanced(TreeNode* &root)\\n    {\\n        if(!root)\\n            return;\\n        else\\n        {\\n            while(!isBalanced(root))\\n            {\\n                int l = height(root->left);\\n                int r = height(root->right);\\n                if(l > r)\\n                    rotate_R(root);\\n                else\\n                    rotate_L(root);\\n            }\\n            selfBalanced(root->left);\\n            selfBalanced(root->right);\\n        }\\n    }\\n```\\n"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) \\nYeah I approached the same way. Was fairly simple implementation."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Maybe Yes, I am storing the nodes in vector<node> then arranging them as per the requirement \\n\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<TreeNode*> &in){\\n        if(!root)\\n        return ;\\n\\n        inorder(root->left, in);\\n        in.push_back(root);\\n        inorder(root->right, in);\\n    }\\n\\n    TreeNode* balancing(int start, int end, vector<TreeNode*> &in){\\n        if(start>end) return NULL;\\n\\n        int mid = (start+end)/2;\\n        in[mid]->left = balancing(start, mid-1, in);\\n        in[mid]->right = balancing(mid+1, end, in);\\n        return in[mid];\\n    }\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> in;\\n        inorder(root, in);\\n        return balancing(0,in.size()-1, in);\\n    }\\n};"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        ino(root,list);\\nint e=list.size()-1;\\n      return  bs(list,0,e);\\n    }\\n\\n    public void ino(TreeNode root, ArrayList<Integer> list){\\n        if(root==null)return;\\nino(root.left,list);\\nlist.add(root.val);\\nino(root.right,list);\\n    }\\n\\n    public TreeNode bs(ArrayList<Integer> list,int s,int e){\\n        if(s>e) return null;\\n        int mid=s+(e-s)/2;\\n        TreeNode node=new TreeNode(list.get(mid));\\n        node.left=bs(list,s,mid-1);\\n        node.right=bs(list,mid+1,e);\\n        return node;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1568295,
                "content": [
                    {
                        "username": "ahcox",
                        "content": "Links to the algorithm for the optimal solution using just in-place node pointer manipulations:\\n\\n* [One-Time Binary Search Tree Balancing: The Day/Stout/Warren (DSW) Algorithm](https://web.archive.org/web/20220406184919/https://sci-hub.hkvisa.net/10.1145/820127.820173), 2002\\n* [Tree Rebalancing in Optimal Time and Space](http://web.eecs.umich.edu/~qstout/pap/CACM86.pdf), 1986\\n  This is the best one to read.\\n* [Balancing a Binary Tree, Algorithms Supplement, The Computer Journal, Volume 19, Issue 4, 1976, Pages 360\\u2013363](https://academic.oup.com/comjnl/article/19/4/360/326682)"
                    },
                    {
                        "username": "dimitars",
                        "content": "These look like some awesome reading materials. Thank you for sharing!"
                    },
                    {
                        "username": "raju31",
                        "content": "AVL tree solution ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Does AVL tree always give us the minimum height?"
                    },
                    {
                        "username": "PadhakuLaunde",
                        "content": "We can convert this BST to sorted DLL (using same nodes as of tree -https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/)\\nThen sorted DLL to height balanced BST . I think this can save some space"
                    },
                    {
                        "username": "Simpola",
                        "content": "Did it in one shot, basically it comes under traversal of tree and there are really less ways to tackle it so you will come up with solution after few tries.\\n```\\n- tree ( convert to ) vector\\n- sort the vector\\n- sorted vector -> Inorder Traversal\\n- that\\'s all\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This question is quite tricky. I never want this question to come up in my interview!"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Alright, This question sucks!"
                    },
                    {
                        "username": "sxz1069",
                        "content": "Is it possible to adjust the input tree without building a new one? \\nAnyone have that kind of solution?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "I try this way and I couldn\\'t figure out why it\\'s not work yet, maybe it could help you a little bit\\n```\\nvoid selfBalanced(TreeNode* &root)\\n    {\\n        if(!root)\\n            return;\\n        else\\n        {\\n            while(!isBalanced(root))\\n            {\\n                int l = height(root->left);\\n                int r = height(root->right);\\n                if(l > r)\\n                    rotate_R(root);\\n                else\\n                    rotate_L(root);\\n            }\\n            selfBalanced(root->left);\\n            selfBalanced(root->right);\\n        }\\n    }\\n```\\n"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) \\nYeah I approached the same way. Was fairly simple implementation."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Maybe Yes, I am storing the nodes in vector<node> then arranging them as per the requirement \\n\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<TreeNode*> &in){\\n        if(!root)\\n        return ;\\n\\n        inorder(root->left, in);\\n        in.push_back(root);\\n        inorder(root->right, in);\\n    }\\n\\n    TreeNode* balancing(int start, int end, vector<TreeNode*> &in){\\n        if(start>end) return NULL;\\n\\n        int mid = (start+end)/2;\\n        in[mid]->left = balancing(start, mid-1, in);\\n        in[mid]->right = balancing(mid+1, end, in);\\n        return in[mid];\\n    }\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> in;\\n        inorder(root, in);\\n        return balancing(0,in.size()-1, in);\\n    }\\n};"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        ino(root,list);\\nint e=list.size()-1;\\n      return  bs(list,0,e);\\n    }\\n\\n    public void ino(TreeNode root, ArrayList<Integer> list){\\n        if(root==null)return;\\nino(root.left,list);\\nlist.add(root.val);\\nino(root.right,list);\\n    }\\n\\n    public TreeNode bs(ArrayList<Integer> list,int s,int e){\\n        if(s>e) return null;\\n        int mid=s+(e-s)/2;\\n        TreeNode node=new TreeNode(list.get(mid));\\n        node.left=bs(list,s,mid-1);\\n        node.right=bs(list,mid+1,e);\\n        return node;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1570366,
                "content": [
                    {
                        "username": "ahcox",
                        "content": "Links to the algorithm for the optimal solution using just in-place node pointer manipulations:\\n\\n* [One-Time Binary Search Tree Balancing: The Day/Stout/Warren (DSW) Algorithm](https://web.archive.org/web/20220406184919/https://sci-hub.hkvisa.net/10.1145/820127.820173), 2002\\n* [Tree Rebalancing in Optimal Time and Space](http://web.eecs.umich.edu/~qstout/pap/CACM86.pdf), 1986\\n  This is the best one to read.\\n* [Balancing a Binary Tree, Algorithms Supplement, The Computer Journal, Volume 19, Issue 4, 1976, Pages 360\\u2013363](https://academic.oup.com/comjnl/article/19/4/360/326682)"
                    },
                    {
                        "username": "dimitars",
                        "content": "These look like some awesome reading materials. Thank you for sharing!"
                    },
                    {
                        "username": "raju31",
                        "content": "AVL tree solution ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Does AVL tree always give us the minimum height?"
                    },
                    {
                        "username": "PadhakuLaunde",
                        "content": "We can convert this BST to sorted DLL (using same nodes as of tree -https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/)\\nThen sorted DLL to height balanced BST . I think this can save some space"
                    },
                    {
                        "username": "Simpola",
                        "content": "Did it in one shot, basically it comes under traversal of tree and there are really less ways to tackle it so you will come up with solution after few tries.\\n```\\n- tree ( convert to ) vector\\n- sort the vector\\n- sorted vector -> Inorder Traversal\\n- that\\'s all\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This question is quite tricky. I never want this question to come up in my interview!"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Alright, This question sucks!"
                    },
                    {
                        "username": "sxz1069",
                        "content": "Is it possible to adjust the input tree without building a new one? \\nAnyone have that kind of solution?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "I try this way and I couldn\\'t figure out why it\\'s not work yet, maybe it could help you a little bit\\n```\\nvoid selfBalanced(TreeNode* &root)\\n    {\\n        if(!root)\\n            return;\\n        else\\n        {\\n            while(!isBalanced(root))\\n            {\\n                int l = height(root->left);\\n                int r = height(root->right);\\n                if(l > r)\\n                    rotate_R(root);\\n                else\\n                    rotate_L(root);\\n            }\\n            selfBalanced(root->left);\\n            selfBalanced(root->right);\\n        }\\n    }\\n```\\n"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) \\nYeah I approached the same way. Was fairly simple implementation."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Maybe Yes, I am storing the nodes in vector<node> then arranging them as per the requirement \\n\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<TreeNode*> &in){\\n        if(!root)\\n        return ;\\n\\n        inorder(root->left, in);\\n        in.push_back(root);\\n        inorder(root->right, in);\\n    }\\n\\n    TreeNode* balancing(int start, int end, vector<TreeNode*> &in){\\n        if(start>end) return NULL;\\n\\n        int mid = (start+end)/2;\\n        in[mid]->left = balancing(start, mid-1, in);\\n        in[mid]->right = balancing(mid+1, end, in);\\n        return in[mid];\\n    }\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> in;\\n        inorder(root, in);\\n        return balancing(0,in.size()-1, in);\\n    }\\n};"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        ino(root,list);\\nint e=list.size()-1;\\n      return  bs(list,0,e);\\n    }\\n\\n    public void ino(TreeNode root, ArrayList<Integer> list){\\n        if(root==null)return;\\nino(root.left,list);\\nlist.add(root.val);\\nino(root.right,list);\\n    }\\n\\n    public TreeNode bs(ArrayList<Integer> list,int s,int e){\\n        if(s>e) return null;\\n        int mid=s+(e-s)/2;\\n        TreeNode node=new TreeNode(list.get(mid));\\n        node.left=bs(list,s,mid-1);\\n        node.right=bs(list,mid+1,e);\\n        return node;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1934947,
                "content": [
                    {
                        "username": "ahcox",
                        "content": "Links to the algorithm for the optimal solution using just in-place node pointer manipulations:\\n\\n* [One-Time Binary Search Tree Balancing: The Day/Stout/Warren (DSW) Algorithm](https://web.archive.org/web/20220406184919/https://sci-hub.hkvisa.net/10.1145/820127.820173), 2002\\n* [Tree Rebalancing in Optimal Time and Space](http://web.eecs.umich.edu/~qstout/pap/CACM86.pdf), 1986\\n  This is the best one to read.\\n* [Balancing a Binary Tree, Algorithms Supplement, The Computer Journal, Volume 19, Issue 4, 1976, Pages 360\\u2013363](https://academic.oup.com/comjnl/article/19/4/360/326682)"
                    },
                    {
                        "username": "dimitars",
                        "content": "These look like some awesome reading materials. Thank you for sharing!"
                    },
                    {
                        "username": "raju31",
                        "content": "AVL tree solution ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Does AVL tree always give us the minimum height?"
                    },
                    {
                        "username": "PadhakuLaunde",
                        "content": "We can convert this BST to sorted DLL (using same nodes as of tree -https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/)\\nThen sorted DLL to height balanced BST . I think this can save some space"
                    },
                    {
                        "username": "Simpola",
                        "content": "Did it in one shot, basically it comes under traversal of tree and there are really less ways to tackle it so you will come up with solution after few tries.\\n```\\n- tree ( convert to ) vector\\n- sort the vector\\n- sorted vector -> Inorder Traversal\\n- that\\'s all\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This question is quite tricky. I never want this question to come up in my interview!"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Alright, This question sucks!"
                    },
                    {
                        "username": "sxz1069",
                        "content": "Is it possible to adjust the input tree without building a new one? \\nAnyone have that kind of solution?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "I try this way and I couldn\\'t figure out why it\\'s not work yet, maybe it could help you a little bit\\n```\\nvoid selfBalanced(TreeNode* &root)\\n    {\\n        if(!root)\\n            return;\\n        else\\n        {\\n            while(!isBalanced(root))\\n            {\\n                int l = height(root->left);\\n                int r = height(root->right);\\n                if(l > r)\\n                    rotate_R(root);\\n                else\\n                    rotate_L(root);\\n            }\\n            selfBalanced(root->left);\\n            selfBalanced(root->right);\\n        }\\n    }\\n```\\n"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) \\nYeah I approached the same way. Was fairly simple implementation."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Maybe Yes, I am storing the nodes in vector<node> then arranging them as per the requirement \\n\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<TreeNode*> &in){\\n        if(!root)\\n        return ;\\n\\n        inorder(root->left, in);\\n        in.push_back(root);\\n        inorder(root->right, in);\\n    }\\n\\n    TreeNode* balancing(int start, int end, vector<TreeNode*> &in){\\n        if(start>end) return NULL;\\n\\n        int mid = (start+end)/2;\\n        in[mid]->left = balancing(start, mid-1, in);\\n        in[mid]->right = balancing(mid+1, end, in);\\n        return in[mid];\\n    }\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> in;\\n        inorder(root, in);\\n        return balancing(0,in.size()-1, in);\\n    }\\n};"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        ino(root,list);\\nint e=list.size()-1;\\n      return  bs(list,0,e);\\n    }\\n\\n    public void ino(TreeNode root, ArrayList<Integer> list){\\n        if(root==null)return;\\nino(root.left,list);\\nlist.add(root.val);\\nino(root.right,list);\\n    }\\n\\n    public TreeNode bs(ArrayList<Integer> list,int s,int e){\\n        if(s>e) return null;\\n        int mid=s+(e-s)/2;\\n        TreeNode node=new TreeNode(list.get(mid));\\n        node.left=bs(list,s,mid-1);\\n        node.right=bs(list,mid+1,e);\\n        return node;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1906089,
                "content": [
                    {
                        "username": "ahcox",
                        "content": "Links to the algorithm for the optimal solution using just in-place node pointer manipulations:\\n\\n* [One-Time Binary Search Tree Balancing: The Day/Stout/Warren (DSW) Algorithm](https://web.archive.org/web/20220406184919/https://sci-hub.hkvisa.net/10.1145/820127.820173), 2002\\n* [Tree Rebalancing in Optimal Time and Space](http://web.eecs.umich.edu/~qstout/pap/CACM86.pdf), 1986\\n  This is the best one to read.\\n* [Balancing a Binary Tree, Algorithms Supplement, The Computer Journal, Volume 19, Issue 4, 1976, Pages 360\\u2013363](https://academic.oup.com/comjnl/article/19/4/360/326682)"
                    },
                    {
                        "username": "dimitars",
                        "content": "These look like some awesome reading materials. Thank you for sharing!"
                    },
                    {
                        "username": "raju31",
                        "content": "AVL tree solution ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Does AVL tree always give us the minimum height?"
                    },
                    {
                        "username": "PadhakuLaunde",
                        "content": "We can convert this BST to sorted DLL (using same nodes as of tree -https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/)\\nThen sorted DLL to height balanced BST . I think this can save some space"
                    },
                    {
                        "username": "Simpola",
                        "content": "Did it in one shot, basically it comes under traversal of tree and there are really less ways to tackle it so you will come up with solution after few tries.\\n```\\n- tree ( convert to ) vector\\n- sort the vector\\n- sorted vector -> Inorder Traversal\\n- that\\'s all\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This question is quite tricky. I never want this question to come up in my interview!"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Alright, This question sucks!"
                    },
                    {
                        "username": "sxz1069",
                        "content": "Is it possible to adjust the input tree without building a new one? \\nAnyone have that kind of solution?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "I try this way and I couldn\\'t figure out why it\\'s not work yet, maybe it could help you a little bit\\n```\\nvoid selfBalanced(TreeNode* &root)\\n    {\\n        if(!root)\\n            return;\\n        else\\n        {\\n            while(!isBalanced(root))\\n            {\\n                int l = height(root->left);\\n                int r = height(root->right);\\n                if(l > r)\\n                    rotate_R(root);\\n                else\\n                    rotate_L(root);\\n            }\\n            selfBalanced(root->left);\\n            selfBalanced(root->right);\\n        }\\n    }\\n```\\n"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) \\nYeah I approached the same way. Was fairly simple implementation."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Maybe Yes, I am storing the nodes in vector<node> then arranging them as per the requirement \\n\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<TreeNode*> &in){\\n        if(!root)\\n        return ;\\n\\n        inorder(root->left, in);\\n        in.push_back(root);\\n        inorder(root->right, in);\\n    }\\n\\n    TreeNode* balancing(int start, int end, vector<TreeNode*> &in){\\n        if(start>end) return NULL;\\n\\n        int mid = (start+end)/2;\\n        in[mid]->left = balancing(start, mid-1, in);\\n        in[mid]->right = balancing(mid+1, end, in);\\n        return in[mid];\\n    }\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> in;\\n        inorder(root, in);\\n        return balancing(0,in.size()-1, in);\\n    }\\n};"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        ino(root,list);\\nint e=list.size()-1;\\n      return  bs(list,0,e);\\n    }\\n\\n    public void ino(TreeNode root, ArrayList<Integer> list){\\n        if(root==null)return;\\nino(root.left,list);\\nlist.add(root.val);\\nino(root.right,list);\\n    }\\n\\n    public TreeNode bs(ArrayList<Integer> list,int s,int e){\\n        if(s>e) return null;\\n        int mid=s+(e-s)/2;\\n        TreeNode node=new TreeNode(list.get(mid));\\n        node.left=bs(list,s,mid-1);\\n        node.right=bs(list,mid+1,e);\\n        return node;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1906088,
                "content": [
                    {
                        "username": "ahcox",
                        "content": "Links to the algorithm for the optimal solution using just in-place node pointer manipulations:\\n\\n* [One-Time Binary Search Tree Balancing: The Day/Stout/Warren (DSW) Algorithm](https://web.archive.org/web/20220406184919/https://sci-hub.hkvisa.net/10.1145/820127.820173), 2002\\n* [Tree Rebalancing in Optimal Time and Space](http://web.eecs.umich.edu/~qstout/pap/CACM86.pdf), 1986\\n  This is the best one to read.\\n* [Balancing a Binary Tree, Algorithms Supplement, The Computer Journal, Volume 19, Issue 4, 1976, Pages 360\\u2013363](https://academic.oup.com/comjnl/article/19/4/360/326682)"
                    },
                    {
                        "username": "dimitars",
                        "content": "These look like some awesome reading materials. Thank you for sharing!"
                    },
                    {
                        "username": "raju31",
                        "content": "AVL tree solution ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Does AVL tree always give us the minimum height?"
                    },
                    {
                        "username": "PadhakuLaunde",
                        "content": "We can convert this BST to sorted DLL (using same nodes as of tree -https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/)\\nThen sorted DLL to height balanced BST . I think this can save some space"
                    },
                    {
                        "username": "Simpola",
                        "content": "Did it in one shot, basically it comes under traversal of tree and there are really less ways to tackle it so you will come up with solution after few tries.\\n```\\n- tree ( convert to ) vector\\n- sort the vector\\n- sorted vector -> Inorder Traversal\\n- that\\'s all\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This question is quite tricky. I never want this question to come up in my interview!"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Alright, This question sucks!"
                    },
                    {
                        "username": "sxz1069",
                        "content": "Is it possible to adjust the input tree without building a new one? \\nAnyone have that kind of solution?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "I try this way and I couldn\\'t figure out why it\\'s not work yet, maybe it could help you a little bit\\n```\\nvoid selfBalanced(TreeNode* &root)\\n    {\\n        if(!root)\\n            return;\\n        else\\n        {\\n            while(!isBalanced(root))\\n            {\\n                int l = height(root->left);\\n                int r = height(root->right);\\n                if(l > r)\\n                    rotate_R(root);\\n                else\\n                    rotate_L(root);\\n            }\\n            selfBalanced(root->left);\\n            selfBalanced(root->right);\\n        }\\n    }\\n```\\n"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) \\nYeah I approached the same way. Was fairly simple implementation."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Maybe Yes, I am storing the nodes in vector<node> then arranging them as per the requirement \\n\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<TreeNode*> &in){\\n        if(!root)\\n        return ;\\n\\n        inorder(root->left, in);\\n        in.push_back(root);\\n        inorder(root->right, in);\\n    }\\n\\n    TreeNode* balancing(int start, int end, vector<TreeNode*> &in){\\n        if(start>end) return NULL;\\n\\n        int mid = (start+end)/2;\\n        in[mid]->left = balancing(start, mid-1, in);\\n        in[mid]->right = balancing(mid+1, end, in);\\n        return in[mid];\\n    }\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> in;\\n        inorder(root, in);\\n        return balancing(0,in.size()-1, in);\\n    }\\n};"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        ino(root,list);\\nint e=list.size()-1;\\n      return  bs(list,0,e);\\n    }\\n\\n    public void ino(TreeNode root, ArrayList<Integer> list){\\n        if(root==null)return;\\nino(root.left,list);\\nlist.add(root.val);\\nino(root.right,list);\\n    }\\n\\n    public TreeNode bs(ArrayList<Integer> list,int s,int e){\\n        if(s>e) return null;\\n        int mid=s+(e-s)/2;\\n        TreeNode node=new TreeNode(list.get(mid));\\n        node.left=bs(list,s,mid-1);\\n        node.right=bs(list,mid+1,e);\\n        return node;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1574823,
                "content": [
                    {
                        "username": "ahcox",
                        "content": "Links to the algorithm for the optimal solution using just in-place node pointer manipulations:\\n\\n* [One-Time Binary Search Tree Balancing: The Day/Stout/Warren (DSW) Algorithm](https://web.archive.org/web/20220406184919/https://sci-hub.hkvisa.net/10.1145/820127.820173), 2002\\n* [Tree Rebalancing in Optimal Time and Space](http://web.eecs.umich.edu/~qstout/pap/CACM86.pdf), 1986\\n  This is the best one to read.\\n* [Balancing a Binary Tree, Algorithms Supplement, The Computer Journal, Volume 19, Issue 4, 1976, Pages 360\\u2013363](https://academic.oup.com/comjnl/article/19/4/360/326682)"
                    },
                    {
                        "username": "dimitars",
                        "content": "These look like some awesome reading materials. Thank you for sharing!"
                    },
                    {
                        "username": "raju31",
                        "content": "AVL tree solution ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Does AVL tree always give us the minimum height?"
                    },
                    {
                        "username": "PadhakuLaunde",
                        "content": "We can convert this BST to sorted DLL (using same nodes as of tree -https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/)\\nThen sorted DLL to height balanced BST . I think this can save some space"
                    },
                    {
                        "username": "Simpola",
                        "content": "Did it in one shot, basically it comes under traversal of tree and there are really less ways to tackle it so you will come up with solution after few tries.\\n```\\n- tree ( convert to ) vector\\n- sort the vector\\n- sorted vector -> Inorder Traversal\\n- that\\'s all\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This question is quite tricky. I never want this question to come up in my interview!"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Alright, This question sucks!"
                    },
                    {
                        "username": "sxz1069",
                        "content": "Is it possible to adjust the input tree without building a new one? \\nAnyone have that kind of solution?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "I try this way and I couldn\\'t figure out why it\\'s not work yet, maybe it could help you a little bit\\n```\\nvoid selfBalanced(TreeNode* &root)\\n    {\\n        if(!root)\\n            return;\\n        else\\n        {\\n            while(!isBalanced(root))\\n            {\\n                int l = height(root->left);\\n                int r = height(root->right);\\n                if(l > r)\\n                    rotate_R(root);\\n                else\\n                    rotate_L(root);\\n            }\\n            selfBalanced(root->left);\\n            selfBalanced(root->right);\\n        }\\n    }\\n```\\n"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) \\nYeah I approached the same way. Was fairly simple implementation."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Maybe Yes, I am storing the nodes in vector<node> then arranging them as per the requirement \\n\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<TreeNode*> &in){\\n        if(!root)\\n        return ;\\n\\n        inorder(root->left, in);\\n        in.push_back(root);\\n        inorder(root->right, in);\\n    }\\n\\n    TreeNode* balancing(int start, int end, vector<TreeNode*> &in){\\n        if(start>end) return NULL;\\n\\n        int mid = (start+end)/2;\\n        in[mid]->left = balancing(start, mid-1, in);\\n        in[mid]->right = balancing(mid+1, end, in);\\n        return in[mid];\\n    }\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> in;\\n        inorder(root, in);\\n        return balancing(0,in.size()-1, in);\\n    }\\n};"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        ino(root,list);\\nint e=list.size()-1;\\n      return  bs(list,0,e);\\n    }\\n\\n    public void ino(TreeNode root, ArrayList<Integer> list){\\n        if(root==null)return;\\nino(root.left,list);\\nlist.add(root.val);\\nino(root.right,list);\\n    }\\n\\n    public TreeNode bs(ArrayList<Integer> list,int s,int e){\\n        if(s>e) return null;\\n        int mid=s+(e-s)/2;\\n        TreeNode node=new TreeNode(list.get(mid));\\n        node.left=bs(list,s,mid-1);\\n        node.right=bs(list,mid+1,e);\\n        return node;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1976463,
                "content": [
                    {
                        "username": "ahcox",
                        "content": "Links to the algorithm for the optimal solution using just in-place node pointer manipulations:\\n\\n* [One-Time Binary Search Tree Balancing: The Day/Stout/Warren (DSW) Algorithm](https://web.archive.org/web/20220406184919/https://sci-hub.hkvisa.net/10.1145/820127.820173), 2002\\n* [Tree Rebalancing in Optimal Time and Space](http://web.eecs.umich.edu/~qstout/pap/CACM86.pdf), 1986\\n  This is the best one to read.\\n* [Balancing a Binary Tree, Algorithms Supplement, The Computer Journal, Volume 19, Issue 4, 1976, Pages 360\\u2013363](https://academic.oup.com/comjnl/article/19/4/360/326682)"
                    },
                    {
                        "username": "dimitars",
                        "content": "These look like some awesome reading materials. Thank you for sharing!"
                    },
                    {
                        "username": "raju31",
                        "content": "AVL tree solution ?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Does AVL tree always give us the minimum height?"
                    },
                    {
                        "username": "PadhakuLaunde",
                        "content": "We can convert this BST to sorted DLL (using same nodes as of tree -https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/)\\nThen sorted DLL to height balanced BST . I think this can save some space"
                    },
                    {
                        "username": "Simpola",
                        "content": "Did it in one shot, basically it comes under traversal of tree and there are really less ways to tackle it so you will come up with solution after few tries.\\n```\\n- tree ( convert to ) vector\\n- sort the vector\\n- sorted vector -> Inorder Traversal\\n- that\\'s all\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This question is quite tricky. I never want this question to come up in my interview!"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Alright, This question sucks!"
                    },
                    {
                        "username": "sxz1069",
                        "content": "Is it possible to adjust the input tree without building a new one? \\nAnyone have that kind of solution?"
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "I try this way and I couldn\\'t figure out why it\\'s not work yet, maybe it could help you a little bit\\n```\\nvoid selfBalanced(TreeNode* &root)\\n    {\\n        if(!root)\\n            return;\\n        else\\n        {\\n            while(!isBalanced(root))\\n            {\\n                int l = height(root->left);\\n                int r = height(root->right);\\n                if(l > r)\\n                    rotate_R(root);\\n                else\\n                    rotate_L(root);\\n            }\\n            selfBalanced(root->left);\\n            selfBalanced(root->right);\\n        }\\n    }\\n```\\n"
                    },
                    {
                        "username": "user0181Tj",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) \\nYeah I approached the same way. Was fairly simple implementation."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Maybe Yes, I am storing the nodes in vector<node> then arranging them as per the requirement \\n\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<TreeNode*> &in){\\n        if(!root)\\n        return ;\\n\\n        inorder(root->left, in);\\n        in.push_back(root);\\n        inorder(root->right, in);\\n    }\\n\\n    TreeNode* balancing(int start, int end, vector<TreeNode*> &in){\\n        if(start>end) return NULL;\\n\\n        int mid = (start+end)/2;\\n        in[mid]->left = balancing(start, mid-1, in);\\n        in[mid]->right = balancing(mid+1, end, in);\\n        return in[mid];\\n    }\\n\\n    TreeNode* balanceBST(TreeNode* root) {\\n        vector<TreeNode*> in;\\n        inorder(root, in);\\n        return balancing(0,in.size()-1, in);\\n    }\\n};"
                    },
                    {
                        "username": "Raveesh_gautam",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode balanceBST(TreeNode root) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        ino(root,list);\\nint e=list.size()-1;\\n      return  bs(list,0,e);\\n    }\\n\\n    public void ino(TreeNode root, ArrayList<Integer> list){\\n        if(root==null)return;\\nino(root.left,list);\\nlist.add(root.val);\\nino(root.right,list);\\n    }\\n\\n    public TreeNode bs(ArrayList<Integer> list,int s,int e){\\n        if(s>e) return null;\\n        int mid=s+(e-s)/2;\\n        TreeNode node=new TreeNode(list.get(mid));\\n        node.left=bs(list,s,mid-1);\\n        node.right=bs(list,mid+1,e);\\n        return node;\\n    }\\n}"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Number of Operations to Move All Balls to Each Box",
        "question_content": "<p>You have <code>n</code> boxes. You are given a binary string <code>boxes</code> of length <code>n</code>, where <code>boxes[i]</code> is <code>&#39;0&#39;</code> if the <code>i<sup>th</sup></code> box is <strong>empty</strong>, and <code>&#39;1&#39;</code> if it contains <strong>one</strong> ball.</p>\n\n<p>In one operation, you can move <strong>one</strong> ball from a box to an adjacent box. Box <code>i</code> is adjacent to box <code>j</code> if <code>abs(i - j) == 1</code>. Note that after doing so, there may be more than one ball in some boxes.</p>\n\n<p>Return an array <code>answer</code> of size <code>n</code>, where <code>answer[i]</code> is the <strong>minimum</strong> number of operations needed to move all the balls to the <code>i<sup>th</sup></code> box.</p>\n\n<p>Each <code>answer[i]</code> is calculated considering the <strong>initial</strong> state of the boxes.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> boxes = &quot;110&quot;\n<strong>Output:</strong> [1,1,3]\n<strong>Explanation:</strong> The answer for each box is as follows:\n1) First box: you will have to move one ball from the second box to the first box in one operation.\n2) Second box: you will have to move one ball from the first box to the second box in one operation.\n3) Third box: you will have to move one ball from the first box to the third box in two operations, and move one ball from the second box to the third box in one operation.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> boxes = &quot;001011&quot;\n<strong>Output:</strong> [11,8,5,4,3,4]</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == boxes.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2000</code></li>\n\t<li><code>boxes[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1075474,
                "title": "c-java-o-n-ltr-rtl",
                "content": "We first \"move\" balls from left to right, and track how many ops it takes for each box.\\n\\nFor that, we count how many balls we got so far in `cnt`, and accumulate it in `ops`.\\n\\nThen, we do the same from right to left. \\n\\n**C++**\\n```cpp\\nvector<int> minOperations(string boxes) {\\n    vector<int> res(boxes.length()); \\n    for (int i = 0, ops = 0, cnt = 0; i < boxes.length(); ++i) {\\n       res[i] += ops;\\n       cnt += boxes[i] == \\'1\\' ? 1 : 0;\\n       ops += cnt;\\n    }\\n    for (int i = boxes.length() - 1, ops = 0, cnt = 0; i >= 0; --i) {\\n        res[i] += ops;\\n        cnt += boxes[i] == \\'1\\' ? 1 : 0;\\n        ops += cnt;\\n    }\\n    return res;\\n}\\n```\\n\\n**Java**\\n```java\\npublic int[] minOperations(String boxes) {\\n    int[] res = new int[boxes.length()];\\n    for (int i = 0, ops = 0, cnt = 0; i < boxes.length(); ++i) {\\n       res[i] += ops;\\n       cnt += boxes.charAt(i) == \\'1\\' ? 1 : 0;\\n       ops += cnt;\\n    }    \\n    for (int i = boxes.length() - 1, ops = 0, cnt = 0; i >= 0; --i) {\\n        res[i] += ops;\\n        cnt += boxes.charAt(i) == \\'1\\' ? 1 : 0;\\n        ops += cnt;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> minOperations(string boxes) {\\n    vector<int> res(boxes.length()); \\n    for (int i = 0, ops = 0, cnt = 0; i < boxes.length(); ++i) {\\n       res[i] += ops;\\n       cnt += boxes[i] == \\'1\\' ? 1 : 0;\\n       ops += cnt;\\n    }\\n    for (int i = boxes.length() - 1, ops = 0, cnt = 0; i >= 0; --i) {\\n        res[i] += ops;\\n        cnt += boxes[i] == \\'1\\' ? 1 : 0;\\n        ops += cnt;\\n    }\\n    return res;\\n}\\n```\n```java\\npublic int[] minOperations(String boxes) {\\n    int[] res = new int[boxes.length()];\\n    for (int i = 0, ops = 0, cnt = 0; i < boxes.length(); ++i) {\\n       res[i] += ops;\\n       cnt += boxes.charAt(i) == \\'1\\' ? 1 : 0;\\n       ops += cnt;\\n    }    \\n    for (int i = boxes.length() - 1, ops = 0, cnt = 0; i >= 0; --i) {\\n        res[i] += ops;\\n        cnt += boxes.charAt(i) == \\'1\\' ? 1 : 0;\\n        ops += cnt;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1075895,
                "title": "easy-python-beats-100-time-and-space",
                "content": "Similar to **238. Product of Array Except Self** and **42. Trapping Rain Water**.\\nFor each index, the cost to move all boxes to it is sum of the cost ```leftCost``` to move all left boxes to it, and the cost ```rightCost``` to move all right boxes to it.\\n- ```leftCost``` for all indexes can be calculted using a single pass from left to right.\\n- ```rightCost``` for all indexes can be calculted using a single pass from right to left.\\n```\\nExample:\\nboxes      11010\\nleftCount  01223\\nleftCost   01358\\nrightCount 21100\\nrightCost  42100\\nans        43458\\n```\\n\\n```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        ans = [0]*len(boxes)\\n        leftCount, leftCost, rightCount, rightCost, n = 0, 0, 0, 0, len(boxes)\\n        for i in range(1, n):\\n            if boxes[i-1] == \\'1\\': leftCount += 1\\n            leftCost += leftCount # each step move to right, the cost increases by # of 1s on the left\\n            ans[i] = leftCost\\n        for i in range(n-2, -1, -1):\\n            if boxes[i+1] == \\'1\\': rightCount += 1\\n            rightCost += rightCount\\n            ans[i] += rightCost\\n        return ans\\n```\\n\\n![image](https://assets.leetcode.com/users/images/3d995443-d359-4b78-8d87-3064999f2fa8_1613890251.8506355.png)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```leftCost```\n```rightCost```\n```leftCost```\n```rightCost```\n```\\nExample:\\nboxes      11010\\nleftCount  01223\\nleftCost   01358\\nrightCount 21100\\nrightCost  42100\\nans        43458\\n```\n```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        ans = [0]*len(boxes)\\n        leftCount, leftCost, rightCount, rightCost, n = 0, 0, 0, 0, len(boxes)\\n        for i in range(1, n):\\n            if boxes[i-1] == \\'1\\': leftCount += 1\\n            leftCost += leftCount # each step move to right, the cost increases by # of 1s on the left\\n            ans[i] = leftCost\\n        for i in range(n-2, -1, -1):\\n            if boxes[i+1] == \\'1\\': rightCount += 1\\n            rightCost += rightCount\\n            ans[i] += rightCost\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336827,
                "title": "python-2-solutions-picture-explain-clean-concise-o-n",
                "content": "**\\u2714\\uFE0F Solution 1: Bruteforce Solution**\\n```\\nclass Solution(object):\\n    def minOperations(self, boxes):\\n        n = len(boxes)\\n        ans = [0] * n\\n        for i in range(n):\\n            for j in range(n):\\n                if boxes[j] == \\'1\\':\\n                    ans[i] += abs(j-i)\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 2000` is length of `boxes`.\\n- Space: `O(1)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: DP Left to Right and Right To Left**\\n- Let `leftDist[i]` is the total distance after moving all the ball from the left side to **ith box**.\\n- Let `leftBallCnt` is the number of balls after moving all the ball from the left side to **ith box** so far.\\n- To calculate `leftDist[i]`, we need to move `leftBallCnt` balls from **(i-1)th box** by one, so total distance:\\n\\t- `leftDist[i] = leftDist[i-1] + leftBallCnt`\\n- Do the same with `rightDist[i]` and `rightBallCnt` in the right side. \\n- To calculate total distance after moving all the ball from the left and the right side to **ith box**:\\n\\t- `ans[i] = leftDist[i] + rightDist[i]`\\n\\n![image](https://assets.leetcode.com/users/images/aa1c731c-ca2a-4bed-bfe5-06e3abe2e8d3_1626259914.2228394.png)\\n\\n\\n```python\\nclass Solution(object):\\n    def minOperations(self, boxes):\\n        n = len(boxes)\\n\\n        leftDist = [0] * n\\n        leftBallCnt = int(boxes[0])\\n        for i in range(1, n):\\n            leftDist[i] = leftDist[i - 1] + leftBallCnt\\n            leftBallCnt = leftBallCnt + int(boxes[i])\\n\\n        rightDist = [0] * n\\n        rightBallCnt = int(boxes[n - 1])\\n        for i in range(n - 2, -1, -1):\\n            rightDist[i] = rightDist[i + 1] + rightBallCnt\\n            rightBallCnt = rightBallCnt + int(boxes[i])\\n\\n        ans = [0] * n\\n        for i in range(n):\\n            ans[i] = leftDist[i] + rightDist[i]\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N <= 2000` is length of `boxes`.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minOperations(self, boxes):\\n        n = len(boxes)\\n        ans = [0] * n\\n        for i in range(n):\\n            for j in range(n):\\n                if boxes[j] == \\'1\\':\\n                    ans[i] += abs(j-i)\\n        return ans\\n```\n```python\\nclass Solution(object):\\n    def minOperations(self, boxes):\\n        n = len(boxes)\\n\\n        leftDist = [0] * n\\n        leftBallCnt = int(boxes[0])\\n        for i in range(1, n):\\n            leftDist[i] = leftDist[i - 1] + leftBallCnt\\n            leftBallCnt = leftBallCnt + int(boxes[i])\\n\\n        rightDist = [0] * n\\n        rightBallCnt = int(boxes[n - 1])\\n        for i in range(n - 2, -1, -1):\\n            rightDist[i] = rightDist[i + 1] + rightBallCnt\\n            rightBallCnt = rightBallCnt + int(boxes[i])\\n\\n        ans = [0] * n\\n        for i in range(n):\\n            ans[i] = leftDist[i] + rightDist[i]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075595,
                "title": "java-o-n-left-sum-and-right-sum",
                "content": "```\\n\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int n = boxes.length();\\n\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        int[] ans = new int[n];\\n\\n        int count = boxes.charAt(0) - \\'0\\';\\n        for(int i = 1 ; i < n ; i++){\\n            left[i] = left[i - 1] + count;\\n            count += boxes.charAt(i) - \\'0\\';\\n        }\\n\\n        count = boxes.charAt(n - 1) - \\'0\\';\\n        for(int i = n - 2 ; i >=0 ; i--){\\n            right[i] = right[i + 1] + count;\\n            count += boxes.charAt(i) - \\'0\\';\\n        }\\n\\t\\t\\n        for(int i = 0 ; i < n ; i++) {\\n            ans[i] = left[i] + right[i];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int n = boxes.length();\\n\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        int[] ans = new int[n];\\n\\n        int count = boxes.charAt(0) - \\'0\\';\\n        for(int i = 1 ; i < n ; i++){\\n            left[i] = left[i - 1] + count;\\n            count += boxes.charAt(i) - \\'0\\';\\n        }\\n\\n        count = boxes.charAt(n - 1) - \\'0\\';\\n        for(int i = n - 2 ; i >=0 ; i--){\\n            right[i] = right[i + 1] + count;\\n            count += boxes.charAt(i) - \\'0\\';\\n        }\\n\\t\\t\\n        for(int i = 0 ; i < n ; i++) {\\n            ans[i] = left[i] + right[i];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120427,
                "title": "easy-c-o-n-solution-in-2-pass",
                "content": "The idea here is to use use Prefix sum array. \\nWe iterate the given array twice, but in opposite direction. In 1st pass we move from left to right, storing the total balls to be moved from 0th index to current ith index (ie. all elements to left), in a variable (here sum) and res stores the operations needed to move all balls to ith index. Thus, res[i]= res[i-1]+ sum, gives minimum number of operations needed to move all balls from the left indices.\\n\\nSimilarily, we need to iterate from right to left and storing total balls in a variable (sum) and using it to find res[i], which is res[i]=res[i-1]+sum.\\n\\n**Time Complexity** :  O(N) due to the linear traversal from 1st element to last element & vice versa\\n**Space Complexity:** O(N) due to the space used to store the prefix sum and ultimately the result.\\n```\\nvector<int> minOperations(string boxes) {\\n        int n=boxes.length();\\n        vector<int>res(n);\\n        int last_cost=0, sum=boxes[0]-\\'0\\';\\n        for(int i=1;i<n;i++){\\n            res[i]+=sum+last_cost;\\n            last_cost=res[i];\\n            sum+=(boxes[i]-\\'0\\');\\n        }\\n        \\n        last_cost=0,sum=boxes[n-1]-\\'0\\';\\n        \\n        for(int i=n-2;i>=0;i--){\\n            res[i]+=sum+last_cost;\\n            last_cost=(sum+last_cost);\\n            sum+=(boxes[i]-\\'0\\');\\n        }\\n        return res;\\n    }\\n\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nvector<int> minOperations(string boxes) {\\n        int n=boxes.length();\\n        vector<int>res(n);\\n        int last_cost=0, sum=boxes[0]-\\'0\\';\\n        for(int i=1;i<n;i++){\\n            res[i]+=sum+last_cost;\\n            last_cost=res[i];\\n            sum+=(boxes[i]-\\'0\\');\\n        }\\n        \\n        last_cost=0,sum=boxes[n-1]-\\'0\\';\\n        \\n        for(int i=n-2;i>=0;i--){\\n            res[i]+=sum+last_cost;\\n            last_cost=(sum+last_cost);\\n            sum+=(boxes[i]-\\'0\\');\\n        }\\n        return res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1075518,
                "title": "clean-python-3-two-passes-o-n",
                "content": "Time: `O(N)`\\nSpace: `O(N)`\\n```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        n = len(boxes)\\n        answer = [0] * n\\n        curr, steps = 0, 0\\n        for i in range(n):\\n            answer[i] += steps\\n            curr += int(boxes[i])\\n            steps += curr\\n        curr, steps = 0, 0\\n        for i in reversed(range(n)):\\n            answer[i] += steps\\n            curr += int(boxes[i])\\n            steps += curr\\n        return answer\\n```\\n\\nor shorter (by @KellyBundy)\\n```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        n = len(boxes)\\n        answer = [0] * n\\n        for I in range(n), reversed(range(n)):\\n            curr = steps = 0\\n            for i in I:\\n                answer[i] += steps\\n                curr += int(boxes[i])\\n                steps += curr\\n        return answer\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        n = len(boxes)\\n        answer = [0] * n\\n        curr, steps = 0, 0\\n        for i in range(n):\\n            answer[i] += steps\\n            curr += int(boxes[i])\\n            steps += curr\\n        curr, steps = 0, 0\\n        for i in reversed(range(n)):\\n            answer[i] += steps\\n            curr += int(boxes[i])\\n            steps += curr\\n        return answer\\n```\n```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        n = len(boxes)\\n        answer = [0] * n\\n        for I in range(n), reversed(range(n)):\\n            curr = steps = 0\\n            for i in I:\\n                answer[i] += steps\\n                curr += int(boxes[i])\\n                steps += curr\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117526,
                "title": "java-100-faster-two-pass-with-explanation",
                "content": "First let\\'s look at the O(N^2) solution - \\nSimply do a double iteration and for each ball found, compute the distance and add it to the cost. Easy peasy.\\n```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int len = boxes.length();\\n        int[] ans = new int[len];\\n        for(int i=0;i<len;i++){\\n            int cost = 0;\\n            for(int j=0;j<len;j++){\\n                if(boxes.charAt(j)==\\'1\\') cost += Math.abs(i-j);\\n            }\\n            ans[i] = cost;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nNow, let\\'s take a look at the O(N) solution. The code has two passes, forward and back. \\nThe assumption is when we travel forward we\\'re only considering the balls that are left to the current index, similarly when we travel back we\\'re only considering the balls that are to the right of the current index.\\nWhen moving forward, the cost of moving balls to the right for ith index can be computed if we know the total number of balls till (i-1)th index and the cost of moving balls till (i-1)th index i.e\\n*forward[i] = forward[i-1]+number_of_balls_till_i-1*\\nIn a similar fashion, \\n*back[i] = back[i+1]+number_of_balls_till_i+1*\\n\\nOnce we have both these values, the answer is simply the summation of the forward and backward costs.\\n```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int len = boxes.length();\\n        int[] forward = new int[len];\\n        int prev = (boxes.charAt(0)==\\'0\\'?0:1);\\n        for(int i=1;i<len;i++){\\n            forward[i] += forward[i-1]+prev;\\n            prev += (boxes.charAt(i)==\\'0\\'?0:1);\\n        }\\n        prev = (boxes.charAt(len-1)==\\'0\\'?0:1);\\n        int[] back = new int[len];\\n        for(int i=len-2;i>=0;i--){\\n            back[i] += back[i+1]+prev;\\n            prev += (boxes.charAt(i)==\\'0\\'?0:1);\\n        }\\n        int[] op = new int[len];\\n        for(int i=0;i<len;i++) op[i] = forward[i]+back[i];\\n        return op;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int len = boxes.length();\\n        int[] ans = new int[len];\\n        for(int i=0;i<len;i++){\\n            int cost = 0;\\n            for(int j=0;j<len;j++){\\n                if(boxes.charAt(j)==\\'1\\') cost += Math.abs(i-j);\\n            }\\n            ans[i] = cost;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int len = boxes.length();\\n        int[] forward = new int[len];\\n        int prev = (boxes.charAt(0)==\\'0\\'?0:1);\\n        for(int i=1;i<len;i++){\\n            forward[i] += forward[i-1]+prev;\\n            prev += (boxes.charAt(i)==\\'0\\'?0:1);\\n        }\\n        prev = (boxes.charAt(len-1)==\\'0\\'?0:1);\\n        int[] back = new int[len];\\n        for(int i=len-2;i>=0;i--){\\n            back[i] += back[i+1]+prev;\\n            prev += (boxes.charAt(i)==\\'0\\'?0:1);\\n        }\\n        int[] op = new int[len];\\n        for(int i=0;i<len;i++) op[i] = forward[i]+back[i];\\n        return op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085988,
                "title": "prefix-sum-c-with-explain",
                "content": "### Brute & Force (Accepted)\\n#### Idea\\nFor every element `i` in `boxes`, we travel the whole array and count the distance from element `i` to `j`, if `boxes[j] == \\'1\\'`.\\n#### Time Complexity\\nO(n^2)\\n> Notice that this solution is accepted because the size of test data is small (2000). Generally this method may cause TLE when the size of test data is in 10^4 or larger.\\n\\n#### Code\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n = boxes.size();\\n        vector<int> ans;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int res = 0;\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(boxes[j] == \\'1\\')\\n                {\\n                    res += abs(i-j);\\n                }\\n            }\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n### Prefix Sum\\n#### Idea\\nIn above, we traveled the whole array for every element. But actually, things could be easier.\\nLet\\'s consider the following situation: we have handled the `i`th element and we have known that the answer is `answer[i]`, i.e., **the minimum number of operations to move all balls to box `i` is `answer[i]`**.    \\n\\nNotice that, when the pointer moves to `i+1`, if there are `cntl` `\\'1\\'`s in the left of `i+1` (i.e., [0, i]), the total cost will be added by `cntl` compared with `x`. That\\'s beacuse you need to move all of them further by 1. Similarily, when the pointer moves to `i+1`, if there are `cntr` `\\'1\\'`s in the right of `i` (i.e., [i+1, n-1]), the total cost will be subtracted  by `cntr`.  That\\'s because you can move them to `i+1` in a less cost compared with moving them to `i`. \\n\\nHence, we have `answer[i+1] = answer[i] + cntl - cntr`. \\nAnd that\\'s the key. \\n\\n#### Time Complexity\\nO(n)\\n\\n### Code\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string bs) {\\n        int n = bs.size();\\n\\t\\t\\n\\t\\t// We use l[i] to record there are how many 1s before index i\\n\\t\\t// and r[i] to record there are how many 1s after index i, including i.\\n        vector<int> l(n, 0), r(n + 1, 0), ans(n, 0);\\n\\t\\t\\n\\t\\t// Initialisation of l\\n\\t\\t// With out loss of generality, we can count the answer for index 0 and deduce other answers based on answer[0]\\n\\t\\t// We count answer[0] simultaneously here\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(bs[i-1] == \\'1\\')\\n            {\\n                l[i] = l[i-1] + 1;\\n                ans[0] += i-1;\\n            }\\n            else\\n                l[i] = l[i-1]; \\n        }\\n        if(bs[n-1] == \\'1\\')ans[0] += n - 1;\\n\\n\\t\\t// Initialisation of r\\n        for(int i = n - 1; i >= 0; i --)\\n        {\\n            if(bs[i] == \\'1\\') r[i] = r[i+1] + 1;\\n            else r[i] = r[i+1];\\n        }\\n\\n        for(int i = 1; i < n; i++)\\n        {\\n            ans[i] = ans[i - 1] + l[i] - r[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n = boxes.size();\\n        vector<int> ans;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int res = 0;\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(boxes[j] == \\'1\\')\\n                {\\n                    res += abs(i-j);\\n                }\\n            }\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string bs) {\\n        int n = bs.size();\\n\\t\\t\\n\\t\\t// We use l[i] to record there are how many 1s before index i\\n\\t\\t// and r[i] to record there are how many 1s after index i, including i.\\n        vector<int> l(n, 0), r(n + 1, 0), ans(n, 0);\\n\\t\\t\\n\\t\\t// Initialisation of l\\n\\t\\t// With out loss of generality, we can count the answer for index 0 and deduce other answers based on answer[0]\\n\\t\\t// We count answer[0] simultaneously here\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(bs[i-1] == \\'1\\')\\n            {\\n                l[i] = l[i-1] + 1;\\n                ans[0] += i-1;\\n            }\\n            else\\n                l[i] = l[i-1]; \\n        }\\n        if(bs[n-1] == \\'1\\')ans[0] += n - 1;\\n\\n\\t\\t// Initialisation of r\\n        for(int i = n - 1; i >= 0; i --)\\n        {\\n            if(bs[i] == \\'1\\') r[i] = r[i+1] + 1;\\n            else r[i] = r[i+1];\\n        }\\n\\n        for(int i = 1; i < n; i++)\\n        {\\n            ans[i] = ans[i - 1] + l[i] - r[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075946,
                "title": "c-o-n-dp",
                "content": "**Approach** - \\nThe minimum number of moves to move all balls to box[i] will be the number of minimum moves to move balls to moves[i-1] + moves[i+1]\\ni.e. box[i] = moveLeft[i-1] + moveRight[i+1]\\n\\nTime Complexity - O(N)\\nSpace Complexity - O(N)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        vector<int> left(boxes.size(), 0), right(boxes.size(), 0), ans(boxes.size(), 0);\\n        int balls = 0;\\n        \\n        balls = boxes[0] - \\'0\\';\\n        for(int i=1;i<boxes.size();i++){\\n            left[i] = left[i-1] + balls;\\n            balls += boxes[i] - \\'0\\';\\n        }\\n        \\n        balls = boxes[boxes.size()-1] - \\'0\\';\\n        for(int i=boxes.size()-2;i>=0;i--){\\n            right[i] = right[i+1] + balls;\\n            balls += boxes[i] - \\'0\\';\\n        }\\n        \\n        for(int i=0;i<boxes.size();i++)\\n            ans[i] = left[i] + right[i];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        vector<int> left(boxes.size(), 0), right(boxes.size(), 0), ans(boxes.size(), 0);\\n        int balls = 0;\\n        \\n        balls = boxes[0] - \\'0\\';\\n        for(int i=1;i<boxes.size();i++){\\n            left[i] = left[i-1] + balls;\\n            balls += boxes[i] - \\'0\\';\\n        }\\n        \\n        balls = boxes[boxes.size()-1] - \\'0\\';\\n        for(int i=boxes.size()-2;i>=0;i--){\\n            right[i] = right[i+1] + balls;\\n            balls += boxes[i] - \\'0\\';\\n        }\\n        \\n        for(int i=0;i<boxes.size();i++)\\n            ans[i] = left[i] + right[i];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084304,
                "title": "rtl-ltr-explanation-python-3-100",
                "content": "I was having some trouble grasping the idea of doing two traversals, and I wrote down it in a way that helped me understand. Perhaps it might help some of you as well.\\n\\nFor any element `i`, the left-to-right traversal will provide the number of operations needed to move all the balls in `0..i` to the `i`\\'th box. Similarly, the right-to-left traversal provides us the number of operations needed to move the balls in `i+1..n` range. Summing these two up, we get the total number of operations for `i`.\\n\\nTo calculate the LTR/RTL sum, we keep track of the number of balls encountered thus far. Let\\'s call this variable `ctr`. For every array index traversed, we increment the number of operations needed by `ctr`, because we need **one operation each** to move those balls from `i-1` to `i` and we have encountered `ctr` such balls so far. To keep track of the number of operations for each `i`, we use an array.\\n\\n```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        operations = 0\\n        ctr = 0\\n        answer = [0]*len(boxes)\\n        for i in range(len(boxes)):\\n            operations += ctr\\n            if boxes[i] == \"1\":\\n                ctr += 1\\n            answer[i] += operations\\n        operations = 0\\n        ctr = 0\\n        for i in range(len(boxes)-1, -1, -1):\\n            operations += ctr\\n            if boxes[i] == \"1\":\\n                ctr += 1\\n            answer[i] += operations\\n        return answer\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        operations = 0\\n        ctr = 0\\n        answer = [0]*len(boxes)\\n        for i in range(len(boxes)):\\n            operations += ctr\\n            if boxes[i] == \"1\":\\n                ctr += 1\\n            answer[i] += operations\\n        operations = 0\\n        ctr = 0\\n        for i in range(len(boxes)-1, -1, -1):\\n            operations += ctr\\n            if boxes[i] == \"1\":\\n                ctr += 1\\n            answer[i] += operations\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075669,
                "title": "c-o-n-keep-track-of-of-balls-to-the-right-and-left",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1.\\n\\nAssume we are at `s[i]` and the corresponding operations needed is `sum`. When we move from `s[i]` to `s[i + 1]`, if there are `left` balls that have indexes `<= i` and `right` balls that have indexes `> i`, then the number of operations needed for `s[i + 1]` will be `sum + left - right`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string s) {\\n        int N = s.size(), sum = 0, right = 0, left = 0;\\n        vector<int> ans(s.size());\\n        for (int i = 0; i < N; ++i) {\\n            if (s[i] == \\'1\\') sum += i, ++right;\\n        }\\n        for (int i = 0; i < N; ++i) {\\n            ans[i] = sum;\\n            if (s[i] == \\'1\\') --right, ++left;\\n            sum += left - right;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string s) {\\n        int N = s.size(), sum = 0, right = 0, left = 0;\\n        vector<int> ans(s.size());\\n        for (int i = 0; i < N; ++i) {\\n            if (s[i] == \\'1\\') sum += i, ++right;\\n        }\\n        for (int i = 0; i < N; ++i) {\\n            ans[i] = sum;\\n            if (s[i] == \\'1\\') --right, ++left;\\n            sum += left - right;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201401,
                "title": "c-solution-o-n-expalined-in-details",
                "content": "\\nThis can be a bit tricky especially for the beginners however, you can definitely understand the approach and solve it.\\n\\nAs per the question \\'**1**\\' represent a box containing exactly one ball and \\'**0**\\' represent the empty box.\\n\\nThe Approach to solving this problem is **to traverse the string left to right** and **traverse the string left to right**. This is because the **left to right traversal** count the number of operations required to transfer ball in **right direction** to **ith** position and vice versa.\\n\\n### Left to right traversal \\nNow the operation at **ith position** is calculated as the sum of  **total operation at (i-1)th (adjacent position) plus the number of balls seen so far during traversal**. This is because total operation necessary to transfer all balls to adjacent position is already calculated the only number of extra operation required is to transfer all the balls from adjacent to current position which is equal to **1 operation  X no. of ball seen**\\n\\n### Right to Left traversal \\nPretty much the same thing like the left to right traversal.\\n\\n\\n```\\n vector<int> minOperations(string boxes) \\n\\t{\\n\\t\\t int sum=0;\\n\\t\\t int ballSeen =0;\\n\\t\\t  vector<int> result(boxes.size(), 0);\\n                \\n            for( int i=1; i<boxes.size(); ++i )\\n\\t\\t {\\n\\t\\t\\t if( boxes[i-1] ==\\'1\\')\\n\\t\\t\\t { \\n\\t\\t\\t\\t ballSeen+=1;\\n\\t\\t\\t }\\n\\t\\t\\t sum+=ballSeen;\\n\\t\\t\\tresult[i]+=sum;\\n\\t\\t }\\n\\n\\t\\t sum=0;\\n\\t\\t ballSeen=0;\\n\\t\\t for( int i=boxes.size()-2; i>=0; --i )\\n\\t\\t {\\n\\t\\t\\t if( boxes[i+1] ==\\'1\\')\\n\\t\\t\\t { \\n\\t\\t\\t\\t ballSeen+=1;\\n\\t\\t\\t }\\n\\t\\t\\t sum+=ballSeen;\\n\\t\\t\\t result[i]+=sum;\\n\\t\\t }\\n\\t\\t \\n\\t\\treturn result;\\n    }\\n```\\nIf this helped you in understanding the approach don\\'t forget to upvote. :)",
                "solutionTags": [],
                "code": "```\\n vector<int> minOperations(string boxes) \\n\\t{\\n\\t\\t int sum=0;\\n\\t\\t int ballSeen =0;\\n\\t\\t  vector<int> result(boxes.size(), 0);\\n                \\n            for( int i=1; i<boxes.size(); ++i )\\n\\t\\t {\\n\\t\\t\\t if( boxes[i-1] ==\\'1\\')\\n\\t\\t\\t { \\n\\t\\t\\t\\t ballSeen+=1;\\n\\t\\t\\t }\\n\\t\\t\\t sum+=ballSeen;\\n\\t\\t\\tresult[i]+=sum;\\n\\t\\t }\\n\\n\\t\\t sum=0;\\n\\t\\t ballSeen=0;\\n\\t\\t for( int i=boxes.size()-2; i>=0; --i )\\n\\t\\t {\\n\\t\\t\\t if( boxes[i+1] ==\\'1\\')\\n\\t\\t\\t { \\n\\t\\t\\t\\t ballSeen+=1;\\n\\t\\t\\t }\\n\\t\\t\\t sum+=ballSeen;\\n\\t\\t\\t result[i]+=sum;\\n\\t\\t }\\n\\t\\t \\n\\t\\treturn result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1184205,
                "title": "javascript-easy-to-follow-o-n-92ms",
                "content": "```js\\nfunction minOperations(boxes) {\\n  const result = Array(boxes.length).fill(0);\\n  \\n  // First we make one pass through the array (left to right).\\n  // For each index, we calculate the moves needed to get every\\n  // non-empty box on the left of the current index to the current index.\\n  \\n  // At each i in boxes:\\n  //   - add the running sum to result[i]\\n  //   - increment the notEmpty box count if the current box is \\'1\\'\\n  //   - add the previously seen notEmpty boxes (including current index) to the runningSum\\n  \\n  let notEmpty = 0;\\n  let runningSum = 0;\\n  \\n  for (let i = 0; i < boxes.length; ++i) {\\n    result[i] += runningSum;\\n    if (boxes[i] === \\'1\\') ++notEmpty;\\n    runningSum += notEmpty;\\n  }\\n  \\n  // Make one more pass through the array (right to left).\\n  // The operations are identical to the first loop, except that\\n  // this pass calculates the moves needed to get every non-empty box\\n  // on the right of each index to the current index.\\n  \\n  notEmpty = 0;\\n  runningSum = 0;\\n  \\n  for (let i = boxes.length - 1; i >= 0; --i) {\\n    result[i] += runningSum;\\n    if (boxes[i] === \\'1\\') ++notEmpty;\\n    runningSum += notEmpty;\\n  }\\n  \\n  return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nfunction minOperations(boxes) {\\n  const result = Array(boxes.length).fill(0);\\n  \\n  // First we make one pass through the array (left to right).\\n  // For each index, we calculate the moves needed to get every\\n  // non-empty box on the left of the current index to the current index.\\n  \\n  // At each i in boxes:\\n  //   - add the running sum to result[i]\\n  //   - increment the notEmpty box count if the current box is \\'1\\'\\n  //   - add the previously seen notEmpty boxes (including current index) to the runningSum\\n  \\n  let notEmpty = 0;\\n  let runningSum = 0;\\n  \\n  for (let i = 0; i < boxes.length; ++i) {\\n    result[i] += runningSum;\\n    if (boxes[i] === \\'1\\') ++notEmpty;\\n    runningSum += notEmpty;\\n  }\\n  \\n  // Make one more pass through the array (right to left).\\n  // The operations are identical to the first loop, except that\\n  // this pass calculates the moves needed to get every non-empty box\\n  // on the right of each index to the current index.\\n  \\n  notEmpty = 0;\\n  runningSum = 0;\\n  \\n  for (let i = boxes.length - 1; i >= 0; --i) {\\n    result[i] += runningSum;\\n    if (boxes[i] === \\'1\\') ++notEmpty;\\n    runningSum += notEmpty;\\n  }\\n  \\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1613928,
                "title": "drive-equation-100-fast-java",
                "content": "![image](https://assets.leetcode.com/users/images/d3fe940c-663e-4500-aee7-5b5995c51f0e_1638756782.6873157.png)\\n\\n\\n**Implementation Of Above Equation**\\n```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int n =  boxes.length();\\n        int suffix[] =  new int[n];\\n        int prefix[] =  new int[n];\\n        int count1=0;\\n        if(boxes.charAt(0)==\\'1\\') count1++;\\n        for(int i=1;i<n;i++ ){\\n            prefix[i] =  prefix[i-1]+count1;\\n            \\n            if(boxes.charAt(i)==\\'1\\') count1++;\\n        }\\n        count1=0;\\n        if(boxes.charAt(n-1)==\\'1\\') count1++;\\n        for(int i=n-2;i>=0;i--){\\n            suffix[i] = suffix[i+1]+count1;\\n            if(boxes.charAt(i)==\\'1\\') count1++;\\n        }\\n        \\n        int ans[] =  new int[n];\\n        for(int i=0;i<n;i++){\\n            ans[i]=  prefix[i]+suffix[i];\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int n =  boxes.length();\\n        int suffix[] =  new int[n];\\n        int prefix[] =  new int[n];\\n        int count1=0;\\n        if(boxes.charAt(0)==\\'1\\') count1++;\\n        for(int i=1;i<n;i++ ){\\n            prefix[i] =  prefix[i-1]+count1;\\n            \\n            if(boxes.charAt(i)==\\'1\\') count1++;\\n        }\\n        count1=0;\\n        if(boxes.charAt(n-1)==\\'1\\') count1++;\\n        for(int i=n-2;i>=0;i--){\\n            suffix[i] = suffix[i+1]+count1;\\n            if(boxes.charAt(i)==\\'1\\') count1++;\\n        }\\n        \\n        int ans[] =  new int[n];\\n        for(int i=0;i<n;i++){\\n            ans[i]=  prefix[i]+suffix[i];\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1614367,
                "title": "python-o-n-solution-easy-to-understand",
                "content": "At beginning, calculate the total distance that put all the balls into the first box, and also calculate how many balls are after the first box (including it self). \\nAnd runs again to put the distance in the answer list, the first distance is already been calculated, then the question is how we calculate the remaining? By moving forward one box, all the balls behind are 1 distance less, and the balls behind are 1 distance added, so the thing is to know how many balls are after and before the box, then we can calculate for each box by add the amount of balls before and minus the amount of balls after the box. \\nThe time complexity is O(n) * 2 ~= O(n)\\n```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        l = len(boxes)\\n        ans = [0] * l\\n        before = 0\\n        after = 0\\n        num = 0\\n        for i in range(l):\\n            if boxes[i] == \"1\":\\n                after += 1\\n                num += i\\n        for i in range(l):\\n            ans[i] = num\\n            if boxes[i] == \"1\":\\n                before += 1\\n                after -= 1\\n            num += before - after\\n        return ans\\n```\\nThis is my first post, feel free to comment or discuss, thank you!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        l = len(boxes)\\n        ans = [0] * l\\n        before = 0\\n        after = 0\\n        num = 0\\n        for i in range(l):\\n            if boxes[i] == \"1\":\\n                after += 1\\n                num += i\\n        for i in range(l):\\n            ans[i] = num\\n            if boxes[i] == \"1\":\\n                before += 1\\n                after -= 1\\n            num += before - after\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328289,
                "title": "c-explained-ltr-rtl-o-n",
                "content": "```\\n\\n/*\\n\\nHarshit Gupta | 10th July, 2021\\n--------------------------------\\n\\nMinimum Number of Operations to Move All Balls to Each Box\\n\\nYou have n boxes. You are given a binary string boxes of length n, where boxes[i] is \\'0\\' if the ith box is empty, \\n    and \\'1\\' if it contains one ball.\\nIn one operation, you can move one ball from a box to an adjacent box. Box i is adjacent to box j if abs(i - j) == 1. \\n    Note that after doing so, there may be more than one ball in some boxes.\\nReturn an array answer of size n, where answer[i] is the minimum number of operations needed to move all the balls \\n    to the ith box.\\n\\nEach answer[i] is calculated considering the initial state of the boxes.\\n\\nExample 1:\\n    Input: boxes = \"110\"\\n    Output: [1,1,3]\\n    Explanation: The answer for each box is as follows:\\n    1) First box: you will have to move one ball from the second box to the first box in one operation.\\n    2) Second box: you will have to move one ball from the first box to the second box in one operation.\\n    3) Third box: you will have to move one ball from the first box to the third box in two operations, \\n        and move one ball from the second box to the third box in one operation.\\n\\nExample 2:\\n    Input: boxes = \"001011\"\\n    Output: [11,8,5,4,3,4]\\n\\nhttps://leetcode.com/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/\\n------\\n\\nSolution: For each element in the array, we have to find the distance with all the 1s in the array.\\n\\n    1. Brute Force:\\n        For each element in the array, check for all 1s in the array and add the dist of all 1s.\\n\\n        TC: O(n2)\\n        SC: O(1)\\n\\n    2. LeftToRight + RightToLeft Traversal:\\n        - For each element, calculate the number of 1s on its left and 1s on its right\\n        - For each element, calculate the cost of 1s from the elements on its left & similarly calcualate cost \\n            of 1s from the elements on its right\\n        - Add the leftCost & rightCost for each i\\n    \\n        Example:\\n        boxes      11010\\n        leftCount  01223 (How many 1s are to the left of your index)\\n        leftCost   01358 (What is the cost of 1s to the left of your index)\\n        rightCount 21100 (How many 1s are to the right of your index)\\n        rightCost  42100 (What is the cost of 1s to the right of your index)\\n        ans        43458 (Total cost of 1s to the left + right)\\n\\n        TC: O(n)\\n        SC: O(n)\\n\\nParadigm:\\n---\\n  NOTE: \\n\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n = boxes.size();\\n        vector<int> leftCost(n), leftCount(n);\\n        vector<int> rightCost(n), rightCount(n);\\n        vector<int> res;\\n        \\n        for(int i=1; i<n; i++){\\n            if(boxes[i-1] == \\'1\\')\\n                leftCount[i] = leftCount[i-1]+1;\\n            else \\n                leftCount[i] = leftCount[i-1];\\n            leftCost[i] = leftCost[i-1]+leftCount[i];\\n        }\\n        \\n        for(int i=n-2; i>=0; i--){\\n            if(boxes[i+1] == \\'1\\')\\n                rightCount[i] = rightCount[i+1]+1;\\n            else \\n                rightCount[i] = rightCount[i+1];\\n            rightCost[i] = rightCost[i+1]+rightCount[i];\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            res.push_back(leftCost[i]+rightCost[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\n/*\\n\\nHarshit Gupta | 10th July, 2021\\n--------------------------------\\n\\nMinimum Number of Operations to Move All Balls to Each Box\\n\\nYou have n boxes. You are given a binary string boxes of length n, where boxes[i] is \\'0\\' if the ith box is empty, \\n    and \\'1\\' if it contains one ball.\\nIn one operation, you can move one ball from a box to an adjacent box. Box i is adjacent to box j if abs(i - j) == 1. \\n    Note that after doing so, there may be more than one ball in some boxes.\\nReturn an array answer of size n, where answer[i] is the minimum number of operations needed to move all the balls \\n    to the ith box.\\n\\nEach answer[i] is calculated considering the initial state of the boxes.\\n\\nExample 1:\\n    Input: boxes = \"110\"\\n    Output: [1,1,3]\\n    Explanation: The answer for each box is as follows:\\n    1) First box: you will have to move one ball from the second box to the first box in one operation.\\n    2) Second box: you will have to move one ball from the first box to the second box in one operation.\\n    3) Third box: you will have to move one ball from the first box to the third box in two operations, \\n        and move one ball from the second box to the third box in one operation.\\n\\nExample 2:\\n    Input: boxes = \"001011\"\\n    Output: [11,8,5,4,3,4]\\n\\nhttps://leetcode.com/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/\\n------\\n\\nSolution: For each element in the array, we have to find the distance with all the 1s in the array.\\n\\n    1. Brute Force:\\n        For each element in the array, check for all 1s in the array and add the dist of all 1s.\\n\\n        TC: O(n2)\\n        SC: O(1)\\n\\n    2. LeftToRight + RightToLeft Traversal:\\n        - For each element, calculate the number of 1s on its left and 1s on its right\\n        - For each element, calculate the cost of 1s from the elements on its left & similarly calcualate cost \\n            of 1s from the elements on its right\\n        - Add the leftCost & rightCost for each i\\n    \\n        Example:\\n        boxes      11010\\n        leftCount  01223 (How many 1s are to the left of your index)\\n        leftCost   01358 (What is the cost of 1s to the left of your index)\\n        rightCount 21100 (How many 1s are to the right of your index)\\n        rightCost  42100 (What is the cost of 1s to the right of your index)\\n        ans        43458 (Total cost of 1s to the left + right)\\n\\n        TC: O(n)\\n        SC: O(n)\\n\\nParadigm:\\n---\\n  NOTE: \\n\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n = boxes.size();\\n        vector<int> leftCost(n), leftCount(n);\\n        vector<int> rightCost(n), rightCount(n);\\n        vector<int> res;\\n        \\n        for(int i=1; i<n; i++){\\n            if(boxes[i-1] == \\'1\\')\\n                leftCount[i] = leftCount[i-1]+1;\\n            else \\n                leftCount[i] = leftCount[i-1];\\n            leftCost[i] = leftCost[i-1]+leftCount[i];\\n        }\\n        \\n        for(int i=n-2; i>=0; i--){\\n            if(boxes[i+1] == \\'1\\')\\n                rightCount[i] = rightCount[i+1]+1;\\n            else \\n                rightCount[i] = rightCount[i+1];\\n            rightCost[i] = rightCost[i+1]+rightCount[i];\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            res.push_back(leftCost[i]+rightCost[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624704,
                "title": "java-thought-process-brute-force-optimal",
                "content": "After reading the question, it is quite easy to kick-off the Brute Force Solution : \\n\\n# Brute-Force Solution:\\n```\\n* TC : O(n2)\\n* SC : O(1)\\n\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        if(boxes == null || boxes.length()==0) return new int[]{};\\n        int n = boxes.length();\\n        int[] result = new int[n];\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i!=j && boxes.charAt(j)!=\\'0\\') {\\n                    result[i] += Math.abs(j-i);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n# Optimized Approach :\\n\\nThe question highlights : \\n\\n\\tthe minimum number of operations needed to move all the balls to the ith box.\\n\\t\\n\\t\\nSo, if we try to find the number of operations to move all the balls to ith index and that too minimum then we are done.\\n\\n* Let\\'s take two arrays Left[] and Right[] ( why ? -> It is given that we are allowed to move the balls in an adjacent manner so, we will have to levy some space to reduce our time complexity from 10^6 or n2 to a linear solution )\\n\\nWhen we say calculating the number of operations for moving all the balls to the left of a box to that box, say we are at the ith position(or box). This consists of two parts : \\n1. first left[i - 1] will give us the number of operations to move all the balls so far till (i - 1) th position and now we have all the balls till the (i - 1) th position in the (i - 1) th box. \\n\\n2. The next part involves moving all those balls in (i - 1) th position to the i th position. Also note the cost of moving a single ball by 1 position is 1. Thus, we need to keep in account the number of balls so that we can calculate the cost to move the balls in previous boxes to ith position, as the cost to move a ball in adjacent manner is 1. So, `left[i] = left[i - 1] + (1 * balls)` where 1 here is the cost of moving a single ball in adjacent fashion.\\n\\n**Note : The number of balls will be used to calculate the number of operations to move the balls at i-1 th index to ith index.**\\n\\t\\n```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        if(boxes == null || boxes.length()==0) return new int[]{};\\n        int n = boxes.length();\\n        \\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        int[] result = new int[n];\\n        \\n        // Left to Right\\n        int balls = boxes.charAt(0) == \\'1\\' ? 1 : 0;\\n        for(int i=1;i<n;i++) {\\n            left[i] = left[i-1] + 1 * balls;\\n            balls += boxes.charAt(i) == \\'1\\' ? 1 : 0;\\n        }\\n        \\n        // Right to Left\\n        balls = boxes.charAt(n-1) == \\'1\\' ? 1 : 0;\\n        for(int i=n-2;i>=0;i--) {\\n            right[i] = right[i+1] + 1 * balls;\\n            balls += boxes.charAt(i) == \\'1\\' ? 1 : 0;\\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            result[i] = left[i] + right[i];\\n        }\\n        return result;\\n    }\\n}\\n\\nTC : O(n)\\nSC : O(n)\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n* TC : O(n2)\\n* SC : O(1)\\n\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        if(boxes == null || boxes.length()==0) return new int[]{};\\n        int n = boxes.length();\\n        int[] result = new int[n];\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i!=j && boxes.charAt(j)!=\\'0\\') {\\n                    result[i] += Math.abs(j-i);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        if(boxes == null || boxes.length()==0) return new int[]{};\\n        int n = boxes.length();\\n        \\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        int[] result = new int[n];\\n        \\n        // Left to Right\\n        int balls = boxes.charAt(0) == \\'1\\' ? 1 : 0;\\n        for(int i=1;i<n;i++) {\\n            left[i] = left[i-1] + 1 * balls;\\n            balls += boxes.charAt(i) == \\'1\\' ? 1 : 0;\\n        }\\n        \\n        // Right to Left\\n        balls = boxes.charAt(n-1) == \\'1\\' ? 1 : 0;\\n        for(int i=n-2;i>=0;i--) {\\n            right[i] = right[i+1] + 1 * balls;\\n            balls += boxes.charAt(i) == \\'1\\' ? 1 : 0;\\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            result[i] = left[i] + right[i];\\n        }\\n        return result;\\n    }\\n}\\n\\nTC : O(n)\\nSC : O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744956,
                "title": "c-two-solution-brute-force-optimized",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        \\n        // brute force   tc->O(N^N)  + sc->O(N)  \\n        \\n        vector<int>ans(boxes.length());\\n        for(int i = 0 ; i < boxes.length() ; i++){\\n            int cnt = 0;\\n            for(int j = 0 ; j < boxes.length() ; j++){\\n                if(i != j && boxes[j] == \\'1\\'){\\n                    cnt += abs(i-j);\\n                }\\n            }\\n            ans[i] = cnt;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n    \\n    // optimized approach   \\n\\n    // Time: O(N)\\n    // Space: O(1)\\n        \\n        \\nclass Solution {\\npublic:\\n    vector<int> minOperations(string s) {\\n        int N = s.size(), sum = 0, right = 0, left = 0;\\n        vector<int> ans(s.size());\\n        for (int i = 0; i < N; ++i) {\\n            if (s[i] == \\'1\\') sum += i, ++right;\\n        }\\n        for (int i = 0; i < N; ++i) {\\n            ans[i] = sum;\\n            if (s[i] == \\'1\\') --right, ++left;\\n            sum += left - right;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        \\n        // brute force   tc->O(N^N)  + sc->O(N)  \\n        \\n        vector<int>ans(boxes.length());\\n        for(int i = 0 ; i < boxes.length() ; i++){\\n            int cnt = 0;\\n            for(int j = 0 ; j < boxes.length() ; j++){\\n                if(i != j && boxes[j] == \\'1\\'){\\n                    cnt += abs(i-j);\\n                }\\n            }\\n            ans[i] = cnt;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n    \\n    // optimized approach   \\n\\n    // Time: O(N)\\n    // Space: O(1)\\n        \\n        \\nclass Solution {\\npublic:\\n    vector<int> minOperations(string s) {\\n        int N = s.size(), sum = 0, right = 0, left = 0;\\n        vector<int> ans(s.size());\\n        for (int i = 0; i < N; ++i) {\\n            if (s[i] == \\'1\\') sum += i, ++right;\\n        }\\n        for (int i = 0; i < N; ++i) {\\n            ans[i] = sum;\\n            if (s[i] == \\'1\\') --right, ++left;\\n            sum += left - right;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1134709,
                "title": "java-o-n-time-complexity-solution",
                "content": "```\\npublic int[] minOperations(String boxes) {\\n        int size = boxes.length();\\n        int arr[] = new int[size];\\n\\n        int rightSum = 0;\\n        int onesAtRight = 0;\\n        for (int i = 0; i < size; i++) {\\n            if(boxes.charAt(i)==\\'1\\'){\\n                onesAtRight++;\\n                rightSum+=i;\\n            }\\n        }\\n        int leftSum = 0;\\n        int onesAtLeft = 0;\\n        for (int i = 0; i < size; i++) {\\n            leftSum+=onesAtLeft;\\n            if(boxes.charAt(i)==\\'1\\'){\\n                onesAtRight--;\\n                onesAtLeft++;\\n            }\\n            arr[i] = rightSum+leftSum;\\n            rightSum-= onesAtRight;\\n        }\\n        return arr;\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] minOperations(String boxes) {\\n        int size = boxes.length();\\n        int arr[] = new int[size];\\n\\n        int rightSum = 0;\\n        int onesAtRight = 0;\\n        for (int i = 0; i < size; i++) {\\n            if(boxes.charAt(i)==\\'1\\'){\\n                onesAtRight++;\\n                rightSum+=i;\\n            }\\n        }\\n        int leftSum = 0;\\n        int onesAtLeft = 0;\\n        for (int i = 0; i < size; i++) {\\n            leftSum+=onesAtLeft;\\n            if(boxes.charAt(i)==\\'1\\'){\\n                onesAtRight--;\\n                onesAtLeft++;\\n            }\\n            arr[i] = rightSum+leftSum;\\n            rightSum-= onesAtRight;\\n        }\\n        return arr;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1510448,
                "title": "96-faster-greedy-approach-well-explained-for-beginners",
                "content": "## IDEA :\\nHere, we can create prefix and postfix array of size n\\\\*2 to store the number of ones before (or after) the index and also information of the number of costs required to collect all the ones at previous index.\\n**For Example :**  \\n\\'\\'\\'\\n\\n\\tstring given  =   \"  0       0       1      0      1      1 \"\\n\\tpostfix array =   [[3,11], [3,8],  [2,5], [2,3], [1,1], [0,0]]        # (starting the array from right for computation).\\n\\tprefix array  =   [[0,0],  [0,0],  [0,0], [1,1], [1,2], [2,4]]        # (starting the array from left for computation).\\n\\t\\n\\tTake prefix array for explaination:\\n\\t[0,0]    -> 0 number of \\'1\\' is present left to that position and 0 number of cost required to collect all 1\\'s left to it.\\n\\t[0,0]    -> 0 number of \\'1\\' is present left to that position and 0 number of cost required to collect all 1\\'s left to it.\\n\\t[0,0]    -> 0 number of \\'1\\' is present left to that position and 0 number of cost required to collect all 1\\'s left to it.\\n\\t[1,1]    -> 1 number of \\'1\\' is present left to that position and 1 number of cost required to collect all 1\\'s left to it.\\n\\t[1,2]    -> 1 number of \\'1\\' is present left to that position and 2 number of cost required to collect all 1\\'s left to it.\\n\\t[2,4]    -> 2 number of \\'1\\' is present left to that position and 4 number of cost required to collect all 1\\'s left to it.\\n\\t\\n\\tFormula used to calculate:\\n\\tpre[i][0] = boxes[i-1] + pre[i-1][0]\\n    pre[i][1] = boxes[i-1] + pre[i-1][0] + pre[i-1][1]\\n\\n### CODE :\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        \\n        n = len(boxes)\\n        boxes = [int(i) for i in boxes]\\n        pre = [[0,0] for i in range(n)]\\n        post= [[0,0] for i in range(n)]\\n        \\n        for i in range(1,n):\\n            pre[i][0] = boxes[i-1] + pre[i-1][0]\\n            pre[i][1] = boxes[i-1] + pre[i-1][0] + pre[i-1][1]\\n        \\n        for i in range(n-2,-1,-1):\\n            post[i][0] = boxes[i+1] + post[i+1][0]\\n            post[i][1] = boxes[i+1] + post[i+1][0] + post[i+1][1]\\n        \\n        for i in range(n):\\n            boxes[i] = pre[i][1]+post[i][1]\\n        \\n        return boxes\\n\\n### Thanks & upvote if you like the idea!!\\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "## IDEA :\\nHere, we can create prefix and postfix array of size n\\\\*2 to store the number of ones before (or after) the index and also information of the number of costs required to collect all the ones at previous index.\\n**For Example :**  \\n\\'\\'\\'\\n\\n\\tstring given  =   \"  0       0       1      0      1      1 \"\\n\\tpostfix array =   [[3,11], [3,8],  [2,5], [2,3], [1,1], [0,0]]        # (starting the array from right for computation).\\n\\tprefix array  =   [[0,0],  [0,0],  [0,0], [1,1], [1,2], [2,4]]        # (starting the array from left for computation).\\n\\t\\n\\tTake prefix array for explaination:\\n\\t[0,0]    -> 0 number of \\'1\\' is present left to that position and 0 number of cost required to collect all 1\\'s left to it.\\n\\t[0,0]    -> 0 number of \\'1\\' is present left to that position and 0 number of cost required to collect all 1\\'s left to it.\\n\\t[0,0]    -> 0 number of \\'1\\' is present left to that position and 0 number of cost required to collect all 1\\'s left to it.\\n\\t[1,1]    -> 1 number of \\'1\\' is present left to that position and 1 number of cost required to collect all 1\\'s left to it.\\n\\t[1,2]    -> 1 number of \\'1\\' is present left to that position and 2 number of cost required to collect all 1\\'s left to it.\\n\\t[2,4]    -> 2 number of \\'1\\' is present left to that position and 4 number of cost required to collect all 1\\'s left to it.\\n\\t\\n\\tFormula used to calculate:\\n\\tpre[i][0] = boxes[i-1] + pre[i-1][0]\\n    pre[i][1] = boxes[i-1] + pre[i-1][0] + pre[i-1][1]\\n\\n### CODE :\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        \\n        n = len(boxes)\\n        boxes = [int(i) for i in boxes]\\n        pre = [[0,0] for i in range(n)]\\n        post= [[0,0] for i in range(n)]\\n        \\n        for i in range(1,n):\\n            pre[i][0] = boxes[i-1] + pre[i-1][0]\\n            pre[i][1] = boxes[i-1] + pre[i-1][0] + pre[i-1][1]\\n        \\n        for i in range(n-2,-1,-1):\\n            post[i][0] = boxes[i+1] + post[i+1][0]\\n            post[i][1] = boxes[i+1] + post[i+1][0] + post[i+1][1]\\n        \\n        for i in range(n):\\n            boxes[i] = pre[i][1]+post[i][1]\\n        \\n        return boxes\\n\\n### Thanks & upvote if you like the idea!!\\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1421551,
                "title": "easy-to-understand-simple-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string s) \\n    {\\n        int n=s.size();\\n        vector<int>r(n),v(n,0);\\n        int cnt=0,i;\\n        v[0]=s[0]-\\'0\\';\\n        for(i=1;i<n;i++)\\n        {\\n            v[i]=v[i-1]+(s[i]-\\'0\\');//pre-computed array to find total balls at ith position.\\n            if(s[i]==\\'1\\')\\n                cnt+=i;\\n        }\\n        r[0]=cnt;\\n        for(i=1;i<n;i++)\\n        {\\n\\t\\t//subtract balls after ith position and add balls before ith position inclusive of ith position.\\n            r[i]=cnt+v[i-1]-(v[n-1]-v[i-1]);\\n            cnt=r[i];\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string s) \\n    {\\n        int n=s.size();\\n        vector<int>r(n),v(n,0);\\n        int cnt=0,i;\\n        v[0]=s[0]-\\'0\\';\\n        for(i=1;i<n;i++)\\n        {\\n            v[i]=v[i-1]+(s[i]-\\'0\\');//pre-computed array to find total balls at ith position.\\n            if(s[i]==\\'1\\')\\n                cnt+=i;\\n        }\\n        r[0]=cnt;\\n        for(i=1;i<n;i++)\\n        {\\n\\t\\t//subtract balls after ith position and add balls before ith position inclusive of ith position.\\n            r[i]=cnt+v[i-1]-(v[n-1]-v[i-1]);\\n            cnt=r[i];\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1342333,
                "title": "javascript-88ms-one-pass-o-n-time-o-1-memory",
                "content": "```\\n var minOperations = function(boxes) {\\n    \\n    const ans = new Array(boxes.length).fill(0);\\n\\n    let ballsLeft = 0, ballsRight = 0;\\n    let movesLeft = 0, movesRight = 0;\\n\\n    const len = boxes.length - 1;\\n    \\n    for(let i = 0; i <= len; i++) {\\n       \\n       movesLeft += ballsLeft;\\n       movesRight += ballsRight;\\n       ans[i] += movesLeft;\\n       ans[len - i] += movesRight;\\n       ballsLeft += +boxes[i];\\n       ballsRight += +boxes[len - i];\\n    }\\n\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n var minOperations = function(boxes) {\\n    \\n    const ans = new Array(boxes.length).fill(0);\\n\\n    let ballsLeft = 0, ballsRight = 0;\\n    let movesLeft = 0, movesRight = 0;\\n\\n    const len = boxes.length - 1;\\n    \\n    for(let i = 0; i <= len; i++) {\\n       \\n       movesLeft += ballsLeft;\\n       movesRight += ballsRight;\\n       ans[i] += movesLeft;\\n       ans[len - i] += movesRight;\\n       ballsLeft += +boxes[i];\\n       ballsRight += +boxes[len - i];\\n    }\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1172589,
                "title": "python3-brute-force-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        arr = []\\n        for i in range(len(boxes)):\\n            sumi = 0\\n            for j in range(len(boxes)):\\n                if(boxes[j] == \\'1\\'):\\n                    sumi += abs(j - i)\\n            arr.append(sumi)\\n        \\n        return arr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        arr = []\\n        for i in range(len(boxes)):\\n            sumi = 0\\n            for j in range(len(boxes)):\\n                if(boxes[j] == \\'1\\'):\\n                    sumi += abs(j - i)\\n            arr.append(sumi)\\n        \\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1101094,
                "title": "python-o-n-dp-time-beats-100-space-beats-100",
                "content": "![image](https://assets.leetcode.com/users/images/dc2b12a6-2b9f-4f15-a971-3ef25664d173_1615282750.7098162.png)\\n\\n\\n```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        n = len(boxes)\\n        dpleft, dpright = [0]*n, [0]*n\\n        countleft, countright = int(boxes[0]), int(boxes[-1])\\n        ans = [0]*n\\n        \\n        for i in range(1, n):\\n            dpleft[i] = dpleft[i-1] + countleft\\n            if boxes[i] == \\'1\\':\\n                countleft += 1\\n        \\n        for i in range(n-2, -1, -1):\\n            dpright[i] = dpright[i+1] + countright\\n            if boxes[i] == \\'1\\':\\n                countright += 1\\n        \\n        for i in range(len(boxes)):\\n            ans[i] = dpleft[i]+dpright[i]\\n        \\n        return ans\\n\\t\\t\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        n = len(boxes)\\n        dpleft, dpright = [0]*n, [0]*n\\n        countleft, countright = int(boxes[0]), int(boxes[-1])\\n        ans = [0]*n\\n        \\n        for i in range(1, n):\\n            dpleft[i] = dpleft[i-1] + countleft\\n            if boxes[i] == \\'1\\':\\n                countleft += 1\\n        \\n        for i in range(n-2, -1, -1):\\n            dpright[i] = dpright[i+1] + countright\\n            if boxes[i] == \\'1\\':\\n                countright += 1\\n        \\n        for i in range(len(boxes)):\\n            ans[i] = dpleft[i]+dpright[i]\\n        \\n        return ans\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422420,
                "title": "c-easy-to-understand",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n\\n**Time complexity: O(n)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n    int n=boxes.length();\\n    vector<int> ans(n);\\n    vector<int> left(n),right(n);\\n    int count=boxes[0]-\\'0\\';\\n    for(int i=1;i<n;i++)\\n    {\\n        left[i]=left[i-1]+count;\\n        count+=boxes[i]-\\'0\\';\\n    }   \\n    count=boxes[n-1]-\\'0\\';\\n    for(int i=n-2;i>=0;i--)\\n    {\\n        right[i]=right[i+1]+count;\\n        count+=boxes[i]-\\'0\\';\\n    }\\n    for(int i=0;i<n;i++)\\n    {\\n        ans[i]=left[i]+right[i];\\n    }    \\n    return ans;    \\n    }\\n};\\n```\\n**Time complexity: O(nxn)**\\n```\\n//1769. Minimum Number of Operations to Move All Balls to Each Box\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n    int n=boxes.length();\\n    vector<int> ans(n);\\n    vector<int> pos;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(boxes[i]==\\'1\\')\\n        pos.push_back(i);    \\n    }\\n    for(int i=0;i<n;i++)\\n    {\\n        for(int num:pos)\\n        {\\n            ans[i]+=abs(num-i);\\n        }    \\n    }  \\n    return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n    int n=boxes.length();\\n    vector<int> ans(n);\\n    vector<int> left(n),right(n);\\n    int count=boxes[0]-\\'0\\';\\n    for(int i=1;i<n;i++)\\n    {\\n        left[i]=left[i-1]+count;\\n        count+=boxes[i]-\\'0\\';\\n    }   \\n    count=boxes[n-1]-\\'0\\';\\n    for(int i=n-2;i>=0;i--)\\n    {\\n        right[i]=right[i+1]+count;\\n        count+=boxes[i]-\\'0\\';\\n    }\\n    for(int i=0;i<n;i++)\\n    {\\n        ans[i]=left[i]+right[i];\\n    }    \\n    return ans;    \\n    }\\n};\\n```\n```\\n//1769. Minimum Number of Operations to Move All Balls to Each Box\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n    int n=boxes.length();\\n    vector<int> ans(n);\\n    vector<int> pos;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(boxes[i]==\\'1\\')\\n        pos.push_back(i);    \\n    }\\n    for(int i=0;i<n;i++)\\n    {\\n        for(int num:pos)\\n        {\\n            ans[i]+=abs(num-i);\\n        }    \\n    }  \\n    return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259973,
                "title": "c-logic-for-o-n-2-to-o-n-explained",
                "content": "The most straightforward solution is this one:\\n```\\nvector<int> minOperations(string boxes) {\\n\\tint len=boxes.size();\\n\\tvector<int> minOps(len,0);\\n\\tfor(int i=0; i<len; i++)\\n\\t\\tfor(int j=0; j<len; j++)\\n\\t\\t\\tif(boxes[j]==\\'1\\')\\n\\t\\t\\t\\tminOps[i]+=abs(i-j);\\n\\treturn minOps;\\n}\\n```\\nEach ball  at ```boxes[j]``` will take ```abs(i-j)``` to move to ```boxes[i]```. This easily makes for a solution using a nested for loop, but this runs at O(n^2) time complexity. \\n\\nWe can do better, but we must delve deeper into the logic and take a hard look at what\\'s happening. \\nWe can say the number of operations at index i can be determined by\\n```\\n(i*runCnt-prejSum)+(postjSum-i*afterCnt)\\n```\\n```runCnt``` : the number of balls encountered up till ```i```\\n```afterCnt```: the number of balls after ```i```\\n```prejSum```: the sum of all indices of balls up to ```i```\\n```postjSum```: the sum of all indices of balls after ```i```\\n\\nIf you don\\'t see it right away, take a look at this example, assuming j are the indices of \\'1\\'\\n```boxes = \"1101\"```\\n```\\n[sum(abs(0-j)), sum(abs(1-j)), sum(abs(2-j)), sum(abs(3-j))] \\n[(0-0) + (1-0)+(3-0) , (1-0)+(1-1) + (3-1) , (2-0)+(2-1) + (3-2) , (3-0)+(3-1)+(3-3)] =\\n[(0*1-sum(j<=0)) + (sum(j>0)-0*2), (1*2-sum(j<=1) + (sum(j>1)-1*1), ...]\\n[4,3,4,5]\\n```\\nHopefully that makes it more clear.\\n\\nWe must do two passes in order to do this in O(n), one to find the total numbers of balls and the sum of all indices where there are balls, and one pass where we use those and some running sums to compute ```numOps[i]```\\n\\nHere\\'s the code using this method (with some algebra and bit shifting marginally optimizing the formula):\\n```\\nvector<int> minOperations(string boxes) {\\n\\tint len=boxes.size(), runCnt=0,posSum=0,count=0,totalPosSum=0;\\n\\tvector<int> minOps(len);\\n\\tfor(int i=0; i<len; i++)\\n\\t\\tif(boxes[i]==\\'1\\'){\\n\\t\\t\\tcount++;\\n\\t\\t\\ttotalPosSum+=i;\\n\\t\\t}\\n\\tfor(int i=0; i<len; i++){\\n\\t\\tif(boxes[i]==\\'1\\'){\\n\\t\\t\\trunCnt++;\\n\\t\\t\\tposSum+=i;\\n\\t\\t}\\n\\t\\t// minOps[i]=(i*runCnt-posSum)+((totalPosSum-posSum)-i*(count-runCnt));\\n\\t\\tminOps[i]=i*((runCnt<<1)-count)+totalPosSum-(posSum<<1);\\n\\t}\\n\\treturn minOps;\\n}\\n```\\nDrop any questions, comments, or optimizations of these methods below!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> minOperations(string boxes) {\\n\\tint len=boxes.size();\\n\\tvector<int> minOps(len,0);\\n\\tfor(int i=0; i<len; i++)\\n\\t\\tfor(int j=0; j<len; j++)\\n\\t\\t\\tif(boxes[j]==\\'1\\')\\n\\t\\t\\t\\tminOps[i]+=abs(i-j);\\n\\treturn minOps;\\n}\\n```\n```boxes[j]```\n```abs(i-j)```\n```boxes[i]```\n```\\n(i*runCnt-prejSum)+(postjSum-i*afterCnt)\\n```\n```runCnt```\n```i```\n```afterCnt```\n```i```\n```prejSum```\n```i```\n```postjSum```\n```i```\n```boxes = \"1101\"```\n```\\n[sum(abs(0-j)), sum(abs(1-j)), sum(abs(2-j)), sum(abs(3-j))] \\n[(0-0) + (1-0)+(3-0) , (1-0)+(1-1) + (3-1) , (2-0)+(2-1) + (3-2) , (3-0)+(3-1)+(3-3)] =\\n[(0*1-sum(j<=0)) + (sum(j>0)-0*2), (1*2-sum(j<=1) + (sum(j>1)-1*1), ...]\\n[4,3,4,5]\\n```\n```numOps[i]```\n```\\nvector<int> minOperations(string boxes) {\\n\\tint len=boxes.size(), runCnt=0,posSum=0,count=0,totalPosSum=0;\\n\\tvector<int> minOps(len);\\n\\tfor(int i=0; i<len; i++)\\n\\t\\tif(boxes[i]==\\'1\\'){\\n\\t\\t\\tcount++;\\n\\t\\t\\ttotalPosSum+=i;\\n\\t\\t}\\n\\tfor(int i=0; i<len; i++){\\n\\t\\tif(boxes[i]==\\'1\\'){\\n\\t\\t\\trunCnt++;\\n\\t\\t\\tposSum+=i;\\n\\t\\t}\\n\\t\\t// minOps[i]=(i*runCnt-posSum)+((totalPosSum-posSum)-i*(count-runCnt));\\n\\t\\tminOps[i]=i*((runCnt<<1)-count)+totalPosSum-(posSum<<1);\\n\\t}\\n\\treturn minOps;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1075585,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        \\n        l=[]\\n        \\n        for i in range(len(boxes)):\\n            k=0\\n            for j in range(len(boxes)):\\n                if boxes[j]==\\'1\\':\\n                    k+=abs(i-j)\\n            l.append(k)\\n            \\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        \\n        l=[]\\n        \\n        for i in range(len(boxes)):\\n            k=0\\n            for j in range(len(boxes)):\\n                if boxes[j]==\\'1\\':\\n                    k+=abs(i-j)\\n            l.append(k)\\n            \\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626252,
                "title": "tc-o-n-sc-o-1-c-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n = boxes.size();\\n        vector<int> pref(n,0);\\n        int ones = boxes[0] == \\'1\\';\\n        for(int i = 1; i < n; ++i){\\n            pref[i] = pref[i-1] + ones;\\n            if(boxes[i] == \\'1\\') ones++;\\n        }\\n        ones = 0;\\n        int prev = 0;\\n        for(int i = n-1; i >= 0; --i){\\n            pref[i] = pref[i] + prev;\\n            if(boxes[i] == \\'1\\'){\\n                ones++;\\n            }\\n            prev += ones;\\n        }\\n        return pref;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n = boxes.size();\\n        vector<int> pref(n,0);\\n        int ones = boxes[0] == \\'1\\';\\n        for(int i = 1; i < n; ++i){\\n            pref[i] = pref[i-1] + ones;\\n            if(boxes[i] == \\'1\\') ones++;\\n        }\\n        ones = 0;\\n        int prev = 0;\\n        for(int i = n-1; i >= 0; --i){\\n            pref[i] = pref[i] + prev;\\n            if(boxes[i] == \\'1\\'){\\n                ones++;\\n            }\\n            prev += ones;\\n        }\\n        return pref;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242851,
                "title": "100-faster-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n=boxes.length();\\n        vector<int>op(n);\\n        int suml=0,sumr=0;\\n        for(int i=0;i<n;i++){\\n            if(boxes[i]==\\'1\\'){\\n                sumr+=1;\\n                op[0]+=i;    \\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            if(boxes[i-1]!=\\'0\\'){\\n                suml+=1;\\n                sumr-=1;\\n            }\\n            op[i]=op[i-1]+suml-sumr; \\n        }\\n        return op;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n=boxes.length();\\n        vector<int>op(n);\\n        int suml=0,sumr=0;\\n        for(int i=0;i<n;i++){\\n            if(boxes[i]==\\'1\\'){\\n                sumr+=1;\\n                op[0]+=i;    \\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            if(boxes[i-1]!=\\'0\\'){\\n                suml+=1;\\n                sumr-=1;\\n            }\\n            op[i]=op[i-1]+suml-sumr; \\n        }\\n        return op;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613616,
                "title": "c-o-n-solution-in-2-passes",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) \\n    {\\n        vector<int> v;\\n        int leftcount=0; //counts number of 1s to the left of current index\\n        int leftsum=0; //sum of indexes, i such that boxes[i]=\\'1\\' to the left of current index\\n        int rightsum=0; //sum of indexes, i such that boxes[i]=\\'1\\' to the right of current index\\n        int rightcount=0; //counts number of 1s to the right of current index\\n        \\n        //initially only rightsum and rightcount will be there for the zeroth index\\n        for(int i=0;i<boxes.size();i++)\\n        {\\n            if(boxes[i]==\\'1\\')\\n            {\\n                rightsum+=i;\\n                rightcount++;\\n            }\\n        }\\n        \\n        for(int i=0;i<boxes.size();i++)\\n        {\\n            if(boxes[i]==\\'1\\')\\n            {\\n                rightcount--;\\n                rightsum-=i;\\n            }\\n            int sum=abs(rightsum-(rightcount*i))+abs(leftsum-(leftcount*i));\\n            v.push_back(sum);\\n            if(boxes[i]==\\'1\\')\\n            {\\n                leftcount++;\\n                leftsum+=i;\\n            }\\n                                                     \\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nTime complexity : O(N)\\nSpace complexity : O(N) for the vector, but it can be ignored as it is required for the question",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) \\n    {\\n        vector<int> v;\\n        int leftcount=0; //counts number of 1s to the left of current index\\n        int leftsum=0; //sum of indexes, i such that boxes[i]=\\'1\\' to the left of current index\\n        int rightsum=0; //sum of indexes, i such that boxes[i]=\\'1\\' to the right of current index\\n        int rightcount=0; //counts number of 1s to the right of current index\\n        \\n        //initially only rightsum and rightcount will be there for the zeroth index\\n        for(int i=0;i<boxes.size();i++)\\n        {\\n            if(boxes[i]==\\'1\\')\\n            {\\n                rightsum+=i;\\n                rightcount++;\\n            }\\n        }\\n        \\n        for(int i=0;i<boxes.size();i++)\\n        {\\n            if(boxes[i]==\\'1\\')\\n            {\\n                rightcount--;\\n                rightsum-=i;\\n            }\\n            int sum=abs(rightsum-(rightcount*i))+abs(leftsum-(leftcount*i));\\n            v.push_back(sum);\\n            if(boxes[i]==\\'1\\')\\n            {\\n                leftcount++;\\n                leftsum+=i;\\n            }\\n                                                     \\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529635,
                "title": "99-59-fast-linear-time-python-solution-easiest-explained",
                "content": "Logic is to calculate the sum of indices having balls and store it in ans[0]. We also calculate number of balls that are ahead of index 0 as we iterate once.\\n\\nAs you iterate forward again, reduce the previous sum (at index - 1 in the ans array) by the number of balls ahead and increase the previous sum by number of balls behind. \\n\\nSince when you move ahead, **the distance from balls behind increases by 1 for every ball behind current index but the distance from balls ahead decreases by 1 for every ball ahead of current index.**\\n\\nUpvote if you understood the logic :)\\n\\n```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        \\n        ans = [0] * len(boxes)\\n        sumAhead = ballsAhead = ballsBehind = 0\\n               \\n        for i in range(1, len(boxes)):\\n            if boxes[i] == \\'1\\':\\n                sumAhead += i\\n                ballsAhead += 1\\n        \\n        ans[0] = sumAhead\\n        \\n        if boxes[0] == \\'1\\':\\n            ballsBehind += 1\\n        \\n        for i in range(1, len(ans)):\\n            ans[i] = ans[i - 1] + ballsBehind - ballsAhead\\n            \\n            if boxes[i] == \\'1\\':\\n                ballsBehind += 1\\n                ballsAhead -= 1\\n            \\n        return ans  \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        \\n        ans = [0] * len(boxes)\\n        sumAhead = ballsAhead = ballsBehind = 0\\n               \\n        for i in range(1, len(boxes)):\\n            if boxes[i] == \\'1\\':\\n                sumAhead += i\\n                ballsAhead += 1\\n        \\n        ans[0] = sumAhead\\n        \\n        if boxes[0] == \\'1\\':\\n            ballsBehind += 1\\n        \\n        for i in range(1, len(ans)):\\n            ans[i] = ans[i - 1] + ballsBehind - ballsAhead\\n            \\n            if boxes[i] == \\'1\\':\\n                ballsBehind += 1\\n                ballsAhead -= 1\\n            \\n        return ans  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340205,
                "title": "explained-solution",
                "content": "let\\'s consider this example - \"001001\". For this we don\\'t want to calculate for each 1\\'s , how many movement it needs to move, instead we will use previous calculated result and see how to optimize it. \\n<img src=\"https://assets.leetcode.com/users/images/6145b6dd-d653-4c66-af54-83d5c6048b74_1658907426.8135538.png\" width =\"600\" >\\n\\nfirstly i will calculate movement for all balls to reach 0th index that is sum of all indexes, along with this we will keep a count of no. of 1\\'s (let say rightones) .\\n\\n<img src=\"https://assets.leetcode.com/users/images/8ae0122c-f7d9-4047-bb9b-7abd1ea83495_1658910100.8864417.png\" width = \"600\">\\n\\nsee it took all the 3 balls on the right to reach 11 operations for 0th index. for index = 1, they will take 11 operations to reach 0 and -3 operations for all balls (as we are traversing back, consider as taking steps back) to go back 1 step i.e 11 - 3 = 8. \\n\\n<img src=\"https://assets.leetcode.com/users/images/9dd64e32-85d2-42f9-8448-f209e5580921_1658910160.1058989.png\" width = \"600\" >\\n\\nat index = 2, they will take 8 stpes to reach index 1 and then all three of them will take 1 step back  i.e 8 - 3 = 5\\n\\n**So basically if i know there is total B balls on the right (including current index ) and i know it took V operations for the previous index then for the current index, it will take *V- B* operations .**\\n\\nnow at index = 3, i can see there are 2 balls that will take 5 operations for index 2 and there is 1 ball on the left which will need to traverse 1 step ahaed then total steps = 5 - 2 + 1 => 4\\n\\n<img src=\"https://assets.leetcode.com/users/images/f2d188ba-9c55-4718-a5d3-5c1b934d4453_1658910941.8645532.png\" width = \"600\">\\n\\n**If there are K balls on the left then i need to add them as they took V operations to reach (i-1) index and +1 operations for each K ball to reach at index i** \\n\\n> **Operations for ith index = operations for (i-1) index - total balls on the right including ith index + total balls on the left  .**\\n\\nHope this explains how to proceed for O(n) solutions with 2 pass (preprocessing).\\n\\n```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int n = boxes.length();\\n     int ans[] = new int[n];\\n     int count = 0;\\n     int index = 0;\\n        for(int i = 0 ; i < n ; ++i ){\\n            if(boxes.charAt(i) == \\'1\\'){\\n                ++count;\\n                index += i;\\n            }\\n        }\\n        ans[0] = index;\\n        \\n        int fcount = 0;  // 1\\'s that i processed \\n        if(boxes.charAt(0) == \\'1\\'){\\n            count--;\\n            fcount++;\\n        }\\n        for(int i = 1 ; i < n ; ++i){\\n            ans[i] = ans[i-1] - count + fcount;\\n            if(boxes.charAt(i) == \\'1\\'){\\n            count--;\\n            fcount++;\\n        }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int n = boxes.length();\\n     int ans[] = new int[n];\\n     int count = 0;\\n     int index = 0;\\n        for(int i = 0 ; i < n ; ++i ){\\n            if(boxes.charAt(i) == \\'1\\'){\\n                ++count;\\n                index += i;\\n            }\\n        }\\n        ans[0] = index;\\n        \\n        int fcount = 0;  // 1\\'s that i processed \\n        if(boxes.charAt(0) == \\'1\\'){\\n            count--;\\n            fcount++;\\n        }\\n        for(int i = 1 ; i < n ; ++i){\\n            ans[i] = ans[i-1] - count + fcount;\\n            if(boxes.charAt(i) == \\'1\\'){\\n            count--;\\n            fcount++;\\n        }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942346,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n         int[] min=new int[boxes.length()];\\n        List<Integer> ans=new ArrayList<>();\\n        List<Integer> ind=new ArrayList<>();\\n        for(int i=0;i<boxes.length();i++){\\n            if(boxes.charAt(i)==\\'1\\'){\\n                ind.add(i);\\n            }\\n        }\\n        for(int i=0;i<boxes.length();i++){\\n            \\n                int temp=0;\\n                for(int j=0;j<ind.size();j++){\\n                    temp+=Math.abs(i-ind.get(j));\\n                }\\n                min[i]=temp;\\n            \\n        }\\n        \\n        return min;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n         int[] min=new int[boxes.length()];\\n        List<Integer> ans=new ArrayList<>();\\n        List<Integer> ind=new ArrayList<>();\\n        for(int i=0;i<boxes.length();i++){\\n            if(boxes.charAt(i)==\\'1\\'){\\n                ind.add(i);\\n            }\\n        }\\n        for(int i=0;i<boxes.length();i++){\\n            \\n                int temp=0;\\n                for(int j=0;j<ind.size();j++){\\n                    temp+=Math.abs(i-ind.get(j));\\n                }\\n                min[i]=temp;\\n            \\n        }\\n        \\n        return min;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077682,
                "title": "java-dp-beats-100-2ms-o-boxes-length-o-1",
                "content": "\\n    public int[] minOperations(String boxes) {\\n        int left = 0, right = 0, lsum = 0, rsum = 0, len = boxes.length();\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (boxes.charAt(i) == \\'1\\') {\\n\\t\\t\\t\\tright++;\\n\\t\\t\\t\\trsum += i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint[] ans = new int[len];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tans[i] = lsum + rsum;\\n\\t\\t\\tif (boxes.charAt(i) == \\'1\\') {\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t}\\n\\t\\t\\tlsum = lsum + left;\\n\\t\\t\\trsum = rsum - right;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int[] minOperations(String boxes) {\\n        int left = 0, right = 0, lsum = 0, rsum = 0, len = boxes.length();\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (boxes.charAt(i) == \\'1\\') {\\n\\t\\t\\t\\tright++;\\n\\t\\t\\t\\trsum += i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint[] ans = new int[len];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tans[i] = lsum + rsum;\\n\\t\\t\\tif (boxes.charAt(i) == \\'1\\') {\\n\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t}\\n\\t\\t\\tlsum = lsum + left;\\n\\t\\t\\trsum = rsum - right;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3039948,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string b) {\\n        \\n        vector<int> ans;\\n         vector<int> temp;\\n         for(int i=0; i<b.length(); i++){\\n             if(b[i]==\\'1\\'){\\n                 temp.push_back(i);\\n             }\\n         }\\n        for( int i=0 ; i<b.length(); i++){\\n            int count=0;\\n            for(auto j: temp){\\n                count=count+ abs(j-i);\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string b) {\\n        \\n        vector<int> ans;\\n         vector<int> temp;\\n         for(int i=0; i<b.length(); i++){\\n             if(b[i]==\\'1\\'){\\n                 temp.push_back(i);\\n             }\\n         }\\n        for( int i=0 ; i<b.length(); i++){\\n            int count=0;\\n            for(auto j: temp){\\n                count=count+ abs(j-i);\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719536,
                "title": "easy-c-code-with-time-complexity-o-n",
                "content": "\\n\\n\\nvector<int> minOperations(string boxes) {\\n        vector<int>ans;\\n        \\n        int sum=0;\\n        int count=0;\\n        int ext=0;\\n        for(int i=boxes.size()-1;i>=0;i--){\\n            if(boxes[i]==\\'1\\'){\\n                ext++;\\n                  sum+=(boxes.size()-(i+1));\\n            }\\n              \\n        }\\n        int left=0;\\n          for(int i=boxes.size()-1;i>=0;i--){\\n            if(boxes[i]==\\'1\\')\\n            {\\n                sum-=(boxes.size()-(i+1));\\n                ext--;\\n                ans.push_back(sum+count-(ext*(boxes.size()-(i+1))));\\n                left++;\\n            }\\n              else{\\n                    \\n                  ans.push_back(sum+count-(ext*(boxes.size()-(i+1))));\\n                   }\\n              count+=left;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }",
                "solutionTags": [],
                "code": "\\n\\n\\nvector<int> minOperations(string boxes) {\\n        vector<int>ans;\\n        \\n        int sum=0;\\n        int count=0;\\n        int ext=0;\\n        for(int i=boxes.size()-1;i>=0;i--){\\n            if(boxes[i]==\\'1\\'){\\n                ext++;\\n                  sum+=(boxes.size()-(i+1));\\n            }\\n              \\n        }\\n        int left=0;\\n          for(int i=boxes.size()-1;i>=0;i--){\\n            if(boxes[i]==\\'1\\')\\n            {\\n                sum-=(boxes.size()-(i+1));\\n                ext--;\\n                ans.push_back(sum+count-(ext*(boxes.size()-(i+1))));\\n                left++;\\n            }\\n              else{\\n                    \\n                  ans.push_back(sum+count-(ext*(boxes.size()-(i+1))));\\n                   }\\n              count+=left;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1604722,
                "title": "c-o-n-solution-very-simple-100-faster-in-runtime-and-space",
                "content": "Intution is simple - \\nWe need to perform two pass of the boxes in linear time one from left to right and vice versa.\\nTwo variable **step** and **ball** are getting updated in both the passes. At every index, we need to look into sum of previous step and number of ball till previous index in first pass from right to left.\\nAnd in second pass left to right, we do exactly the same thing.\\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n=boxes.size();\\n        vector<int> ans(n);\\n        int step=0, ball=0;\\n        for(int i=n-1; i>=0; i--){\\n            ans[i] = step;\\n            if(boxes[i] == \\'1\\') ball++;\\n            step += ball;\\n        }\\n        step=0; ball=0;\\n        for(int i=0; i<n; i++){\\n            ans[i]+=step;\\n            if(boxes[i] == \\'1\\') ball++;\\n            step+=ball;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n=boxes.size();\\n        vector<int> ans(n);\\n        int step=0, ball=0;\\n        for(int i=n-1; i>=0; i--){\\n            ans[i] = step;\\n            if(boxes[i] == \\'1\\') ball++;\\n            step += ball;\\n        }\\n        step=0; ball=0;\\n        for(int i=0; i<n; i++){\\n            ans[i]+=step;\\n            if(boxes[i] == \\'1\\') ball++;\\n            step+=ball;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179627,
                "title": "c-o-n-time",
                "content": "\\n    vector<int> minOperations(string boxes) \\n    {\\n        int n = boxes.size();\\n        vector<int> res;\\n        int sum = 0, right = 0, left = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(boxes[i] == \\'1\\')\\n            {\\n                sum += i;\\n                right++;\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            res.push_back(sum);\\n            if(boxes[i] == \\'1\\')\\n            {\\n                right--;\\n                left++;\\n            }\\n            \\n            sum += left - right;\\n        }\\n        \\n        return res;\\n                \\n        \\n    }\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\n    vector<int> minOperations(string boxes) \\n    {\\n        int n = boxes.size();\\n        vector<int> res;\\n        int sum = 0, right = 0, left = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(boxes[i] == \\'1\\')\\n            {\\n                sum += i;\\n                right++;\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            res.push_back(sum);\\n            if(boxes[i] == \\'1\\')\\n            {\\n                right--;\\n                left++;\\n            }\\n            \\n            sum += left - right;\\n        }\\n        \\n        return res;\\n                \\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1139946,
                "title": "java-faster-than-99",
                "content": "```\\npublic int[] minOperations(String boxes) {\\n        int sum=0;\\n        int count=0;\\n        int[] operation=new int[boxes.length()];\\n        for(int i=0;i<boxes.length();i++){\\n            operation[i]+=sum;\\n            if(boxes.charAt(i)==\\'1\\'){\\n                count++;\\n            }\\n            sum+=count;\\n        }\\n        sum=0;\\n        count=0;\\n        for(int i=boxes.length()-1;i>=0;i--){\\n            operation[i]+=sum;\\n            if(boxes.charAt(i)==\\'1\\'){\\n                count++;\\n            }\\n            sum+=count;\\n        }\\n        return operation;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] minOperations(String boxes) {\\n        int sum=0;\\n        int count=0;\\n        int[] operation=new int[boxes.length()];\\n        for(int i=0;i<boxes.length();i++){\\n            operation[i]+=sum;\\n            if(boxes.charAt(i)==\\'1\\'){\\n                count++;\\n            }\\n            sum+=count;\\n        }\\n        sum=0;\\n        count=0;\\n        for(int i=boxes.length()-1;i>=0;i--){\\n            operation[i]+=sum;\\n            if(boxes.charAt(i)==\\'1\\'){\\n                count++;\\n            }\\n            sum+=count;\\n        }\\n        return operation;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1095658,
                "title": "python-dp",
                "content": "The codes are similar to other posts but I think it is better to give some clarification in terms of DP. Let\\'s first think about the subproblem where we need to obtain the minimum number of operations to move all LEFT balls to each Box (i.e., those balls on the left of each box). It is quite clear this is a DP problem. Denote the solution for box i as cost_i. Then we can write down the DP equation: cost_i = cost_{i-1} + the number of balls on the left of box i. This gives us the first half of the code. Similarly, we can consider the subproblem of moving all RIGHT balls to each box, which is the second half.\\n\\n```\\nclass Solution(object):\\n    def minOperations(self, boxes):\\n        \"\"\"\\n        :type boxes: str\\n        :rtype: List[int]\\n        \"\"\"\\n        cost = [0]*len(boxes)\\n        #first consider those balls that are moved from left to right\\n        #cost[i] = cost[i-1] + # of balls on the left of ith box\\n        #num_ball indicates number of balls on the left\\n        num_ball, cost_update = 0,0\\n        for i in range(len(boxes)):\\n            cost[i] += cost_update\\n            #update the number of balls on the left of box i+1\\n            num_ball += int(boxes[i])\\n            #update cost for box i+1\\n            cost_update += num_ball\\n        #consider those balls that are moved from right to left\\n        num_ball, cost_update = 0,0\\n        for i in reversed(range(len(boxes))):\\n            cost[i] += cost_update\\n            #update the number of balls on the right of box i-1\\n            num_ball += int(boxes[i])\\n            #update cost for box i-1\\n            cost_update += num_ball\\n            \\n        return cost\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minOperations(self, boxes):\\n        \"\"\"\\n        :type boxes: str\\n        :rtype: List[int]\\n        \"\"\"\\n        cost = [0]*len(boxes)\\n        #first consider those balls that are moved from left to right\\n        #cost[i] = cost[i-1] + # of balls on the left of ith box\\n        #num_ball indicates number of balls on the left\\n        num_ball, cost_update = 0,0\\n        for i in range(len(boxes)):\\n            cost[i] += cost_update\\n            #update the number of balls on the left of box i+1\\n            num_ball += int(boxes[i])\\n            #update cost for box i+1\\n            cost_update += num_ball\\n        #consider those balls that are moved from right to left\\n        num_ball, cost_update = 0,0\\n        for i in reversed(range(len(boxes))):\\n            cost[i] += cost_update\\n            #update the number of balls on the right of box i-1\\n            num_ball += int(boxes[i])\\n            #update cost for box i-1\\n            cost_update += num_ball\\n            \\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075681,
                "title": "python3-line-sweep",
                "content": "**Algo**\\nWhile sweeping from left to right, the only relevant variable is the number of remaining `1`s to the right of current position. Here, we subtract 2 from `cnt` to account for the effect that while a number move from right to left of the current pointer, it contributes to `ops` by removing the distances from the right ones and adding the distance from the left ones. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        ans = []\\n        ops = cnt = 0 # count of remaining \"1\"s\\n        for i, x in enumerate(boxes):\\n            if x == \"1\": \\n                ops += i\\n                cnt += 1\\n        \\n        for i, x in enumerate(boxes): \\n            ans.append(ops)\\n            if x == \"1\": cnt -= 2\\n            ops -= cnt\\n        return ans \\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        ans = []\\n        ops = cnt = 0 # count of remaining \"1\"s\\n        for i, x in enumerate(boxes):\\n            if x == \"1\": \\n                ops += i\\n                cnt += 1\\n        \\n        for i, x in enumerate(boxes): \\n            ans.append(ops)\\n            if x == \"1\": cnt -= 2\\n            ops -= cnt\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987156,
                "title": "98-18-of-time-and-memory-solution",
                "content": "![Screenshot 2023-01-02 at 20.37.33.png](https://assets.leetcode.com/users/images/2f305629-3c2d-4c8c-9607-9faa25cc937d_1672673898.8989983.png)\\n\\n```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        l, ans = len(boxes), []\\n        left, right = 0, sum(i for i in range(l) if boxes[i]==\\'1\\')\\n        one_left, one_right = 0, boxes.count(\\'1\\')\\n        for i in range(l):\\n            ans.append(left+right)\\n            if boxes[i]==\\'1\\':\\n                one_left, one_right = one_left+1, one_right-1\\n            left, right = left+one_left, right-one_right\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        l, ans = len(boxes), []\\n        left, right = 0, sum(i for i in range(l) if boxes[i]==\\'1\\')\\n        one_left, one_right = 0, boxes.count(\\'1\\')\\n        for i in range(l):\\n            ans.append(left+right)\\n            if boxes[i]==\\'1\\':\\n                one_left, one_right = one_left+1, one_right-1\\n            left, right = left+one_left, right-one_right\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805394,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) \\n    {\\n        vector<int> v;\\n        int leftcount=0; \\n        int leftsum=0; \\n        int rightsum=0; \\n        int rightcount=0; \\n        for(int i=0;i<boxes.size();i++)\\n        {\\n            if(boxes[i]==\\'1\\')\\n            {\\n                rightsum+=i;\\n                rightcount++;\\n            }\\n        }\\n        \\n        for(int i=0;i<boxes.size();i++)\\n        {\\n            if(boxes[i]==\\'1\\')\\n            {\\n                rightcount--;\\n                rightsum-=i;\\n            }\\n            int sum=abs(rightsum-(rightcount*i))+abs(leftsum-(leftcount*i));\\n            v.push_back(sum);\\n            if(boxes[i]==\\'1\\')\\n            {\\n                leftcount++;\\n                leftsum+=i;\\n            }\\n                                                     \\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) \\n    {\\n        vector<int> v;\\n        int leftcount=0; \\n        int leftsum=0; \\n        int rightsum=0; \\n        int rightcount=0; \\n        for(int i=0;i<boxes.size();i++)\\n        {\\n            if(boxes[i]==\\'1\\')\\n            {\\n                rightsum+=i;\\n                rightcount++;\\n            }\\n        }\\n        \\n        for(int i=0;i<boxes.size();i++)\\n        {\\n            if(boxes[i]==\\'1\\')\\n            {\\n                rightcount--;\\n                rightsum-=i;\\n            }\\n            int sum=abs(rightsum-(rightcount*i))+abs(leftsum-(leftcount*i));\\n            v.push_back(sum);\\n            if(boxes[i]==\\'1\\')\\n            {\\n                leftcount++;\\n                leftsum+=i;\\n            }\\n                                                     \\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907970,
                "title": "java-easy-consise-beginer-friendly",
                "content": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int[] res = new int[boxes.length()];\\n        List<Integer> list = new ArrayList<>();\\n        for(int i=0;i<boxes.length();i++) if(boxes.charAt(i) == \\'1\\') list.add(i);\\n        for(int i=0;i<res.length;i++) for(int idx:list) res[i] += Math.abs(idx - i);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int[] res = new int[boxes.length()];\\n        List<Integer> list = new ArrayList<>();\\n        for(int i=0;i<boxes.length();i++) if(boxes.charAt(i) == \\'1\\') list.add(i);\\n        for(int i=0;i<res.length;i++) for(int idx:list) res[i] += Math.abs(idx - i);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1812650,
                "title": "c-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int size = boxes.size();\\n        vector<int> leftToRight(size, 0);\\n        vector<int> rightToLeft(size, 0);\\n        \\n        int ballCount;\\n        \\n        ballCount = 0;\\n        for(int i=0; i<size; i++) {\\n            if(i>0) leftToRight[i] = (ballCount*1) + leftToRight[i-1];\\n            if(boxes[i]==\\'1\\') ballCount++;\\n        }\\n        \\n        ballCount = 0;\\n        for(int i=size-1; i>=0; i--) {\\n            if(i<size-1) rightToLeft[i] = (ballCount*1) + rightToLeft[i+1];\\n            if(boxes[i]==\\'1\\') ballCount++;\\n        }\\n        \\n        vector<int> minMoves(size, 0);\\n        for(int i=0; i<size; i++) minMoves[i] = leftToRight[i]+rightToLeft[i];\\n        return minMoves;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int size = boxes.size();\\n        vector<int> leftToRight(size, 0);\\n        vector<int> rightToLeft(size, 0);\\n        \\n        int ballCount;\\n        \\n        ballCount = 0;\\n        for(int i=0; i<size; i++) {\\n            if(i>0) leftToRight[i] = (ballCount*1) + leftToRight[i-1];\\n            if(boxes[i]==\\'1\\') ballCount++;\\n        }\\n        \\n        ballCount = 0;\\n        for(int i=size-1; i>=0; i--) {\\n            if(i<size-1) rightToLeft[i] = (ballCount*1) + rightToLeft[i+1];\\n            if(boxes[i]==\\'1\\') ballCount++;\\n        }\\n        \\n        vector<int> minMoves(size, 0);\\n        for(int i=0; i<size; i++) minMoves[i] = leftToRight[i]+rightToLeft[i];\\n        return minMoves;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805191,
                "title": "java-o-n-ltr-2",
                "content": "This solution relies on updating counters for the balls that we have seen so far as we travel from left to right. As we get further away from balls on the left, the number of operations needed scales positively linearly with the number of balls we\\'ve seen. Similarly, for the balls on the right of our current box, the number of operations scales negatively linearly with the number of balls we\\'ve seen. Therefore, to start off the algorithm, we need to count all of the balls to the right of the \\'0\\'th box. \\n\\nOnce we know how many balls are to the right, we just update our counters on each iteration. This is similar to the LTR + RTL approaches that are heavily voted up in the discussion, but the second pass traverses from the left.\\n```\\n    public int[] minOperations(String boxes) {\\n        // Initialize the number of operations and our counters\\n        int[] numberOfOperations = new int[boxes.length()];\\n        int ballsToTheLeft = 0, ballsInBox = boxes.charAt(0) - \\'0\\', ballsToTheRight = 0;\\n        // Calculate how many operations are required to move all balls to the first bin\\n        for (int i = 1; i < numberOfOperations.length; i++) {\\n            int ball = boxes.charAt(i) - \\'0\\';\\n            ballsToTheRight += ball;\\n            numberOfOperations[0] += i * ball;\\n        }\\n        // Count how many operations are required for the rest of the bins. This relies on where the balls are in relation to the current box;\\n        for (int i = 1; i < numberOfOperations.length; i++) {\\n            int ball = boxes.charAt(i) - \\'0\\';\\n            // As we move to the right, update our counters based on positions of the seen balls\\n            ballsToTheLeft += ballsInBox;\\n            ballsInBox = ball;\\n            ballsToTheRight -= ballsInBox;\\n            // We rely on the previous box operations as our base count\\n            // We subtract the balls to the right and in the current bucket since we\\'re moving towards them\\n            // We add the balls to the left because we\\'re moving away from them\\n            numberOfOperations[i] = numberOfOperations[i - 1] - ballsToTheRight - ballsInBox + ballsToTheLeft;\\n        }\\n        return numberOfOperations;\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "This solution relies on updating counters for the balls that we have seen so far as we travel from left to right. As we get further away from balls on the left, the number of operations needed scales positively linearly with the number of balls we\\'ve seen. Similarly, for the balls on the right of our current box, the number of operations scales negatively linearly with the number of balls we\\'ve seen. Therefore, to start off the algorithm, we need to count all of the balls to the right of the \\'0\\'th box. \\n\\nOnce we know how many balls are to the right, we just update our counters on each iteration. This is similar to the LTR + RTL approaches that are heavily voted up in the discussion, but the second pass traverses from the left.\\n```\\n    public int[] minOperations(String boxes) {\\n        // Initialize the number of operations and our counters\\n        int[] numberOfOperations = new int[boxes.length()];\\n        int ballsToTheLeft = 0, ballsInBox = boxes.charAt(0) - \\'0\\', ballsToTheRight = 0;\\n        // Calculate how many operations are required to move all balls to the first bin\\n        for (int i = 1; i < numberOfOperations.length; i++) {\\n            int ball = boxes.charAt(i) - \\'0\\';\\n            ballsToTheRight += ball;\\n            numberOfOperations[0] += i * ball;\\n        }\\n        // Count how many operations are required for the rest of the bins. This relies on where the balls are in relation to the current box;\\n        for (int i = 1; i < numberOfOperations.length; i++) {\\n            int ball = boxes.charAt(i) - \\'0\\';\\n            // As we move to the right, update our counters based on positions of the seen balls\\n            ballsToTheLeft += ballsInBox;\\n            ballsInBox = ball;\\n            ballsToTheRight -= ballsInBox;\\n            // We rely on the previous box operations as our base count\\n            // We subtract the balls to the right and in the current bucket since we\\'re moving towards them\\n            // We add the balls to the left because we\\'re moving away from them\\n            numberOfOperations[i] = numberOfOperations[i - 1] - ballsToTheRight - ballsInBox + ballsToTheLeft;\\n        }\\n        return numberOfOperations;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1372414,
                "title": "c-solution-o-n",
                "content": "The approach used:\\n**Work done to move the balls to any box is equal to work done to bring the balls in previous box plus the number of balls in the previous box**\\n\\n``` \\nclass Solution {\\npublic:\\n    vector<int> minOperations(string s) {\\n        int l = s.size();\\n        int w1[l],w2[l];\\n        vector<int>ans;\\n        ans.resize(l);\\n        w1[0]=0;w2[l-1]=0;\\n        int balls =0;\\n        for(int i=1;i<l;i++){\\n            if(s[i-1]==\\'1\\') balls++;\\n            w1[i]=w1[i-1]+balls;\\n        }\\n        balls=0;\\n        for(int i=l-2;i>=0;i--){\\n            if(s[i+1]==\\'1\\') balls++;\\n            w2[i]=w2[i+1]+balls;\\n        }\\n        for(int i=0;i<l;i++){\\n            ans[i]=w1[i]+w2[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "``` \\nclass Solution {\\npublic:\\n    vector<int> minOperations(string s) {\\n        int l = s.size();\\n        int w1[l],w2[l];\\n        vector<int>ans;\\n        ans.resize(l);\\n        w1[0]=0;w2[l-1]=0;\\n        int balls =0;\\n        for(int i=1;i<l;i++){\\n            if(s[i-1]==\\'1\\') balls++;\\n            w1[i]=w1[i-1]+balls;\\n        }\\n        balls=0;\\n        for(int i=l-2;i>=0;i--){\\n            if(s[i+1]==\\'1\\') balls++;\\n            w2[i]=w2[i+1]+balls;\\n        }\\n        for(int i=0;i<l;i++){\\n            ans[i]=w1[i]+w2[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349310,
                "title": "o-n-python-incremental-approach",
                "content": "You just need to solve it for the first entry and do the rest incrementally. For that end, we keep the number of 1\\'s on the right side and left side. The intuition is that, each time we move to the right, *r* 1\\'s get closer to us and *l* 1\\'s get further away from us where *r* is the number of 1\\'s on the right and *l* is the number of 1\\'s on the left.\\n\\n\\'\\'\\'\\n\\n    def minOperations(self, boxes: str) -> List[int]:\\n        on_left  = 0\\n        on_right = 0\\n        result   = []\\n        \\n        # Compute the value for the first entry (O(n)) and update the number of 1s on the right (including the first index)\\n        counter  = 0 # Stores the totall number of moves necessary\\n        for i, b in enumerate(boxes):\\n            if b == \\'1\\':\\n                on_right += 1\\n                counter  += i \\n                \\n        # Move forward and compute other entries incrementally (O(n))\\n        for i in range(len(boxes)):\\n            if i > 0:\\n                counter = counter - on_right + on_left\\n            result.append(counter)\\n            if boxes[i] == \\'1\\':\\n                on_left  += 1\\n                on_right -= 1\\n                \\n        return result\\n\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "You just need to solve it for the first entry and do the rest incrementally. For that end, we keep the number of 1\\'s on the right side and left side. The intuition is that, each time we move to the right, *r* 1\\'s get closer to us and *l* 1\\'s get further away from us where *r* is the number of 1\\'s on the right and *l* is the number of 1\\'s on the left.\\n\\n\\'\\'\\'\\n\\n    def minOperations(self, boxes: str) -> List[int]:\\n        on_left  = 0\\n        on_right = 0\\n        result   = []\\n        \\n        # Compute the value for the first entry (O(n)) and update the number of 1s on the right (including the first index)\\n        counter  = 0 # Stores the totall number of moves necessary\\n        for i, b in enumerate(boxes):\\n            if b == \\'1\\':\\n                on_right += 1\\n                counter  += i \\n                \\n        # Move forward and compute other entries incrementally (O(n))\\n        for i in range(len(boxes)):\\n            if i > 0:\\n                counter = counter - on_right + on_left\\n            result.append(counter)\\n            if boxes[i] == \\'1\\':\\n                on_left  += 1\\n                on_right -= 1\\n                \\n        return result\\n\\n\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 1272485,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n       \\n        int ah=0;//ahead\\n        int be=0;//behind\\n        \\n        int n=boxes.size();\\n         vector<int> res(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(boxes[i]==\\'1\\')\\n            {\\n                ah++;\\n                res[0]+=i;\\n            }\\n        }\\n        if(boxes[0]==\\'1\\')\\n        {\\n            ah--;\\n            be++;\\n        }\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            res[i]+= res[i-1]-ah+be;\\n             if(boxes[i]==\\'1\\')\\n        {\\n            ah--;\\n            be++;\\n        }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n       \\n        int ah=0;//ahead\\n        int be=0;//behind\\n        \\n        int n=boxes.size();\\n         vector<int> res(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(boxes[i]==\\'1\\')\\n            {\\n                ah++;\\n                res[0]+=i;\\n            }\\n        }\\n        if(boxes[0]==\\'1\\')\\n        {\\n            ah--;\\n            be++;\\n        }\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            res[i]+= res[i-1]-ah+be;\\n             if(boxes[i]==\\'1\\')\\n        {\\n            ah--;\\n            be++;\\n        }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243394,
                "title": "o-n-and-o-n2-both-solutions-done",
                "content": "can we do it by recursion if yes\\nplease letme know \\n\\n```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        //better approach than brute force \\n        //we maintain two arrays left and right and \\n        \\n        int n = boxes.length();\\n        char []ch = boxes.toCharArray();\\n        \\n        int left[] = new int[n];\\n        int count  = ch[0] - \\'0\\';\\n        \\n        for(int i=1; i<n; i++){\\n            left[i] = left[i-1] + count;\\n            count += ch[i] - \\'0\\';\\n        }\\n        \\n        int right[] = new int[n];\\n        count  = ch[n - 1] - \\'0\\';\\n        \\n        for(int i=n-2; i>=0; i--){\\n            right[i] = right[i+1] + count;\\n            count += ch[i] - \\'0\\';\\n        }\\n        \\n        for(int i=0; i< n;i++){\\n            left[i] += right[i];\\n        }\\n        \\n        return left;\\n        \\n        //this is the brute froce method \\n        //TC- O(n2)  and space is O(n) because we are creating new array\\n//          int n = boxes.length();\\n//         char []ch = boxes.toCharArray();\\n//         int []answer = new int[n];\\n        \\n//         for(int i=0; i<n; i++){\\n//             int count = 0;\\n//             for(int j=0; j<n ;j++){\\n//                 if(i != j && ch[j] == \\'1\\'){\\n//                     count += Math.abs(j-i);\\n//                 }\\n//                 answer[i] = count;\\n//             }\\n//         }\\n//         return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        //better approach than brute force \\n        //we maintain two arrays left and right and \\n        \\n        int n = boxes.length();\\n        char []ch = boxes.toCharArray();\\n        \\n        int left[] = new int[n];\\n        int count  = ch[0] - \\'0\\';\\n        \\n        for(int i=1; i<n; i++){\\n            left[i] = left[i-1] + count;\\n            count += ch[i] - \\'0\\';\\n        }\\n        \\n        int right[] = new int[n];\\n        count  = ch[n - 1] - \\'0\\';\\n        \\n        for(int i=n-2; i>=0; i--){\\n            right[i] = right[i+1] + count;\\n            count += ch[i] - \\'0\\';\\n        }\\n        \\n        for(int i=0; i< n;i++){\\n            left[i] += right[i];\\n        }\\n        \\n        return left;\\n        \\n        //this is the brute froce method \\n        //TC- O(n2)  and space is O(n) because we are creating new array\\n//          int n = boxes.length();\\n//         char []ch = boxes.toCharArray();\\n//         int []answer = new int[n];\\n        \\n//         for(int i=0; i<n; i++){\\n//             int count = 0;\\n//             for(int j=0; j<n ;j++){\\n//                 if(i != j && ch[j] == \\'1\\'){\\n//                     count += Math.abs(j-i);\\n//                 }\\n//                 answer[i] = count;\\n//             }\\n//         }\\n//         return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1235472,
                "title": "simple-o-n-python-solution-beats-100",
                "content": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        n = [0 for i in range(len(boxes))]\\n        num_right = 0\\n        num_left = 0\\n        for i in range(1,len(boxes)):\\n            if(boxes[i] == \"1\"):\\n                num_right += 1\\n                n[0] += i\\n        \\n        for i in range(1, len(boxes)):\\n            if(boxes[i-1] == \"1\"):\\n                num_left += 1\\n            n[i] = n[i-1]+num_left-num_right\\n            if(boxes[i] == \"1\"):\\n                num_right -= 1\\n        return n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        n = [0 for i in range(len(boxes))]\\n        num_right = 0\\n        num_left = 0\\n        for i in range(1,len(boxes)):\\n            if(boxes[i] == \"1\"):\\n                num_right += 1\\n                n[0] += i\\n        \\n        for i in range(1, len(boxes)):\\n            if(boxes[i-1] == \"1\"):\\n                num_left += 1\\n            n[i] = n[i-1]+num_left-num_right\\n            if(boxes[i] == \"1\"):\\n                num_right -= 1\\n        return n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1226993,
                "title": "python-easiest-two-solution-brute-force-efficient-one-beats-99-24-solution",
                "content": "#### Brute force\\n```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        \\n        \\n        n=len(boxes)\\n        \\n        ans=[]\\n        \\n        for i in range(n):\\n            \\n            p=0\\n            \\n            for j in range(n):\\n                if boxes[j]==\\'1\\':\\n                    p+= abs(i-j)\\n            ans.append(p)\\n        \\n        return ans\\n```\\n#### Efficient one \\n\\n```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        n=len(boxes)\\n        \\n        ans=[]\\n        \\n        right=0\\n        left = 0\\n        \\n        p=0\\n        for i in range(n):\\n            \\n            if boxes[i]==\\'1\\':\\n                left+=1\\n                p+=i\\n                \\n        ans.append(p)\\n        \\n        if boxes[0]==\\'1\\':\\n            left-=1\\n            right+=1\\n        \\n        \\n            \\n        for j in range(1,n):\\n            \\n            if boxes[j]==\\'0\\':\\n                \\n                ans.append(ans[-1]-left+right)\\n            else:\\n                ans.append(ans[-1]-left+right)\\n                left-=1\\n                right+=1\\n        return ans\\n                \\n                \\n```\\n\\nif you like do upvote <3",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        \\n        \\n        n=len(boxes)\\n        \\n        ans=[]\\n        \\n        for i in range(n):\\n            \\n            p=0\\n            \\n            for j in range(n):\\n                if boxes[j]==\\'1\\':\\n                    p+= abs(i-j)\\n            ans.append(p)\\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        n=len(boxes)\\n        \\n        ans=[]\\n        \\n        right=0\\n        left = 0\\n        \\n        p=0\\n        for i in range(n):\\n            \\n            if boxes[i]==\\'1\\':\\n                left+=1\\n                p+=i\\n                \\n        ans.append(p)\\n        \\n        if boxes[0]==\\'1\\':\\n            left-=1\\n            right+=1\\n        \\n        \\n            \\n        for j in range(1,n):\\n            \\n            if boxes[j]==\\'0\\':\\n                \\n                ans.append(ans[-1]-left+right)\\n            else:\\n                ans.append(ans[-1]-left+right)\\n                left-=1\\n                right+=1\\n        return ans\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1197191,
                "title": "c-solution-8ms-o-n-optimal",
                "content": "We will maintain a result vector res, in which we will store the number of operations. First we will traverse the boxes string from left to right and keep the count of the operations required to transfer the balls to adjacent boxes. \\n**For left traversal:**\\nThe operations required to transfer the balls from (i-1)th box to ith box will be equal to operations for (i-1)th box plus the number of balls seen till (i-1)th box.\\n\\n**For right traversal:**\\nSimilarly, the operations required to transfer the balls from (i+1)th box to ith box will be equal to operations for (i+1)th box plus the number of balls seen till (i+1)th box plus the current res[i] value.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        vector<int> res(boxes.size(), 0);\\n        \\n        int ballsSeen = 0;\\n        int sum = 0;\\n        for(int i = 1; i < boxes.size(); ++i)\\n        {\\n            if(boxes[i-1] == \\'1\\')\\n            {\\n                ballsSeen += 1;\\n            }\\n            \\n            sum += ballsSeen;\\n            res[i] = sum;\\n        }\\n        \\n        ballsSeen = 0;\\n        sum = 0;\\n        for(int i = boxes.size() - 2; i >= 0; --i)\\n        {\\n            if(boxes[i+1] == \\'1\\')\\n                ballsSeen +=1;\\n            \\n            sum += ballsSeen;\\n            res[i] += sum;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nI have tried my best to explain the problem in a simple way. For better understanding of the thought process, I will recommend to have a dry run of the code on any example.\\nSorry for any mistakes!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        vector<int> res(boxes.size(), 0);\\n        \\n        int ballsSeen = 0;\\n        int sum = 0;\\n        for(int i = 1; i < boxes.size(); ++i)\\n        {\\n            if(boxes[i-1] == \\'1\\')\\n            {\\n                ballsSeen += 1;\\n            }\\n            \\n            sum += ballsSeen;\\n            res[i] = sum;\\n        }\\n        \\n        ballsSeen = 0;\\n        sum = 0;\\n        for(int i = boxes.size() - 2; i >= 0; --i)\\n        {\\n            if(boxes[i+1] == \\'1\\')\\n                ballsSeen +=1;\\n            \\n            sum += ballsSeen;\\n            res[i] += sum;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098883,
                "title": "c-solution-explanation-o-n-space-o-n-time-prefix-sum-and-dp-simple",
                "content": "Comments should be enough for the explanation. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n = boxes.size();\\n        \\n        \\n        // idea is that we will separately calculate the distance that all the 1s\\n        // left to i will have to travel to position i\\n        // and the distance all the 1s will have to travel from the right of i to position i.\\n        \\n        // observation : \\n        // at any point i, if we want to calcualte the distance all the 1s\\n        // will have to travel to reach i, which are left of i\\n        // say left[i] = left[i-1] + #1s to left of i (excluding if there is a 1 at i).\\n        \\n        // e.g. in \"00101\"\\n        // left-prefix looks like : [0,0,0,1,1]\\n        // distance travelled by 1s to left of i will be \\n        // for i=0, left[0] = 0\\n        // for i=1, left[1] = 0  (no 1s to the left of this position).\\n        // for i=2, left[2] = left[1] + lprefix[2] = 0 + 0 = 0\\n        // for i=3, left[3] = left[2] + lprefix[3] = 0 + 1 = 1.\\n        \\n        // This works because let\\'s say there are 3 1s to left of position i. \\n        // till position i-1 they had to travel distance d to reach i-1. \\n        // now each of these 1s will need to travel a unit = 1 distance more from i-1 to i.\\n        // so the total additional distance all these one\\'s need to travel in addition to \\n        // reaching i-1 position = #1s.\\n        // total distance = till i-1 + extra,\\n        // extra = from i-1 to i = unit_distance * number of 1s = 1*lprefix[i].\\n        \\n        // Calculation for the one\\'s on the right side is similar. \\n        \\n        // Finally, we add the distance that\\'s required to be travelled by all the ones\\n        // from the left and the right. \\n        \\n        \\n        // left prefix sum and right prefix sum. \\n        vector<int> rpre(n, 0);\\n        vector<int> lpre(n, 0); // counts number of 1s to left/right of i. (excluding i).\\n        \\n        // left prefix.\\n        lpre[0] = 0;\\n        for(int i=1;i<n;i++){\\n            int b = 0;\\n            if(boxes[i-1] == \\'1\\')\\n                b = 1;\\n            lpre[i] = lpre[i-1] + b;\\n        }\\n        // right prefix.\\n        rpre[n-1] = 0;\\n        for(int i=n-2;i>=0;i--){\\n            int b = 0;\\n            if(boxes[i+1] == \\'1\\')\\n                b = 1;\\n            rpre[i] = rpre[i+1] + b;\\n        }\\n        \\n        \\n        // now distance of all 1s to left and to right of i. \\n        \\n        vector<int> left(n,0);\\n        vector<int> right(n,0);\\n        \\n        left[0] = 0;\\n        for(int i=1;i<n;i++){\\n            left[i] = left[i-1] + lpre[i];\\n        }\\n        \\n        right[n-1] = 0;\\n        for(int i=n-2;i>=0;i--){\\n            right[i] = right[i+1] + rpre[i];\\n        }\\n        \\n        \\n        vector<int> ans(n,0);\\n        \\n        for(int i=0;i<n;i++){\\n            ans[i] = left[i] + right[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n = boxes.size();\\n        \\n        \\n        // idea is that we will separately calculate the distance that all the 1s\\n        // left to i will have to travel to position i\\n        // and the distance all the 1s will have to travel from the right of i to position i.\\n        \\n        // observation : \\n        // at any point i, if we want to calcualte the distance all the 1s\\n        // will have to travel to reach i, which are left of i\\n        // say left[i] = left[i-1] + #1s to left of i (excluding if there is a 1 at i).\\n        \\n        // e.g. in \"00101\"\\n        // left-prefix looks like : [0,0,0,1,1]\\n        // distance travelled by 1s to left of i will be \\n        // for i=0, left[0] = 0\\n        // for i=1, left[1] = 0  (no 1s to the left of this position).\\n        // for i=2, left[2] = left[1] + lprefix[2] = 0 + 0 = 0\\n        // for i=3, left[3] = left[2] + lprefix[3] = 0 + 1 = 1.\\n        \\n        // This works because let\\'s say there are 3 1s to left of position i. \\n        // till position i-1 they had to travel distance d to reach i-1. \\n        // now each of these 1s will need to travel a unit = 1 distance more from i-1 to i.\\n        // so the total additional distance all these one\\'s need to travel in addition to \\n        // reaching i-1 position = #1s.\\n        // total distance = till i-1 + extra,\\n        // extra = from i-1 to i = unit_distance * number of 1s = 1*lprefix[i].\\n        \\n        // Calculation for the one\\'s on the right side is similar. \\n        \\n        // Finally, we add the distance that\\'s required to be travelled by all the ones\\n        // from the left and the right. \\n        \\n        \\n        // left prefix sum and right prefix sum. \\n        vector<int> rpre(n, 0);\\n        vector<int> lpre(n, 0); // counts number of 1s to left/right of i. (excluding i).\\n        \\n        // left prefix.\\n        lpre[0] = 0;\\n        for(int i=1;i<n;i++){\\n            int b = 0;\\n            if(boxes[i-1] == \\'1\\')\\n                b = 1;\\n            lpre[i] = lpre[i-1] + b;\\n        }\\n        // right prefix.\\n        rpre[n-1] = 0;\\n        for(int i=n-2;i>=0;i--){\\n            int b = 0;\\n            if(boxes[i+1] == \\'1\\')\\n                b = 1;\\n            rpre[i] = rpre[i+1] + b;\\n        }\\n        \\n        \\n        // now distance of all 1s to left and to right of i. \\n        \\n        vector<int> left(n,0);\\n        vector<int> right(n,0);\\n        \\n        left[0] = 0;\\n        for(int i=1;i<n;i++){\\n            left[i] = left[i-1] + lpre[i];\\n        }\\n        \\n        right[n-1] = 0;\\n        for(int i=n-2;i>=0;i--){\\n            right[i] = right[i+1] + rpre[i];\\n        }\\n        \\n        \\n        vector<int> ans(n,0);\\n        \\n        for(int i=0;i<n;i++){\\n            ans[i] = left[i] + right[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089263,
                "title": "o-n-java-100-time-memory",
                "content": "Iterate and calculate all the steps required from left to right and then from right to left.\\n\\n```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int size = boxes.length();\\n        int arr[] = new int[size];\\n        int count  = 0, stepsMoved = 0;  \\n        for(int i=0;i<size;i++){\\n           stepsMoved = stepsMoved+count;\\n           arr[i] = arr[i]+stepsMoved; \\n           count = count+(int)(boxes.charAt(i)-48);\\n        }\\n        count=0;stepsMoved=0;\\n        for(int i=size-1;i>=0;i--){\\n           stepsMoved = stepsMoved+count;\\n           arr[i] = arr[i]+stepsMoved; \\n           count = count+(int)(boxes.charAt(i)-48);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int size = boxes.length();\\n        int arr[] = new int[size];\\n        int count  = 0, stepsMoved = 0;  \\n        for(int i=0;i<size;i++){\\n           stepsMoved = stepsMoved+count;\\n           arr[i] = arr[i]+stepsMoved; \\n           count = count+(int)(boxes.charAt(i)-48);\\n        }\\n        count=0;stepsMoved=0;\\n        for(int i=size-1;i>=0;i--){\\n           stepsMoved = stepsMoved+count;\\n           arr[i] = arr[i]+stepsMoved; \\n           count = count+(int)(boxes.charAt(i)-48);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1086507,
                "title": "python-o-n-solution-beat-100-time-and-memory",
                "content": "\\n```python\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        num_ones = 0\\n        i_sum = 0 \\n        for i,bar in enumerate(boxes):\\n            if bar == \\'1\\':\\n                num_ones += 1\\n                i_sum += i\\n                \\n        answer = []\\n        num_left = 0\\n        num_right = num_ones\\n        \\n        for bar in boxes:\\n            if not answer:\\n                ans = i_sum\\n            else:\\n                ans = answer[-1] + num_left - num_right\\n            answer.append(ans)\\n            if bar == \\'1\\':\\n                num_left += 1\\n                num_right -= 1\\n        \\n        return answer\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        num_ones = 0\\n        i_sum = 0 \\n        for i,bar in enumerate(boxes):\\n            if bar == \\'1\\':\\n                num_ones += 1\\n                i_sum += i\\n                \\n        answer = []\\n        num_left = 0\\n        num_right = num_ones\\n        \\n        for bar in boxes:\\n            if not answer:\\n                ans = i_sum\\n            else:\\n                ans = answer[-1] + num_left - num_right\\n            answer.append(ans)\\n            if bar == \\'1\\':\\n                num_left += 1\\n                num_right -= 1\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081549,
                "title": "python3-one-pass-o-1-space-beats-100",
                "content": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        n = len(boxes)\\n        res, f, b, cf, cb = [0] * n, 0, 0, 0, 0\\n        for i in range(n):\\n            res[i] += cf * i - f\\n            cf += boxes[i] == \\'1\\'\\n            f += i if boxes[i] == \\'1\\' else 0\\n            res[n - i - 1] += cb * i - b\\n            cb += boxes[n - i - 1] == \\'1\\'\\n            b += i if boxes[n - i - 1] == \\'1\\' else 0\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        n = len(boxes)\\n        res, f, b, cf, cb = [0] * n, 0, 0, 0, 0\\n        for i in range(n):\\n            res[i] += cf * i - f\\n            cf += boxes[i] == \\'1\\'\\n            f += i if boxes[i] == \\'1\\' else 0\\n            res[n - i - 1] += cb * i - b\\n            cb += boxes[n - i - 1] == \\'1\\'\\n            b += i if boxes[n - i - 1] == \\'1\\' else 0\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075716,
                "title": "python-o-n-two-passes-solution-with-explanation",
                "content": "1. Bruce force:\\nIf you want to move a ball from box i to box j, you\\'ll need abs(i-j) moves. So there naive solution is for each box i, iterate on each ball in a box j, and add abs(i - j) to answers[i].\\nTime & space complexity: O(n^2) & O(1)\\n\\n2. O(n) solutions: \\nIterate nums from Left to Right and then Right to Left.\\n- Left to Right:\\n\\t\\t- For each box i, calculate \\'pre_balls\\': total balls from previous boxs which contain a ball.\\n\\t\\t- When moving from box i to box i + 1: \\n\\t\\t\\n\\t\\t\\tnum_of_opes(i + 1) = num_of_opes(i) + pre_balls\\n\\tBecause **It needs pre_balls operations to move all pre_balls from box i to box i + 1** . Therefore, we can calculate number of operation at index (i + 1) base on previous index and it leads to O(n).\\n\\t\\t\\n\\t\\tExample: \"001011\" \\n\\t\\t\\t- At box 0: pre_balls = 0, num_of_opes(0) = 0\\n\\t\\t\\t- At box 1, pre_balls = 0, num_of_opes(1) = 0\\n\\t\\t\\t- At box 2, pre_balls = 0, num_of_opes(2) = 0\\n\\t\\t\\t- At box 3, pre_balls = 1, num_of_opes(3) = num_of_opes(2) + pre_balls = 1\\n\\t\\t\\t- At box 4, pre_balls = 1, num_of_opes(4) = num_of_opes(3) + 1 = 2\\n\\t\\t\\t- At box 5, pre_balls = 2, num_of_opes(5) = num_of_opes(4) + 2 = 4\\n\\n- Right to Left: Same logic we will have the answer.\\n\\n\\n```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        N = len(boxes)\\n        ans = [0] * N\\n        \\n        pre_balls, num_of_opes = 0, 0\\n        for i in range(N):\\n            ans[i] += num_of_opes\\n            if boxes[i] == \\'1\\': \\n                pre_balls += 1\\n            num_of_opes += pre_balls\\n        \\n        pre_balls, num_of_opes = 0, 0\\n        for i in reversed(range(N)):\\n            ans[i] += num_of_opes\\n            if boxes[i] == \\'1\\': \\n                pre_balls += 1\\n            num_of_opes += pre_balls\\n            \\n        return ans\\n```\\n\\t\\t\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        N = len(boxes)\\n        ans = [0] * N\\n        \\n        pre_balls, num_of_opes = 0, 0\\n        for i in range(N):\\n            ans[i] += num_of_opes\\n            if boxes[i] == \\'1\\': \\n                pre_balls += 1\\n            num_of_opes += pre_balls\\n        \\n        pre_balls, num_of_opes = 0, 0\\n        for i in reversed(range(N)):\\n            ans[i] += num_of_opes\\n            if boxes[i] == \\'1\\': \\n                pre_balls += 1\\n            num_of_opes += pre_balls\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075524,
                "title": "java-clean-solution",
                "content": "Just to remember which boxes have balls, then you move balls whereever you would like to move. List<Integer> l \\nis the indice of balls. \\n```\\n    public int[] minOperations(String boxes) {\\n        List<Integer> l = new ArrayList<>();\\n        char[] c = boxes.toCharArray();\\n        for (int i = 0; i < c.length; i++) {\\n            if (c[i] == \\'1\\') l.add(i);\\n        }\\n        int[] res = new int[c.length];\\n        for (int i = 0; i < c.length; i++) {\\n            for (int j : l) {\\n                res[i] += Math.abs(j - i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] minOperations(String boxes) {\\n        List<Integer> l = new ArrayList<>();\\n        char[] c = boxes.toCharArray();\\n        for (int i = 0; i < c.length; i++) {\\n            if (c[i] == \\'1\\') l.add(i);\\n        }\\n        int[] res = new int[c.length];\\n        for (int i = 0; i < c.length; i++) {\\n            for (int j : l) {\\n                res[i] += Math.abs(j - i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3664040,
                "title": "java-super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int len=boxes.length();\\n        int ans[]=new int[len];\\n\\n        for(int i=0;i<len;i++){\\n            for(int j=0;j<len;j++){\\n                if(boxes.charAt(j)==\\'1\\' && i!=j){\\n                    ans[i]+=Math.abs(i-j);\\n                }\\n            }\\n        }\\n        return ans;\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int len=boxes.length();\\n        int ans[]=new int[len];\\n\\n        for(int i=0;i<len;i++){\\n            for(int j=0;j<len;j++){\\n                if(boxes.charAt(j)==\\'1\\' && i!=j){\\n                    ans[i]+=Math.abs(i-j);\\n                }\\n            }\\n        }\\n        return ans;\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484445,
                "title": "beats-100-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int n=boxes.length();\\n       \\n        int ans[]=new int[n];\\n        int right[]=new int[n];\\n         int left[]=new int[n];\\n         \\n          int c=boxes.charAt(0) - \\'0\\'; //001011 c=0\\n        for(int i=1;i<n;i++){\\nleft[i]=c+left[i-1];            //previosidx  +curr eg. [0,0,0,1,2,4]\\nc+= boxes.charAt(i) - \\'0\\';  // this return value of boxes[i] --->0,1                //and add value to c whenever 1 encounter \\n        }           \\n\\nc=boxes.charAt(n-1) - \\'0\\';   //  c=1\\n        for(int i=n-2; i>=0;i--){ \\n            right[i]=right[i+1]+c;   //O/P : [11,8,5,3,1,0]\\n     c+= boxes.charAt(i) - \\'0\\';   \\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            ans[i]=left[i]+right[i];\\n            }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int n=boxes.length();\\n       \\n        int ans[]=new int[n];\\n        int right[]=new int[n];\\n         int left[]=new int[n];\\n         \\n          int c=boxes.charAt(0) - \\'0\\'; //001011 c=0\\n        for(int i=1;i<n;i++){\\nleft[i]=c+left[i-1];            //previosidx  +curr eg. [0,0,0,1,2,4]\\nc+= boxes.charAt(i) - \\'0\\';  // this return value of boxes[i] --->0,1                //and add value to c whenever 1 encounter \\n        }           \\n\\nc=boxes.charAt(n-1) - \\'0\\';   //  c=1\\n        for(int i=n-2; i>=0;i--){ \\n            right[i]=right[i+1]+c;   //O/P : [11,8,5,3,1,0]\\n     c+= boxes.charAt(i) - \\'0\\';   \\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            ans[i]=left[i]+right[i];\\n            }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431517,
                "title": "beats-100-in-time-complexity",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCounting the number of 1\\'s preceeding and succeeding every index.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int c=0;\\n        for(int i=0;i<boxes.length();i++)\\n        {\\n            if(boxes[i]==\\'1\\')\\n            c++;\\n        }\\n        int j=0;\\n        for(int i=1;i<boxes.length();i++)\\n        {\\n            j+=(boxes[i]-\\'0\\')*i;\\n        }\\n        cout<<j;\\n        vector<int> v;\\n        v.push_back(j);\\n        int h=0;\\n        if(boxes[0]==\\'1\\')\\n        {\\n            h=1;\\n            c--;\\n        }\\n        for(int i=1;i<boxes.length();i++)\\n        {\\n            if(boxes[i]==\\'1\\')\\n            {\\n                j--;\\n                c--;\\n                j=j-c+h;\\n                h++;\\n            }\\n            else\\n            {\\n                j=j-c+h;\\n            }\\n            v.push_back(j);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int c=0;\\n        for(int i=0;i<boxes.length();i++)\\n        {\\n            if(boxes[i]==\\'1\\')\\n            c++;\\n        }\\n        int j=0;\\n        for(int i=1;i<boxes.length();i++)\\n        {\\n            j+=(boxes[i]-\\'0\\')*i;\\n        }\\n        cout<<j;\\n        vector<int> v;\\n        v.push_back(j);\\n        int h=0;\\n        if(boxes[0]==\\'1\\')\\n        {\\n            h=1;\\n            c--;\\n        }\\n        for(int i=1;i<boxes.length();i++)\\n        {\\n            if(boxes[i]==\\'1\\')\\n            {\\n                j--;\\n                c--;\\n                j=j-c+h;\\n                h++;\\n            }\\n            else\\n            {\\n                j=j-c+h;\\n            }\\n            v.push_back(j);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3418243,
                "title": "minimum-number-of-operations-to-move-all-balls-to-each-box-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int i, j, count=0;\\n        vector<int> min_num_of_operations;\\n        for(i=0 ; i<boxes.size() ; i++)\\n        {\\n            for(j=0 ; j<boxes.size() ; j++)\\n            {\\n                if(boxes[j]==\\'1\\' && i!=j)\\n                {\\n                    count += abs(i-j);\\n                }\\n            }\\n            min_num_of_operations.push_back(count);\\n            count=0;\\n        }\\n        return min_num_of_operations;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int i, j, count=0;\\n        vector<int> min_num_of_operations;\\n        for(i=0 ; i<boxes.size() ; i++)\\n        {\\n            for(j=0 ; j<boxes.size() ; j++)\\n            {\\n                if(boxes[j]==\\'1\\' && i!=j)\\n                {\\n                    count += abs(i-j);\\n                }\\n            }\\n            min_num_of_operations.push_back(count);\\n            count=0;\\n        }\\n        return min_num_of_operations;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051557,
                "title": "o-nxn-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        vector<int>res;\\n        for(int i=0;i<boxes.length();i++){\\n            int cnt=0;\\n            for(int j=0;j<boxes.length();j++){\\n                if(boxes[j]==\\'1\\' && j!=i){\\n                    cnt+=abs(i-j);\\n                }\\n            }\\n            res.push_back(cnt);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        vector<int>res;\\n        for(int i=0;i<boxes.length();i++){\\n            int cnt=0;\\n            for(int j=0;j<boxes.length();j++){\\n                if(boxes[j]==\\'1\\' && j!=i){\\n                    cnt+=abs(i-j);\\n                }\\n            }\\n            res.push_back(cnt);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697071,
                "title": "simple-python3-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        arr = []\\n        \\n        for i, balls in enumerate(boxes):\\n            if balls == \\'1\\':\\n                arr.append(i)\\n        \\n        res = []\\n        for i in range(len(boxes)):\\n            tmp = 0\\n            for index in arr:\\n                tmp += abs(i - index)\\n            res.append(tmp)\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        arr = []\\n        \\n        for i, balls in enumerate(boxes):\\n            if balls == \\'1\\':\\n                arr.append(i)\\n        \\n        res = []\\n        for i in range(len(boxes)):\\n            tmp = 0\\n            for index in arr:\\n                tmp += abs(i - index)\\n            res.append(tmp)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491257,
                "title": "solution-for-beginner-nested-loop-o-n-2-java",
                "content": "# Please Upvote if you liked it \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\nJust add the difference between the indices with the ball\\n\\n```\\n        int ans[] = new int[boxes.length()];\\n        for(int i = 0; i < boxes.length(); i++){\\n            for(int j = 0; j < boxes.length(); j++){\\n                if(boxes.charAt(j) == \\'1\\')\\n                    ans[i] += Math.abs(j - i);\\n            }\\n        }\\n        return ans;\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n        int ans[] = new int[boxes.length()];\\n        for(int i = 0; i < boxes.length(); i++){\\n            for(int j = 0; j < boxes.length(); j++){\\n                if(boxes.charAt(j) == \\'1\\')\\n                    ans[i] += Math.abs(j - i);\\n            }\\n        }\\n        return ans;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2431797,
                "title": "2-python-solution-optimal-o-n-bruteforce-n-2",
                "content": "Please Upvote If you Like it ! \\n```\\nclass Solution(object):\\n    def minOperations(self, boxes):\\n        \"\"\"\\n        :type boxes: str\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        # 1. Optimal Solution \\n        \\n        leftCount = 0\\n        leftCost = 0\\n        rightCount = 0\\n        rightCost = 0\\n        n = len(boxes)\\n        \\n        ans = [0]*len(boxes)\\n        for i in range(1, len(boxes)):\\n            if boxes[i-1] == \\'1\\':\\n                leftCount+=1\\n            \\n            leftCost +=leftCount\\n            ans[i] = leftCost\\n        \\n        for i in range(n-2, -1, -1):\\n            if boxes[i+1] == \\'1\\':\\n                rightCount+=1\\n            \\n            rightCost+=rightCount\\n            ans[i]+=rightCost\\n        return ans\\n        \\n#         2. Brute Force Soln \\n#         ans = [0]*len(boxes)\\n#         for i in range(len(boxes)):\\n#             count = 0\\n#             for left in range(i):\\n#                 if boxes[left] == \\'1\\':\\n#                     count+=(i-left)\\n            \\n#             for right in range(i+1, len(boxes)):\\n#                 if boxes[right] == \\'1\\':\\n#                     count+=(right-i)\\n            \\n#             ans[i] = count\\n#         return ans\\n            \\n            \\n                    \\n                \\n                    \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minOperations(self, boxes):\\n        \"\"\"\\n        :type boxes: str\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        # 1. Optimal Solution \\n        \\n        leftCount = 0\\n        leftCost = 0\\n        rightCount = 0\\n        rightCost = 0\\n        n = len(boxes)\\n        \\n        ans = [0]*len(boxes)\\n        for i in range(1, len(boxes)):\\n            if boxes[i-1] == \\'1\\':\\n                leftCount+=1\\n            \\n            leftCost +=leftCount\\n            ans[i] = leftCost\\n        \\n        for i in range(n-2, -1, -1):\\n            if boxes[i+1] == \\'1\\':\\n                rightCount+=1\\n            \\n            rightCost+=rightCount\\n            ans[i]+=rightCost\\n        return ans\\n        \\n#         2. Brute Force Soln \\n#         ans = [0]*len(boxes)\\n#         for i in range(len(boxes)):\\n#             count = 0\\n#             for left in range(i):\\n#                 if boxes[left] == \\'1\\':\\n#                     count+=(i-left)\\n            \\n#             for right in range(i+1, len(boxes)):\\n#                 if boxes[right] == \\'1\\':\\n#                     count+=(right-i)\\n            \\n#             ans[i] = count\\n#         return ans\\n            \\n            \\n                    \\n                \\n                    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342878,
                "title": "c-o-n-2-using-set-unique-solution-easy",
                "content": "\\n1.      vector<int> minOperations(string boxes) {\\n        int n=boxes.length();``\\n        vector<int>ans;\\n        set<int>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(boxes[i]==\\'1\\')\\n               mp.insert(i);             //store index which contain \\'1\\' only \\n        }\\n        for(int i=0;i<n;i++)\\n         {\\n           int sum=0;\\n           for(auto it:mp)\\n           {\\n             sum+=abs(i-it);           // now sum all the possible path from the given position\\n           }\\n           ans.push_back(sum);\\n         }\\n        return ans;\\n\\t\\t}\\n",
                "solutionTags": [
                    "C",
                    "String",
                    "Ordered Set"
                ],
                "code": "\\n1.      vector<int> minOperations(string boxes) {\\n        int n=boxes.length();``\\n        vector<int>ans;\\n        set<int>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(boxes[i]==\\'1\\')\\n               mp.insert(i);             //store index which contain \\'1\\' only \\n        }\\n        for(int i=0;i<n;i++)\\n         {\\n           int sum=0;\\n           for(auto it:mp)\\n           {\\n             sum+=abs(i-it);           // now sum all the possible path from the given position\\n           }\\n           ans.push_back(sum);\\n         }\\n        return ans;\\n\\t\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2337359,
                "title": "only-one-pass-through-the-array-o-n-solution",
                "content": "\\nuse the idea that how many elment in the towards the left and right, for that we use suffix array\\n(1). fill the suffix array denoting the elements towards the right.\\n(2). for how many element we need from left we use only one variable call \"cnt\"\\n(3). for the i\\'th element ,  distance = previous_distance - no. of element to right + no. of element in left\\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n = boxes.size();\\n        int cnt_right[n];\\n        int temp = 0;\\n        int dist = 0;\\n        for(int i=n-1; i>=0; i--) {\\n            \\n            if(boxes[i] == \\'1\\') {\\n                temp++;\\n                dist+=i;\\n            }\\n            \\n            cnt_right[i] = temp;\\n            \\n        }\\n        \\n        vector<int> ans;\\n        ans.push_back(dist);\\n        \\n        int cnt = 0;\\n        \\n        if(boxes[0] == \\'1\\') {\\n            cnt++;\\n        }\\n        for(int i=1; i<n ; i++) {\\n            dist = dist - cnt_right[i] + cnt;\\n            \\n            if(boxes[i] == \\'1\\')\\n            cnt++;\\n            \\n            ans.push_back(dist);\\n        } \\n        \\n        return ans;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n = boxes.size();\\n        int cnt_right[n];\\n        int temp = 0;\\n        int dist = 0;\\n        for(int i=n-1; i>=0; i--) {\\n            \\n            if(boxes[i] == \\'1\\') {\\n                temp++;\\n                dist+=i;\\n            }\\n            \\n            cnt_right[i] = temp;\\n            \\n        }\\n        \\n        vector<int> ans;\\n        ans.push_back(dist);\\n        \\n        int cnt = 0;\\n        \\n        if(boxes[0] == \\'1\\') {\\n            cnt++;\\n        }\\n        for(int i=1; i<n ; i++) {\\n            dist = dist - cnt_right[i] + cnt;\\n            \\n            if(boxes[i] == \\'1\\')\\n            cnt++;\\n            \\n            ans.push_back(dist);\\n        } \\n        \\n        return ans;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246135,
                "title": "python-o-n-solution",
                "content": "We observe how the sum of distance will change when we move along the input.\\n\\n- When we move to the right, \\n\\t- all the \\'1\\'s before the current index will have distance + 1\\n\\t- all the \\'1\\'s after the index (inclusive of current index) will have distance - 1\\n\\t- all the \\'0\\'s does not matter\\n\\nThus we use two variables to track all the \\'1\\'s before and after the current index, and update the sum of distances along the way.\\n\\nThis algorithm will go over the list of boxes twice, first time calculate the initial distance and the number of \\'1\\'s in total. Time complexity is O(N) and space complexity can be O(1) (I have O(N) in my code below but the `num_ones` and `total` can be calculated with constant space in first iteration)\\n\\n```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        indices = set()\\n        for i, box in enumerate(boxes):\\n            if box == \\'1\\':\\n                indices.add(i)\\n                \\n        num_ones = len(indices)\\n        total = sum(indices)\\n        \\n        out = [total]\\n        before = 0\\n        after = num_ones\\n        for idx in range(1, len(boxes)):\\n            if boxes[idx-1] == \\'1\\':\\n                before += 1\\n                after -= 1 \\n            total += before\\n            total -= after\\n            out.append(total)\\n        return out   \\n```\\n\\nThis one is faster than 98.55% of all Python submissions.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        indices = set()\\n        for i, box in enumerate(boxes):\\n            if box == \\'1\\':\\n                indices.add(i)\\n                \\n        num_ones = len(indices)\\n        total = sum(indices)\\n        \\n        out = [total]\\n        before = 0\\n        after = num_ones\\n        for idx in range(1, len(boxes)):\\n            if boxes[idx-1] == \\'1\\':\\n                before += 1\\n                after -= 1 \\n            total += before\\n            total -= after\\n            out.append(total)\\n        return out   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2149412,
                "title": "javascript-es6",
                "content": "```javascript\\nconst minOperations = boxes => {\\n    const indexes = []\\n    \\n    // Store the index for all balls\\n    for (const i in boxes) {\\n        if (boxes[i] === \\'1\\') indexes.push(i)\\n    }\\n    \\n    const answer = []\\n    \\n    for (const i in boxes) {\\n        let moves = 0\\n        \\n        for (const index of indexes) {\\n            // Calculate the spaces between every\\n            // ball and the current index\\n            moves += Math.abs(i - index)\\n        }\\n        \\n        answer.push(moves)\\n    }\\n    \\n    return answer\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst minOperations = boxes => {\\n    const indexes = []\\n    \\n    // Store the index for all balls\\n    for (const i in boxes) {\\n        if (boxes[i] === \\'1\\') indexes.push(i)\\n    }\\n    \\n    const answer = []\\n    \\n    for (const i in boxes) {\\n        let moves = 0\\n        \\n        for (const index of indexes) {\\n            // Calculate the spaces between every\\n            // ball and the current index\\n            moves += Math.abs(i - index)\\n        }\\n        \\n        answer.push(moves)\\n    }\\n    \\n    return answer\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2107263,
                "title": "python-o-n-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:        \\n        output = []\\n        positions_list = []\\n        \\n        # we save all 1\\'s positions in list         \\n        for i in range(len(boxes)):\\n            if boxes[i] == \"1\":\\n                positions_list.append(i)\\n        \\n        # if there no one 1 was founded, we return boxes      \\n        if len(positions_list)==0:\\n            return boxes\\n        \\n        # rc is count of 1s that located in RIGHT SIDE of list inclusive current position  \\n        # lc is count of 1s that located in LEFT SIDE of list      \\n        rc = len(positions_list)\\n        lc = 0\\n        \\n        # rs is sum of 1\\'s positions that located in RIGHT SIDE of list inclusive current position  \\n        # ls is sum of 1s that located in LEFT SIDE of list  \\n        rs = sum(positions_list)\\n        ls = 0\\n            \\n        for i in range(0,len(boxes)):\\n            # current sum is:            \\n            csum = rs - rc*i + lc*i - ls\\n            output.append(csum)\\n            # if current element is 1 \\n            # we add its position to left side sum and subtract from left side sum   \\n            # also correct their counts             \\n            if boxes[i]==\\'1\\':\\n                rs -= i\\n                ls += i\\n                rc -= 1\\n                lc +=1\\n                \\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:        \\n        output = []\\n        positions_list = []\\n        \\n        # we save all 1\\'s positions in list         \\n        for i in range(len(boxes)):\\n            if boxes[i] == \"1\":\\n                positions_list.append(i)\\n        \\n        # if there no one 1 was founded, we return boxes      \\n        if len(positions_list)==0:\\n            return boxes\\n        \\n        # rc is count of 1s that located in RIGHT SIDE of list inclusive current position  \\n        # lc is count of 1s that located in LEFT SIDE of list      \\n        rc = len(positions_list)\\n        lc = 0\\n        \\n        # rs is sum of 1\\'s positions that located in RIGHT SIDE of list inclusive current position  \\n        # ls is sum of 1s that located in LEFT SIDE of list  \\n        rs = sum(positions_list)\\n        ls = 0\\n            \\n        for i in range(0,len(boxes)):\\n            # current sum is:            \\n            csum = rs - rc*i + lc*i - ls\\n            output.append(csum)\\n            # if current element is 1 \\n            # we add its position to left side sum and subtract from left side sum   \\n            # also correct their counts             \\n            if boxes[i]==\\'1\\':\\n                rs -= i\\n                ls += i\\n                rc -= 1\\n                lc +=1\\n                \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044683,
                "title": "c-3ms-solution",
                "content": "\\n\\n\\n\\n\\n\\n\\nvector<int> minOperations(string boxes) {\\n        vector<int> ans(boxes.size());\\n        vector<int> ones(boxes.size());\\n        int count=0,sum=0;\\n        for(int i=0;i<boxes.size();i++)\\n        {\\n            if(boxes[i]==\\'1\\') {\\n                count++;\\n                sum+=i;\\n            }\\n            ones[i]=count;\\n        }\\n        ans[0]=sum;\\n           for(int i=1;i<boxes.size();i++)\\n        {\\n            sum=(sum-count+ones[i-1]*2);\\n            ans[i]=sum;\\n        }\\n        \\n        return ans;\\n        \\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\n\\n\\n\\n\\n\\nvector<int> minOperations(string boxes) {\\n        vector<int> ans(boxes.size());\\n        vector<int> ones(boxes.size());\\n        int count=0,sum=0;\\n        for(int i=0;i<boxes.size();i++)\\n        {\\n            if(boxes[i]==\\'1\\') {\\n                count++;\\n                sum+=i;\\n            }\\n            ones[i]=count;\\n        }\\n        ans[0]=sum;\\n           for(int i=1;i<boxes.size();i++)\\n        {\\n            sum=(sum-count+ones[i-1]*2);\\n            ans[i]=sum;\\n        }\\n        \\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2030884,
                "title": "easy-o-n-dp-solution-in-c-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string b) {\\n        vector<int>l(b.size(),0);    // dp array for left to right traversal\\n        vector<int>c(b.size(),0);    // count array for number of 1\\'s seen so far\\n        \\n        for(int i=1;i<b.size();i++){\\n            l[i]=c[i-1]+l[i-1];    // to move all 1\\'s from left of i we can first move them to i-1 with l[i-1] moves and then all those c[i-1] 1\\'s can be moved to i;\\n            c[i]=c[i-1];       \\n            if(b[i-1]==\\'1\\')l[i]++,c[i]++;   // if i-1 also had a 1 then we have to shift it as well and increase the count of 1\\'s.\\n            \\n        }\\n         \\n        // same can be done for right to left traversal   \\n        \\n        vector<int>r(b.size(),0);\\n        for(int i=0;i<c.size();i++)c[i]=0;\\n        \\n        for(int i=b.size()-2;i>=0;i--){\\n            r[i]=c[i+1]+r[i+1];\\n            c[i]=c[i+1];\\n            if(b[i+1]==\\'1\\')r[i]++,c[i]++;\\n        }\\n        \\n        for(int i=0;i<b.size();i++)l[i]+=r[i];\\n        return l;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string b) {\\n        vector<int>l(b.size(),0);    // dp array for left to right traversal\\n        vector<int>c(b.size(),0);    // count array for number of 1\\'s seen so far\\n        \\n        for(int i=1;i<b.size();i++){\\n            l[i]=c[i-1]+l[i-1];    // to move all 1\\'s from left of i we can first move them to i-1 with l[i-1] moves and then all those c[i-1] 1\\'s can be moved to i;\\n            c[i]=c[i-1];       \\n            if(b[i-1]==\\'1\\')l[i]++,c[i]++;   // if i-1 also had a 1 then we have to shift it as well and increase the count of 1\\'s.\\n            \\n        }\\n         \\n        // same can be done for right to left traversal   \\n        \\n        vector<int>r(b.size(),0);\\n        for(int i=0;i<c.size();i++)c[i]=0;\\n        \\n        for(int i=b.size()-2;i>=0;i--){\\n            r[i]=c[i+1]+r[i+1];\\n            c[i]=c[i+1];\\n            if(b[i+1]==\\'1\\')r[i]++,c[i]++;\\n        }\\n        \\n        for(int i=0;i<b.size();i++)l[i]+=r[i];\\n        return l;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014715,
                "title": "very-easy-brute-force-solution-using-c",
                "content": "CODE\\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string s) {\\n        vector<int> v(s.size(),-1);\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'0\\')v[i]=0;\\n            else{\\n                v[i]=1;\\n            }\\n            \\n        }\\n        vector<int> ans;\\n        for(int i=0;i<v.size();i++){\\n            int res=0;\\n            for(int j=0;j<v.size();j++){\\n                if(v[j]){\\n                    res+=abs(j-i);\\n                }\\n            }\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string s) {\\n        vector<int> v(s.size(),-1);\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'0\\')v[i]=0;\\n            else{\\n                v[i]=1;\\n            }\\n            \\n        }\\n        vector<int> ans;\\n        for(int i=0;i<v.size();i++){\\n            int res=0;\\n            for(int j=0;j<v.size();j++){\\n                if(v[j]){\\n                    res+=abs(j-i);\\n                }\\n            }\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1779880,
                "title": "java-simple-prefix-sum-based-solution-beats-85-of-solutions",
                "content": "```\\npublic int[] minOperations(String boxes) {\\n        int[] left = new int[boxes.length()];\\n        \\n        int numOnes = 0;\\n        if(boxes.charAt(0) == \\'1\\') numOnes = 1;\\n        for(int i = 1; i < boxes.length(); i++) {\\n            left[i] = left[i - 1] + numOnes;\\n            if(boxes.charAt(i) == \\'1\\') numOnes++;\\n        }\\n        \\n        int[] ans = new int[left.length];\\n        numOnes = 0;\\n        int prev = 0;\\n        ans[boxes.length() - 1] = left[boxes.length() - 1];\\n        if(boxes.charAt(boxes.length() - 1) == \\'1\\') numOnes = 1;\\n        for(int i = boxes.length() - 2; i >= 0; i--) {\\n            ans[i] = prev + numOnes;\\n            if(boxes.charAt(i) == \\'1\\') numOnes++;\\n            prev = ans[i];\\n            ans[i] += left[i];\\n        }\\n        \\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic int[] minOperations(String boxes) {\\n        int[] left = new int[boxes.length()];\\n        \\n        int numOnes = 0;\\n        if(boxes.charAt(0) == \\'1\\') numOnes = 1;\\n        for(int i = 1; i < boxes.length(); i++) {\\n            left[i] = left[i - 1] + numOnes;\\n            if(boxes.charAt(i) == \\'1\\') numOnes++;\\n        }\\n        \\n        int[] ans = new int[left.length];\\n        numOnes = 0;\\n        int prev = 0;\\n        ans[boxes.length() - 1] = left[boxes.length() - 1];\\n        if(boxes.charAt(boxes.length() - 1) == \\'1\\') numOnes = 1;\\n        for(int i = boxes.length() - 2; i >= 0; i--) {\\n            ans[i] = prev + numOnes;\\n            if(boxes.charAt(i) == \\'1\\') numOnes++;\\n            prev = ans[i];\\n            ans[i] += left[i];\\n        }\\n        \\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1720422,
                "title": "difference-between-o-n-and-o-n-solution",
                "content": "# BRUTE FORCE (QUADRATIC SOLUTION)\\n* **TIME: O(N\\xB2)**\\n* **SPACE: O(N)**\\n\\nJUST CALCULATE THE NUMBER OF MOVES FOR EVERY POSITION\\n```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        n = len(boxes)\\n        idx = []\\n        \\n        for i in range(n):\\n            if boxes[i] == \"1\":\\n                idx.append(i)\\n                \\n        return [sum([abs(idx[i]-j) for i in range(len(idx))]) for j in range(n)]\\n```\\n\\n# TWO PASS APPROACH\\n* **TIME: O(N)**\\n* **SPACE: O(2N)**\\n\\n1. GO FROM LEFT TO RIGHT IF THE BOX IS NOT EMPTY INCREASE THE  `count += 1` \\n1. FOR EVERY POSITION ADD THE COUNT OF NON-EMPTY BOXES AND MOVES FOR POSITION JUST BEFORE IT  `ans[i] = ans[i-1] + count` \\n\\nDO SAME WHILE YOU GO FROM RIGHT TO LEFT\\n```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        n = len(boxes)\\n        count, ans = 0, [0]*n\\n        for i in range(n):\\n            ans[i] = ans[i-1] + count\\n            if boxes[i] == \"1\":\\n                count += 1\\n        count = 0\\n        bns = [0]*n\\n        for i in range(n-2,-1,-1):\\n            if boxes[i+1] == \"1\":\\n                count += 1\\n            bns[i] += count + bns[i+1]\\n    \\n        return [ans[i]+bns[i] for i in range(n)]\\n```\\n\\nYOU CAN SEE HOW RUNTIME DIFFER FOR LINEAR AND QUADRATIC ALGORITHMS\\n![image](https://assets.leetcode.com/users/images/bc313745-e9e6-4f65-a379-f902225bcd0d_1643175505.302727.png)\\n\\nIF YOU HAVE ANY QUERRY REAGARDING THE SOLUTIONS PLZ ASK. IF YOU GET SOMETHING FROM THIS PLEASE **UPVOTE !**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        n = len(boxes)\\n        idx = []\\n        \\n        for i in range(n):\\n            if boxes[i] == \"1\":\\n                idx.append(i)\\n                \\n        return [sum([abs(idx[i]-j) for i in range(len(idx))]) for j in range(n)]\\n```\n```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        n = len(boxes)\\n        count, ans = 0, [0]*n\\n        for i in range(n):\\n            ans[i] = ans[i-1] + count\\n            if boxes[i] == \"1\":\\n                count += 1\\n        count = 0\\n        bns = [0]*n\\n        for i in range(n-2,-1,-1):\\n            if boxes[i+1] == \"1\":\\n                count += 1\\n            bns[i] += count + bns[i+1]\\n    \\n        return [ans[i]+bns[i] for i in range(n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570124,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string s) {\\n        vector<int> ans(s.size());\\n        int n=s.size();\\n        int cost=0;\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            cost=count+cost;\\n            ans[i]+=cost;\\n            if(s[i]==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        cost=0;count=0;\\n        for(int i=n-1;i>=0;i--){\\n            cost=count+cost;\\n            ans[i]+=cost;\\n            if(s[i]==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> minOperations(string s) {\\n        vector<int> ans(s.size());\\n        int n=s.size();\\n        int cost=0;\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            cost=count+cost;\\n            ans[i]+=cost;\\n            if(s[i]==\\'1\\'){\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1522072,
                "title": "java-solution-easy-o-n-time-and-o-1-constant-space",
                "content": "Get the sum of indexes which have 1 and Also count the number of ones, in the first array traversal. Then, in the second traversal, maintain values leftSum and leftCount. Use these to calculate rightSum and rightCount. So, you end up with constant space and linear time. \\n\\n\\n```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int sum = 0, count=0;\\n        int n = boxes.length();\\n        int[] answer = new int[n];\\n        for(int i=0;i<n;i++){\\n            if(boxes.charAt(i) == \\'1\\') {\\n                sum += i+1; \\n                count++;\\n            } \\n        }\\n        int leftSum = 0, leftCount = 0;\\n        for(int i=0;i<n;i++){\\n            if(boxes.charAt(i) == \\'1\\') {\\n                answer[i] = ((leftCount * (i+1)) - leftSum) + (sum - leftSum - (i+1) - (count-leftCount-1)*(i+1));\\n                leftSum += i+1;\\n                leftCount++;\\n            } else {\\n                answer[i] = ((leftCount * (i+1)) - leftSum) + (sum - leftSum - (count-leftCount)*(i+1));\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int sum = 0, count=0;\\n        int n = boxes.length();\\n        int[] answer = new int[n];\\n        for(int i=0;i<n;i++){\\n            if(boxes.charAt(i) == \\'1\\') {\\n                sum += i+1; \\n                count++;\\n            } \\n        }\\n        int leftSum = 0, leftCount = 0;\\n        for(int i=0;i<n;i++){\\n            if(boxes.charAt(i) == \\'1\\') {\\n                answer[i] = ((leftCount * (i+1)) - leftSum) + (sum - leftSum - (i+1) - (count-leftCount-1)*(i+1));\\n                leftSum += i+1;\\n                leftCount++;\\n            } else {\\n                answer[i] = ((leftCount * (i+1)) - leftSum) + (sum - leftSum - (count-leftCount)*(i+1));\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1288451,
                "title": "c-only-one-pass-o-n-time-o-1-space-easy-solution",
                "content": "Same idea as https://leetcode.com/problems/product-of-array-except-self/\\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n = boxes.size();\\n        vector<int> res(n, 0);\\n        int left_cnt = 0, left_step = 0, right_cnt = 0, right_step = 0;\\n        for (int i = 0, j = n-1; i < n; ++i,--j) {\\n            res[i] += left_step;\\n            res[j] += right_step;\\n            if (boxes[i] == \\'1\\') {\\n                ++left_cnt;\\n            }\\n            if (boxes[j] == \\'1\\') {\\n                ++right_cnt;\\n            }\\n            left_step += left_cnt, right_step += right_cnt;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n = boxes.size();\\n        vector<int> res(n, 0);\\n        int left_cnt = 0, left_step = 0, right_cnt = 0, right_step = 0;\\n        for (int i = 0, j = n-1; i < n; ++i,--j) {\\n            res[i] += left_step;\\n            res[j] += right_step;\\n            if (boxes[i] == \\'1\\') {\\n                ++left_cnt;\\n            }\\n            if (boxes[j] == \\'1\\') {\\n                ++right_cnt;\\n            }\\n            left_step += left_cnt, right_step += right_cnt;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285306,
                "title": "c-easiest-solution-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n = boxes.length(), sum;\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++){\\n            sum = 0;\\n            for(int j = 0; j < n; j++){\\n                if (j == i)\\n                    ++j;\\n                if (boxes[j] == \\'1\\')\\n                    sum += abs(j - i);\\n            }\\n            ans[i] += sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n = boxes.length(), sum;\\n        vector<int> ans(n);\\n        for(int i = 0; i < n; i++){\\n            sum = 0;\\n            for(int j = 0; j < n; j++){\\n                if (j == i)\\n                    ++j;\\n                if (boxes[j] == \\'1\\')\\n                    sum += abs(j - i);\\n            }\\n            ans[i] += sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1277321,
                "title": "c-two-pass-o-n-prefix-sum-faster-than-97",
                "content": "```\\n    vector<int> minOperations(string boxes) {\\n        int n=boxes.size();\\n        vector<int>out(n);\\n        vector<int>left(n); //for left prefix sum\\n        vector<int>right(n); //for right prefix sum\\n        \\n        //we will be counting the value of ones to move and prefix sum of left to right\\n        int count_one=boxes[0]-\\'0\\';\\n        for(int i=1;i<n;i++)\\n        {\\n            left[i]+=left[i-1]+count_one;\\n            count_one+=boxes[i]-\\'0\\';\\n        }\\n        \\n         //we will be counting the value of ones to move and prefix sum of right to left\\n        count_one=boxes[n-1]-\\'0\\'; \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            right[i]+=right[i+1]+count_one;\\n            count_one+=boxes[i]-\\'0\\';\\n        }\\n        \\n        //add both the prefix sum;\\n        for(int i=0;i<n;i++)\\n            out[i]=left[i]+right[i];\\n        \\n        \\n        return out;\\n\\t\\t}\\n\\t\\t\\n```\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n    vector<int> minOperations(string boxes) {\\n        int n=boxes.size();\\n        vector<int>out(n);\\n        vector<int>left(n); //for left prefix sum\\n        vector<int>right(n); //for right prefix sum\\n        \\n        //we will be counting the value of ones to move and prefix sum of left to right\\n        int count_one=boxes[0]-\\'0\\';\\n        for(int i=1;i<n;i++)\\n        {\\n            left[i]+=left[i-1]+count_one;\\n            count_one+=boxes[i]-\\'0\\';\\n        }\\n        \\n         //we will be counting the value of ones to move and prefix sum of right to left\\n        count_one=boxes[n-1]-\\'0\\'; \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            right[i]+=right[i+1]+count_one;\\n            count_one+=boxes[i]-\\'0\\';\\n        }\\n        \\n        //add both the prefix sum;\\n        for(int i=0;i<n;i++)\\n            out[i]=left[i]+right[i];\\n        \\n        \\n        return out;\\n\\t\\t}\\n\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1274090,
                "title": "using-cumulative-sum-and-count-o-n-c",
                "content": "Basically, we need to count the relative distances of \\'1\\'s from each index. For that, we maintain 2 vectors - cumsum and count - one to count the cumulative sum of indices of \\'1\\'s until that index, and other to count the total number of \\'1\\'s encountered until that index. After that, we simply need to use addition and subtraction operations to find the relative distances of \\'1\\'s, which is self-explanatory in the code explained below :\\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        \\n        int n = boxes.length();\\n        \\n        vector<int> cumsum(n + 1, 0);\\n        vector<int> count(n + 1, 0);\\n        \\n        int i;\\n        for(i = 1; i <= n ; i++){\\n            \\n            if(boxes[i - 1] == \\'1\\'){\\n                cumsum[i] = cumsum[i - 1] + i - 1;\\n                count[i] = count[i - 1] + 1;\\n            } \\n            \\n            else{\\n                cumsum[i] = cumsum[i -1];\\n                count[i] = count[i - 1];\\n            }\\n        }\\n        \\n        vector<int> result(n, 0);\\n        \\n        int x;\\n        for(i = 0 ; i < n ; i++){\\n            x = cumsum[n] - cumsum[i + 1] - i * (count[n] - count[i + 1]) -  cumsum[i] + i * count[i];\\n            result[i] = x;\\n            \\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        \\n        int n = boxes.length();\\n        \\n        vector<int> cumsum(n + 1, 0);\\n        vector<int> count(n + 1, 0);\\n        \\n        int i;\\n        for(i = 1; i <= n ; i++){\\n            \\n            if(boxes[i - 1] == \\'1\\'){\\n                cumsum[i] = cumsum[i - 1] + i - 1;\\n                count[i] = count[i - 1] + 1;\\n            } \\n            \\n            else{\\n                cumsum[i] = cumsum[i -1];\\n                count[i] = count[i - 1];\\n            }\\n        }\\n        \\n        vector<int> result(n, 0);\\n        \\n        int x;\\n        for(i = 0 ; i < n ; i++){\\n            x = cumsum[n] - cumsum[i + 1] - i * (count[n] - count[i + 1]) -  cumsum[i] + i * count[i];\\n            result[i] = x;\\n            \\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259534,
                "title": "mathematical-approach-total-sum-minus-front-sum",
                "content": "\\n```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        totalsum=0\\n        frontsum=0\\n        k=0\\n        for i in range(0,len(boxes)):\\n            if(boxes[i]!=\\'0\\'):\\n                totalsum+=i\\n                k+=1\\n        n=[]\\n        cnt=0\\n        for i in range(0,len(boxes)):\\n            if(boxes[i]!=\\'0\\'):\\n                frontsum+=i\\n                cnt+=1\\n                n.append(((totalsum-frontsum)-((k-cnt)*i))+abs(frontsum-(cnt*i)))\\n            else:\\n                n.append(((totalsum-frontsum)-((k-cnt)*i))+abs(frontsum-(cnt*i)))\\n        return (n)\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        totalsum=0\\n        frontsum=0\\n        k=0\\n        for i in range(0,len(boxes)):\\n            if(boxes[i]!=\\'0\\'):\\n                totalsum+=i\\n                k+=1\\n        n=[]\\n        cnt=0\\n        for i in range(0,len(boxes)):\\n            if(boxes[i]!=\\'0\\'):\\n                frontsum+=i\\n                cnt+=1\\n                n.append(((totalsum-frontsum)-((k-cnt)*i))+abs(frontsum-(cnt*i)))\\n            else:\\n                n.append(((totalsum-frontsum)-((k-cnt)*i))+abs(frontsum-(cnt*i)))\\n        return (n)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256533,
                "title": "intuitive-easy-c-solution-with-explanations-o-n",
                "content": "Here i am **not** discussing the BRUTE FORCE APPROACH\\n**Logic behind this is:**\\nWe are using the necessary calculations done for the first index element to other elemennts as well\\nNow:\\n**for 0:**\\nkeep leftCnt, rightCnt of \\'1\\' and leftVal,rightVal the values corresponding from both sides.\\n**for any ith:**\\n* Check how many left ones need to move from i-1 pos to ith, and increment +1 to each for one move to each.\\n* For right move each one back by decrmenting -1 to each , now update the val if ith is \\'1\\' which is no longer participating for the value\\n```\\n\\n    vector<int> minOperations(string boxes) {\\n     int leftVal=0;\\n     int rightVal=0;\\n     int leftCnt=0;\\n        int rightCnt=0;\\n        int n=boxes.size();\\n        \\n        // claculating count and value\\n        for(int i=1;i<n;i++){\\n            if(boxes[i]==\\'1\\') {\\n                rightVal+=(i-0);\\n                rightCnt++;}\\n        }\\n        \\n        vector<int>res;\\n        res.push_back(rightVal);\\n        for(int i=1;i<n;i++){\\n\\n            leftCnt=leftCnt+(boxes[i-1]==\\'1\\');             // updating left ones\\n            leftVal+=leftCnt;\\n            rightVal-=rightCnt;                                     // moving  all back 1 step\\n             rightCnt=rightCnt-(boxes[i]==\\'1\\');\\n            res.push_back(leftVal+rightVal);\\n        }\\n        return res;\\n    }\\n\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\n    vector<int> minOperations(string boxes) {\\n     int leftVal=0;\\n     int rightVal=0;\\n     int leftCnt=0;\\n        int rightCnt=0;\\n        int n=boxes.size();\\n        \\n        // claculating count and value\\n        for(int i=1;i<n;i++){\\n            if(boxes[i]==\\'1\\') {\\n                rightVal+=(i-0);\\n                rightCnt++;}\\n        }\\n        \\n        vector<int>res;\\n        res.push_back(rightVal);\\n        for(int i=1;i<n;i++){\\n\\n            leftCnt=leftCnt+(boxes[i-1]==\\'1\\');             // updating left ones\\n            leftVal+=leftCnt;\\n            rightVal-=rightCnt;                                     // moving  all back 1 step\\n             rightCnt=rightCnt-(boxes[i]==\\'1\\');\\n            res.push_back(leftVal+rightVal);\\n        }\\n        return res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1239655,
                "title": "c-prefix-sum-array-o-n-95-96-runtime-with-comments",
                "content": "Analysis:\\n\\nPrefix array approach.\\n\\nUse prefix array to carry over cost of moving over balls for each of two directions.\\n\\nAssume a ball at index `i`, and we want to move to an index `j`, to its right after some non-zero distance X (i.e. `i + X = j`), then the cost to move it is simply `j - i = X`.\\n\\nIf we have `count` number of balls from the left, say from indices `i0,i1,...,in`, what they are doesn\\'t matter, the cost to move them over to index `j` is `(j * count) - (i0 + i1 + ... + in)`.\\n\\nSo with this logic, as we move from one side to another, we only need to track the cumulative distances of all balls from their origin to the end where we started (thats `i0 + i1 + ... + in`), as well as the number of balls (thats `count`), and we can use those two pieces of information to compute the cost to move them to any index `j`.\\n\\nAs we iterate through the array from one end to another, don\\'t forget to increment `count` every time we encounter a ball, for subsequent indices.\\n\\nFinally, we need to do the above steps twice, from left to right, and from right to left, and add the results cumulatively to the result array.\\n\\nSolution:\\n\\n```\\nclass Solution {\\npublic:\\n    std::vector<int> minOperations(std::string boxes) {\\n        const auto N = boxes.size();\\n\\n        std::vector<int> result(N, 0);\\n\\n        // Left to right\\n        int count = 0; // number of balls\\n        int sum = 0;\\n\\n        for ( size_t i = 0; i < N; ++i ) {\\n            result[i] = ( (i+1) * count - sum );\\n\\n            if ( boxes[i] == \\'1\\' ) {\\n                sum += (i+1);\\n                count++;\\n            }\\n        }\\n\\n        // Right to left\\n        count = 0;\\n        sum = 0;\\n        for ( int i = N-1; i >= 0; --i ) {\\n            result[i] += ( (N-i) * count - sum );\\n\\n            if ( boxes[i] == \\'1\\' ) {\\n                sum += (N-i);\\n                count++;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    std::vector<int> minOperations(std::string boxes) {\\n        const auto N = boxes.size();\\n\\n        std::vector<int> result(N, 0);\\n\\n        // Left to right\\n        int count = 0; // number of balls\\n        int sum = 0;\\n\\n        for ( size_t i = 0; i < N; ++i ) {\\n            result[i] = ( (i+1) * count - sum );\\n\\n            if ( boxes[i] == \\'1\\' ) {\\n                sum += (i+1);\\n                count++;\\n            }\\n        }\\n\\n        // Right to left\\n        count = 0;\\n        sum = 0;\\n        for ( int i = N-1; i >= 0; --i ) {\\n            result[i] += ( (N-i) * count - sum );\\n\\n            if ( boxes[i] == \\'1\\' ) {\\n                sum += (N-i);\\n                count++;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219810,
                "title": "c-solution-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n       \\n        \\n        int left=0;\\n        int right=0; //including the index\\n        int dist=0;\\n        for(int i =0;i<boxes.size();++i)\\n        {\\n            if(boxes[i]==\\'1\\')\\n            {\\n                dist+=i;\\n                ++right;\\n            }\\n        }\\n        \\n        vector<int> o(boxes.size(),0);\\n        \\n        if(right ==0)\\n            return o;\\n\\n        for(int i =0;i<boxes.size();++i)\\n        {\\n          o[i]=abs(dist);\\n          if(boxes[i]==\\'1\\')\\n          {\\n            --right;\\n              ++left;\\n          }\\n            dist-= (right-left);\\n            \\n        }\\n        \\n        return o;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n       \\n        \\n        int left=0;\\n        int right=0; //including the index\\n        int dist=0;\\n        for(int i =0;i<boxes.size();++i)\\n        {\\n            if(boxes[i]==\\'1\\')\\n            {\\n                dist+=i;\\n                ++right;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1214298,
                "title": "c-o-n-solution-97-fast",
                "content": "This solution is simply based on using the intution one would get at first shot, i.e., at any point ***i*** we want to know how many balls from left should move how many steps to reach ***i***, similarily from right.\\n\\nSo, we ***pre-compute*** both the solutions by traversing the array once from start and once from end.\\nAt each index, we first assign the **left**(or **right**) array the variable \"***steps***\". Then we check if we get a new ball at this index, if we do then increment variable \"***balls***\" by 1. Now at each frequent step increment your \"***steps***\" by number of balls. \\n\\nAt last, the answer at index ***i*** is nothing but the sum of ***left[i]*** and ***right[i]*** , i.e., ***left[i]+right[i]*** .\\n\\nHappy coding :)\\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n = boxes.size();\\n        vector<int> left(n), right(n);\\n        vector<int> ans(n);\\n        int balls = 0, steps =0;\\n        for(int i=0;i<n;i++)\\n        {\\n            left[i] = steps;\\n            if(boxes[i] == \\'1\\')\\n                balls +=1;\\n            steps+=balls;\\n        }\\n        balls = 0, steps=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            right[i] = steps;\\n            if(boxes[i] == \\'1\\')\\n                balls +=1;\\n            steps+=balls;\\n            ans[i] = left[i]+right[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n = boxes.size();\\n        vector<int> left(n), right(n);\\n        vector<int> ans(n);\\n        int balls = 0, steps =0;\\n        for(int i=0;i<n;i++)\\n        {\\n            left[i] = steps;\\n            if(boxes[i] == \\'1\\')\\n                balls +=1;\\n            steps+=balls;\\n        }\\n        balls = 0, steps=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            right[i] = steps;\\n            if(boxes[i] == \\'1\\')\\n                balls +=1;\\n            steps+=balls;\\n            ans[i] = left[i]+right[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200744,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n = boxes.size();\\n        vector<int> result(n);\\n        \\n        int prev = 0;\\n        int ballCount = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int curResult = prev + ballCount;\\n            result[i] += curResult;\\n            prev = curResult;\\n            \\n            if (boxes[i] == \\'1\\')\\n                ballCount++;\\n        }\\n        \\n        prev = 0;\\n        ballCount = 0;\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            int curResult = prev + ballCount;\\n            result[i] += curResult;\\n            prev = curResult;\\n            \\n            if (boxes[i] == \\'1\\')\\n                ballCount++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n/*\\n0  1 0 1 1 1\\n0  0 1 2 4 7\\n13 9 6 3 1 0\\n*/",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n = boxes.size();\\n        vector<int> result(n);\\n        \\n        int prev = 0;\\n        int ballCount = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int curResult = prev + ballCount;\\n            result[i] += curResult;\\n            prev = curResult;\\n            \\n            if (boxes[i] == \\'1\\')\\n                ballCount++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1191820,
                "title": "javascript-with-comments",
                "content": "```\\nvar minOperations = function(boxes) {\\n    let arr = [...boxes]\\n    let res = [], i\\n    \\n    // get the indices of all the 1\\'s in the string\\n    while((i = arr.indexOf(\\'1\\'))!== -1) {\\n        res.push(i+res.length)\\n        arr.splice(i,1)\\n    }\\n\\n    // distance between each index from the 1\\'s in the string, \\n    for(let ind = 0; ind < boxes.length; ind++) {\\n        arr[ind] = res.reduce((a,c) => a + Math.abs((c - ind)) , 0)\\n    }\\n    \\n    return arr\\n};\\n```\\n```\\n* in the example \"001011\" \\n* we first get the indices of all the 1\\'s in the string and store it in an array\\n\\t* so we get res = [2,4,5]\\n* Now we need to calculate the distance of index of each character in the string from the 1\\'s \\n* which is -> \\nfor boxes[0]  we get [(2-0) + (4-0) + (5-0)] which is 11\\nfor boxes[1]  we get [(2-1) + (4-1) + (5-1)] which is 8 and so on",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minOperations = function(boxes) {\\n    let arr = [...boxes]\\n    let res = [], i\\n    \\n    // get the indices of all the 1\\'s in the string\\n    while((i = arr.indexOf(\\'1\\'))!== -1) {\\n        res.push(i+res.length)\\n        arr.splice(i,1)\\n    }\\n\\n    // distance between each index from the 1\\'s in the string, \\n    for(let ind = 0; ind < boxes.length; ind++) {\\n        arr[ind] = res.reduce((a,c) => a + Math.abs((c - ind)) , 0)\\n    }\\n    \\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1179254,
                "title": "java-o-n-by-maintaining-counts-from-left-and-right",
                "content": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int result[] = new int[boxes.length()];\\n        \\n        char[] chars = boxes.toCharArray();\\n        \\n        int[] countFromLeft = new int[chars.length];\\n        int leftIncrement = 0;\\n        \\n        \\n        int[] countFromRight = new int[chars.length];\\n        int rightIncrement = 0;\\n        \\n        int cumulativeSum = 0;\\n        for (int i = 0; i < chars.length; i++) {\\n            cumulativeSum += leftIncrement;\\n            countFromLeft[i] = cumulativeSum;\\n            if (chars[i] == \\'1\\') {\\n                leftIncrement++;\\n            }\\n        }\\n        \\n        cumulativeSum = 0;\\n        for (int i = chars.length - 1; i >= 0; i--) {\\n            cumulativeSum += rightIncrement;\\n            countFromRight[i] = cumulativeSum;\\n            if (chars[i] == \\'1\\') {\\n                rightIncrement++;\\n            }\\n        }\\n        \\n        \\n        for (int i = 0; i < chars.length; i++) {\\n             result[i] = countFromLeft[i] + countFromRight[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int result[] = new int[boxes.length()];\\n        \\n        char[] chars = boxes.toCharArray();\\n        \\n        int[] countFromLeft = new int[chars.length];\\n        int leftIncrement = 0;\\n        \\n        \\n        int[] countFromRight = new int[chars.length];\\n        int rightIncrement = 0;\\n        \\n        int cumulativeSum = 0;\\n        for (int i = 0; i < chars.length; i++) {\\n            cumulativeSum += leftIncrement;\\n            countFromLeft[i] = cumulativeSum;\\n            if (chars[i] == \\'1\\') {\\n                leftIncrement++;\\n            }\\n        }\\n        \\n        cumulativeSum = 0;\\n        for (int i = chars.length - 1; i >= 0; i--) {\\n            cumulativeSum += rightIncrement;\\n            countFromRight[i] = cumulativeSum;\\n            if (chars[i] == \\'1\\') {\\n                rightIncrement++;\\n            }\\n        }\\n        \\n        \\n        for (int i = 0; i < chars.length; i++) {\\n             result[i] = countFromLeft[i] + countFromRight[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169255,
                "title": "c-faster-than-100-solution-o-n-easy-to-understand",
                "content": "\\nclass Solution {\\n\\npublic:\\n\\n    vector<int> minOperations(string boxes) {\\n     int n=boxes.size();\\n    vector<int> a(n);\\n   \\n    int lc[n];  // for left count of number of 1\\'s before i\\n    int rc[n];  // for right count of number of 1\\'s before i\\n     vector<int> left(n); // to store solution if we move all the left 1\\'s to index i\\n    left[0]=0;\\n    vector<int> right(n);  // to store solution if we move all the right 1\\'s to index i\\n    right[n-1]=0;\\n    lc[0]=0;\\n    rc[n-1]=0;\\n    for(int i=1;i<boxes.size();i++)\\n    { \\n        \\n        if(boxes[i-1]==\\'1\\')\\n        {left[i]=left[i-1]+lc[i-1]+1;\\n            lc[i]=lc[i-1]+1;\\n        }\\n        else\\n        {\\n            left[i]=left[i-1]+lc[i-1];\\n            lc[i]=lc[i-1];\\n        }\\n    }\\n    for(int i=n-2;i>=0;i--)\\n    {   \\n        if (boxes[i+1]==\\'1\\')\\n        {\\n        \\n        right[i]=right[i+1]+rc[i+1]+1;\\n            rc[i]=rc[i+1]+1;\\n        }\\n        else\\n        {\\n        right[i]=right[i+1]+rc[i+1];\\n            rc[i]=rc[i+1];\\n        }\\n    }\\n    for(int i=0;i<n;i++)\\n    {\\n        a[i]=(left[i]+right[i]);\\n    }\\n    return a;\\n\\t}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n\\n    vector<int> minOperations(string boxes) {\\n     int n=boxes.size();\\n    vector<int> a(n);\\n   \\n    int lc[n];  // for left count of number of 1\\'s before i\\n    int rc[n];  // for right count of number of 1\\'s before i\\n     vector<int> left(n); // to store solution if we move all the left 1\\'s to index i\\n    left[0]=0;\\n    vector<int> right(n);  // to store solution if we move all the right 1\\'s to index i\\n    right[n-1]=0;\\n    lc[0]=0;\\n    rc[n-1]=0;\\n    for(int i=1;i<boxes.size();i++)\\n    { \\n        \\n        if(boxes[i-1]==\\'1\\')\\n        {left[i]=left[i-1]+lc[i-1]+1;\\n            lc[i]=lc[i-1]+1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1160020,
                "title": "c-o-n-solution",
                "content": "**Intuition**\\n\\noperations of moving all balls to boxes[i] = operations of moving balls to boxes[i] from its left + operations of moving balls to boxes[i] from its right.\\n\\n\\n**Approach 1**\\n```\\npublic class Solution {\\n    public int[] MinOperations(string boxes) {\\n        \\n        if(boxes == null || boxes.Length == 0)\\n            return new int[0];\\n        \\n        // moveLeft[i]: total operations to balls to boxes[i] from its left\\n        int[] moveLeft = new int[boxes.Length];\\n        moveLeft[0] = 0;\\n        int left = boxes[0] == \\'1\\'? 1 : 0; // number of balls so far\\n        for(int i = 1; i < boxes.Length; i++)\\n        {\\n            moveLeft[i] = moveLeft[i - 1] + left;\\n            left = boxes[i] == \\'1\\'? left + 1: left;\\n        }\\n        \\n        // moveLeft[i]: total operations to balls to boxes[i] from its right\\n        int[] moveRight = new int[boxes.Length];\\n        moveRight[boxes.Length - 1] = 0;\\n        int right = boxes[boxes.Length - 1] == \\'1\\'? 1 : 0;\\n        for(int j = boxes.Length - 2; j >= 0; j--)\\n        {\\n            moveRight[j] = moveRight[j + 1] + right;\\n            right = boxes[j] == \\'1\\'? right + 1 : right;\\n        }\\n        \\n        int[] res = new int[boxes.Length];\\n        for(int k = 0; k < boxes.Length; k++)\\n        {\\n            res[k] = moveLeft[k] + moveRight[k];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n**Approach 2**\\n```\\npublic class Solution {\\n    public int[] MinOperations(string boxes) {\\n        \\n        if(boxes == null || boxes.Length == 0)\\n            return new int[0];\\n        \\n        int[] res = new int[boxes.Length];\\n        int prev = 0, post = 0, op = 0;        \\n        for(int i = 0; i < boxes.Length; i++)\\n        {\\n            op += prev;\\n            prev += boxes[i] - \\'0\\';\\n            res[i] = op;\\n        }\\n        \\n        op = 0;\\n        for(int j = boxes.Length - 1; j >= 0; j--)\\n        {\\n            op += post;\\n            post += boxes[j] - \\'0\\';\\n            res[j] += op;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] MinOperations(string boxes) {\\n        \\n        if(boxes == null || boxes.Length == 0)\\n            return new int[0];\\n        \\n        // moveLeft[i]: total operations to balls to boxes[i] from its left\\n        int[] moveLeft = new int[boxes.Length];\\n        moveLeft[0] = 0;\\n        int left = boxes[0] == \\'1\\'? 1 : 0; // number of balls so far\\n        for(int i = 1; i < boxes.Length; i++)\\n        {\\n            moveLeft[i] = moveLeft[i - 1] + left;\\n            left = boxes[i] == \\'1\\'? left + 1: left;\\n        }\\n        \\n        // moveLeft[i]: total operations to balls to boxes[i] from its right\\n        int[] moveRight = new int[boxes.Length];\\n        moveRight[boxes.Length - 1] = 0;\\n        int right = boxes[boxes.Length - 1] == \\'1\\'? 1 : 0;\\n        for(int j = boxes.Length - 2; j >= 0; j--)\\n        {\\n            moveRight[j] = moveRight[j + 1] + right;\\n            right = boxes[j] == \\'1\\'? right + 1 : right;\\n        }\\n        \\n        int[] res = new int[boxes.Length];\\n        for(int k = 0; k < boxes.Length; k++)\\n        {\\n            res[k] = moveLeft[k] + moveRight[k];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int[] MinOperations(string boxes) {\\n        \\n        if(boxes == null || boxes.Length == 0)\\n            return new int[0];\\n        \\n        int[] res = new int[boxes.Length];\\n        int prev = 0, post = 0, op = 0;        \\n        for(int i = 0; i < boxes.Length; i++)\\n        {\\n            op += prev;\\n            prev += boxes[i] - \\'0\\';\\n            res[i] = op;\\n        }\\n        \\n        op = 0;\\n        for(int j = boxes.Length - 1; j >= 0; j--)\\n        {\\n            op += post;\\n            post += boxes[j] - \\'0\\';\\n            res[j] += op;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152809,
                "title": "c-faster-than-100-self-documented-clean-code",
                "content": "I love self documented code because it\\'s self documented! but to you my precious reader, consider the following test cases:\\n* \"10000\", if you go from left to right the answer would be [0,1,2,3,4], so any patterns in mind? YES! you need to keep track of the **previous ball count**!\\nOkay, consider this:\\n* \"11000\",if you go from left to right  the answer would be [**x**,1,3,4,5],so any patterns in mind? YES! you need to keep track of the **previous steps** as well!\\n\\nOkay what what about the first ball \"**x**\"? Well, that\\'s the other way around! with the same exact algorithm but totally in reverse!\\n```\\n vector<int> minOperations(string boxes) {\\n        int size=boxes.size();\\n        vector<int>answer(size,0);\\n        int numberOfLeftBalls=boxes[0]-\\'0\\',numberOfLeftSteps=0;\\n        for(int i=1;i<size;i++)\\n        {\\n            answer[i]+=numberOfLeftSteps+numberOfLeftBalls;\\n            numberOfLeftSteps+=numberOfLeftBalls;\\n            numberOfLeftBalls+=boxes[i]-\\'0\\';\\n        }\\n         int numberOfRightBalls=boxes[size-1]-\\'0\\',numberOfRightSteps=0;\\n        for(int i=size-2;i>=0;i--)\\n        {\\n            answer[i]+=numberOfRightSteps+numberOfRightBalls;\\n            numberOfRightSteps+=numberOfRightBalls;\\n            numberOfRightBalls+=boxes[i]-\\'0\\';\\n        }\\n        return answer;\\n    }\\n```\\nIf you **like**, **hit** the **Upvote** and If you **don\\'t**, **hit** the **Downvote** \\uD83D\\uDE06",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n vector<int> minOperations(string boxes) {\\n        int size=boxes.size();\\n        vector<int>answer(size,0);\\n        int numberOfLeftBalls=boxes[0]-\\'0\\',numberOfLeftSteps=0;\\n        for(int i=1;i<size;i++)\\n        {\\n            answer[i]+=numberOfLeftSteps+numberOfLeftBalls;\\n            numberOfLeftSteps+=numberOfLeftBalls;\\n            numberOfLeftBalls+=boxes[i]-\\'0\\';\\n        }\\n         int numberOfRightBalls=boxes[size-1]-\\'0\\',numberOfRightSteps=0;\\n        for(int i=size-2;i>=0;i--)\\n        {\\n            answer[i]+=numberOfRightSteps+numberOfRightBalls;\\n            numberOfRightSteps+=numberOfRightBalls;\\n            numberOfRightBalls+=boxes[i]-\\'0\\';\\n        }\\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1148723,
                "title": "easy-detailed-c-solution-in-o-n-time-and-o-1-space",
                "content": "* First travel left to right of ans array \"arr\"\\n\\t* Keep \"l1\" as count of no of 1s on the left of index \"i\" .\\n\\t* **For any i, no steps required to bring all 1s from its left to index \"i\"= [no steps required to bring all 1s from left of index \"i-1\" to \"i-1\"] + l1.** \\n\\t* Update answer for index \"i\" in main answer array \"arr\" only.\\n\\t* After traversal, arr[i] will have no steps to bring all 1s from left of index \"i\" to \"i\". But answer is incomplete as we have to bring 1s from right of index \"i\" too.\\n\\n* Now travel from right to left of ans array \"arr\".\\n\\t* r1=count of no of 1s on the right of index \"i\" .\\n\\t* To save space use a single variable \"prev\" for ans of (i+1)th index.\\n\\t* Again,  **For any i, no steps required to bring all 1s from its right to index \"i\"= [no steps required to bring all 1s from right of index \"i+1\" to \"i+1\"] + r1.** \\n\\t* Update prev as the answer for index \"i\".\\n\\t* Update ans in main answer array \"arr\".\\n\\t\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n=boxes.length();\\n        vector<int> arr(n,0);\\n        int l1=0,r1=0,prev=0;\\n        \\n        // Left to right travel\\n        if(boxes[0]==\\'1\\') l1=1;\\n        \\n        for(int i=1;i<n;i++){\\n            arr[i]=arr[i-1]+l1;\\n            if(boxes[i]==\\'1\\') l1++;\\n        }\\n        \\n        //right to left travel\\n        if(boxes[n-1]==\\'1\\') r1=1;\\n        \\n        for(int i=n-2;i>=0;i--){\\n            arr[i]+=prev+r1;\\n            prev=prev+r1;\\n            if(boxes[i]==\\'1\\') r1++;            \\n        }\\n        return arr;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n=boxes.length();\\n        vector<int> arr(n,0);\\n        int l1=0,r1=0,prev=0;\\n        \\n        // Left to right travel\\n        if(boxes[0]==\\'1\\') l1=1;\\n        \\n        for(int i=1;i<n;i++){\\n            arr[i]=arr[i-1]+l1;\\n            if(boxes[i]==\\'1\\') l1++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1146645,
                "title": "c-easy-explanation-with-diagram-both-o-n2-o-n",
                "content": "This question is simple and o(n2) approach is also accepting\\nHere is the code\\n```\\nvector<int> minOperations(string boxes) {\\n        vector<int> pos;\\n        \\n        for (int i=0;i<boxes.size();i++)\\n        {\\n            if (boxes[i] == \\'1\\')\\n                pos.push_back(i);\\n        }\\n        \\n        vector<int> res(boxes.size(),0);\\n        for (int i=0;i<boxes.size();i++)\\n        {\\n            for (int j=0;j<pos.size();j++)\\n            {\\n                res[i] += abs(i-pos[j]);\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\nNow for tricky part is to how to solve in o(n) comlexity.\\n![image](https://assets.leetcode.com/users/images/9a4dc82b-c4ee-4817-a33f-9759184b0c3d_1617781933.4991782.png)\\nNo we can do this in two pass first from left to right. Here is the code.\\n```\\n  int leftsum=0;\\n        int leftc=0;\\n        \\n        for (int i=0;i<boxes.size();i++)\\n        {\\n            dp[i] = abs(leftsum - leftc*i);\\n            if (boxes[i] == \\'1\\')\\n            {\\n                leftsum += i;\\n                leftc++;\\n            }\\n        }\\n```\\nsecond from right to left. \\n```\\n int rightsum=0;\\n        int rightc=0;\\n        \\n        for (int i=boxes.size()-1;i>=0;i--)\\n        {\\n            dp[i] += abs(rightsum-rightc*i);\\n            if (boxes[i] == \\'1\\')\\n            {\\n                rightsum+=i;\\n                rightc++;\\n            }\\n        }\\n```\\nhere is the full code.\\n```\\nvector<int> minOperations(string boxes) {\\n        \\n        vector<int> dp(boxes.size(),0);\\n        \\n        int leftsum=0;\\n        int leftc=0;\\n        \\n        for (int i=0;i<boxes.size();i++)\\n        {\\n            dp[i] = abs(leftsum - leftc*i);\\n            if (boxes[i] == \\'1\\')\\n            {\\n                leftsum += i;\\n                leftc++;\\n            }\\n        }\\n        \\n        int rightsum=0;\\n        int rightc=0;\\n        \\n        for (int i=boxes.size()-1;i>=0;i--)\\n        {\\n            dp[i] += abs(rightsum-rightc*i);\\n            if (boxes[i] == \\'1\\')\\n            {\\n                rightsum+=i;\\n                rightc++;\\n            }\\n        }\\n        return dp;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> minOperations(string boxes) {\\n        vector<int> pos;\\n        \\n        for (int i=0;i<boxes.size();i++)\\n        {\\n            if (boxes[i] == \\'1\\')\\n                pos.push_back(i);\\n        }\\n        \\n        vector<int> res(boxes.size(),0);\\n        for (int i=0;i<boxes.size();i++)\\n        {\\n            for (int j=0;j<pos.size();j++)\\n            {\\n                res[i] += abs(i-pos[j]);\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n  int leftsum=0;\\n        int leftc=0;\\n        \\n        for (int i=0;i<boxes.size();i++)\\n        {\\n            dp[i] = abs(leftsum - leftc*i);\\n            if (boxes[i] == \\'1\\')\\n            {\\n                leftsum += i;\\n                leftc++;\\n            }\\n        }\\n```\n```\\n int rightsum=0;\\n        int rightc=0;\\n        \\n        for (int i=boxes.size()-1;i>=0;i--)\\n        {\\n            dp[i] += abs(rightsum-rightc*i);\\n            if (boxes[i] == \\'1\\')\\n            {\\n                rightsum+=i;\\n                rightc++;\\n            }\\n        }\\n```\n```\\nvector<int> minOperations(string boxes) {\\n        \\n        vector<int> dp(boxes.size(),0);\\n        \\n        int leftsum=0;\\n        int leftc=0;\\n        \\n        for (int i=0;i<boxes.size();i++)\\n        {\\n            dp[i] = abs(leftsum - leftc*i);\\n            if (boxes[i] == \\'1\\')\\n            {\\n                leftsum += i;\\n                leftc++;\\n            }\\n        }\\n        \\n        int rightsum=0;\\n        int rightc=0;\\n        \\n        for (int i=boxes.size()-1;i>=0;i--)\\n        {\\n            dp[i] += abs(rightsum-rightc*i);\\n            if (boxes[i] == \\'1\\')\\n            {\\n                rightsum+=i;\\n                rightc++;\\n            }\\n        }\\n        return dp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1139560,
                "title": "python3-one-pass-o-n",
                "content": "```\\ndef minOperations(self, boxes: str) -> List[int]:\\n        left_count = left_dist = 0\\n        right_count = right_dist = 0\\n        l = len(boxes)\\n        res = [0] * l\\n        \\n        for i in range(l):\\n            res[i] += left_dist\\n            res[~i] += right_dist\\n            \\n            if boxes[i] == \\'1\\': left_count += 1\\n            if boxes[~i] == \\'1\\': right_count += 1\\n            left_dist += left_count\\n            right_dist += right_count\\n            \\n        return res\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\ndef minOperations(self, boxes: str) -> List[int]:\\n        left_count = left_dist = 0\\n        right_count = right_dist = 0\\n        l = len(boxes)\\n        res = [0] * l\\n        \\n        for i in range(l):\\n            res[i] += left_dist\\n            res[~i] += right_dist\\n            \\n            if boxes[i] == \\'1\\': left_count += 1\\n            if boxes[~i] == \\'1\\': right_count += 1\\n            left_dist += left_count\\n            right_dist += right_count\\n            \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1120040,
                "title": "c-faster-than-100-00",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) \\n    {\\n        int left_1=0;  //keeping count of 1\\'s in left\\n        int right_1=0; //keeping count of 1\\'s in right\\n        int left_sum=0;  //keeping sum of indices in left subarray\\n        int right_sum=0; //keeping sum of indices in right subarray\\n        \\n        for(int i=0;i<boxes.size();i++) // first scan to know the number of 1\\'s and sum of indices having 1 at their position\\n        {\\n            if(boxes[i]==\\'1\\')\\n            {\\n                right_1++;\\n                right_sum+=i;\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        int temp=0;\\n        for(int i=0;i<boxes.size();i++)\\n        {\\n            if(boxes[i]==\\'1\\') //while scanning if 1 is encountered then adjusting the values in left and right sub arrays\\n            {\\n                left_sum+=i;\\n                left_1+=1;\\n                right_sum-=i;\\n                right_1-=1;\\n            }\\n            temp=abs(i*left_1 - left_sum)+abs(i*right_1-right_sum);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIn this solution we need to keep the count of 1\\'s on left side as well as right side.\\nIn addition to that we need to keep the sum of indexes at which 1 is there in the left subarray and right subarray.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) \\n    {\\n        int left_1=0;  //keeping count of 1\\'s in left\\n        int right_1=0; //keeping count of 1\\'s in right\\n        int left_sum=0;  //keeping sum of indices in left subarray\\n        int right_sum=0; //keeping sum of indices in right subarray\\n        \\n        for(int i=0;i<boxes.size();i++) // first scan to know the number of 1\\'s and sum of indices having 1 at their position\\n        {\\n            if(boxes[i]==\\'1\\')\\n            {\\n                right_1++;\\n                right_sum+=i;\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        int temp=0;\\n        for(int i=0;i<boxes.size();i++)\\n        {\\n            if(boxes[i]==\\'1\\') //while scanning if 1 is encountered then adjusting the values in left and right sub arrays\\n            {\\n                left_sum+=i;\\n                left_1+=1;\\n                right_sum-=i;\\n                right_1-=1;\\n            }\\n            temp=abs(i*left_1 - left_sum)+abs(i*right_1-right_sum);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108217,
                "title": "c-o-n",
                "content": "```\\n    vector<int> minOperations(string boxes) {\\n        const int n = boxes.size();\\n        vector<int> res(n,0);\\n        int leftBall= 0, rightBall = 0, leftPre= 0, rightPre = 0;\\n        for(int i=0;i<n;i++){\\n            res[i] += leftPre;\\n            leftBall += boxes[i] - \\'0\\';\\n            leftPre += leftBall;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            res[i] += rightPre;\\n            rightBall += boxes[i] - \\'0\\';\\n            rightPre += rightBall;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    vector<int> minOperations(string boxes) {\\n        const int n = boxes.size();\\n        vector<int> res(n,0);\\n        int leftBall= 0, rightBall = 0, leftPre= 0, rightPre = 0;\\n        for(int i=0;i<n;i++){\\n            res[i] += leftPre;\\n            leftBall += boxes[i] - \\'0\\';\\n            leftPre += leftBall;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            res[i] += rightPre;\\n            rightBall += boxes[i] - \\'0\\';\\n            rightPre += rightBall;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1078447,
                "title": "explanation-one-pass-only-java-with-example-and-commented-optimal-code",
                "content": "```\\n/*\\nExplanation:\\nBrute force :O(n^2) accepted\\nWe will traverse complete array for each and every element let say i\\nif we found 1 at j i.e we have move this 1 at j to i\\ni.e. we have shift this absolute (j-i) \\n*/\\n```\\n\\n```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int n=boxes.length();\\n        int ans[]=new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(boxes.charAt(j)==\\'1\\' && i!=j)\\n                    count+=Math.abs(j-i);\\n            }\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n```\\nOptimal:\\nwhat we have observe that one ball from a box to an adjacent box.\\ni.e. ball can be move to position from left as well as from right\\nn is length of string\\nhere pos is position or 0 based indexing\\nThink when we have only one \\'1\\' in string i.e. \"001000\"\\nconsider from left to right:\\n   consider psoition 2 (0 Indexed positioning) \\n      Now onwards for pos 3=  1 operation\\n\\t              for pos 4=  2 operation\\n\\t\\t\\t\\t  for pos 5=  3 operation\\nOne thing we have noticed that current=previous+1\\n\\nSimilar thing will be done for right to left\\n\\n\\nNow what will happen if we found two \\'1\\' in string i.e. \"00100100\"\\nconsider from left to right:\\n   consider psoition 2 (0 Indexed positioning) \\n      Now onwards for pos 3=  1 operation\\n\\t              for pos 4=  2 operation\\n\\t\\t\\t\\t  for pos 5=  3 operation\\n   Now we get \\'1\\' at position 5 so from 6 onwards we have to add opeartion for \\'1\\' at 5 psotion alse\\n                  for pos 6=  4 + 1 = 5 operation\\n\\t\\t\\t\\t  for pos 7=  5 + 2 = 7 operation\\n\\nHere we have noticed at as soon as we get new \\'1\\' we have to consider for new \\'1\\' also\\nnow formula will be  current = previous + how many  \\'1\\'  appear before\\n\\nSimilar thing will be done for right to left\\n\\nhere I have stored count of one from left to right in rcount and previous value in right\\ncount of one from right to left in lcount and previous value in left\\n```\\n\\n```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int n=boxes.length();\\n        int ans[]=new int[n];\\n        int right=0;\\n        int rcount=0;\\n        int left=0;\\n        int lcount=0;\\n        for(int i=0;i<n;i++)\\n        {\\n\\t\\t    //from left to right\\n\\t\\t\\t\\n\\t\\t\\t// current=previous+nunber of \\'1\\' \\n            ans[i]+=(right+rcount); \\n\\t\\t\\t//Update previous value;\\n            right+=rcount; \\n            //Increase count if we found \\'1\\'\\n\\t\\t\\tif(boxes.charAt(i)==\\'1\\')\\n                rcount++;\\n            \\n\\t\\t\\t//from right to left\\n\\t\\t\\tans[n-1-i]+=(lcount+left);\\n            left+=lcount;\\n            if(boxes.charAt(n-1-i)==\\'1\\')\\n                lcount++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nExplanation:\\nBrute force :O(n^2) accepted\\nWe will traverse complete array for each and every element let say i\\nif we found 1 at j i.e we have move this 1 at j to i\\ni.e. we have shift this absolute (j-i) \\n*/\\n```\n```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int n=boxes.length();\\n        int ans[]=new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(boxes.charAt(j)==\\'1\\' && i!=j)\\n                    count+=Math.abs(j-i);\\n            }\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nOptimal:\\nwhat we have observe that one ball from a box to an adjacent box.\\ni.e. ball can be move to position from left as well as from right\\nn is length of string\\nhere pos is position or 0 based indexing\\nThink when we have only one \\'1\\' in string i.e. \"001000\"\\nconsider from left to right:\\n   consider psoition 2 (0 Indexed positioning) \\n      Now onwards for pos 3=  1 operation\\n\\t              for pos 4=  2 operation\\n\\t\\t\\t\\t  for pos 5=  3 operation\\nOne thing we have noticed that current=previous+1\\n\\nSimilar thing will be done for right to left\\n\\n\\nNow what will happen if we found two \\'1\\' in string i.e. \"00100100\"\\nconsider from left to right:\\n   consider psoition 2 (0 Indexed positioning) \\n      Now onwards for pos 3=  1 operation\\n\\t              for pos 4=  2 operation\\n\\t\\t\\t\\t  for pos 5=  3 operation\\n   Now we get \\'1\\' at position 5 so from 6 onwards we have to add opeartion for \\'1\\' at 5 psotion alse\\n                  for pos 6=  4 + 1 = 5 operation\\n\\t\\t\\t\\t  for pos 7=  5 + 2 = 7 operation\\n\\nHere we have noticed at as soon as we get new \\'1\\' we have to consider for new \\'1\\' also\\nnow formula will be  current = previous + how many  \\'1\\'  appear before\\n\\nSimilar thing will be done for right to left\\n\\nhere I have stored count of one from left to right in rcount and previous value in right\\ncount of one from right to left in lcount and previous value in left\\n```\n```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int n=boxes.length();\\n        int ans[]=new int[n];\\n        int right=0;\\n        int rcount=0;\\n        int left=0;\\n        int lcount=0;\\n        for(int i=0;i<n;i++)\\n        {\\n\\t\\t    //from left to right\\n\\t\\t\\t\\n\\t\\t\\t// current=previous+nunber of \\'1\\' \\n            ans[i]+=(right+rcount); \\n\\t\\t\\t//Update previous value;\\n            right+=rcount; \\n            //Increase count if we found \\'1\\'\\n\\t\\t\\tif(boxes.charAt(i)==\\'1\\')\\n                rcount++;\\n            \\n\\t\\t\\t//from right to left\\n\\t\\t\\tans[n-1-i]+=(lcount+left);\\n            left+=lcount;\\n            if(boxes.charAt(n-1-i)==\\'1\\')\\n                lcount++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076981,
                "title": "c-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(const string& boxes) {\\n        \\n        int oneLeft=0,oneRight=0,sumPos=0;\\n        for(int i=0; i<boxes.size(); ++i)\\n            if(boxes[i]==\\'1\\') {\\n                ++oneRight;\\n                sumPos+=i;\\n            }\\n        \\n        vector<int> res;\\n        for(auto i:boxes) {\\n            res.push_back(sumPos);\\n            if(i==\\'1\\') { ++oneLeft; --oneRight; }\\n            sumPos+=oneLeft-oneRight;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(const string& boxes) {\\n        \\n        int oneLeft=0,oneRight=0,sumPos=0;\\n        for(int i=0; i<boxes.size(); ++i)\\n            if(boxes[i]==\\'1\\') {\\n                ++oneRight;\\n                sumPos+=i;\\n            }\\n        \\n        vector<int> res;\\n        for(auto i:boxes) {\\n            res.push_back(sumPos);\\n            if(i==\\'1\\') { ++oneLeft; --oneRight; }\\n            sumPos+=oneLeft-oneRight;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076688,
                "title": "java-o-n-time-o-n-space-dp-beginner-friendly-easy",
                "content": "idea inspired by @votrubac \\n\\nbring all balls from left to right and calculate cost for every i  , and do the same from right to left \\nthen ans[i] = cost to bring all balls from left to i + cost to bring all balls from right to i \\n\\n```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int n = boxes.length() ;\\n        int ans [] = new int[n];\\n        int balls = boxes.charAt(0) - \\'0\\' ;\\n        ans[0] = 0 ;\\n        \\n        // for any i the cost to bring all balls at i from left side is the sum of cost to bring all balls to i - 1 th index \\n        // and number of balls in the i - 1 th index , becasue each ball costs 1 unit to move 1 index\\n        // so left[i] = left[i - 1] + cnt of balls at i - 1 th index\\n        for(int i = 1 ; i < n ; i++){\\n            ans[i] = ans[i - 1] + balls ; \\n            balls += boxes.charAt(i) - \\'0\\';\\n        }\\n        \\n        \\n        // use same logic to calculate cost to bring all balls to i from right side  \\n        balls = boxes.charAt(n - 1) -\\'0\\';\\n        int rcost[] = new int[n];\\n        rcost[n - 1] = 0 ;\\n        \\n        for(int i = n - 2 ; i >= 0 ; i--){\\n            rcost[i] = rcost[i + 1] + balls ;\\n            balls += boxes.charAt(i) - \\'0\\';\\n        }\\n        \\n        // soo ... ans at i will be left[i] + right [i]\\n        for(int i = 0 ; i < n ; i++)\\n            ans[i] += rcost[i];\\n        return ans ;   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int n = boxes.length() ;\\n        int ans [] = new int[n];\\n        int balls = boxes.charAt(0) - \\'0\\' ;\\n        ans[0] = 0 ;\\n        \\n        // for any i the cost to bring all balls at i from left side is the sum of cost to bring all balls to i - 1 th index \\n        // and number of balls in the i - 1 th index , becasue each ball costs 1 unit to move 1 index\\n        // so left[i] = left[i - 1] + cnt of balls at i - 1 th index\\n        for(int i = 1 ; i < n ; i++){\\n            ans[i] = ans[i - 1] + balls ; \\n            balls += boxes.charAt(i) - \\'0\\';\\n        }\\n        \\n        \\n        // use same logic to calculate cost to bring all balls to i from right side  \\n        balls = boxes.charAt(n - 1) -\\'0\\';\\n        int rcost[] = new int[n];\\n        rcost[n - 1] = 0 ;\\n        \\n        for(int i = n - 2 ; i >= 0 ; i--){\\n            rcost[i] = rcost[i + 1] + balls ;\\n            balls += boxes.charAt(i) - \\'0\\';\\n        }\\n        \\n        // soo ... ans at i will be left[i] + right [i]\\n        for(int i = 0 ; i < n ; i++)\\n            ans[i] += rcost[i];\\n        return ans ;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075542,
                "title": "python-with-description-set",
                "content": "\\n\\n```\\n    def minOperations(self, boxes):\\n        se = set()\\n        for i in range(len(boxes)): # a set that has index of \"1\"\\n            if boxes[i] == \"1\":\\n                se.add(i)\\n        li = [0] * len(boxes)\\n        for i in range(len(boxes)): # for each box we calculate distance with other box which has \"1\"\\n            su =0\\n            for j in se:\\n                su+=abs(i-j) #abs is for calculate distance\\n            li[i] = su\\n        return li\\n```\\nLet me know if it is not clear :)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def minOperations(self, boxes):\\n        se = set()\\n        for i in range(len(boxes)): # a set that has index of \"1\"\\n            if boxes[i] == \"1\":\\n                se.add(i)\\n        li = [0] * len(boxes)\\n        for i in range(len(boxes)): # for each box we calculate distance with other box which has \"1\"\\n            su =0\\n            for j in se:\\n                su+=abs(i-j) #abs is for calculate distance\\n            li[i] = su\\n        return li\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4050868,
                "title": "two-pass-o-n-solution-faster-than-100",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$O(n)$$<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string box) {\\n        vector<int> x1;\\n        int count1=0,ans=0;\\n        for(int i=0;i<box.size();i++){\\n            x1.push_back(ans);\\n            if(box[i]==\\'1\\'){count1++;}\\n            ans+=count1;\\n        }count1=0;ans=0;\\n        for(int i=box.size()-1;i>=0;i--){\\n            x1[i]+=ans;\\n            if(box[i]==\\'1\\'){count1++;}\\n            ans+=count1;\\n        }\\n        return x1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string box) {\\n        vector<int> x1;\\n        int count1=0,ans=0;\\n        for(int i=0;i<box.size();i++){\\n            x1.push_back(ans);\\n            if(box[i]==\\'1\\'){count1++;}\\n            ans+=count1;\\n        }count1=0;ans=0;\\n        for(int i=box.size()-1;i>=0;i--){\\n            x1[i]+=ans;\\n            if(box[i]==\\'1\\'){count1++;}\\n            ans+=count1;\\n        }\\n        return x1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939535,
                "title": "easiest-solution-java",
                "content": "# Code\\n```\\nclass Solution{\\n    public int[] minOperations(String boxes){\\n        int n = boxes.length();\\n        int[] ans = new int[n];\\n        for(int i=0; i<n; i++){\\n            int t = 0;\\n            for(int j=0; j<n; j++){\\n                char c = boxes.charAt(j);\\n                if(c==\\'1\\') t += Math.abs(i-j);\\n            }\\n            ans[i] = t;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n    public int[] minOperations(String boxes){\\n        int n = boxes.length();\\n        int[] ans = new int[n];\\n        for(int i=0; i<n; i++){\\n            int t = 0;\\n            for(int j=0; j<n; j++){\\n                char c = boxes.charAt(j);\\n                if(c==\\'1\\') t += Math.abs(i-j);\\n            }\\n            ans[i] = t;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924488,
                "title": "c-easy-approach-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n=boxes.size();\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            for(int j=0;j<n;j++){\\n                if(boxes[j]==\\'1\\'){\\n                    count+=abs(i-j);\\n                }\\n            }\\n            ans.push_back(count);\\n\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n=boxes.size();\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            for(int j=0;j<n;j++){\\n                if(boxes[j]==\\'1\\'){\\n                    count+=abs(i-j);\\n                }\\n            }\\n            ans.push_back(count);\\n\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863136,
                "title": "beats-97-98-java-beginner-friendly-easy-way-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize variables \\'moves\\' and \\'diff\\' to keep track of the total moves and the distance between positions, respectively.\\n2. Create an integer array \\'ans\\' with the same length as the \\'boxes\\' string to store the total moves for each position.\\n3. Start iterating through the \\'boxes\\' string using the variable \\'i\\', representing the current position.\\n4. For each \\'i\\', start another loop with the variable \\'j\\' to iterate through the \\'boxes\\' string again.\\n5. For each \\'j\\', check if \\'i\\' and \\'j\\' are not the same position, and if the box at position \\'j\\' contains a ball (i.e., \\'boxes.charAt(j) == \\'1\\'\\').\\n6. If both conditions are met, calculate the absolute difference between \\'i\\' and \\'j\\' (i.e., \\'diff = Math.abs(j - i)\\') and add it to the \\'moves\\' variable.\\n7. After the inner loop, store the value of \\'moves\\' in the \\'ans\\' array at index \\'i\\', representing the total moves required for the ball at position \\'i\\'.\\n8. Reset the \\'moves\\' variable to zero for the next iteration.\\n9. Repeat steps 4 to 8 for all positions in the \\'boxes\\' string.\\n10. Return the \\'ans\\' array containing the total moves for each ball\\'s position.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n)\\nwhere,\\n \\'n\\' is the length of the \\'boxes\\' string.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int moves = 0;\\n        int diff = 0;\\n        int[] ans = new int[boxes.length()];\\n        for(int i=0; i<boxes.length(); i++){\\n            for(int j=0; j<boxes.length(); j++){\\n                if(i!=j && boxes.charAt(j)==\\'1\\'){\\n                    diff = Math.abs(j-i);\\n                    moves = moves+diff;\\n                }\\n            }\\n            ans[i] = moves;\\n            moves = 0;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int moves = 0;\\n        int diff = 0;\\n        int[] ans = new int[boxes.length()];\\n        for(int i=0; i<boxes.length(); i++){\\n            for(int j=0; j<boxes.length(); j++){\\n                if(i!=j && boxes.charAt(j)==\\'1\\'){\\n                    diff = Math.abs(j-i);\\n                    moves = moves+diff;\\n                }\\n            }\\n            ans[i] = moves;\\n            moves = 0;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325801,
                "title": "brute-force-must-see-easy-to-understand",
                "content": "# Code\\n```\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) \\n    {\\n         vector<int>ans;\\n         for(int i=0;i<boxes.length();i++)\\n         {\\n             //creating the ans for the ith index\\n             string str = boxes;\\n             int temp = 0;\\n             for(int j=str.length()-1;j>i;j--)\\n             {\\n                 if(str[j] == \\'0\\')\\n                 {\\n                     continue;\\n                 }\\n                 else\\n                 {\\n                     int move = abs(i-j);\\n                     temp+=move;\\n                 }\\n             }\\n             for(int j=0;j<i;j++)\\n             {\\n                 if(str[j] == \\'0\\')\\n                 {\\n                     continue;\\n                 }\\n                 else\\n                 {\\n                     int move = abs(i-j);\\n                     temp+=move;\\n                 }\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) \\n    {\\n         vector<int>ans;\\n         for(int i=0;i<boxes.length();i++)\\n         {\\n             //creating the ans for the ith index\\n             string str = boxes;\\n             int temp = 0;\\n             for(int j=str.length()-1;j>i;j--)\\n             {\\n                 if(str[j] == \\'0\\')\\n                 {\\n                     continue;\\n                 }\\n                 else\\n                 {\\n                     int move = abs(i-j);\\n                     temp+=move;\\n                 }\\n             }\\n             for(int j=0;j<i;j++)\\n             {\\n                 if(str[j] == \\'0\\')\\n                 {\\n                     continue;\\n                 }\\n                 else\\n                 {\\n                     int move = abs(i-j);\\n                     temp+=move;\\n                 }\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3298714,
                "title": "just-prefix-sum-easy-approach",
                "content": "You just need to count where the index of \\'1\\' is present and then find the absolute difference between current index and index of \\'1\\' and push the difference of each index into the ans vector.\\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> minOperations(string boxes)\\n    {\\n\\n        vector<int> ans;\\n\\n        int n = boxes.size();\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            int cnt = 0;\\n\\n            for (int j = 0; j < n; j++)\\n            {\\n\\n                if (boxes[j] == \\'1\\')\\n                {\\n                    cnt += abs(i - j);\\n                }\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> minOperations(string boxes)\\n    {\\n\\n        vector<int> ans;\\n\\n        int n = boxes.size();\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            int cnt = 0;\\n\\n            for (int j = 0; j < n; j++)\\n            {\\n\\n                if (boxes[j] == \\'1\\')\\n                {\\n                    cnt += abs(i - j);\\n                }\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273836,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func minOperations(_ boxes: String) -> [Int] {\\n        \\n        let bs = boxes\\n            .map { $0 }\\n            .enumerated()\\n            .filter { $0.element == \"1\" }\\n            .map { $0.offset }\\n        \\n        return (0..<boxes.count).map { i in bs.map({ abs(i - $0) }).reduce(0, +) }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minOperations(_ boxes: String) -> [Int] {\\n        \\n        let bs = boxes\\n            .map { $0 }\\n            .enumerated()\\n            .filter { $0.element == \"1\" }\\n            .map { $0.offset }\\n        \\n        return (0..<boxes.count).map { i in bs.map({ abs(i - $0) }).reduce(0, +) }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241536,
                "title": "simple-brute-force-and-optimized-solutions-c-easy-understandable",
                "content": "# Brute force TLE\\n# Time:O(n*n)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        vector<int>ans;\\n        for(int i=0;i<boxes.size();i++){\\n            int sum=0;\\n            for(int j=0;j<boxes.size();j++){\\n                    cout<<j<<\" \";\\n\\n                if(boxes[j] == \\'1\\') sum+=abs(j-i); \\n                if(j == boxes.size()-1)  ans.push_back(sum);\\n           \\n            }\\n\\n\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# OPTIMIZED\\n# Time:O(n*m) where m=number of ones\\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        vector<int>ans;\\n        vector<int>help;\\n        int one=0;\\n        for(int i=0;i<boxes.size();i++){\\n            if(boxes[i] == \\'1\\') help.push_back(i);\\n        }\\n         for(int i=0;i<boxes.size();i++){\\n       int sum=0;\\n        for(int j=0;j<help.size();j++){\\n            sum+=abs(help[j]-i);\\n        }\\n        ans.push_back(sum);\\n    }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        vector<int>ans;\\n        for(int i=0;i<boxes.size();i++){\\n            int sum=0;\\n            for(int j=0;j<boxes.size();j++){\\n                    cout<<j<<\" \";\\n\\n                if(boxes[j] == \\'1\\') sum+=abs(j-i); \\n                if(j == boxes.size()-1)  ans.push_back(sum);\\n           \\n            }\\n\\n\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        vector<int>ans;\\n        vector<int>help;\\n        int one=0;\\n        for(int i=0;i<boxes.size();i++){\\n            if(boxes[i] == \\'1\\') help.push_back(i);\\n        }\\n         for(int i=0;i<boxes.size();i++){\\n       int sum=0;\\n        for(int j=0;j<help.size();j++){\\n            sum+=abs(help[j]-i);\\n        }\\n        ans.push_back(sum);\\n    }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3228948,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int [] m = new int[boxes.length()];\\n        for(int i = 0; i < boxes.length(); i++){\\n            for(int j = 0; j < boxes.length(); j++){\\n                if(boxes.charAt(j) == \\'1\\' && i !=  j)\\n                    m[i] += Math.abs(i-j);\\n            }\\n        }   \\n        return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int [] m = new int[boxes.length()];\\n        for(int i = 0; i < boxes.length(); i++){\\n            for(int j = 0; j < boxes.length(); j++){\\n                if(boxes.charAt(j) == \\'1\\' && i !=  j)\\n                    m[i] += Math.abs(i-j);\\n            }\\n        }   \\n        return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185854,
                "title": "brute-force-and-optimised",
                "content": "```\\nvoid pa(vector<int> v)\\n{\\n    for(auto i: v)\\n    {\\n        cout<<i<<\" \";\\n    }\\n    cout<<endl;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string b) {\\n        int n  = b.size();\\n        vector<int> v(n,0),right(n,0);\\n        int cnt = 0;\\n        \\n        cnt=(b[0]==\\'1\\');\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            v[i] = v[i-1]+cnt;\\n            cnt+=(b[i]==\\'1\\');\\n            \\n        }\\n        cnt=(b[n-1]==\\'1\\');\\n         for(int i=n-2;i>=0;i--)\\n        {\\n            right[i] = right[i+1]+cnt;\\n            cnt+=(b[i]==\\'1\\');\\n        }\\n        \\n\\n        for(int i=0;i<n;i++)\\n            v[i]+=right[i];\\n        \\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     int cnt = 0;\\n        //     for(int j=0;j<n;j++){\\n        //         if(i==j)\\n        //             continue;\\n        //         if(b[j]==\\'1\\')\\n        //         {\\n        //             cnt+=abs(j-i);\\n        //         }\\n        //     }\\n        //     v[i] =  cnt;           \\n        // }\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid pa(vector<int> v)\\n{\\n    for(auto i: v)\\n    {\\n        cout<<i<<\" \";\\n    }\\n    cout<<endl;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string b) {\\n        int n  = b.size();\\n        vector<int> v(n,0),right(n,0);\\n        int cnt = 0;\\n        \\n        cnt=(b[0]==\\'1\\');\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            v[i] = v[i-1]+cnt;\\n            cnt+=(b[i]==\\'1\\');\\n            \\n        }\\n        cnt=(b[n-1]==\\'1\\');\\n         for(int i=n-2;i>=0;i--)\\n        {\\n            right[i] = right[i+1]+cnt;\\n            cnt+=(b[i]==\\'1\\');\\n        }\\n        \\n\\n        for(int i=0;i<n;i++)\\n            v[i]+=right[i];\\n        \\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     int cnt = 0;\\n        //     for(int j=0;j<n;j++){\\n        //         if(i==j)\\n        //             continue;\\n        //         if(b[j]==\\'1\\')\\n        //         {\\n        //             cnt+=abs(j-i);\\n        //         }\\n        //     }\\n        //     v[i] =  cnt;           \\n        // }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2842552,
                "title": "java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int[] res = new int[boxes.length()];\\n        for (int k = 0; k < boxes.length(); k++) {\\n            int i = 0, j = boxes.length()-1;\\n            int c = 0;\\n            while(i < k || j > k){\\n                if(i < k && boxes.charAt(i) == \\'1\\') c += k-i;\\n                if(j > k && boxes.charAt(j) == \\'1\\') c += j-k;\\n                i++;\\n                j--;\\n            }\\n            res[k] = c;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int[] res = new int[boxes.length()];\\n        for (int k = 0; k < boxes.length(); k++) {\\n            int i = 0, j = boxes.length()-1;\\n            int c = 0;\\n            while(i < k || j > k){\\n                if(i < k && boxes.charAt(i) == \\'1\\') c += k-i;\\n                if(j > k && boxes.charAt(j) == \\'1\\') c += j-k;\\n                i++;\\n                j--;\\n            }\\n            res[k] = c;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802234,
                "title": "c-beginner-friendly-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> minOperations(string boxes) {\\n        vector<int> ans;\\n        int temp;\\n        for(int i=0;i<boxes.length();i++)\\n        {\\n            temp=0;\\n            for(int j=0;j<boxes.length();j++)\\n            {\\n                if( i!=j && boxes[j]==\\'1\\')\\n                {\\n                    temp+=abs(i-j);\\n                }\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> minOperations(string boxes) {\\n        vector<int> ans;\\n        int temp;\\n        for(int i=0;i<boxes.length();i++)\\n        {\\n            temp=0;\\n            for(int j=0;j<boxes.length();j++)\\n            {\\n                if( i!=j && boxes[j]==\\'1\\')\\n                {\\n                    temp+=abs(i-j);\\n                }\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572157,
                "title": "c-solution-minimum-number-of-operations-to-move-all-balls-to-each-box",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        vector<int> ans;\\n        \\n        for(int i = 0 ; i < boxes.size() ; i++){\\n            int x = 0;\\n            for(int j = 0 ; j < boxes.size() ; j++){\\n                if(boxes[j] == \\'1\\')\\n                    x = x + abs(i-j);\\n            }\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        vector<int> ans;\\n        \\n        for(int i = 0 ; i < boxes.size() ; i++){\\n            int x = 0;\\n            for(int j = 0 ; j < boxes.size() ; j++){\\n                if(boxes[j] == \\'1\\')\\n                    x = x + abs(i-j);\\n            }\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527911,
                "title": "80-time-beats-90-space-beats-12ms-c-easy-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string &boxes) {\\n        int a = 0, b = 0, c = 0, d = 0,i = 0;\\n        for(i = boxes.size()-1; i >= 0; i--){\\n            d += c;\\n            if(boxes[i] == \\'1\\'){\\n                c++;\\n            }\\n        }\\n        vector<int> ans(boxes.size());\\n        for(int i = 0; i < boxes.size(); i++){\\n            if(boxes[i] == \\'1\\'){\\n                c--;\\n            }\\n            ans[i] = b+d;\\n            d = d - c;\\n            if(boxes[i] == \\'1\\'){\\n                a++;\\n            }\\n            b =b +a;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string &boxes) {\\n        int a = 0, b = 0, c = 0, d = 0,i = 0;\\n        for(i = boxes.size()-1; i >= 0; i--){\\n            d += c;\\n            if(boxes[i] == \\'1\\'){\\n                c++;\\n            }\\n        }\\n        vector<int> ans(boxes.size());\\n        for(int i = 0; i < boxes.size(); i++){\\n            if(boxes[i] == \\'1\\'){\\n                c--;\\n            }\\n            ans[i] = b+d;\\n            d = d - c;\\n            if(boxes[i] == \\'1\\'){\\n                a++;\\n            }\\n            b =b +a;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491885,
                "title": "c-is-it-a-single-pass-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int sz = boxes.size(), count = 0, ops = 0, backCount = 0, backOps = 0;\\n        vector<int> res(sz);\\n        for(int i=0, j=sz-i-1;i<sz;i++,j--) {\\n            ops += count; \\n            backOps += backCount;\\n            count += (boxes[i] == \\'1\\');\\n            backCount += (boxes[j] == \\'1\\');\\n            res[i] += ops;\\n            res[j] += backOps;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int sz = boxes.size(), count = 0, ops = 0, backCount = 0, backOps = 0;\\n        vector<int> res(sz);\\n        for(int i=0, j=sz-i-1;i<sz;i++,j--) {\\n            ops += count; \\n            backOps += backCount;\\n            count += (boxes[i] == \\'1\\');\\n            backCount += (boxes[j] == \\'1\\');\\n            res[i] += ops;\\n            res[j] += backOps;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480481,
                "title": "python-o-n-using-dynamic-programming-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        left, right = [0] * len(boxes), [0] * len(boxes)\\n        \\n        ball = 0\\n        for i in range(1, len(left)):\\n            ball += (1 if boxes[i-1] == \\'1\\' else 0)\\n            left[i] = left[i-1] + ball\\n            \\n\\n        ball = 0\\n        for i in range(len(right) - 2, -1, -1):\\n            ball += (1 if boxes[i+1] == \\'1\\' else 0)\\n            right[i] += right[i+1] + ball\\n                \\n        return [l + r for l, r in zip(left, right)]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        left, right = [0] * len(boxes), [0] * len(boxes)\\n        \\n        ball = 0\\n        for i in range(1, len(left)):\\n            ball += (1 if boxes[i-1] == \\'1\\' else 0)\\n            left[i] = left[i-1] + ball\\n            \\n\\n        ball = 0\\n        for i in range(len(right) - 2, -1, -1):\\n            ball += (1 if boxes[i+1] == \\'1\\' else 0)\\n            right[i] += right[i+1] + ball\\n                \\n        return [l + r for l, r in zip(left, right)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460155,
                "title": "brute-force-approach-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int n = boxes.length();\\n        int arr[] = new int[n];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j)\\n                    continue;\\n                if(boxes.charAt(j)==\\'1\\'){\\n                    arr[i] += Math.abs(i-j);\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] minOperations(String boxes) {\\n        int n = boxes.length();\\n        int arr[] = new int[n];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j)\\n                    continue;\\n                if(boxes.charAt(j)==\\'1\\'){\\n                    arr[i] += Math.abs(i-j);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2459219,
                "title": "java-solution-2-approaches-1-bruteforce-o-n-2-2-linear-o-n",
                "content": "```\\nclass Solution {\\n    // public int[] minOperations(String boxes) {\\n    //     int n = boxes.length();\\n    //     char[] boxesAry = boxes.toCharArray();\\n    //     int[] ans = new int[n];\\n    //     for(int i=0;i<n;i++){\\n    //         for(int j=0;j<n;j++){\\n    //             if(boxesAry[j]==\\'1\\')\\n    //                 ans[i] += Math.abs(i-j);\\n    //         }\\n    //     }\\n    //     return ans;\\n    // }\\n    public int[] minOperations(String boxes) {\\n        int n = boxes.length();\\n        char[] boxesAry = boxes.toCharArray();\\n        int[] left = new int[n], right = new int[n];; \\n        int[] ans = new int[n];\\n        left[0] = 0;\\n        right[n-1] = 0;\\n        int count = 0;\\n        for(int i=1;i<n;i++){\\n            count += boxesAry[i-1]-\\'0\\';\\n            \\n            left[i] = left[i-1]+count;\\n            \\n        }\\n        count = 0;\\n        for(int i=n-2;i>=0;i--){\\n            count += boxesAry[i+1]-\\'0\\';\\n            right[i] = right[i+1]+count;\\n        }\\n        for(int i=0;i<n;i++){\\n            ans[i] = left[i]+right[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    // public int[] minOperations(String boxes) {\\n    //     int n = boxes.length();\\n    //     char[] boxesAry = boxes.toCharArray();\\n    //     int[] ans = new int[n];\\n    //     for(int i=0;i<n;i++){\\n    //         for(int j=0;j<n;j++){\\n    //             if(boxesAry[j]==\\'1\\')\\n    //                 ans[i] += Math.abs(i-j);\\n    //         }\\n    //     }\\n    //     return ans;\\n    // }\\n    public int[] minOperations(String boxes) {\\n        int n = boxes.length();\\n        char[] boxesAry = boxes.toCharArray();\\n        int[] left = new int[n], right = new int[n];; \\n        int[] ans = new int[n];\\n        left[0] = 0;\\n        right[n-1] = 0;\\n        int count = 0;\\n        for(int i=1;i<n;i++){\\n            count += boxesAry[i-1]-\\'0\\';\\n            \\n            left[i] = left[i-1]+count;\\n            \\n        }\\n        count = 0;\\n        for(int i=n-2;i>=0;i--){\\n            count += boxesAry[i+1]-\\'0\\';\\n            right[i] = right[i+1]+count;\\n        }\\n        for(int i=0;i<n;i++){\\n            ans[i] = left[i]+right[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446728,
                "title": "c-double-pass-prefix-suffix-sum-100-time-0ms-80-space-8-9mb",
                "content": "Intriguing problem and while we might be tempted to solve it in quadratic time (counting  all the elements to the left and to the right of each cell with their distances from it), we can of course do better.\\n\\nIf we think for example about the string `\"001011\"`, we will see that the first cell needs `2` moves for the firsts `\\'1\\'`, `4` for the second `\\'1\\'` and  `5` moves for the last `\\'1\\'`, so `11` moves in total; the second cell will require only `8` moves in total, since we moved closer to all `3` existing `\\'1\\'` to the right of it and so on. Only once we pass a `\\'1\\'` we will start reducing the total cost of the previous cell in smaller increment: after we reach the third cell, which is itself a `1` and will cost us `8 - 3 == 5` moves to fill, we will start decreasing the cost of moving the balls to the right by `2` at each step. \\n\\nWe can have specular logic running for the left side and we are mostly done.\\n\\nNow, to translate all this elucubrations into code, we will start declaring a few support variables:\\n* `left` and `leftSum` will store the number of elements on the left of the current cell and the total cost to move them in position, all initialised to `0`;\\n* specularly, `right` and `rightSum` will store the number of balls and their cost to be moved in the current cell - again set to `0` initially;\\n* `len` will store the length of `boxes`;\\n* `res` will be our accumulator variable, set to be already of the proper size (`len`) to avoid reallocations.\\n\\nWe will then compute `right` and `rightSum`, parsing `boxes` from the right with `i` and:\\n* increasing `right` by `1` when we meet a `\\'1\\'`;\\n* increasing `rightSum` by `right`, as explained above.\\n\\nNow, with this information readied, we can go and compute each cell of `res`, again using `i`, this time from the left and:\\n* set `currIsOne` to be `1` when the current character is a `\\'1\\'`, `0` otherwise;\\n* specularly to the above move,  decreasing `rightSum` by `right`;\\n* decreasing `right` by `currIsOne`;\\n* writing the sum of `leftSum` and `rightSum` into the `i`th cell of `res`;\\n* again, specularly to the first loop, increasing `left` by `currIsOne`;\\n* increasing `leftSum` by `left`, as explained above.\\n\\nOnce done, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int left = 0, leftSum = 0, right = 0, rightSum = 0, len = boxes.size();\\n        vector<int> res(len);\\n        // computing right and rightSum\\n        for (int i = len - 1; i >= 0; i--) {\\n            right += boxes[i] == \\'1\\';\\n            rightSum += right;\\n        }\\n        // populating res\\n        for (int i = 0, currIsOne; i < len; i++) {\\n            // checking if we are parsing a \\'1\\' now\\n            currIsOne = boxes[i] == \\'1\\';\\n            // updating the right elements\\n            rightSum -= right;\\n            right -= currIsOne;\\n            // updating res\\n            res[i] = leftSum + rightSum;\\n            // updating the left elements\\n            left += currIsOne;\\n            leftSum += left;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAlternative using only one variable for the amount of elements and only one for the prefix/suffix sum; it seems to go a bit slower, despite doing a bit less computations - possibly the cost of accessing a different vector element twice? Anyway, the update code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int ones = 0, onesSum = 0, len = boxes.size();\\n        vector<int> res(len);\\n        // getting all the moves for balls on the right\\n        for (int i = len - 1; i >= 0; i--) {\\n            res[i] = (onesSum += ones);\\n            ones += boxes[i] == \\'1\\';\\n        }\\n        // resetting ones and onesSum\\n        ones = 0, onesSum = 0;\\n        // getting all the moves for balls on the left\\n        for (int i = 0; i < len; i++) {\\n            res[i] += (onesSum += ones);\\n            ones += boxes[i] == \\'1\\';\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int left = 0, leftSum = 0, right = 0, rightSum = 0, len = boxes.size();\\n        vector<int> res(len);\\n        // computing right and rightSum\\n        for (int i = len - 1; i >= 0; i--) {\\n            right += boxes[i] == \\'1\\';\\n            rightSum += right;\\n        }\\n        // populating res\\n        for (int i = 0, currIsOne; i < len; i++) {\\n            // checking if we are parsing a \\'1\\' now\\n            currIsOne = boxes[i] == \\'1\\';\\n            // updating the right elements\\n            rightSum -= right;\\n            right -= currIsOne;\\n            // updating res\\n            res[i] = leftSum + rightSum;\\n            // updating the left elements\\n            left += currIsOne;\\n            leftSum += left;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int ones = 0, onesSum = 0, len = boxes.size();\\n        vector<int> res(len);\\n        // getting all the moves for balls on the right\\n        for (int i = len - 1; i >= 0; i--) {\\n            res[i] = (onesSum += ones);\\n            ones += boxes[i] == \\'1\\';\\n        }\\n        // resetting ones and onesSum\\n        ones = 0, onesSum = 0;\\n        // getting all the moves for balls on the left\\n        for (int i = 0; i < len; i++) {\\n            res[i] += (onesSum += ones);\\n            ones += boxes[i] == \\'1\\';\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433542,
                "title": "java-simple-o-n",
                "content": "```\\npublic int[] minOperations(String boxes) {\\n        int len=boxes.length();\\n        int[] arr=new int[len];\\n        int j=0;\\n        for(char ch:boxes.toCharArray()){\\n            if(ch==\\'1\\'){\\n                arr[j++]=1;\\n            }else{\\n                arr[j++]=0;\\n            }\\n        }\\n        int[] leftBalls=new int[len];\\n        int[] rightBalls=new int[len];\\n        int[] leftShifts=new int[len];\\n        int[] rightShifts=new int[len];\\n        for(int i=1;i<len;i++){\\n            leftBalls[i]+=(leftBalls[i-1]+arr[i-1]);\\n            leftShifts[i]=(arr[i-1]+leftBalls[i-1]+leftShifts[i-1]);\\n        }\\n        for(int i=len-2;i>=0;i--){\\n            rightBalls[i]+=(rightBalls[i+1]+arr[i+1]);\\n            rightShifts[i]=(arr[i+1]+rightBalls[i+1]+rightShifts[i+1]);\\n        }\\n        int[] ans=new int[len];\\n        for(int i=1;i< len-1;i++){\\n            ans[i]=leftShifts[i]+rightShifts[i];\\n        }\\n        ans[0]=rightShifts[0];\\n        ans[len-1]=leftShifts[len-1];\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int[] minOperations(String boxes) {\\n        int len=boxes.length();\\n        int[] arr=new int[len];\\n        int j=0;\\n        for(char ch:boxes.toCharArray()){\\n            if(ch==\\'1\\'){\\n                arr[j++]=1;\\n            }else{\\n                arr[j++]=0;\\n            }\\n        }\\n        int[] leftBalls=new int[len];\\n        int[] rightBalls=new int[len];\\n        int[] leftShifts=new int[len];\\n        int[] rightShifts=new int[len];\\n        for(int i=1;i<len;i++){\\n            leftBalls[i]+=(leftBalls[i-1]+arr[i-1]);\\n            leftShifts[i]=(arr[i-1]+leftBalls[i-1]+leftShifts[i-1]);\\n        }\\n        for(int i=len-2;i>=0;i--){\\n            rightBalls[i]+=(rightBalls[i+1]+arr[i+1]);\\n            rightShifts[i]=(arr[i+1]+rightBalls[i+1]+rightShifts[i+1]);\\n        }\\n        int[] ans=new int[len];\\n        for(int i=1;i< len-1;i++){\\n            ans[i]=leftShifts[i]+rightShifts[i];\\n        }\\n        ans[0]=rightShifts[0];\\n        ans[len-1]=leftShifts[len-1];\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2398760,
                "title": "easy-c-beats-95-88-time",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        if(boxes.size()==1) return{0};\\n        int num=0, left=0, right=0;\\n        vector<int>ans;\\n        if(boxes[0]==\\'1\\') left++;\\n        for(int i=1; i<boxes.size(); i++){\\n            if(boxes[i]==\\'1\\'){\\n                right++;\\n                num+=i;\\n            }\\n        }\\n        ans.push_back(num);\\n        for(int i=1; i<boxes.size(); i++){\\n            num-=right-left;\\n            ans.push_back(num);\\n            if(boxes[i]==\\'1\\'){\\n                left+=1;\\n                right-=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        if(boxes.size()==1) return{0};\\n        int num=0, left=0, right=0;\\n        vector<int>ans;\\n        if(boxes[0]==\\'1\\') left++;\\n        for(int i=1; i<boxes.size(); i++){\\n            if(boxes[i]==\\'1\\'){\\n                right++;\\n                num+=i;\\n            }\\n        }\\n        ans.push_back(num);\\n        for(int i=1; i<boxes.size(); i++){\\n            num-=right-left;\\n            ans.push_back(num);\\n            if(boxes[i]==\\'1\\'){\\n                left+=1;\\n                right-=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2387775,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int n = boxes.length();\\n        int ans[] = new int[n];\\n        ArrayList<Integer> ones = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            if(boxes.charAt(i)==\\'1\\'){\\n                ones.add(i);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int x=0;x<ones.size();x++){\\n                ans[i]+= Math.abs(ones.get(x)-i);\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] minOperations(String boxes) {\\n        int n = boxes.length();\\n        int ans[] = new int[n];\\n        ArrayList<Integer> ones = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            if(boxes.charAt(i)==\\'1\\'){\\n                ones.add(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2372519,
                "title": "easy-cpp-solution",
                "content": "```\\n\\nvector<int> minOperations(string boxes) {\\n        vector<int>pre;\\n        vector<int>suf;\\n        vector<int>ans;\\n        int p=0; // this variable track how many balls in previous box\\n        for(int i=0;i<boxes.length();i++) \\n        {\\n            if(i==0)// at the 0th index left side there is no box so put 0\\n            {\\n                pre.push_back(0);\\n                p+=boxes[i]-\\'0\\';\\n                continue;\\n            }\\n            pre.push_back(p+pre.back()); // here you need add previous box ball + previous move\\n            p+=boxes[i]-\\'0\\';\\n        }\\n\\t\\t\\n\\t\\t//suffix sum is same prefix sum;\\n        p=0;\\n        for(int i=boxes.length()-1;i>=0;i--)\\n        {\\n            if(i==boxes.length()-1)\\n            {\\n                suf.push_back(0);\\n                p+=boxes[i]-\\'0\\';\\n                continue;\\n            }\\n            suf.push_back(p+suf.back());\\n            p+=boxes[i]-\\'0\\';\\n            \\n        }\\n        int n=suf.size();\\n        for(int i=0;i<pre.size();i++)\\n        {\\n            ans.push_back(pre[i]+suf[n-i-1]);\\n        }\\n        return ans;\\n    }\\n\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\n\\nvector<int> minOperations(string boxes) {\\n        vector<int>pre;\\n        vector<int>suf;\\n        vector<int>ans;\\n        int p=0; // this variable track how many balls in previous box\\n        for(int i=0;i<boxes.length();i++) \\n        {\\n            if(i==0)// at the 0th index left side there is no box so put 0\\n            {\\n                pre.push_back(0);\\n                p+=boxes[i]-\\'0\\';\\n                continue;\\n            }\\n            pre.push_back(p+pre.back()); // here you need add previous box ball + previous move\\n            p+=boxes[i]-\\'0\\';\\n        }\\n\\t\\t\\n\\t\\t//suffix sum is same prefix sum;\\n        p=0;\\n        for(int i=boxes.length()-1;i>=0;i--)\\n        {\\n            if(i==boxes.length()-1)\\n            {\\n                suf.push_back(0);\\n                p+=boxes[i]-\\'0\\';\\n                continue;\\n            }\\n            suf.push_back(p+suf.back());\\n            p+=boxes[i]-\\'0\\';\\n            \\n        }\\n        int n=suf.size();\\n        for(int i=0;i<pre.size();i++)\\n        {\\n            ans.push_back(pre[i]+suf[n-i-1]);\\n        }\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2342357,
                "title": "c-straightforward-easy-simple",
                "content": "![image](https://assets.leetcode.com/users/images/4584d9fa-f518-4678-bb05-e35d2b58e4b6_1658946661.552834.png)\\n\\n**n==box.size()\\nT->O(n * n) && S->O(n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> minOperations(string box) {\\n\\t\\t\\tvector<int>ans;\\n\\t\\t\\tfor(int i=0;i<box.size();i++){\\n\\t\\t\\t\\tint t=0;\\n\\t\\t\\t\\tfor(int j=0;j<box.size();j++){\\n\\t\\t\\t\\t\\tif(box[j]==\\'1\\') t+=abs(j-i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans.push_back(t);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> minOperations(string box) {\\n\\t\\t\\tvector<int>ans;\\n\\t\\t\\tfor(int i=0;i<box.size();i++){\\n\\t\\t\\t\\tint t=0;\\n\\t\\t\\t\\tfor(int j=0;j<box.size();j++){\\n\\t\\t\\t\\t\\tif(box[j]==\\'1\\') t+=abs(j-i);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2318302,
                "title": "1-ms-java",
                "content": "```\\npublic int[] minOperations(String boxes) {\\n        \\t//System.out.println();\\n            int[] result = new int[boxes.length()];\\n            int[] left = new int[boxes.length()];\\n            int[] right = new int[boxes.length()];\\n            int count = boxes.charAt(0)-\\'0\\';\\n            for(int i = 1;i<boxes.length();i++)\\n            {\\n            \\n            \\tleft[i] =left[i-1]+count;\\n            \\tcount+=boxes.charAt(i)-\\'0\\';\\n            }\\n            count = boxes.charAt(boxes.length()-1)-\\'0\\';\\n            for(int i = boxes.length()-2;i>=0;i--)\\n            {\\n            \\tright[i]  = right[i+1]+count;\\n            \\tcount+=boxes.charAt(i)-\\'0\\';\\n            }\\n            for(int i = 0;i<result.length;i++)\\n            {\\n            \\tresult[i] = left[i]+right[i];\\n            }\\n            return result;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] minOperations(String boxes) {\\n        \\t//System.out.println();\\n            int[] result = new int[boxes.length()];\\n            int[] left = new int[boxes.length()];\\n            int[] right = new int[boxes.length()];\\n            int count = boxes.charAt(0)-\\'0\\';\\n            for(int i = 1;i<boxes.length();i++)\\n            {\\n            \\n            \\tleft[i] =left[i-1]+count;\\n            \\tcount+=boxes.charAt(i)-\\'0\\';\\n            }\\n            count = boxes.charAt(boxes.length()-1)-\\'0\\';\\n            for(int i = boxes.length()-2;i>=0;i--)\\n            {\\n            \\tright[i]  = right[i+1]+count;\\n            \\tcount+=boxes.charAt(i)-\\'0\\';\\n            }\\n            for(int i = 0;i<result.length;i++)\\n            {\\n            \\tresult[i] = left[i]+right[i];\\n            }\\n            return result;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2311706,
                "title": "c-o-n",
                "content": "vector<int> minOperations(string boxes) {\\n\\t\\n\\tint n = boxes.size();\\n\\t\\n\\tstd::vector<int> left(n, 0);\\n\\tstd::vector<int> right(n, 0);\\n\\t\\n\\tint sum = boxes[0] - \\'0\\';\\n\\t\\n\\tfor(int i = 1; i < n; ++i)\\n\\t{\\n\\t\\tleft[i] = left[i - 1] + sum;\\n\\t\\tsum += boxes[i] - \\'0\\';\\n\\t}\\n\\t\\n\\tsum = boxes[n - 1] - \\'0\\';\\n\\t\\n\\tfor(int i = n - 2; i >= 0; --i)\\n\\t{\\n\\t\\tright[i] = right[i + 1] + sum;\\n\\t\\tsum += boxes[i] - \\'0\\';\\n\\t}\\n\\t\\n\\tfor(int i = 0; i < n; ++i)\\n\\t{\\n\\t\\tleft[i] += right[i];\\n\\t}\\n\\t\\n\\treturn left;\\n}",
                "solutionTags": [],
                "code": "vector<int> minOperations(string boxes) {\\n\\t\\n\\tint n = boxes.size();\\n\\t\\n\\tstd::vector<int> left(n, 0);\\n\\tstd::vector<int> right(n, 0);\\n\\t\\n\\tint sum = boxes[0] - \\'0\\';\\n\\t\\n\\tfor(int i = 1; i < n; ++i)\\n\\t{\\n\\t\\tleft[i] = left[i - 1] + sum;\\n\\t\\tsum += boxes[i] - \\'0\\';\\n\\t}\\n\\t\\n\\tsum = boxes[n - 1] - \\'0\\';\\n\\t\\n\\tfor(int i = n - 2; i >= 0; --i)\\n\\t{\\n\\t\\tright[i] = right[i + 1] + sum;\\n\\t\\tsum += boxes[i] - \\'0\\';\\n\\t}\\n\\t\\n\\tfor(int i = 0; i < n; ++i)\\n\\t{\\n\\t\\tleft[i] += right[i];\\n\\t}\\n\\t\\n\\treturn left;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2307324,
                "title": "easy-method-just-1-pass-using-abs-function",
                "content": "Note that we have atmost one ball in each box and that it is always optimal to not take any \"detours\" in between and go straight to the ```ith``` position from ```jth``` position. Therefore, it takes ```|i - j|``` steps to reach ```ith``` position from ```jth``` position. So, we can just sum this over all ```j``` satisfying ```boxes[j] == 1```. Code is as below:\\n\\n```\\nvector<int> minOperations(string boxes) {\\n        vector<int> ans(boxes.length(), 0);\\n        \\n        for(int i = 0; i < boxes.length(); i++){\\n            for(int j = 0; j < boxes.length(); j++){\\n                if(boxes[j] == \\'1\\'){\\n                    ans[i] += abs(i - j);\\n                }\\n            }\\n\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\nIf any questions or suggestions, tell me in the comments. If you liked the solution (it *is* a little different), don\\'t forget to upvote!\\n\\nThanks for reading!",
                "solutionTags": [
                    "C"
                ],
                "code": "```ith```\n```jth```\n```|i - j|```\n```ith```\n```jth```\n```j```\n```boxes[j] == 1```\n```\\nvector<int> minOperations(string boxes) {\\n        vector<int> ans(boxes.length(), 0);\\n        \\n        for(int i = 0; i < boxes.length(); i++){\\n            for(int j = 0; j < boxes.length(); j++){\\n                if(boxes[j] == \\'1\\'){\\n                    ans[i] += abs(i - j);\\n                }\\n            }\\n\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2255765,
                "title": "c-best-solution-o-n-left-step-right-step",
                "content": "```\\nLets take an example ->\\nEx. 0 0 1 0 1 1\\nNeed to count 1 and add count in each step\\nleftCount=0\\nleftStep= 0\\n\\nstep 1. for i=0\\n  leftStep = leftStep+ leftCount=0;  => 0\\n  i=1\\n leftStep = leftStep+ leftCount=0;  => 0 0\\n i=2\\n  leftStep = leftStep+ leftCount=0;  => 0 0 0\\n  leftCount++ (if we found 1 ) => 1\\n  i=3\\n  leftStep = leftStep+ leftCount=1;  => 0 0 0 1\\n    i=4\\n  leftStep = leftStep+ leftCount=2;  => 0 0 0 1 2\\n  eftCount++ (if we found 1 ) => 2\\n   i=5\\n  leftStep = leftStep+ leftCount=2;  => 0 0 0 1 2 4\\n  eftCount++ (if we found 1 ) => 3\\n  \\n  left = 0 0 0 1 2 4\\n  Similer we will calculate right to left\\n  right = 11 8 5 3 1 0\\n  \\n  ans = left + right = 11 , 8 5 4 3 4 \\n  \\n  ```\\n  \\n  \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        vector<int> left , right(boxes.size(),0);\\n        int leftDiff = 0,rightDiff=0,leftNext=0,rightNext=0,last=boxes.size()-1; \\n        \\n        for(int i=0;i<boxes.size();i++,last--){\\n            leftNext= leftNext+leftDiff;\\n            rightNext= rightNext +rightDiff;\\n            if(boxes[i]==\\'1\\'){\\n                leftDiff++;\\n            }\\n            \\n            if(boxes[last]==\\'1\\'){\\n                rightDiff++;\\n            }\\n            left.push_back(leftNext);\\n            right[last] = rightNext;\\n            \\n            if(last<=i){\\n               left[last] = left[last]+right[last];\\n                if(last!=i){\\n                    left[i] = left[i]+right[i];\\n                }\\n                \\n            }\\n           \\n        }\\n        \\n        \\n        return left;\\n    }\\n};\\n```\\n\\n\\n**All suggestions are welcome.\\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLets take an example ->\\nEx. 0 0 1 0 1 1\\nNeed to count 1 and add count in each step\\nleftCount=0\\nleftStep= 0\\n\\nstep 1. for i=0\\n  leftStep = leftStep+ leftCount=0;  => 0\\n  i=1\\n leftStep = leftStep+ leftCount=0;  => 0 0\\n i=2\\n  leftStep = leftStep+ leftCount=0;  => 0 0 0\\n  leftCount++ (if we found 1 ) => 1\\n  i=3\\n  leftStep = leftStep+ leftCount=1;  => 0 0 0 1\\n    i=4\\n  leftStep = leftStep+ leftCount=2;  => 0 0 0 1 2\\n  eftCount++ (if we found 1 ) => 2\\n   i=5\\n  leftStep = leftStep+ leftCount=2;  => 0 0 0 1 2 4\\n  eftCount++ (if we found 1 ) => 3\\n  \\n  left = 0 0 0 1 2 4\\n  Similer we will calculate right to left\\n  right = 11 8 5 3 1 0\\n  \\n  ans = left + right = 11 , 8 5 4 3 4 \\n  \\n  ```\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        vector<int> left , right(boxes.size(),0);\\n        int leftDiff = 0,rightDiff=0,leftNext=0,rightNext=0,last=boxes.size()-1; \\n        \\n        for(int i=0;i<boxes.size();i++,last--){\\n            leftNext= leftNext+leftDiff;\\n            rightNext= rightNext +rightDiff;\\n            if(boxes[i]==\\'1\\'){\\n                leftDiff++;\\n            }\\n            \\n            if(boxes[last]==\\'1\\'){\\n                rightDiff++;\\n            }\\n            left.push_back(leftNext);\\n            right[last] = rightNext;\\n            \\n            if(last<=i){\\n               left[last] = left[last]+right[last];\\n                if(last!=i){\\n                    left[i] = left[i]+right[i];\\n                }\\n                \\n            }\\n           \\n        }\\n        \\n        \\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227634,
                "title": "runtime-7-ms-faster-than-90-92-of-c-online-submissions",
                "content": "```\\nvector<int> minOperations(string boxes) {\\n        int n=boxes.length();\\n        vector<int> v(n);\\n        int ahead=0 , behind=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(boxes[i]==\\'1\\')\\n            {\\n                ahead++;\\n                v[0] += i;\\n            }\\n        }\\n        if(boxes[0]==\\'1\\')\\n        {\\n             ahead--;\\n             behind++;\\n        }\\n        for(int i=1; i<n; i++)\\n        {\\n            v[i]=v[i-1]-ahead+behind;\\n            if(boxes[i]==\\'1\\')\\n            {\\n                ahead--;\\n                behind++;\\n            }\\n        }\\n        return v;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> minOperations(string boxes) {\\n        int n=boxes.length();\\n        vector<int> v(n);\\n        int ahead=0 , behind=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(boxes[i]==\\'1\\')\\n            {\\n                ahead++;\\n                v[0] += i;\\n            }\\n        }\\n        if(boxes[0]==\\'1\\')\\n        {\\n             ahead--;\\n             behind++;\\n        }\\n        for(int i=1; i<n; i++)\\n        {\\n            v[i]=v[i-1]-ahead+behind;\\n            if(boxes[i]==\\'1\\')\\n            {\\n                ahead--;\\n                behind++;\\n            }\\n        }\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2218660,
                "title": "c-beginners-friendly-with-explanation-thought-process",
                "content": "## ***Quote of the question: \"To become successful you need not to do a lot of things but just a few things and become best at them.\"***\\n\\nThought Process: \\n\"\\nHint: \"Iterate over the string and use two pointer method\" \\n\"\\n\\nCheers!!!\\nOld Monk\\n(Purana Yogi)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        vector<int>ans;\\n        int temp;\\n        for(int i=0;i<boxes.length();i++){\\n            temp=0;\\n            for(int j=0;j<boxes.length();j++){\\n                if(boxes[j]==\\'1\\'){\\n                    temp+=abs(i-j);\\n                }\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        vector<int>ans;\\n        int temp;\\n        for(int i=0;i<boxes.length();i++){\\n            temp=0;\\n            for(int j=0;j<boxes.length();j++){\\n                if(boxes[j]==\\'1\\'){\\n                    temp+=abs(i-j);\\n                }\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2216144,
                "title": "one-liner",
                "content": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        return [sum(abs(i-j) for i in range(len(boxes)) if boxes[i]==\"1\") for j in range(len(boxes))]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        return [sum(abs(i-j) for i in range(len(boxes)) if boxes[i]==\"1\") for j in range(len(boxes))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208700,
                "title": "c-simple-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n = boxes.size();\\n        vector<int> v(n);\\n        \\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            for(int j=0;j<n;j++){\\n                if(boxes[j] == \\'1\\'){\\n                    sum += abs(j-i);\\n                }\\n            }\\n            v[i] = sum;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n = boxes.size();\\n        vector<int> v(n);\\n        \\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            for(int j=0;j<n;j++){\\n                if(boxes[j] == \\'1\\'){\\n                    sum += abs(j-i);\\n                }\\n            }\\n            v[i] = sum;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206962,
                "title": "o-n-2-dynamic-programming-solution-with-python",
                "content": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        opRight,opLeft=[0 for i in range(len(boxes))],[0 for i in range(len(boxes))]\\n        for i in range(1,len(boxes)):\\n            for j in range(i):\\n                if boxes[j]==\"1\":\\n                    opRight[i]+=i-j\\n        boxes=boxes[::-1]\\n        for i in range(1,len(boxes)):\\n            for j in range(i):\\n                if boxes[j]==\"1\":\\n                    opLeft[i]+=i-j\\n        opLeft.reverse()\\n        op=[]\\n        for i in range(len(opRight)):\\n            op.append(opRight[i]+opLeft[i])\\n        return(op)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        opRight,opLeft=[0 for i in range(len(boxes))],[0 for i in range(len(boxes))]\\n        for i in range(1,len(boxes)):\\n            for j in range(i):\\n                if boxes[j]==\"1\":\\n                    opRight[i]+=i-j\\n        boxes=boxes[::-1]\\n        for i in range(1,len(boxes)):\\n            for j in range(i):\\n                if boxes[j]==\"1\":\\n                    opLeft[i]+=i-j\\n        opLeft.reverse()\\n        op=[]\\n        for i in range(len(opRight)):\\n            op.append(opRight[i]+opLeft[i])\\n        return(op)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198048,
                "title": "o-n-from-brute-force-to-presum-solution-with-explanation-python",
                "content": "This question can be transformed into a question asking the relative location for all `1` from the current element because you can only move `1` to adjacent location. Also, please note that the box movements are independent to each other, i.e. 2 boxes in the same box cannot move together.\\nThe brute force way for this question is definitely to compute the relative position for each element.\\nFor example,\\n`[1, 0, 1, 1]` will have relative position as `[0, 0, 2, 3]`. Then, the total operation will be `sum([0, 0, 2, 3])`. However, this will have an algorithm with `O(n^2)`.\\n\\nHow can we simply it into a `O(n)`?\\nWe then need to observe the pattern for each iteration.\\nTaking an example for `[1, 0, 1, 1]`.\\nFor first iteration, we have relative position `[_, 0, 2, 3]`\\nNext round, we will have `[1, _, 1, 2]`\\nAnd next round, `[2, 0, _, 1]`\\nI indicate the current position with `_` so you can easily see the pattern.\\nWhen we iterate from `0` to `2` index, all the relative position on the right will be decremented by `1` and the left one will be incremented by `1`.\\nSo, this is the trick. We can do a presum of relative index for entire list at zero index.\\nWhen we iterate through the list, we can follow the left-increment and right-decrement rule and manipulate the presum. Then, that is exactly what we want!\\nBut how can we easily know the number we want to increment and decrement?\\nSimply a counter for left and right elements! \\n\\nEt voil\\xE0\\n```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        presum = 0\\n        count = [0, 0]\\n        for i, c in enumerate(boxes):\\n            if c == \"1\":\\n                count[1] += 1\\n                presum += i\\n    \\n        out = []\\n        for i, c in enumerate(boxes):\\n            out.append(presum)\\n            if c == \"1\":\\n                count[0] += 1\\n                count[1] -= 1\\n            presum += count[0]\\n            presum -= count[1]\\n        return out\\n\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        presum = 0\\n        count = [0, 0]\\n        for i, c in enumerate(boxes):\\n            if c == \"1\":\\n                count[1] += 1\\n                presum += i\\n    \\n        out = []\\n        for i, c in enumerate(boxes):\\n            out.append(presum)\\n            if c == \"1\":\\n                count[0] += 1\\n                count[1] -= 1\\n            presum += count[0]\\n            presum -= count[1]\\n        return out\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2112700,
                "title": "java-easy-solution-o-n-simple",
                "content": "\\n\\n    public int[] minOperations(String boxes) {\\n        int n=boxes.length();\\n        int ans[]=new int[n];\\n        int ball=0;\\n        int move=0;\\n        for(int i=0; i<n; i++){\\n            move+=ball;\\n            ball+=boxes.charAt(i)-\\'0\\';\\n            ans[i]=move;\\n        }\\n        ball=0;\\n        move=0;\\n        for(int i=n-1; i>=0; i--){\\n            move+=ball;\\n            ball+=boxes.charAt(i)-\\'0\\';\\n            ans[i]+=move;\\n        }\\n        return ans;\\n        \\n    }",
                "solutionTags": [],
                "code": "\\n\\n    public int[] minOperations(String boxes) {\\n        int n=boxes.length();\\n        int ans[]=new int[n];\\n        int ball=0;\\n        int move=0;\\n        for(int i=0; i<n; i++){\\n            move+=ball;\\n            ball+=boxes.charAt(i)-\\'0\\';\\n            ans[i]=move;\\n        }\\n        ball=0;\\n        move=0;\\n        for(int i=n-1; i>=0; i--){\\n            move+=ball;\\n            ball+=boxes.charAt(i)-\\'0\\';\\n            ans[i]+=move;\\n        }\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2103240,
                "title": "c-readable-o-n-time-and-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int totalBoxes = boxes.length();\\n        vector<int>finalDistance;\\n        int distanceToZero =0,count=0;\\n        \\n        for(int i=0;i<totalBoxes;i++){\\n            if(boxes[i]== \\'1\\'){\\n                count++;\\n                distanceToZero+= i;\\n            }\\n        }\\n        int leftOnes = 0;\\n        int leftDistance= 0;\\n        for(int i=0;i<totalBoxes;i++){\\n            leftDistance += leftOnes;\\n            if(boxes[i] == \\'1\\'){\\n                count--;\\n                leftOnes++;\\n            }\\n           \\n        finalDistance.push_back(distanceToZero+leftDistance);          \\n        distanceToZero  = distanceToZero- count;\\n    }\\nreturn finalDistance;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int totalBoxes = boxes.length();\\n        vector<int>finalDistance;\\n        int distanceToZero =0,count=0;\\n        \\n        for(int i=0;i<totalBoxes;i++){\\n            if(boxes[i]== \\'1\\'){\\n                count++;\\n                distanceToZero+= i;\\n            }\\n        }\\n        int leftOnes = 0;\\n        int leftDistance= 0;\\n        for(int i=0;i<totalBoxes;i++){\\n            leftDistance += leftOnes;\\n            if(boxes[i] == \\'1\\'){\\n                count--;\\n                leftOnes++;\\n            }\\n           \\n        finalDistance.push_back(distanceToZero+leftDistance);          \\n        distanceToZero  = distanceToZero- count;\\n    }\\nreturn finalDistance;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070239,
                "title": "java-solution-o-n",
                "content": "```java \\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int rOnes=0;\\n        int rCost=0;\\n        int lOnes=0;\\n        int lCost=0;\\n        for(int i=0;i<boxes.length();i++)\\n        {\\n            if(boxes.charAt(i)==\\'1\\')\\n            {\\n                rOnes++;\\n                rCost+=i;\\n            }\\n        }\\n        int[] res = new int[boxes.length()];\\n        for(int i=0;i<res.length;i++)\\n        {\\n            if(boxes.charAt(i)==\\'1\\')\\n            {\\n                rOnes--;\\n                lOnes++;\\n            }\\n            res[i] = rCost+lCost;\\n            rCost-=rOnes;\\n            lCost+=lOnes;\\n        }\\n        return res;\\n    }\\n}\\n\\n//Another Approach --> O(n\\xB2)\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int[] res = new int[boxes.length()];\\n        for(int i=0;i<res.length;i++)\\n        {\\n            res[i] = calc(boxes,i);\\n        }\\n        return res;\\n    }\\n    \\n    private int calc(String boxes,int j)\\n    {\\n        int sum=0;\\n        for(int i=0;i<boxes.length();i++)\\n        {\\n            if(boxes.charAt(i)==\\'1\\')\\n                sum+=Math.abs(i-j);\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] minOperations(String boxes) {\\n        int rOnes=0;\\n        int rCost=0;\\n        int lOnes=0;\\n        int lCost=0;\\n        for(int i=0;i<boxes.length();i++)\\n        {\\n            if(boxes.charAt(i)==\\'1\\')\\n            {\\n                rOnes++;\\n                rCost+=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2067048,
                "title": "c-easy-solution-begineer-friendly-easy-to-understand-simple-brute-force",
                "content": "\\n\\n    class Solution {\\n    public:\\n    vector<int> minOperations(string boxes) {\\n        vector<int>vect;\\n        int sum=0;\\n        for(int i=0;i<boxes.length();i++){\\n            for(int j=0;j<boxes.length();j++){\\n                if(boxes[j]==\\'1\\'){\\n                    sum+=abs(j-i);\\n                }\\n            }\\n            vect.emplace_back(sum);\\n            sum=0;\\n        }\\n        return vect;\\n      }\\n    };\\n\\t\\n\\t\\n***IF U FIND IT USEFUL PLEASE UPVOTE IT***",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    public:\\n    vector<int> minOperations(string boxes) {\\n        vector<int>vect;\\n        int sum=0;\\n        for(int i=0;i<boxes.length();i++){\\n            for(int j=0;j<boxes.length();j++){\\n                if(boxes[j]==\\'1\\'){\\n                    sum+=abs(j-i);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2041805,
                "title": "move-from-left-to-right-and-then-from-right-to-left",
                "content": "The idea is:\\n1. Try to move each ball from left to right.\\n2. Try to move each ball from right to left.\\n3. The answer is the sum of steps of move from left to right and from right to left.\\n\\nThe code could be more compact if we merge them into 2 loops, \\nbut I like this more for this is easier to understand the logic.\\n```cpp\\nint n = boxes.size();\\nvector<int> left(n), right(n), ret(n);\\n\\n// how many moves if we want to move all the balls at the left of index i to index i?\\nfor (int i = 1; i < n; ++i)\\n\\tleft[i] = left[i - 1] + (boxes[i - 1] == \\'1\\');\\n\\n// accumulate \\nfor (int i = 1; i < n; ++i)\\n\\tleft[i] += left[i - 1];\\n\\n\\n// from right to left\\nfor (int i = n - 2; i >= 0; --i)\\n\\tright[i] = right[i + 1] + (boxes[i + 1] == \\'1\\');\\n\\nfor (int i = n - 2; i >= 0; --i)\\n\\tright[i] += right[i + 1];\\n\\n\\n\\nfor (int i = 0; i < n; ++i)\\n\\tret[i] = left[i] + right[i];\\n\\nreturn ret;\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint n = boxes.size();\\nvector<int> left(n), right(n), ret(n);\\n\\n// how many moves if we want to move all the balls at the left of index i to index i?\\nfor (int i = 1; i < n; ++i)\\n\\tleft[i] = left[i - 1] + (boxes[i - 1] == \\'1\\');\\n\\n// accumulate \\nfor (int i = 1; i < n; ++i)\\n\\tleft[i] += left[i - 1];\\n\\n\\n// from right to left\\nfor (int i = n - 2; i >= 0; --i)\\n\\tright[i] = right[i + 1] + (boxes[i + 1] == \\'1\\');\\n\\nfor (int i = n - 2; i >= 0; --i)\\n\\tright[i] += right[i + 1];\\n\\n\\n\\nfor (int i = 0; i < n; ++i)\\n\\tret[i] = left[i] + right[i];\\n\\nreturn ret;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2030299,
                "title": "simple-python-solution-with-detailed-explanation-easy-to-understand",
                "content": "```\\n\\n```class Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        \\n        save = []\\n        save1 = []\\n        \\n        for index, value in enumerate(boxes):       # find and append the index of 1s into list save\\n            if value == \\'1\\':\\n                save.append(index)\\n\\n        \\n        for i in range(len(boxes)):     # iterate through boxes, every time set counter sums at 0, iterate through save, find the index differences between save[j] and i, append sums\\n            sums = 0\\n            for j in range(len(save)):\\n                sums += abs(save[j]-i)\\n            save1.append(sums)\\n        \\n        return save1",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1991786,
                "title": "c-brute-optimized",
                "content": "* **Brute Force**\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans ;\\n    vector<int> minOperations(string boxes) {\\n        vector<int> ballsIndices ;\\n        for(int i = 0 ; i < boxes.size() ; ++i ){\\n            if(boxes[i] == \\'1\\') ballsIndices.push_back(i) ;\\n        }\\n        for(int i = 0 ; i < boxes.size() ; ++i ){\\n            int operations = 0 ;\\n            for(auto &x : ballsIndices) operations += abs(x-i) ;\\n            ans.push_back(operations) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```\\n```\\n\\n```\\n* **Optimized**\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans ;\\n    vector<int> minOperations(string boxes) {\\n        int ones = 0 ;\\n        int temp = 0 ; \\n        for(int i = 0 ; i < boxes.size() ; ++i ){\\n            ans.push_back(temp) ;\\n            ones += boxes[i]-\\'0\\' ;\\n            temp += ones ;\\n        }\\n        ones = temp = 0 ;\\n        for(int i = boxes.size() - 1 ; i >=0 ; --i ){\\n            ans[i] += temp ;;\\n            ones += boxes[i]-\\'0\\' ;\\n            temp += ones ;\\n        }\\n        return ans ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans ;\\n    vector<int> minOperations(string boxes) {\\n        vector<int> ballsIndices ;\\n        for(int i = 0 ; i < boxes.size() ; ++i ){\\n            if(boxes[i] == \\'1\\') ballsIndices.push_back(i) ;\\n        }\\n        for(int i = 0 ; i < boxes.size() ; ++i ){\\n            int operations = 0 ;\\n            for(auto &x : ballsIndices) operations += abs(x-i) ;\\n            ans.push_back(operations) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```\n```\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> ans ;\\n    vector<int> minOperations(string boxes) {\\n        int ones = 0 ;\\n        int temp = 0 ; \\n        for(int i = 0 ; i < boxes.size() ; ++i ){\\n            ans.push_back(temp) ;\\n            ones += boxes[i]-\\'0\\' ;\\n            temp += ones ;\\n        }\\n        ones = temp = 0 ;\\n        for(int i = boxes.size() - 1 ; i >=0 ; --i ){\\n            ans[i] += temp ;;\\n            ones += boxes[i]-\\'0\\' ;\\n            temp += ones ;\\n        }\\n        return ans ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959439,
                "title": "javascript-iterative-o-n-time-o-1-space-95-time-89-space",
                "content": "```\\nvar minOperations = function(boxes) {\\n    let output = [];\\n    // Left to right\\n    let oneCount = 0, total = 0;\\n    for (let l = 0; l < boxes.length; l++) {\\n        output[l] = total;\\n        if (boxes[l] === \\'1\\') oneCount++;\\n        total += oneCount;\\n    }\\n    // Right to left\\n    oneCount = 0, total = 0;\\n    for (let r = boxes.length - 1; r >= 0; r--) {\\n        output[r] += total;\\n        if (boxes[r] === \\'1\\') oneCount++;\\n        total += oneCount;\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minOperations = function(boxes) {\\n    let output = [];\\n    // Left to right\\n    let oneCount = 0, total = 0;\\n    for (let l = 0; l < boxes.length; l++) {\\n        output[l] = total;\\n        if (boxes[l] === \\'1\\') oneCount++;\\n        total += oneCount;\\n    }\\n    // Right to left\\n    oneCount = 0, total = 0;\\n    for (let r = boxes.length - 1; r >= 0; r--) {\\n        output[r] += total;\\n        if (boxes[r] === \\'1\\') oneCount++;\\n        total += oneCount;\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1938561,
                "title": "java-solution-very-easy",
                "content": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int arr[]=new int[boxes.length()];\\n        for(int i=0;i<boxes.length();i++){\\n            int sum=0;\\n            for(int j=0;j<boxes.length();j++){\\n                if(boxes.charAt(j)==\\'1\\'){\\n                    sum=sum+Math.abs(j-i);\\n                }\\n            }\\n            arr[i]=sum;\\n        }\\n        return arr;\\n    }\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int arr[]=new int[boxes.length()];\\n        for(int i=0;i<boxes.length();i++){\\n            int sum=0;\\n            for(int j=0;j<boxes.length();j++){\\n                if(boxes.charAt(j)==\\'1\\'){\\n                    sum=sum+Math.abs(j-i);\\n                }\\n            }\\n            arr[i]=sum;\\n        }\\n        return arr;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1930809,
                "title": "easy-to-understand-code-python-o-n-90-on-time-and-space",
                "content": "Hello, \\n\\nSo I saw other people had this same idea but I didn\\'t see code that\\'s as easy to understand as mine. I didn\\'t say *shortest*, I said **easiest**. Let\\'s get to it.\\n\\n### Idea\\nSo the whole idea here is something like this:\\n\\n- Let\\'s say we have 3 \"1\"s to the right of the index we\\'re calculating\\n- Just to make it easy let\\'s say they\\'re infinite units away. \\n[ ___ , ....an infinity later.., 1, 1, 1]\\n- Therefore our count for this index would be: 3 * infinite, cause for each \"1\" they have to move infinite units. \\nLooks like this [3 * infinite]\\n- Now this is the important part: What happens when we calculate for index +1? Each \"1\" would have to move one unit less. If we have 3 * \"1\"s that\\'s a total of three units less.\\n- Thus we now have [3 * infinite, 3 * infinite - 3] \\n\\nAnd that\\'s basically the whole idea, where each index is just the count of the previous index minus all the \"1\"s to the right of the previous index.\\n\\nNow of course the weirdest thing you have to consider here is what happens when you \"cross over\" a \"1\". In my example the \"1\"s were really far away, but what happens when you hit one of the \"1\"s?\\n- When we got *onto* the \"1\" nothing different actually happens. You still subtract the same amount since the \"1\" that you\\'re now on does also have to move one less, just like the case for if it was infinite units away. \\n- When we step off the \"1\", it moves to the left and number of units the \"1\" has to move starts to increase again. But that\\'s another good point. As we iterate left to right, we get closer to the \"1\"s on the right (thus we subtract) and we get further from the \"1\"s to the left (thus we add). Now we just have to keep track of the \"1\"s to the right and the left, and also get the initial count of movements at the beginning and we\\'re all good.\\n---\\nThere\\'s alot of ways to implement what I said above. \\n\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        icount = 0\\n        right = 0\\n        for i,s in enumerate(boxes):\\n            if s ==\"1\":\\n                right+=1 #get number of balls, since we start calculating at index=0 technically all \"1\"s are to the right\\n                icount+=i #at index=0 a \"1\" at index=1 is 1 away, same for 2,3,etc.\\n        left = 0\\n        index = 0\\n        output = [0]*len(boxes)\\n\\t\\t\\n\\t\\t# finished setup now start parsing\\n        while index < len(boxes):\\n            output[index] = icount \\n\\t\\t\\t\\n            if boxes[index]==\"1\": #we have to update right/left counts cause we just \"crossed\" a 1\\n                left+=1\\n                right-=1\\n\\t\\t\\t\\t\\n\\t\\t\\tindex+=1              # iterating index\\n            icount -= right       # updating icount for next index, like we said each balls to the right now have to move one unit less, \\n            icount += left\\n           \\n        return output\\n```\\n\\nThat\\'s all. Everyone else\\'s looks way more complicated than this so maybe mine was easier to read and understand, anyways good luck grinding.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, boxes: str) -> List[int]:\\n        icount = 0\\n        right = 0\\n        for i,s in enumerate(boxes):\\n            if s ==\"1\":\\n                right+=1 #get number of balls, since we start calculating at index=0 technically all \"1\"s are to the right\\n                icount+=i #at index=0 a \"1\" at index=1 is 1 away, same for 2,3,etc.\\n        left = 0\\n        index = 0\\n        output = [0]*len(boxes)\\n\\t\\t\\n\\t\\t# finished setup now start parsing\\n        while index < len(boxes):\\n            output[index] = icount \\n\\t\\t\\t\\n            if boxes[index]==\"1\": #we have to update right/left counts cause we just \"crossed\" a 1\\n                left+=1\\n                right-=1\\n\\t\\t\\t\\t\\n\\t\\t\\tindex+=1              # iterating index\\n            icount -= right       # updating icount for next index, like we said each balls to the right now have to move one unit less, \\n            icount += left\\n           \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915691,
                "title": "simple-solution-in-java-o-n-space-and-o-n-time",
                "content": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int numBoxes = boxes.length();\\n        int[] preSum = new int[numBoxes];\\n        \\n        int count = 0;\\n        for(int i=0; i<numBoxes; i++){\\n            preSum[i] = ( i-1 >= 0 ? preSum[i-1] : 0 ) + count;\\n            count += boxes.charAt(i) == \\'1\\' ? 1 : 0;\\n        }\\n        \\n        int[] ans = new int[numBoxes];\\n        count = 0;\\n        int right = 0;\\n        for(int i=numBoxes-1; i>=0; i--){\\n            right += count;\\n            ans[i] = preSum[i] + right;\\n            \\n            count += boxes.charAt(i) == \\'1\\' ? 1 : 0;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int numBoxes = boxes.length();\\n        int[] preSum = new int[numBoxes];\\n        \\n        int count = 0;\\n        for(int i=0; i<numBoxes; i++){\\n            preSum[i] = ( i-1 >= 0 ? preSum[i-1] : 0 ) + count;\\n            count += boxes.charAt(i) == \\'1\\' ? 1 : 0;\\n        }\\n        \\n        int[] ans = new int[numBoxes];\\n        count = 0;\\n        int right = 0;\\n        for(int i=numBoxes-1; i>=0; i--){\\n            right += count;\\n            ans[i] = preSum[i] + right;\\n            \\n            count += boxes.charAt(i) == \\'1\\' ? 1 : 0;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913001,
                "title": "java-dp",
                "content": "This is a dp solution.\\nif dp[i] is the opterations to move all balls into box[i], then dp[i+1]=dp[i]+(balls on the left)-(balls one the right)\\nReason: all the balls on the left side of box[i] must move one more step to the next box, and all the balls one the right side of box[i] can move one less step.\\n\\n```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int ballsOnLeft[]=new int[boxes.length()];\\n        int res[]=new int[ballsOnLeft.length];\\n        int total=0;\\n        for(int i=0;i<boxes.length();i++){\\n            if(boxes.charAt(i)==\\'1\\'){\\n                total++;\\n                res[0]+=i-0;\\n            }\\n            ballsOnLeft[i]=total;\\n        }\\n        for(int i=1;i<res.length;i++){\\n            res[i]=res[i-1]+ballsOnLeft[i-1]-(total-ballsOnLeft[i-1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int ballsOnLeft[]=new int[boxes.length()];\\n        int res[]=new int[ballsOnLeft.length];\\n        int total=0;\\n        for(int i=0;i<boxes.length();i++){\\n            if(boxes.charAt(i)==\\'1\\'){\\n                total++;\\n                res[0]+=i-0;\\n            }\\n            ballsOnLeft[i]=total;\\n        }\\n        for(int i=1;i<res.length;i++){\\n            res[i]=res[i-1]+ballsOnLeft[i-1]-(total-ballsOnLeft[i-1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874907,
                "title": "c-simple-code-0-ms-beats-100-of-cpp-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n = boxes.size();\\n        vector<int> ans(n);\\n        int behind = 0;\\n        int ahead = 0;\\n        for(int i=0; i<n; i++){\\n            if(boxes[i] == \\'1\\'){\\n                ahead++;\\n                ans[0] += i;\\n            }\\n        }\\n        \\n        if(boxes[0] == \\'1\\'){\\n            ahead--;\\n            behind++;\\n        }\\n        \\n        for(int i=1; i<boxes.size(); i++){\\n            ans[i] += ans[i-1] - ahead + behind;\\n            if(boxes[i] == \\'1\\'){\\n                ahead--;\\n                behind++;\\n            }\\n        }\\n            \\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minOperations(string boxes) {\\n        int n = boxes.size();\\n        vector<int> ans(n);\\n        int behind = 0;\\n        int ahead = 0;\\n        for(int i=0; i<n; i++){\\n            if(boxes[i] == \\'1\\'){\\n                ahead++;\\n                ans[0] += i;\\n            }\\n        }\\n        \\n        if(boxes[0] == \\'1\\'){\\n            ahead--;\\n            behind++;\\n        }\\n        \\n        for(int i=1; i<boxes.size(); i++){\\n            ans[i] += ans[i-1] - ahead + behind;\\n            if(boxes[i] == \\'1\\'){\\n                ahead--;\\n                behind++;\\n            }\\n        }\\n            \\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1636896,
                "content": [
                    {
                        "username": "karna001",
                        "content": "here O(N^2) is very simple, but try to do with O(N) also, ig then it will be medium."
                    },
                    {
                        "username": "ajinkode",
                        "content": "The O(N) solution is really tough to come up with. Beautiful question!"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "use prefix count of ones and previous answer"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "i found the O(N^2) solution easily but i couldnt figure out the O(N).\\n\\nCould anyone who found the O(n) solution guide me on what sort of problems/patterns i should practice to be better at figuring out optimal solutions after finding brute force"
                    },
                    {
                        "username": "xaocccc",
                        "content": "O(n\\xB2) doesn\\'t work for this problem. Shame."
                    },
                    {
                        "username": "Harsh404_",
                        "content": "My all test cases (95/95) are passed, still it is saying time limit exceeded. time complexity of my code is O(n^2) "
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips:\\n1. track from left: How much of shifts you need to calculate all ones from the given index.\\n2. do the same from right.\\n3. return the sum of both tracks"
                    },
                    {
                        "username": "pktk001",
                        "content": "O(N) approach.\n1. Store the sum of indices which contains ones and also their frequency.\n2. While looping the string if we encounter a '0'\nthen , answer would be:- (sum - frequency*current-index).\n3. Sum is subtracted because current-index increases in each iteration (For each '1' right to current character we need to decrease the sum by 1).\n4. Above would give correct result till a position where every '1' is present in right of that element.\n5. For correct result use the same idea and use 2 counters:- (1) Frequency of '1' in left of current-index, (2) Sum of indices of '1' in left of current-index. \n\n\n"
                    },
                    {
                        "username": "sohail_akthar",
                        "content": "[@jayamrutkar](/jayamrutkar) count\\n\\n10011 \\nFrequency of ones is 3, and zeros is 2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "What it mean by frequency here?"
                    },
                    {
                        "username": "user3107Wk",
                        "content": "Anybody came up with O(n) solution ??"
                    },
                    {
                        "username": "gygshwr_x",
                        "content": "O(N^2) approach: \\n\\nTry creating a bin of values which saves the index that has the ball\\nThe time taken will be the distance between the current value and the values which has the boxes\\n"
                    }
                ]
            },
            {
                "id": 1725529,
                "content": [
                    {
                        "username": "karna001",
                        "content": "here O(N^2) is very simple, but try to do with O(N) also, ig then it will be medium."
                    },
                    {
                        "username": "ajinkode",
                        "content": "The O(N) solution is really tough to come up with. Beautiful question!"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "use prefix count of ones and previous answer"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "i found the O(N^2) solution easily but i couldnt figure out the O(N).\\n\\nCould anyone who found the O(n) solution guide me on what sort of problems/patterns i should practice to be better at figuring out optimal solutions after finding brute force"
                    },
                    {
                        "username": "xaocccc",
                        "content": "O(n\\xB2) doesn\\'t work for this problem. Shame."
                    },
                    {
                        "username": "Harsh404_",
                        "content": "My all test cases (95/95) are passed, still it is saying time limit exceeded. time complexity of my code is O(n^2) "
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips:\\n1. track from left: How much of shifts you need to calculate all ones from the given index.\\n2. do the same from right.\\n3. return the sum of both tracks"
                    },
                    {
                        "username": "pktk001",
                        "content": "O(N) approach.\n1. Store the sum of indices which contains ones and also their frequency.\n2. While looping the string if we encounter a '0'\nthen , answer would be:- (sum - frequency*current-index).\n3. Sum is subtracted because current-index increases in each iteration (For each '1' right to current character we need to decrease the sum by 1).\n4. Above would give correct result till a position where every '1' is present in right of that element.\n5. For correct result use the same idea and use 2 counters:- (1) Frequency of '1' in left of current-index, (2) Sum of indices of '1' in left of current-index. \n\n\n"
                    },
                    {
                        "username": "sohail_akthar",
                        "content": "[@jayamrutkar](/jayamrutkar) count\\n\\n10011 \\nFrequency of ones is 3, and zeros is 2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "What it mean by frequency here?"
                    },
                    {
                        "username": "user3107Wk",
                        "content": "Anybody came up with O(n) solution ??"
                    },
                    {
                        "username": "gygshwr_x",
                        "content": "O(N^2) approach: \\n\\nTry creating a bin of values which saves the index that has the ball\\nThe time taken will be the distance between the current value and the values which has the boxes\\n"
                    }
                ]
            },
            {
                "id": 1769481,
                "content": [
                    {
                        "username": "karna001",
                        "content": "here O(N^2) is very simple, but try to do with O(N) also, ig then it will be medium."
                    },
                    {
                        "username": "ajinkode",
                        "content": "The O(N) solution is really tough to come up with. Beautiful question!"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "use prefix count of ones and previous answer"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "i found the O(N^2) solution easily but i couldnt figure out the O(N).\\n\\nCould anyone who found the O(n) solution guide me on what sort of problems/patterns i should practice to be better at figuring out optimal solutions after finding brute force"
                    },
                    {
                        "username": "xaocccc",
                        "content": "O(n\\xB2) doesn\\'t work for this problem. Shame."
                    },
                    {
                        "username": "Harsh404_",
                        "content": "My all test cases (95/95) are passed, still it is saying time limit exceeded. time complexity of my code is O(n^2) "
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips:\\n1. track from left: How much of shifts you need to calculate all ones from the given index.\\n2. do the same from right.\\n3. return the sum of both tracks"
                    },
                    {
                        "username": "pktk001",
                        "content": "O(N) approach.\n1. Store the sum of indices which contains ones and also their frequency.\n2. While looping the string if we encounter a '0'\nthen , answer would be:- (sum - frequency*current-index).\n3. Sum is subtracted because current-index increases in each iteration (For each '1' right to current character we need to decrease the sum by 1).\n4. Above would give correct result till a position where every '1' is present in right of that element.\n5. For correct result use the same idea and use 2 counters:- (1) Frequency of '1' in left of current-index, (2) Sum of indices of '1' in left of current-index. \n\n\n"
                    },
                    {
                        "username": "sohail_akthar",
                        "content": "[@jayamrutkar](/jayamrutkar) count\\n\\n10011 \\nFrequency of ones is 3, and zeros is 2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "What it mean by frequency here?"
                    },
                    {
                        "username": "user3107Wk",
                        "content": "Anybody came up with O(n) solution ??"
                    },
                    {
                        "username": "gygshwr_x",
                        "content": "O(N^2) approach: \\n\\nTry creating a bin of values which saves the index that has the ball\\nThe time taken will be the distance between the current value and the values which has the boxes\\n"
                    }
                ]
            },
            {
                "id": 1900339,
                "content": [
                    {
                        "username": "karna001",
                        "content": "here O(N^2) is very simple, but try to do with O(N) also, ig then it will be medium."
                    },
                    {
                        "username": "ajinkode",
                        "content": "The O(N) solution is really tough to come up with. Beautiful question!"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "use prefix count of ones and previous answer"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "i found the O(N^2) solution easily but i couldnt figure out the O(N).\\n\\nCould anyone who found the O(n) solution guide me on what sort of problems/patterns i should practice to be better at figuring out optimal solutions after finding brute force"
                    },
                    {
                        "username": "xaocccc",
                        "content": "O(n\\xB2) doesn\\'t work for this problem. Shame."
                    },
                    {
                        "username": "Harsh404_",
                        "content": "My all test cases (95/95) are passed, still it is saying time limit exceeded. time complexity of my code is O(n^2) "
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips:\\n1. track from left: How much of shifts you need to calculate all ones from the given index.\\n2. do the same from right.\\n3. return the sum of both tracks"
                    },
                    {
                        "username": "pktk001",
                        "content": "O(N) approach.\n1. Store the sum of indices which contains ones and also their frequency.\n2. While looping the string if we encounter a '0'\nthen , answer would be:- (sum - frequency*current-index).\n3. Sum is subtracted because current-index increases in each iteration (For each '1' right to current character we need to decrease the sum by 1).\n4. Above would give correct result till a position where every '1' is present in right of that element.\n5. For correct result use the same idea and use 2 counters:- (1) Frequency of '1' in left of current-index, (2) Sum of indices of '1' in left of current-index. \n\n\n"
                    },
                    {
                        "username": "sohail_akthar",
                        "content": "[@jayamrutkar](/jayamrutkar) count\\n\\n10011 \\nFrequency of ones is 3, and zeros is 2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "What it mean by frequency here?"
                    },
                    {
                        "username": "user3107Wk",
                        "content": "Anybody came up with O(n) solution ??"
                    },
                    {
                        "username": "gygshwr_x",
                        "content": "O(N^2) approach: \\n\\nTry creating a bin of values which saves the index that has the ball\\nThe time taken will be the distance between the current value and the values which has the boxes\\n"
                    }
                ]
            },
            {
                "id": 1883270,
                "content": [
                    {
                        "username": "karna001",
                        "content": "here O(N^2) is very simple, but try to do with O(N) also, ig then it will be medium."
                    },
                    {
                        "username": "ajinkode",
                        "content": "The O(N) solution is really tough to come up with. Beautiful question!"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "use prefix count of ones and previous answer"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "i found the O(N^2) solution easily but i couldnt figure out the O(N).\\n\\nCould anyone who found the O(n) solution guide me on what sort of problems/patterns i should practice to be better at figuring out optimal solutions after finding brute force"
                    },
                    {
                        "username": "xaocccc",
                        "content": "O(n\\xB2) doesn\\'t work for this problem. Shame."
                    },
                    {
                        "username": "Harsh404_",
                        "content": "My all test cases (95/95) are passed, still it is saying time limit exceeded. time complexity of my code is O(n^2) "
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips:\\n1. track from left: How much of shifts you need to calculate all ones from the given index.\\n2. do the same from right.\\n3. return the sum of both tracks"
                    },
                    {
                        "username": "pktk001",
                        "content": "O(N) approach.\n1. Store the sum of indices which contains ones and also their frequency.\n2. While looping the string if we encounter a '0'\nthen , answer would be:- (sum - frequency*current-index).\n3. Sum is subtracted because current-index increases in each iteration (For each '1' right to current character we need to decrease the sum by 1).\n4. Above would give correct result till a position where every '1' is present in right of that element.\n5. For correct result use the same idea and use 2 counters:- (1) Frequency of '1' in left of current-index, (2) Sum of indices of '1' in left of current-index. \n\n\n"
                    },
                    {
                        "username": "sohail_akthar",
                        "content": "[@jayamrutkar](/jayamrutkar) count\\n\\n10011 \\nFrequency of ones is 3, and zeros is 2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "What it mean by frequency here?"
                    },
                    {
                        "username": "user3107Wk",
                        "content": "Anybody came up with O(n) solution ??"
                    },
                    {
                        "username": "gygshwr_x",
                        "content": "O(N^2) approach: \\n\\nTry creating a bin of values which saves the index that has the ball\\nThe time taken will be the distance between the current value and the values which has the boxes\\n"
                    }
                ]
            },
            {
                "id": 1955970,
                "content": [
                    {
                        "username": "karna001",
                        "content": "here O(N^2) is very simple, but try to do with O(N) also, ig then it will be medium."
                    },
                    {
                        "username": "ajinkode",
                        "content": "The O(N) solution is really tough to come up with. Beautiful question!"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "use prefix count of ones and previous answer"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "i found the O(N^2) solution easily but i couldnt figure out the O(N).\\n\\nCould anyone who found the O(n) solution guide me on what sort of problems/patterns i should practice to be better at figuring out optimal solutions after finding brute force"
                    },
                    {
                        "username": "xaocccc",
                        "content": "O(n\\xB2) doesn\\'t work for this problem. Shame."
                    },
                    {
                        "username": "Harsh404_",
                        "content": "My all test cases (95/95) are passed, still it is saying time limit exceeded. time complexity of my code is O(n^2) "
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips:\\n1. track from left: How much of shifts you need to calculate all ones from the given index.\\n2. do the same from right.\\n3. return the sum of both tracks"
                    },
                    {
                        "username": "pktk001",
                        "content": "O(N) approach.\n1. Store the sum of indices which contains ones and also their frequency.\n2. While looping the string if we encounter a '0'\nthen , answer would be:- (sum - frequency*current-index).\n3. Sum is subtracted because current-index increases in each iteration (For each '1' right to current character we need to decrease the sum by 1).\n4. Above would give correct result till a position where every '1' is present in right of that element.\n5. For correct result use the same idea and use 2 counters:- (1) Frequency of '1' in left of current-index, (2) Sum of indices of '1' in left of current-index. \n\n\n"
                    },
                    {
                        "username": "sohail_akthar",
                        "content": "[@jayamrutkar](/jayamrutkar) count\\n\\n10011 \\nFrequency of ones is 3, and zeros is 2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "What it mean by frequency here?"
                    },
                    {
                        "username": "user3107Wk",
                        "content": "Anybody came up with O(n) solution ??"
                    },
                    {
                        "username": "gygshwr_x",
                        "content": "O(N^2) approach: \\n\\nTry creating a bin of values which saves the index that has the ball\\nThe time taken will be the distance between the current value and the values which has the boxes\\n"
                    }
                ]
            },
            {
                "id": 1786619,
                "content": [
                    {
                        "username": "karna001",
                        "content": "here O(N^2) is very simple, but try to do with O(N) also, ig then it will be medium."
                    },
                    {
                        "username": "ajinkode",
                        "content": "The O(N) solution is really tough to come up with. Beautiful question!"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "use prefix count of ones and previous answer"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "i found the O(N^2) solution easily but i couldnt figure out the O(N).\\n\\nCould anyone who found the O(n) solution guide me on what sort of problems/patterns i should practice to be better at figuring out optimal solutions after finding brute force"
                    },
                    {
                        "username": "xaocccc",
                        "content": "O(n\\xB2) doesn\\'t work for this problem. Shame."
                    },
                    {
                        "username": "Harsh404_",
                        "content": "My all test cases (95/95) are passed, still it is saying time limit exceeded. time complexity of my code is O(n^2) "
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips:\\n1. track from left: How much of shifts you need to calculate all ones from the given index.\\n2. do the same from right.\\n3. return the sum of both tracks"
                    },
                    {
                        "username": "pktk001",
                        "content": "O(N) approach.\n1. Store the sum of indices which contains ones and also their frequency.\n2. While looping the string if we encounter a '0'\nthen , answer would be:- (sum - frequency*current-index).\n3. Sum is subtracted because current-index increases in each iteration (For each '1' right to current character we need to decrease the sum by 1).\n4. Above would give correct result till a position where every '1' is present in right of that element.\n5. For correct result use the same idea and use 2 counters:- (1) Frequency of '1' in left of current-index, (2) Sum of indices of '1' in left of current-index. \n\n\n"
                    },
                    {
                        "username": "sohail_akthar",
                        "content": "[@jayamrutkar](/jayamrutkar) count\\n\\n10011 \\nFrequency of ones is 3, and zeros is 2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "What it mean by frequency here?"
                    },
                    {
                        "username": "user3107Wk",
                        "content": "Anybody came up with O(n) solution ??"
                    },
                    {
                        "username": "gygshwr_x",
                        "content": "O(N^2) approach: \\n\\nTry creating a bin of values which saves the index that has the ball\\nThe time taken will be the distance between the current value and the values which has the boxes\\n"
                    }
                ]
            },
            {
                "id": 1758839,
                "content": [
                    {
                        "username": "karna001",
                        "content": "here O(N^2) is very simple, but try to do with O(N) also, ig then it will be medium."
                    },
                    {
                        "username": "ajinkode",
                        "content": "The O(N) solution is really tough to come up with. Beautiful question!"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "use prefix count of ones and previous answer"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "i found the O(N^2) solution easily but i couldnt figure out the O(N).\\n\\nCould anyone who found the O(n) solution guide me on what sort of problems/patterns i should practice to be better at figuring out optimal solutions after finding brute force"
                    },
                    {
                        "username": "xaocccc",
                        "content": "O(n\\xB2) doesn\\'t work for this problem. Shame."
                    },
                    {
                        "username": "Harsh404_",
                        "content": "My all test cases (95/95) are passed, still it is saying time limit exceeded. time complexity of my code is O(n^2) "
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips:\\n1. track from left: How much of shifts you need to calculate all ones from the given index.\\n2. do the same from right.\\n3. return the sum of both tracks"
                    },
                    {
                        "username": "pktk001",
                        "content": "O(N) approach.\n1. Store the sum of indices which contains ones and also their frequency.\n2. While looping the string if we encounter a '0'\nthen , answer would be:- (sum - frequency*current-index).\n3. Sum is subtracted because current-index increases in each iteration (For each '1' right to current character we need to decrease the sum by 1).\n4. Above would give correct result till a position where every '1' is present in right of that element.\n5. For correct result use the same idea and use 2 counters:- (1) Frequency of '1' in left of current-index, (2) Sum of indices of '1' in left of current-index. \n\n\n"
                    },
                    {
                        "username": "sohail_akthar",
                        "content": "[@jayamrutkar](/jayamrutkar) count\\n\\n10011 \\nFrequency of ones is 3, and zeros is 2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "What it mean by frequency here?"
                    },
                    {
                        "username": "user3107Wk",
                        "content": "Anybody came up with O(n) solution ??"
                    },
                    {
                        "username": "gygshwr_x",
                        "content": "O(N^2) approach: \\n\\nTry creating a bin of values which saves the index that has the ball\\nThe time taken will be the distance between the current value and the values which has the boxes\\n"
                    }
                ]
            },
            {
                "id": 1726428,
                "content": [
                    {
                        "username": "karna001",
                        "content": "here O(N^2) is very simple, but try to do with O(N) also, ig then it will be medium."
                    },
                    {
                        "username": "ajinkode",
                        "content": "The O(N) solution is really tough to come up with. Beautiful question!"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "use prefix count of ones and previous answer"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "i found the O(N^2) solution easily but i couldnt figure out the O(N).\\n\\nCould anyone who found the O(n) solution guide me on what sort of problems/patterns i should practice to be better at figuring out optimal solutions after finding brute force"
                    },
                    {
                        "username": "xaocccc",
                        "content": "O(n\\xB2) doesn\\'t work for this problem. Shame."
                    },
                    {
                        "username": "Harsh404_",
                        "content": "My all test cases (95/95) are passed, still it is saying time limit exceeded. time complexity of my code is O(n^2) "
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips:\\n1. track from left: How much of shifts you need to calculate all ones from the given index.\\n2. do the same from right.\\n3. return the sum of both tracks"
                    },
                    {
                        "username": "pktk001",
                        "content": "O(N) approach.\n1. Store the sum of indices which contains ones and also their frequency.\n2. While looping the string if we encounter a '0'\nthen , answer would be:- (sum - frequency*current-index).\n3. Sum is subtracted because current-index increases in each iteration (For each '1' right to current character we need to decrease the sum by 1).\n4. Above would give correct result till a position where every '1' is present in right of that element.\n5. For correct result use the same idea and use 2 counters:- (1) Frequency of '1' in left of current-index, (2) Sum of indices of '1' in left of current-index. \n\n\n"
                    },
                    {
                        "username": "sohail_akthar",
                        "content": "[@jayamrutkar](/jayamrutkar) count\\n\\n10011 \\nFrequency of ones is 3, and zeros is 2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "What it mean by frequency here?"
                    },
                    {
                        "username": "user3107Wk",
                        "content": "Anybody came up with O(n) solution ??"
                    },
                    {
                        "username": "gygshwr_x",
                        "content": "O(N^2) approach: \\n\\nTry creating a bin of values which saves the index that has the ball\\nThe time taken will be the distance between the current value and the values which has the boxes\\n"
                    }
                ]
            },
            {
                "id": 1721238,
                "content": [
                    {
                        "username": "karna001",
                        "content": "here O(N^2) is very simple, but try to do with O(N) also, ig then it will be medium."
                    },
                    {
                        "username": "ajinkode",
                        "content": "The O(N) solution is really tough to come up with. Beautiful question!"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "use prefix count of ones and previous answer"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "i found the O(N^2) solution easily but i couldnt figure out the O(N).\\n\\nCould anyone who found the O(n) solution guide me on what sort of problems/patterns i should practice to be better at figuring out optimal solutions after finding brute force"
                    },
                    {
                        "username": "xaocccc",
                        "content": "O(n\\xB2) doesn\\'t work for this problem. Shame."
                    },
                    {
                        "username": "Harsh404_",
                        "content": "My all test cases (95/95) are passed, still it is saying time limit exceeded. time complexity of my code is O(n^2) "
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips:\\n1. track from left: How much of shifts you need to calculate all ones from the given index.\\n2. do the same from right.\\n3. return the sum of both tracks"
                    },
                    {
                        "username": "pktk001",
                        "content": "O(N) approach.\n1. Store the sum of indices which contains ones and also their frequency.\n2. While looping the string if we encounter a '0'\nthen , answer would be:- (sum - frequency*current-index).\n3. Sum is subtracted because current-index increases in each iteration (For each '1' right to current character we need to decrease the sum by 1).\n4. Above would give correct result till a position where every '1' is present in right of that element.\n5. For correct result use the same idea and use 2 counters:- (1) Frequency of '1' in left of current-index, (2) Sum of indices of '1' in left of current-index. \n\n\n"
                    },
                    {
                        "username": "sohail_akthar",
                        "content": "[@jayamrutkar](/jayamrutkar) count\\n\\n10011 \\nFrequency of ones is 3, and zeros is 2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "What it mean by frequency here?"
                    },
                    {
                        "username": "user3107Wk",
                        "content": "Anybody came up with O(n) solution ??"
                    },
                    {
                        "username": "gygshwr_x",
                        "content": "O(N^2) approach: \\n\\nTry creating a bin of values which saves the index that has the ball\\nThe time taken will be the distance between the current value and the values which has the boxes\\n"
                    }
                ]
            },
            {
                "id": 1636896,
                "content": [
                    {
                        "username": "karna001",
                        "content": "here O(N^2) is very simple, but try to do with O(N) also, ig then it will be medium."
                    },
                    {
                        "username": "ajinkode",
                        "content": "The O(N) solution is really tough to come up with. Beautiful question!"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "use prefix count of ones and previous answer"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "i found the O(N^2) solution easily but i couldnt figure out the O(N).\\n\\nCould anyone who found the O(n) solution guide me on what sort of problems/patterns i should practice to be better at figuring out optimal solutions after finding brute force"
                    },
                    {
                        "username": "xaocccc",
                        "content": "O(n\\xB2) doesn\\'t work for this problem. Shame."
                    },
                    {
                        "username": "Harsh404_",
                        "content": "My all test cases (95/95) are passed, still it is saying time limit exceeded. time complexity of my code is O(n^2) "
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips:\\n1. track from left: How much of shifts you need to calculate all ones from the given index.\\n2. do the same from right.\\n3. return the sum of both tracks"
                    },
                    {
                        "username": "pktk001",
                        "content": "O(N) approach.\n1. Store the sum of indices which contains ones and also their frequency.\n2. While looping the string if we encounter a '0'\nthen , answer would be:- (sum - frequency*current-index).\n3. Sum is subtracted because current-index increases in each iteration (For each '1' right to current character we need to decrease the sum by 1).\n4. Above would give correct result till a position where every '1' is present in right of that element.\n5. For correct result use the same idea and use 2 counters:- (1) Frequency of '1' in left of current-index, (2) Sum of indices of '1' in left of current-index. \n\n\n"
                    },
                    {
                        "username": "sohail_akthar",
                        "content": "[@jayamrutkar](/jayamrutkar) count\\n\\n10011 \\nFrequency of ones is 3, and zeros is 2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "What it mean by frequency here?"
                    },
                    {
                        "username": "user3107Wk",
                        "content": "Anybody came up with O(n) solution ??"
                    },
                    {
                        "username": "gygshwr_x",
                        "content": "O(N^2) approach: \\n\\nTry creating a bin of values which saves the index that has the ball\\nThe time taken will be the distance between the current value and the values which has the boxes\\n"
                    }
                ]
            },
            {
                "id": 1725529,
                "content": [
                    {
                        "username": "karna001",
                        "content": "here O(N^2) is very simple, but try to do with O(N) also, ig then it will be medium."
                    },
                    {
                        "username": "ajinkode",
                        "content": "The O(N) solution is really tough to come up with. Beautiful question!"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "use prefix count of ones and previous answer"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "i found the O(N^2) solution easily but i couldnt figure out the O(N).\\n\\nCould anyone who found the O(n) solution guide me on what sort of problems/patterns i should practice to be better at figuring out optimal solutions after finding brute force"
                    },
                    {
                        "username": "xaocccc",
                        "content": "O(n\\xB2) doesn\\'t work for this problem. Shame."
                    },
                    {
                        "username": "Harsh404_",
                        "content": "My all test cases (95/95) are passed, still it is saying time limit exceeded. time complexity of my code is O(n^2) "
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips:\\n1. track from left: How much of shifts you need to calculate all ones from the given index.\\n2. do the same from right.\\n3. return the sum of both tracks"
                    },
                    {
                        "username": "pktk001",
                        "content": "O(N) approach.\n1. Store the sum of indices which contains ones and also their frequency.\n2. While looping the string if we encounter a '0'\nthen , answer would be:- (sum - frequency*current-index).\n3. Sum is subtracted because current-index increases in each iteration (For each '1' right to current character we need to decrease the sum by 1).\n4. Above would give correct result till a position where every '1' is present in right of that element.\n5. For correct result use the same idea and use 2 counters:- (1) Frequency of '1' in left of current-index, (2) Sum of indices of '1' in left of current-index. \n\n\n"
                    },
                    {
                        "username": "sohail_akthar",
                        "content": "[@jayamrutkar](/jayamrutkar) count\\n\\n10011 \\nFrequency of ones is 3, and zeros is 2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "What it mean by frequency here?"
                    },
                    {
                        "username": "user3107Wk",
                        "content": "Anybody came up with O(n) solution ??"
                    },
                    {
                        "username": "gygshwr_x",
                        "content": "O(N^2) approach: \\n\\nTry creating a bin of values which saves the index that has the ball\\nThe time taken will be the distance between the current value and the values which has the boxes\\n"
                    }
                ]
            },
            {
                "id": 1769481,
                "content": [
                    {
                        "username": "karna001",
                        "content": "here O(N^2) is very simple, but try to do with O(N) also, ig then it will be medium."
                    },
                    {
                        "username": "ajinkode",
                        "content": "The O(N) solution is really tough to come up with. Beautiful question!"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "use prefix count of ones and previous answer"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "i found the O(N^2) solution easily but i couldnt figure out the O(N).\\n\\nCould anyone who found the O(n) solution guide me on what sort of problems/patterns i should practice to be better at figuring out optimal solutions after finding brute force"
                    },
                    {
                        "username": "xaocccc",
                        "content": "O(n\\xB2) doesn\\'t work for this problem. Shame."
                    },
                    {
                        "username": "Harsh404_",
                        "content": "My all test cases (95/95) are passed, still it is saying time limit exceeded. time complexity of my code is O(n^2) "
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips:\\n1. track from left: How much of shifts you need to calculate all ones from the given index.\\n2. do the same from right.\\n3. return the sum of both tracks"
                    },
                    {
                        "username": "pktk001",
                        "content": "O(N) approach.\n1. Store the sum of indices which contains ones and also their frequency.\n2. While looping the string if we encounter a '0'\nthen , answer would be:- (sum - frequency*current-index).\n3. Sum is subtracted because current-index increases in each iteration (For each '1' right to current character we need to decrease the sum by 1).\n4. Above would give correct result till a position where every '1' is present in right of that element.\n5. For correct result use the same idea and use 2 counters:- (1) Frequency of '1' in left of current-index, (2) Sum of indices of '1' in left of current-index. \n\n\n"
                    },
                    {
                        "username": "sohail_akthar",
                        "content": "[@jayamrutkar](/jayamrutkar) count\\n\\n10011 \\nFrequency of ones is 3, and zeros is 2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "What it mean by frequency here?"
                    },
                    {
                        "username": "user3107Wk",
                        "content": "Anybody came up with O(n) solution ??"
                    },
                    {
                        "username": "gygshwr_x",
                        "content": "O(N^2) approach: \\n\\nTry creating a bin of values which saves the index that has the ball\\nThe time taken will be the distance between the current value and the values which has the boxes\\n"
                    }
                ]
            },
            {
                "id": 1900339,
                "content": [
                    {
                        "username": "karna001",
                        "content": "here O(N^2) is very simple, but try to do with O(N) also, ig then it will be medium."
                    },
                    {
                        "username": "ajinkode",
                        "content": "The O(N) solution is really tough to come up with. Beautiful question!"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "use prefix count of ones and previous answer"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "i found the O(N^2) solution easily but i couldnt figure out the O(N).\\n\\nCould anyone who found the O(n) solution guide me on what sort of problems/patterns i should practice to be better at figuring out optimal solutions after finding brute force"
                    },
                    {
                        "username": "xaocccc",
                        "content": "O(n\\xB2) doesn\\'t work for this problem. Shame."
                    },
                    {
                        "username": "Harsh404_",
                        "content": "My all test cases (95/95) are passed, still it is saying time limit exceeded. time complexity of my code is O(n^2) "
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips:\\n1. track from left: How much of shifts you need to calculate all ones from the given index.\\n2. do the same from right.\\n3. return the sum of both tracks"
                    },
                    {
                        "username": "pktk001",
                        "content": "O(N) approach.\n1. Store the sum of indices which contains ones and also their frequency.\n2. While looping the string if we encounter a '0'\nthen , answer would be:- (sum - frequency*current-index).\n3. Sum is subtracted because current-index increases in each iteration (For each '1' right to current character we need to decrease the sum by 1).\n4. Above would give correct result till a position where every '1' is present in right of that element.\n5. For correct result use the same idea and use 2 counters:- (1) Frequency of '1' in left of current-index, (2) Sum of indices of '1' in left of current-index. \n\n\n"
                    },
                    {
                        "username": "sohail_akthar",
                        "content": "[@jayamrutkar](/jayamrutkar) count\\n\\n10011 \\nFrequency of ones is 3, and zeros is 2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "What it mean by frequency here?"
                    },
                    {
                        "username": "user3107Wk",
                        "content": "Anybody came up with O(n) solution ??"
                    },
                    {
                        "username": "gygshwr_x",
                        "content": "O(N^2) approach: \\n\\nTry creating a bin of values which saves the index that has the ball\\nThe time taken will be the distance between the current value and the values which has the boxes\\n"
                    }
                ]
            },
            {
                "id": 1883270,
                "content": [
                    {
                        "username": "karna001",
                        "content": "here O(N^2) is very simple, but try to do with O(N) also, ig then it will be medium."
                    },
                    {
                        "username": "ajinkode",
                        "content": "The O(N) solution is really tough to come up with. Beautiful question!"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "use prefix count of ones and previous answer"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "i found the O(N^2) solution easily but i couldnt figure out the O(N).\\n\\nCould anyone who found the O(n) solution guide me on what sort of problems/patterns i should practice to be better at figuring out optimal solutions after finding brute force"
                    },
                    {
                        "username": "xaocccc",
                        "content": "O(n\\xB2) doesn\\'t work for this problem. Shame."
                    },
                    {
                        "username": "Harsh404_",
                        "content": "My all test cases (95/95) are passed, still it is saying time limit exceeded. time complexity of my code is O(n^2) "
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips:\\n1. track from left: How much of shifts you need to calculate all ones from the given index.\\n2. do the same from right.\\n3. return the sum of both tracks"
                    },
                    {
                        "username": "pktk001",
                        "content": "O(N) approach.\n1. Store the sum of indices which contains ones and also their frequency.\n2. While looping the string if we encounter a '0'\nthen , answer would be:- (sum - frequency*current-index).\n3. Sum is subtracted because current-index increases in each iteration (For each '1' right to current character we need to decrease the sum by 1).\n4. Above would give correct result till a position where every '1' is present in right of that element.\n5. For correct result use the same idea and use 2 counters:- (1) Frequency of '1' in left of current-index, (2) Sum of indices of '1' in left of current-index. \n\n\n"
                    },
                    {
                        "username": "sohail_akthar",
                        "content": "[@jayamrutkar](/jayamrutkar) count\\n\\n10011 \\nFrequency of ones is 3, and zeros is 2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "What it mean by frequency here?"
                    },
                    {
                        "username": "user3107Wk",
                        "content": "Anybody came up with O(n) solution ??"
                    },
                    {
                        "username": "gygshwr_x",
                        "content": "O(N^2) approach: \\n\\nTry creating a bin of values which saves the index that has the ball\\nThe time taken will be the distance between the current value and the values which has the boxes\\n"
                    }
                ]
            },
            {
                "id": 1955970,
                "content": [
                    {
                        "username": "karna001",
                        "content": "here O(N^2) is very simple, but try to do with O(N) also, ig then it will be medium."
                    },
                    {
                        "username": "ajinkode",
                        "content": "The O(N) solution is really tough to come up with. Beautiful question!"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "use prefix count of ones and previous answer"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "i found the O(N^2) solution easily but i couldnt figure out the O(N).\\n\\nCould anyone who found the O(n) solution guide me on what sort of problems/patterns i should practice to be better at figuring out optimal solutions after finding brute force"
                    },
                    {
                        "username": "xaocccc",
                        "content": "O(n\\xB2) doesn\\'t work for this problem. Shame."
                    },
                    {
                        "username": "Harsh404_",
                        "content": "My all test cases (95/95) are passed, still it is saying time limit exceeded. time complexity of my code is O(n^2) "
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips:\\n1. track from left: How much of shifts you need to calculate all ones from the given index.\\n2. do the same from right.\\n3. return the sum of both tracks"
                    },
                    {
                        "username": "pktk001",
                        "content": "O(N) approach.\n1. Store the sum of indices which contains ones and also their frequency.\n2. While looping the string if we encounter a '0'\nthen , answer would be:- (sum - frequency*current-index).\n3. Sum is subtracted because current-index increases in each iteration (For each '1' right to current character we need to decrease the sum by 1).\n4. Above would give correct result till a position where every '1' is present in right of that element.\n5. For correct result use the same idea and use 2 counters:- (1) Frequency of '1' in left of current-index, (2) Sum of indices of '1' in left of current-index. \n\n\n"
                    },
                    {
                        "username": "sohail_akthar",
                        "content": "[@jayamrutkar](/jayamrutkar) count\\n\\n10011 \\nFrequency of ones is 3, and zeros is 2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "What it mean by frequency here?"
                    },
                    {
                        "username": "user3107Wk",
                        "content": "Anybody came up with O(n) solution ??"
                    },
                    {
                        "username": "gygshwr_x",
                        "content": "O(N^2) approach: \\n\\nTry creating a bin of values which saves the index that has the ball\\nThe time taken will be the distance between the current value and the values which has the boxes\\n"
                    }
                ]
            },
            {
                "id": 1786619,
                "content": [
                    {
                        "username": "karna001",
                        "content": "here O(N^2) is very simple, but try to do with O(N) also, ig then it will be medium."
                    },
                    {
                        "username": "ajinkode",
                        "content": "The O(N) solution is really tough to come up with. Beautiful question!"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "use prefix count of ones and previous answer"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "i found the O(N^2) solution easily but i couldnt figure out the O(N).\\n\\nCould anyone who found the O(n) solution guide me on what sort of problems/patterns i should practice to be better at figuring out optimal solutions after finding brute force"
                    },
                    {
                        "username": "xaocccc",
                        "content": "O(n\\xB2) doesn\\'t work for this problem. Shame."
                    },
                    {
                        "username": "Harsh404_",
                        "content": "My all test cases (95/95) are passed, still it is saying time limit exceeded. time complexity of my code is O(n^2) "
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips:\\n1. track from left: How much of shifts you need to calculate all ones from the given index.\\n2. do the same from right.\\n3. return the sum of both tracks"
                    },
                    {
                        "username": "pktk001",
                        "content": "O(N) approach.\n1. Store the sum of indices which contains ones and also their frequency.\n2. While looping the string if we encounter a '0'\nthen , answer would be:- (sum - frequency*current-index).\n3. Sum is subtracted because current-index increases in each iteration (For each '1' right to current character we need to decrease the sum by 1).\n4. Above would give correct result till a position where every '1' is present in right of that element.\n5. For correct result use the same idea and use 2 counters:- (1) Frequency of '1' in left of current-index, (2) Sum of indices of '1' in left of current-index. \n\n\n"
                    },
                    {
                        "username": "sohail_akthar",
                        "content": "[@jayamrutkar](/jayamrutkar) count\\n\\n10011 \\nFrequency of ones is 3, and zeros is 2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "What it mean by frequency here?"
                    },
                    {
                        "username": "user3107Wk",
                        "content": "Anybody came up with O(n) solution ??"
                    },
                    {
                        "username": "gygshwr_x",
                        "content": "O(N^2) approach: \\n\\nTry creating a bin of values which saves the index that has the ball\\nThe time taken will be the distance between the current value and the values which has the boxes\\n"
                    }
                ]
            },
            {
                "id": 1758839,
                "content": [
                    {
                        "username": "karna001",
                        "content": "here O(N^2) is very simple, but try to do with O(N) also, ig then it will be medium."
                    },
                    {
                        "username": "ajinkode",
                        "content": "The O(N) solution is really tough to come up with. Beautiful question!"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "use prefix count of ones and previous answer"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "i found the O(N^2) solution easily but i couldnt figure out the O(N).\\n\\nCould anyone who found the O(n) solution guide me on what sort of problems/patterns i should practice to be better at figuring out optimal solutions after finding brute force"
                    },
                    {
                        "username": "xaocccc",
                        "content": "O(n\\xB2) doesn\\'t work for this problem. Shame."
                    },
                    {
                        "username": "Harsh404_",
                        "content": "My all test cases (95/95) are passed, still it is saying time limit exceeded. time complexity of my code is O(n^2) "
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips:\\n1. track from left: How much of shifts you need to calculate all ones from the given index.\\n2. do the same from right.\\n3. return the sum of both tracks"
                    },
                    {
                        "username": "pktk001",
                        "content": "O(N) approach.\n1. Store the sum of indices which contains ones and also their frequency.\n2. While looping the string if we encounter a '0'\nthen , answer would be:- (sum - frequency*current-index).\n3. Sum is subtracted because current-index increases in each iteration (For each '1' right to current character we need to decrease the sum by 1).\n4. Above would give correct result till a position where every '1' is present in right of that element.\n5. For correct result use the same idea and use 2 counters:- (1) Frequency of '1' in left of current-index, (2) Sum of indices of '1' in left of current-index. \n\n\n"
                    },
                    {
                        "username": "sohail_akthar",
                        "content": "[@jayamrutkar](/jayamrutkar) count\\n\\n10011 \\nFrequency of ones is 3, and zeros is 2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "What it mean by frequency here?"
                    },
                    {
                        "username": "user3107Wk",
                        "content": "Anybody came up with O(n) solution ??"
                    },
                    {
                        "username": "gygshwr_x",
                        "content": "O(N^2) approach: \\n\\nTry creating a bin of values which saves the index that has the ball\\nThe time taken will be the distance between the current value and the values which has the boxes\\n"
                    }
                ]
            },
            {
                "id": 1726428,
                "content": [
                    {
                        "username": "karna001",
                        "content": "here O(N^2) is very simple, but try to do with O(N) also, ig then it will be medium."
                    },
                    {
                        "username": "ajinkode",
                        "content": "The O(N) solution is really tough to come up with. Beautiful question!"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "use prefix count of ones and previous answer"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "i found the O(N^2) solution easily but i couldnt figure out the O(N).\\n\\nCould anyone who found the O(n) solution guide me on what sort of problems/patterns i should practice to be better at figuring out optimal solutions after finding brute force"
                    },
                    {
                        "username": "xaocccc",
                        "content": "O(n\\xB2) doesn\\'t work for this problem. Shame."
                    },
                    {
                        "username": "Harsh404_",
                        "content": "My all test cases (95/95) are passed, still it is saying time limit exceeded. time complexity of my code is O(n^2) "
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips:\\n1. track from left: How much of shifts you need to calculate all ones from the given index.\\n2. do the same from right.\\n3. return the sum of both tracks"
                    },
                    {
                        "username": "pktk001",
                        "content": "O(N) approach.\n1. Store the sum of indices which contains ones and also their frequency.\n2. While looping the string if we encounter a '0'\nthen , answer would be:- (sum - frequency*current-index).\n3. Sum is subtracted because current-index increases in each iteration (For each '1' right to current character we need to decrease the sum by 1).\n4. Above would give correct result till a position where every '1' is present in right of that element.\n5. For correct result use the same idea and use 2 counters:- (1) Frequency of '1' in left of current-index, (2) Sum of indices of '1' in left of current-index. \n\n\n"
                    },
                    {
                        "username": "sohail_akthar",
                        "content": "[@jayamrutkar](/jayamrutkar) count\\n\\n10011 \\nFrequency of ones is 3, and zeros is 2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "What it mean by frequency here?"
                    },
                    {
                        "username": "user3107Wk",
                        "content": "Anybody came up with O(n) solution ??"
                    },
                    {
                        "username": "gygshwr_x",
                        "content": "O(N^2) approach: \\n\\nTry creating a bin of values which saves the index that has the ball\\nThe time taken will be the distance between the current value and the values which has the boxes\\n"
                    }
                ]
            },
            {
                "id": 1721238,
                "content": [
                    {
                        "username": "karna001",
                        "content": "here O(N^2) is very simple, but try to do with O(N) also, ig then it will be medium."
                    },
                    {
                        "username": "ajinkode",
                        "content": "The O(N) solution is really tough to come up with. Beautiful question!"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "use prefix count of ones and previous answer"
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "i found the O(N^2) solution easily but i couldnt figure out the O(N).\\n\\nCould anyone who found the O(n) solution guide me on what sort of problems/patterns i should practice to be better at figuring out optimal solutions after finding brute force"
                    },
                    {
                        "username": "xaocccc",
                        "content": "O(n\\xB2) doesn\\'t work for this problem. Shame."
                    },
                    {
                        "username": "Harsh404_",
                        "content": "My all test cases (95/95) are passed, still it is saying time limit exceeded. time complexity of my code is O(n^2) "
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips:\\n1. track from left: How much of shifts you need to calculate all ones from the given index.\\n2. do the same from right.\\n3. return the sum of both tracks"
                    },
                    {
                        "username": "pktk001",
                        "content": "O(N) approach.\n1. Store the sum of indices which contains ones and also their frequency.\n2. While looping the string if we encounter a '0'\nthen , answer would be:- (sum - frequency*current-index).\n3. Sum is subtracted because current-index increases in each iteration (For each '1' right to current character we need to decrease the sum by 1).\n4. Above would give correct result till a position where every '1' is present in right of that element.\n5. For correct result use the same idea and use 2 counters:- (1) Frequency of '1' in left of current-index, (2) Sum of indices of '1' in left of current-index. \n\n\n"
                    },
                    {
                        "username": "sohail_akthar",
                        "content": "[@jayamrutkar](/jayamrutkar) count\\n\\n10011 \\nFrequency of ones is 3, and zeros is 2"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "What it mean by frequency here?"
                    },
                    {
                        "username": "user3107Wk",
                        "content": "Anybody came up with O(n) solution ??"
                    },
                    {
                        "username": "gygshwr_x",
                        "content": "O(N^2) approach: \\n\\nTry creating a bin of values which saves the index that has the ball\\nThe time taken will be the distance between the current value and the values which has the boxes\\n"
                    }
                ]
            }
        ]
    }
]