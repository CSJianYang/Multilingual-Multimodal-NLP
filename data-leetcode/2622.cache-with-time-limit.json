[
    {
        "title": "Cache With Time Limit",
        "question_content": "Write a class that allows getting and setting&nbsp;key-value pairs, however a&nbsp;time until expiration&nbsp;is associated with each key.\nThe class has three public methods:\nset(key, value, duration):&nbsp;accepts an integer&nbsp;key, an&nbsp;integer&nbsp;value, and a duration in milliseconds. Once the&nbsp;duration&nbsp;has elapsed, the key should be inaccessible. The method should return&nbsp;true&nbsp;if the same&nbsp;un-expired key already exists and false otherwise. Both the value and duration should be overwritten if the key already exists.\nget(key): if an un-expired key exists, it should return the associated value. Otherwise it should return&nbsp;-1.\ncount(): returns the count of un-expired keys.\n&nbsp;\nExample 1:\n\nInput: \nactions = [\"TimeLimitedCache\", \"set\", \"get\", \"count\", \"get\"]\nvalues = [[], [1, 42, 100], [1], [], [1]]\ntimeDelays = [0, 0, 50, 50, 150]\nOutput: [null, false, 42, 1, -1]\nExplanation:\nAt t=0, the cache is constructed.\nAt t=0, a key-value pair (1: 42) is added with a time limit of 100ms. The value doesn't exist so false is returned.\nAt t=50, key=1 is requested and the value of 42 is returned.\nAt t=50, count() is called and there is one active key in the cache.\nAt t=100, key=1 expires.\nAt t=150, get(1) is called but -1 is returned because the cache is empty.\n\nExample 2:\n\nInput: \nactions = [\"TimeLimitedCache\", \"set\", \"set\", \"get\", \"get\", \"get\", \"count\"]\nvalues = [[], [1, 42, 50], [1, 50, 100], [1], [1], [1], []]\ntimeDelays = [0, 0, 40, 50, 120, 200, 250]\nOutput: [null, false, true, 50, 50, -1, 0]\nExplanation:\nAt t=0, the cache is constructed.\nAt t=0, a key-value pair (1: 42) is added with a time limit of 50ms. The value doesn't exist so false is returned.\nAt t=40, a key-value pair (1: 50) is added with a time limit of 100ms. A non-expired value already existed so true is returned and the old value was overwritten.\nAt t=50, get(1) is called which returned 50.\nAt t=120, get(1) is called which returned 50.\nAt t=140, key=1 expires.\nAt t=200, get(1) is called but the cache is empty so -1 is returned.\nAt t=250, count() returns 0 because the cache is empty.\n\n&nbsp;\nConstraints:\n\n\t0 <= key, value <= 109\n\t0 <= duration <= 1000\n\t1 <= actions.length <= 100\n\tactions.length === values.length\n\tactions.length === timeDelays.length\n\t0 <= timeDelays[i] <= 1450\n\tactions[i]&nbsp;is one of \"TimeLimitedCache\", \"set\", \"get\" and&nbsp;\"count\"\n\tFirst action is always \"TimeLimitedCache\" and must be executed immediately, with a 0-millisecond delay",
        "solutions": [
            {
                "id": 3406927,
                "title": "javascript-short-simple-o-n-solution-using-settimeout",
                "content": "# Approach\\n1. Use `setTimeout` to remove items from the cache.\\n2. If a key already exists in the cache, cancel its timeout.\\n\\n- Overall time/space complexity: $$O(n)$$\\n\\n# Code\\n```js\\nconst TimeLimitedCache = function() {\\n    this.cache = new Map();  // Using Map so we don\\'t need a size variable\\n};\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let found = this.cache.has(key);\\n    if (found) clearTimeout(this.cache.get(key).ref);  // Cancel previous timeout\\n    this.cache.set(key, {\\n        value,  // Equivalent to `value: value`\\n        ref: setTimeout(() => this.cache.delete(key), duration)\\n    });\\n    return found;\\n};\\n\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.cache.has(key) ? this.cache.get(key).value : -1;\\n};\\n\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst TimeLimitedCache = function() {\\n    this.cache = new Map();  // Using Map so we don\\'t need a size variable\\n};\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let found = this.cache.has(key);\\n    if (found) clearTimeout(this.cache.get(key).ref);  // Cancel previous timeout\\n    this.cache.set(key, {\\n        value,  // Equivalent to `value: value`\\n        ref: setTimeout(() => this.cache.delete(key), duration)\\n    });\\n    return found;\\n};\\n\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.cache.has(key) ? this.cache.get(key).value : -1;\\n};\\n\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3407588,
                "title": "typescript-ttlvalue-interface-map-number-ttlvalue",
                "content": "```typescript []\\ninterface TTLValue {\\n    value: number;\\n    timer: ReturnType<typeof setTimeout>;\\n}\\n\\nclass TimeLimitedCache {\\n    cache = new Map<number, TTLValue>()\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        const exists = this.cache.has(key)\\n        if (exists) clearTimeout(this.cache.get(key).timer)\\n        this.cache.set(key, {value, timer: setTimeout(() => this.cache.delete(key), duration)})\\n        return exists\\n    }\\n\\n    get(key: number): number {\\n        return this.cache.has(key) ? this.cache.get(key).value : -1\\n    }\\n\\n\\tcount(): number {\\n        return this.cache.size\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript []\\ninterface TTLValue {\\n    value: number;\\n    timer: ReturnType<typeof setTimeout>;\\n}\\n\\nclass TimeLimitedCache {\\n    cache = new Map<number, TTLValue>()\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        const exists = this.cache.has(key)\\n        if (exists) clearTimeout(this.cache.get(key).timer)\\n        this.cache.set(key, {value, timer: setTimeout(() => this.cache.delete(key), duration)})\\n        return exists\\n    }\\n\\n    get(key: number): number {\\n        return this.cache.has(key) ? this.cache.get(key).value : -1\\n    }\\n\\n\\tcount(): number {\\n        return this.cache.size\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536788,
                "title": "cache-with-auto-expiration-detailed-explanation",
                "content": "### \\u2705\\u2705\\uD83D\\uDD1D\\uD83D\\uDD1DPlease Upvote if you find this helpful. \\uD83D\\uDD1D\\uD83D\\uDD1D\\u2705\\u2705\\n\\n \\n1. The `TimeLimitedCache` constructor function initializes a new instance of the cache. It creates an empty `cache` object as a property of the instance.\\n\\n1. The `set` method is used to set a key-value pair in the cache with a specified duration. It takes three parameters: `key`, `value`, and `duration`. Here\\'s how it works:\\n    - First, it checks if the `key` already exists in the cache and has an active timer by checking `this.cache[key] && this.cache[key].timer`. If it does, it means that the key already exists and is not expired.\\n\\n    - If the key exists, the existing timer is cleared using `clearTimeout(this.cache[key].timer)`. This prevents the old timer from expiring and removes the associated timeout.\\n\\n    - Then, the value is updated by assigning `this.cache[key].value = value`.\\n\\n    - Next, a new timer is set using `setTimeout` to remove the key after the specified `duration`. The `setTimeout` function takes a callback function that removes the key from the cache when called. The timer ID is stored as `this.cache[key].timer`.\\n\\n    - Finally, `true` is returned to indicate that the key already existed and was updated.\\n\\n    - If the key does not exist in the cache or has an expired timer, it creates a new entry in the cache with the specified `value`. It sets a new expiration timer as before. Then, it returns `false` to indicate that a new key-value pair was added to the cache.\\n\\n3. The `get` method is used to retrieve the value associated with a key from the cache. It takes one parameter: `key`. Here\\'s how it works:\\n\\n    - It first checks if the key exists in the cache and has an active timer by checking `this.cache[key] && this.cache[key].timer`. If it does, it means that the key exists and is not expired.\\n\\n    - If the key is valid, it returns the associated value by accessing `this.cache[key].value`.\\n\\n    - If the key does not exist in the cache or has an expired timer, it returns `-1` to indicate that the key is not accessible.\\n\\n4. The `count` method is used to count the number of unexpired keys in the cache. It iterates over the cache object and counts the number of entries that have an active timer. Here\\'s how it works:\\n\\n    - It initializes a `count` variable to `0`.\\n\\n    - It iterates over each key in the `cache` object using a `for...in` loop.\\n\\n    - For each key, it checks if the key has an active timer by checking `this.cache[key].timer`. If it does, it increments the `count` by `1`.\\n\\n    - After iterating over all keys, it returns the final `count`.\\n\\n5. The `remove` method is used internally to remove expired keys from the cache when their timers expire. It takes one parameter: `key`. Here\\'s how it works:\\n\\n    - It deletes the key from the `cache` object by using the `delete` operator: `delete this.cache[key]`.\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.cache = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n  if (this.cache[key] && this.cache[key].timer) {\\n    clearTimeout(this.cache[key].timer);\\n    this.cache[key].value = value;\\n    this.cache[key].timer = setTimeout(() => {\\n      this.remove(key);\\n    }, duration);\\n    return true;\\n  } else {\\n    this.cache[key] = {\\n      value: value,\\n      timer: setTimeout(() => {\\n        this.remove(key);\\n      }, duration)\\n    };\\n    return false;\\n  }\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n  if (this.cache[key] && this.cache[key].timer) {\\n    return this.cache[key].value;\\n  } else {\\n    return -1;\\n  }\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n  let count = 0;\\n  for (const key in this.cache) {\\n    if (this.cache[key].timer) {\\n      count++;\\n    }\\n  }\\n  return count;\\n};\\n\\nTimeLimitedCache.prototype.remove = function(key) {\\n  delete this.cache[key];\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cache = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n  if (this.cache[key] && this.cache[key].timer) {\\n    clearTimeout(this.cache[key].timer);\\n    this.cache[key].value = value;\\n    this.cache[key].timer = setTimeout(() => {\\n      this.remove(key);\\n    }, duration);\\n    return true;\\n  } else {\\n    this.cache[key] = {\\n      value: value,\\n      timer: setTimeout(() => {\\n        this.remove(key);\\n      }, duration)\\n    };\\n    return false;\\n  }\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n  if (this.cache[key] && this.cache[key].timer) {\\n    return this.cache[key].value;\\n  } else {\\n    return -1;\\n  }\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n  let count = 0;\\n  for (const key in this.cache) {\\n    if (this.cache[key].timer) {\\n      count++;\\n    }\\n  }\\n  return count;\\n};\\n\\nTimeLimitedCache.prototype.remove = function(key) {\\n  delete this.cache[key];\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3536696,
                "title": "detailed-solution-using-settimeout-and-constructor-in-javascript-faster-than-70",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n - To Store Key -  Value Pair we will used Map.\\n - In order to delete particular key after it\\'s duration is elasped, we will use setTimeout and let the javascript to handle this operation in Asychronous manner.\\n   ```\\n     setTimeout(()=>{\\n        Cache.delete(key);\\n     },duration)\\n   ```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n 1. Create new Map object Cache inside TimieLimitedCache.\\n 2. In set method if key is not present in Cache then \\n       - `const Id=setTimeout(()=>{\\n             Cache.delete(key);\\n          },duration);`\\n      - `Cache.set(key,{\\n                    value:value,\\n                    ref:Id\\n          });`\\n      - We are storing Id in the Map because when we will have to \\n         update value of key in Map then we have to cancel setTimeout\\n         method corresponding to this key and for that Id required.\\n 3. If in set method key is there in map then we do following steps\\n    - `const Id=Cache.get(key).ref`;\\n    - `clearTimeout(Id)` //We are cancelling the prev setTimeout .\\n    - `Id=setTimeout(()=>{\\n           Cache.delete(key);\\n          },duration);`\\n    - `Cache.set(key,{\\n                value:value,\\n                ref:Id\\n          });`\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.Cache=new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n      let res=false;\\n      if(this.Cache.has(key))\\n      {\\n         const ref=this.Cache.get(key).ref;\\n         clearTimeout(ref);\\n         res=true;\\n      }\\n       const ref=setTimeout(()=>{\\n         this.Cache.delete(key);\\n         },duration);\\n         this.Cache.set(key,{\\n               value:value,\\n               ref:ref\\n         });\\n      return res;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(this.Cache.has(key))\\n    {\\n       return this.Cache.get(key).value;  \\n    }\\n    return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.Cache.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```\\n**Please Upvote If You Found Usefull** \\uD83D\\uDC4D\\uD83D\\uDC4D.\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n     setTimeout(()=>{\\n        Cache.delete(key);\\n     },duration)\\n   ```\n```\\nvar TimeLimitedCache = function() {\\n    this.Cache=new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n      let res=false;\\n      if(this.Cache.has(key))\\n      {\\n         const ref=this.Cache.get(key).ref;\\n         clearTimeout(ref);\\n         res=true;\\n      }\\n       const ref=setTimeout(()=>{\\n         this.Cache.delete(key);\\n         },duration);\\n         this.Cache.set(key,{\\n               value:value,\\n               ref:ref\\n         });\\n      return res;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(this.Cache.has(key))\\n    {\\n       return this.Cache.get(key).value;  \\n    }\\n    return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.Cache.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3536612,
                "title": "java-script-solution-for-cache-with-time-limit-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the provided solution is to use a Map data structure to store the key-value pairs in the cache. Each key is associated with an object containing the value and a timeout identifier. The set method updates the value and sets a timeout to remove the key after the specified duration. The get method retrieves the value associated with the key if it exists and has not expired. The count method returns the number of non-expired keys in the cache.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach taken is to use a Map to efficiently store and access the key-value pairs. When setting a key, the existing timeout for that key is cleared, and a new timeout is set. When getting a key, the value is retrieved if it exists and has not expired. The count is simply the size of the Map since it only contains non-expired keys.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the set, get, and count operations in the provided solution is O(1) on average. Accessing, inserting, and deleting elements in a Map have an average time complexity of O(1).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(n), where n is the number of key-value pairs in the cache, as it uses a Map to store the data.\\n\\n# Code\\n```\\nfunction TimeLimitedCache() {\\n  this.cache = new Map();\\n}\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n     const valueInCache = this.cache.get(key);\\n    if (valueInCache) {\\n      clearTimeout(valueInCache.timeout);\\n    }\\n    const timeout = setTimeout(() => this.cache.delete(key), duration);\\n    this.cache.set(key, { value, timeout });\\n    return Boolean(valueInCache);\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n      return this.cache.has(key) ? this.cache.get(key).value : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n     return this.cache.size;\\n};\\n\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction TimeLimitedCache() {\\n  this.cache = new Map();\\n}\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n     const valueInCache = this.cache.get(key);\\n    if (valueInCache) {\\n      clearTimeout(valueInCache.timeout);\\n    }\\n    const timeout = setTimeout(() => this.cache.delete(key), duration);\\n    this.cache.set(key, { value, timeout });\\n    return Boolean(valueInCache);\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n      return this.cache.has(key) ? this.cache.get(key).value : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n     return this.cache.size;\\n};\\n\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3538448,
                "title": "simple-javascript-solution-o-n-using-date-now",
                "content": "# Approach\\n\\n## set(key, value, duration):\\n **Date.now()** method represents the current time at the moment the variable is assigned. If the key already exists and has not expired, it updates the value and extends the expiration time. Returns true if the ****key was updated****, and false if it was newly created.\\n\\n## get(key):\\n If it exists and has not expired. Returns the value if found, or **-1** if not found or expired.\\n\\n## count():\\n Counts the number of valid (non-expired) entries in the data store. It iterates through all keys and **increments** the count if the expiration time has not passed.\\n\\n# Code\\n```\\nclass TimeLimitedCache {\\n  constructor() {\\n    this.data = {};\\n    \\n  }\\n\\n  set(key, value, duration) {\\n    const currentTime = Date.now();\\n    if (this.data[key] && this.data[key].expiration > currentTime) {\\n      this.data[key].value = value;\\n      this.data[key].expiration = currentTime + duration;\\n      return true;\\n    } else {\\n      this.data[key] = {\\n        value: value,\\n        expiration: currentTime + duration\\n      };\\n      return false;\\n    }\\n  }\\n\\n  get(key) {\\n    const entry = this.data[key];\\n    if (entry && entry.expiration > Date.now()) {\\n      return entry.value;\\n    }\\n    return -1;\\n  }\\n\\n  count() {\\n    const currentTime = Date.now();\\n    let count = 0;\\n    for (const key in this.data) {\\n      if (this.data[key].expiration > currentTime) {\\n        count++;\\n      }\\n    }\\n    return count;\\n  }\\n}\\n\\n```\\nUPVOTE IF IT HELPS",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass TimeLimitedCache {\\n  constructor() {\\n    this.data = {};\\n    \\n  }\\n\\n  set(key, value, duration) {\\n    const currentTime = Date.now();\\n    if (this.data[key] && this.data[key].expiration > currentTime) {\\n      this.data[key].value = value;\\n      this.data[key].expiration = currentTime + duration;\\n      return true;\\n    } else {\\n      this.data[key] = {\\n        value: value,\\n        expiration: currentTime + duration\\n      };\\n      return false;\\n    }\\n  }\\n\\n  get(key) {\\n    const entry = this.data[key];\\n    if (entry && entry.expiration > Date.now()) {\\n      return entry.value;\\n    }\\n    return -1;\\n  }\\n\\n  count() {\\n    const currentTime = Date.now();\\n    let count = 0;\\n    for (const key in this.data) {\\n      if (this.data[key].expiration > currentTime) {\\n        count++;\\n      }\\n    }\\n    return count;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406552,
                "title": "my-solution",
                "content": "# Code\\n\\n```javascript\\nvar TimeLimitedCache = function() {\\n    // A map to store the key-value pairs and their expiration time\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    // Get the current time in milliseconds\\n    const now = Date.now();\\n    // Calculate the expiration time as the sum of the current time and the duration\\n    const expirationTime = now + duration;\\n    // Check if the key already exists in the cache\\n    if (this.cache.has(key)) {\\n        // Update the value and expiration time\\n        const entry = this.cache.get(key);\\n        entry.value = value;\\n        entry.expirationTime = expirationTime;\\n        // Return true to indicate that the key already existed\\n        return true;\\n    } else {\\n        // Add a new entry to the cache\\n        this.cache.set(key, { value: value, expirationTime: expirationTime });\\n        // Return false to indicate that the key did not exist before\\n        return false;\\n    }\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key, or -1 if expired or not found\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    // Get the current time in milliseconds\\n    const now = Date.now();\\n    // Check if the key exists in the cache\\n    if (this.cache.has(key)) {\\n        // Get the entry for the key\\n        const entry = this.cache.get(key);\\n        // Check if the entry has expired\\n        if (entry.expirationTime < now) {\\n            // Remove the expired entry from the cache\\n            this.cache.delete(key);\\n            // Return -1 to indicate that the entry has expired\\n            return -1;\\n        } else {\\n            // Return the value associated with the key\\n            return entry.value;\\n        }\\n    } else {\\n        // Return -1 to indicate that the key was not found\\n        return -1;\\n    }\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    // Get the current time in milliseconds\\n    const now = Date.now();\\n    // Count the number of non-expired keys in the cache\\n    let count = 0;\\n    for (const entry of this.cache.values()) {\\n        if (entry.expirationTime >= now) {\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar TimeLimitedCache = function() {\\n    // A map to store the key-value pairs and their expiration time\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    // Get the current time in milliseconds\\n    const now = Date.now();\\n    // Calculate the expiration time as the sum of the current time and the duration\\n    const expirationTime = now + duration;\\n    // Check if the key already exists in the cache\\n    if (this.cache.has(key)) {\\n        // Update the value and expiration time\\n        const entry = this.cache.get(key);\\n        entry.value = value;\\n        entry.expirationTime = expirationTime;\\n        // Return true to indicate that the key already existed\\n        return true;\\n    } else {\\n        // Add a new entry to the cache\\n        this.cache.set(key, { value: value, expirationTime: expirationTime });\\n        // Return false to indicate that the key did not exist before\\n        return false;\\n    }\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key, or -1 if expired or not found\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    // Get the current time in milliseconds\\n    const now = Date.now();\\n    // Check if the key exists in the cache\\n    if (this.cache.has(key)) {\\n        // Get the entry for the key\\n        const entry = this.cache.get(key);\\n        // Check if the entry has expired\\n        if (entry.expirationTime < now) {\\n            // Remove the expired entry from the cache\\n            this.cache.delete(key);\\n            // Return -1 to indicate that the entry has expired\\n            return -1;\\n        } else {\\n            // Return the value associated with the key\\n            return entry.value;\\n        }\\n    } else {\\n        // Return -1 to indicate that the key was not found\\n        return -1;\\n    }\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    // Get the current time in milliseconds\\n    const now = Date.now();\\n    // Count the number of non-expired keys in the cache\\n    let count = 0;\\n    for (const entry of this.cache.values()) {\\n        if (entry.expirationTime >= now) {\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3536888,
                "title": "day-5-o-1-o-9-commented-examples",
                "content": "This code defines a class called `TimeLimitedCache`, which implements a time-limited cache using a `Map` data structure. The cache allows you to store key-value pairs for a specific duration.\\n\\nHere\\'s how the code works:\\n\\n1. The `TimeLimitedCache` constructor initializes an empty `Map` called `Cache` to store the key-value pairs.\\n\\n2. The `set` method is used to add or update a key-value pair in the cache. It takes three parameters: `key` (the key of the item to be stored), `value` (the value associated with the key), and `duration` (the time duration in milliseconds for which the item should be stored in the cache).\\n\\n3. Inside the `set` method:\\n   - If the `Cache` already has an entry for the specified `key`, it means the item is being updated. In this case, the existing reference to the timeout is retrieved from the cache using the `ref` property and cleared using `clearTimeout`. This prevents the previous timeout from triggering and deleting the item prematurely.\\n   - A new timeout is created using `setTimeout`. When the timeout duration elapses, it triggers a function that deletes the item from the cache using `this.Cache.delete(key)`.\\n   - The updated key-value pair is then added to the cache using `this.Cache.set(key, { value: value, ref: ref })`, where `ref` is the reference to the timeout created above.\\n   - Finally, the method returns `true` if the item was updated or `false` if it was newly added.\\n\\n4. The `get` method is used to retrieve the value associated with a given key from the cache. It takes a single parameter: `key` (the key of the item to be retrieved).\\n\\n5. Inside the `get` method:\\n   - If the `Cache` has an entry for the specified `key`, it returns the associated value using `this.Cache.get(key).value`.\\n   - If the `key` is not found in the cache, it returns `-1` to indicate that the key is not present.\\n\\n6. The `count` method returns the number of key-value pairs currently stored in the cache by using the `size` property of the `Cache` map.\\n\\nOverall, this code provides a time-limited cache functionality, allowing you to store key-value pairs for a specific duration and retrieve them before they expire.\\n\\n```\\n\\nvar TimeLimitedCache = function() {\\n    this.Cache=new Map();\\n};\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n     let res=false;\\n      if(this.Cache.has(key))\\n      {\\n         const ref=this.Cache.get(key).ref;\\n         clearTimeout(ref);\\n         res=true;\\n      }\\n       const ref=setTimeout(()=>{\\n         this.Cache.delete(key);\\n         },duration);\\n         this.Cache.set(key,{\\n               value:value,\\n               ref:ref\\n         });\\n      return res;\\n};\\n\\n\\nTimeLimitedCache.prototype.get = function(key) {\\n      if(this.Cache.has(key))\\n    {\\n       return this.Cache.get(key).value;  \\n    }\\n    return -1;\\n};\\n\\n\\nTimeLimitedCache.prototype.count = function() {\\n      return this.Cache.size;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n\\nvar TimeLimitedCache = function() {\\n    this.Cache=new Map();\\n};\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n     let res=false;\\n      if(this.Cache.has(key))\\n      {\\n         const ref=this.Cache.get(key).ref;\\n         clearTimeout(ref);\\n         res=true;\\n      }\\n       const ref=setTimeout(()=>{\\n         this.Cache.delete(key);\\n         },duration);\\n         this.Cache.set(key,{\\n               value:value,\\n               ref:ref\\n         });\\n      return res;\\n};\\n\\n\\nTimeLimitedCache.prototype.get = function(key) {\\n      if(this.Cache.has(key))\\n    {\\n       return this.Cache.get(key).value;  \\n    }\\n    return -1;\\n};\\n\\n\\nTimeLimitedCache.prototype.count = function() {\\n      return this.Cache.size;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3538254,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution uses a Map to store key-value pairs in a cache. The set method updates values and sets timeouts for automatic removal after a duration. The get method retrieves non-expired values by key, and the count method returns the number of non-expired keys in the cache.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution efficiently uses a Map to store key-value pairs. Setting a key clears the existing timeout and sets a new one. Getting a key retrieves its value if it exists and hasn\\'t expired. The count is determined by the size of the Map, which only includes non-expired keys.\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const valcache = this.cache.get(key);\\n    if (valcache) {\\n      clearTimeout(valcache.timeout);\\n    }\\n    const timeout = setTimeout(() => this.cache.delete(key), duration);\\n    this.cache.set(key, { value, timeout });\\n    return Boolean(valcache);\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.cache.has(key) ? this.cache.get(key).value : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const valcache = this.cache.get(key);\\n    if (valcache) {\\n      clearTimeout(valcache.timeout);\\n    }\\n    const timeout = setTimeout(() => this.cache.delete(key), duration);\\n    this.cache.set(key, { value, timeout });\\n    return Boolean(valcache);\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.cache.has(key) ? this.cache.get(key).value : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3432304,
                "title": "simple-solution-using-a-map-and-settimeout",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple solution using `Map` and `setTimeout`.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore a key value pair in the `Map` with value and a reference to the `setTimeout`. Remove pair from the `Map` when the `setTimeout` resolves.\\n\\n# Complexity\\n- Time complexity: For `get()` and `set()`: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    \\n    const hasKey = this.cache.has(key);\\n\\n    if (hasKey) {\\n      \\n      const [, oldRef] = this.cache.get(key);\\n      clearTimeout(oldRef);\\n\\n    }\\n\\n    const ref = setTimeout(() => {\\n      this.cache.delete(key);\\n    }, duration);\\n\\n    this.cache.set(key, [value, ref]);\\n\\n    return hasKey;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (!this.cache.has(key)) {\\n      return -1;\\n    }\\n\\n    const [value, ] = this.cache.get(key);\\n\\n    return value;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    \\n    const hasKey = this.cache.has(key);\\n\\n    if (hasKey) {\\n      \\n      const [, oldRef] = this.cache.get(key);\\n      clearTimeout(oldRef);\\n\\n    }\\n\\n    const ref = setTimeout(() => {\\n      this.cache.delete(key);\\n    }, duration);\\n\\n    this.cache.set(key, [value, ref]);\\n\\n    return hasKey;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (!this.cache.has(key)) {\\n      return -1;\\n    }\\n\\n    const [value, ] = this.cache.get(key);\\n\\n    return value;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3410957,
                "title": "approach-focused-on-readable-and-clean-code-w-justification",
                "content": "# Intuition\\nThe initial intuitive approach to this problem is to use setTimeout to automatically time cache keys out. However, this isn\\'t optimal performance-wise for large n - it\\'s a lot for the browser/Node to keep track of. We need another way to do this.\\n\\n# Approach\\nTo avoid having to use setTimeout, every time we insert a key, we also insert an expiry time for the key.\\n\\nThus, after a key expires, in the code below we don\\'t actually remove anything from the cache - instead, after the entry expires, if a get operation is called with the get key, the object is simply ignored if it\\'s expiry is greater than the current time. Depending on the contraints of the system, this could be a good or bad idea - programming is all about tradeoffs after all.\\n\\nIf the interviewer asks you to actually remove keys from the cache, consider an approach rather than actively removing keys as soon as they expire like in the LRU cache problem. Alternatively, a simple method to lazily remove keys is as follows:\\n\\n1. When a get operation is called, check if the value is expired\\n2. If it isn\\'t expired, just return as normal\\n3. If it is expired, set the value to null\\n\\n# Complexity\\n- Time complexity:\\n    - Depends on the time complexity of ES6 Map functions, which depend on the implementation in the JS engine you are using. Assuming O(log(n)) insertions and O(log(n)) retrivals:\\n    -   Set: O(log(n))\\nGet: O(log(n))\\nCount: O(n)\\n\\n\\n\\n- Space complexity:\\n    - O(n)\\n\\n# Code\\n```\\ninterface CacheEntry {\\n    value: number\\n    expiry: number\\n};\\n\\nclass TimeLimitedCache {\\n    cache: Map<number, CacheEntry>\\n    constructor() {\\n        this.cache = new Map<number, CacheEntry>()\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        let entry : number = this.get(key);\\n        this.cache[key] = {\\n            value: value,\\n            expiry: Date.now() + duration\\n        }\\n        return entry !== -1;\\n    }\\n\\n    get(key: number): number {\\n        if (!this.cache[key] || Date.now() > this.cache[key].expiry){\\n            return -1;\\n        }\\n        return this.cache[key].value;\\n    }\\n\\n\\tcount(): number {\\n        const time : number = Date.now();\\n        let ans : number = 0;\\n        for (const [key, value] of Object.entries(this.cache)){\\n            if (value.expiry >= time){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ninterface CacheEntry {\\n    value: number\\n    expiry: number\\n};\\n\\nclass TimeLimitedCache {\\n    cache: Map<number, CacheEntry>\\n    constructor() {\\n        this.cache = new Map<number, CacheEntry>()\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        let entry : number = this.get(key);\\n        this.cache[key] = {\\n            value: value,\\n            expiry: Date.now() + duration\\n        }\\n        return entry !== -1;\\n    }\\n\\n    get(key: number): number {\\n        if (!this.cache[key] || Date.now() > this.cache[key].expiry){\\n            return -1;\\n        }\\n        return this.cache[key].value;\\n    }\\n\\n\\tcount(): number {\\n        const time : number = Date.now();\\n        let ans : number = 0;\\n        for (const [key, value] of Object.entries(this.cache)){\\n            if (value.expiry >= time){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746167,
                "title": "no-timeout-solution",
                "content": "# Intuition\\nSince the problem\\'s description specifies that the value should not be accessible, and doesn\\'t clarify that it should be cleared when the time has expired, I simply chose to save a timestamp on creation and verify the duration hasn\\'t been elapsed on set/get calls\\n\\n\\n# Code\\n```\\nclass TimeLimitedCache {\\n    map = {}\\n\\n    constructor() {}\\n\\n    #isExpired(duration, timestamp) {\\n        return (Date.now() - timestamp) > duration;\\n    }\\n    \\n    set(key: number, value: number, duration: number): boolean {\\n        const item = this.map[key];\\n        this.map[key] = { duration, value, timestamp: Date.now() };\\n\\n        if (item && !this.#isExpired(item.duration, item.timestamp)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    get(key: number): number {\\n        const item = this.map[key];\\n        return item && !this.#isExpired(item.duration, item.timestamp) ? item.value: -1\\n    }\\n\\n    count(): number {\\n        return Object.keys(this.map).reduce((prev, curr) => {\\n            const { duration, timestamp } = this.map[curr];\\n            if (!this.#isExpired(duration, timestamp)) {\\n                return prev + 1\\n            }\\n            return prev;\\n        }, 0)\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass TimeLimitedCache {\\n    map = {}\\n\\n    constructor() {}\\n\\n    #isExpired(duration, timestamp) {\\n        return (Date.now() - timestamp) > duration;\\n    }\\n    \\n    set(key: number, value: number, duration: number): boolean {\\n        const item = this.map[key];\\n        this.map[key] = { duration, value, timestamp: Date.now() };\\n\\n        if (item && !this.#isExpired(item.duration, item.timestamp)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    get(key: number): number {\\n        const item = this.map[key];\\n        return item && !this.#isExpired(item.duration, item.timestamp) ? item.value: -1\\n    }\\n\\n    count(): number {\\n        return Object.keys(this.map).reduce((prev, curr) => {\\n            const { duration, timestamp } = this.map[curr];\\n            if (!this.#isExpired(duration, timestamp)) {\\n                return prev + 1\\n            }\\n            return prev;\\n        }, 0)\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674056,
                "title": "solution-with-step-by-step-commented-code-explanations",
                "content": "# Intuition\\nThe problem \"core\" can be reduced to:\\nHow do you add items to a hashmap and delete them after n seconds?\\nThe rest just builds on that.\\n\\n# Approach\\n\\nStep-by-step of how I got to the resulting code:\\n\\n1. I\\'ve first dealt with the intuition part:\\n`How do you add items to a hashmap and delete them after n seconds?`\\n\\n```\\n// get a hashmap:\\nthis.hash = {};\\n// set the item\\nthis.hash[key] = value;\\n// and then set a timer to delete it:\\nsetTimeout(() => {\\n    delete this.hash[key];\\n}, duration);\\n```\\n\\n2. Problem asks us to override the value as well as the counter, so I\\'ve had to do the following changes:\\n\\n```\\n// 1. I\\'ve had to actually keep track of the timer id, so now I do not only\\n// store the value, but also the timer id.\\n// So from: this.hash[key] = value; we now have:\\nthis.hash[key] = [value, timerID];\\n\\n// I do this because if I have an initial timer with timerID1 of 500,\\n// and another timer with timerID2 of 1000 for the same key,\\n// if I DO NOT clear timerID1, at t = 500ms, our value will get cleared\\n\\n// Further, we can do:\\nlet timerID = setTimeout(() => {}, t);\\n// and THEN use timerID:\\nthis.hash[key] = [value, timerID];\\n// we can do this because the setTimeout function is async:\\n// i.e. we trigger and forget;\\n// whereas our main function execution continues with the next lines.\\n\\n// So when do we clear the timeout?\\n// It\\'s when we override the value,\\n// as we want to discard everything we had before:\\nif(this.hash[key] !== undefined) {\\n    // get the previous timer that we\\'re discarding\\n    let prevTimer = this.hash[key][1];\\n    // and clear it:\\n    clearTimeout(prevTimer);\\n}\\n```\\nThis was my thought process.\\nHope this helps! :)\\n\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.hash = {};\\n};\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let isInHash = false;\\n\\n    // if key/val is in hash, we need to clear the timeout\\n    // to prevent the key being deleted at a random/unwanted time\\n    if(this.hash[key] !== undefined) {\\n        isInHash = true;\\n        let prevTimer = this.hash[key][1];\\n        clearTimeout(prevTimer);\\n    }\\n\\n    // add to hash / update hash\\n    let timerID = setTimeout(() => {\\n        delete this.hash[key];\\n    }, duration);\\n    // we can do this after the setTimeout, as setTimeout is async.\\n    this.hash[key] = [value, timerID];\\n\\n    return isInHash;\\n};\\n\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.hash[key] !== undefined ? this.hash[key][0] : -1;\\n};\\n\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.hash).length;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n// get a hashmap:\\nthis.hash = {};\\n// set the item\\nthis.hash[key] = value;\\n// and then set a timer to delete it:\\nsetTimeout(() => {\\n    delete this.hash[key];\\n}, duration);\\n```\n```\\n// 1. I\\'ve had to actually keep track of the timer id, so now I do not only\\n// store the value, but also the timer id.\\n// So from: this.hash[key] = value; we now have:\\nthis.hash[key] = [value, timerID];\\n\\n// I do this because if I have an initial timer with timerID1 of 500,\\n// and another timer with timerID2 of 1000 for the same key,\\n// if I DO NOT clear timerID1, at t = 500ms, our value will get cleared\\n\\n// Further, we can do:\\nlet timerID = setTimeout(() => {}, t);\\n// and THEN use timerID:\\nthis.hash[key] = [value, timerID];\\n// we can do this because the setTimeout function is async:\\n// i.e. we trigger and forget;\\n// whereas our main function execution continues with the next lines.\\n\\n// So when do we clear the timeout?\\n// It\\'s when we override the value,\\n// as we want to discard everything we had before:\\nif(this.hash[key] !== undefined) {\\n    // get the previous timer that we\\'re discarding\\n    let prevTimer = this.hash[key][1];\\n    // and clear it:\\n    clearTimeout(prevTimer);\\n}\\n```\n```\\nvar TimeLimitedCache = function() {\\n    this.hash = {};\\n};\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let isInHash = false;\\n\\n    // if key/val is in hash, we need to clear the timeout\\n    // to prevent the key being deleted at a random/unwanted time\\n    if(this.hash[key] !== undefined) {\\n        isInHash = true;\\n        let prevTimer = this.hash[key][1];\\n        clearTimeout(prevTimer);\\n    }\\n\\n    // add to hash / update hash\\n    let timerID = setTimeout(() => {\\n        delete this.hash[key];\\n    }, duration);\\n    // we can do this after the setTimeout, as setTimeout is async.\\n    this.hash[key] = [value, timerID];\\n\\n    return isInHash;\\n};\\n\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.hash[key] !== undefined ? this.hash[key][0] : -1;\\n};\\n\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.hash).length;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3664354,
                "title": "99-recursive-solution",
                "content": "# Intuition\\nWe need to recursively call `setTimeout` while new `TimeLimitedCache.set(key)` are supplied within cache liftime.re\\n\\n# Approach\\n`lll()` is a function that calls `setTimeout` recursively for some `key`, while new `TimeLimitedCache.set(key)` are called. When `TimeLimitedCache.set(key)`is called, and `setTimeout`\\'s callback already executed in callstack, it will break recursion and set map\\'s value to -1. Otherwise we return `this.pairs.get(key) ? true : false`, which will return true or false in accordance with description.\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.pairs = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const vol = this.pairs.get(key);\\n    const ans = vol && (vol !== -1) ? true : false\\n    this.pairs.set(key, {\\n        val: value,\\n        dur: duration,\\n        index: (vol?.index ?? 0) + 1,\\n    });\\n    const lll = (duration, ind) => {\\n        setTimeout(() => {\\n            const volIn =  this.pairs.get(key);\\n            if (ind === volIn.index) {\\n                this.pairs.set(key, {\\n                    ...volIn,\\n                    val: -1\\n                });\\n                return ans;\\n            }\\n            lll(volIn.dur, volIn.index)\\n        }, duration)\\n    }\\n    lll(duration, this.pairs.get(key).index);\\n    return ans;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.pairs.get(key)?.val ?? -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let sum = 0;\\n    for (let [key, value] of this.pairs) {\\n        if (value.val !== -1) sum++;\\n    }\\n    return sum;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.pairs = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const vol = this.pairs.get(key);\\n    const ans = vol && (vol !== -1) ? true : false\\n    this.pairs.set(key, {\\n        val: value,\\n        dur: duration,\\n        index: (vol?.index ?? 0) + 1,\\n    });\\n    const lll = (duration, ind) => {\\n        setTimeout(() => {\\n            const volIn =  this.pairs.get(key);\\n            if (ind === volIn.index) {\\n                this.pairs.set(key, {\\n                    ...volIn,\\n                    val: -1\\n                });\\n                return ans;\\n            }\\n            lll(volIn.dur, volIn.index)\\n        }, duration)\\n    }\\n    lll(duration, this.pairs.get(key).index);\\n    return ans;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.pairs.get(key)?.val ?? -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let sum = 0;\\n    for (let [key, value] of this.pairs) {\\n        if (value.val !== -1) sum++;\\n    }\\n    return sum;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3537409,
                "title": "9-line-solution",
                "content": "# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.data = {};\\n    this.active = 0;\\n};\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const prevActive = !!this.data[key]?.isActive;\\n    prevActive ? clearTimeout(this.data[key].timeoutId) : this.active++;\\n    const timeoutId = setTimeout(() => {\\n        this.active--;\\n        this.data[key].isActive = false;\\n    },duration);\\n    this.data[key] = {\\n        isActive: true,\\n        value,\\n        timeoutId\\n    }\\n    return prevActive;\\n};\\n\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.data[key]?.isActive ? this.data[key].value : -1;\\n};\\n\\nTimeLimitedCache.prototype.count = function() {\\n    return this.active;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.data = {};\\n    this.active = 0;\\n};\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const prevActive = !!this.data[key]?.isActive;\\n    prevActive ? clearTimeout(this.data[key].timeoutId) : this.active++;\\n    const timeoutId = setTimeout(() => {\\n        this.active--;\\n        this.data[key].isActive = false;\\n    },duration);\\n    this.data[key] = {\\n        isActive: true,\\n        value,\\n        timeoutId\\n    }\\n    return prevActive;\\n};\\n\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.data[key]?.isActive ? this.data[key].value : -1;\\n};\\n\\nTimeLimitedCache.prototype.count = function() {\\n    return this.active;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3537140,
                "title": "javascript-solution",
                "content": "\\n```\\n\\nvar TimeLimitedCache = function() {\\n    this.cache={};\\n    \\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    if (this.cache[key] && this.cache[key].timer){\\n        clearTimeout(this.cache[key].timer);\\n        this.cache[key].value=value;\\n        this.cache[key].timer=setTimeout(()=>{\\n            this.remove(key);\\n        }, duration);\\n        return true;\\n    }else{\\n        this.cache[key]={\\n            value:value,\\n            timer:setTimeout(()=>{\\n                this.remove(key);\\n            }, duration)\\n        };\\n        return false;\\n    }\\n    \\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (this.cache[key] && this.cache[key].timer){\\n        return this.cache[key].value;\\n    }else{\\n        return -1;\\n    }\\n    \\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let count=0;\\n    for(const key in this.cache){\\n        if(this.cache[key].timer){\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n\\nTimeLimitedCache.prototype.remove=function(key){\\n    delete this.cache[key];\\n};\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar TimeLimitedCache = function() {\\n    this.cache={};\\n    \\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    if (this.cache[key] && this.cache[key].timer){\\n        clearTimeout(this.cache[key].timer);\\n        this.cache[key].value=value;\\n        this.cache[key].timer=setTimeout(()=>{\\n            this.remove(key);\\n        }, duration);\\n        return true;\\n    }else{\\n        this.cache[key]={\\n            value:value,\\n            timer:setTimeout(()=>{\\n                this.remove(key);\\n            }, duration)\\n        };\\n        return false;\\n    }\\n    \\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (this.cache[key] && this.cache[key].timer){\\n        return this.cache[key].value;\\n    }else{\\n        return -1;\\n    }\\n    \\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let count=0;\\n    for(const key in this.cache){\\n        if(this.cache[key].timer){\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n\\nTimeLimitedCache.prototype.remove=function(key){\\n    delete this.cache[key];\\n};\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3536560,
                "title": "day-14-easy-solution-in-js",
                "content": "\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.cache={}\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let currTime=new Date();\\n    currTime.setTime(currTime.getTime()+duration);\\n    if(this.cache[key]){\\n        this.cache[key]={value:value,expired_at:currTime.getTime()}\\n        return true;\\n    }else{\\n        this.cache[key]={value:value,expired_at:currTime.getTime()}\\n        return false;\\n    }\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    key = key.toString()\\n    if(this.cache[key] && this.cache[key].expired_at >= (new Date()).getTime())\\n        return this.cache[key].value;\\n    return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let time = (new Date()).getTime();\\n    let el = Object.keys(this.cache).filter(key => {\\n        if(this.cache[key].expired_at >= time) return true;\\n        else return false;\\n    })\\n    return el.length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cache={}\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let currTime=new Date();\\n    currTime.setTime(currTime.getTime()+duration);\\n    if(this.cache[key]){\\n        this.cache[key]={value:value,expired_at:currTime.getTime()}\\n        return true;\\n    }else{\\n        this.cache[key]={value:value,expired_at:currTime.getTime()}\\n        return false;\\n    }\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    key = key.toString()\\n    if(this.cache[key] && this.cache[key].expired_at >= (new Date()).getTime())\\n        return this.cache[key].value;\\n    return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let time = (new Date()).getTime();\\n    let el = Object.keys(this.cache).filter(key => {\\n        if(this.cache[key].expired_at >= time) return true;\\n        else return false;\\n    })\\n    return el.length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3536501,
                "title": "using-settimeout-cleartimeout-typescript",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse setTimeout reference to remove key from cache & while setting, store the setTimeout reference along the value to later clear it.\\n\\n# Code\\n```\\nclass TimeLimitedCache {\\n    cache: Map<number, any>;\\n    constructor() {\\n        this.cache = new Map();\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        let existed: boolean = this.cache.has(key);\\n        if (existed) \\n            clearTimeout(this.cache.get(key).ref);\\n        this.cache.set(key, {\\n            value,\\n            ref: setTimeout(() => {\\n                this.cache.delete(key);\\n            }, duration)\\n        });\\n        return existed;\\n    }\\n\\n    get(key: number): number {\\n        return this.cache.has(key) ? this.cache.get(key).value : -1;\\n    }\\n\\n    count(): number {\\n        return this.cache.size;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass TimeLimitedCache {\\n    cache: Map<number, any>;\\n    constructor() {\\n        this.cache = new Map();\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        let existed: boolean = this.cache.has(key);\\n        if (existed) \\n            clearTimeout(this.cache.get(key).ref);\\n        this.cache.set(key, {\\n            value,\\n            ref: setTimeout(() => {\\n                this.cache.delete(key);\\n            }, duration)\\n        });\\n        return existed;\\n    }\\n\\n    get(key: number): number {\\n        return this.cache.has(key) ? this.cache.get(key).value : -1;\\n    }\\n\\n    count(): number {\\n        return this.cache.size;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444346,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.cache = {}\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let currentTime = new Date();\\n    currentTime.setTime(currentTime.getTime() + duration);\\n    if(this.cache[key]){\\n        this.cache[key] = {value: value, expired_at: currentTime.getTime()}\\n        return true;\\n    }else{\\n        this.cache[key] = {value: value, expired_at: currentTime.getTime()}\\n        return false;\\n    }\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    key = key.toString()\\n    if(this.cache[key] && this.cache[key].expired_at >= (new Date()).getTime())\\n        return this.cache[key].value;\\n    return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let time = (new Date()).getTime();\\n    let el = Object.keys(this.cache).filter(key => {\\n        if(this.cache[key].expired_at >= time) return true;\\n        else return false;\\n    })\\n    return el.length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cache = {}\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let currentTime = new Date();\\n    currentTime.setTime(currentTime.getTime() + duration);\\n    if(this.cache[key]){\\n        this.cache[key] = {value: value, expired_at: currentTime.getTime()}\\n        return true;\\n    }else{\\n        this.cache[key] = {value: value, expired_at: currentTime.getTime()}\\n        return false;\\n    }\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    key = key.toString()\\n    if(this.cache[key] && this.cache[key].expired_at >= (new Date()).getTime())\\n        return this.cache[key].value;\\n    return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let time = (new Date()).getTime();\\n    let el = Object.keys(this.cache).filter(key => {\\n        if(this.cache[key].expired_at >= time) return true;\\n        else return false;\\n    })\\n    return el.length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3415784,
                "title": "settimeout-simple-solution-make-value-undefined-after-duration",
                "content": "\\n# Code\\n```\\n\\nvar TimeLimitedCache = function() {\\n    \\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    \\n\\n    if(this.keys == undefined){\\n        this.keys = [key];\\n    }else{\\n        if(this.keys.includes(key)){\\n\\n        }else{\\n            let arr = this.keys;\\n            arr.push(key);\\n            this.keys = arr;\\n        }\\n      //  console.log(this.keys)\\n    }\\n\\n    if(this[key]){\\n        clearTimeout(this[key].timeoutid);\\n        if(this[key].value!=undefined){\\n            this[key] = {\\n            value:value,\\n             expireAt :function(){\\n                 let localid = setTimeout(()=>{\\n                     this.value = undefined;\\n                 },duration);\\n                 return localid;\\n             },\\n             isExpired:false,\\n         }\\n         this[key].timeoutid = this[key].expireAt();\\n        }\\n       // console.log(\\'ket after exists \\'+key, \\' \\',value,\\' \\',this[key],\\' \\',Date.now())\\n\\n        return true;\\n    }\\n    this[key] = {\\n        value:value,\\n        isExpired:false,\\n        expireAt :function(){\\n                 let localid = setTimeout(()=>{\\n                     this.value = undefined;\\n                 },duration)\\n                 return localid;\\n             },\\n    }\\n    this[key].timeoutid = this[key].expireAt();\\n    return false\\n\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    \\n    if(this[key]){\\n        if(this[key].value == undefined){    \\n            return -1;\\n        }\\n        return this[key].value;\\n    }\\n    return -1;\\n\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let c = 0;\\n       this.keys.forEach((x,index)=>{\\n           if(this[x].value!=undefined){\\n               c++;\\n           }\\n        })\\n        return c;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar TimeLimitedCache = function() {\\n    \\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    \\n\\n    if(this.keys == undefined){\\n        this.keys = [key];\\n    }else{\\n        if(this.keys.includes(key)){\\n\\n        }else{\\n            let arr = this.keys;\\n            arr.push(key);\\n            this.keys = arr;\\n        }\\n      //  console.log(this.keys)\\n    }\\n\\n    if(this[key]){\\n        clearTimeout(this[key].timeoutid);\\n        if(this[key].value!=undefined){\\n            this[key] = {\\n            value:value,\\n             expireAt :function(){\\n                 let localid = setTimeout(()=>{\\n                     this.value = undefined;\\n                 },duration);\\n                 return localid;\\n             },\\n             isExpired:false,\\n         }\\n         this[key].timeoutid = this[key].expireAt();\\n        }\\n       // console.log(\\'ket after exists \\'+key, \\' \\',value,\\' \\',this[key],\\' \\',Date.now())\\n\\n        return true;\\n    }\\n    this[key] = {\\n        value:value,\\n        isExpired:false,\\n        expireAt :function(){\\n                 let localid = setTimeout(()=>{\\n                     this.value = undefined;\\n                 },duration)\\n                 return localid;\\n             },\\n    }\\n    this[key].timeoutid = this[key].expireAt();\\n    return false\\n\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    \\n    if(this[key]){\\n        if(this[key].value == undefined){    \\n            return -1;\\n        }\\n        return this[key].value;\\n    }\\n    return -1;\\n\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let c = 0;\\n       this.keys.forEach((x,index)=>{\\n           if(this[x].value!=undefined){\\n               c++;\\n           }\\n        })\\n        return c;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3414930,
                "title": "simple-approach-beats-78",
                "content": "# Approach\\nThe problem requires implementing a TimeLimitedCache class that allows storing key-value pairs with an associated expiration time in milliseconds. The class should support the following methods:\\n\\n- set(key, value, duration): sets a key-value pair with a specified duration in milliseconds. If the key already exists and hasn\\'t expired, it should overwrite the existing value and duration and return true, otherwise return false.\\n- get(key): retrieves the value of a given key if it exists and hasn\\'t expired, otherwise returns -1.\\n- count(): returns the count of keys that haven\\'t expired.\\nTo implement this, I would first create a class constructor that initializes an empty object to store the key-value pairs and a counter to keep track of the number of keys that haven\\'t expired.\\n\\nThen, I would implement the set method by checking if the key already exists and hasn\\'t expired. If it has, then overwrite the existing value and duration and return true, otherwise add a new key-value pair with the specified duration and return false. In both cases, I would update the counter accordingly.\\n\\nNext, I would implement the get method by checking if the key exists and hasn\\'t expired. If it has, then return the value, otherwise return -1.\\n\\nFinally, I would implement the count method to return the counter that keeps track of the number of keys that haven\\'t expired.\\n\\nThroughout the implementation, I would make sure to handle all edge cases and to update the expiration time of the key-value pairs whenever a get or set operation is performed.\\n\\n# Complexity\\nOverall, the set method has a time complexity of O(1) and a space complexity of O(n), the get method has a time complexity of O(1) and a space complexity of O(1), and the count method has a time complexity of O(n) and a space complexity of O(1).\\n# Code\\n```\\nclass TimeLimitedCache {\\n  constructor() {\\n    this.cache = new Map();\\n  }\\n\\n  set(key, value, duration) {\\n    const currentTime = Date.now();\\n    const expireTime = currentTime + duration;\\n    if (this.cache.has(key) && this.cache.get(key).expireTime > currentTime) {\\n      this.cache.set(key, { value, expireTime });\\n      return true;\\n    } else {\\n      this.cache.set(key, { value, expireTime });\\n      return false;\\n    }\\n  }\\n\\n  get(key) {\\n    const currentTime = Date.now();\\n    if (this.cache.has(key) && this.cache.get(key).expireTime > currentTime) {\\n      return this.cache.get(key).value;\\n    } else {\\n      return -1;\\n    }\\n  }\\n\\n  count() {\\n    const currentTime = Date.now();\\n    let count = 0;\\n    for (const [key, value] of this.cache.entries()) {\\n      if (value.expireTime > currentTime) {\\n        count++;\\n      } else {\\n        this.cache.delete(key);\\n      }\\n    }\\n    return count;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass TimeLimitedCache {\\n  constructor() {\\n    this.cache = new Map();\\n  }\\n\\n  set(key, value, duration) {\\n    const currentTime = Date.now();\\n    const expireTime = currentTime + duration;\\n    if (this.cache.has(key) && this.cache.get(key).expireTime > currentTime) {\\n      this.cache.set(key, { value, expireTime });\\n      return true;\\n    } else {\\n      this.cache.set(key, { value, expireTime });\\n      return false;\\n    }\\n  }\\n\\n  get(key) {\\n    const currentTime = Date.now();\\n    if (this.cache.has(key) && this.cache.get(key).expireTime > currentTime) {\\n      return this.cache.get(key).value;\\n    } else {\\n      return -1;\\n    }\\n  }\\n\\n  count() {\\n    const currentTime = Date.now();\\n    let count = 0;\\n    for (const [key, value] of this.cache.entries()) {\\n      if (value.expireTime > currentTime) {\\n        count++;\\n      } else {\\n        this.cache.delete(key);\\n      }\\n    }\\n    return count;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407610,
                "title": "easy-to-understand-by-using-settimeout",
                "content": "# Code\\n```\\nvar TimeLimitedCache = function() {\\n  this.cache = {};\\n  this.c = 0;\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n  if (this.cache[key] !== undefined) {\\n    if (this.cache[key].value === -1) {\\n      this.c++;\\n    } else {\\n      res = true;\\n      clearTimeout(this.cache[key].timeout);\\n    }\\n    this.cache[key] = {\\n      value: value,\\n      timeout: setTimeout(() => {\\n        this.cache[key].value = -1;\\n        this.c--;\\n      }, duration),\\n    }\\n  } else {\\n    this.c++;\\n    this.cache[key] = {\\n      value,\\n      timeout: setTimeout(() => {\\n        this.cache[key].value = -1;\\n        this.c--;\\n      }, duration),\\n    }\\n  }\\n  return res;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n  return this.cache[key]?.value || -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n  return this.c;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n  this.cache = {};\\n  this.c = 0;\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n  if (this.cache[key] !== undefined) {\\n    if (this.cache[key].value === -1) {\\n      this.c++;\\n    } else {\\n      res = true;\\n      clearTimeout(this.cache[key].timeout);\\n    }\\n    this.cache[key] = {\\n      value: value,\\n      timeout: setTimeout(() => {\\n        this.cache[key].value = -1;\\n        this.c--;\\n      }, duration),\\n    }\\n  } else {\\n    this.c++;\\n    this.cache[key] = {\\n      value,\\n      timeout: setTimeout(() => {\\n        this.cache[key].value = -1;\\n        this.c--;\\n      }, duration),\\n    }\\n  }\\n  return res;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n  return this.cache[key]?.value || -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n  return this.c;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3736707,
                "title": "easy-understandable-solution-without-this-operator-beats-96-time-complexity",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![leet_code-expiring cache.png](https://assets.leetcode.com/users/images/a9e96359-f911-4f27-a541-b3944125725d_1688824583.0570786.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHandling expiring cache with setTimeout(registering it in the event loop) and clearing from event loop with clearTimeout. Rest it is just basic object validation w.r.t to the scenerio   \\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nlet obj \\nvar TimeLimitedCache = function() {\\n    obj = {}\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    if( !Object.hasOwn(obj, key) || obj[key].val === null  ){\\n        obj[key] = {val : value}\\n        const timerId = setTimeout(() => obj[key].val = null , duration)\\n        obj[key].timer = timerId\\n        return false\\n    }\\n    obj[key].val = value\\n    clearTimeout(obj[key].timer)\\n    const timerId = setTimeout(() => obj[key].val = null , duration)\\n    obj[key].timer = timerId\\n    return true \\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(!obj[key]) return -1\\n    let tmp = obj[key].val\\n    return tmp !== null ? tmp : -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let count = 0\\n    for( key in obj ){\\n        if( obj[key].val !== null ) {++count }\\n    }\\n    return count\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```\\nPlease comment and upvote if anyone needs detailed explaination :-)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet obj \\nvar TimeLimitedCache = function() {\\n    obj = {}\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    if( !Object.hasOwn(obj, key) || obj[key].val === null  ){\\n        obj[key] = {val : value}\\n        const timerId = setTimeout(() => obj[key].val = null , duration)\\n        obj[key].timer = timerId\\n        return false\\n    }\\n    obj[key].val = value\\n    clearTimeout(obj[key].timer)\\n    const timerId = setTimeout(() => obj[key].val = null , duration)\\n    obj[key].timer = timerId\\n    return true \\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(!obj[key]) return -1\\n    let tmp = obj[key].val\\n    return tmp !== null ? tmp : -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let count = 0\\n    for( key in obj ){\\n        if( obj[key].val !== null ) {++count }\\n    }\\n    return count\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3601594,
                "title": "solution-typescript-javescript",
                "content": "# Code\\n``` typescript []\\ntype MapEntry = { value: number, timeout: NodeJS.Timeout };\\n\\nclass TimeLimitedCache {\\n  cache = new Map<number, MapEntry>();\\n\\n  set(key: number, value: number, duration: number) {\\n    const valueInCache = this.cache.get(key);\\n    if (valueInCache) {\\n      clearTimeout(valueInCache.timeout);\\n    }\\n    const timeout = setTimeout(() => this.cache.delete(key), duration);\\n    this.cache.set(key, { value, timeout });\\n    return Boolean(valueInCache);\\n  }\\n\\n  get(key: number) {\\n    return this.cache.has(key) ? this.cache.get(key).value : -1;\\n  }\\n\\n  count() {\\n    return this.cache.size;\\n  }\\n};\\n```\\n``` javascript []\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map();\\n};\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const valueInCache = this.cache.get(key);\\n    if (valueInCache) {\\n      clearTimeout(valueInCache.timeout);\\n    }\\n    const timeout = setTimeout(() => this.cache.delete(key), duration);\\n    this.cache.set(key, { value, timeout });\\n    return Boolean(valueInCache);\\n};\\n\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.cache.has(key) ? this.cache.get(key).value : -1;\\n};\\n\\nTimeLimitedCache.prototype.count = function() {\\n     return this.cache.size;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` typescript []\\ntype MapEntry = { value: number, timeout: NodeJS.Timeout };\\n\\nclass TimeLimitedCache {\\n  cache = new Map<number, MapEntry>();\\n\\n  set(key: number, value: number, duration: number) {\\n    const valueInCache = this.cache.get(key);\\n    if (valueInCache) {\\n      clearTimeout(valueInCache.timeout);\\n    }\\n    const timeout = setTimeout(() => this.cache.delete(key), duration);\\n    this.cache.set(key, { value, timeout });\\n    return Boolean(valueInCache);\\n  }\\n\\n  get(key: number) {\\n    return this.cache.has(key) ? this.cache.get(key).value : -1;\\n  }\\n\\n  count() {\\n    return this.cache.size;\\n  }\\n};\\n```\n``` javascript []\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map();\\n};\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const valueInCache = this.cache.get(key);\\n    if (valueInCache) {\\n      clearTimeout(valueInCache.timeout);\\n    }\\n    const timeout = setTimeout(() => this.cache.delete(key), duration);\\n    this.cache.set(key, { value, timeout });\\n    return Boolean(valueInCache);\\n};\\n\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.cache.has(key) ? this.cache.get(key).value : -1;\\n};\\n\\nTimeLimitedCache.prototype.count = function() {\\n     return this.cache.size;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539243,
                "title": "javascript-challenge-solution-day-14-with-comments-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TimeLimitedCache {\\n  constructor() {\\n    this.store = {};\\n  }\\n\\n  set(key, value, duration) {\\n    const now = new Date().getTime();\\n    const expirationTime = now + duration;\\n    if (this.store.hasOwnProperty(key) && this.store[key].expirationTime >= now) {\\n      this.store[key].value = value;\\n      this.store[key].expirationTime = expirationTime;\\n      return true; // return true if key exists and value and duration are updated\\n    } else {\\n      this.store[key] = { value, expirationTime };\\n      return false; // return false if key doesn\\'t exist and a new key-value pair is added\\n    }\\n  }\\n\\n  get(key) {\\n    const now = new Date().getTime();\\n    const cachedValue = this.store[key];\\n    if (cachedValue && cachedValue.expirationTime >= now) {\\n      return cachedValue.value; // return cached value if it exists and hasn\\'t expired\\n    } else {\\n      delete this.store[key]; // remove expired or non-existent value from cache\\n      return -1; // return -1 to indicate cache miss\\n    }\\n  }\\n\\n  count() {\\n    let count = 0;\\n    const now = new Date().getTime();\\n    for (const key in this.store) {\\n      const cachedValue = this.store[key];\\n      if (cachedValue && cachedValue.expirationTime >= now) {\\n        count++; // increment count for each un-expired key\\n      } else {\\n        delete this.store[key]; // remove expired or non-existent value from cache\\n      }\\n    }\\n    return count;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass TimeLimitedCache {\\n  constructor() {\\n    this.store = {};\\n  }\\n\\n  set(key, value, duration) {\\n    const now = new Date().getTime();\\n    const expirationTime = now + duration;\\n    if (this.store.hasOwnProperty(key) && this.store[key].expirationTime >= now) {\\n      this.store[key].value = value;\\n      this.store[key].expirationTime = expirationTime;\\n      return true; // return true if key exists and value and duration are updated\\n    } else {\\n      this.store[key] = { value, expirationTime };\\n      return false; // return false if key doesn\\'t exist and a new key-value pair is added\\n    }\\n  }\\n\\n  get(key) {\\n    const now = new Date().getTime();\\n    const cachedValue = this.store[key];\\n    if (cachedValue && cachedValue.expirationTime >= now) {\\n      return cachedValue.value; // return cached value if it exists and hasn\\'t expired\\n    } else {\\n      delete this.store[key]; // remove expired or non-existent value from cache\\n      return -1; // return -1 to indicate cache miss\\n    }\\n  }\\n\\n  count() {\\n    let count = 0;\\n    const now = new Date().getTime();\\n    for (const key in this.store) {\\n      const cachedValue = this.store[key];\\n      if (cachedValue && cachedValue.expirationTime >= now) {\\n        count++; // increment count for each un-expired key\\n      } else {\\n        delete this.store[key]; // remove expired or non-existent value from cache\\n      }\\n    }\\n    return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536627,
                "title": "easy-in-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n`Caching` is a common technique used to improve the performance of applications by storing frequently accessed data in a faster and more accessible location. In this problem, we are tasked with implementing a time-limited cache, where each key-value pair has an associated expiration time. Once the expiration time is reached, the key becomes inaccessible.\\n\\nTo solve this problem, we can use a data structure that allows fast insertion, retrieval, and deletion, such as a Map in JavaScript. The Map data structure provides a convenient way to store key-value pairs and easily access them using the key. Additionally, we can utilize setTimeout to schedule the expiration of keys after a specified duration.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a `class` named \"`TimeLimitedCache`\" that initializes an empty `Map` to store the` key-value` pairs.\\n- Implement the \"`set`\" method to accept a `key`, `value`, and `duration`.\\n- Check if the `key` already `exists` in the `cache` using the Map\\'s \"`get`\" method.\\n- If it exists, clear the previous expiration `timer` using `clearTimeout`. Set a new expiration `timer` using `setTimeout` and associate it with the key in the Map. Return true if the key already `existed`, and `false` otherwise.\\n- Implement the \"`get`\" method to accept a `key` and return the associated `value` if the `key` exists in the `cache` and has not expired. If the key does not exist or has expired, return -1.\\n- Implement the \"count\" method to return the number of non-expired keys in the `cache` by returning the `size` of the Map.\\n\\n# Code\\n``` \\nclass TimeLimitedCache {\\n  constructor() {\\n    this.cache = new Map();\\n  }\\n\\n  set(key, value, duration) {\\n    const keyExist = this.cache.get(key);\\n    if (keyExist)\\n      clearTimeout(keyExist.timer);\\n    const timer = setTimeout(() => this.cache.delete(key), duration);\\n    this.cache.set(key, {value, timer});\\n    return Boolean(keyExist);\\n  }\\n\\n  get(key) {\\n    return this.cache.has(key) ? this.cache.get(key).value : -1;\\n  }\\n\\n  count() {\\n    return this.cache.size;\\n  }\\n}\\n```\\nVideo solution :---- youtube.com/watch?v=-AmlEzEgRF4\\n![Time (setTimeout).png](https://assets.leetcode.com/users/images/c72f7bc7-13d5-4347-a879-53184edae42e_1684380181.0587213.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` \\nclass TimeLimitedCache {\\n  constructor() {\\n    this.cache = new Map();\\n  }\\n\\n  set(key, value, duration) {\\n    const keyExist = this.cache.get(key);\\n    if (keyExist)\\n      clearTimeout(keyExist.timer);\\n    const timer = setTimeout(() => this.cache.delete(key), duration);\\n    this.cache.set(key, {value, timer});\\n    return Boolean(keyExist);\\n  }\\n\\n  get(key) {\\n    return this.cache.has(key) ? this.cache.get(key).value : -1;\\n  }\\n\\n  count() {\\n    return this.cache.size;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418988,
                "title": "javascript-map-keep-value-and-timerid",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep timerId together with value, set timeout for deleting value. If we try set a new value clear previous timeout and set a new one.\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let cached = this.cache.get(key);\\n\\n    if (cached) {\\n        clearTimeout(cached.timerId);        \\n    }\\n\\n    let timerId = setTimeout(() => this.cache.delete(key), duration);\\n\\n    this.cache.set(key, { value, timerId });\\n\\n    return !!cached;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.cache.get(key)?.value || -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.size;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let cached = this.cache.get(key);\\n\\n    if (cached) {\\n        clearTimeout(cached.timerId);        \\n    }\\n\\n    let timerId = setTimeout(() => this.cache.delete(key), duration);\\n\\n    this.cache.set(key, { value, timerId });\\n\\n    return !!cached;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.cache.get(key)?.value || -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.size;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4093235,
                "title": "a-simple-solution-with-cleartimeout",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\ninterface LimitedValue {\\n\\tvalue: number\\n\\ttimeout: any\\n\\tdestroy: (timeoutId: number, key: number, pairs: Map<number, LimitedValue>) => void\\n}\\n\\nclass TimeLimitedCache {\\n    pairs = new Map<number, LimitedValue>()\\n\\n    constructor() {\\n        \\n    }\\n    \\n    set(key: number, value: number, duration: number): boolean {\\n\\t\\t\\t\\tconst foundPair = this.pairs.get(key)\\n\\t\\t\\t\\tif (foundPair) foundPair.destroy(foundPair.timeout, key, this.pairs)\\n\\t\\t\\t\\tthis.pairs.set(key, {\\n\\t\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\t\\ttimeout: setTimeout(() => {\\n\\t\\t\\t\\t\\t\\tconst {timeout, destroy} = this.pairs.get(key)\\n\\t\\t\\t\\t\\t\\tdestroy(timeout, key, this.pairs)\\n\\t\\t\\t\\t\\t}, duration),\\n\\t\\t\\t\\t \\tdestroy: (timeout, key, pairs) => {\\n\\t\\t\\t\\t\\t\\tclearTimeout(timeout)\\n\\t\\t\\t\\t\\t\\tpairs.delete(key)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t})\\n\\t\\t\\t\\treturn !!foundPair\\n    }\\n\\n    get(key: number): number {\\n      const foundPair = this.pairs.get(key)\\n\\t\\t\\treturn foundPair ? foundPair.value : -1\\n    }\\n\\n    count(): number {\\n       return this.pairs.size\\n    }\\n}\\n\\n/**\\n * const timeLimitedCache = new TimeLimitedCache()\\n * timeLimitedCache.set(1, 42, 1000); // false\\n * timeLimitedCache.get(1) // 42\\n * timeLimitedCache.count() // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ninterface LimitedValue {\\n\\tvalue: number\\n\\ttimeout: any\\n\\tdestroy: (timeoutId: number, key: number, pairs: Map<number, LimitedValue>) => void\\n}\\n\\nclass TimeLimitedCache {\\n    pairs = new Map<number, LimitedValue>()\\n\\n    constructor() {\\n        \\n    }\\n    \\n    set(key: number, value: number, duration: number): boolean {\\n\\t\\t\\t\\tconst foundPair = this.pairs.get(key)\\n\\t\\t\\t\\tif (foundPair) foundPair.destroy(foundPair.timeout, key, this.pairs)\\n\\t\\t\\t\\tthis.pairs.set(key, {\\n\\t\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\t\\ttimeout: setTimeout(() => {\\n\\t\\t\\t\\t\\t\\tconst {timeout, destroy} = this.pairs.get(key)\\n\\t\\t\\t\\t\\t\\tdestroy(timeout, key, this.pairs)\\n\\t\\t\\t\\t\\t}, duration),\\n\\t\\t\\t\\t \\tdestroy: (timeout, key, pairs) => {\\n\\t\\t\\t\\t\\t\\tclearTimeout(timeout)\\n\\t\\t\\t\\t\\t\\tpairs.delete(key)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t})\\n\\t\\t\\t\\treturn !!foundPair\\n    }\\n\\n    get(key: number): number {\\n      const foundPair = this.pairs.get(key)\\n\\t\\t\\treturn foundPair ? foundPair.value : -1\\n    }\\n\\n    count(): number {\\n       return this.pairs.size\\n    }\\n}\\n\\n/**\\n * const timeLimitedCache = new TimeLimitedCache()\\n * timeLimitedCache.set(1, 42, 1000); // false\\n * timeLimitedCache.get(1) // 42\\n * timeLimitedCache.count() // 1\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091957,
                "title": "time-limited-cache-with-key-value-expiration",
                "content": "# Intuition\\nTo solve this problem, I need to create a cache that allows setting key-value pairs with a specified expiration duration and provides methods to get values and count the number of non-expired keys. I can use a data structure like a Map to store the key-value pairs along with their expiration times.\\n\\n# Approach\\n1. I will use a Map called `cache` to store key-value pairs. Each entry in this Map will contain the key, value, and expiration time.\\n2. When setting a key-value pair using the `set` method, I will check if the key already exists in the cache and whether it has expired. If it has not expired, I will update the value and expiration time; otherwise, I will create a new entry.\\n3. The `get` method will check if the key exists in the cache and whether it has expired. If it has not expired, it will return the associated value; otherwise, it will remove the key from the cache and return -1.\\n4. The `count` method will iterate through the entries in the cache, checking their expiration times. It will count the number of non-expired keys and return that count.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n1. Setting a key-value pair (set method): $$O(1)$$ on average, as Map operations are typically $$O(1)$$.\\n2. Getting a value (get method): $$O(1)$$ on average, as Map operations are typically $$O(1)$$.\\n3. Counting non-expired keys (count method): $$O(n)$$, where n is the number of entries in the cache. In the worst case, we iterate through all entries to count non-expired keys.\\n\\n- Space complexity:\\nThe space complexity depends on the number of key-value pairs in the cache, which is $$O(n)$$, where n is the number of entries in the cache.\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map();\\n};\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const currentTime = Date.now();\\n    const expirationTime = currentTime + duration;\\n    \\n    if (this.cache.has(key)) {\\n        const { expiration } = this.cache.get(key);\\n        if (expiration > currentTime) {\\n            this.cache.set(key, { value, expiration: expirationTime });\\n            return true;\\n        }\\n    }\\n    this.cache.set(key, { value, expiration: expirationTime });\\n    return false;\\n};\\n\\nTimeLimitedCache.prototype.get = function(key) {\\n    const currentTime = Date.now();  \\n    if (this.cache.has(key)) {\\n        const { value, expiration } = this.cache.get(key);\\n        \\n        if (expiration > currentTime) {\\n            return value;\\n        } else {\\n            this.cache.delete(key);\\n        }\\n    }\\n    return -1;\\n};\\n\\nTimeLimitedCache.prototype.count = function() {\\n    const currentTime = Date.now();\\n    let count = 0;\\n    \\n    for (const [key, { expiration }] of this.cache.entries()) {\\n        if (expiration > currentTime) {\\n            count++;\\n        } else {\\n            this.cache.delete(key);\\n        }\\n    }\\n    return count;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map();\\n};\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const currentTime = Date.now();\\n    const expirationTime = currentTime + duration;\\n    \\n    if (this.cache.has(key)) {\\n        const { expiration } = this.cache.get(key);\\n        if (expiration > currentTime) {\\n            this.cache.set(key, { value, expiration: expirationTime });\\n            return true;\\n        }\\n    }\\n    this.cache.set(key, { value, expiration: expirationTime });\\n    return false;\\n};\\n\\nTimeLimitedCache.prototype.get = function(key) {\\n    const currentTime = Date.now();  \\n    if (this.cache.has(key)) {\\n        const { value, expiration } = this.cache.get(key);\\n        \\n        if (expiration > currentTime) {\\n            return value;\\n        } else {\\n            this.cache.delete(key);\\n        }\\n    }\\n    return -1;\\n};\\n\\nTimeLimitedCache.prototype.count = function() {\\n    const currentTime = Date.now();\\n    let count = 0;\\n    \\n    for (const [key, { expiration }] of this.cache.entries()) {\\n        if (expiration > currentTime) {\\n            count++;\\n        } else {\\n            this.cache.delete(key);\\n        }\\n    }\\n    return count;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4089338,
                "title": "not-bad-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TimeLimitedCache {\\nconstructor() {\\n\\tthis.cache = {}\\n  this.timeouts = {}\\n}\\n  get(key) {\\n\\t\\treturn this.cache[key] || -1\\n  }\\n  set (key, value, duration) {\\n    let isExisted = false\\n  \\tif (this.timeouts[key]) {\\n      isExisted = true\\n      clearTimeout(this.timeouts[key])\\n    } \\n  \\n\\t\\tthis.cache[key] = value\\n    this.timeouts[key] = setTimeout(() => {\\n    \\tdelete this.cache[key]\\n      clearTimeout(this.timeouts[key])\\n    }, duration)\\n\\n    return isExisted\\n  }\\n  count() {\\n    return Object.keys(this.cache).length\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass TimeLimitedCache {\\nconstructor() {\\n\\tthis.cache = {}\\n  this.timeouts = {}\\n}\\n  get(key) {\\n\\t\\treturn this.cache[key] || -1\\n  }\\n  set (key, value, duration) {\\n    let isExisted = false\\n  \\tif (this.timeouts[key]) {\\n      isExisted = true\\n      clearTimeout(this.timeouts[key])\\n    } \\n  \\n\\t\\tthis.cache[key] = value\\n    this.timeouts[key] = setTimeout(() => {\\n    \\tdelete this.cache[key]\\n      clearTimeout(this.timeouts[key])\\n    }, duration)\\n\\n    return isExisted\\n  }\\n  count() {\\n    return Object.keys(this.cache).length\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086091,
                "title": "simple-solution-using-settimeout-and-cleartimeout-functions",
                "content": "# Intuition\\nwe need to keep track of the function that deletes the key in a map and delete it / clear it if same key is being passed again.\\n\\n# Approach\\nmake use of 2 separate maps. One map has key value pair. Other map has key and value as setTimeout function that deletes the key in a given time.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n\\nvar TimeLimitedCache = function() {\\n    this.obj = {}\\n    this.promise = {}\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    this.obj[key] = value\\n    let flag      = false\\n    if(this.promise[key]) {\\n        clearTimeout(this.promise[key])\\n        delete this.promise[key]\\n        flag = true\\n    }\\n    this.promise[key] = setTimeout(()=> delete this.obj[key], duration)\\n    return flag\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    console.log(String(this.obj[key]))\\n    if(String(this.obj[key])!= \\'undefined\\'){\\n        return this.obj[key]\\n    }\\n    return -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.obj).length\\n};\\n\\n/**\\n * const timeLimitedCache = new TimeLimitedCache()\\n * timeLimitedCache.set(1, 42, 1000); // false\\n * timeLimitedCache.get(1) // 42\\n * timeLimitedCache.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar TimeLimitedCache = function() {\\n    this.obj = {}\\n    this.promise = {}\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    this.obj[key] = value\\n    let flag      = false\\n    if(this.promise[key]) {\\n        clearTimeout(this.promise[key])\\n        delete this.promise[key]\\n        flag = true\\n    }\\n    this.promise[key] = setTimeout(()=> delete this.obj[key], duration)\\n    return flag\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    console.log(String(this.obj[key]))\\n    if(String(this.obj[key])!= \\'undefined\\'){\\n        return this.obj[key]\\n    }\\n    return -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.obj).length\\n};\\n\\n/**\\n * const timeLimitedCache = new TimeLimitedCache()\\n * timeLimitedCache.set(1, 42, 1000); // false\\n * timeLimitedCache.get(1) // 42\\n * timeLimitedCache.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4082041,
                "title": "prototypes-using-object-and-expiration-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar TimeLimitedCache = function() {\\n    this.values = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const valueExists = Boolean(this.values[key]);\\n    const initialDate = new Date();\\n    const initialTimestamp = initialDate.getTime();\\n    const updatedTimestamp = initialTimestamp + duration;\\n    const newDateWithMilliseconds = new Date(updatedTimestamp);\\n    const newVal = {value: value, expiration: newDateWithMilliseconds};\\n    this.values[key] = newVal;\\n    return valueExists;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    const valueFromObject = this.values[key];\\n    if(valueFromObject){\\n    const currentDate = new Date();\\n\\n// Compare the two dates\\nif (valueFromObject.expiration < currentDate) {\\n  return -1;\\n} else {\\n  return valueFromObject.value;\\n}\\n    }else{\\n        return -1;\\n    }\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n        const valuesFromObject = Object.values(this.values);\\n    const currentDate = new Date();\\n        const unExpiredValues = valuesFromObject.filter(item => item.expiration >= currentDate);\\n    return unExpiredValues.length;\\n};\\n\\n/**\\n * const timeLimitedCache = new TimeLimitedCache()\\n * timeLimitedCache.set(1, 42, 1000); // false\\n * timeLimitedCache.get(1) // 42\\n * timeLimitedCache.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar TimeLimitedCache = function() {\\n    this.values = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const valueExists = Boolean(this.values[key]);\\n    const initialDate = new Date();\\n    const initialTimestamp = initialDate.getTime();\\n    const updatedTimestamp = initialTimestamp + duration;\\n    const newDateWithMilliseconds = new Date(updatedTimestamp);\\n    const newVal = {value: value, expiration: newDateWithMilliseconds};\\n    this.values[key] = newVal;\\n    return valueExists;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    const valueFromObject = this.values[key];\\n    if(valueFromObject){\\n    const currentDate = new Date();\\n\\n// Compare the two dates\\nif (valueFromObject.expiration < currentDate) {\\n  return -1;\\n} else {\\n  return valueFromObject.value;\\n}\\n    }else{\\n        return -1;\\n    }\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n        const valuesFromObject = Object.values(this.values);\\n    const currentDate = new Date();\\n        const unExpiredValues = valuesFromObject.filter(item => item.expiration >= currentDate);\\n    return unExpiredValues.length;\\n};\\n\\n/**\\n * const timeLimitedCache = new TimeLimitedCache()\\n * timeLimitedCache.set(1, 42, 1000); // false\\n * timeLimitedCache.get(1) // 42\\n * timeLimitedCache.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081855,
                "title": "typescript-solution",
                "content": "# Code\\n```\\nclass TimeLimitedCache {\\n    private _keys: {\\n        key: number,\\n        value: number,\\n        duration: number\\n    }[] = []\\n\\n    constructor() {\\n        \\n    }\\n    \\n    set(key: number, value: number, duration: number): boolean {\\n        const keyIndex = this._keys.findIndex(k => k.key === key)\\n        if (keyIndex !== -1 && this._keys[keyIndex].duration > Date.now()) {\\n            this._keys[keyIndex].key = key\\n            this._keys[keyIndex].value = value\\n            this._keys[keyIndex].duration = Date.now() + duration\\n            return true\\n        }\\n\\n        this._keys.push({\\n            key: key,\\n            value: value,\\n            duration: Date.now() + duration\\n        })\\n        return false\\n    }\\n\\n    get(key: number): number {\\n        const wantedKey = this._keys.find(k => k.key === key)\\n        if (!wantedKey || wantedKey.duration < Date.now()) return -1\\n\\n\\n        return wantedKey.value\\n    }\\n\\n    count(): number {\\n        let keyCount = 0\\n        this._keys.forEach(key => {\\n            if (key.duration > Date.now()) keyCount++\\n        })\\n        return keyCount\\n    }\\n}\\n\\n/**\\n * const timeLimitedCache = new TimeLimitedCache()\\n * timeLimitedCache.set(1, 42, 1000); // false\\n * timeLimitedCache.get(1) // 42\\n * timeLimitedCache.count() // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass TimeLimitedCache {\\n    private _keys: {\\n        key: number,\\n        value: number,\\n        duration: number\\n    }[] = []\\n\\n    constructor() {\\n        \\n    }\\n    \\n    set(key: number, value: number, duration: number): boolean {\\n        const keyIndex = this._keys.findIndex(k => k.key === key)\\n        if (keyIndex !== -1 && this._keys[keyIndex].duration > Date.now()) {\\n            this._keys[keyIndex].key = key\\n            this._keys[keyIndex].value = value\\n            this._keys[keyIndex].duration = Date.now() + duration\\n            return true\\n        }\\n\\n        this._keys.push({\\n            key: key,\\n            value: value,\\n            duration: Date.now() + duration\\n        })\\n        return false\\n    }\\n\\n    get(key: number): number {\\n        const wantedKey = this._keys.find(k => k.key === key)\\n        if (!wantedKey || wantedKey.duration < Date.now()) return -1\\n\\n\\n        return wantedKey.value\\n    }\\n\\n    count(): number {\\n        let keyCount = 0\\n        this._keys.forEach(key => {\\n            if (key.duration > Date.now()) keyCount++\\n        })\\n        return keyCount\\n    }\\n}\\n\\n/**\\n * const timeLimitedCache = new TimeLimitedCache()\\n * timeLimitedCache.set(1, 42, 1000); // false\\n * timeLimitedCache.get(1) // 42\\n * timeLimitedCache.count() // 1\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076244,
                "title": "javascript-timelimitedcache",
                "content": "\\n```\\n\\nvar TimeLimitedCache = function() {\\n    \\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const d = new Date()\\n    let ret = false\\n    if(!this[key])\\n        this[key] = {}\\n    else    \\n        ret = true\\n    this[key].value = value\\n    this[key].expires = d.getTime() + duration\\n    return ret\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    const d = new Date()\\n    return d.getTime() < this[key]?.expires ? this[key].value : -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this).reduce((acc, next) => {\\n        const d = new Date()\\n        return d.getTime() < this[next].expires ? acc + 1 : acc\\n    }, 0)\\n};\\n\\n/**\\n * const timeLimitedCache = new TimeLimitedCache()\\n * timeLimitedCache.set(1, 42, 1000); // false\\n * timeLimitedCache.get(1) // 42\\n * timeLimitedCache.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar TimeLimitedCache = function() {\\n    \\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const d = new Date()\\n    let ret = false\\n    if(!this[key])\\n        this[key] = {}\\n    else    \\n        ret = true\\n    this[key].value = value\\n    this[key].expires = d.getTime() + duration\\n    return ret\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    const d = new Date()\\n    return d.getTime() < this[key]?.expires ? this[key].value : -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this).reduce((acc, next) => {\\n        const d = new Date()\\n        return d.getTime() < this[next].expires ? acc + 1 : acc\\n    }, 0)\\n};\\n\\n/**\\n * const timeLimitedCache = new TimeLimitedCache()\\n * timeLimitedCache.set(1, 42, 1000); // false\\n * timeLimitedCache.get(1) // 42\\n * timeLimitedCache.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074082,
                "title": "beats-89-26-of-users-runtime-and-beats-75-17-of-users-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor set method, we need to add key, value and duration into the cache. If key is already present then we will update value,duration and return True but if key is not present in cache we will add key, value , duration to the cache and return false.\\n\\nFor get method, we will return value if the duration is not expired else we will return -1;\\n\\nFor count method , we need to return the count of non expired duration items only.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI am using a Map ds, to store values.\\nfor set method, check if data has key then, update it with new values and return true, else add key,value and duration pair into data and return false;\\nfor get method, check if data has the given key && given key\\'s duration has not expired , then return its associated value.\\nfor count , i am using a count & and a date variable, use forEach on data and for each item in data check if duration > date(Date.now()) , increment the count++ and outside the loop return count; \\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar TimeLimitedCache = function () {\\n  this.data = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function (key, value, duration) {\\n  if (this.data.has(key)) {\\n    this.data.set(key, { value: value, duration: Date.now() + duration });\\n    return true;\\n  }\\n  this.data.set(key, { value: value, duration: Date.now() + duration });\\n  return false;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function (key) {\\n  if (this.data.has(key)&&this.data.get(key).duration > Date.now()) {\\n    return this.data.get(key).value;\\n  }\\n  return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function () {\\n  let count = 0;\\n  let date=Date.now()\\n  this.data.forEach((value, key)=>{\\n    if(value.duration > date) {\\n      count++;\\n    }\\n  })\\n    return count;\\n};\\n\\n/**\\n * const timeLimitedCache = new TimeLimitedCache()\\n * timeLimitedCache.set(1, 42, 1000); // false\\n * timeLimitedCache.get(1) // 42\\n * timeLimitedCache.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar TimeLimitedCache = function () {\\n  this.data = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function (key, value, duration) {\\n  if (this.data.has(key)) {\\n    this.data.set(key, { value: value, duration: Date.now() + duration });\\n    return true;\\n  }\\n  this.data.set(key, { value: value, duration: Date.now() + duration });\\n  return false;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function (key) {\\n  if (this.data.has(key)&&this.data.get(key).duration > Date.now()) {\\n    return this.data.get(key).value;\\n  }\\n  return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function () {\\n  let count = 0;\\n  let date=Date.now()\\n  this.data.forEach((value, key)=>{\\n    if(value.duration > date) {\\n      count++;\\n    }\\n  })\\n    return count;\\n};\\n\\n/**\\n * const timeLimitedCache = new TimeLimitedCache()\\n * timeLimitedCache.set(1, 42, 1000); // false\\n * timeLimitedCache.get(1) // 42\\n * timeLimitedCache.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4069719,
                "title": "javascript-solution-using-inbuilt-map",
                "content": "# Code\\n```\\n\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let alreadyExists = this.cache.get(key);\\n    if(alreadyExists){\\n      clearTimeout(alreadyExists.timeoutId);\\n    }\\n    let timeoutId = setTimeout(()=>{\\n      this.cache.delete(key);\\n    },duration)\\n\\n    this.cache.set(key,{value,timeoutId})\\n    return Boolean(alreadyExists);\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(this.cache.has(key))\\n      return this.cache.get(key).value;\\n    return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.size;\\n};\\n\\n/**\\n * const timeLimitedCache = new TimeLimitedCache()\\n * timeLimitedCache.set(1, 42, 1000); // false\\n * timeLimitedCache.get(1) // 42\\n * timeLimitedCache.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let alreadyExists = this.cache.get(key);\\n    if(alreadyExists){\\n      clearTimeout(alreadyExists.timeoutId);\\n    }\\n    let timeoutId = setTimeout(()=>{\\n      this.cache.delete(key);\\n    },duration)\\n\\n    this.cache.set(key,{value,timeoutId})\\n    return Boolean(alreadyExists);\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(this.cache.has(key))\\n      return this.cache.get(key).value;\\n    return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.size;\\n};\\n\\n/**\\n * const timeLimitedCache = new TimeLimitedCache()\\n * timeLimitedCache.set(1, 42, 1000); // false\\n * timeLimitedCache.get(1) // 42\\n * timeLimitedCache.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4064181,
                "title": "best-space-complexity-solution",
                "content": "# Code\\n```\\n\\nvar TimeLimitedCache = function() {\\n    \\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let alreadyExists = false\\n    if(this[key]){\\n        alreadyExists = true\\n    }\\n    this[key] = value\\n    setTimeout(()=>{\\n        if(this[key]===value)\\n        delete this[key]\\n    },duration)\\n    \\n    if(alreadyExists){\\n        return true\\n    }else{\\n        return false\\n    }\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    console.log(this[key])\\n    if(this[key]){\\n        return this[key]\\n    }else{\\n        return -1\\n    }\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n   return Object.keys(this).length\\n};\\n\\n/**\\n * const timeLimitedCache = new TimeLimitedCache()\\n * timeLimitedCache.set(1, 42, 1000); // false\\n * timeLimitedCache.get(1) // 42\\n * timeLimitedCache.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar TimeLimitedCache = function() {\\n    \\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let alreadyExists = false\\n    if(this[key]){\\n        alreadyExists = true\\n    }\\n    this[key] = value\\n    setTimeout(()=>{\\n        if(this[key]===value)\\n        delete this[key]\\n    },duration)\\n    \\n    if(alreadyExists){\\n        return true\\n    }else{\\n        return false\\n    }\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    console.log(this[key])\\n    if(this[key]){\\n        return this[key]\\n    }else{\\n        return -1\\n    }\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n   return Object.keys(this).length\\n};\\n\\n/**\\n * const timeLimitedCache = new TimeLimitedCache()\\n * timeLimitedCache.set(1, 42, 1000); // false\\n * timeLimitedCache.get(1) // 42\\n * timeLimitedCache.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4053160,
                "title": "simple-and-clean",
                "content": "# Intuition\\nKeep a map in memory and use the JavaScript built in function `setTimeout` to control the key expiration. Keep the `count` always ready in memory to avoid calculation.\\n\\n# Approach\\n\\nStarted writing the some class variables to control the object\\'s state: `_values` and `_count`.\\n\\n- `set(key, value, duration)` verifies if the key exists, and if so: clear it from the hashtable and if not, just add it. Be careful to control the `_count` variable here.\\n\\n- `get(key)` accesses directly the map using the `key` parameter.\\n\\n- `count()` just returns the in memory `_count` variable.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar TimeLimitedCache = function() {\\n    \\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\n\\nconst _values = {};\\nlet _count = 0;\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n\\n    let exists = false;\\n    if (_values[key] !== undefined) {\\n        clearTimeout(_values[key].timeout)\\n        _count--;\\n        exists = true;\\n    }\\n    _values[key] = {\\n        value, \\n        duration, \\n        timeout: setTimeout(()=> {\\n            _values[key] = undefined;\\n            _count--\\n        }, duration)\\n    }\\n    _count++;\\n    return exists;    \\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (_values[key] !== undefined) {\\n        return _values[key].value;\\n    } else {\\n        return -1\\n    }\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return _count;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar TimeLimitedCache = function() {\\n    \\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\n\\nconst _values = {};\\nlet _count = 0;\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n\\n    let exists = false;\\n    if (_values[key] !== undefined) {\\n        clearTimeout(_values[key].timeout)\\n        _count--;\\n        exists = true;\\n    }\\n    _values[key] = {\\n        value, \\n        duration, \\n        timeout: setTimeout(()=> {\\n            _values[key] = undefined;\\n            _count--\\n        }, duration)\\n    }\\n    _count++;\\n    return exists;    \\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (_values[key] !== undefined) {\\n        return _values[key].value;\\n    } else {\\n        return -1\\n    }\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return _count;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046892,
                "title": "with-timeout",
                "content": "\\n\\n# Code\\n```\\n\\nvar TimeLimitedCache = function() {\\n    // console.log(this)\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let t = this;\\n    let flag = false\\n    if(this[key]) {\\n        clearTimeout(this[key][\"timer\"])\\n        flag = true\\n    }\\n    this[key] = {\\n        value : value,\\n        timer : setTimeout(()=>{\\n                delete t[key];\\n            },duration)\\n    };\\n    \\n    return flag;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n   return this[key] ? this[key][\"value\"] : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this).length\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar TimeLimitedCache = function() {\\n    // console.log(this)\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let t = this;\\n    let flag = false\\n    if(this[key]) {\\n        clearTimeout(this[key][\"timer\"])\\n        flag = true\\n    }\\n    this[key] = {\\n        value : value,\\n        timer : setTimeout(()=>{\\n                delete t[key];\\n            },duration)\\n    };\\n    \\n    return flag;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n   return this[key] ? this[key][\"value\"] : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this).length\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041907,
                "title": "easy-solution-with-settimeout",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar TimeLimitedCache = function() {\\n  this.cache= {}\\n};\\n\\n/** \\n* @param {number} key\\n* @param {number} value\\n* @param {number} duration time until expiration in ms\\n* @return {boolean} if un-expired key already existed\\n*/\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n  if(this.cache[key])\\n  {\\n      this.cache[key].value = value\\n      clearTimeout(this.cache[key].timeout)\\n      this.cache[key].timeout = setTimeout(() => {\\n        delete this.cache[key]\\n       }, duration)  \\n      return true\\n    }\\n  this.cache[key] = {\\n    value\\n  }\\n  this.cache[key].timeout = setTimeout(() => {\\n    delete this.cache[key]\\n   }, duration)\\n  return false\\n  \\n};\\n\\n/** \\n* @param {number} key\\n* @return {number} value associated with key\\n*/\\nTimeLimitedCache.prototype.get = function(key) {\\n  if(this.cache[key])\\n  {\\n    return this.cache[key].value\\n    \\n  }\\n  return -1\\n};\\n\\n/** \\n* @return {number} count of non-expired keys\\n*/\\nTimeLimitedCache.prototype.count = function() {\\n  return Object.keys(this.cache).length\\n}\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar TimeLimitedCache = function() {\\n  this.cache= {}\\n};\\n\\n/** \\n* @param {number} key\\n* @param {number} value\\n* @param {number} duration time until expiration in ms\\n* @return {boolean} if un-expired key already existed\\n*/\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n  if(this.cache[key])\\n  {\\n      this.cache[key].value = value\\n      clearTimeout(this.cache[key].timeout)\\n      this.cache[key].timeout = setTimeout(() => {\\n        delete this.cache[key]\\n       }, duration)  \\n      return true\\n    }\\n  this.cache[key] = {\\n    value\\n  }\\n  this.cache[key].timeout = setTimeout(() => {\\n    delete this.cache[key]\\n   }, duration)\\n  return false\\n  \\n};\\n\\n/** \\n* @param {number} key\\n* @return {number} value associated with key\\n*/\\nTimeLimitedCache.prototype.get = function(key) {\\n  if(this.cache[key])\\n  {\\n    return this.cache[key].value\\n    \\n  }\\n  return -1\\n};\\n\\n/** \\n* @return {number} count of non-expired keys\\n*/\\nTimeLimitedCache.prototype.count = function() {\\n  return Object.keys(this.cache).length\\n}\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041856,
                "title": "done-with-set-timeout",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar TimeLimitedCache = function() {\\n  this.cache= {}\\n  \\n};\\n\\n/** \\n* @param {number} key\\n* @param {number} value\\n* @param {number} duration time until expiration in ms\\n* @return {boolean} if un-expired key already existed\\n*/\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n  if(this.cache[key])\\n  {\\n  //   let index = this.cache.findIndex(item => item.key === key)\\n      this.cache[key].value = value\\n      this.cache[key].duration = duration\\n      clearTimeout(this.cache[key].timeout)\\n      this.cache[key].timeout = setTimeout(() => {\\n        delete this.cache[key]\\n       }, this.cache[key].duration)  \\n      return true\\n    }\\n  this.cache[key] = {\\n    value,\\n    duration\\n  }\\n  this.cache[key].timeout = setTimeout(() => {\\n    delete this.cache[key]\\n   }, this.cache[key].duration)\\n  \\n  return false\\n  \\n};\\n\\n/** \\n* @param {number} key\\n* @return {number} value associated with key\\n*/\\nTimeLimitedCache.prototype.get = function(key) {\\n  if(this.cache[key])\\n  {\\n    return this.cache[key].value\\n    \\n  }\\n  return -1\\n};\\n\\n/** \\n* @return {number} count of non-expired keys\\n*/\\nTimeLimitedCache.prototype.count = function() {\\n  return Object.keys(this.cache).length\\n}\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar TimeLimitedCache = function() {\\n  this.cache= {}\\n  \\n};\\n\\n/** \\n* @param {number} key\\n* @param {number} value\\n* @param {number} duration time until expiration in ms\\n* @return {boolean} if un-expired key already existed\\n*/\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n  if(this.cache[key])\\n  {\\n  //   let index = this.cache.findIndex(item => item.key === key)\\n      this.cache[key].value = value\\n      this.cache[key].duration = duration\\n      clearTimeout(this.cache[key].timeout)\\n      this.cache[key].timeout = setTimeout(() => {\\n        delete this.cache[key]\\n       }, this.cache[key].duration)  \\n      return true\\n    }\\n  this.cache[key] = {\\n    value,\\n    duration\\n  }\\n  this.cache[key].timeout = setTimeout(() => {\\n    delete this.cache[key]\\n   }, this.cache[key].duration)\\n  \\n  return false\\n  \\n};\\n\\n/** \\n* @param {number} key\\n* @return {number} value associated with key\\n*/\\nTimeLimitedCache.prototype.get = function(key) {\\n  if(this.cache[key])\\n  {\\n    return this.cache[key].value\\n    \\n  }\\n  return -1\\n};\\n\\n/** \\n* @return {number} count of non-expired keys\\n*/\\nTimeLimitedCache.prototype.count = function() {\\n  return Object.keys(this.cache).length\\n}\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041605,
                "title": "w",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar TimeLimitedCache = function() {\\n    this.pairs = new Map()\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\nconst vol = this.pairs.get(key);\\nconst ans = vol && (vol !== -1) ? true : false\\nthis.pairs.set(key, {\\nval: value,\\ndur: duration,\\nindex: (vol?.index ?? 0) + 1,\\n});\\nconst lll = (duration, ind) => {\\nsetTimeout(() => {\\nconst volIn =  this.pairs.get(key);\\nif (ind === volIn.index) {\\nthis.pairs.set(key, {\\n...volIn,\\nval: -1\\n});\\nreturn ans;\\n}\\nlll(volIn.dur, volIn.index)\\n}, duration)\\n}\\nlll(duration, this.pairs.get(key).index);\\nreturn ans;\\n};\\n/** \\n* @param {number} key\\n* @return {number} value associated with key\\n*/\\nTimeLimitedCache.prototype.get = function(key) {\\nreturn this.pairs.get(key)?.val ?? -1\\n};\\n/** \\n* @return {number} count of non-expired keys\\n*/\\nTimeLimitedCache.prototype.count = function() {\\nlet sum = 0;\\nfor (let [key, value] of this.pairs) {\\nif (value.val !== -1) sum++;\\n}\\nreturn sum;\\n};\\n/**\\n* Your TimeLimitedCache object will be instantiated and called as such:\\n* var obj = new TimeLimitedCache()\\n* obj.set(1, 42, 1000); // false\\n* obj.get(1) // 42\\n* obj.count() // 1\\n*/\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar TimeLimitedCache = function() {\\n    this.pairs = new Map()\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\nconst vol = this.pairs.get(key);\\nconst ans = vol && (vol !== -1) ? true : false\\nthis.pairs.set(key, {\\nval: value,\\ndur: duration,\\nindex: (vol?.index ?? 0) + 1,\\n});\\nconst lll = (duration, ind) => {\\nsetTimeout(() => {\\nconst volIn =  this.pairs.get(key);\\nif (ind === volIn.index) {\\nthis.pairs.set(key, {\\n...volIn,\\nval: -1\\n});\\nreturn ans;\\n}\\nlll(volIn.dur, volIn.index)\\n}, duration)\\n}\\nlll(duration, this.pairs.get(key).index);\\nreturn ans;\\n};\\n/** \\n* @param {number} key\\n* @return {number} value associated with key\\n*/\\nTimeLimitedCache.prototype.get = function(key) {\\nreturn this.pairs.get(key)?.val ?? -1\\n};\\n/** \\n* @return {number} count of non-expired keys\\n*/\\nTimeLimitedCache.prototype.count = function() {\\nlet sum = 0;\\nfor (let [key, value] of this.pairs) {\\nif (value.val !== -1) sum++;\\n}\\nreturn sum;\\n};\\n/**\\n* Your TimeLimitedCache object will be instantiated and called as such:\\n* var obj = new TimeLimitedCache()\\n* obj.set(1, 42, 1000); // false\\n* obj.get(1) // 42\\n* obj.count() // 1\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4040211,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar TimeLimitedCache = function () {\\n    this.pairs = new Map();\\n\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function (key, value, duration) {\\n    const vol = this.pairs.get(key);\\n    const ans = vol && (vol!== -1) ? true : false;\\n    this.pairs.set(key, {\\n        val: value,\\n        dur: duration,\\n        index: (vol?.index ?? 0) + 1,\\n    });\\n    const lll = (duration, ind) => {\\n        setTimeout(() => {\\n            const volIn = this.pairs.get(key);\\n            if (ind === volIn.index) {\\n                this.pairs.set(key, {\\n                    ...volIn,\\n                    val: -1\\n                });\\n                return ans;\\n            }\\n            lll(volIn.dur, volIn.index)\\n        }, duration)\\n    }\\n    lll(duration, this.pairs.get(key).index);\\n    return ans;\\n\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function (key) {\\n    return this.pairs.get(key)?.val ?? -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function () {\\n    let sum = 0;\\n    for (let [key, value] of this.pairs) {\\n        if (value.val !== -1) sum++;\\n    }\\n    return sum;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar TimeLimitedCache = function () {\\n    this.pairs = new Map();\\n\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function (key, value, duration) {\\n    const vol = this.pairs.get(key);\\n    const ans = vol && (vol!== -1) ? true : false;\\n    this.pairs.set(key, {\\n        val: value,\\n        dur: duration,\\n        index: (vol?.index ?? 0) + 1,\\n    });\\n    const lll = (duration, ind) => {\\n        setTimeout(() => {\\n            const volIn = this.pairs.get(key);\\n            if (ind === volIn.index) {\\n                this.pairs.set(key, {\\n                    ...volIn,\\n                    val: -1\\n                });\\n                return ans;\\n            }\\n            lll(volIn.dur, volIn.index)\\n        }, duration)\\n    }\\n    lll(duration, this.pairs.get(key).index);\\n    return ans;\\n\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function (key) {\\n    return this.pairs.get(key)?.val ?? -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function () {\\n    let sum = 0;\\n    for (let [key, value] of this.pairs) {\\n        if (value.val !== -1) sum++;\\n    }\\n    return sum;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4026882,
                "title": "easy-understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar TimeLimitedCache = function() {\\n    this.cache=new Map();\\n    this.timer;\\n    this.time=0;\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const { cache }=this;\\n\\n    const keyIsExist=cache.has(key);\\n    this.time=duration;\\n\\n    if(keyIsExist){      \\n      cache.set(key, value);\\n      clearTimeout(this.timer);\\n    }else{\\n      cache.set(key, value);\\n    }\\n\\n    this.timer=setTimeout(()=>{\\n        cache.delete(key);\\n    }, this.time);\\n\\n    return keyIsExist;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    const { cache }=this;\\n\\n    return cache.get(key) ?? -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    const { cache }=this;\\n\\n    return this.cache.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar TimeLimitedCache = function() {\\n    this.cache=new Map();\\n    this.timer;\\n    this.time=0;\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const { cache }=this;\\n\\n    const keyIsExist=cache.has(key);\\n    this.time=duration;\\n\\n    if(keyIsExist){      \\n      cache.set(key, value);\\n      clearTimeout(this.timer);\\n    }else{\\n      cache.set(key, value);\\n    }\\n\\n    this.timer=setTimeout(()=>{\\n        cache.delete(key);\\n    }, this.time);\\n\\n    return keyIsExist;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    const { cache }=this;\\n\\n    return cache.get(key) ?? -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    const { cache }=this;\\n\\n    return this.cache.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4024368,
                "title": "simple-solution-without-timers-86-65",
                "content": "# Intuition\\nLast sentence of this assignment stated that total function calls will not exceed 100. Therefore we don\\'t really care that much about the cache growing size, this means that we don\\'t really need to clean expired items.\\n\\n# Approach\\nStore expiry date together with the value in the cache. Each time we do get() and count() we check the expiry date accordingly.\\n\\n# Complexity\\n- Time complexity:\\n```\\n- set() constant time\\n- get() constant time\\n- count() O(N)\\n```\\n\\n- Space complexity:\\n```\\nO(N)\\n```\\n\\n# Code\\n```\\nclass TimeLimitedCache {  \\n    cache = new Map()\\n\\n    set(key, value, duration) {\\n        let isExist = this.get(key) != -1\\n        this.cache.set(key, [value, Date.now() + duration])\\n        return isExist\\n    }\\n\\n    get(key) {\\n        if (!this.cache.has(key)) return -1\\n        let [val, exp] = this.cache.get(key)\\n        if (exp <= Date.now()) {\\n            this.cache.delete(key)\\n            return -1\\n        }\\n        return val\\n    }\\n\\n    count() {\\n        let count = 0;\\n        for (let [key, val] of this.cache) {\\n            let exp = val[1]\\n            exp > Date.now()\\n                ? ++count\\n                : this.cache.delete(key)\\n        }\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n- set() constant time\\n- get() constant time\\n- count() O(N)\\n```\n```\\nO(N)\\n```\n```\\nclass TimeLimitedCache {  \\n    cache = new Map()\\n\\n    set(key, value, duration) {\\n        let isExist = this.get(key) != -1\\n        this.cache.set(key, [value, Date.now() + duration])\\n        return isExist\\n    }\\n\\n    get(key) {\\n        if (!this.cache.has(key)) return -1\\n        let [val, exp] = this.cache.get(key)\\n        if (exp <= Date.now()) {\\n            this.cache.delete(key)\\n            return -1\\n        }\\n        return val\\n    }\\n\\n    count() {\\n        let count = 0;\\n        for (let [key, val] of this.cache) {\\n            let exp = val[1]\\n            exp > Date.now()\\n                ? ++count\\n                : this.cache.delete(key)\\n        }\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018542,
                "title": "solution-with-comments-on-each-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Define the TimeLimitedCache class\\nvar TimeLimitedCache = function() {\\n    // Initialize the cache as a new Map object\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    // Check if the key already exists in the cache\\n    const existed = this.cache.has(key);\\n    \\n    // If the key already exists, cancel any previously scheduled deletion\\n    if (existed) {\\n        clearTimeout(this.cache.get(key).timeoutId);\\n    }\\n    \\n    // Set the value and timeoutId for the given key in the cache\\n    const timeoutId = setTimeout(() => this.cache.delete(key), duration);\\n    this.cache.set(key, {value, timeoutId});\\n    \\n    // Return whether the key already existed in the cache\\n    return existed;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    // Check if the key exists in the cache\\n    if (this.cache.has(key)) {\\n        // If the key exists, return its value\\n        return this.cache.get(key).value;\\n    } else {\\n        // If the key does not exist, return -1\\n        return -1;\\n    }\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    // Return the number of keys in the cache\\n    return this.cache.size;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Define the TimeLimitedCache class\\nvar TimeLimitedCache = function() {\\n    // Initialize the cache as a new Map object\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    // Check if the key already exists in the cache\\n    const existed = this.cache.has(key);\\n    \\n    // If the key already exists, cancel any previously scheduled deletion\\n    if (existed) {\\n        clearTimeout(this.cache.get(key).timeoutId);\\n    }\\n    \\n    // Set the value and timeoutId for the given key in the cache\\n    const timeoutId = setTimeout(() => this.cache.delete(key), duration);\\n    this.cache.set(key, {value, timeoutId});\\n    \\n    // Return whether the key already existed in the cache\\n    return existed;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    // Check if the key exists in the cache\\n    if (this.cache.has(key)) {\\n        // If the key exists, return its value\\n        return this.cache.get(key).value;\\n    } else {\\n        // If the key does not exist, return -1\\n        return -1;\\n    }\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    // Return the number of keys in the cache\\n    return this.cache.size;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014754,
                "title": "best-of-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar TimeLimitedCache = function() {\\n    this.pairs = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n     const vol = this.pairs.get(key);\\n    const ans = vol && (vol !== -1) ? true : false\\n    this.pairs.set(key, {\\n        val: value,\\n        dur: duration,\\n        index: (vol?.index ?? 0) + 1,\\n    });\\n    const lll = (duration, ind) => {\\n        setTimeout(() => {\\n            const volIn =  this.pairs.get(key);\\n            if (ind === volIn.index) {\\n                this.pairs.set(key, {\\n                    ...volIn,\\n                    val: -1\\n                });\\n                return ans;\\n            }\\n            lll(volIn.dur, volIn.index)\\n        }, duration)\\n    }\\n    lll(duration, this.pairs.get(key).index);\\n    return ans;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.pairs.get(key)?.val ?? -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let sum = 0;\\n    for (let [key, value] of this.pairs) {\\n        if (value.val !== -1) sum++;\\n    }\\n    return sum;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar TimeLimitedCache = function() {\\n    this.pairs = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n     const vol = this.pairs.get(key);\\n    const ans = vol && (vol !== -1) ? true : false\\n    this.pairs.set(key, {\\n        val: value,\\n        dur: duration,\\n        index: (vol?.index ?? 0) + 1,\\n    });\\n    const lll = (duration, ind) => {\\n        setTimeout(() => {\\n            const volIn =  this.pairs.get(key);\\n            if (ind === volIn.index) {\\n                this.pairs.set(key, {\\n                    ...volIn,\\n                    val: -1\\n                });\\n                return ans;\\n            }\\n            lll(volIn.dur, volIn.index)\\n        }, duration)\\n    }\\n    lll(duration, this.pairs.get(key).index);\\n    return ans;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.pairs.get(key)?.val ?? -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let sum = 0;\\n    for (let [key, value] of this.pairs) {\\n        if (value.val !== -1) sum++;\\n    }\\n    return sum;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011281,
                "title": "cache-solution",
                "content": "\\n```\\nvar TimeLimitedCache = function() {\\n    this.cache = {};\\n};\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const currentTime = Date.now();\\n    \\n    if (this.cache[key] && this.cache[key].expirationTime > currentTime) {\\n        this.cache[key].value = value;\\n        this.cache[key].expirationTime = currentTime + duration;\\n        return true;\\n    } else {\\n        this.cache[key] = {\\n            value: value,\\n            expirationTime: currentTime + duration\\n        };\\n        return false;\\n    }\\n};\\n\\nTimeLimitedCache.prototype.get = function(key) {\\n    const currentTime = Date.now();\\n    \\n    if (this.cache[key] && this.cache[key].expirationTime > currentTime) {\\n        return this.cache[key].value;\\n    } else {\\n        return -1;\\n    }\\n};\\n\\nTimeLimitedCache.prototype.count = function() {\\n    const currentTime = Date.now();\\n    let count = 0;\\n    \\n    for (const key in this.cache) {\\n        if (this.cache[key].expirationTime > currentTime) {\\n            count++;\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cache = {};\\n};\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const currentTime = Date.now();\\n    \\n    if (this.cache[key] && this.cache[key].expirationTime > currentTime) {\\n        this.cache[key].value = value;\\n        this.cache[key].expirationTime = currentTime + duration;\\n        return true;\\n    } else {\\n        this.cache[key] = {\\n            value: value,\\n            expirationTime: currentTime + duration\\n        };\\n        return false;\\n    }\\n};\\n\\nTimeLimitedCache.prototype.get = function(key) {\\n    const currentTime = Date.now();\\n    \\n    if (this.cache[key] && this.cache[key].expirationTime > currentTime) {\\n        return this.cache[key].value;\\n    } else {\\n        return -1;\\n    }\\n};\\n\\nTimeLimitedCache.prototype.count = function() {\\n    const currentTime = Date.now();\\n    let count = 0;\\n    \\n    for (const key in this.cache) {\\n        if (this.cache[key].expirationTime > currentTime) {\\n            count++;\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4009221,
                "title": "the-10x-approach-cross-platform-ttl",
                "content": "# Intuition\\nWhen we want to cache data but only for a limited amount of time, we need a mechanism to automatically remove the data after a certain duration. This can be achieved using JavaScript\\'s `setTimeout` function, which allows us to execute a function after a specified delay.\\n\\n# Approach\\n1. We use a `Map` to store our cache data. Each entry in the map consists of a key, a value, and a timeout ID.\\n2. When adding a new item to the cache using the `set` method:\\n   - If the key already exists, we clear the existing timeout to prevent premature deletion.\\n   - We then set a new timeout to delete the key after the specified duration.\\n   - The method returns `true` if the key existed before and `false` otherwise.\\n3. The `get` method retrieves the value associated with a key. If the key doesn\\'t exist, it returns `-1`.\\n4. The `count` method returns the number of items currently in the cache.\\n\\n# Complexity\\n- Time complexity:\\n  - `set`: $$O(1)$$ - Map operations (set, get, has) are average constant time.\\n  - `get`: $$O(1)$$\\n  - `count`: $$O(1)$$\\n\\n- Space complexity:\\n  - $$O(n)$$ where `n` is the number of items in the cache.\\n\\n# Code\\n```typescript\\nclass TimeLimitedCache {\\n    store: Map<number, {value:number,timeoutID: ReturnType<typeof setTimeout>}>;\\n    \\n    constructor() {\\n        this.store = new Map();\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        const exists = this.store.has(key);\\n\\n        // If the key already exists, clear the existing timeout.\\n        if (exists) clearTimeout(this.store.get(key)!.timeoutID);\\n\\n        // Set the new value and a timeout to delete the key after the specified duration.\\n        this.store.set(key, {value, timeoutID: setTimeout(() => this.store.delete(key), duration)});\\n\\n        return exists;\\n    }\\n\\n    get(key: number): number {\\n        return this.store.get(key)?.value || -1;\\n    }\\n\\n\\tcount(): number {\\n        return this.store.size;\\n    }\\n}\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "# Intuition\\nWhen we want to cache data but only for a limited amount of time, we need a mechanism to automatically remove the data after a certain duration. This can be achieved using JavaScript\\'s `setTimeout` function, which allows us to execute a function after a specified delay.\\n\\n# Approach\\n1. We use a `Map` to store our cache data. Each entry in the map consists of a key, a value, and a timeout ID.\\n2. When adding a new item to the cache using the `set` method:\\n   - If the key already exists, we clear the existing timeout to prevent premature deletion.\\n   - We then set a new timeout to delete the key after the specified duration.\\n   - The method returns `true` if the key existed before and `false` otherwise.\\n3. The `get` method retrieves the value associated with a key. If the key doesn\\'t exist, it returns `-1`.\\n4. The `count` method returns the number of items currently in the cache.\\n\\n# Complexity\\n- Time complexity:\\n  - `set`: $$O(1)$$ - Map operations (set, get, has) are average constant time.\\n  - `get`: $$O(1)$$\\n  - `count`: $$O(1)$$\\n\\n- Space complexity:\\n  - $$O(n)$$ where `n` is the number of items in the cache.\\n\\n# Code\\n```typescript\\nclass TimeLimitedCache {\\n    store: Map<number, {value:number,timeoutID: ReturnType<typeof setTimeout>}>;\\n    \\n    constructor() {\\n        this.store = new Map();\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        const exists = this.store.has(key);\\n\\n        // If the key already exists, clear the existing timeout.\\n        if (exists) clearTimeout(this.store.get(key)!.timeoutID);\\n\\n        // Set the new value and a timeout to delete the key after the specified duration.\\n        this.store.set(key, {value, timeoutID: setTimeout(() => this.store.delete(key), duration)});\\n\\n        return exists;\\n    }\\n\\n    get(key: number): number {\\n        return this.store.get(key)?.value || -1;\\n    }\\n\\n\\tcount(): number {\\n        return this.store.size;\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 4009023,
                "title": "ts-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TimeLimitedCache {\\n    values: Record<number, {value: number, life: ReturnType<typeof setTimeout>}>\\n    constructor() {\\n        this.values = {}\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        let result = false\\n        if (this.values[key]?.value)  {\\n            result = true\\n            clearTimeout(this.values[key].life)\\n        }\\n        this.values[key] = {value, life: null}\\n        this.values[key].life = setTimeout(() => {\\n            delete this.values[key]\\n        }, duration)\\n        return result\\n    }\\n\\n    get(key: number): number {\\n        return this.values[key]?.value ?? -1\\n    }\\n\\n\\tcount(): number {\\n        return Object.keys(this.values).length\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass TimeLimitedCache {\\n    values: Record<number, {value: number, life: ReturnType<typeof setTimeout>}>\\n    constructor() {\\n        this.values = {}\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        let result = false\\n        if (this.values[key]?.value)  {\\n            result = true\\n            clearTimeout(this.values[key].life)\\n        }\\n        this.values[key] = {value, life: null}\\n        this.values[key].life = setTimeout(() => {\\n            delete this.values[key]\\n        }, duration)\\n        return result\\n    }\\n\\n    get(key: number): number {\\n        return this.values[key]?.value ?? -1\\n    }\\n\\n\\tcount(): number {\\n        return Object.keys(this.values).length\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007181,
                "title": "simple-ts-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ninterface TimeLimitedCacheItem {\\n    value: number;\\n    duration: number;\\n    key: number;\\n}\\nclass TimeLimitedCache {\\n    cache = new Map<number, TimeLimitedCacheItem>();\\n    timersCache = new Map<number, any>();\\n    queue: TimeLimitedCacheItem[] = [];\\n    constructor() {\\n\\n    }\\n\\n    setTimerToDeleteKey() {\\n        while (this.queue.length > 0) {\\n            const el = this.queue.shift();\\n            const timerId = setTimeout(() => {\\n                this.cache.delete(el.key);\\n                this.timersCache.delete(el.key);\\n            }, el.duration);\\n            this.timersCache.set(el.key, timerId);\\n        }\\n    }\\n\\n    clearCacheTimer(key: number) {\\n        if (this.timersCache.has(key)) {\\n            clearTimeout(this.timersCache.get(key));\\n        }\\n    }\\n\\n    setToQueue(el: TimeLimitedCacheItem) {\\n        this.queue.push(el);\\n        this.setTimerToDeleteKey();\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        if (this.cache.has(key)) {\\n            this.clearCacheTimer(key);\\n            this.cache.set(key, {value, duration, key});\\n            this.setToQueue(this.cache.get(key));\\n            return true;\\n        } else {\\n            this.cache.set(key, {value, duration, key});\\n            this.setToQueue(this.cache.get(key));\\n            return false;\\n        }\\n    }\\n\\n    get(key: number): number {\\n        return this.cache.has(key) ? this.cache.get(key).value : -1;\\n    }\\n\\n\\tcount(): number {\\n        return this.cache.size;\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ninterface TimeLimitedCacheItem {\\n    value: number;\\n    duration: number;\\n    key: number;\\n}\\nclass TimeLimitedCache {\\n    cache = new Map<number, TimeLimitedCacheItem>();\\n    timersCache = new Map<number, any>();\\n    queue: TimeLimitedCacheItem[] = [];\\n    constructor() {\\n\\n    }\\n\\n    setTimerToDeleteKey() {\\n        while (this.queue.length > 0) {\\n            const el = this.queue.shift();\\n            const timerId = setTimeout(() => {\\n                this.cache.delete(el.key);\\n                this.timersCache.delete(el.key);\\n            }, el.duration);\\n            this.timersCache.set(el.key, timerId);\\n        }\\n    }\\n\\n    clearCacheTimer(key: number) {\\n        if (this.timersCache.has(key)) {\\n            clearTimeout(this.timersCache.get(key));\\n        }\\n    }\\n\\n    setToQueue(el: TimeLimitedCacheItem) {\\n        this.queue.push(el);\\n        this.setTimerToDeleteKey();\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        if (this.cache.has(key)) {\\n            this.clearCacheTimer(key);\\n            this.cache.set(key, {value, duration, key});\\n            this.setToQueue(this.cache.get(key));\\n            return true;\\n        } else {\\n            this.cache.set(key, {value, duration, key});\\n            this.setToQueue(this.cache.get(key));\\n            return false;\\n        }\\n    }\\n\\n    get(key: number): number {\\n        return this.cache.has(key) ? this.cache.get(key).value : -1;\\n    }\\n\\n\\tcount(): number {\\n        return this.cache.size;\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006870,
                "title": "settimeout-cleartimeout-80",
                "content": "# Approach\\nPlain setTimeout and clearTimeout\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\ntype IStateValue = {\\n    value: number;\\n    available: number;\\n    timeoutId: NodeJS.Timeout;\\n}\\n\\ninterface IState {\\n    [key: number]: IStateValue;\\n};\\n\\nclass TimeLimitedCache {\\n    mainState = {} as Iterable<IState>;\\n\\n    constructor() {\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        const existsAndAvailable = this.get(key) !== -1;\\n\\n        if (this.mainState[key]) {\\n            clearTimeout(this.mainState[key].timeoutId);\\n        };\\n\\n        this.mainState[key] = {\\n            value,\\n            available: 1,\\n            timeoutId: setTimeout(() => {\\n                this.mainState[key].available = 0;\\n            }, duration)\\n        } as IStateValue;\\n\\n        return existsAndAvailable;\\n    }\\n\\n    get(key: number | string): number {\\n        if (this.mainState[key]?.available) {\\n            return this.mainState[key].value;\\n        }\\n        return -1;\\n    }\\n\\n\\tcount(): number {\\n        let count = 0;\\n\\n        for (const key in this.mainState) {\\n            count += this.mainState[key].available;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype IStateValue = {\\n    value: number;\\n    available: number;\\n    timeoutId: NodeJS.Timeout;\\n}\\n\\ninterface IState {\\n    [key: number]: IStateValue;\\n};\\n\\nclass TimeLimitedCache {\\n    mainState = {} as Iterable<IState>;\\n\\n    constructor() {\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        const existsAndAvailable = this.get(key) !== -1;\\n\\n        if (this.mainState[key]) {\\n            clearTimeout(this.mainState[key].timeoutId);\\n        };\\n\\n        this.mainState[key] = {\\n            value,\\n            available: 1,\\n            timeoutId: setTimeout(() => {\\n                this.mainState[key].available = 0;\\n            }, duration)\\n        } as IStateValue;\\n\\n        return existsAndAvailable;\\n    }\\n\\n    get(key: number | string): number {\\n        if (this.mainState[key]?.available) {\\n            return this.mainState[key].value;\\n        }\\n        return -1;\\n    }\\n\\n\\tcount(): number {\\n        let count = 0;\\n\\n        for (const key in this.mainState) {\\n            count += this.mainState[key].available;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001414,
                "title": "javascript-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let found = this.cache.has(key);\\n    if(found) clearTimeout(this.cache.get(key).ref);\\n    this.cache.set(key,{\\n        value,\\n        ref: setTimeout(() => this.cache.delete(key),duration)\\n    });\\n    return found;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.cache.has(key) ? this.cache.get(key).value : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let found = this.cache.has(key);\\n    if(found) clearTimeout(this.cache.get(key).ref);\\n    this.cache.set(key,{\\n        value,\\n        ref: setTimeout(() => this.cache.delete(key),duration)\\n    });\\n    return found;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.cache.has(key) ? this.cache.get(key).value : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4000515,
                "title": "typescript-no-timeouts-clean-easy",
                "content": "# Intuition\\nIn designing a time-limited cache, instead of relying on `setTimeout` functions or similar mechanisms to manage the expiration of cache entries, we utilize the current time in milliseconds to determine if a cache entry is expired at the time of a given operation. This approach ensures more immediate and precise expiration checking and avoids potential issues with event loop congestion that can occur with numerous `setTimeout` functions.\\n\\n# Approach\\nIn the `TimeLimitedCache` class, the central idea is to maintain a map where each entry contains a value and an expiration time in milliseconds. Whenever a `get` or `count` operation is performed, we first check if the key\\'s validity period has expired and, if so, remove it from the map. This method, combined with timestamping each entry with a `validUntilMilis` timestamp, allows us to avoid using potentially resource-intensive `setTimeout` functions, which could cause delays and inefficiencies in large-scale applications.\\n\\n# Complexity\\n- Time complexity:\\n  - `set` method: \\\\(O(1)\\\\)\\n  - `get` method: \\\\(O(1)\\\\)\\n  - `count` method: \\\\(O(n)\\\\)\\n  \\n- Space complexity: \\\\(O(n)\\\\) (where \\\\(n\\\\) is the number of active entries in the map).\\n\\n# Code\\n```\\nclass TimeLimitedCache {\\n    private map: Map<number, {value: number, validUntilMilis: number}>;\\n\\n    constructor() {\\n        this.map = new Map();\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        const hasValidValue = this._exists(key) && !this._isExpired(key);\\n  \\n        const validUntilMilis = duration + this._getCurrentMilis();\\n\\n        this.map.set(key, {value, validUntilMilis});\\n\\n        return hasValidValue;\\n    }\\n\\n    get(key: number): number {\\n        if (this._ensureDeleteIfExpired(key)) {\\n            return -1;\\n        }\\n\\n         if (this._exists(key) && !this._isExpired(key)) {\\n           return this.map.get(key).value;\\n        }\\n\\n        return -1;\\n    }\\n\\n\\tcount(): number {\\n        this.map.forEach((_, key) => this._ensureDeleteIfExpired(key));\\n\\n        return this.map.size;\\n    }\\n\\n    private _ensureDeleteIfExpired(key: number): boolean {\\n        return this._exists(key) && this._isExpired(key) && this.map.delete(key);\\n    }\\n\\n    private _exists(key: number): boolean {\\n        return this.map.has(key);\\n    }\\n\\n    private _isExpired(key: number): boolean {\\n        return this.map.get(key).validUntilMilis < this._getCurrentMilis();\\n    }\\n\\n    private _getCurrentMilis() {\\n        return (new Date()).getTime();\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass TimeLimitedCache {\\n    private map: Map<number, {value: number, validUntilMilis: number}>;\\n\\n    constructor() {\\n        this.map = new Map();\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        const hasValidValue = this._exists(key) && !this._isExpired(key);\\n  \\n        const validUntilMilis = duration + this._getCurrentMilis();\\n\\n        this.map.set(key, {value, validUntilMilis});\\n\\n        return hasValidValue;\\n    }\\n\\n    get(key: number): number {\\n        if (this._ensureDeleteIfExpired(key)) {\\n            return -1;\\n        }\\n\\n         if (this._exists(key) && !this._isExpired(key)) {\\n           return this.map.get(key).value;\\n        }\\n\\n        return -1;\\n    }\\n\\n\\tcount(): number {\\n        this.map.forEach((_, key) => this._ensureDeleteIfExpired(key));\\n\\n        return this.map.size;\\n    }\\n\\n    private _ensureDeleteIfExpired(key: number): boolean {\\n        return this._exists(key) && this._isExpired(key) && this.map.delete(key);\\n    }\\n\\n    private _exists(key: number): boolean {\\n        return this.map.has(key);\\n    }\\n\\n    private _isExpired(key: number): boolean {\\n        return this.map.get(key).validUntilMilis < this._getCurrentMilis();\\n    }\\n\\n    private _getCurrentMilis() {\\n        return (new Date()).getTime();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998250,
                "title": "solution-with-es6-clean-code-map-solusion",
                "content": "# ES6 + Clean Code + Map \\u26A1\\n\\n# Code\\n```\\nOO\\nclass TimeLimitedCache {\\n    constructor() {\\n        this.cache = new Map();\\n    }\\n\\n    set(key, value, duration) {\\n        const found = this.cache.has(key);\\n\\n        if (found) clearTimeout(this.cache.get(key).ref);\\n        this.cache.set(key, { value, ref: setTimeout(() => this.cache.delete(key), duration)});\\n        return found;\\n    }\\n\\n    get(key) {\\n        return this.cache.has(key) ? this.cache.get(key).value : -1;\\n    }\\n\\n    count() {\\n        return this.cache.size;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nOO\\nclass TimeLimitedCache {\\n    constructor() {\\n        this.cache = new Map();\\n    }\\n\\n    set(key, value, duration) {\\n        const found = this.cache.has(key);\\n\\n        if (found) clearTimeout(this.cache.get(key).ref);\\n        this.cache.set(key, { value, ref: setTimeout(() => this.cache.delete(key), duration)});\\n        return found;\\n    }\\n\\n    get(key) {\\n        return this.cache.has(key) ? this.cache.get(key).value : -1;\\n    }\\n\\n    count() {\\n        return this.cache.size;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995503,
                "title": "prototype",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n\\n    if(this.cache[key] && this.cache[key].timer){\\n        clearTimeout(this.cache[key].timer);\\n        this.cache[key].value = value;\\n\\n        this.cache[key].timer = setTimeout(()=>{\\n            this.remove(key);\\n        }, duration);\\n        return true;\\n    }else{\\n        this.cache[key] = {\\n            value : value,\\n            timer: setTimeout(()=>{\\n                this.remove(key);\\n            },duration)\\n        };\\n        return false;\\n    }\\n    \\n};\\n\\nTimeLimitedCache.prototype.remove = function(key){\\n    delete this.cache[key];\\n}\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(this.cache[key] && this.cache[key].timer){\\n        return this.cache[key].value;\\n    }else{\\n        return -1;\\n    }\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let count = 0;\\n\\n    for(const key in this.cache){\\n        if(this.cache[key].timer){\\n            count++;\\n        }\\n    }\\n\\n    return count;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n\\n    if(this.cache[key] && this.cache[key].timer){\\n        clearTimeout(this.cache[key].timer);\\n        this.cache[key].value = value;\\n\\n        this.cache[key].timer = setTimeout(()=>{\\n            this.remove(key);\\n        }, duration);\\n        return true;\\n    }else{\\n        this.cache[key] = {\\n            value : value,\\n            timer: setTimeout(()=>{\\n                this.remove(key);\\n            },duration)\\n        };\\n        return false;\\n    }\\n    \\n};\\n\\nTimeLimitedCache.prototype.remove = function(key){\\n    delete this.cache[key];\\n}\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(this.cache[key] && this.cache[key].timer){\\n        return this.cache[key].value;\\n    }else{\\n        return -1;\\n    }\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let count = 0;\\n\\n    for(const key in this.cache){\\n        if(this.cache[key].timer){\\n            count++;\\n        }\\n    }\\n\\n    return count;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3982595,
                "title": "simple-solution-without-using-map",
                "content": "# Intuition\\n`Map` is the best solution if you\\'re able to use it. However, this assumes you\\'re told you cannot use the native `map` functionality. Lucky for us, Map is more or less an object (just like most things in JavaScript). \\n\\nA few things to note: the requirements state that each key should have it\\'s own duration. That means we need to capture the return value of `setTimeout` which will identify each timer. We us a few handy features in JavaScript, like `!!` which converts truthy values to true booleans. We also use optional chaining (`?.`) to check the cache in the `get` method and return `-1` if the key doesn\\'t exist.\\n\\n# Approach\\nTo keep this as simple and straight forward as possible we rely on accessing object properties directly.\\n\\n# Complexity\\n- Time complexity: O(1) as we do not iterate over the array. We simply access the keys directly and call existing properties (i.e. `.length`). \\n\\n- Space complexity: O(n) as the cache grows so will our space requirements.\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.cache = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    var exists = !!this.cache[key];\\n    if (exists){\\n        clearTimeout(this.cache[key].timer)\\n    }\\n    this.cache[key] = {\\n        timer: setTimeout(()=> delete this.cache[key], duration),\\n        val: value\\n    }\\n    return exists;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.cache[key]?.val || -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.cache).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cache = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    var exists = !!this.cache[key];\\n    if (exists){\\n        clearTimeout(this.cache[key].timer)\\n    }\\n    this.cache[key] = {\\n        timer: setTimeout(()=> delete this.cache[key], duration),\\n        val: value\\n    }\\n    return exists;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.cache[key]?.val || -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.cache).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3981050,
                "title": "simple-map-solution-53ms-42-41mb-beats-92-26",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to a data structure to store the current cache and a reference to the timeout. The interface for the TimeLimitedCache class is very similar to that of a Map.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing a map for our cache\\'s data structure gives us a similar interface.\\n\\n- Create a map for our cache store\\n- Create a map for our timers\\n- Set method\\n    - First check if the key exists in our cache store\\n        - If it exists clear out the timer\\n    - Set the key and value in our cache store\\n    - Create a timeout that will delete the key from our cache store after the given duration\\n    - Store a refrence to the timeout in our timer map using the same key\\n- Get method\\n    - Use the built-in get method from our cache store map\\n        - If the key exists (and is not expired) return the value\\n        - Else return -1\\n- Count method\\n    - Return the cache store map\\'s prototype property `.size` \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TimeLimitedCache {\\n    private _store: Map<number, number>;\\n    private _clock: Map<number, any>\\n\\n    constructor() {\\n        this._store = new Map();\\n        this._clock = new Map();\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        const keyExists = this._store.has(key)\\n\\n        keyExists && clearTimeout(this._clock.get(key))\\n\\n        this._store.set(key, value)\\n        this._clock.set(key, setTimeout(() => { \\n            this._store.delete(key); \\n        }, duration))\\n\\n        return keyExists;\\n    }\\n\\n    get(key: number): number {\\n        const val = this._store.get(key)\\n\\n        return typeof val === \\'number\\' ? val : -1;\\n    }\\n\\n\\tcount(): number {\\n        return this._store.size;\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass TimeLimitedCache {\\n    private _store: Map<number, number>;\\n    private _clock: Map<number, any>\\n\\n    constructor() {\\n        this._store = new Map();\\n        this._clock = new Map();\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        const keyExists = this._store.has(key)\\n\\n        keyExists && clearTimeout(this._clock.get(key))\\n\\n        this._store.set(key, value)\\n        this._clock.set(key, setTimeout(() => { \\n            this._store.delete(key); \\n        }, duration))\\n\\n        return keyExists;\\n    }\\n\\n    get(key: number): number {\\n        const val = this._store.get(key)\\n\\n        return typeof val === \\'number\\' ? val : -1;\\n    }\\n\\n\\tcount(): number {\\n        return this._store.size;\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980022,
                "title": "a-simple-solution-to-the-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.mapCache = new Map();\\n    this.timer = 0;\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    if(this.mapCache.has(key)){\\n        this.mapCache.set(key, value)\\n        clearTimeout(this.timer)\\n        this.timer = setTimeout(()=>(this.mapCache.delete(key)), duration + 10)\\n        return true\\n    } else {\\n        this.mapCache.set(key, value)\\n        this.timer = setTimeout(()=>(this.mapCache.delete(key)), duration + 10)\\n        return false;\\n    }\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.mapCache.get(key) ? this.mapCache.get(key) : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.mapCache.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.mapCache = new Map();\\n    this.timer = 0;\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    if(this.mapCache.has(key)){\\n        this.mapCache.set(key, value)\\n        clearTimeout(this.timer)\\n        this.timer = setTimeout(()=>(this.mapCache.delete(key)), duration + 10)\\n        return true\\n    } else {\\n        this.mapCache.set(key, value)\\n        this.timer = setTimeout(()=>(this.mapCache.delete(key)), duration + 10)\\n        return false;\\n    }\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.mapCache.get(key) ? this.mapCache.get(key) : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.mapCache.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3974653,
                "title": "typescript-easy-solution-no-exp-needed",
                "content": "\\n# Code\\n```\\n\\n\\nclass TimeLimitedCache {\\n    private cache: Map<number, { value: number, Cleaner: any }>\\n\\n    constructor() {\\n        this.cache = new Map()\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n\\n        let result: boolean\\n\\n        if (this.cache.has(key)) {\\n            //clrear previous Timeout\\n            clearTimeout(this.cache.get(key)?.Cleaner)\\n            result = true\\n        } else {\\n            result = false\\n        }\\n\\n        //add new values to the object\\n        this.cache.set(key, {\\n            value: value,\\n            Cleaner: setTimeout(() => {\\n                this.cache.delete(key)\\n            }, duration)\\n        })\\n        \\n        return result\\n    }\\n\\n    get(key: number): number {\\n        const val = this.cache.get(key)?.value\\n        return val !== undefined ? val : -1\\n    }\\n\\n    count(): number {\\n        return this.cache.size\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n\\n\\nclass TimeLimitedCache {\\n    private cache: Map<number, { value: number, Cleaner: any }>\\n\\n    constructor() {\\n        this.cache = new Map()\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n\\n        let result: boolean\\n\\n        if (this.cache.has(key)) {\\n            //clrear previous Timeout\\n            clearTimeout(this.cache.get(key)?.Cleaner)\\n            result = true\\n        } else {\\n            result = false\\n        }\\n\\n        //add new values to the object\\n        this.cache.set(key, {\\n            value: value,\\n            Cleaner: setTimeout(() => {\\n                this.cache.delete(key)\\n            }, duration)\\n        })\\n        \\n        return result\\n    }\\n\\n    get(key: number): number {\\n        const val = this.cache.get(key)?.value\\n        return val !== undefined ? val : -1\\n    }\\n\\n    count(): number {\\n        return this.cache.size\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960136,
                "title": "my-approach-for-this-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    \\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const existed = new Date().getTime() <= (this[key]?.expiresMs || 0); \\n\\n    this[key] = {\\n        value,\\n        expiresMs: new Date().getTime() + duration,\\n    };\\n\\n    return existed;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return (this[key]?.expiresMs || 0) < new Date().getTime() ? -1 : this[key].value;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this).filter((key) => {\\n        return new Date().getTime() <= this[key].expiresMs;\\n    }).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    \\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const existed = new Date().getTime() <= (this[key]?.expiresMs || 0); \\n\\n    this[key] = {\\n        value,\\n        expiresMs: new Date().getTime() + duration,\\n    };\\n\\n    return existed;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return (this[key]?.expiresMs || 0) < new Date().getTime() ? -1 : this[key].value;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this).filter((key) => {\\n        return new Date().getTime() <= this[key].expiresMs;\\n    }).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3958177,
                "title": "cache-with-time-limit-day-17-javascript-solution-map",
                "content": "# Intuition\\nThe problem is asking us to write a class that allows setting and getting key/value pairs however a `time until expiration` is associated with each key.\\n\\n# Approach\\nWe need to:\\n- Instantiate a cache and timeouts map that will store `cache` values and `timeouts` respectively.\\n\\nOnce we call set:\\n- we check if the `cache` has the key passed as a parameter and assign the value to variable `exists`.\\n- Check if the timeouts map has the key passed and clear that timeout.\\n- Set the cache key and value.\\n- Set the timeouts key and value.\\n- Once the timeout elapses delete the key from the cache.\\n- Return the value exists.\\n\\nOnce we call get:\\n- Return the cache value otherwise -1.\\n\\nOnce we call get:\\n- Return the size of the cache.\\n\\n# Complexity\\n- Time complexity:\\n0(1)\\n\\n- Space complexity:\\n0(1)\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n  this.cache = new Map();\\n  this.timeouts = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n  var exists = this.cache.has(key);\\n\\n  if (this.timeouts.has(key)) {\\n    clearTimeout(this.timeouts.get(key));\\n  }\\n\\n  this.cache.set(key, value);\\n  this.timeouts.set(\\n    key,\\n    setTimeout(() => {\\n      this.cache.delete(key);\\n    }, duration)\\n  );\\n\\n  return exists;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n  return this.cache.get(key) || -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n  return this.cache.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n  this.cache = new Map();\\n  this.timeouts = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n  var exists = this.cache.has(key);\\n\\n  if (this.timeouts.has(key)) {\\n    clearTimeout(this.timeouts.get(key));\\n  }\\n\\n  this.cache.set(key, value);\\n  this.timeouts.set(\\n    key,\\n    setTimeout(() => {\\n      this.cache.delete(key);\\n    }, duration)\\n  );\\n\\n  return exists;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n  return this.cache.get(key) || -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n  return this.cache.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3954025,
                "title": "2622-cache-with-time-limit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map();\\n    this.timeouts = {};\\n};\\n\\n/**\\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let exists = this.cache.has(key);\\n    if (this.timeouts[key]) clearTimeout(this.timeouts[key]);\\n\\n    this.cache.set(key, value);\\n\\n    this.timeouts[key] = setTimeout(() => {\\n        this.cache.delete(key);\\n        clearTimeout(this.timeouts[key]);\\n        delete this.timeouts[key];\\n    }, duration)\\n\\n    return exists;\\n};\\n\\n/**\\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (!this.cache.has(key)) return -1;\\n\\n    return this.cache.get(key);\\n};\\n\\n/**\\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.size;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map();\\n    this.timeouts = {};\\n};\\n\\n/**\\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let exists = this.cache.has(key);\\n    if (this.timeouts[key]) clearTimeout(this.timeouts[key]);\\n\\n    this.cache.set(key, value);\\n\\n    this.timeouts[key] = setTimeout(() => {\\n        this.cache.delete(key);\\n        clearTimeout(this.timeouts[key]);\\n        delete this.timeouts[key];\\n    }, duration)\\n\\n    return exists;\\n};\\n\\n/**\\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (!this.cache.has(key)) return -1;\\n\\n    return this.cache.get(key);\\n};\\n\\n/**\\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.size;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3950882,
                "title": "simple-and-clean",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstoring the timeout id in the map as well to reset it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1) - retriveing from hash is guaranteed to be O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) - input size\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.map = new Map();\\n    \\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const hasKey = this.map.has(key);\\n    const timer = setTimeout(()=> this.map.delete(key),duration);\\n    if(hasKey){\\n        clearTimeout(this.map.get(key).timer);\\n    }\\n    this.map.set(key,{value,duration,timer});\\n    return hasKey;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(!this.map.has(key)) return -1;\\n    return this.map.get(key).value;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.map.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.map = new Map();\\n    \\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const hasKey = this.map.has(key);\\n    const timer = setTimeout(()=> this.map.delete(key),duration);\\n    if(hasKey){\\n        clearTimeout(this.map.get(key).timer);\\n    }\\n    this.map.set(key,{value,duration,timer});\\n    return hasKey;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(!this.map.has(key)) return -1;\\n    return this.map.get(key).value;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.map.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3949871,
                "title": "solution-from-newbie",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TimeLimitedCache {\\n  private readonly keyValue: Map<number, number>;\\n  private readonly duration: Map<number, number>;\\n\\n  constructor() {\\n    this.keyValue = new Map();\\n    this.duration = new Map();\\n  }\\n\\n  private cleanUp() {\\n    const currentTime = new Date().getTime();\\n    const expiredKeys = [];\\n\\n    this.duration.forEach((expirationTime, key) => {\\n      if (currentTime >= expirationTime) {\\n        expiredKeys.push(key);\\n      }\\n    });\\n\\n    for (const key of expiredKeys) {\\n      this.keyValue.delete(key);\\n      this.duration.delete(key);\\n    }\\n  }\\n\\n  set(key: number, value: number, duration: number): boolean {\\n    this.cleanUp();\\n\\n    if (this.keyValue.has(key)) {\\n      this.keyValue.set(key, value);\\n      this.duration.set(key, new Date().getTime() + duration);\\n      return true;\\n    }\\n\\n    this.keyValue.set(key, value);\\n    this.duration.set(key, new Date().getTime() + duration);\\n    return false;\\n  }\\n\\n  get(key: number): number {\\n    this.cleanUp();\\n\\n    if (this.keyValue.has(key)) {\\n      return this.keyValue.get(key) || -1;\\n    }\\n\\n    return -1;\\n  }\\n\\n  count(): number {\\n    this.cleanUp();\\n    return this.keyValue.size;\\n  }\\n}\\n\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass TimeLimitedCache {\\n  private readonly keyValue: Map<number, number>;\\n  private readonly duration: Map<number, number>;\\n\\n  constructor() {\\n    this.keyValue = new Map();\\n    this.duration = new Map();\\n  }\\n\\n  private cleanUp() {\\n    const currentTime = new Date().getTime();\\n    const expiredKeys = [];\\n\\n    this.duration.forEach((expirationTime, key) => {\\n      if (currentTime >= expirationTime) {\\n        expiredKeys.push(key);\\n      }\\n    });\\n\\n    for (const key of expiredKeys) {\\n      this.keyValue.delete(key);\\n      this.duration.delete(key);\\n    }\\n  }\\n\\n  set(key: number, value: number, duration: number): boolean {\\n    this.cleanUp();\\n\\n    if (this.keyValue.has(key)) {\\n      this.keyValue.set(key, value);\\n      this.duration.set(key, new Date().getTime() + duration);\\n      return true;\\n    }\\n\\n    this.keyValue.set(key, value);\\n    this.duration.set(key, new Date().getTime() + duration);\\n    return false;\\n  }\\n\\n  get(key: number): number {\\n    this.cleanUp();\\n\\n    if (this.keyValue.has(key)) {\\n      return this.keyValue.get(key) || -1;\\n    }\\n\\n    return -1;\\n  }\\n\\n  count(): number {\\n    this.cleanUp();\\n    return this.keyValue.size;\\n  }\\n}\\n\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943193,
                "title": "cache-using-stored-timeout-in-record-type",
                "content": "\\n\\n# Code\\n```\\nclass TimeLimitedCache {\\n    cache: Record<number, [number, any]>; // { key: [value, timeout_id ] }\\n    size: number;\\n\\n    constructor() {\\n        this.cache = {};\\n        this.size = 0;\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        let overwrote: boolean = false;\\n        if (this.cache[key] !== undefined) {\\n            overwrote = true;\\n            clearTimeout(this.cache[key][1]);\\n        } else {\\n            this.size++;\\n        }\\n        this.cache[key] = [\\n            value,\\n            setTimeout(() => { \\n                delete this.cache[key];\\n                this.size--;\\n            }, duration)\\n        ];\\n        return overwrote;\\n    }\\n\\n    get(key: number): number {\\n        return this.cache[key]?.[0] ?? -1;\\n    }\\n\\n\\tcount(): number {\\n        return this.size;\\n    }\\n}",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "\\n\\n# Code\\n```\\nclass TimeLimitedCache {\\n    cache: Record<number, [number, any]>; // { key: [value, timeout_id ] }\\n    size: number;\\n\\n    constructor() {\\n        this.cache = {};\\n        this.size = 0;\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        let overwrote: boolean = false;\\n        if (this.cache[key] !== undefined) {\\n            overwrote = true;\\n            clearTimeout(this.cache[key][1]);\\n        } else {\\n            this.size++;\\n        }\\n        this.cache[key] = [\\n            value,\\n            setTimeout(() => { \\n                delete this.cache[key];\\n                this.size--;\\n            }, duration)\\n        ];\\n        return overwrote;\\n    }\\n\\n    get(key: number): number {\\n        return this.cache[key]?.[0] ?? -1;\\n    }\\n\\n\\tcount(): number {\\n        return this.size;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3932765,
                "title": "simple-easy-to-understand-solution-using-objects",
                "content": "```\\nvar TimeLimitedCache = function() {\\n    this.cache = {};\\n};\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const keyExists = this.cache.hasOwnProperty(key);\\n    if(keyExists) {\\n        clearTimeout(this.cache[key].timer);\\n    }\\n    this.cache[key] = {\\n        value,\\n        timer: setTimeout(() => {\\n            delete this.cache[key];\\n        }, duration),\\n    };\\n    return keyExists;\\n};\\n\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(!this.cache.hasOwnProperty(key)) {\\n        return -1;\\n    }\\n    return this.cache[key].value;\\n};\\n\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.cache).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cache = {};\\n};\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const keyExists = this.cache.hasOwnProperty(key);\\n    if(keyExists) {\\n        clearTimeout(this.cache[key].timer);\\n    }\\n    this.cache[key] = {\\n        value,\\n        timer: setTimeout(() => {\\n            delete this.cache[key];\\n        }, duration),\\n    };\\n    return keyExists;\\n};\\n\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(!this.cache.hasOwnProperty(key)) {\\n        return -1;\\n    }\\n    return this.cache[key].value;\\n};\\n\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.cache).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3925867,
                "title": "ts-easy-solution-beats-97",
                "content": "\\n\\n# Code\\n```\\ntype CachedRecord = { value: number, duration: number, accessibleUntill: number };\\n\\nclass TimeLimitedCache {\\n\\n    private cache: { [key: number]: CachedRecord } = {};\\n\\n    constructor() { }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        const thisTime = Date.now();\\n        if (key in this.cache && this.cache[key].accessibleUntill > thisTime) {\\n            this.cache[key].value = value;\\n            this.cache[key].duration = duration;\\n            this.cache[key].accessibleUntill = duration + thisTime;\\n            return true;\\n        }\\n        this.cache[key] = { value: value, duration: duration, accessibleUntill: duration + thisTime };\\n        return false;\\n    }\\n\\n    get(key: number): number {\\n        return this.cache[key]?.accessibleUntill > Date.now() ? this.cache[key].value : -1;\\n    }\\n\\n    count(): number {\\n        let count = 0;\\n        const thisTime = Date.now();\\n        for (const key in this.cache)\\n            if (this.cache[key].accessibleUntill > thisTime)\\n                count++;\\n        return count;\\n    }\\n}\\n\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype CachedRecord = { value: number, duration: number, accessibleUntill: number };\\n\\nclass TimeLimitedCache {\\n\\n    private cache: { [key: number]: CachedRecord } = {};\\n\\n    constructor() { }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        const thisTime = Date.now();\\n        if (key in this.cache && this.cache[key].accessibleUntill > thisTime) {\\n            this.cache[key].value = value;\\n            this.cache[key].duration = duration;\\n            this.cache[key].accessibleUntill = duration + thisTime;\\n            return true;\\n        }\\n        this.cache[key] = { value: value, duration: duration, accessibleUntill: duration + thisTime };\\n        return false;\\n    }\\n\\n    get(key: number): number {\\n        return this.cache[key]?.accessibleUntill > Date.now() ? this.cache[key].value : -1;\\n    }\\n\\n    count(): number {\\n        let count = 0;\\n        const thisTime = Date.now();\\n        for (const key in this.cache)\\n            if (this.cache[key].accessibleUntill > thisTime)\\n                count++;\\n        return count;\\n    }\\n}\\n\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920126,
                "title": "simple-readable-solution-using-javascript-and-settimeout",
                "content": "```\\nvar TimeLimitedCache = function() {\\n    this.keys = [];\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let keyExists = false;\\n    \\n    if(key in this.keys)\\n    {\\n        clearTimeout(this.keys[key].timeoutId);\\n        keyExists = true;\\n    }\\n\\n    this.keys[key] = {\\n        value: value,\\n        isExpired: false,\\n        timeoutId: setTimeout(() => {\\n            this.keys[key].isExpired = true;\\n        }, duration)\\n    }\\n\\n    return keyExists;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(key in this.keys && !this.keys[key].isExpired)\\n        return this.keys[key].value;\\n    else\\n        return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let count = 0;\\n    this.keys.forEach((key) => {\\n        if(!key.isExpired)\\n        {\\n            count += 1;\\n        }\\n    });\\n    return count;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.keys = [];\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let keyExists = false;\\n    \\n    if(key in this.keys)\\n    {\\n        clearTimeout(this.keys[key].timeoutId);\\n        keyExists = true;\\n    }\\n\\n    this.keys[key] = {\\n        value: value,\\n        isExpired: false,\\n        timeoutId: setTimeout(() => {\\n            this.keys[key].isExpired = true;\\n        }, duration)\\n    }\\n\\n    return keyExists;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(key in this.keys && !this.keys[key].isExpired)\\n        return this.keys[key].value;\\n    else\\n        return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let count = 0;\\n    this.keys.forEach((key) => {\\n        if(!key.isExpired)\\n        {\\n            count += 1;\\n        }\\n    });\\n    return count;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3917405,
                "title": "easy-solution-2-approach",
                "content": "\\n\\n# Code\\n### 1. Using Map and setTimeout\\n```\\nclass TimeLimitedCache {\\n    #cache = new Map();\\n    #timeoutId = null;\\n    \\n    set(key, value, duration) {\\n        let keyExists = false;\\n\\n        if (this.#cache.has(key) && this.#timeoutId) {\\n            clearInterval(this.#timeoutId);\\n            keyExists = true\\n        }\\n\\n        this.#cache.set(key, value);\\n        this.#timeoutId = setTimeout(() => this.#cache.delete(key), duration);\\n        \\n        return keyExists;\\n    };\\n\\n    get(key) {\\n        return this.#cache.get(key) || -1;\\n    };\\n\\n    count() {\\n        return this.#cache.size;\\n    };\\n}\\n```\\n\\n### 2. Using Map and Date.now()\\n```\\nclass TimeLimitedCache {\\n    #cache = new Map()\\n\\n    set(key, value, duration) {\\n        let keyExists = false;\\n\\n        if (this.#cache.has(key)) {\\n            if (this.#cache.get(key)[0] >= Date.now()) {\\n                keyExists = true\\n            }\\n        }\\n\\n        const expiration = duration + Date.now();\\n        this.#cache.set(key, [expiration, value]);\\n\\n        return keyExists;\\n    }\\n\\n    get(key) {\\n        if (this.#cache.has(key)) {\\n            const [expiration, value] = this.#cache.get(key);\\n\\n            if (expiration >= Date.now()) return value;\\n            else this.#cache.delete(key);\\n        }\\n\\n        return -1;\\n    }\\n\\n    count() {\\n        let count = 0;\\n\\n        for (let [key, [expiration, _]] of this.#cache) {\\n            if (expiration >= Date.now()) count++;\\n            else this.#cache.delete(key);\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass TimeLimitedCache {\\n    #cache = new Map();\\n    #timeoutId = null;\\n    \\n    set(key, value, duration) {\\n        let keyExists = false;\\n\\n        if (this.#cache.has(key) && this.#timeoutId) {\\n            clearInterval(this.#timeoutId);\\n            keyExists = true\\n        }\\n\\n        this.#cache.set(key, value);\\n        this.#timeoutId = setTimeout(() => this.#cache.delete(key), duration);\\n        \\n        return keyExists;\\n    };\\n\\n    get(key) {\\n        return this.#cache.get(key) || -1;\\n    };\\n\\n    count() {\\n        return this.#cache.size;\\n    };\\n}\\n```\n```\\nclass TimeLimitedCache {\\n    #cache = new Map()\\n\\n    set(key, value, duration) {\\n        let keyExists = false;\\n\\n        if (this.#cache.has(key)) {\\n            if (this.#cache.get(key)[0] >= Date.now()) {\\n                keyExists = true\\n            }\\n        }\\n\\n        const expiration = duration + Date.now();\\n        this.#cache.set(key, [expiration, value]);\\n\\n        return keyExists;\\n    }\\n\\n    get(key) {\\n        if (this.#cache.has(key)) {\\n            const [expiration, value] = this.#cache.get(key);\\n\\n            if (expiration >= Date.now()) return value;\\n            else this.#cache.delete(key);\\n        }\\n\\n        return -1;\\n    }\\n\\n    count() {\\n        let count = 0;\\n\\n        for (let [key, [expiration, _]] of this.#cache) {\\n            if (expiration >= Date.now()) count++;\\n            else this.#cache.delete(key);\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912702,
                "title": "typescript-solution-using-a-map-object-an-timeout",
                "content": "\\n\\n# Code\\n```\\n\\nclass TimeLimitedCache {\\n  store: Map<number, { pairValue: number; timeoutId: NodeJS.Timeout }>;\\n  constructor() {\\n    this.store = new Map();\\n  }\\n\\n  set(key: number, value: number, duration: number): boolean {\\n    const storedKeyValue = this.store.get(key);\\n\\n    // store\\n\\n    this.store.set(key, {\\n      pairValue: value,\\n      timeoutId: setTimeout(() => {\\n        this.store.delete(key);\\n      }, duration),\\n    });\\n\\n    // timer to clean store after duration\\n    if (storedKeyValue) clearTimeout(storedKeyValue.timeoutId);\\n\\n    return !!storedKeyValue;\\n  }\\n\\n  get(key: number): number {\\n    return this.store.get(key)?.pairValue ?? -1;\\n  }\\n\\n  count(): number {\\n    return this.store.size;\\n  }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n\\nclass TimeLimitedCache {\\n  store: Map<number, { pairValue: number; timeoutId: NodeJS.Timeout }>;\\n  constructor() {\\n    this.store = new Map();\\n  }\\n\\n  set(key: number, value: number, duration: number): boolean {\\n    const storedKeyValue = this.store.get(key);\\n\\n    // store\\n\\n    this.store.set(key, {\\n      pairValue: value,\\n      timeoutId: setTimeout(() => {\\n        this.store.delete(key);\\n      }, duration),\\n    });\\n\\n    // timer to clean store after duration\\n    if (storedKeyValue) clearTimeout(storedKeyValue.timeoutId);\\n\\n    return !!storedKeyValue;\\n  }\\n\\n  get(key: number): number {\\n    return this.store.get(key)?.pairValue ?? -1;\\n  }\\n\\n  count(): number {\\n    return this.store.size;\\n  }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910608,
                "title": "typescript-class-solution",
                "content": "# Code\\n```\\nclass TimeLimitedCache {\\n    #dict: { [key: number]: [number, ReturnType<typeof setTimeout>] } = {}\\n    #count = 0;\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        let updated = false;\\n\\n        if(this.#dict[key] == null) {\\n            this.#count++;\\n        } else {\\n            clearTimeout(this.#dict[key][1]);\\n            updated = true;\\n        }\\n        \\n        this.#dict[key] = [\\n            value,\\n            setTimeout(() => {\\n                this.#dict[key] = undefined;\\n                this.#count--;\\n            }, duration)\\n        ];\\n        \\n        return updated;\\n    }\\n\\n    get(key: number): number {\\n        return this.#dict[key] == null\\n            ? -1\\n            : this.#dict[key][0];\\n    }\\n\\n\\tcount(): number {\\n        return this.#count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass TimeLimitedCache {\\n    #dict: { [key: number]: [number, ReturnType<typeof setTimeout>] } = {}\\n    #count = 0;\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        let updated = false;\\n\\n        if(this.#dict[key] == null) {\\n            this.#count++;\\n        } else {\\n            clearTimeout(this.#dict[key][1]);\\n            updated = true;\\n        }\\n        \\n        this.#dict[key] = [\\n            value,\\n            setTimeout(() => {\\n                this.#dict[key] = undefined;\\n                this.#count--;\\n            }, duration)\\n        ];\\n        \\n        return updated;\\n    }\\n\\n    get(key: number): number {\\n        return this.#dict[key] == null\\n            ? -1\\n            : this.#dict[key][0];\\n    }\\n\\n\\tcount(): number {\\n        return this.#count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904512,
                "title": "simple-and-acceptable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    \\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let isExist = key in this;\\n\\n    if (isExist) {\\n        clearTimeout(this[key].timer);\\n    }\\n\\n    this[key] = { \\n        value,\\n        timer: setTimeout(() => {\\n            delete this[key];\\n        }, duration),\\n    };\\n\\n    return isExist;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (!(key in this)) return -1;\\n    return this[key].value;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    \\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let isExist = key in this;\\n\\n    if (isExist) {\\n        clearTimeout(this[key].timer);\\n    }\\n\\n    this[key] = { \\n        value,\\n        timer: setTimeout(() => {\\n            delete this[key];\\n        }, duration),\\n    };\\n\\n    return isExist;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (!(key in this)) return -1;\\n    return this[key].value;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3901324,
                "title": "using-timer-and-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.kv = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {    \\n    let result = key in this.kv;\\n    if (result) {\\n        let previousTimer = this.kv[key].timer;\\n        clearTimeout(previousTimer);\\n    }\\n    const timer = setTimeout(() => {\\n        delete this.kv[key];\\n    }, duration);     \\n    this.kv[key] = {\\n        value,\\n        timer\\n    };       \\n    return result;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return key in this.kv ? this.kv[key].value : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {  \\n    return Object.keys(this.kv).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.kv = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {    \\n    let result = key in this.kv;\\n    if (result) {\\n        let previousTimer = this.kv[key].timer;\\n        clearTimeout(previousTimer);\\n    }\\n    const timer = setTimeout(() => {\\n        delete this.kv[key];\\n    }, duration);     \\n    this.kv[key] = {\\n        value,\\n        timer\\n    };       \\n    return result;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return key in this.kv ? this.kv[key].value : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {  \\n    return Object.keys(this.kv).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3898975,
                "title": "commented-and-fast-beats-95-users",
                "content": "# Code\\n```\\nvar TimeLimitedCache = function() {\\n    // Create a cache (store) to keep all the values\\n    this.store = new Map()\\n};\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let ret = false \\n\\n    // If the value already exists in cache, delete it and clear timer\\n    if(this.store.has(key)) {\\n        ret = true\\n        const stub = this.store.get(key)\\n        this.store.delete(key)\\n        clearTimeout(stub[1])\\n    }\\n\\n    // Add the value to cache \\n    const handle = setTimeout(() => {\\n        this.store.delete(key)\\n    }, duration)\\n    this.store.set(key, [value, handle])\\n\\n    return ret\\n};\\n\\nTimeLimitedCache.prototype.get = function(key) {\\n    // return if the value is found\\n    if(this.store.has(key))\\n        return this.store.get(key)[0]\\n    return -1\\n};\\n\\nTimeLimitedCache.prototype.count = function() {\\n    // return the size of our cache\\n    return this.store.size\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/a55ed568-adee-4a80-ab56-17e0c536b03e_1691838978.2860994.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    // Create a cache (store) to keep all the values\\n    this.store = new Map()\\n};\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let ret = false \\n\\n    // If the value already exists in cache, delete it and clear timer\\n    if(this.store.has(key)) {\\n        ret = true\\n        const stub = this.store.get(key)\\n        this.store.delete(key)\\n        clearTimeout(stub[1])\\n    }\\n\\n    // Add the value to cache \\n    const handle = setTimeout(() => {\\n        this.store.delete(key)\\n    }, duration)\\n    this.store.set(key, [value, handle])\\n\\n    return ret\\n};\\n\\nTimeLimitedCache.prototype.get = function(key) {\\n    // return if the value is found\\n    if(this.store.has(key))\\n        return this.store.get(key)[0]\\n    return -1\\n};\\n\\nTimeLimitedCache.prototype.count = function() {\\n    // return the size of our cache\\n    return this.store.size\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3897256,
                "title": "o-n-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.cache = {};\\n    this.validKey = key => {\\n       if(this.cache[key]){\\n            const [,duration] = this.cache[key];\\n            if(Date.now() > duration){\\n                delete this.cache[key];\\n                return false;\\n            }\\n            return true;\\n       }\\n       return false;\\n    }\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const calcDuration = Date.now() + duration;\\n    const result = !!this.cache[key]\\n    this.cache[key] = [value, calcDuration];\\n    return result;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    this.validKey(key)\\n\\n    return this.validKey(key)? this.cache[key][0] : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let count = 0;\\n    for(let key in this.cache) {\\n        if(this.validKey(key)){\\n            // increase the count\\n            count++;\\n        }       \\n    }\\n    return count;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cache = {};\\n    this.validKey = key => {\\n       if(this.cache[key]){\\n            const [,duration] = this.cache[key];\\n            if(Date.now() > duration){\\n                delete this.cache[key];\\n                return false;\\n            }\\n            return true;\\n       }\\n       return false;\\n    }\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const calcDuration = Date.now() + duration;\\n    const result = !!this.cache[key]\\n    this.cache[key] = [value, calcDuration];\\n    return result;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    this.validKey(key)\\n\\n    return this.validKey(key)? this.cache[key][0] : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let count = 0;\\n    for(let key in this.cache) {\\n        if(this.validKey(key)){\\n            // increase the count\\n            count++;\\n        }       \\n    }\\n    return count;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3895969,
                "title": "add-timelimit-for-each-value-date-now",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Adding timelimit for each key using `Date.now()`\\n- Now when get is called then check if timeLimit is expired or not and return -1 if expired or otherwise return the value stored\\n- Same for the `count()`, count the values whose timeLimit is not expired\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function () {\\n    this.cache = {}\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\n\\nTimeLimitedCache.prototype.set = function (key, value, duration) {\\n    currentTime = Date.now();\\n    timeLimit = currentTime+duration;\\n    if (this.cache[key]) {\\n        result = this.cache[key].timeLimit>=currentTime;\\n        this.cache[key] = {\\n            value,\\n            timeLimit\\n        }\\n\\n        return result;\\n    }\\n\\n    this.cache[key] = {\\n        value,\\n        timeLimit\\n    }\\n\\n    return false;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function (key) {\\n    currentTime = Date.now();\\n    if(!this.cache[key] || this.cache[key].timeLimit < currentTime) return -1;\\n\\n    return this.cache[key].value;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function () {\\n    let result = 0;\\n    currentTime = Date.now();\\n    for(let val of Object.values(this.cache || {})) {\\n        result+= (val.timeLimit >= currentTime);\\n    }\\n\\n    return result;\\n};\\n\\n\\n//  Your TimeLimitedCache object will be instantiated and called as such:\\n var obj = new TimeLimitedCache()\\n//  console.log(obj)\\n obj.set(1, 42, 1000); // false\\n obj.get(1) // 42\\n obj.count() // 1\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function () {\\n    this.cache = {}\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\n\\nTimeLimitedCache.prototype.set = function (key, value, duration) {\\n    currentTime = Date.now();\\n    timeLimit = currentTime+duration;\\n    if (this.cache[key]) {\\n        result = this.cache[key].timeLimit>=currentTime;\\n        this.cache[key] = {\\n            value,\\n            timeLimit\\n        }\\n\\n        return result;\\n    }\\n\\n    this.cache[key] = {\\n        value,\\n        timeLimit\\n    }\\n\\n    return false;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function (key) {\\n    currentTime = Date.now();\\n    if(!this.cache[key] || this.cache[key].timeLimit < currentTime) return -1;\\n\\n    return this.cache[key].value;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function () {\\n    let result = 0;\\n    currentTime = Date.now();\\n    for(let val of Object.values(this.cache || {})) {\\n        result+= (val.timeLimit >= currentTime);\\n    }\\n\\n    return result;\\n};\\n\\n\\n//  Your TimeLimitedCache object will be instantiated and called as such:\\n var obj = new TimeLimitedCache()\\n//  console.log(obj)\\n obj.set(1, 42, 1000); // false\\n obj.get(1) // 42\\n obj.count() // 1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3893217,
                "title": "expiring-key-value-store-using-map",
                "content": "# Intuition\\nWe need to create a class that stores key-value pairs with associated expiration times. The class should provide methods for setting key-value pairs with expiration, retrieving values for unexpired keys, and counting the number of unexpired keys.\\n\\n# Approach\\nWe can use a JavaScript Map to store the key-value pairs along with their expiration times. When setting a key-value pair, we\\'ll record the expiration time based on the provided duration. When getting a value, we\\'ll check if the key exists and if its expiration time has not passed. For counting unexpired keys, we\\'ll iterate through the map and count the keys with valid expiration times.\\n\\n# Time Complexity\\nset: O(1) (average case) - Insertion and update in a Map is usually constant time.\\nget: O(1) (average case) - Retrieval from a Map is usually constant time.\\ncount: O(n) - We need to iterate through all the key-value pairs in the Map to count unexpired keys.\\n# Space Complexity\\nO(n) - The space complexity depends on the number of key-value pairs stored in the Map.\\nPlease note that this solution \\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.data = new Map(); // To store key-value pairs and expiration times\\n}\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n        const currentTime = Date.now();\\n    const expirationTime = currentTime + duration;\\n\\n    if (this.data.has(key) && this.data.get(key).expirationTime > currentTime) {\\n      // Key already exists and is unexpired\\n      this.data.set(key, { value, expirationTime });\\n      return true;\\n    } else {\\n      this.data.set(key, { value, expirationTime });\\n      return false;\\n    }\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n     const entry = this.data.get(key);\\n\\n    if (entry && entry.expirationTime > Date.now()) {\\n      return entry.value;\\n    } else {\\n      return -1;\\n    }\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    const currentTime = Date.now();\\n    let count = 0;\\n\\n    for (const entry of this.data.values()) {\\n      if (entry.expirationTime > currentTime) {\\n        count++;\\n      }\\n    }\\n\\n    return count;\\n    \\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.data = new Map(); // To store key-value pairs and expiration times\\n}\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n        const currentTime = Date.now();\\n    const expirationTime = currentTime + duration;\\n\\n    if (this.data.has(key) && this.data.get(key).expirationTime > currentTime) {\\n      // Key already exists and is unexpired\\n      this.data.set(key, { value, expirationTime });\\n      return true;\\n    } else {\\n      this.data.set(key, { value, expirationTime });\\n      return false;\\n    }\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n     const entry = this.data.get(key);\\n\\n    if (entry && entry.expirationTime > Date.now()) {\\n      return entry.value;\\n    } else {\\n      return -1;\\n    }\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    const currentTime = Date.now();\\n    let count = 0;\\n\\n    for (const entry of this.data.values()) {\\n      if (entry.expirationTime > currentTime) {\\n        count++;\\n      }\\n    }\\n\\n    return count;\\n    \\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3890364,
                "title": "readable-js-solution-with-reusable-haskeyexpired-method",
                "content": "# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.keys = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let hasReplacedKey = false;\\n\\n    if ( this.keys[key] && !this.hasKeyExpired(key) ) {\\n        hasReplacedKey = true;\\n    }\\n\\n    this.keys[key] = {\\n        value,\\n        expiresAt: Date.now() + duration\\n    }\\n\\n    return hasReplacedKey;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if( !this.keys[key] || this.hasKeyExpired(key) ) {\\n        return -1\\n    }\\n\\n    return this.keys[key].value\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    const allKeys = Object.keys(this.keys);\\n    let keyCount = 0;\\n\\n    allKeys.forEach(key => {\\n        if ( !this.hasKeyExpired(key) ) {\\n            keyCount++;\\n        }\\n    }); \\n\\n    return keyCount;\\n};\\n\\n/**\\n * @param {number} key\\n * @return {boolean} if existing key has expired\\n */\\nTimeLimitedCache.prototype.hasKeyExpired = function(key) {\\n    return this.keys[key] && this.keys[key].expiresAt < Date.now();\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.keys = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let hasReplacedKey = false;\\n\\n    if ( this.keys[key] && !this.hasKeyExpired(key) ) {\\n        hasReplacedKey = true;\\n    }\\n\\n    this.keys[key] = {\\n        value,\\n        expiresAt: Date.now() + duration\\n    }\\n\\n    return hasReplacedKey;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if( !this.keys[key] || this.hasKeyExpired(key) ) {\\n        return -1\\n    }\\n\\n    return this.keys[key].value\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    const allKeys = Object.keys(this.keys);\\n    let keyCount = 0;\\n\\n    allKeys.forEach(key => {\\n        if ( !this.hasKeyExpired(key) ) {\\n            keyCount++;\\n        }\\n    }); \\n\\n    return keyCount;\\n};\\n\\n/**\\n * @param {number} key\\n * @return {boolean} if existing key has expired\\n */\\nTimeLimitedCache.prototype.hasKeyExpired = function(key) {\\n    return this.keys[key] && this.keys[key].expiresAt < Date.now();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3884132,
                "title": "beats-98-60-best-solution-solution-with-minimal-code",
                "content": "# Intuition\\nThese approach emphasizes achieving **performance with minimal code**.\\n\\nAll **the solutions that I reviewed** after writing my solution, they are making the solution too complex, while it is not.\\n\\nPlease **Upvote** if you find helpful.\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const expirationTime = Date.now() + duration;\\n    const isNewEntry =  this.cache.get(key)?.expirationTime > Date.now();\\n    this.cache.set(key, {value, expirationTime});\\n    return isNewEntry;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    const cachedEntry = this.cache.get(key);\\n    return cachedEntry?.expirationTime > Date.now() ? cachedEntry.value : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Array.from(this.cache.values()).reduce((count, cachedEntry) =>{\\n        return count + (cachedEntry.expirationTime > Date.now() ? 1 : 0);\\n    } , 0);\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const expirationTime = Date.now() + duration;\\n    const isNewEntry =  this.cache.get(key)?.expirationTime > Date.now();\\n    this.cache.set(key, {value, expirationTime});\\n    return isNewEntry;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    const cachedEntry = this.cache.get(key);\\n    return cachedEntry?.expirationTime > Date.now() ? cachedEntry.value : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Array.from(this.cache.values()).reduce((count, cachedEntry) =>{\\n        return count + (cachedEntry.expirationTime > Date.now() ? 1 : 0);\\n    } , 0);\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3880832,
                "title": "simple-with-map-and-settimeout",
                "content": "# Approach\\n\\nUse Map as storage.  \\nAuto-expire keys with setTimeout.\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.items = new Map()\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const ex = this.items.has(key)\\n    if (ex) clearTimeout(this.items.get(key)[1])\\n    this.items.set(key, [value, setTimeout(() => this.items.delete(key), duration)])\\n    return ex\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.items.get(key)?.[0] ?? -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.items.size\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.items = new Map()\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const ex = this.items.has(key)\\n    if (ex) clearTimeout(this.items.get(key)[1])\\n    this.items.set(key, [value, setTimeout(() => this.items.delete(key), duration)])\\n    return ex\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.items.get(key)?.[0] ?? -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.items.size\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3880617,
                "title": "beats-98-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs object allows us to rewrite the values we just need a way to handle the expiry of the key value pairs\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst we use a flag in set method to keep track if a key is already present or not by default it is false and if key already exists then it will become true, each time we use set method a new or existing key value pair is created or overridden respectively and also the respective key value pairs are deleted after the given duration using setTimeout api, rest of the code is self explainatory.\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let flag = false\\n    if(this[key]){\\n        clearTimeout(this[key].id)\\n        flag  = !flag\\n    }\\n    this[key]={value}\\n    const id = setTimeout(()=>{delete this[key]},duration)\\n    this[key].id = id\\n    return flag\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this[key] && this[key].value || -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this).length\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let flag = false\\n    if(this[key]){\\n        clearTimeout(this[key].id)\\n        flag  = !flag\\n    }\\n    this[key]={value}\\n    const id = setTimeout(()=>{delete this[key]},duration)\\n    this[key].id = id\\n    return flag\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this[key] && this[key].value || -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this).length\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3876907,
                "title": "simple-easy-solution",
                "content": "# Intuition\\nsettimeout & this keyword\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.obj = { };\\n    this.time = Date.now();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n      \\n      if(this.obj[[key]])\\n      {\\n        clearTimeout(this.obj[[key]].timer);\\n        this.obj[[key]] =  {\\n            value : value,\\n        };\\n        const timer = setTimeout(()=>\\n        {\\n          delete this.obj[[key]];\\n        },duration) ;\\n        this.obj[[key]].timer = timer;\\n        return true\\n      }\\n      else\\n      {\\n        this.obj[[key]] = {\\n            value : value,\\n            timer : 0\\n        };\\n        const timer = setTimeout(()=>\\n        {\\n          delete this.obj[[key]];\\n        },duration)\\n        this.obj[[key]].timer = timer;\\n        return false\\n      }\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(this.obj[[key]])\\n    {\\n        return this.obj[[key]].value;\\n    }\\n    else\\n    {\\n        return -1;\\n    }\\n    \\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n     return Object.keys(this.obj).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.obj = { };\\n    this.time = Date.now();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n      \\n      if(this.obj[[key]])\\n      {\\n        clearTimeout(this.obj[[key]].timer);\\n        this.obj[[key]] =  {\\n            value : value,\\n        };\\n        const timer = setTimeout(()=>\\n        {\\n          delete this.obj[[key]];\\n        },duration) ;\\n        this.obj[[key]].timer = timer;\\n        return true\\n      }\\n      else\\n      {\\n        this.obj[[key]] = {\\n            value : value,\\n            timer : 0\\n        };\\n        const timer = setTimeout(()=>\\n        {\\n          delete this.obj[[key]];\\n        },duration)\\n        this.obj[[key]].timer = timer;\\n        return false\\n      }\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(this.obj[[key]])\\n    {\\n        return this.obj[[key]].value;\\n    }\\n    else\\n    {\\n        return -1;\\n    }\\n    \\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n     return Object.keys(this.obj).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3875613,
                "title": "2622-cache-with-time-limit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction TimeLimitedCache() {\\n  this.cache = new Map();\\n}\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n     const valueInCache = this.cache.get(key);\\n    if (valueInCache) {\\n      clearTimeout(valueInCache.timeout);\\n    }\\n    const timeout = setTimeout(() => this.cache.delete(key), duration);\\n    this.cache.set(key, { value, timeout });\\n    return Boolean(valueInCache);\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n      return this.cache.has(key) ? this.cache.get(key).value : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n     return this.cache.size;\\n};\\n\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction TimeLimitedCache() {\\n  this.cache = new Map();\\n}\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n     const valueInCache = this.cache.get(key);\\n    if (valueInCache) {\\n      clearTimeout(valueInCache.timeout);\\n    }\\n    const timeout = setTimeout(() => this.cache.delete(key), duration);\\n    this.cache.set(key, { value, timeout });\\n    return Boolean(valueInCache);\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n      return this.cache.has(key) ? this.cache.get(key).value : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n     return this.cache.size;\\n};\\n\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3873479,
                "title": "simple-timeout-based-solution-beats-88-92",
                "content": "# Code\\n```\\n\\nvar TimeLimitedCache = function() {\\n    this.store = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const keyExists = key in this.store;\\n\\n    if (keyExists) {\\n        clearTimeout(this.store[key].timer);\\n    }\\n\\n    const timer = setTimeout(() => {\\n        delete this.store[key];\\n    }, duration);\\n    this.store[key] = { value, timer };\\n\\n    return keyExists;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (key in this.store) return this.store[key].value;\\n    return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.store).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar TimeLimitedCache = function() {\\n    this.store = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const keyExists = key in this.store;\\n\\n    if (keyExists) {\\n        clearTimeout(this.store[key].timer);\\n    }\\n\\n    const timer = setTimeout(() => {\\n        delete this.store[key];\\n    }, duration);\\n    this.store[key] = { value, timer };\\n\\n    return keyExists;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (key in this.store) return this.store[key].value;\\n    return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.store).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3871543,
                "title": "simple-aproach-with-cache-and-timers-99-53",
                "content": "# Code\\n```\\nclass TimeLimitedCache {\\n  private cache: { [key: number]: number } = [];\\n  private timers: any[] = [];\\n\\n  constructor() {}\\n\\n  set(key: number, value: number, duration: number): boolean {\\n    const cachedValue = this.get(key);\\n    let result = false;\\n\\n    if (cachedValue !== -1) {\\n      clearTimeout(this.timers[key]);\\n      result = true;\\n    }\\n\\n    this.cache[key] = value;\\n    this.timers[key] = setTimeout(() => {\\n      delete this.cache[key];\\n      delete this.timers[key];\\n    }, duration);\\n\\n    return result;\\n  }\\n\\n  get(key: number): number {\\n    return this.cache[key] ?? -1;\\n  }\\n\\n  count(): number {\\n    return Object.keys(this.cache).length;\\n  }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass TimeLimitedCache {\\n  private cache: { [key: number]: number } = [];\\n  private timers: any[] = [];\\n\\n  constructor() {}\\n\\n  set(key: number, value: number, duration: number): boolean {\\n    const cachedValue = this.get(key);\\n    let result = false;\\n\\n    if (cachedValue !== -1) {\\n      clearTimeout(this.timers[key]);\\n      result = true;\\n    }\\n\\n    this.cache[key] = value;\\n    this.timers[key] = setTimeout(() => {\\n      delete this.cache[key];\\n      delete this.timers[key];\\n    }, duration);\\n\\n    return result;\\n  }\\n\\n  get(key: number): number {\\n    return this.cache[key] ?? -1;\\n  }\\n\\n  count(): number {\\n    return Object.keys(this.cache).length;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869516,
                "title": "2622-cache-with-time-limit",
                "content": "# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.__data = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let existed = key in this.__data;\\n\\n    this.__data[key] = value;\\n    setTimeout(() => {if (this.__data[key] == value)delete this.__data[key]}, duration); \\n\\n    return existed;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return key in this.__data ? this.__data[key] : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.__data).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.__data = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let existed = key in this.__data;\\n\\n    this.__data[key] = value;\\n    setTimeout(() => {if (this.__data[key] == value)delete this.__data[key]}, duration); \\n\\n    return existed;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return key in this.__data ? this.__data[key] : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.__data).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3867648,
                "title": "simple-and-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.cache={};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let already = false;\\n    if(this.cache[key]?.value){\\n    clearTimeout(this.cache[key]?.timerId);\\n     already = true;\\n    }\\n    const timeout = setTimeout(()=>delete this.cache[key],duration);\\n     this.cache[key] = {\\n        value : value,\\n        timerId: timeout\\n    };\\n     return already;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    let value = this.cache[key]?.value;\\n    if(value) return value;\\n    return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.cache).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cache={};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let already = false;\\n    if(this.cache[key]?.value){\\n    clearTimeout(this.cache[key]?.timerId);\\n     already = true;\\n    }\\n    const timeout = setTimeout(()=>delete this.cache[key],duration);\\n     this.cache[key] = {\\n        value : value,\\n        timerId: timeout\\n    };\\n     return already;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    let value = this.cache[key]?.value;\\n    if(value) return value;\\n    return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.cache).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3862863,
                "title": "kiss-solution-with-with-timeout-and-object-delete-key-cache-timer-also-not-just-value",
                "content": "cache timer also not just value\\n\\n# Code\\n```\\nclass TimeLimitedCache {\\n    stack: {}\\n\\n    constructor() {\\n        this.stack = {}\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        let result = false\\n\\n        if ( this.stack.hasOwnProperty(key)){\\n            clearTimeout(this.stack[key].timer)\\n            result = true\\n        }\\n\\n        this.stack[key] = {timer: setTimeout( () => delete this.stack[key], duration ), value: value }\\n\\n        return result\\n    }\\n\\n    get(key: number): number {\\n        return this.stack.hasOwnProperty(key) ? this.stack[key].value : -1\\n    }\\n\\n\\tcount(): number {\\n        return Object.keys(this.stack).length\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass TimeLimitedCache {\\n    stack: {}\\n\\n    constructor() {\\n        this.stack = {}\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        let result = false\\n\\n        if ( this.stack.hasOwnProperty(key)){\\n            clearTimeout(this.stack[key].timer)\\n            result = true\\n        }\\n\\n        this.stack[key] = {timer: setTimeout( () => delete this.stack[key], duration ), value: value }\\n\\n        return result\\n    }\\n\\n    get(key: number): number {\\n        return this.stack.hasOwnProperty(key) ? this.stack[key].value : -1\\n    }\\n\\n\\tcount(): number {\\n        return Object.keys(this.stack).length\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860226,
                "title": "beats-82-92-of-users-with-typescript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TimeLimitedCache {\\n    cache:any;  \\n    constructor() {\\n        this.cache=new Map();\\n    }\\n    set(key: number, value: number, duration: number): boolean {\\n       const alreadyExists = this.cache.get(key);\\n        if (alreadyExists) {\\n            clearTimeout(alreadyExists.timeoutId);\\n        }\\n        const timeoutId = setTimeout(() => {\\n            this.cache.delete(key);          \\n        }, duration);\\n        this.cache.set(key,{\\n                value,timeoutId\\n        });\\n\\n        return Boolean(alreadyExists);\\n    }\\n\\n    get(key: number): number {\\n        return this.cache.has(key)?this.cache.get(key).value:-1;\\n    }\\n\\n\\tcount(): number {\\n        return this.cache.size;\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass TimeLimitedCache {\\n    cache:any;  \\n    constructor() {\\n        this.cache=new Map();\\n    }\\n    set(key: number, value: number, duration: number): boolean {\\n       const alreadyExists = this.cache.get(key);\\n        if (alreadyExists) {\\n            clearTimeout(alreadyExists.timeoutId);\\n        }\\n        const timeoutId = setTimeout(() => {\\n            this.cache.delete(key);          \\n        }, duration);\\n        this.cache.set(key,{\\n                value,timeoutId\\n        });\\n\\n        return Boolean(alreadyExists);\\n    }\\n\\n    get(key: number): number {\\n        return this.cache.has(key)?this.cache.get(key).value:-1;\\n    }\\n\\n\\tcount(): number {\\n        return this.cache.size;\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855048,
                "title": "simple-solution-beating-99",
                "content": "# Intuition\\nWe are given a class, have to write 3 functions of that class. First functino is for setting a value to a key for duration amount of time, after that time, that key will be removed from the cache (object), second function is to get value from a key, return val of the key if key is not  removed yet, else return -1 and third function is to get count of keys.\\n\\n# Approach\\nCreated an object named cache in constructor. in set function, checked if the key is already presnet, if yes, then removed the previous timer, and added new timer with new duration, overwrote the value of the key, if key is not present, just add that key-val pair to the cache object If duration is passed, the key will be removed\\n\\n# Complexity\\n- Time complexity:\\nTime complexity of set is O(1)\\nTime complexity of get is O(1)\\nTime complexity of count is O(n)\\n\\n- Space complexity:\\nSpace complexity  is O(n) for cache\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.cache = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let retStatus = false;\\n    if(this.cache[key]){ \\n        retStatus = true;\\n        clearTimeout(this.expire)\\n    }\\n\\n    this.cache[key] = value;\\n    this.expire = setTimeout(() => {\\n        delete this.cache[key]\\n    }, duration)\\n    return retStatus;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(this.cache[key]) return this.cache[key];\\n    else return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.cache).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cache = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let retStatus = false;\\n    if(this.cache[key]){ \\n        retStatus = true;\\n        clearTimeout(this.expire)\\n    }\\n\\n    this.cache[key] = value;\\n    this.expire = setTimeout(() => {\\n        delete this.cache[key]\\n    }, duration)\\n    return retStatus;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(this.cache[key]) return this.cache[key];\\n    else return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.cache).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3850335,
                "title": "the-easiest-solution-with-settimeout",
                "content": "# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.values = {};\\n    this.timers = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const isExist = this.values.hasOwnProperty(key);\\n    this.values[key] = value;\\n    if (isExist) {\\n        clearTimeout(this.timers[key]);\\n    }\\n\\n    this.timers[key] = setTimeout(() => {\\n        delete this.values[key];\\n    }, duration);\\n\\n    return isExist;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.values.hasOwnProperty(key) ? this.values[key] : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.values).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.values = {};\\n    this.timers = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const isExist = this.values.hasOwnProperty(key);\\n    this.values[key] = value;\\n    if (isExist) {\\n        clearTimeout(this.timers[key]);\\n    }\\n\\n    this.timers[key] = setTimeout(() => {\\n        delete this.values[key];\\n    }, duration);\\n\\n    return isExist;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.values.hasOwnProperty(key) ? this.values[key] : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.values).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3848534,
                "title": "easy-to-understand-and-99-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nMy approach for this exercise was very simple.\\n\\nTo manage cache, dictionary are always a perfect match. They have $$O(1)$$ time complexity and $$O(n)$$ space complexity. In our case the complex part is to clear a value at key after a given duration. To do this we can use `setTimeout` to execute a function after some time. In our function we just have to delete the value at the given key inside our cache dictionary, so `delete cache[key]`.\\n\\nWe have a functionning cache management system that even handle expiration delay.\\n\\nBut what would happen if we add a key that have already been given ? With our code it will replace the current value with the new one and start a new promise to clear this key after the given time. But our last delete funtion for this may still be running, so we need to stop it before it erase our new value !\\n\\nTo do this we need to use `clearTimeout`, this function can stop our old delete function. But it need the process id that is returned when we started the delete function.\\n\\nSo we can store this timeout id in the dictonary at the given key next to our value. This way we can still retrieve our value and now we can also retrieve our timeout id to cancel it before starting a new one.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` JS\\nvar TimeLimitedCache = function() {\\n    this.cache = {}; // {key, {value, timeoutID}}\\n    this.itemCount = 0;\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    var keyAlreadyExist = this.get(key) !== -1;\\n\\n    if (keyAlreadyExist) {\\n        // Remove old element\\n        clearTimeout(this.cache[key].timeoutID);\\n        this.itemCount--;\\n    }\\n\\n    // add new element\\n    this.itemCount++;\\n    this.cache[key] = {value};\\n    this.cache[key].timeoutID = setTimeout(() => { delete this.cache[key]; this.itemCount--; }, duration);\\n\\n    return keyAlreadyExist;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.cache.hasOwnProperty(key) ? this.cache[key].value : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.itemCount;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` JS\\nvar TimeLimitedCache = function() {\\n    this.cache = {}; // {key, {value, timeoutID}}\\n    this.itemCount = 0;\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    var keyAlreadyExist = this.get(key) !== -1;\\n\\n    if (keyAlreadyExist) {\\n        // Remove old element\\n        clearTimeout(this.cache[key].timeoutID);\\n        this.itemCount--;\\n    }\\n\\n    // add new element\\n    this.itemCount++;\\n    this.cache[key] = {value};\\n    this.cache[key].timeoutID = setTimeout(() => { delete this.cache[key]; this.itemCount--; }, duration);\\n\\n    return keyAlreadyExist;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.cache.hasOwnProperty(key) ? this.cache[key].value : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.itemCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3841780,
                "title": "simple-javascript-solution-using-settimeout",
                "content": "# Intuition\\nWe need to recursively call setTimeout while new TimeLimitedCache.set(key) are supplied within cache liftime.re\\n\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.pairOj = {}\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let ans = key in this.pairOj ? true : false\\n\\n    if(this.pairOj[key]){\\n        this.pairOj[key].value = value;\\n        clearTimeout(this.pairOj[key].timeout);\\n        this.pairOj[key].timeout = setTimeout(()=> delete this.pairOj[key], duration)\\n    } else {\\n        this.pairOj[key] = {\\n            value: value,\\n            timeout: setTimeout(()=> delete this.pairOj[key], duration)\\n        }\\n    }\\n    \\n    return ans\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (this.pairOj[key]){\\n        return this.pairOj[key].value\\n    }\\n    return -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys( this.pairOj ).length; \\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.pairOj = {}\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let ans = key in this.pairOj ? true : false\\n\\n    if(this.pairOj[key]){\\n        this.pairOj[key].value = value;\\n        clearTimeout(this.pairOj[key].timeout);\\n        this.pairOj[key].timeout = setTimeout(()=> delete this.pairOj[key], duration)\\n    } else {\\n        this.pairOj[key] = {\\n            value: value,\\n            timeout: setTimeout(()=> delete this.pairOj[key], duration)\\n        }\\n    }\\n    \\n    return ans\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (this.pairOj[key]){\\n        return this.pairOj[key].value\\n    }\\n    return -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys( this.pairOj ).length; \\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3840387,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.obj = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    if (this.obj[key] == undefined || (new Date(Date.now()) - this.obj[key].time) >= this.obj[key].duration){\\n        this.obj[key] = {value, duration, time: new Date(Date.now())};\\n        return false\\n    }\\n    this.obj[key] = {value, duration, time: new Date(Date.now())};\\n    return true;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (this.obj[key] == undefined){\\n        return -1;\\n    }\\n    if ((new Date(Date.now()) - this.obj[key].time) >= this.obj[key].duration){\\n        return -1;\\n    }\\n    return this.obj[key].value;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let sum = 0;\\n    for (const key in this.obj){\\n        if ((new Date(Date.now()) - this.obj[key].time) < this.obj[key].duration){\\n            sum += 1;\\n        }\\n    }\\n    return sum;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.obj = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    if (this.obj[key] == undefined || (new Date(Date.now()) - this.obj[key].time) >= this.obj[key].duration){\\n        this.obj[key] = {value, duration, time: new Date(Date.now())};\\n        return false\\n    }\\n    this.obj[key] = {value, duration, time: new Date(Date.now())};\\n    return true;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (this.obj[key] == undefined){\\n        return -1;\\n    }\\n    if ((new Date(Date.now()) - this.obj[key].time) >= this.obj[key].duration){\\n        return -1;\\n    }\\n    return this.obj[key].value;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let sum = 0;\\n    for (const key in this.obj){\\n        if ((new Date(Date.now()) - this.obj[key].time) < this.obj[key].duration){\\n            sum += 1;\\n        }\\n    }\\n    return sum;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3838183,
                "title": "easy-and-concise-javascript",
                "content": "# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map()\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let result = false\\n    if (this.cache.has(key)) {\\n      const ref = this.cache.get(key).ref;\\n      clearTimeout(ref)\\n      result = true;\\n    }\\n    const ref = setTimeout(() => this.cache.delete(key), duration)\\n    this.cache.set(key, { value, ref})\\n    return result;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (this.cache.has(key))\\n      return this.cache.get(key).value\\n    return -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.size\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map()\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let result = false\\n    if (this.cache.has(key)) {\\n      const ref = this.cache.get(key).ref;\\n      clearTimeout(ref)\\n      result = true;\\n    }\\n    const ref = setTimeout(() => this.cache.delete(key), duration)\\n    this.cache.set(key, { value, ref})\\n    return result;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (this.cache.has(key))\\n      return this.cache.get(key).value\\n    return -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.size\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3835430,
                "title": "simple-and-fastest-solution-with-explanation",
                "content": "# Explanation\\n<!-- Describe your approach to solving the problem. -->\\nIn this solution we store key-value pairs in private class field `#cache`, where every key associated with array, containing value and expiration date. Expiration date calculated in `set()` method, using `Date.now() + duration`. To check if cache entry is expired, we use private method `#expired()`, which compares `Date.now()` and expiration date stored in cache entry.\\n\\n---\\n\\nCache entry: `[\\'key\\': [\\'value\\', \\'expirationDate\\']]`\\nExample: `[\\'1\\': [42, 100]]`\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TimeLimitedCache {\\n    #cache = {};\\n\\n    #expired(key) {\\n        return (Date.now() > this.#cache[key][1]) ? true : false;\\n    };\\n\\n    set(key, value, duration) {\\n        var returnValue = this.#cache[key] && !this.#expired(key) ? true : false;\\n        this.#cache[key] = [value, Date.now() + duration];\\n        return returnValue;\\n    };\\n\\n    get(key) {\\n        return this.#cache[key] && !this.#expired(key) ? this.#cache[key][0] : -1;\\n    };\\n\\n    count() {\\n        return Object.entries(this.#cache).filter(record => !this.#expired(record[0])).length;\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass TimeLimitedCache {\\n    #cache = {};\\n\\n    #expired(key) {\\n        return (Date.now() > this.#cache[key][1]) ? true : false;\\n    };\\n\\n    set(key, value, duration) {\\n        var returnValue = this.#cache[key] && !this.#expired(key) ? true : false;\\n        this.#cache[key] = [value, Date.now() + duration];\\n        return returnValue;\\n    };\\n\\n    get(key) {\\n        return this.#cache[key] && !this.#expired(key) ? this.#cache[key][0] : -1;\\n    };\\n\\n    count() {\\n        return Object.entries(this.#cache).filter(record => !this.#expired(record[0])).length;\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833226,
                "title": "simple-solution",
                "content": "# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.obj = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    if(this.obj.has(key))\\n    {\\n        clearTimeout(this.obj.get(key).expTimer);\\n        let id = setTimeout(() => this.obj.delete(key), duration);\\n        this.obj.set(key, {value : value, expTimer : id});\\n        return true;\\n    }\\n    else{\\n        let id = setTimeout(() => this.obj.delete(key), duration)\\n        this.obj.set(key, {value : value, expTimer : id});\\n        return false;\\n    }\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.obj.has(key) ? this.obj.get(key).value : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.obj.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.obj = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    if(this.obj.has(key))\\n    {\\n        clearTimeout(this.obj.get(key).expTimer);\\n        let id = setTimeout(() => this.obj.delete(key), duration);\\n        this.obj.set(key, {value : value, expTimer : id});\\n        return true;\\n    }\\n    else{\\n        let id = setTimeout(() => this.obj.delete(key), duration)\\n        this.obj.set(key, {value : value, expTimer : id});\\n        return false;\\n    }\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.obj.has(key) ? this.obj.get(key).value : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.obj.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3832393,
                "title": "o-1-js-solution-using-settimeout",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.data = {};\\n    this.counter = 0;\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let exists = false\\n    const timeoutId = setTimeout(()=>{\\n        delete this.data[key];\\n        this.counter += -1;\\n    }, [duration])\\n    if(this.data[key]){\\n        exists = true;\\n        clearTimeout(this.data[key].timeoutId);\\n    }\\n    if(!exists){\\n        this.counter += 1;\\n    }\\n    this.data[key] = { value, timeoutId };  \\n   return exists;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.data[key] ? this.data[key].value : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.counter;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.data = {};\\n    this.counter = 0;\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let exists = false\\n    const timeoutId = setTimeout(()=>{\\n        delete this.data[key];\\n        this.counter += -1;\\n    }, [duration])\\n    if(this.data[key]){\\n        exists = true;\\n        clearTimeout(this.data[key].timeoutId);\\n    }\\n    if(!exists){\\n        this.counter += 1;\\n    }\\n    this.data[key] = { value, timeoutId };  \\n   return exists;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.data[key] ? this.data[key].value : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.counter;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3832322,
                "title": "javascript-no-bs-o-1-plain-and-simple-if-else-logic-with-settimeout-cleartimeout",
                "content": "# Intuition\\nUse \\'this\\' to store the keys with other necessary info.\\n\\n# Approach\\nSET method :\\n1. Use \\'this\\' as your store, first of all we want to check if the key does not exist in the store at all.\\n2. If it doesn\\'t push the key to \\'this\\' object with value and exired parameter set to false initially.\\n3. To automatically exipre the key after \\'duration\\' ms, create a setTimeout and take it\\'s memory location reference in a variable.\\n4. Store the memory ref of setTimeout also as part of the key (this will come handy when we want to discard and re-create existing timeout)\\n5. The case where we don\\'t have a key at all is now handled, lets move to another case where we will be entertaining the set request, i.e. when the key exists but it is not exipre yet.\\n6. Write the else if block with above mentioned condition.\\n7. The first thing we want to do is, discard the old setTimeout that\\'s running. This is where that memory ref comes in handy. Since we already have the old timeout\\'s memory ref in the key itself, we can use clearTimeout to get rid of it.\\n8. Now, let\\'s create another setTimeout with updated duration.\\n9. Set the key again as before. Since the questions asks us to return \\'true\\' only in this case, we can quickly write that and end our else if block.\\n10. return false in all other cases and our set method is now complete.\\n\\nCOUNT method :\\n1. Simply iterate over keys in \\'this\\' object and check if the key is not already exired ( I used filter and then .length to achieve it )\\n\\nGET method : You really thought I was going to explain that didn\\'t ya ? :D\\n\\n# Complexity\\n- Time complexity:\\nset = O(1)\\nget = O(1)\\ncount = O(1)\\n\\n- Space complexity:\\nset = O(1)\\nget = O(1)\\ncount = O(n) | n = number of keys\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    if(!this[key]){\\n        const ref = setTimeout(()=>{this[key].expired = true},duration)\\n        this[key] = {\\n            value,\\n            expired : false,\\n            ref\\n        }\\n    }\\n    else if(this[key] && !this[key].expired){\\n        clearTimeout(this[key].ref);\\n        const ref = setTimeout(()=>{this[key].expired = true},duration);\\n        this[key] = { value, expired: false, ref }\\n        return true;\\n    }\\n\\n    return false;\\n\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(!this[key] || this[key].expired) return -1;\\n    return this[key].value;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n   return Object.keys(this).filter(key=>!this[key].expired).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    if(!this[key]){\\n        const ref = setTimeout(()=>{this[key].expired = true},duration)\\n        this[key] = {\\n            value,\\n            expired : false,\\n            ref\\n        }\\n    }\\n    else if(this[key] && !this[key].expired){\\n        clearTimeout(this[key].ref);\\n        const ref = setTimeout(()=>{this[key].expired = true},duration);\\n        this[key] = { value, expired: false, ref }\\n        return true;\\n    }\\n\\n    return false;\\n\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(!this[key] || this[key].expired) return -1;\\n    return this[key].value;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n   return Object.keys(this).filter(key=>!this[key].expired).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3830732,
                "title": "beats-99-6-simple-and-readable-solution",
                "content": "N*OTE: A lot of the submissions remove the entries based on timers, the question does not mention anything about keeping the cached entries clean, only that the cache class should set and return the expected values. If you want to make the it better in terms of memory consumption, feel free to extend the solution to remove entries based on cache entry duration.*\\n\\nThis solution beats 99.6% of all submissions in terms of speed.\\n\\n\\n# Code\\n```\\nclass TimeLimitedCache {\\n    constructor() {\\n        this.cachedObjects = {};\\n    }\\n}\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    // This could be simpler if it was not for the fact that the `get`\\n    // function can return -1 which is \"truthy\".\\n    const exists = this.get(key) && !!this.cachedObjects[key];\\n\\n    this.cachedObjects[key] = {\\n        value,\\n        duration: Date.now() + duration,\\n    };\\n\\n    return exists;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (\\n        !this.cachedObjects[key] ||\\n        ((this.cachedObjects[key].duration - Date.now()) <= 0)\\n    ) {\\n        return -1;\\n    }\\n\\n    return this.cachedObjects[key].value;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.entries(this.cachedObjects)\\n        .filter(([, { duration }]) => (duration - Date.now()) > 0).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass TimeLimitedCache {\\n    constructor() {\\n        this.cachedObjects = {};\\n    }\\n}\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    // This could be simpler if it was not for the fact that the `get`\\n    // function can return -1 which is \"truthy\".\\n    const exists = this.get(key) && !!this.cachedObjects[key];\\n\\n    this.cachedObjects[key] = {\\n        value,\\n        duration: Date.now() + duration,\\n    };\\n\\n    return exists;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (\\n        !this.cachedObjects[key] ||\\n        ((this.cachedObjects[key].duration - Date.now()) <= 0)\\n    ) {\\n        return -1;\\n    }\\n\\n    return this.cachedObjects[key].value;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.entries(this.cachedObjects)\\n        .filter(([, { duration }]) => (duration - Date.now()) > 0).length;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826966,
                "title": "using-settimeout-and-cleartimeout",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->I understood that i should store values for certain period of time after it shouldn\\'t be inaccesseble for which i can either delete or freeze keys. I should require an object or map to do store. inorder to make key delete itself after sometime we should add settimout,if key already exists then timout is cleared and updated with new duration.If key exist return value else -1 . for count return no of key\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.map={}; //store cache\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n   //flag to check the preasence of key already\\n    let flag= this.map.hasOwnProperty(key) ? true :false;\\n    if(flag){\\n        // clear the timeout inorder to update new one in future\\n        clearTimeout(this.map[key].timeout);\\n    }\\n    //set timeout and store in that key for future modifcation.\\n    let timeout= setTimeout(()=>{delete this.map[key];\\n                                    },duration);\\n    this.map[key] = {value,timeout};\\n    return flag;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    //if key is present then return value else -1\\n    if(this.map.hasOwnProperty(key)){\\n        return this.map[key].value;\\n    }else return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    //return length\\n    return Object.keys(this.map).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.map={}; //store cache\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n   //flag to check the preasence of key already\\n    let flag= this.map.hasOwnProperty(key) ? true :false;\\n    if(flag){\\n        // clear the timeout inorder to update new one in future\\n        clearTimeout(this.map[key].timeout);\\n    }\\n    //set timeout and store in that key for future modifcation.\\n    let timeout= setTimeout(()=>{delete this.map[key];\\n                                    },duration);\\n    this.map[key] = {value,timeout};\\n    return flag;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    //if key is present then return value else -1\\n    if(this.map.hasOwnProperty(key)){\\n        return this.map[key].value;\\n    }else return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    //return length\\n    return Object.keys(this.map).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3818226,
                "title": "day-8-cache-w-timelimt-explain-solution-o-1-simple-hashmap",
                "content": "### Idea\\nWhen I see key & value with no repetition, the first idea that comes to my mind is hashmap. A hashmap provides ```read, insert and delete``` operations with a time complexity of ```O(1)```.\\n\\n\\n\\n### Things to Aware:\\n1. Defining type: We define the ```type``` to prevent passing the wrong type of data.\\n2. We need to clear the old timeout function first while updating the existing record, otherwise ```setTimeout``` will keep counting and the record will be deleted at the wrong time.\\n3. ```clearTimeout``` needs the ```timeoutId``` that is generated at ```setTimeout```, therefore we also need to save it in the cache.\\n\\n\\n```\\ntype CacheType= {\\n    value: number;\\n    timeoutId: ReturnType<typeof setTimeout>;\\n}\\n\\nclass TimeLimitedCache {\\n    cache = new Map<number,CacheType>();\\n\\n    set(key: number, value: number, duration: number): boolean {\\n\\t\\t// Check if the key exists in the cache\\n        const exists = this.cache.has(key)\\n        \\n\\t\\t// If the key exists, we clear the timeout first.\\n        if(exists) clearTimeout(this.cache.get(key).timeoutId)\\n        \\n\\t\\t// Set expiration by using setTimeout and store the timeoutId\\n        const timeoutId = setTimeout(()=>{\\n            this.cache.delete(key)\\n        },duration)\\n        \\n\\t\\t// Save the key-value pair.\\n        this.cache.set(key,{value,timeoutId})\\n        \\n        return exists\\n    }\\n\\n    get(key: number): number {\\n\\t\\t// First, check if the key exists\\n\\t\\t// since we can\\'t get value from an undefined object.\\n\\t\\t// -1 will be returned if it does not exist.\\n        return this.cache.has(key)? this.cache.get(key).value : -1\\n    }\\n\\n\\tcount(): number {\\n        return this.cache.size\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```\\n\\n## Up Vote and Comment if this help you.\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```read, insert and delete```\n```O(1)```\n```type```\n```setTimeout```\n```clearTimeout```\n```timeoutId```\n```setTimeout```\n```\\ntype CacheType= {\\n    value: number;\\n    timeoutId: ReturnType<typeof setTimeout>;\\n}\\n\\nclass TimeLimitedCache {\\n    cache = new Map<number,CacheType>();\\n\\n    set(key: number, value: number, duration: number): boolean {\\n\\t\\t// Check if the key exists in the cache\\n        const exists = this.cache.has(key)\\n        \\n\\t\\t// If the key exists, we clear the timeout first.\\n        if(exists) clearTimeout(this.cache.get(key).timeoutId)\\n        \\n\\t\\t// Set expiration by using setTimeout and store the timeoutId\\n        const timeoutId = setTimeout(()=>{\\n            this.cache.delete(key)\\n        },duration)\\n        \\n\\t\\t// Save the key-value pair.\\n        this.cache.set(key,{value,timeoutId})\\n        \\n        return exists\\n    }\\n\\n    get(key: number): number {\\n\\t\\t// First, check if the key exists\\n\\t\\t// since we can\\'t get value from an undefined object.\\n\\t\\t// -1 will be returned if it does not exist.\\n        return this.cache.has(key)? this.cache.get(key).value : -1\\n    }\\n\\n\\tcount(): number {\\n        return this.cache.size\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809682,
                "title": "cache-with-time-limit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n     this.data = {};\\n    this.active = 0;\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n\\n \\n     const prevActive = !!this.data[key]?.isActive;\\n    prevActive ? clearTimeout(this.data[key].timeoutId) : this.active++;\\n    const timeoutId = setTimeout(() => {\\n        this.active--;\\n        this.data[key].isActive = false;\\n    },duration);\\n    this.data[key] = {\\n        isActive: true,\\n        value,\\n        timeoutId\\n    }\\n    return prevActive;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n\\n     return this.data[key]?.isActive ? this.data[key].value : -1;\\n\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n  \\n    return this.active;\\n\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n     this.data = {};\\n    this.active = 0;\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n\\n \\n     const prevActive = !!this.data[key]?.isActive;\\n    prevActive ? clearTimeout(this.data[key].timeoutId) : this.active++;\\n    const timeoutId = setTimeout(() => {\\n        this.active--;\\n        this.data[key].isActive = false;\\n    },duration);\\n    this.data[key] = {\\n        isActive: true,\\n        value,\\n        timeoutId\\n    }\\n    return prevActive;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n\\n     return this.data[key]?.isActive ? this.data[key].value : -1;\\n\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n  \\n    return this.active;\\n\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3804834,
                "title": "clear-old-timer-with-cleartimeout",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nClear old timer with `clearTimeout`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse `Payload` type to keep the value and timer, and clear old timer.\\n\\n# Complexity\\n- Time complexity: $O(N)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(N)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ninterface Payload {\\n    value: number;\\n    timeout: NodeJS.Timeout;\\n}\\n\\nclass TimeLimitedCache {\\n    #cache: Map<number, Payload>;\\n    constructor() {\\n        this.#cache = new Map();\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        let exist = this.#cache.has(key);\\n        if (exist) {\\n            clearTimeout(this.#cache.get(key)?.timeout);\\n        }\\n        let payload = {\\n            value: value,\\n            timeout: setTimeout(() => this.#cache.delete(key), duration)\\n        }\\n        this.#cache.set(key, payload);\\n        return exist ? true : false;\\n    }\\n\\n    get(key: number): number {\\n        if (this.#cache.has(key)) {\\n            return this.#cache.get(key)!.value;\\n        }\\n\\n        return -1;\\n    }\\n\\n    count(): number {\\n        return this.#cache.size;\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ninterface Payload {\\n    value: number;\\n    timeout: NodeJS.Timeout;\\n}\\n\\nclass TimeLimitedCache {\\n    #cache: Map<number, Payload>;\\n    constructor() {\\n        this.#cache = new Map();\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        let exist = this.#cache.has(key);\\n        if (exist) {\\n            clearTimeout(this.#cache.get(key)?.timeout);\\n        }\\n        let payload = {\\n            value: value,\\n            timeout: setTimeout(() => this.#cache.delete(key), duration)\\n        }\\n        this.#cache.set(key, payload);\\n        return exist ? true : false;\\n    }\\n\\n    get(key: number): number {\\n        if (this.#cache.has(key)) {\\n            return this.#cache.get(key)!.value;\\n        }\\n\\n        return -1;\\n    }\\n\\n    count(): number {\\n        return this.#cache.size;\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797116,
                "title": "simple-solution-with-map-object",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TimeLimitedCache {\\n    private _data = new Map<number, {\\n        value: number\\n        timer: any\\n    }>()\\n\\n    set = (key: number, value: number, duration: number): boolean => {\\n        const data = this._data.get(key)\\n\\n        if (data) {\\n            clearTimeout(data.timer)\\n        }\\n\\n        this._data.set(key, {\\n            value,\\n            timer: setTimeout(() => {\\n                this._data.delete(key)\\n            }, duration)\\n        })\\n\\n        return data ? true : false\\n    }\\n\\n    get = (key: number): number => this._data.get(key)?.value ?? -1\\n\\n    count = (): number => this._data.size\\n\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass TimeLimitedCache {\\n    private _data = new Map<number, {\\n        value: number\\n        timer: any\\n    }>()\\n\\n    set = (key: number, value: number, duration: number): boolean => {\\n        const data = this._data.get(key)\\n\\n        if (data) {\\n            clearTimeout(data.timer)\\n        }\\n\\n        this._data.set(key, {\\n            value,\\n            timer: setTimeout(() => {\\n                this._data.delete(key)\\n            }, duration)\\n        })\\n\\n        return data ? true : false\\n    }\\n\\n    get = (key: number): number => this._data.get(key)?.value ?? -1\\n\\n    count = (): number => this._data.size\\n\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795281,
                "title": "simple-solution-with-settimeout",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach stores both values and timers in dedicated hashmaps.\\n\\nOne issue to watch out for in timeout-based approach is the cancellation of the existing timers upon key overwrite.\\n\\n`setTimeout` is used to clear expired keys.\\n`clearTimeout` is used to cancel timers\\n# Complexity\\n- Time complexity: O(1) - no looping involved in `set()` or `get()` \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) - each `set()` requires storage of value and at most one timer. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    // It is really easy to get confusing errors with `this`\\n    // due to how keyword changes what it is referring to. \\n    // Even though `this` in arrow functions points to the outer scope,\\n    // to avoid potential issues during refactorings it is common \\n    // to bind `this` to `self`;\\n    const self = this;\\n\\n    self.timers = {};\\n    self.values = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const self = this;\\n\\n    // Was there an existing key with this value? \\n    const existed = Boolean(self.timers[key]);\\n\\n    // Must cancel the timer if there was\\n    if (existed) {\\n        clearTimeout(self.timers[key]);\\n    }\\n\\n    // Insert new value:\\n    self.values[key] = value;\\n\\n    // Insert new timer: \\n    self.timers[key] = setTimeout(() => {\\n        // Once timer runs out deletes the value\\n        delete self.values[key];\\n        // And the expired timer handle itself \\n        delete self.timers[key];\\n    }, duration);\\n\\n    return existed;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    const self = this;\\n    // Given the timer has expired, then value would be nullish\\n    // in which case, nullish-coalescing operator `??` \\n    // returns right-hand side `-1`\\n    return self.values[key] ?? -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    const self = this;\\n    // As soon as value expires it is cleaned up by the \\n    // corresponding timer, which means that keys in `self.values` \\n    // reflect count of non-expired keys. \\n    return Object.keys(self.values).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    // It is really easy to get confusing errors with `this`\\n    // due to how keyword changes what it is referring to. \\n    // Even though `this` in arrow functions points to the outer scope,\\n    // to avoid potential issues during refactorings it is common \\n    // to bind `this` to `self`;\\n    const self = this;\\n\\n    self.timers = {};\\n    self.values = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const self = this;\\n\\n    // Was there an existing key with this value? \\n    const existed = Boolean(self.timers[key]);\\n\\n    // Must cancel the timer if there was\\n    if (existed) {\\n        clearTimeout(self.timers[key]);\\n    }\\n\\n    // Insert new value:\\n    self.values[key] = value;\\n\\n    // Insert new timer: \\n    self.timers[key] = setTimeout(() => {\\n        // Once timer runs out deletes the value\\n        delete self.values[key];\\n        // And the expired timer handle itself \\n        delete self.timers[key];\\n    }, duration);\\n\\n    return existed;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    const self = this;\\n    // Given the timer has expired, then value would be nullish\\n    // in which case, nullish-coalescing operator `??` \\n    // returns right-hand side `-1`\\n    return self.values[key] ?? -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    const self = this;\\n    // As soon as value expires it is cleaned up by the \\n    // corresponding timer, which means that keys in `self.values` \\n    // reflect count of non-expired keys. \\n    return Object.keys(self.values).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3793090,
                "title": "using-map-in-javascript",
                "content": "\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const isExists = this.cache.get(key);\\n    if (isExists) {\\n        clearTimeout(isExists.timeOutId);\\n    }\\n    const timeOutId = setTimeout(() => {\\n        this.cache.delete(key)\\n    }, duration);\\n    this.cache.set(key, {value, timeOutId});\\n    return Boolean(isExists);\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (this.cache.has(key)) {\\n        return this.cache.get(key).value;\\n    }\\n    return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const isExists = this.cache.get(key);\\n    if (isExists) {\\n        clearTimeout(isExists.timeOutId);\\n    }\\n    const timeOutId = setTimeout(() => {\\n        this.cache.delete(key)\\n    }, duration);\\n    this.cache.set(key, {value, timeOutId});\\n    return Boolean(isExists);\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (this.cache.has(key)) {\\n        return this.cache.get(key).value;\\n    }\\n    return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3791559,
                "title": "easy-javascript-implementation-of-cache",
                "content": "\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.data = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const currentTime = Date.now();\\n    const expirationTime = currentTime + duration;\\n    if (this.data.has(key)){\\n        const {expiration} = this.data.get(key);\\n        if (expiration  >  currentTime) {\\n            this.data.set(key, {value, expiration: expirationTime});\\n            return true;\\n        }\\n    }\\n    this.data.set(key, {value, expiration: expirationTime})\\n    return false;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    const currentTime = Date.now();\\n    if (this.data.has(key)) {\\n        const {value, expiration} = this.data.get(key);\\n        if (expiration > currentTime){\\n            return value;\\n        }\\n    }\\n\\n    return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let size = 0;\\n    const currentTime = Date.now();\\n\\n    for (const [key, { expiration }] of this.data) {\\n      if (expiration > currentTime) {\\n        size++;\\n      }\\n    }\\n    return size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.data = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const currentTime = Date.now();\\n    const expirationTime = currentTime + duration;\\n    if (this.data.has(key)){\\n        const {expiration} = this.data.get(key);\\n        if (expiration  >  currentTime) {\\n            this.data.set(key, {value, expiration: expirationTime});\\n            return true;\\n        }\\n    }\\n    this.data.set(key, {value, expiration: expirationTime})\\n    return false;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    const currentTime = Date.now();\\n    if (this.data.has(key)) {\\n        const {value, expiration} = this.data.get(key);\\n        if (expiration > currentTime){\\n            return value;\\n        }\\n    }\\n\\n    return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let size = 0;\\n    const currentTime = Date.now();\\n\\n    for (const [key, { expiration }] of this.data) {\\n      if (expiration > currentTime) {\\n        size++;\\n      }\\n    }\\n    return size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3772765,
                "title": "simple-to-understand-js-solution",
                "content": "\\n# Code\\n```\\nvar TimeLimitedCache = function () {\\n    this.cache = new Map()\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function (key, value, duration) {\\n    const tmId = setTimeout(() => {\\n        this.cache.delete(key)\\n    }, duration)\\n\\n    const result = this.cache.get(key)\\n    this.cache.set(key, { value, tmId })\\n    if (result) clearTimeout(result.tmId)\\n\\n    return Boolean(result)\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function (key) {\\n    return this.cache.get(key)?.value ?? -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function () {\\n    return this.cache.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function () {\\n    this.cache = new Map()\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function (key, value, duration) {\\n    const tmId = setTimeout(() => {\\n        this.cache.delete(key)\\n    }, duration)\\n\\n    const result = this.cache.get(key)\\n    this.cache.set(key, { value, tmId })\\n    if (result) clearTimeout(result.tmId)\\n\\n    return Boolean(result)\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function (key) {\\n    return this.cache.get(key)?.value ?? -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function () {\\n    return this.cache.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3767943,
                "title": "js-no-timers",
                "content": "# Approach\\nHide expired items, clean them on count call\\n\\n# Complexity\\n- Time complexity:\\nget O(1)\\nset O(1)\\ncount O(n)\\n\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass TimeLimitedCache  {\\n    constructor() {\\n        this.store = new Map();\\n    }\\n\\n    set(key, value, duration) {\\n        const item = this.get(key);\\n        this.store.set(key, {\\n            ts: Date.now() + duration,\\n            value\\n        });\\n        return item !== -1;\\n    }\\n\\n    get(key) {\\n        const item = this.store.get(key);\\n        return this.isAlive(item) ? item.value : -1;\\n    }\\n\\n    count() {\\n        this.sweep();\\n        return this.store.size;\\n    }\\n\\n    isAlive(item) {\\n        return item && item.ts > Date.now();\\n    }\\n\\n    sweep() {\\n        this.store.forEach((val, key) => {\\n            if (!this.isAlive(val)) {\\n                this.store.delete(key);\\n            }\\n        });\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass TimeLimitedCache  {\\n    constructor() {\\n        this.store = new Map();\\n    }\\n\\n    set(key, value, duration) {\\n        const item = this.get(key);\\n        this.store.set(key, {\\n            ts: Date.now() + duration,\\n            value\\n        });\\n        return item !== -1;\\n    }\\n\\n    get(key) {\\n        const item = this.store.get(key);\\n        return this.isAlive(item) ? item.value : -1;\\n    }\\n\\n    count() {\\n        this.sweep();\\n        return this.store.size;\\n    }\\n\\n    isAlive(item) {\\n        return item && item.ts > Date.now();\\n    }\\n\\n    sweep() {\\n        this.store.forEach((val, key) => {\\n            if (!this.isAlive(val)) {\\n                this.store.delete(key);\\n            }\\n        });\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763612,
                "title": "using-class",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TimeLimitedCache {\\n    cache = new Map();\\n\\n    set(key, value, duration) {\\n    const exists = this.cache.get(key);\\n    if(exists){\\n        clearTimeout(exists.timeOut)\\n    }\\n    const timeOut = setTimeout(()=>{\\n        this.cache.delete(key);\\n    },duration);\\n    this.cache.set(key,{value,timeOut})\\n    return Boolean(exists)\\n};\\n\\nget(key) {\\n    if (this.cache.has(key))\\n        return this.cache.get(key).value;\\n    return -1;\\n};\\n\\ncount() {\\n    return this.cache.size;\\n};\\n\\n}\\n\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass TimeLimitedCache {\\n    cache = new Map();\\n\\n    set(key, value, duration) {\\n    const exists = this.cache.get(key);\\n    if(exists){\\n        clearTimeout(exists.timeOut)\\n    }\\n    const timeOut = setTimeout(()=>{\\n        this.cache.delete(key);\\n    },duration);\\n    this.cache.set(key,{value,timeOut})\\n    return Boolean(exists)\\n};\\n\\nget(key) {\\n    if (this.cache.has(key))\\n        return this.cache.get(key).value;\\n    return -1;\\n};\\n\\ncount() {\\n    return this.cache.size;\\n};\\n\\n}\\n\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757951,
                "title": "typescript-very-simple-solution-map-settimeout-cleartimeout",
                "content": "# Code\\n```\\nclass TimeLimitedCache {\\n    private keyMap:Map<number,any>;\\n    constructor() {\\n        this.keyMap = new Map<number,any>(); \\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        var existed:boolean = this.keyMap.has(key);\\n        if(existed) clearTimeout(this.keyMap.get(key).clearRef);\\n\\n        this.keyMap.set(key,{\\n            value,\\n            clearRef:setTimeout(()=>{\\n                this.keyMap.delete(key);\\n            },duration)\\n        });   \\n        return existed;\\n    }\\n\\n    get(key: number): number {\\n        return this.keyMap.has(key) ? this.keyMap.get(key).value : -1;\\n    }\\n\\n\\tcount(): number {\\n        return this.keyMap.size;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass TimeLimitedCache {\\n    private keyMap:Map<number,any>;\\n    constructor() {\\n        this.keyMap = new Map<number,any>(); \\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        var existed:boolean = this.keyMap.has(key);\\n        if(existed) clearTimeout(this.keyMap.get(key).clearRef);\\n\\n        this.keyMap.set(key,{\\n            value,\\n            clearRef:setTimeout(()=>{\\n                this.keyMap.delete(key);\\n            },duration)\\n        });   \\n        return existed;\\n    }\\n\\n    get(key: number): number {\\n        return this.keyMap.has(key) ? this.keyMap.get(key).value : -1;\\n    }\\n\\n\\tcount(): number {\\n        return this.keyMap.size;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730110,
                "title": "solution-using-class",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInstead of using the given code template in function. I try this code in a different way using Classes.  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code creates a Time-Limited Cache, allowing you to store key-value pairs with an expiration time. It uses a Map to store the data. \\n\\nThe cache has three methods:\\n\\n1. `set(key, value, duration)`: Sets a key-value pair in the cache with a specified duration. Previous entries with the same key are removed, and a timer is set to delete the entry after the duration.\\n\\n2. `get(key)`: Retrieves the value associated with a key from the cache. Returns -1 if the key doesn\\'t exist.\\n\\n3. `count()`: Returns the number of key-value pairs in the cache.\\n\\nWith this cache, you can store data for a limited time and efficiently access it when needed.\\n\\n# Code\\n```\\nclass TimeLimitedCache\\n{\\n    cache= new Map();\\n    set(key,value,duration)\\n    {\\n        const alreadyExists= this.cache.get(key);\\n        if(alreadyExists)\\n        {\\n            clearTimeout(alreadyExists.timeoutId);\\n        }\\n        const timeoutId=setTimeout(()=>{\\n            this.cache.delete(key);\\n        },duration);\\n        this.cache.set(key,{value,timeoutId});\\n        return Boolean(alreadyExists)\\n\\n    };\\n    get(key)\\n    {\\n        if(this.cache.has(key))\\n        return this.cache.get(key).value;\\n        return -1;\\n    };\\n    count()\\n    {\\n        return this.cache.size;\\n    };\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass TimeLimitedCache\\n{\\n    cache= new Map();\\n    set(key,value,duration)\\n    {\\n        const alreadyExists= this.cache.get(key);\\n        if(alreadyExists)\\n        {\\n            clearTimeout(alreadyExists.timeoutId);\\n        }\\n        const timeoutId=setTimeout(()=>{\\n            this.cache.delete(key);\\n        },duration);\\n        this.cache.set(key,{value,timeoutId});\\n        return Boolean(alreadyExists)\\n\\n    };\\n    get(key)\\n    {\\n        if(this.cache.has(key))\\n        return this.cache.get(key).value;\\n        return -1;\\n    };\\n    count()\\n    {\\n        return this.cache.size;\\n    };\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729466,
                "title": "without-using-settimeout",
                "content": "# Intuition\\n- Model the key expiration at the time the call is made.\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- I feel that the problem with having a lot of self expiring timmeouts is that they don\\'t scale very well.\\n- Imagine having a lot of key-value pairs, each of them carrying their own expiring timeouts, it shouldn\\'t be good.\\n- Use key-value pairs along with the duration. On every get/set call, check if the key is expired.\\n- For every count call, iterate over the cache, count the number of unexpired keys.\\n- Moreover, as an optimization, while counting the valid keys, remove the expired ones. \\n\\n# Complexity\\n- Time complexity:\\nO(1) for every get/set call, O(n) for each count call\\n\\n- Space complexity:\\nO(n) where n is the total number of keys\\n\\n# Code\\n\\n```js\\nvar TimeLimitedCache = function() {\\n    this.init = 0;\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const NOW = (new Date()).getTime();\\n    const existing = this.cache.get(key);\\n    if (existing && existing.duration>NOW){\\n        this.cache.set(key, {value, duration: duration + NOW });\\n        return true;\\n    }\\n    this.cache.set(key, {value, duration: duration + NOW });\\n    return false;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    const NOW = (new Date()).getTime();\\n    const existing = this.cache.get(key);\\n    if (!existing || existing.duration<NOW){\\n        return -1;\\n    }\\n    return existing.value;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    const NOW = (new Date()).getTime();\\n    let count = 0;\\n    for(const [key, obj] of this.cache){\\n        if (obj.duration>NOW)count++;\\n        else this.cache.delete(key);\\n    }\\n    return count;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar TimeLimitedCache = function() {\\n    this.init = 0;\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const NOW = (new Date()).getTime();\\n    const existing = this.cache.get(key);\\n    if (existing && existing.duration>NOW){\\n        this.cache.set(key, {value, duration: duration + NOW });\\n        return true;\\n    }\\n    this.cache.set(key, {value, duration: duration + NOW });\\n    return false;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    const NOW = (new Date()).getTime();\\n    const existing = this.cache.get(key);\\n    if (!existing || existing.duration<NOW){\\n        return -1;\\n    }\\n    return existing.value;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    const NOW = (new Date()).getTime();\\n    let count = 0;\\n    for(const [key, obj] of this.cache){\\n        if (obj.duration>NOW)count++;\\n        else this.cache.delete(key);\\n    }\\n    return count;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3729294,
                "title": "iskeyexpired",
                "content": "\\n# Use of isKeyExpired function to validate if the key has expired.\\nThe key has expired if `Date.now()` is after `expireEpoch` \\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map()\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    // store the epoch time as the duration, on every get request\\n    const valueFromMap = this.cache.get(key)\\n\\n    let expireEpoch;\\n    if(valueFromMap && !this.isKeyExpired(key)){\\n        expireEpoch =  Date.now() + duration\\n        this.cache.set(key, {value, expireEpoch})\\n        return true\\n    } else {\\n        expireEpoch =  Date.now() + duration\\n        this.cache.set(key, {value, expireEpoch})\\n        return false\\n    }\\n};\\n\\n/**\\n * Key is expired if Date.now is greater than expireEpoch\\n */\\nTimeLimitedCache.prototype.isKeyExpired = function(key){\\n    if(this.cache.get(key)) return this.cache.get(key).expireEpoch <= Date.now()\\n    return true\\n}\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(this.isKeyExpired(key)) return -1\\n    return this.cache.get(key).value\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    const validEntries = [...this.cache.keys()].filter((k) => !this.isKeyExpired(k))\\n    return validEntries.length\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map()\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    // store the epoch time as the duration, on every get request\\n    const valueFromMap = this.cache.get(key)\\n\\n    let expireEpoch;\\n    if(valueFromMap && !this.isKeyExpired(key)){\\n        expireEpoch =  Date.now() + duration\\n        this.cache.set(key, {value, expireEpoch})\\n        return true\\n    } else {\\n        expireEpoch =  Date.now() + duration\\n        this.cache.set(key, {value, expireEpoch})\\n        return false\\n    }\\n};\\n\\n/**\\n * Key is expired if Date.now is greater than expireEpoch\\n */\\nTimeLimitedCache.prototype.isKeyExpired = function(key){\\n    if(this.cache.get(key)) return this.cache.get(key).expireEpoch <= Date.now()\\n    return true\\n}\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(this.isKeyExpired(key)) return -1\\n    return this.cache.get(key).value\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    const validEntries = [...this.cache.keys()].filter((k) => !this.isKeyExpired(k))\\n    return validEntries.length\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3726463,
                "title": "solution-without-map",
                "content": "\\n# TypeScript Code\\n```\\ninterface Cache {\\n    [key:number]: {\\n        value:number;\\n        timer: ReturnType<typeof setTimeout>;\\n    }\\n}\\nclass TimeLimitedCache {\\n    private cache:Cache = <Cache>{};\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        const allready:boolean = key in this.cache;\\n        if(allready) clearTimeout(this.cache[key].timer);\\n        this.cache[key] = {\\n            value: value,\\n            timer: setTimeout(() => delete this.cache[key], duration)\\n        }\\n        return allready;\\n    }\\n\\n    get(key: number): number {\\n        return key in this.cache ? this.cache[key].value : -1;\\n    }\\n\\n    count(): number {\\n        return Object.keys(this.cache).length; \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ninterface Cache {\\n    [key:number]: {\\n        value:number;\\n        timer: ReturnType<typeof setTimeout>;\\n    }\\n}\\nclass TimeLimitedCache {\\n    private cache:Cache = <Cache>{};\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        const allready:boolean = key in this.cache;\\n        if(allready) clearTimeout(this.cache[key].timer);\\n        this.cache[key] = {\\n            value: value,\\n            timer: setTimeout(() => delete this.cache[key], duration)\\n        }\\n        return allready;\\n    }\\n\\n    get(key: number): number {\\n        return key in this.cache ? this.cache[key].value : -1;\\n    }\\n\\n    count(): number {\\n        return Object.keys(this.cache).length; \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724688,
                "title": "cache-with-time-limit-30-days-of-javascript-day-17",
                "content": "# Approach\\n- The cache is implemented using a `Map`, where the keys are the cache keys and the values are arrays containing the expiration time and the corresponding value.\\n\\n- The `set()` method accepts a key, value, and duration. It checks if the key already exists in the cache. If it does, it checks if the key has expired by comparing the current time with the stored expiration time. If the key is still valid, it returns `true` to indicate that the key already existed and was unexpired. If the key is expired or doesn\\'t exist, it sets the key-value pair in the cache with the new expiration time and returns `false`.\\n\\n- The `get()` method accepts a key and retrieves the corresponding value from the cache. It first checks if the key exists in the cache. If it doesn\\'t, it returns `-1`. If the key exists, it checks if the key has expired by comparing the current time with the stored expiration time. If the key is expired, it deletes the key from the cache and returns `-1`. Otherwise, it returns the associated value.\\n\\n- The `count()` method counts the number of non-expired keys in the cache. It iterates over the entries in the cache and checks if each key has expired. If a key is expired, it is deleted from the cache. The method returns the count of non-expired keys.\\n\\n## Time Complexity\\n- Time complexity:\\n\\n- The time complexity of the `set()` method is `O(1)` because it involves checking and setting values in a Map.\\n\\n- The time complexity of the `get()` method is `O(1)` because it involves accessing values from a Map.\\n\\n- The time complexity of the `count()` method is `O(n)`, where n is the number of entries in the cache. It involves iterating over the entries and deleting expired keys.\\n\\n## Space Complexity\\n- The space complexity is `O(n)`, where n is the number of entries in the cache. The cache is implemented using a Map which stores the key-value pairs and their expiration times.\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.map = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let res = false;\\n    if (this.map.has(key)) {\\n        const [limit] = this.map.get(key);\\n        res = !(Date.now() > limit);\\n    }\\n    this.map.set(key, [Date.now() + duration, value]);\\n    return res;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (!this.map.has(key)) return -1;\\n    const [limit, val] = this.map.get(key);\\n    if (Date.now() > limit) {\\n        this.map.delete(key);\\n        return -1;\\n    }\\n    return val;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let res = 0;\\n    for(const [key, value] of this.map.entries()) {\\n        const [limit] = value;\\n        if (!(Date.now() > limit)) res++;\\n        else this.map.delete(key);\\n    }\\n    return res;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.map = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let res = false;\\n    if (this.map.has(key)) {\\n        const [limit] = this.map.get(key);\\n        res = !(Date.now() > limit);\\n    }\\n    this.map.set(key, [Date.now() + duration, value]);\\n    return res;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (!this.map.has(key)) return -1;\\n    const [limit, val] = this.map.get(key);\\n    if (Date.now() > limit) {\\n        this.map.delete(key);\\n        return -1;\\n    }\\n    return val;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let res = 0;\\n    for(const [key, value] of this.map.entries()) {\\n        const [limit] = value;\\n        if (!(Date.now() > limit)) res++;\\n        else this.map.delete(key);\\n    }\\n    return res;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3724269,
                "title": "simple-and-short-solution",
                "content": "```js\\nclass TimeLimitedCache {\\n    constructor() {\\n        this.cache = {};\\n    }\\n\\n    set(key,value,duration) {\\n        let now = Date.now(), exists = false;\\n        if (this.cache[key] && this.cache[key].expiry > now)\\n            exists = true;\\n        \\n        this.cache[key] = {value: value, expiry: now + duration};\\n        return exists;\\n    }\\n\\n    get(key) {\\n        let now = Date.now();\\n        \\n        if (this.cache[key] && !(this.cache[key].expiry < now))\\n            return this.cache[key].value\\n\\n        return -1\\n    }\\n\\n    count() {\\n        let now = Date.now(), n = 0;\\n\\n        Object.keys(this.cache).forEach(item => {\\n            n += this.cache[item].expiry > now ? 1 : 0;\\n        }) \\n\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nclass TimeLimitedCache {\\n    constructor() {\\n        this.cache = {};\\n    }\\n\\n    set(key,value,duration) {\\n        let now = Date.now(), exists = false;\\n        if (this.cache[key] && this.cache[key].expiry > now)\\n            exists = true;\\n        \\n        this.cache[key] = {value: value, expiry: now + duration};\\n        return exists;\\n    }\\n\\n    get(key) {\\n        let now = Date.now();\\n        \\n        if (this.cache[key] && !(this.cache[key].expiry < now))\\n            return this.cache[key].value\\n\\n        return -1\\n    }\\n\\n    count() {\\n        let now = Date.now(), n = 0;\\n\\n        Object.keys(this.cache).forEach(item => {\\n            n += this.cache[item].expiry > now ? 1 : 0;\\n        }) \\n\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721833,
                "title": "easiest-way-to-solve-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.cage = new Map();\\n    \\n    \\n};\\n\\n\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let isAble = this.cage.has(key);\\n    if(isAble) clearTimeout(this.cage.get(key).reference);\\n    this.cage.set(key, {\\n        value,\\n        reference : setTimeout(()=> this.cage.delete(key), duration)\\n    });\\n    return isAble;\\n    \\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.cage.has(key) ? this.cage.get(key).value : -1;\\n    \\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cage.size;\\n    \\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cage = new Map();\\n    \\n    \\n};\\n\\n\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let isAble = this.cage.has(key);\\n    if(isAble) clearTimeout(this.cage.get(key).reference);\\n    this.cage.set(key, {\\n        value,\\n        reference : setTimeout(()=> this.cage.delete(key), duration)\\n    });\\n    return isAble;\\n    \\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.cage.has(key) ? this.cage.get(key).value : -1;\\n    \\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cage.size;\\n    \\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3716574,
                "title": "js-using-function-settimeout-map",
                "content": "# Intuition\\nKey value set is mentioned so it is obvious to use map.\\n\\n# Approach\\nThere are 2 maps \\nmp: For key & value (For cache)\\ntimer: For key & timerID from setTimeout (as value)\\n\\ntimer is required for one scenario, where we add same key set to map. You need to remove the existing timeout callback before creating a new callback.\\n\\n\\n# Code\\n```\\n\\nvar TimeLimitedCache = function() {\\n    this.mp = new Map();\\n    this.timer = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n\\n    const hasKey = this.mp.has(key);\\n    this.mp.set(key, value);\\n\\n    if(this.timer.has(key)){\\n        clearTimeout(this.timer.get(key))\\n    }\\n    \\n    let timer = setTimeout(()=>{\\n        this.mp.delete(key);\\n    },duration)\\n\\n    this.timer.set(key, timer);\\n\\n    return hasKey;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(this.mp.has(key)) return this.mp.get(key);\\n\\n    return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.mp.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar TimeLimitedCache = function() {\\n    this.mp = new Map();\\n    this.timer = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n\\n    const hasKey = this.mp.has(key);\\n    this.mp.set(key, value);\\n\\n    if(this.timer.has(key)){\\n        clearTimeout(this.timer.get(key))\\n    }\\n    \\n    let timer = setTimeout(()=>{\\n        this.mp.delete(key);\\n    },duration)\\n\\n    this.timer.set(key, timer);\\n\\n    return hasKey;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(this.mp.has(key)) return this.mp.get(key);\\n\\n    return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.mp.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3711537,
                "title": "simple-solution",
                "content": "# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.keys = {}\\n    this.timeout = function(key, duration){\\n        return setTimeout(()=>{\\n            delete this.keys[key];\\n        }, duration)\\n    }\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const exists = this.keys[key] !== undefined;\\n    if(exists) clearTimeout(this.keys[key].timeout)\\n    this.keys[key] = {value, timeout:this.timeout(key, duration)}\\n    return exists\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(this.keys[key] !== undefined) return this.keys[key].value\\n    else return -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.keys).length\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```\\n\\n# Explaintion\\n**First :** Constructor\\n```\\nvar TimeLimitedCache = function() {\\n    this.keys = {}\\n    this.timeout = function(key, duration){\\n        return setTimeout(()=>{\\n            delete this.keys[key];\\n        }, duration)\\n    }\\n};\\n```\\n\\nhere we defiend 2 things,\\n1. ```this.keys```: a normal JS object that will be our chach, each ```key``` will have 2 properties:\\n    1. ```value``` the value of the key\\n    2. ```timeout``` the id of the timer generated by ```setTimeout```\\n2. ```this.timeout```: an ***optional*** function that returns a ```setTimeout``` that will delete the ```key``` after ```duration```, you can skip this and in the ```setter``` just write normal ```setTimeout``` but I prefer it for cleaner code\\n---\\n**Second :** The setter\\n```\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const exists = this.keys[key] !== undefined;\\n    if(exists) clearTimeout(this.keys[key].timeout)\\n    this.keys[key] = {value, timeout:this.timeout(key, duration)}\\n    return exists\\n};\\n```\\n\\nwe have 4 lines,\\n1. ```exists```: A **boolean** value of whether  the key exists or not\\n2. If key ```exists``` we clear its timer so it doesn\\'t delete the key based on old duration\\n3. We set the ```value``` and the ```timer``` for  ```this.keys[key]```, it doesn\\'t matter if it exists or not because even if it exists we update its ```value``` and ```duration``` \\n4. Last but not least we return ```exists```\\n---\\n**Third :** The getter\\n```\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(this.keys[key] !== undefined) return this.keys[key].value\\n    else return -1\\n};\\n```\\n\\nsimply if the key exists we return its ```value``` otherwise we return ```-1```\\n\\n---\\n**Fourth :** The count function\\n```\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.keys).length\\n};\\n```\\n\\nhere we return the number of keys of the objct ```this.keys```knowing that ```Object.keys(obj)``` returns a string array of the keys in ```obj```\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.keys = {}\\n    this.timeout = function(key, duration){\\n        return setTimeout(()=>{\\n            delete this.keys[key];\\n        }, duration)\\n    }\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const exists = this.keys[key] !== undefined;\\n    if(exists) clearTimeout(this.keys[key].timeout)\\n    this.keys[key] = {value, timeout:this.timeout(key, duration)}\\n    return exists\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(this.keys[key] !== undefined) return this.keys[key].value\\n    else return -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.keys).length\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```\n```\\nvar TimeLimitedCache = function() {\\n    this.keys = {}\\n    this.timeout = function(key, duration){\\n        return setTimeout(()=>{\\n            delete this.keys[key];\\n        }, duration)\\n    }\\n};\\n```\n```this.keys```\n```key```\n```value```\n```timeout```\n```setTimeout```\n```this.timeout```\n```setTimeout```\n```key```\n```duration```\n```setter```\n```setTimeout```\n```\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const exists = this.keys[key] !== undefined;\\n    if(exists) clearTimeout(this.keys[key].timeout)\\n    this.keys[key] = {value, timeout:this.timeout(key, duration)}\\n    return exists\\n};\\n```\n```exists```\n```exists```\n```value```\n```timer```\n```this.keys[key]```\n```value```\n```duration```\n```exists```\n```\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(this.keys[key] !== undefined) return this.keys[key].value\\n    else return -1\\n};\\n```\n```value```\n```-1```\n```\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.keys).length\\n};\\n```\n```this.keys```\n```Object.keys(obj)```\n```obj```",
                "codeTag": "Unknown"
            },
            {
                "id": 3704759,
                "title": "9-line-simple-solution-using-settimeout-example",
                "content": "```\\n\\nvar TimeLimitedCache = function() {\\n    this.cache = {}\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    setTimeout(()=>{\\n        let origin = value\\n        if(this.cache[key] === value){\\n           delete this.cache[key]\\n       }\\n    }, duration)\\n    \\n    if(key in this.cache){\\n        this.cache[key] = value\\n        return true\\n    }\\n    this.cache[key] = value\\n    return false\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.cache[key]?? -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.cache).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n\\nvar TimeLimitedCache = function() {\\n    this.cache = {}\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    setTimeout(()=>{\\n        let origin = value\\n        if(this.cache[key] === value){\\n           delete this.cache[key]\\n       }\\n    }, duration)\\n    \\n    if(key in this.cache){\\n        this.cache[key] = value\\n        return true\\n    }\\n    this.cache[key] = value\\n    return false\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.cache[key]?? -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.cache).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3695882,
                "title": "solution-using-js-55ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.hashObj = {}\\n    \\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let isAvail = false\\n\\n    if(this.hashObj?.[key]) {\\n        isAvail = true\\n        let previousTimerId = this.hashObj?.[key]?.[1]\\n        clearTimeout(previousTimerId)\\n    }\\n    let timerId = setTimeout(() => {\\n        delete this.hashObj[key]\\n    }, duration)\\n\\n    this.hashObj[key] = [value, timerId]\\n    return isAvail\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.hashObj?.[key]?.[0] || -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.hashObj).length\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.hashObj = {}\\n    \\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let isAvail = false\\n\\n    if(this.hashObj?.[key]) {\\n        isAvail = true\\n        let previousTimerId = this.hashObj?.[key]?.[1]\\n        clearTimeout(previousTimerId)\\n    }\\n    let timerId = setTimeout(() => {\\n        delete this.hashObj[key]\\n    }, duration)\\n\\n    this.hashObj[key] = [value, timerId]\\n    return isAvail\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.hashObj?.[key]?.[0] || -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.hashObj).length\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3673801,
                "title": "63-milsicunds-who-s-less",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.data = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n     if(this.data[key]) {\\n        clearTimeout(this.setiTimoutId);\\n    }\\n\\n    const hasKey = !!this.data[key];\\n    this.data[key] = value;\\n    this.setiTimoutId = setTimeout(() => this.data[key] = false, duration);\\n    return hasKey;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.data[key] ? this.data[key] : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let count = 0;\\n    for (key in this.data) {\\n        if (this.data[key]) {\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.data = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n     if(this.data[key]) {\\n        clearTimeout(this.setiTimoutId);\\n    }\\n\\n    const hasKey = !!this.data[key];\\n    this.data[key] = value;\\n    this.setiTimoutId = setTimeout(() => this.data[key] = false, duration);\\n    return hasKey;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.data[key] ? this.data[key] : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let count = 0;\\n    for (key in this.data) {\\n        if (this.data[key]) {\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3651858,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.timeLimitedMap = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n\\n   const isKeyPresent = this.timeLimitedMap.has(key);\\n   if(isKeyPresent){\\n      const timeoutId = this.timeLimitedMap.get(key).timeoutId;\\n      clearTimeout(timeoutId);\\n   }\\n   this.timeLimitedMap.set(key,{\\n       value:value,\\n       timeoutId: setTimeout(()=>{\\n            this.timeLimitedMap.delete(key);\\n        },duration)\\n   });\\n\\n   return isKeyPresent;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(this.timeLimitedMap.has(key)){\\n        return this.timeLimitedMap.get(key).value;\\n    }\\n    return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.timeLimitedMap.size;\\n    \\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.timeLimitedMap = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n\\n   const isKeyPresent = this.timeLimitedMap.has(key);\\n   if(isKeyPresent){\\n      const timeoutId = this.timeLimitedMap.get(key).timeoutId;\\n      clearTimeout(timeoutId);\\n   }\\n   this.timeLimitedMap.set(key,{\\n       value:value,\\n       timeoutId: setTimeout(()=>{\\n            this.timeLimitedMap.delete(key);\\n        },duration)\\n   });\\n\\n   return isKeyPresent;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(this.timeLimitedMap.has(key)){\\n        return this.timeLimitedMap.get(key).value;\\n    }\\n    return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.timeLimitedMap.size;\\n    \\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3643399,
                "title": "simple-solution-without-need-for-this-and-class",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution uses `Map`, `setTimeout`, and `clearTimout`.\\n- A `Map` object is used for cache. \\n- Once `key`,`value` is added to map, we need to set timout for `duration` and delete the key in its callback. \\n- However, when the key is overwritten by new value with new `duration`, the new key can get deleted with the old timeout set. Therefore we need to keep reference to timeout object for every key and use `clearTimout` to clear it and then set new timeout for new duration.\\n- So the key value need to be an object having `{value, timeout}`.\\n\\n\\n# Code\\n```\\n\\nvar TimeLimitedCache = function() { \\n    cacheMap = new Map()\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let output\\n    if(cacheMap.has(key)) {\\n        output=true\\n        clearTimeout(cacheMap.get(key).timeout)\\n    }\\n    else output=false\\n\\n    let timeout = setTimeout(()=>{cacheMap.delete(key)},duration)\\n    cacheMap.set(key,{value,timeout})\\n    return output\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(cacheMap.has(key)) return cacheMap.get(key).value\\n    return -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return cacheMap.size\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar TimeLimitedCache = function() { \\n    cacheMap = new Map()\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let output\\n    if(cacheMap.has(key)) {\\n        output=true\\n        clearTimeout(cacheMap.get(key).timeout)\\n    }\\n    else output=false\\n\\n    let timeout = setTimeout(()=>{cacheMap.delete(key)},duration)\\n    cacheMap.set(key,{value,timeout})\\n    return output\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(cacheMap.has(key)) return cacheMap.get(key).value\\n    return -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return cacheMap.size\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3642001,
                "title": "simple-js-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.cache={}\\n\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function (key, value, duration) {\\n\\n    if (this.cache[key] && this.cache[key].timer) {\\n        //when cache key is same and unExpired (the timer is still there) it comes in if block\\n        //and clears the previous timeout and overwrites it \\n        clearTimeout(this.cache[key].timer)\\n\\n        //over writes the previoud timer and value\\n        this.cache[key].value = value\\n\\n        this.cache[key].timer = setTimeout(() => {\\n            delete this.cache[key]\\n        }, duration)\\n\\n        console.log(\"IF--->\", this.cache)\\n        //as per the question it returns true when the cache key is not unique\\n        return true;\\n    }\\n    else {\\n        //for the first time when key is unique it comes to the else block\\n        this.cache[key] = {\\n            value,\\n            timer: setTimeout(() => {\\n                //after duration is complete cache key will automatically gets deleted\\n                delete this.cache[key]\\n            }, duration)\\n        }\\n        console.log(\"ELSE--->\", this.cache)\\n\\n        //as per the question it returns false when the cache key is unique\\n        return false;\\n    }\\n\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(this.cache[key] && this.cache[key].timer){\\n        return this.cache[key].value;\\n    }\\n    else{\\n        return -1;\\n    }\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let c=0;\\n    for(const key in this.cache){\\n        if(this.cache[key].timer){\\n            c++;\\n        }\\n    }\\n    console.log(\"Count c-->\", c)\\n\\n    return c;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cache={}\\n\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function (key, value, duration) {\\n\\n    if (this.cache[key] && this.cache[key].timer) {\\n        //when cache key is same and unExpired (the timer is still there) it comes in if block\\n        //and clears the previous timeout and overwrites it \\n        clearTimeout(this.cache[key].timer)\\n\\n        //over writes the previoud timer and value\\n        this.cache[key].value = value\\n\\n        this.cache[key].timer = setTimeout(() => {\\n            delete this.cache[key]\\n        }, duration)\\n\\n        console.log(\"IF--->\", this.cache)\\n        //as per the question it returns true when the cache key is not unique\\n        return true;\\n    }\\n    else {\\n        //for the first time when key is unique it comes to the else block\\n        this.cache[key] = {\\n            value,\\n            timer: setTimeout(() => {\\n                //after duration is complete cache key will automatically gets deleted\\n                delete this.cache[key]\\n            }, duration)\\n        }\\n        console.log(\"ELSE--->\", this.cache)\\n\\n        //as per the question it returns false when the cache key is unique\\n        return false;\\n    }\\n\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if(this.cache[key] && this.cache[key].timer){\\n        return this.cache[key].value;\\n    }\\n    else{\\n        return -1;\\n    }\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let c=0;\\n    for(const key in this.cache){\\n        if(this.cache[key].timer){\\n            c++;\\n        }\\n    }\\n    console.log(\"Count c-->\", c)\\n\\n    return c;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3639752,
                "title": "typescript-easy-to-understand-solution",
                "content": "# Intuition\\nThe `TimeLimitedCache` class is a cache that implements a time-to-live (`TTL`) policy for objects that it stores. This means that objects added to the cache have a limited lifespan, after which they are considered expired and removed from the cache. Each object in the cache is identified by a unique key, and the cache stores `key-value` pairs.\\n\\n# Approach\\nThe `TimeLimitedCache` class uses an object `kvObject` to store `key-value` pairs, where the keys are number values and the values are objects with a value property and a timeout property. The value property holds the actual value stored in the cache for the respective key, while the timeout property is a reference to a setTimeout function that is used to expire the `key-value` pair after a specified duration.\\n\\nThe set method of the `TimeLimitedCache` class takes a key, a value, and a duration as input parameters. If the key already exists in the cache, the `setTimeout` function associated with the key is cleared using `clearTimeout`, and a new setTimeout function is created with the updated duration. If the key does not exist in the cache, a new `setTimeout` function is created with the specified duration, and the `kvObject` is updated with the new `key-value` pair and the corresponding `setTimeout` function.\\n\\nThe get method of the `TimeLimitedCache` class takes a key as input parameter and returns the value associated with the key if it exists in the kvObject. If the key is expired or does not exist in the `kvObject`, it returns -1.\\n\\nThe count method of the `TimeLimitedCache` class returns the total number of keys currently stored in the cache.\\n\\n# Complexity\\nThe time complexity of the set method is O(1) in the best and average cases, and O(n) in the worst case, where n is the number of keys currently stored in the cache.\\n\\nThe time complexity of the get method is O(1) in the best and average cases, and O(n) in the worst case, where n is the number of keys currently stored in the cache.\\n\\nThe space complexity of the `TimeLimitedCache` class is O(n), where n is the number of `key-value` pairs stored in the `kvObject`.\\n\\n# Code\\n```javascript\\nclass TimeLimitedCache {\\n    private totalKeys = 0;\\n    private kvObject: any = {};\\n\\n    constructor() {\\n\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        if (this.kvObject[`${key}`] && this.kvObject[`${key}`].value > -1) {\\n            clearTimeout(this.kvObject[`${key}`].timeout);\\n\\n            const expirer = setTimeout(() => {\\n                this.kvObject[`${key}`].value = -1;\\n                this.totalKeys -= 1;\\n            }, duration);\\n\\n            this.kvObject = Object.assign(this.kvObject, {\\n                [`${key}`]: {\\n                    value,\\n                    timeout: expirer,\\n                },\\n            });\\n\\n            return true;\\n        }\\n\\n        const expirer = setTimeout(() => {\\n            this.kvObject[`${key}`].value = -1;\\n            this.totalKeys -= 1;\\n        }, duration);\\n\\n        this.totalKeys += 1;\\n        this.kvObject = Object.assign(this.kvObject, {\\n            [`${key}`]: {\\n                value,\\n                timeout: expirer,\\n            },\\n        });\\n\\n        return false;\\n    }\\n\\n    get(key: number): number {\\n        return (this.kvObject[`${key}`] && this.kvObject[`${key}`].value) || -1;\\n    }\\n\\n\\tcount(): number {\\n        return this.totalKeys;\\n    }\\n}",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "# Intuition\\nThe `TimeLimitedCache` class is a cache that implements a time-to-live (`TTL`) policy for objects that it stores. This means that objects added to the cache have a limited lifespan, after which they are considered expired and removed from the cache. Each object in the cache is identified by a unique key, and the cache stores `key-value` pairs.\\n\\n# Approach\\nThe `TimeLimitedCache` class uses an object `kvObject` to store `key-value` pairs, where the keys are number values and the values are objects with a value property and a timeout property. The value property holds the actual value stored in the cache for the respective key, while the timeout property is a reference to a setTimeout function that is used to expire the `key-value` pair after a specified duration.\\n\\nThe set method of the `TimeLimitedCache` class takes a key, a value, and a duration as input parameters. If the key already exists in the cache, the `setTimeout` function associated with the key is cleared using `clearTimeout`, and a new setTimeout function is created with the updated duration. If the key does not exist in the cache, a new `setTimeout` function is created with the specified duration, and the `kvObject` is updated with the new `key-value` pair and the corresponding `setTimeout` function.\\n\\nThe get method of the `TimeLimitedCache` class takes a key as input parameter and returns the value associated with the key if it exists in the kvObject. If the key is expired or does not exist in the `kvObject`, it returns -1.\\n\\nThe count method of the `TimeLimitedCache` class returns the total number of keys currently stored in the cache.\\n\\n# Complexity\\nThe time complexity of the set method is O(1) in the best and average cases, and O(n) in the worst case, where n is the number of keys currently stored in the cache.\\n\\nThe time complexity of the get method is O(1) in the best and average cases, and O(n) in the worst case, where n is the number of keys currently stored in the cache.\\n\\nThe space complexity of the `TimeLimitedCache` class is O(n), where n is the number of `key-value` pairs stored in the `kvObject`.\\n\\n# Code\\n```javascript\\nclass TimeLimitedCache {\\n    private totalKeys = 0;\\n    private kvObject: any = {};\\n\\n    constructor() {\\n\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        if (this.kvObject[`${key}`] && this.kvObject[`${key}`].value > -1) {\\n            clearTimeout(this.kvObject[`${key}`].timeout);\\n\\n            const expirer = setTimeout(() => {\\n                this.kvObject[`${key}`].value = -1;\\n                this.totalKeys -= 1;\\n            }, duration);\\n\\n            this.kvObject = Object.assign(this.kvObject, {\\n                [`${key}`]: {\\n                    value,\\n                    timeout: expirer,\\n                },\\n            });\\n\\n            return true;\\n        }\\n\\n        const expirer = setTimeout(() => {\\n            this.kvObject[`${key}`].value = -1;\\n            this.totalKeys -= 1;\\n        }, duration);\\n\\n        this.totalKeys += 1;\\n        this.kvObject = Object.assign(this.kvObject, {\\n            [`${key}`]: {\\n                value,\\n                timeout: expirer,\\n            },\\n        });\\n\\n        return false;\\n    }\\n\\n    get(key: number): number {\\n        return (this.kvObject[`${key}`] && this.kvObject[`${key}`].value) || -1;\\n    }\\n\\n\\tcount(): number {\\n        return this.totalKeys;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3637368,
                "title": "based-typescript-solution",
                "content": "# Code\\n```\\ninterface Value {\\n    value: number;\\n    timeout: any;\\n}\\n\\nclass TimeLimitedCache {\\n    cache = {} as {[key: number]: Value};\\n\\n    constructor() {}\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        const keyInCache = key in this.cache;\\n        if (keyInCache)\\n            clearTimeout(this.cache[key].timeout);\\n        const newVal = {\\n            value,\\n            timeout: setTimeout(() => {\\n                delete this.cache[key];\\n            }, duration)\\n        }\\n        this.cache[key] = newVal;\\n        return keyInCache;\\n    }\\n\\n    get(key: number): number {\\n        if (!(key in this.cache))\\n            return -1;\\n        return this.cache[key].value;\\n    }\\n\\n\\tcount(): number {\\n        return Object.keys(this.cache).length;\\n    }\\n}",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "# Code\\n```\\ninterface Value {\\n    value: number;\\n    timeout: any;\\n}\\n\\nclass TimeLimitedCache {\\n    cache = {} as {[key: number]: Value};\\n\\n    constructor() {}\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        const keyInCache = key in this.cache;\\n        if (keyInCache)\\n            clearTimeout(this.cache[key].timeout);\\n        const newVal = {\\n            value,\\n            timeout: setTimeout(() => {\\n                delete this.cache[key];\\n            }, duration)\\n        }\\n        this.cache[key] = newVal;\\n        return keyInCache;\\n    }\\n\\n    get(key: number): number {\\n        if (!(key in this.cache))\\n            return -1;\\n        return this.cache[key].value;\\n    }\\n\\n\\tcount(): number {\\n        return Object.keys(this.cache).length;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3621222,
                "title": "simple-using-map-50ms-95-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.map=new Map()\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let check;\\n    if (this.map.has(key) && this.map.get(key)[1]>=Date.now()) check=true\\n    else check=false\\n    this.map.set(key,[value,Date.now()+duration])\\n    return check\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (!this.map.has(key))return -1\\n    return this.map.get(key)[1]>=Date.now() ? this.map.get(key)[0]:-1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let count=0\\n    for (const [key, value] of this.map.entries()){if (value[1]>=Date.now()) count++}\\n    return count\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.map=new Map()\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let check;\\n    if (this.map.has(key) && this.map.get(key)[1]>=Date.now()) check=true\\n    else check=false\\n    this.map.set(key,[value,Date.now()+duration])\\n    return check\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (!this.map.has(key))return -1\\n    return this.map.get(key)[1]>=Date.now() ? this.map.get(key)[0]:-1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let count=0\\n    for (const [key, value] of this.map.entries()){if (value[1]>=Date.now()) count++}\\n    return count\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3617661,
                "title": "javascript-solution-without-settimeout",
                "content": "# Code\\n```\\n\\nvar TimeLimitedCache = function() {\\n    this.cache={};\\n    this.freq=0;\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let val=this.cache[key];\\n    let time=(new Date()).getTime();\\n    if(val && val.dur>=time-val.createdAt) {\\n        this.cache[key]={\\n            val: value,\\n            createdAt: time,\\n            dur: duration\\n        };\\n        return true;\\n    }else if(val && val.dur<time-val.createdAt) {\\n        this.cache[key]={\\n            val: value,\\n            createdAt: time,\\n            dur: duration\\n        };\\n        return false;\\n    }else {\\n        this.cache[key]={\\n            val: value,\\n            createdAt: time,\\n            dur: duration\\n        };\\n        this.freq++;\\n        return false;\\n    }\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    let val=this.cache[key];\\n    let time=(new Date()).getTime();\\n\\n    if(val && val.dur>=time-val.createdAt) {\\n        return val.val;\\n    }else if(val && val.dur<time-val.createdAt) {\\n        this.cache[key]=undefined;\\n        this.freq--;\\n        return -1;\\n    }else \\n        return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let k=Object.keys(this.cache);\\n    let time=(new Date()).getTime();\\n    for(let i=0;i<k.length;i++) {\\n        let val=this.cache[k[i]];\\n        if(val && val.dur<time-val.createdAt) {\\n            this.cache[k[i]]=undefined;\\n            this.freq--;\\n        }\\n    }\\n    return this.freq;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar TimeLimitedCache = function() {\\n    this.cache={};\\n    this.freq=0;\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let val=this.cache[key];\\n    let time=(new Date()).getTime();\\n    if(val && val.dur>=time-val.createdAt) {\\n        this.cache[key]={\\n            val: value,\\n            createdAt: time,\\n            dur: duration\\n        };\\n        return true;\\n    }else if(val && val.dur<time-val.createdAt) {\\n        this.cache[key]={\\n            val: value,\\n            createdAt: time,\\n            dur: duration\\n        };\\n        return false;\\n    }else {\\n        this.cache[key]={\\n            val: value,\\n            createdAt: time,\\n            dur: duration\\n        };\\n        this.freq++;\\n        return false;\\n    }\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    let val=this.cache[key];\\n    let time=(new Date()).getTime();\\n\\n    if(val && val.dur>=time-val.createdAt) {\\n        return val.val;\\n    }else if(val && val.dur<time-val.createdAt) {\\n        this.cache[key]=undefined;\\n        this.freq--;\\n        return -1;\\n    }else \\n        return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let k=Object.keys(this.cache);\\n    let time=(new Date()).getTime();\\n    for(let i=0;i<k.length;i++) {\\n        let val=this.cache[k[i]];\\n        if(val && val.dur<time-val.createdAt) {\\n            this.cache[k[i]]=undefined;\\n            this.freq--;\\n        }\\n    }\\n    return this.freq;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3614436,
                "title": "typescript-solution",
                "content": "\\n\\n# Code\\n```\\nclass TimeLimitedCache {\\n    record: {[key: number]: number};\\n    timer: {[key: number]: ReturnType<typeof setTimeout>}\\n    constructor() {\\n        this.record = {};\\n        this.timer = {};\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        if(this.timer[key]){\\n            clearTimeout(this.timer[key]);\\n            this.record[key] =value;\\n            this.timer[key] =  setTimeout(() =>{\\n                delete this.record[key];\\n            }, duration);;\\n            return true;\\n        }\\n        this.record[key] =value;\\n        this.timer[key] = setTimeout(() =>{\\n            delete this.record[key];\\n        }, duration);;\\n        return false;\\n\\n\\n    }\\n\\n    get(key: number): number {\\n        if(this.record[key]){\\n            return this.record[key];\\n        }\\n        return -1;\\n    }\\n\\n\\tcount(): number {\\n        return Object.keys(this.record).length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass TimeLimitedCache {\\n    record: {[key: number]: number};\\n    timer: {[key: number]: ReturnType<typeof setTimeout>}\\n    constructor() {\\n        this.record = {};\\n        this.timer = {};\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        if(this.timer[key]){\\n            clearTimeout(this.timer[key]);\\n            this.record[key] =value;\\n            this.timer[key] =  setTimeout(() =>{\\n                delete this.record[key];\\n            }, duration);;\\n            return true;\\n        }\\n        this.record[key] =value;\\n        this.timer[key] = setTimeout(() =>{\\n            delete this.record[key];\\n        }, duration);;\\n        return false;\\n\\n\\n    }\\n\\n    get(key: number): number {\\n        if(this.record[key]){\\n            return this.record[key];\\n        }\\n        return -1;\\n    }\\n\\n\\tcount(): number {\\n        return Object.keys(this.record).length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609831,
                "title": "simple-readable-solution",
                "content": "Keys expires and deletes from cache object with setTimeout callback. If a set a key again just a clear previous timeout with `clearTimeout`.\\n\\nGet is just accessing an object value by key if found or return `-1` otherwise.\\n\\nMethod `count` return cache object keys length.\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.cache = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const cached = this.cache[key];\\n    if (cached) {\\n        clearTimeout(cached.expirationTimerId);\\n    }\\n\\n    this.cache[key] = {\\n        expirationTimerId: setTimeout(() => {\\n            delete this.cache[key];\\n        }, duration),\\n        value,\\n    };\\n\\n    return !!cached;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    const cached = this.cache[key];\\n    return (cached && cached.value) || -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.cache).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cache = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const cached = this.cache[key];\\n    if (cached) {\\n        clearTimeout(cached.expirationTimerId);\\n    }\\n\\n    this.cache[key] = {\\n        expirationTimerId: setTimeout(() => {\\n            delete this.cache[key];\\n        }, duration),\\n        value,\\n    };\\n\\n    return !!cached;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    const cached = this.cache[key];\\n    return (cached && cached.value) || -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.cache).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3597063,
                "title": "easy-and-fast-solution",
                "content": "# Intuition\\nNeed to get a new timeout if key already present. Rest all looks like a plain cache implementation using inbuilt Map data structure\\n# Approach\\nUse setTimeout JS engine (web api) to hold an \\'expiry\\'. Renew the expiry by using clearTimeout api and retrigger a new timeout/expiry\\n# Complexity\\n- Time complexity:\\nUses inbuild Map DS so the set and get menthods has same retrival and insertion time complexity as of Map implemenation. O(log n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSame as time complexity for Map implementation\\n# Code\\n```\\nclass TimeLimitedCache {\\n\\tprivate _cache = new Map();\\n\\tconstructor() {}\\n\\n\\tset(key: number, value: number, duration: number): boolean {\\n\\t\\tif (!this._cache.get(key)) {\\n\\t\\t\\tthis.setAndClearKeyAfterDuration(key, value, duration, false);\\n\\t\\t\\treturn false;\\n\\t\\t} else {\\n\\t\\t\\t// key is already there clear the timeout and add a new\\n\\t\\t\\tthis.setAndClearKeyAfterDuration(key, value, duration, true);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\n\\tget(key: number): number {\\n\\t\\tif (this._cache.get(key)) {\\n\\t\\t\\treturn this._cache.get(key).value;\\n\\t\\t} else {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\n\\tcount(): number {\\n\\t\\treturn this._cache.size;\\n\\t}\\n\\n\\tsetAndClearKeyAfterDuration(key: number, value: number, time: number, timeoutSet: boolean) {\\n\\t\\tlet timeoutId: any;\\n\\t\\tif (!timeoutSet) {\\n\\t\\t\\ttimeoutId = setTimeout(() => {\\n\\t\\t\\t\\tthis._cache.delete(key);\\n\\t\\t\\t}, time);\\n\\t\\t} else {\\n\\t\\t\\ttimeoutId = this._cache.get(key).timeoutId;\\n\\t\\t\\tclearTimeout(timeoutId);\\n\\t\\t\\t// get a new timeout\\n\\t\\t\\ttimeoutId = setTimeout(() => {\\n\\t\\t\\t\\tthis._cache.delete(key);\\n\\t\\t\\t}, time);\\n\\t\\t}\\n\\n\\t\\tthis._cache.set(key, { value, timeoutId });\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass TimeLimitedCache {\\n\\tprivate _cache = new Map();\\n\\tconstructor() {}\\n\\n\\tset(key: number, value: number, duration: number): boolean {\\n\\t\\tif (!this._cache.get(key)) {\\n\\t\\t\\tthis.setAndClearKeyAfterDuration(key, value, duration, false);\\n\\t\\t\\treturn false;\\n\\t\\t} else {\\n\\t\\t\\t// key is already there clear the timeout and add a new\\n\\t\\t\\tthis.setAndClearKeyAfterDuration(key, value, duration, true);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\n\\tget(key: number): number {\\n\\t\\tif (this._cache.get(key)) {\\n\\t\\t\\treturn this._cache.get(key).value;\\n\\t\\t} else {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\n\\tcount(): number {\\n\\t\\treturn this._cache.size;\\n\\t}\\n\\n\\tsetAndClearKeyAfterDuration(key: number, value: number, time: number, timeoutSet: boolean) {\\n\\t\\tlet timeoutId: any;\\n\\t\\tif (!timeoutSet) {\\n\\t\\t\\ttimeoutId = setTimeout(() => {\\n\\t\\t\\t\\tthis._cache.delete(key);\\n\\t\\t\\t}, time);\\n\\t\\t} else {\\n\\t\\t\\ttimeoutId = this._cache.get(key).timeoutId;\\n\\t\\t\\tclearTimeout(timeoutId);\\n\\t\\t\\t// get a new timeout\\n\\t\\t\\ttimeoutId = setTimeout(() => {\\n\\t\\t\\t\\tthis._cache.delete(key);\\n\\t\\t\\t}, time);\\n\\t\\t}\\n\\n\\t\\tthis._cache.set(key, { value, timeoutId });\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594605,
                "title": "my-js-solution-saving-timeoutes-with-a-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.experationMap = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let keyAlreadyExisted = false;\\n\\n    //if key exists cancel old experation\\n    if(this.hasOwnProperty(key) && this.experationMap.has(key)){\\n        clearTimeout(this.experationMap.get(key));\\n        keyAlreadyExisted = true;\\n    }\\n\\n    this[key] = value;\\n\\n    //delete key after duration\\n    this.experationMap.set(key,\\n        setTimeout(() => {\\n            delete this[key];\\n            this.experationMap.delete(key);\\n        }, duration)\\n    );\\n\\n    return keyAlreadyExisted;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    //return key or -1 if key does not exist\\n    return this.hasOwnProperty(key) ? this[key] : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    //-1 is because we dont want to count the experationMap property\\n    return Object.keys(this).length - 1;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.experationMap = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let keyAlreadyExisted = false;\\n\\n    //if key exists cancel old experation\\n    if(this.hasOwnProperty(key) && this.experationMap.has(key)){\\n        clearTimeout(this.experationMap.get(key));\\n        keyAlreadyExisted = true;\\n    }\\n\\n    this[key] = value;\\n\\n    //delete key after duration\\n    this.experationMap.set(key,\\n        setTimeout(() => {\\n            delete this[key];\\n            this.experationMap.delete(key);\\n        }, duration)\\n    );\\n\\n    return keyAlreadyExisted;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    //return key or -1 if key does not exist\\n    return this.hasOwnProperty(key) ? this[key] : -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    //-1 is because we dont want to count the experationMap property\\n    return Object.keys(this).length - 1;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593494,
                "title": "day-14-javascript-solution",
                "content": "# Code\\n```\\nvar TimeLimitedCache = function() {\\n  this.cacheMap = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n  const mapValue = this.cacheMap.get(key);\\n  if (mapValue) {\\n    clearTimeout(mapValue.timeout);\\n  }\\n  const timeout = setTimeout(() => this.cacheMap.delete(key), duration);\\n  this.cacheMap.set(key, { value, timeout });\\n  return !!mapValue;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n  return this.cacheMap.get(key)?.value ?? -1;  \\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n  return this.cacheMap.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n  this.cacheMap = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n  const mapValue = this.cacheMap.get(key);\\n  if (mapValue) {\\n    clearTimeout(mapValue.timeout);\\n  }\\n  const timeout = setTimeout(() => this.cacheMap.delete(key), duration);\\n  this.cacheMap.set(key, { value, timeout });\\n  return !!mapValue;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n  return this.cacheMap.get(key)?.value ?? -1;  \\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n  return this.cacheMap.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590881,
                "title": "ok",
                "content": "```\\nvar TimeLimitedCache = function() \\n{\\n    this.m = {count : 0};\\n};\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) \\n{\\n    let hasValue = false;\\n    if(this.m[key]!=undefined) \\n    {\\n        clearTimeout(this.m[key].timeout);\\n        hasValue = true;\\n    }\\n    else\\n        ++this.m.count;\\n    this.m[key] = { value : value, timeout : setTimeout(() => { --this.m.count; this.m[key] = undefined; }, duration) };\\n    return hasValue;\\n};\\n\\nTimeLimitedCache.prototype.get = function(key) \\n{\\n    return this.m[key]!=undefined ? this.m[key].value : -1;\\n};\\n\\nTimeLimitedCache.prototype.count = function() \\n{\\n    return this.m.count;\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvar TimeLimitedCache = function() \\n{\\n    this.m = {count : 0};\\n};\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) \\n{\\n    let hasValue = false;\\n    if(this.m[key]!=undefined) \\n    {\\n        clearTimeout(this.m[key].timeout);\\n        hasValue = true;\\n    }\\n    else\\n        ++this.m.count;\\n    this.m[key] = { value : value, timeout : setTimeout(() => { --this.m.count; this.m[key] = undefined; }, duration) };\\n    return hasValue;\\n};\\n\\nTimeLimitedCache.prototype.get = function(key) \\n{\\n    return this.m[key]!=undefined ? this.m[key].value : -1;\\n};\\n\\nTimeLimitedCache.prototype.count = function() \\n{\\n    return this.m.count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587794,
                "title": "short-sweet-js-ts-settimeout-o-n-tc-map",
                "content": "# Approach\\n- Use `setTimeout` to remove items from the cache.\\n- If a key already exists in the cache, cancel its timeout.\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```javascript []\\nconst TimeLimitedCache = function() {\\n    this.cache = new Map();  \\n\\n    /*\\n     *  Each object will be like this:\\n     *  key,{value, id}\\n     *  \\n     *  id: setTimeout(...code)\\n     */\\n};\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let found = this.cache.has(key);\\n    if (found) clearTimeout(this.cache.get(key).id);  // Cancel previous timeout\\n    this.cache.set(key, {\\n        value,\\n        id: setTimeout(() => this.cache.delete(key), duration)\\n    });\\n    return found;\\n};\\n\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.cache.has(key) ? this.cache.get(key).value : -1;\\n};\\n\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.size;\\n};\\n```\\n```Typescript []\\nclass TimeLimitedCache {\\n    private cache: Map<number, { value: number; ref: NodeJS.Timeout }>;\\n\\n    constructor() {\\n        this.cache = new Map();\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        const found = this.cache.has(key);\\n        if (found) clearTimeout(this.cache.get(key)!.ref);\\n        this.cache.set(key, {\\n            value,\\n            ref: setTimeout(() => this.cache.delete(key), duration)\\n        });\\n        return found;\\n    }\\n\\n    get(key: number): number {\\n        return this.cache.has(key) ? this.cache.get(key)!.value : -1;\\n    }\\n\\n\\tcount(): number {\\n        return this.cache.size;\\n    }\\n}\\n```\\n\\nFor u guys :)\\n```\\nThe most effective way to do it, is to do it.\\n-Amelia Earhart\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```javascript []\\nconst TimeLimitedCache = function() {\\n    this.cache = new Map();  \\n\\n    /*\\n     *  Each object will be like this:\\n     *  key,{value, id}\\n     *  \\n     *  id: setTimeout(...code)\\n     */\\n};\\n\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let found = this.cache.has(key);\\n    if (found) clearTimeout(this.cache.get(key).id);  // Cancel previous timeout\\n    this.cache.set(key, {\\n        value,\\n        id: setTimeout(() => this.cache.delete(key), duration)\\n    });\\n    return found;\\n};\\n\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.cache.has(key) ? this.cache.get(key).value : -1;\\n};\\n\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.size;\\n};\\n```\n```Typescript []\\nclass TimeLimitedCache {\\n    private cache: Map<number, { value: number; ref: NodeJS.Timeout }>;\\n\\n    constructor() {\\n        this.cache = new Map();\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        const found = this.cache.has(key);\\n        if (found) clearTimeout(this.cache.get(key)!.ref);\\n        this.cache.set(key, {\\n            value,\\n            ref: setTimeout(() => this.cache.delete(key), duration)\\n        });\\n        return found;\\n    }\\n\\n    get(key: number): number {\\n        return this.cache.has(key) ? this.cache.get(key)!.value : -1;\\n    }\\n\\n\\tcount(): number {\\n        return this.cache.size;\\n    }\\n}\\n```\n```\\nThe most effective way to do it, is to do it.\\n-Amelia Earhart\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583076,
                "title": "javascript-easy-solution",
                "content": "\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    \\n    this.cache = new Map();\\n\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    \\n    const alreadyExists = this.cache.get(key);\\n\\n    if(alreadyExists){\\n        clearTimeout(alreadyExists.timeoutId)\\n    }\\n\\n   \\n    const timeoutId = setTimeout(()=> {\\n        // remove the key\\n        this.cache.delete(key);\\n    }, duration);\\n     this.cache.set(key, {\\n         \\'value\\' : value,\\n         timeoutId\\n     });\\n    return Boolean(alreadyExists);\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    \\n    if(this.cache.has(key))\\n        return this.cache.get(key).value;\\n    return -1\\n\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    \\n    return this.cache.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    \\n    this.cache = new Map();\\n\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    \\n    const alreadyExists = this.cache.get(key);\\n\\n    if(alreadyExists){\\n        clearTimeout(alreadyExists.timeoutId)\\n    }\\n\\n   \\n    const timeoutId = setTimeout(()=> {\\n        // remove the key\\n        this.cache.delete(key);\\n    }, duration);\\n     this.cache.set(key, {\\n         \\'value\\' : value,\\n         timeoutId\\n     });\\n    return Boolean(alreadyExists);\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    \\n    if(this.cache.has(key))\\n        return this.cache.get(key).value;\\n    return -1\\n\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    \\n    return this.cache.size;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3580269,
                "title": "easy-javascript-solution-using-object",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe best approach is always using a data structure that allows us to get O(1) when getting the values and also when deleting them based on a period of time we can save\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo for the data structure we can just use an object that stores objects like { key: \\'1\\', value: \\'example\\', timeout: setTimeout }\\n\\nWhen storing the setTimeout we can do a clearTimeout knowing which was the object we saved we executed using an especific time\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.cache = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const valueInCache = this.cache[key];\\n    if(valueInCache) {\\n        clearTimeout(valueInCache.timeout);\\n    }\\n    const timeout = setTimeout(() => {\\n        delete this.cache[key];\\n    }, duration)\\n    this.cache[key] = { value, timeout };\\n    return Boolean(valueInCache);\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.cache[key]?.value ?? -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.cache).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cache = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const valueInCache = this.cache[key];\\n    if(valueInCache) {\\n        clearTimeout(valueInCache.timeout);\\n    }\\n    const timeout = setTimeout(() => {\\n        delete this.cache[key];\\n    }, duration)\\n    this.cache[key] = { value, timeout };\\n    return Boolean(valueInCache);\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    return this.cache[key]?.value ?? -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.cache).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3571369,
                "title": "clean-optimised-and-simple-code",
                "content": "\\n\\n# Code\\n```\\n\\nclass TimeLimitedCache {\\n   cache: Record<number,{\\n     value:number,\\n     creation:number,\\n     duration:number,\\n }>\\n    constructor() {\\n      this.cache={}\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        \\n    if(this.cache[key]){\\n        this.cache[key]={\\n            value,\\n            creation:Date.now(),\\n            duration\\n        }\\n        return true\\n    }\\n      this.cache[key]={\\n            value,\\n            creation:Date.now(),\\n            duration\\n        }\\n        return false   \\n       \\n       \\n    }\\n\\n    get(key: number): number {\\n        const current=Date.now();\\n        if(!this.cache[key] || current-this.cache[key].creation>this.cache[key].duration)\\n        return -1\\n        return this.cache[key].value\\n    \\n    }\\n\\n\\tcount(): number {\\n        const current=Date.now();\\n        return Object.keys(this.cache).reduce((ac:number,key)=>{\\n          if(current-this.cache[key].creation<this.cache[key].duration)\\n          return ac+1\\n          return ac\\n        },0)\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n\\nclass TimeLimitedCache {\\n   cache: Record<number,{\\n     value:number,\\n     creation:number,\\n     duration:number,\\n }>\\n    constructor() {\\n      this.cache={}\\n    }\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        \\n    if(this.cache[key]){\\n        this.cache[key]={\\n            value,\\n            creation:Date.now(),\\n            duration\\n        }\\n        return true\\n    }\\n      this.cache[key]={\\n            value,\\n            creation:Date.now(),\\n            duration\\n        }\\n        return false   \\n       \\n       \\n    }\\n\\n    get(key: number): number {\\n        const current=Date.now();\\n        if(!this.cache[key] || current-this.cache[key].creation>this.cache[key].duration)\\n        return -1\\n        return this.cache[key].value\\n    \\n    }\\n\\n\\tcount(): number {\\n        const current=Date.now();\\n        return Object.keys(this.cache).reduce((ac:number,key)=>{\\n          if(current-this.cache[key].creation<this.cache[key].duration)\\n          return ac+1\\n          return ac\\n        },0)\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568944,
                "title": "simple-settimeout-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(Depends on Map Size)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype MapEntry = {\\n    value: number;\\n    timer: NodeJS.Timeout;\\n}\\n\\nclass TimeLimitedCache {\\n    cache = new Map<number, MapEntry>()\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        const _cache = this.cache.get(key)\\n        if (_cache) clearTimeout(_cache.timer)\\n\\n        const timer = setTimeout(() => this.cache.delete(key), duration)\\n\\n        this.cache.set(key, {\\n            value,\\n            timer,\\n        })\\n        \\n        return !!_cache;\\n    }\\n\\n    get(key: number): number {\\n        const value = this.cache.get(key)?.value\\n        return this.cache.has(key) ? this.cache.get(key).value : -1\\n    }\\n\\n\\tcount(): number {\\n        return this.cache.size\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype MapEntry = {\\n    value: number;\\n    timer: NodeJS.Timeout;\\n}\\n\\nclass TimeLimitedCache {\\n    cache = new Map<number, MapEntry>()\\n\\n    set(key: number, value: number, duration: number): boolean {\\n        const _cache = this.cache.get(key)\\n        if (_cache) clearTimeout(_cache.timer)\\n\\n        const timer = setTimeout(() => this.cache.delete(key), duration)\\n\\n        this.cache.set(key, {\\n            value,\\n            timer,\\n        })\\n        \\n        return !!_cache;\\n    }\\n\\n    get(key: number): number {\\n        const value = this.cache.get(key)?.value\\n        return this.cache.has(key) ? this.cache.get(key).value : -1\\n    }\\n\\n\\tcount(): number {\\n        return this.cache.size\\n    }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565701,
                "title": "simple-solution",
                "content": "# General Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly, we create an object since it is easier to group the value and the timer until expiration.\\nThen we can access each of those objects through their corresponding key and update their value and reset the corresponding timer if needed.\\n\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.cache = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let keyExists = false;\\n\\n    if (this.cache[key]) {\\n        clearTimeout(this.cache[key].timer) \\n        keyExists = true;\\n    };\\n\\n    this.cache[key] = {\\n        value,\\n        timer: setTimeout(() => {\\n            delete this.cache[key];\\n        }, duration)\\n    };\\n\\n    return keyExists;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (this.cache[key]) {\\n        return this.cache[key].value;\\n    } else {\\n        return -1;\\n    }\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.cache).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cache = {};\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let keyExists = false;\\n\\n    if (this.cache[key]) {\\n        clearTimeout(this.cache[key].timer) \\n        keyExists = true;\\n    };\\n\\n    this.cache[key] = {\\n        value,\\n        timer: setTimeout(() => {\\n            delete this.cache[key];\\n        }, duration)\\n    };\\n\\n    return keyExists;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    if (this.cache[key]) {\\n        return this.cache[key].value;\\n    } else {\\n        return -1;\\n    }\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.keys(this.cache).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3563680,
                "title": "ts-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TimeLimitedCache {\\n  _obj: { [key: number]: { val: number; timeoutId: NodeJS.Timeout } };\\n  _count: number;\\n\\n  constructor() {\\n    this._obj = {};\\n    this._count = 0;\\n  }\\n\\n  set(key: number, value: number, duration: number): boolean {\\n    const exists = this._obj[key];\\n    if (exists) {\\n      clearTimeout(this._obj[key].timeoutId);\\n    }\\n\\n    const id = setTimeout(() => {\\n      delete this._obj[key];\\n      this._count--;\\n    }, duration);\\n    this._obj[key] = { val: value, timeoutId: id };\\n    if (!exists) this._count++;\\n\\n    return !!exists;\\n  }\\n\\n  get(key: number): number {\\n    return this._obj[key]?.val || -1;\\n  }\\n\\n  count(): number {\\n    return this._count;\\n  }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass TimeLimitedCache {\\n  _obj: { [key: number]: { val: number; timeoutId: NodeJS.Timeout } };\\n  _count: number;\\n\\n  constructor() {\\n    this._obj = {};\\n    this._count = 0;\\n  }\\n\\n  set(key: number, value: number, duration: number): boolean {\\n    const exists = this._obj[key];\\n    if (exists) {\\n      clearTimeout(this._obj[key].timeoutId);\\n    }\\n\\n    const id = setTimeout(() => {\\n      delete this._obj[key];\\n      this._count--;\\n    }, duration);\\n    this._obj[key] = { val: value, timeoutId: id };\\n    if (!exists) this._count++;\\n\\n    return !!exists;\\n  }\\n\\n  get(key: number): number {\\n    return this._obj[key]?.val || -1;\\n  }\\n\\n  count(): number {\\n    return this._count;\\n  }\\n}\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561984,
                "title": "approach-with-using-javascript-map",
                "content": "# Approach\\nThis approach using two separate Maps for `cache` and `cacheTimers` for better clarity.\\n\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n  this.cache = new Map()\\n  this.cacheTimers = new Map()\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n  let has = false\\n  \\n  if (this.cache.has(key)) {\\n    has = true\\n    clearTimeout(this.cacheTimers.get(key))\\n  }\\n  \\n  this.cache.set(key, value)\\n  \\n  this.cacheTimers.set(key, setTimeout(() => {\\n    this.cache.delete(key)\\n  }, duration))\\n  \\n  return has\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n  return this.cache.get(key) || -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n  return this.cache.size\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n  this.cache = new Map()\\n  this.cacheTimers = new Map()\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n  let has = false\\n  \\n  if (this.cache.has(key)) {\\n    has = true\\n    clearTimeout(this.cacheTimers.get(key))\\n  }\\n  \\n  this.cache.set(key, value)\\n  \\n  this.cacheTimers.set(key, setTimeout(() => {\\n    this.cache.delete(key)\\n  }, duration))\\n  \\n  return has\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n  return this.cache.get(key) || -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n  return this.cache.size\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3561582,
                "title": "very-simple-solution-with-javascript-prototype-50ms-95-46",
                "content": "# Intuition\\n- Imagine each object is a prototype of class.\\n```\\nfunction classA () {}\\n\\nclassA.prototype.set = function(name) {\\n    this.name = name;\\n}\\n\\nExecution:\\nconst obj = new classA();\\nobj.set(\\'pro1\\');\\nobj.set(\\'pro2\\');\\n\\nconsole.log(obj);\\n\\n<!-- {pro1: \\'pro1\\', pro2: \\'pro2\\'} -->\\n```\\n\\n- To control the order, use \"setTimeout\" to handle it.\\n```\\nsetTimeout(() => {\\n    ...\\n}, duration)\\n```\\n# Approach\\n1. Create `unExpired` to handle caches running.\\n2. In ***set*** method:\\n    - Create `setTimeout`\\n    ```\\n        let idTimeout = setTimeout(() => {\\n            this.unExpired--;\\n            clearTimeout(idTimeout);\\n            this[key] = null;\\n        }, duration)\\n\\n    ```\\n    - Manage **id** of setTimeout in each object.\\n    ```\\n        this[key] = {\\n            ...,\\n            idTimeout\\n        }\\n    ```\\n    - clearTimeout when have same un_expired key already exists. Especilly, `unExpired` have to Increment **1** if not same un_expired key.\\n3. In ***get*** method, simplify get value of current key or -1 otherwise.\\n4. In ***count*** method, return value of `unExpired`\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n  this.unExpired = 0;\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let isExitsKey = !!this[key]\\n\\n    if(isExitsKey) {\\n      clearTimeout(this[key].idTimeout);\\n    } else {\\n      this.unExpired++;\\n    }\\n\\n    let idTimeout = setTimeout(() => {\\n      this.unExpired--;\\n      clearTimeout(idTimeout);\\n      this[key] = null;\\n    }, duration)\\n\\n    this[key] = {\\n      value,\\n      duration,\\n      idTimeout\\n    }\\n\\n    return isExitsKey ? true : false;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    const time = this[key];\\n    if(time) {\\n      return time.value;\\n    }\\n    return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.unExpired;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction classA () {}\\n\\nclassA.prototype.set = function(name) {\\n    this.name = name;\\n}\\n\\nExecution:\\nconst obj = new classA();\\nobj.set(\\'pro1\\');\\nobj.set(\\'pro2\\');\\n\\nconsole.log(obj);\\n\\n<!-- {pro1: \\'pro1\\', pro2: \\'pro2\\'} -->\\n```\n```\\nsetTimeout(() => {\\n    ...\\n}, duration)\\n```\n```\\n        let idTimeout = setTimeout(() => {\\n            this.unExpired--;\\n            clearTimeout(idTimeout);\\n            this[key] = null;\\n        }, duration)\\n\\n    ```\n```\\n        this[key] = {\\n            ...,\\n            idTimeout\\n        }\\n    ```\n```\\nvar TimeLimitedCache = function() {\\n  this.unExpired = 0;\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let isExitsKey = !!this[key]\\n\\n    if(isExitsKey) {\\n      clearTimeout(this[key].idTimeout);\\n    } else {\\n      this.unExpired++;\\n    }\\n\\n    let idTimeout = setTimeout(() => {\\n      this.unExpired--;\\n      clearTimeout(idTimeout);\\n      this[key] = null;\\n    }, duration)\\n\\n    this[key] = {\\n      value,\\n      duration,\\n      idTimeout\\n    }\\n\\n    return isExitsKey ? true : false;\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    const time = this[key];\\n    if(time) {\\n      return time.value;\\n    }\\n    return -1;\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.unExpired;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560191,
                "title": "solution-with-date-now",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.keysCache = {}\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const keyCache = this.keysCache[key]\\n    const result = !!(keyCache && keyCache.expiredAt > Date.now())\\n\\n    const expiredAt = Date.now() + duration\\n    this.keysCache[key] = { value, expiredAt }\\n\\n    return result\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    const keyCache = this.keysCache[key]\\n    return (keyCache && keyCache.expiredAt > Date.now()) ? keyCache.value : -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.values(this.keysCache).filter(key => key.expiredAt > Date.now()).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.keysCache = {}\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const keyCache = this.keysCache[key]\\n    const result = !!(keyCache && keyCache.expiredAt > Date.now())\\n\\n    const expiredAt = Date.now() + duration\\n    this.keysCache[key] = { value, expiredAt }\\n\\n    return result\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    const keyCache = this.keysCache[key]\\n    return (keyCache && keyCache.expiredAt > Date.now()) ? keyCache.value : -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return Object.values(this.keysCache).filter(key => key.expiredAt > Date.now()).length;\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3559161,
                "title": "js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this._count = 0\\n    this.map = new Map()\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const val = this.map.get(key)\\n    const isExist = Boolean(val && typeof val.value === \\'number\\')\\n    if (isExist) clearTimeout(val.timer)\\n    const timer = setTimeout(() => {\\n        this.map.delete(key)\\n        this._count--\\n    }, duration)\\n    this.map.set(key, { value, timer })\\n    if (!isExist) this._count++\\n    return isExist\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    const v = this.map.get(key)\\n    return (v && v.value) || -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this._count\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this._count = 0\\n    this.map = new Map()\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    const val = this.map.get(key)\\n    const isExist = Boolean(val && typeof val.value === \\'number\\')\\n    if (isExist) clearTimeout(val.timer)\\n    const timer = setTimeout(() => {\\n        this.map.delete(key)\\n        this._count--\\n    }, duration)\\n    this.map.set(key, { value, timer })\\n    if (!isExist) this._count++\\n    return isExist\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    const v = this.map.get(key)\\n    return (v && v.value) || -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this._count\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3556154,
                "title": "javascript-lazy-cache-ttl-approach-without-settimeout-beats-95",
                "content": "# Code\\n```\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let resp = false \\n    if (key in this.cache) {\\n        resp = true\\n    }\\n    this.cache[key] = [value, Date.now() + duration]\\n    return resp \\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    let content = this.cache[key] || []\\n    let value = content[0]\\n    let time = content[1]\\n    if (value === undefined) {\\n        return -1\\n    }\\n    if (time < Date.now()) {\\n        delete this.cache[key]\\n        return -1\\n    }\\n    return value\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let count = 0 \\n    for (const key in this.cache)  {\\n        let content = this.cache[key] || []\\n        let time = content[1]\\n        if (time < Date.now()) {\\n            delete this.cache[key]\\n        } else {\\n            count += 1\\n        }\\n    }\\n    return count\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TimeLimitedCache = function() {\\n    this.cache = new Map();\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    let resp = false \\n    if (key in this.cache) {\\n        resp = true\\n    }\\n    this.cache[key] = [value, Date.now() + duration]\\n    return resp \\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    let content = this.cache[key] || []\\n    let value = content[0]\\n    let time = content[1]\\n    if (value === undefined) {\\n        return -1\\n    }\\n    if (time < Date.now()) {\\n        delete this.cache[key]\\n        return -1\\n    }\\n    return value\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    let count = 0 \\n    for (const key in this.cache)  {\\n        let content = this.cache[key] || []\\n        let time = content[1]\\n        if (time < Date.now()) {\\n            delete this.cache[key]\\n        } else {\\n            count += 1\\n        }\\n    }\\n    return count\\n};\\n\\n/**\\n * Your TimeLimitedCache object will be instantiated and called as such:\\n * var obj = new TimeLimitedCache()\\n * obj.set(1, 42, 1000); // false\\n * obj.get(1) // 42\\n * obj.count() // 1\\n */\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1860969,
                "content": [
                    {
                        "username": "lan32",
                        "content": "I think the getters and setters should take a time argument, since  how time that has elapsed between code execution isn\\'t explicitly mentioned in the problem."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "No, you don\\'t need to pass a time argument to the getter. The setter gets an argument `duration` that provides how long a key should be stored for. You should create a ref with setTimeout that deletes the key from your cache after the duration has elapsed. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Finesse](/Finesse) sorry, I meant `new Date().getTime()` actually, thanks for the correction"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@cartesPerforees](/cartesPerforees) Correction: `Date.now()`\n\n`setTimeout` also works. Both are mocked by the test runner."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You can use Date.getTime() to get the current time in milliseconds. That would make time arguments redundant"
                    },
                    {
                        "username": "Narkaa",
                        "content": "If I don't know anything about javascript very well, should I study from scratch to solve this problem ?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "If you are doing the 30 days of js track don\\'t skip the easy questions because they slowly build you up to answer this one. It can be boring reading stuff you already know but the editorials on this track have some hidden gems - things I didn\\'t know even though I have been using js professionally for 6 years"
                    },
                    {
                        "username": "arunrits15",
                        "content": " atleast you should have basic understandings of javascript."
                    },
                    {
                        "username": "soupracer",
                        "content": "[@cartesPerforees](/cartesPerforees) `var TimeLimitedCache = function() {...}` is probably very confusing to 1st timers (in the context of prototype and methods), definitely recommend reading up on JS objects and how JS functions work at a low level."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Saurabh_Sen](/Saurabh_Sen) all the prototype stuff has been taken care of for us. The most he's gonna need in terms of OOP concepts is the use of `this`.\nThe focus is definitely more on async functions and callbacks"
                    },
                    {
                        "username": "juleshwar",
                        "content": "I'd recommend reading up on the fundamentals ([javascript.info](javascript.info) is a good place to start) and going for Easy questions first"
                    },
                    {
                        "username": "Saurabh_Sen",
                        "content": "yes bro, this problem needs your Object oriented programming concepts and prototype concept"
                    },
                    {
                        "username": "vkavek",
                        "content": "Hint - Can be done using Map."
                    },
                    {
                        "username": "ziadhosaaam",
                        "content": "whats the problem in my code, I see the duration input every get() doesn\\'t change so my code should be good:\\n\\n ```\\n\\nvar TimeLimitedCache = function() {\\n    this.cache = {}\\n    this.cache.count = 0\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    if(!this.cache.hasOwnProperty(key)){\\n        this.cache[key] = {\\n            value,\\n            expired: false\\n        }\\n        setTimeout(()=>{\\n            this.cache[key].expired = true\\n            this.cache.count -= 1\\n        }, duration)\\n        this.cache.count += 1\\n        return false\\n    }\\n    else if(this.cache.hasOwnProperty(key) && this.cache[key].expired){\\n        delete this.cache[key]\\n        this.cache.count -= 1\\n    }\\n    else if(this.cache.hasOwnProperty(key) && !this.cache[key].expired){\\n        this.cache[key].value = value\\n        this.cache[key].time = duration\\n        this.cache[key].expired = false\\n        setTimeout(()=>{\\n            this.cache[key].expired = true\\n            this.cache.count -= 1\\n        }, duration)\\n        return true\\n    }\\n\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    console.log(this.cache)\\n    if(this.cache.hasOwnProperty(key) && !this.cache[key].expired){\\n        return this.cache[key].value\\n    }\\n    else return -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.count\\n};\\n\\n/**\\n * const timeLimitedCache = new TimeLimitedCache()\\n * timeLimitedCache.set(1, 42, 1000); // false\\n * timeLimitedCache.get(1) // 42\\n * timeLimitedCache.count() // 1\\n */\\n```"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day14 : Done Solving Today\\'s question\\n"
                    }
                ]
            },
            {
                "id": 1897563,
                "content": [
                    {
                        "username": "lan32",
                        "content": "I think the getters and setters should take a time argument, since  how time that has elapsed between code execution isn\\'t explicitly mentioned in the problem."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "No, you don\\'t need to pass a time argument to the getter. The setter gets an argument `duration` that provides how long a key should be stored for. You should create a ref with setTimeout that deletes the key from your cache after the duration has elapsed. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Finesse](/Finesse) sorry, I meant `new Date().getTime()` actually, thanks for the correction"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@cartesPerforees](/cartesPerforees) Correction: `Date.now()`\n\n`setTimeout` also works. Both are mocked by the test runner."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You can use Date.getTime() to get the current time in milliseconds. That would make time arguments redundant"
                    },
                    {
                        "username": "Narkaa",
                        "content": "If I don't know anything about javascript very well, should I study from scratch to solve this problem ?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "If you are doing the 30 days of js track don\\'t skip the easy questions because they slowly build you up to answer this one. It can be boring reading stuff you already know but the editorials on this track have some hidden gems - things I didn\\'t know even though I have been using js professionally for 6 years"
                    },
                    {
                        "username": "arunrits15",
                        "content": " atleast you should have basic understandings of javascript."
                    },
                    {
                        "username": "soupracer",
                        "content": "[@cartesPerforees](/cartesPerforees) `var TimeLimitedCache = function() {...}` is probably very confusing to 1st timers (in the context of prototype and methods), definitely recommend reading up on JS objects and how JS functions work at a low level."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Saurabh_Sen](/Saurabh_Sen) all the prototype stuff has been taken care of for us. The most he's gonna need in terms of OOP concepts is the use of `this`.\nThe focus is definitely more on async functions and callbacks"
                    },
                    {
                        "username": "juleshwar",
                        "content": "I'd recommend reading up on the fundamentals ([javascript.info](javascript.info) is a good place to start) and going for Easy questions first"
                    },
                    {
                        "username": "Saurabh_Sen",
                        "content": "yes bro, this problem needs your Object oriented programming concepts and prototype concept"
                    },
                    {
                        "username": "vkavek",
                        "content": "Hint - Can be done using Map."
                    },
                    {
                        "username": "ziadhosaaam",
                        "content": "whats the problem in my code, I see the duration input every get() doesn\\'t change so my code should be good:\\n\\n ```\\n\\nvar TimeLimitedCache = function() {\\n    this.cache = {}\\n    this.cache.count = 0\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    if(!this.cache.hasOwnProperty(key)){\\n        this.cache[key] = {\\n            value,\\n            expired: false\\n        }\\n        setTimeout(()=>{\\n            this.cache[key].expired = true\\n            this.cache.count -= 1\\n        }, duration)\\n        this.cache.count += 1\\n        return false\\n    }\\n    else if(this.cache.hasOwnProperty(key) && this.cache[key].expired){\\n        delete this.cache[key]\\n        this.cache.count -= 1\\n    }\\n    else if(this.cache.hasOwnProperty(key) && !this.cache[key].expired){\\n        this.cache[key].value = value\\n        this.cache[key].time = duration\\n        this.cache[key].expired = false\\n        setTimeout(()=>{\\n            this.cache[key].expired = true\\n            this.cache.count -= 1\\n        }, duration)\\n        return true\\n    }\\n\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    console.log(this.cache)\\n    if(this.cache.hasOwnProperty(key) && !this.cache[key].expired){\\n        return this.cache[key].value\\n    }\\n    else return -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.count\\n};\\n\\n/**\\n * const timeLimitedCache = new TimeLimitedCache()\\n * timeLimitedCache.set(1, 42, 1000); // false\\n * timeLimitedCache.get(1) // 42\\n * timeLimitedCache.count() // 1\\n */\\n```"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day14 : Done Solving Today\\'s question\\n"
                    }
                ]
            },
            {
                "id": 2066037,
                "content": [
                    {
                        "username": "lan32",
                        "content": "I think the getters and setters should take a time argument, since  how time that has elapsed between code execution isn\\'t explicitly mentioned in the problem."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "No, you don\\'t need to pass a time argument to the getter. The setter gets an argument `duration` that provides how long a key should be stored for. You should create a ref with setTimeout that deletes the key from your cache after the duration has elapsed. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Finesse](/Finesse) sorry, I meant `new Date().getTime()` actually, thanks for the correction"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@cartesPerforees](/cartesPerforees) Correction: `Date.now()`\n\n`setTimeout` also works. Both are mocked by the test runner."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You can use Date.getTime() to get the current time in milliseconds. That would make time arguments redundant"
                    },
                    {
                        "username": "Narkaa",
                        "content": "If I don't know anything about javascript very well, should I study from scratch to solve this problem ?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "If you are doing the 30 days of js track don\\'t skip the easy questions because they slowly build you up to answer this one. It can be boring reading stuff you already know but the editorials on this track have some hidden gems - things I didn\\'t know even though I have been using js professionally for 6 years"
                    },
                    {
                        "username": "arunrits15",
                        "content": " atleast you should have basic understandings of javascript."
                    },
                    {
                        "username": "soupracer",
                        "content": "[@cartesPerforees](/cartesPerforees) `var TimeLimitedCache = function() {...}` is probably very confusing to 1st timers (in the context of prototype and methods), definitely recommend reading up on JS objects and how JS functions work at a low level."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Saurabh_Sen](/Saurabh_Sen) all the prototype stuff has been taken care of for us. The most he's gonna need in terms of OOP concepts is the use of `this`.\nThe focus is definitely more on async functions and callbacks"
                    },
                    {
                        "username": "juleshwar",
                        "content": "I'd recommend reading up on the fundamentals ([javascript.info](javascript.info) is a good place to start) and going for Easy questions first"
                    },
                    {
                        "username": "Saurabh_Sen",
                        "content": "yes bro, this problem needs your Object oriented programming concepts and prototype concept"
                    },
                    {
                        "username": "vkavek",
                        "content": "Hint - Can be done using Map."
                    },
                    {
                        "username": "ziadhosaaam",
                        "content": "whats the problem in my code, I see the duration input every get() doesn\\'t change so my code should be good:\\n\\n ```\\n\\nvar TimeLimitedCache = function() {\\n    this.cache = {}\\n    this.cache.count = 0\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    if(!this.cache.hasOwnProperty(key)){\\n        this.cache[key] = {\\n            value,\\n            expired: false\\n        }\\n        setTimeout(()=>{\\n            this.cache[key].expired = true\\n            this.cache.count -= 1\\n        }, duration)\\n        this.cache.count += 1\\n        return false\\n    }\\n    else if(this.cache.hasOwnProperty(key) && this.cache[key].expired){\\n        delete this.cache[key]\\n        this.cache.count -= 1\\n    }\\n    else if(this.cache.hasOwnProperty(key) && !this.cache[key].expired){\\n        this.cache[key].value = value\\n        this.cache[key].time = duration\\n        this.cache[key].expired = false\\n        setTimeout(()=>{\\n            this.cache[key].expired = true\\n            this.cache.count -= 1\\n        }, duration)\\n        return true\\n    }\\n\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    console.log(this.cache)\\n    if(this.cache.hasOwnProperty(key) && !this.cache[key].expired){\\n        return this.cache[key].value\\n    }\\n    else return -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.count\\n};\\n\\n/**\\n * const timeLimitedCache = new TimeLimitedCache()\\n * timeLimitedCache.set(1, 42, 1000); // false\\n * timeLimitedCache.get(1) // 42\\n * timeLimitedCache.count() // 1\\n */\\n```"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day14 : Done Solving Today\\'s question\\n"
                    }
                ]
            },
            {
                "id": 2063276,
                "content": [
                    {
                        "username": "lan32",
                        "content": "I think the getters and setters should take a time argument, since  how time that has elapsed between code execution isn\\'t explicitly mentioned in the problem."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "No, you don\\'t need to pass a time argument to the getter. The setter gets an argument `duration` that provides how long a key should be stored for. You should create a ref with setTimeout that deletes the key from your cache after the duration has elapsed. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Finesse](/Finesse) sorry, I meant `new Date().getTime()` actually, thanks for the correction"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@cartesPerforees](/cartesPerforees) Correction: `Date.now()`\n\n`setTimeout` also works. Both are mocked by the test runner."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You can use Date.getTime() to get the current time in milliseconds. That would make time arguments redundant"
                    },
                    {
                        "username": "Narkaa",
                        "content": "If I don't know anything about javascript very well, should I study from scratch to solve this problem ?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "If you are doing the 30 days of js track don\\'t skip the easy questions because they slowly build you up to answer this one. It can be boring reading stuff you already know but the editorials on this track have some hidden gems - things I didn\\'t know even though I have been using js professionally for 6 years"
                    },
                    {
                        "username": "arunrits15",
                        "content": " atleast you should have basic understandings of javascript."
                    },
                    {
                        "username": "soupracer",
                        "content": "[@cartesPerforees](/cartesPerforees) `var TimeLimitedCache = function() {...}` is probably very confusing to 1st timers (in the context of prototype and methods), definitely recommend reading up on JS objects and how JS functions work at a low level."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Saurabh_Sen](/Saurabh_Sen) all the prototype stuff has been taken care of for us. The most he's gonna need in terms of OOP concepts is the use of `this`.\nThe focus is definitely more on async functions and callbacks"
                    },
                    {
                        "username": "juleshwar",
                        "content": "I'd recommend reading up on the fundamentals ([javascript.info](javascript.info) is a good place to start) and going for Easy questions first"
                    },
                    {
                        "username": "Saurabh_Sen",
                        "content": "yes bro, this problem needs your Object oriented programming concepts and prototype concept"
                    },
                    {
                        "username": "vkavek",
                        "content": "Hint - Can be done using Map."
                    },
                    {
                        "username": "ziadhosaaam",
                        "content": "whats the problem in my code, I see the duration input every get() doesn\\'t change so my code should be good:\\n\\n ```\\n\\nvar TimeLimitedCache = function() {\\n    this.cache = {}\\n    this.cache.count = 0\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    if(!this.cache.hasOwnProperty(key)){\\n        this.cache[key] = {\\n            value,\\n            expired: false\\n        }\\n        setTimeout(()=>{\\n            this.cache[key].expired = true\\n            this.cache.count -= 1\\n        }, duration)\\n        this.cache.count += 1\\n        return false\\n    }\\n    else if(this.cache.hasOwnProperty(key) && this.cache[key].expired){\\n        delete this.cache[key]\\n        this.cache.count -= 1\\n    }\\n    else if(this.cache.hasOwnProperty(key) && !this.cache[key].expired){\\n        this.cache[key].value = value\\n        this.cache[key].time = duration\\n        this.cache[key].expired = false\\n        setTimeout(()=>{\\n            this.cache[key].expired = true\\n            this.cache.count -= 1\\n        }, duration)\\n        return true\\n    }\\n\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    console.log(this.cache)\\n    if(this.cache.hasOwnProperty(key) && !this.cache[key].expired){\\n        return this.cache[key].value\\n    }\\n    else return -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.count\\n};\\n\\n/**\\n * const timeLimitedCache = new TimeLimitedCache()\\n * timeLimitedCache.set(1, 42, 1000); // false\\n * timeLimitedCache.get(1) // 42\\n * timeLimitedCache.count() // 1\\n */\\n```"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day14 : Done Solving Today\\'s question\\n"
                    }
                ]
            },
            {
                "id": 1898183,
                "content": [
                    {
                        "username": "lan32",
                        "content": "I think the getters and setters should take a time argument, since  how time that has elapsed between code execution isn\\'t explicitly mentioned in the problem."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "No, you don\\'t need to pass a time argument to the getter. The setter gets an argument `duration` that provides how long a key should be stored for. You should create a ref with setTimeout that deletes the key from your cache after the duration has elapsed. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Finesse](/Finesse) sorry, I meant `new Date().getTime()` actually, thanks for the correction"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@cartesPerforees](/cartesPerforees) Correction: `Date.now()`\n\n`setTimeout` also works. Both are mocked by the test runner."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "You can use Date.getTime() to get the current time in milliseconds. That would make time arguments redundant"
                    },
                    {
                        "username": "Narkaa",
                        "content": "If I don't know anything about javascript very well, should I study from scratch to solve this problem ?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "If you are doing the 30 days of js track don\\'t skip the easy questions because they slowly build you up to answer this one. It can be boring reading stuff you already know but the editorials on this track have some hidden gems - things I didn\\'t know even though I have been using js professionally for 6 years"
                    },
                    {
                        "username": "arunrits15",
                        "content": " atleast you should have basic understandings of javascript."
                    },
                    {
                        "username": "soupracer",
                        "content": "[@cartesPerforees](/cartesPerforees) `var TimeLimitedCache = function() {...}` is probably very confusing to 1st timers (in the context of prototype and methods), definitely recommend reading up on JS objects and how JS functions work at a low level."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@Saurabh_Sen](/Saurabh_Sen) all the prototype stuff has been taken care of for us. The most he's gonna need in terms of OOP concepts is the use of `this`.\nThe focus is definitely more on async functions and callbacks"
                    },
                    {
                        "username": "juleshwar",
                        "content": "I'd recommend reading up on the fundamentals ([javascript.info](javascript.info) is a good place to start) and going for Easy questions first"
                    },
                    {
                        "username": "Saurabh_Sen",
                        "content": "yes bro, this problem needs your Object oriented programming concepts and prototype concept"
                    },
                    {
                        "username": "vkavek",
                        "content": "Hint - Can be done using Map."
                    },
                    {
                        "username": "ziadhosaaam",
                        "content": "whats the problem in my code, I see the duration input every get() doesn\\'t change so my code should be good:\\n\\n ```\\n\\nvar TimeLimitedCache = function() {\\n    this.cache = {}\\n    this.cache.count = 0\\n};\\n\\n/** \\n * @param {number} key\\n * @param {number} value\\n * @param {number} duration time until expiration in ms\\n * @return {boolean} if un-expired key already existed\\n */\\nTimeLimitedCache.prototype.set = function(key, value, duration) {\\n    if(!this.cache.hasOwnProperty(key)){\\n        this.cache[key] = {\\n            value,\\n            expired: false\\n        }\\n        setTimeout(()=>{\\n            this.cache[key].expired = true\\n            this.cache.count -= 1\\n        }, duration)\\n        this.cache.count += 1\\n        return false\\n    }\\n    else if(this.cache.hasOwnProperty(key) && this.cache[key].expired){\\n        delete this.cache[key]\\n        this.cache.count -= 1\\n    }\\n    else if(this.cache.hasOwnProperty(key) && !this.cache[key].expired){\\n        this.cache[key].value = value\\n        this.cache[key].time = duration\\n        this.cache[key].expired = false\\n        setTimeout(()=>{\\n            this.cache[key].expired = true\\n            this.cache.count -= 1\\n        }, duration)\\n        return true\\n    }\\n\\n};\\n\\n/** \\n * @param {number} key\\n * @return {number} value associated with key\\n */\\nTimeLimitedCache.prototype.get = function(key) {\\n    console.log(this.cache)\\n    if(this.cache.hasOwnProperty(key) && !this.cache[key].expired){\\n        return this.cache[key].value\\n    }\\n    else return -1\\n};\\n\\n/** \\n * @return {number} count of non-expired keys\\n */\\nTimeLimitedCache.prototype.count = function() {\\n    return this.cache.count\\n};\\n\\n/**\\n * const timeLimitedCache = new TimeLimitedCache()\\n * timeLimitedCache.set(1, 42, 1000); // false\\n * timeLimitedCache.get(1) // 42\\n * timeLimitedCache.count() // 1\\n */\\n```"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day14 : Done Solving Today\\'s question\\n"
                    }
                ]
            }
        ]
    }
]